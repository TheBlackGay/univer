import {
  EnUs
} from "./chunk-OJWCZZ56.js";
import {
  Button,
  CSSMotionList_default,
  Checkbox,
  ColorPicker,
  ConfigContext,
  ConfigProvider,
  Confirm,
  Dialog,
  Dropdown,
  DropdownMenu,
  InputNumber,
  KeyCode_default,
  Menu,
  MenuItem,
  MenuItemGroup,
  Messager,
  Popup,
  Select,
  Separator,
  SubMenu,
  Tooltip,
  _arrayLikeToArray,
  _defineProperty,
  _extends,
  _objectSpread2,
  _objectWithoutProperties,
  _slicedToArray,
  _typeof,
  _unsupportedIterableToArray,
  add_digits_single_default,
  adjust_height_default,
  adjust_width_default,
  align_bottom_single_default,
  align_text_both_single_default,
  align_top_single_default,
  all_border_single_default,
  amplify_single_default,
  auto_height_default,
  auto_width_default,
  autowrap_single_default,
  avg_single_default,
  back_slash_single_default,
  bold_single_default,
  brush_single_default,
  cancel_freeze_single_default,
  cancel_merge_single_default,
  check_mark_single_default,
  clear_format_default,
  close_single_default,
  clsx,
  cnt_single_default,
  code_single_default,
  conditions_default,
  content_single_16_default,
  copy_default,
  default_module_default,
  delete_cell_move_down_default,
  delete_cell_shift_left_default,
  delete_cell_shift_right_default,
  delete_cell_shift_up_default,
  delete_column_default,
  delete_row_default,
  direct_export_single_default,
  dollar_single_default,
  down_border_default,
  error_single_default,
  euro_single_default,
  export_single_default,
  floor,
  folder_single_default,
  font_color_default,
  font_size_increase_single_default,
  font_size_reduce_single_single_default,
  freeze_column_single_default,
  freeze_row_single_default,
  freeze_to_selected_single_default,
  function_single_default,
  getDocumentElement,
  getOverflowAncestors,
  grid_single_default,
  header_footer_single_default,
  hide_default,
  horizontal_border_default,
  horizontal_merge_single_default,
  horizontally_single_default,
  increase_single_default,
  inner_border_default,
  insert_cell_down_default,
  insert_cell_shift_right_default,
  insert_default,
  insert_row_above_default,
  insert_row_below_default,
  isBrowser,
  italic_single_default,
  keyboard_single_default,
  left_border_default,
  left_double_diagonal_single_default,
  left_insert_column_default,
  left_justifying_single_default,
  left_rotation_forty_five_degrees_single_default,
  left_rotation_ninety_degrees_single_default,
  left_tridiagonal_single_default,
  max,
  max_single_default,
  menu_single_24_default,
  merge_all_single_default,
  message,
  min,
  min_single_default,
  more_down_single_default,
  more_function_single_default,
  more_single_default,
  no_border_single_default,
  no_color_default,
  no_rotation_single_default,
  order_single_default,
  outer_border_default,
  overflow_single_default,
  paint_bucket_default,
  paste_special_default,
  percent_single_default,
  pickAttrs,
  piping_single_default,
  redo_single_default,
  reduce_default,
  reduce_digits_single_default,
  reduce_single_default,
  removeMessage,
  render,
  require_classnames,
  require_jsx_runtime,
  require_react,
  require_react_dom,
  resizeObserverCtor,
  right_border_default,
  right_double_diagonal_single_default,
  right_insert_column_default,
  right_justifying_single_default,
  right_rotation_forty_five_degrees_single_default,
  right_rotation_ninety_degrees_single_default,
  rmb_single_default,
  rouble_single_default,
  slash_single_default,
  strikethrough_single_default,
  subscript_single_default,
  success_single_default,
  sum_single_default,
  superscript_single_default,
  themeInstance,
  todo_list_default,
  truncation_single_default,
  underline_single_default,
  undo_single_default,
  unmount,
  unorder_single_default,
  up_border_default,
  vertical_border_default,
  vertical_center_single_default,
  vertical_integration_single_default,
  vertical_text_single_default,
  warning_single_default
} from "./chunk-22LKBS37.js";
import {
  BehaviorSubject,
  BuildTextUtils,
  COLORS,
  ColorKit,
  DEFAULT_EMPTY_DOCUMENT_VALUE,
  DEFAULT_STYLES,
  DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
  DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
  DOCS_ZEN_EDITOR_UNIT_ID_KEY,
  DependentOn,
  Disposable,
  DisposableCollection,
  DocumentDataModel,
  EDITOR_ACTIVATED,
  ErrorService,
  EventSubject,
  FOCUSING_COMMON_DRAWINGS,
  FOCUSING_DOC,
  FOCUSING_EDITOR_STANDALONE,
  FOCUSING_FX_BAR_EDITOR,
  FOCUSING_UNIVER_EDITOR,
  ICommandService,
  IConfigService,
  IContextService,
  IImageIoService,
  ILocalStorageService,
  ILogService,
  IUndoRedoService,
  IUniverInstanceService,
  Inject,
  Injector,
  JSONX,
  LRUMap,
  LifecycleService,
  LocaleService,
  MOVE_BUFFER_VALUE,
  MemoryCursor,
  O,
  ObjectMatrix,
  Observable,
  Optional,
  PRESET_LIST_TYPE,
  Plugin,
  QuickListTypeMap,
  Range,
  Rectangle,
  RediError,
  RedoCommand,
  RedoCommandId,
  Registry,
  ReplaySubject,
  RxDisposable,
  SHEET_EDITOR_UNITS,
  SheetSkeleton,
  Skeleton,
  SlideDataModel,
  Subject,
  Subscription,
  TextX,
  ThemeService,
  Tools,
  UndoCommand,
  UndoCommandId,
  Workbook,
  addLinkToDocumentModel,
  animationFrameScheduler,
  bufferTime,
  checkForSubstrings,
  checkParagraphHasIndentByStyle,
  combineLatest,
  composeInterceptors,
  composeStyles,
  createIdentifier,
  createInterceptorKey,
  createInternalEditorID,
  debounceTime,
  debounce_default,
  deleteContent,
  distinctUntilChanged,
  extractPureTextFromCell,
  filter,
  first,
  fromEvent,
  fromEventSubject,
  generateRandomId,
  getBodySlice,
  getBorderStyleType,
  getColorStyle,
  getPlainText,
  horizontalLineSegmentsSubtraction,
  insertTextToContent,
  isClassDependencyItem,
  isInternalEditorID,
  isNullCell,
  isObservable,
  isRealNum,
  isWhiteColor,
  map,
  merge,
  mergeOverrideWithDependencies,
  mergeWith_default,
  merge_default,
  normalizeBody,
  numberToABC,
  numberToListABC,
  of,
  registerDependencies,
  remove,
  requestImmediateMacroTask,
  require_dist,
  searchArray,
  sequenceExecuteAsync,
  shareReplay,
  skipParseTagNames,
  sortRules,
  sortRulesByDesc,
  sortRulesFactory,
  startWith,
  switchMap,
  take,
  takeUntil,
  throttleTime,
  toDisposable,
  touchDependencies
} from "./chunk-33NDYU5R.js";
import {
  __commonJS,
  __decorateClass,
  __decorateParam,
  __export,
  __glob,
  __privateAdd,
  __publicField,
  __require,
  __toESM
} from "./chunk-NSSCU2QI.js";

// (disabled):fs
var require_fs = __commonJS({
  "(disabled):fs"() {
  }
});

// ../node_modules/.pnpm/localforage@1.10.0/node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "../node_modules/.pnpm/localforage@1.10.0/node_modules/localforage/dist/localforage.js"(exports2, module) {
    (function(f) {
      if (typeof exports2 === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.localforage = f();
      }
    })(function() {
      var define2, module2, exports3;
      return function e(t2, n, r) {
        function s(o2, u) {
          if (!n[o2]) {
            if (!t2[o2]) {
              var a = typeof __require == "function" && __require;
              if (!u && a) return a(o2, true);
              if (i) return i(o2, true);
              var f = new Error("Cannot find module '" + o2 + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o2] = { exports: {} };
            t2[o2][0].call(l.exports, function(e2) {
              var n2 = t2[o2][1][e2];
              return s(n2 ? n2 : e2);
            }, l, l.exports, e, t2, n, r);
          }
          return n[o2].exports;
        }
        var i = typeof __require == "function" && __require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
      }({ 1: [function(_dereq_, module3, exports4) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i = -1;
              while (++i < len) {
                oldQueue[i]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module3.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module3, exports4) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module3.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap3(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap3(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap3(this.promise, this.onRejected, value);
        };
        function unwrap3(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e) {
              return handlers.reject(promise, e);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i = -1;
            var len = self2.queue.length;
            while (++i < len) {
              self2.queue[i].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e) {
            out.status = "error";
            out.value = e;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all2;
        function all2(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            allResolver(iterable[i], i);
          }
          return promise;
          function allResolver(value, i2) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i2] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i = -1;
          var promise = new this(INTERNAL);
          while (++i < len) {
            resolver(iterable[i]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module3, exports4) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module3, exports4) {
        "use strict";
        var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e) {
            if (e.name !== "TypeError") {
              throw e;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder = new Builder();
            for (var i = 0; i < parts.length; i += 1) {
              builder.append(parts[i]);
            }
            return builder.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length2 = bin.length;
          var buf = new ArrayBuffer(length2);
          var arr = new Uint8Array(buf);
          for (var i = 0; i < length2; i++) {
            arr[i] = bin.charCodeAt(i);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e) {
              e.preventDefault();
              e.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e) {
              e.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e) {
                e.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e) {
              var base64 = btoa(e.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base64,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i = 0; i < forages.length; i++) {
            var forage = forages[i];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j = 0; j < dbContext.forages.length; j++) {
            var forage = dbContext.forages[j];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k = 0; k < forages.length; k++) {
              var forage2 = forages[k];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e) {
                  reject(e);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i = 0; i < forages.length; i++) {
                forages[i]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i2 = 0; i2 < forages.length; i2++) {
                    var _forage = forages[i2];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i = 0; i < forages.length; i++) {
                  var forage = forages[i];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j = 0; j < forages.length; j++) {
                    var _forage2 = forages[j];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$1 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i;
          var p = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
            bytes[p++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i;
          for (i = 0; i < bytes.length; i += 3) {
            base64String += BASE_CHARS[bytes[i] >> 2];
            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64String += BASE_CHARS[bytes[i + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$1.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type2) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type2);
          }
        }
        var localforageSerializer = {
          serialize,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t2, dbInfo, callback, errorCallback) {
          t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i in options) {
              dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e) {
              return reject(e);
            }
            dbInfo.db.transaction(function(t2) {
              createDbTable(t2, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t3, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
          t2.executeSql(sqlStatement, args, callback, function(t3, error) {
            if (error.code === error.SYNTAX_ERR) {
              t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
                if (!results.rows.length) {
                  createDbTable(t4, dbInfo, function() {
                    t4.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t4, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t3, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                  var rows = results.rows;
                  var length2 = rows.length;
                  for (var i = 0; i < length2; i++) {
                    var item = rows.item(i);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t2) {
                    tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t3, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t3, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t2) {
                tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                  var keys2 = [];
                  for (var i = 0; i < results.rows.length; i++) {
                    keys2.push(results.rows.item(i).key);
                  }
                  resolve(keys2);
                }, function(t3, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t2) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
                var storeNames = [];
                for (var i = 0; i < results.rows.length; i++) {
                  storeNames.push(results.rows.item(i).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t3, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t2) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t3, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                    operations.push(dropTable(operationInfo.storeNames[i]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e) {
                    reject(e);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i in options) {
              dbInfo[i] = options[i];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length2 = localStorage.length;
            var iterationNumber = 1;
            for (var i = 0; i < length2; i++) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length2 = localStorage.length;
            var keys2 = [];
            for (var i = 0; i < length2; i++) {
              var itemKey = localStorage.key(i);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e) {
                    if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e);
                    }
                    reject(e);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i = localStorage.length - 1; i >= 0; i--) {
                var key2 = localStorage.key(i);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x, y) {
          return x === y || typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i = 0;
          while (i < len) {
            if (sameValue(array[i], searchElement)) {
              return true;
            }
            i++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i = 1; i < arguments.length; i++) {
            var arg = arguments[i];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof2(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i in options) {
                if (i === "storeName") {
                  options[i] = options[i].replace(/\W/g, "_");
                }
                if (i === "version" && typeof options[i] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i] = options[i];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i = 0, len = driverMethods.length; i < len; i++) {
                  var driverMethodName = driverMethods[i];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e) {
                reject(e);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i = 0, len = drivers.length; i < len; i++) {
              var driverName = drivers[i];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i = 0, len = LibraryMethods.length; i < len; i++) {
              callWhenReady(this, LibraryMethods[i]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module3.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// ../packages/engine-render/src/controllers/config.schema.ts
var ENGINE_RENDER_PLUGIN_CONFIG_KEY = "engine-render.config";
var configSymbol = Symbol(ENGINE_RENDER_PLUGIN_CONFIG_KEY);
var defaultPluginConfig = {};

// ../packages/engine-render/src/basics/const.ts
var MIDDLE_CELL_POS_MAGIC_NUMBER = 1;
var DEFAULT_FONTFACE_PLANE = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
var DEFAULT_SKELETON_HEADER_FOOTER = {
  lines: [],
  drawings: /* @__PURE__ */ new Map(),
  height: 0,
  st: 0,
  ed: 0,
  marginLeft: 0
};
var DEFAULT_SKELETON_HEADER = {
  ...DEFAULT_SKELETON_HEADER_FOOTER,
  marginTop: 20
};
var DEFAULT_SKELETON_FOOTER = {
  ...DEFAULT_SKELETON_HEADER_FOOTER,
  marginBottom: 20
};
var DEFAULT_OFFSET_SPACING = 1;
var DEFAULT_DOCUMENT_FONTSIZE = 14;
var COLOR_BLACK_RGB = "rgb(0,0,0)";
var MAXIMUM_ROW_HEIGHT = 2e3;
var MAXIMUM_COL_WIDTH = 2e3;
var MIN_COL_WIDTH = 2;
var FIX_ONE_PIXEL_BLUR_OFFSET = 0.5;
var DRAWING_OBJECT_LAYER_INDEX = 4;

// ../packages/engine-render/src/basics/performance-monitor.ts
var DEFAULT_FRAME_SAMPLE_SIZE = 60;
var DEFAULT_FRAME_LIST_SIZE = 60 * 60;
var DEFAULT_ONE_SEC_MS = 1e3;
var DEFAULT_FRAME_TIME = 16.67;
var PerformanceMonitor = class extends Disposable {
  // private _frameCount: number = 0; // number of all frames in whole life time.
  /**
   * @param {number} frameSampleSize The number of samples required to saturate the sliding window
   */
  constructor(frameSampleSize = DEFAULT_FRAME_SAMPLE_SIZE) {
    super();
    __publicField(this, "_enabled", true);
    __publicField(this, "_rollingFrameTime");
    __publicField(this, "_lastFrameTimeMs");
    /**
     * Counting frame in a second.
     */
    __publicField(this, "_frameCountInLastSecond", 0);
    /**
     *  The millisecond value of the last second. For counting frame in a second.
     */
    __publicField(this, "_lastSecondTimeMs");
    /**
     * The FPS values recorded in the past 1 second.
     */
    __publicField(this, "_recFPSValueLastSecond", 60);
    this._rollingFrameTime = new RollingAverage(frameSampleSize);
  }
  dispose() {
    super.dispose();
  }
  /**
   * Returns the average frame time in milliseconds of the sliding window (or the subset of frames sampled so far)
   */
  get averageFrameTime() {
    return this._rollingFrameTime.averageFrameTime;
  }
  /**
   * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
   */
  get averageFrameTimeVariance() {
    return this._rollingFrameTime.variance;
  }
  /**
   * Returns the frame time of the last recent frame.
   */
  get instantaneousFrameTime() {
    return this._rollingFrameTime.history(0);
  }
  /**
   * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
   */
  get averageFPS() {
    return this._recFPSValueLastSecond;
  }
  /**
   * Returns the average framerate in frames per second using the most recent frame time
   */
  get instantaneousFPS() {
    const history = this._rollingFrameTime.history(0);
    if (history === 0) {
      return 0;
    }
    return DEFAULT_ONE_SEC_MS / history;
  }
  /**
   * Returns true if enough samples have been taken to completely fill the sliding window
   */
  get isSaturated() {
    return this._rollingFrameTime.isSaturated();
  }
  /**
   * Returns true if sampling is enabled
   */
  get isEnabled() {
    return this._enabled;
  }
  /**
   * Samples current frame, set averageFPS instantaneousFrameTime
   * this method is called each frame by engine renderLoop  --> endFrame.
   * @param timestamp A timestamp in milliseconds of the current frame to compare with other frames
   */
  sampleFrame(timestamp = this.now()) {
    if (!this._enabled) {
      return;
    }
    this._frameCountInLastSecond++;
    if (this._lastSecondTimeMs != null) {
      const oneSecPassed = this._lastSecondTimeMs <= timestamp - DEFAULT_ONE_SEC_MS;
      if (oneSecPassed) {
        const passedTime = timestamp - this._lastSecondTimeMs;
        this._recFPSValueLastSecond = Math.round(this._frameCountInLastSecond / passedTime * DEFAULT_ONE_SEC_MS);
        this._lastSecondTimeMs = timestamp;
        this._frameCountInLastSecond = 0;
      }
    } else {
      this._lastSecondTimeMs = timestamp;
    }
    if (this._lastFrameTimeMs != null) {
      const dt = timestamp - this._lastFrameTimeMs;
      this._rollingFrameTime.addFrameTime(dt);
      this._rollingFrameTime.calcAverageFrameTime();
    }
  }
  endFrame(timestamp) {
    this.sampleFrame(timestamp);
    this._lastFrameTimeMs = timestamp;
  }
  now() {
    if (performance && performance.now) {
      return performance.now();
    }
    return Date.now();
  }
  /**
   * Enables contributions to the sliding window sample set
   */
  enable() {
    this._enabled = true;
  }
  /**
   * Disables contributions to the sliding window sample set
   * Samples will not be interpolated over the disabled period
   */
  disable() {
    this._enabled = false;
    this._lastFrameTimeMs = null;
  }
  /**
   * Resets performance monitor
   */
  reset() {
    this._lastFrameTimeMs = null;
    this._rollingFrameTime.reset();
  }
};
var RollingAverage = class {
  // sum of squares of differences from the (current) mean
  /**
   * constructor
   * @param length The number of samples required to saturate the sliding window
   */
  constructor(length) {
    /**
     * Current average
     */
    __publicField(this, "averageFrameTime", DEFAULT_FRAME_TIME);
    /**
     * Current variance
     */
    __publicField(this, "variance", 0);
    __publicField(this, "_samples", []);
    /**
     * for isStaturated
     * max value of _sampleCount is length of _samples
     */
    __publicField(this, "_sampleCount", 0);
    __publicField(this, "_pos", 0);
    __publicField(this, "_m2", 0);
    this._samples = new Array(length);
    this.reset();
  }
  /**
   * Calc average frameTime and variance.
   */
  calcAverageFrameTime() {
    const frameDuration = this.history(0);
    let delta;
    if (this.isSaturated()) {
      const bottomValue = this._samples[this._pos];
      delta = bottomValue - this.averageFrameTime;
      this._m2 -= delta * (bottomValue - this.averageFrameTime);
    } else {
      this._sampleCount++;
    }
    const min2 = Math.min(...this._samples);
    const max2 = Math.min(...this._samples);
    const filteredData = this._samples.filter((v) => v !== max2 && v !== min2);
    this.averageFrameTime = filteredData.reduce((sum, value) => sum + value, 0) / filteredData.length;
    delta = frameDuration - this.averageFrameTime;
    this._m2 += delta * (frameDuration - this.averageFrameTime);
    this.variance = this._m2 / (this._sampleCount - 1);
  }
  /**
   * Adds a sample to the sample set
   * @param frameTime The sample value
   */
  addFrameTime(frameTime) {
    this._samples[this._pos] = frameTime;
    this._pos = ++this._pos % this._samples.length;
  }
  /**
   * Returns previously added values or null if outside of history or outside the sliding window domain
   * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
   * @return Value previously recorded with add() or null if outside of range
   */
  history(i) {
    if (i >= this._sampleCount || i >= this._samples.length) {
      return 0;
    }
    const i0 = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(i0 - i)];
  }
  /**
   * Returns true if enough samples have been taken to completely fill the sliding window
   * @return true if sample-set saturated
   */
  isSaturated() {
    return this._sampleCount >= this._samples.length;
  }
  /**
   * Resets the rolling average (equivalent to 0 samples taken so far)
   */
  reset() {
    this.averageFrameTime = DEFAULT_FRAME_TIME;
    this.variance = 0;
    this._sampleCount = 0;
    this._pos = 0;
    this._m2 = 0;
  }
  /**
   * Wraps a value around the sample range boundaries
   * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.
   * @return Wrapped position in sample range
   */
  _wrapPosition(i) {
    const max2 = this._samples.length;
    return (i % max2 + max2) % max2;
  }
};

// ../node_modules/.pnpm/regexp-util@2.0.0/node_modules/regexp-util/lib/base.js
var Base = class {
  isEmpty() {
    return this._isEmpty();
  }
  toString(flags) {
    if (this.isEmpty()) {
      throw new Error(`Output is empty.`);
    }
    return this._toString(flags);
  }
  toRegExp(flags) {
    return new RegExp(this.toString(flags), flags);
  }
};

// ../node_modules/.pnpm/regexp-util@2.0.0/node_modules/regexp-util/lib/charset.js
var Charset = class _Charset extends Base {
  constructor(...inputs) {
    super();
    this.data = [];
    for (const input of inputs) {
      if (input instanceof _Charset) {
        this.data.push(...input.data);
      } else {
        this.data.push(normalize(input));
      }
    }
    this._unique();
  }
  union(...inputs) {
    return new _Charset(this, ...inputs);
  }
  subtract(...inputs) {
    const currentData = this.data.slice();
    const newData = [];
    let subtractIndex = 0;
    const { data: subtractData } = new _Charset(...inputs);
    while (currentData.length !== 0) {
      const dataUnit = currentData.shift();
      const [start, end] = dataUnit;
      let isDone;
      do {
        isDone = true;
        const subtractDataUnit = subtractData[subtractIndex];
        if (subtractDataUnit === void 0) {
          newData.push(dataUnit);
          break;
        }
        const [subtractStart, subtractEnd] = subtractDataUnit;
        if (subtractEnd < start) {
          isDone = false;
          subtractIndex++;
        } else if (end < subtractStart) {
          newData.push(dataUnit);
        } else if (subtractStart <= start && subtractEnd < end) {
          subtractIndex++;
          currentData.unshift([subtractEnd + 1, end]);
        } else if (start < subtractStart && subtractEnd < end) {
          subtractIndex++;
          newData.push([start, subtractStart - 1]);
          currentData.unshift([subtractEnd + 1, end]);
        } else if (start < subtractStart && end <= subtractEnd) {
          newData.push([start, subtractStart - 1]);
        }
      } while (!isDone);
    }
    return new _Charset(...newData);
  }
  intersect(...inputs) {
    return this.subtract(this.subtract(...inputs));
  }
  _isEmpty() {
    return this.data.length === 0;
  }
  _toString(flags) {
    return rangesToString(this.data, flags);
  }
  _unique() {
    this.data.sort(compare);
    const newData = [];
    let lastDataUnit = null;
    for (const dataUnit of this.data) {
      if (lastDataUnit === null || lastDataUnit[1] + 1 < dataUnit[0]) {
        newData.push(dataUnit);
        lastDataUnit = dataUnit;
      } else {
        newData.splice(-1, 1, [
          Math.min(dataUnit[0], lastDataUnit[0]),
          Math.max(dataUnit[1], lastDataUnit[1])
        ]);
        lastDataUnit = newData[newData.length - 1];
      }
    }
    this.data = newData;
  }
};
var charset = (...inputs) => new Charset(...inputs);
function charCode(char) {
  if (char.length !== 1) {
    const display = `${char.length} (${JSON.stringify(char)})`;
    throw new Error(`Expected length = 1, but received ${display}.`);
  }
  return char.charCodeAt(0);
}
function normalize(rawInput) {
  if (typeof rawInput === "number" && (rawInput < 0 || rawInput > 1114111)) {
    throw new Error(`Invalid unicode code point detected: ${rawInput < 0 ? rawInput : `0x${rawInput.toString(16)}`}`);
  }
  const [normalized] = [rawInput].map((_819) => typeof _819 !== "object" ? [_819, _819] : _819).map((_819) => _819.map((u) => typeof u === "string" ? charCode(u) : u));
  return normalized;
}
function compare(a, b) {
  return a[0] - b[0];
}
function rangesToString(ranges, flags = "") {
  if (flags.includes("u")) {
    return normalToPattern(ranges, true);
  }
  const { normal, surrogate } = splitRanges(ranges);
  const patterns = [];
  if (normal.length !== 0) {
    patterns.push(normalToPattern(normal, false));
  }
  patterns.push(...surrogateToPatterns(surrogate));
  return patterns.join("|");
}
function normalToPattern(normal, hasUnicodeFlag) {
  const ranges = normal.map(([start, end]) => start === end ? unicode(start, hasUnicodeFlag) : `${unicode(start, hasUnicodeFlag)}-${unicode(end, hasUnicodeFlag)}`);
  return `[${ranges.join("")}]`;
}
function surrogateToPatterns(surrogate) {
  const patterns = [];
  if (surrogate.entire.data.length !== 0) {
    const h = surrogate.entire.toString();
    const l = `[${[
      56320,
      57343
      /* SurrogateLimit.MaxL */
    ].map((_819) => unicode(_819, false)).join("-")}]`;
    patterns.push(`${h}${l}`);
  }
  for (const { h: rawH, l: lCharset } of surrogate.partial) {
    const h = unicode(rawH, false);
    const l = lCharset.toString();
    patterns.push(`${h}${l}`);
  }
  return patterns;
}
function splitRanges(data2) {
  const normal = [];
  const surrogateRanges = [];
  for (let i = 0; i < data2.length; i++) {
    const dataUnit = data2[i];
    const [start, end] = dataUnit;
    if (start >= 65536) {
      surrogateRanges.push(...data2.slice(i));
      break;
    }
    if (end >= 65536) {
      normal.push([start, 65536 - 1]);
      surrogateRanges.push([65536, end], ...data2.slice(i + 1));
      break;
    }
    normal.push(dataUnit);
  }
  return { normal, surrogate: splitSurrogateRanges(surrogateRanges) };
}
function splitSurrogateRanges(ranges) {
  const entire = [];
  const partial = [];
  for (const [start, end] of ranges) {
    const startPair = surrogatePair(start);
    const endPair = surrogatePair(end);
    if (startPair.h === endPair.h) {
      addPartialRange(startPair.h, startPair.l, endPair.l);
      continue;
    }
    if (startPair.l === 56320) {
      addEntireRange(startPair.h);
    } else {
      addPartialRange(
        startPair.h,
        startPair.l,
        57343
        /* SurrogateLimit.MaxL */
      );
    }
    for (let h = startPair.h + 1; h < endPair.h; h++) {
      addEntireRange(h);
    }
    if (endPair.l === 57343) {
      addEntireRange(endPair.h);
    } else {
      addPartialRange(endPair.h, 56320, endPair.l);
    }
  }
  return {
    entire: new Charset(...entire),
    partial: partial.map(({ h, l }) => ({ h, l: new Charset(...l) }))
  };
  function addEntireRange(h) {
    entire.push(h);
  }
  function addPartialRange(h, start, end) {
    const lastPartial = partial[partial.length - 1];
    if (lastPartial !== void 0 && lastPartial.h === h) {
      lastPartial.l.push([start, end]);
    } else {
      partial.push({ h, l: [[start, end]] });
    }
  }
}
function surrogatePair(codepoint) {
  return {
    h: Math.floor((codepoint - 65536) / 1024) + 55296,
    l: (codepoint - 65536) % 1024 + 56320
  };
}
function unicode(char, hasUnicodeFlag) {
  const hex = char.toString(16);
  return hasUnicodeFlag ? `\\u{${hex}}` : `\\u${"0".repeat(4 - hex.length)}${hex}`;
}

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/index.js
var data_exports = {};
__export(data_exports, {
  Bidi_Class: () => Bidi_Class_exports,
  Bidi_Mirroring_Glyph: () => Bidi_Mirroring_Glyph_exports,
  Bidi_Paired_Bracket_Type: () => Bidi_Paired_Bracket_Type_exports,
  Binary_Property: () => Binary_Property_exports,
  Block: () => Block_exports,
  Case_Folding: () => Case_Folding_exports,
  General_Category: () => General_Category_exports,
  Line_Break: () => Line_Break_exports,
  Script: () => Script_exports,
  Script_Extensions: () => Script_Extensions_exports,
  Word_Break: () => Word_Break_exports
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/index.js
var Binary_Property_exports = {};
__export(Binary_Property_exports, {
  ASCII: () => ASCII_default,
  ASCII_Hex_Digit: () => ASCII_Hex_Digit_default,
  Alphabetic: () => Alphabetic_default,
  Any: () => Any_default,
  Assigned: () => Assigned_default,
  Bidi_Control: () => Bidi_Control_default,
  Bidi_Mirrored: () => Bidi_Mirrored_default,
  Case_Ignorable: () => Case_Ignorable_default,
  Cased: () => Cased_default,
  Changes_When_Casefolded: () => Changes_When_Casefolded_default,
  Changes_When_Casemapped: () => Changes_When_Casemapped_default,
  Changes_When_Lowercased: () => Changes_When_Lowercased_default,
  Changes_When_NFKC_Casefolded: () => Changes_When_NFKC_Casefolded_default,
  Changes_When_Titlecased: () => Changes_When_Titlecased_default,
  Changes_When_Uppercased: () => Changes_When_Uppercased_default,
  Composition_Exclusion: () => Composition_Exclusion_default,
  Dash: () => Dash_default,
  Default_Ignorable_Code_Point: () => Default_Ignorable_Code_Point_default,
  Deprecated: () => Deprecated_default,
  Diacritic: () => Diacritic_default,
  Emoji: () => Emoji_default,
  Emoji_Component: () => Emoji_Component_default,
  Emoji_Modifier: () => Emoji_Modifier_default,
  Emoji_Modifier_Base: () => Emoji_Modifier_Base_default,
  Emoji_Presentation: () => Emoji_Presentation_default,
  Expands_On_NFC: () => Expands_On_NFC_default,
  Expands_On_NFD: () => Expands_On_NFD_default,
  Expands_On_NFKC: () => Expands_On_NFKC_default,
  Expands_On_NFKD: () => Expands_On_NFKD_default,
  Extended_Pictographic: () => Extended_Pictographic_default,
  Extender: () => Extender_default,
  Full_Composition_Exclusion: () => Full_Composition_Exclusion_default,
  Grapheme_Base: () => Grapheme_Base_default,
  Grapheme_Extend: () => Grapheme_Extend_default,
  Grapheme_Link: () => Grapheme_Link_default,
  Hex_Digit: () => Hex_Digit_default,
  Hyphen: () => Hyphen_default,
  IDS_Binary_Operator: () => IDS_Binary_Operator_default,
  IDS_Trinary_Operator: () => IDS_Trinary_Operator_default,
  ID_Continue: () => ID_Continue_default,
  ID_Start: () => ID_Start_default,
  Ideographic: () => Ideographic_default,
  Join_Control: () => Join_Control_default,
  Logical_Order_Exception: () => Logical_Order_Exception_default,
  Lowercase: () => Lowercase_default,
  Math: () => Math_default,
  Noncharacter_Code_Point: () => Noncharacter_Code_Point_default,
  Other_Alphabetic: () => Other_Alphabetic_default,
  Other_Default_Ignorable_Code_Point: () => Other_Default_Ignorable_Code_Point_default,
  Other_Grapheme_Extend: () => Other_Grapheme_Extend_default,
  Other_ID_Continue: () => Other_ID_Continue_default,
  Other_ID_Start: () => Other_ID_Start_default,
  Other_Lowercase: () => Other_Lowercase_default,
  Other_Math: () => Other_Math_default,
  Other_Uppercase: () => Other_Uppercase_default,
  Pattern_Syntax: () => Pattern_Syntax_default,
  Pattern_White_Space: () => Pattern_White_Space_default,
  Prepended_Concatenation_Mark: () => Prepended_Concatenation_Mark_default,
  Quotation_Mark: () => Quotation_Mark_default,
  Radical: () => Radical_default,
  Regional_Indicator: () => Regional_Indicator_default,
  Sentence_Terminal: () => Sentence_Terminal_default,
  Soft_Dotted: () => Soft_Dotted_default,
  Terminal_Punctuation: () => Terminal_Punctuation_default,
  Unified_Ideograph: () => Unified_Ideograph_default,
  Uppercase: () => Uppercase_default,
  Variation_Selector: () => Variation_Selector_default,
  White_Space: () => White_Space_default,
  XID_Continue: () => XID_Continue_default,
  XID_Start: () => XID_Start_default
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ASCII.js
var _ = [[0, 127]];
var ASCII_default = _;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ASCII_Hex_Digit.js
var _2 = [[48, 57], [65, 70], [97, 102]];
var ASCII_Hex_Digit_default = _2;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Alphabetic.js
var _3 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, 837, [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1456, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1488, 1514], [1519, 1522], [1552, 1562], [1568, 1623], [1625, 1631], [1646, 1747], [1749, 1756], [1761, 1768], [1773, 1775], [1786, 1788], 1791, [1808, 1855], [1869, 1969], [1994, 2026], [2036, 2037], 2042, [2048, 2071], [2074, 2092], [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2260, 2271], [2275, 2281], [2288, 2363], [2365, 2380], [2382, 2384], [2389, 2403], [2417, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2493, 2500], [2503, 2504], [2507, 2508], 2510, 2519, [2524, 2525], [2527, 2531], [2544, 2545], 2556, [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2622, 2626], [2631, 2632], [2635, 2636], 2641, [2649, 2652], 2654, [2672, 2677], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2757], [2759, 2761], [2763, 2764], 2768, [2784, 2787], [2809, 2812], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2877, 2884], [2887, 2888], [2891, 2892], [2902, 2903], [2908, 2909], [2911, 2915], 2929, [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3020], 3024, 3031, [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3133, 3140], [3142, 3144], [3146, 3148], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3200, 3203], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3268], [3270, 3272], [3274, 3276], [3285, 3286], [3293, 3294], [3296, 3299], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3386], [3389, 3396], [3398, 3400], [3402, 3404], 3406, [3412, 3415], [3423, 3427], [3450, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3535, 3540], 3542, [3544, 3551], [3570, 3571], [3585, 3642], [3648, 3654], 3661, [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3769], [3771, 3773], [3776, 3780], 3782, 3789, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3953, 3971], [3976, 3991], [3993, 4028], [4096, 4150], 4152, [4155, 4159], [4176, 4239], [4250, 4253], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5907], [5919, 5939], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6067], [6070, 6088], 6103, 6108, [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6456], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6683], [6688, 6750], [6753, 6772], 6823, [6847, 6848], [6860, 6862], [6912, 6963], [6965, 6979], [6981, 6988], [7040, 7081], [7084, 7087], [7098, 7141], [7143, 7153], [7168, 7222], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7655, 7668], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [9398, 9449], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11775], 11823, [12293, 12295], [12321, 12329], [12337, 12341], [12344, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42612, 42619], [42623, 42735], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43013], [43015, 43047], [43072, 43123], [43136, 43203], 43205, [43250, 43255], 43259, [43261, 43263], [43274, 43306], [43312, 43346], [43360, 43388], [43392, 43442], [43444, 43455], 43471, [43488, 43503], [43514, 43518], [43520, 43574], [43584, 43597], [43616, 43638], [43642, 43710], 43712, 43714, [43739, 43741], [43744, 43759], [43762, 43765], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44010], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66426], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], [68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68903], [69248, 69289], [69291, 69292], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69632, 69701], [69745, 69749], [69760, 69816], 69826, [69840, 69864], [69888, 69938], [69956, 69959], [69968, 70002], 70006, [70016, 70079], [70081, 70084], [70094, 70095], 70106, 70108, [70144, 70161], [70163, 70196], 70199, [70206, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70376], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70461, 70468], [70471, 70472], [70475, 70476], 70480, 70487, [70493, 70499], [70656, 70721], [70723, 70725], [70727, 70730], [70751, 70753], [70784, 70849], [70852, 70853], 70855, [71040, 71093], [71096, 71102], [71128, 71133], [71168, 71230], 71232, 71236, [71296, 71349], 71352, [71424, 71450], [71453, 71466], [71488, 71494], [71680, 71736], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 71996], [71999, 72002], [72096, 72103], [72106, 72151], [72154, 72159], 72161, [72163, 72164], [72192, 72242], [72245, 72254], [72272, 72343], 72349, [72368, 72440], [72704, 72712], [72714, 72758], [72760, 72766], 72768, [72818, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73025], 73027, [73030, 73031], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73110], 73112, [73440, 73462], [73472, 73488], [73490, 73530], [73534, 73536], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94177], 94179, [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113822, [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125255, 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [127280, 127305], [127312, 127337], [127344, 127369], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var Alphabetic_default = _3;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Any.js
var _4 = [[0, 1114111]];
var Any_default = _4;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Assigned.js
var _5 = [[0, 887], [890, 895], [900, 906], 908, [910, 929], [931, 1327], [1329, 1366], [1369, 1418], [1421, 1423], [1425, 1479], [1488, 1514], [1519, 1524], [1536, 1805], [1807, 1866], [1869, 1969], [1984, 2042], [2045, 2093], [2096, 2110], [2112, 2139], 2142, [2144, 2154], [2160, 2190], [2192, 2193], [2200, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2558], [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2678], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2801], [2809, 2815], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2935], [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3066], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3191, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3407], [3412, 3427], [3430, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3572], [3585, 3642], [3647, 3675], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807], [3840, 3911], [3913, 3948], [3953, 3991], [3993, 4028], [4030, 4044], [4046, 4058], [4096, 4293], 4295, 4301, [4304, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4988], [4992, 5017], [5024, 5109], [5112, 5117], [5120, 5788], [5792, 5880], [5888, 5909], [5919, 5942], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6109], [6112, 6121], [6128, 6137], [6144, 6169], [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6459], 6464, [6468, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6622, 6683], [6686, 6750], [6752, 6780], [6783, 6793], [6800, 6809], [6816, 6829], [6832, 6862], [6912, 6988], [6992, 7038], [7040, 7155], [7164, 7223], [7227, 7241], [7245, 7304], [7312, 7354], [7357, 7367], [7376, 7418], [7424, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], [8192, 8292], [8294, 8305], [8308, 8334], [8336, 8348], [8352, 8384], [8400, 8432], [8448, 8587], [8592, 9254], [9280, 9290], [9312, 11123], [11126, 11157], [11159, 11507], [11513, 11557], 11559, 11565, [11568, 11623], [11631, 11632], [11647, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11869], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12288, 12351], [12353, 12438], [12441, 12543], [12549, 12591], [12593, 12686], [12688, 12771], [12784, 12830], [12832, 42124], [42128, 42182], [42192, 42539], [42560, 42743], [42752, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43052], [43056, 43065], [43072, 43127], [43136, 43205], [43214, 43225], [43232, 43347], [43359, 43388], [43392, 43469], [43471, 43481], [43486, 43518], [43520, 43574], [43584, 43597], [43600, 43609], [43612, 43714], [43739, 43766], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43883], [43888, 44013], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [55296, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64450], [64467, 64911], [64914, 64967], 64975, [65008, 65049], [65056, 65106], [65108, 65126], [65128, 65131], [65136, 65140], [65142, 65276], 65279, [65281, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65504, 65510], [65512, 65518], [65529, 65533], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65792, 65794], [65799, 65843], [65847, 65934], [65936, 65948], 65952, [66e3, 66045], [66176, 66204], [66208, 66256], [66272, 66299], [66304, 66339], [66349, 66378], [66384, 66426], [66432, 66461], [66463, 66499], [66504, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67671, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67871, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], [68159, 68168], [68176, 68184], [68192, 68255], [68288, 68326], [68331, 68342], [68352, 68405], [68409, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68903], [68912, 68921], [69216, 69246], [69248, 69289], [69291, 69293], [69296, 69297], [69373, 69415], [69424, 69465], [69488, 69513], [69552, 69579], [69600, 69622], [69632, 69709], [69714, 69749], [69759, 69826], 69837, [69840, 69864], [69872, 69881], [69888, 69940], [69942, 69959], [69968, 70006], [70016, 70111], [70113, 70132], [70144, 70161], [70163, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313], [70320, 70378], [70384, 70393], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [70656, 70747], [70749, 70753], [70784, 70855], [70864, 70873], [71040, 71093], [71096, 71133], [71168, 71236], [71248, 71257], [71264, 71276], [71296, 71353], [71360, 71369], [71424, 71450], [71453, 71467], [71472, 71494], [71680, 71739], [71840, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72006], [72016, 72025], [72096, 72103], [72106, 72151], [72154, 72164], [72192, 72263], [72272, 72354], [72368, 72440], [72448, 72457], [72704, 72712], [72714, 72758], [72760, 72773], [72784, 72812], [72816, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129], [73440, 73464], [73472, 73488], [73490, 73530], [73534, 73561], 73648, [73664, 73713], [73727, 74649], [74752, 74862], [74864, 74868], [74880, 75075], [77712, 77810], [77824, 78933], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92782, 92862], [92864, 92873], [92880, 92909], [92912, 92917], [92928, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93850], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94180], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113820, 113827], [118528, 118573], [118576, 118598], [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119274], [119296, 119365], [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 121483], [121499, 121503], [121505, 121519], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123184, 123197], [123200, 123209], [123214, 123215], [123536, 123566], [123584, 123641], 123647, [124112, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125127, 125142], [125184, 125259], [125264, 125273], [125278, 125279], [126065, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], 917505, [917536, 917631], [917760, 917999], [983040, 1048573], [1048576, 1114109]];
var Assigned_default = _5;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Bidi_Control.js
var _6 = [1564, [8206, 8207], [8234, 8238], [8294, 8297]];
var Bidi_Control_default = _6;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Bidi_Mirrored.js
var _7 = [[40, 41], 60, 62, 91, 93, 123, 125, 171, 187, [3898, 3901], [5787, 5788], [8249, 8250], [8261, 8262], [8317, 8318], [8333, 8334], 8512, [8705, 8708], [8712, 8717], 8721, [8725, 8726], [8730, 8733], [8735, 8738], 8740, 8742, [8747, 8755], 8761, [8763, 8780], [8786, 8789], [8799, 8800], 8802, [8804, 8811], [8814, 8844], [8847, 8850], 8856, [8866, 8867], [8870, 8888], [8894, 8895], [8905, 8909], [8912, 8913], [8918, 8941], [8944, 8959], [8968, 8971], [8992, 8993], [9001, 9002], [10088, 10101], 10176, [10179, 10182], [10184, 10185], [10187, 10189], [10195, 10198], [10204, 10206], [10210, 10223], [10627, 10648], [10651, 10656], [10658, 10671], 10680, [10688, 10693], 10697, [10702, 10706], [10708, 10709], [10712, 10716], 10721, [10723, 10725], [10728, 10729], [10740, 10745], [10748, 10749], [10762, 10780], [10782, 10785], 10788, 10790, 10793, [10795, 10798], [10804, 10805], [10812, 10814], [10839, 10840], [10852, 10853], [10858, 10861], [10863, 10864], [10867, 10868], [10873, 10915], [10918, 10925], [10927, 10966], 10972, 10974, [10978, 10982], [10988, 10990], 10995, [10999, 11003], 11005, 11262, [11778, 11781], [11785, 11786], [11788, 11789], [11804, 11805], [11808, 11817], [11861, 11868], [12296, 12305], [12308, 12315], [65113, 65118], [65124, 65125], [65288, 65289], 65308, 65310, 65339, 65341, 65371, 65373, [65375, 65376], [65378, 65379], 120539, 120597, 120655, 120713, 120771];
var Bidi_Mirrored_default = _7;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Case_Ignorable.js
var _8 = [39, 46, 58, 94, 96, 168, 173, 175, 180, [183, 184], [688, 879], [884, 885], 890, [900, 901], 903, [1155, 1161], 1369, 1375, [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, 1524, [1536, 1541], [1552, 1562], 1564, 1600, [1611, 1631], 1648, [1750, 1757], [1759, 1768], [1770, 1773], 1807, 1809, [1840, 1866], [1958, 1968], [2027, 2037], 2042, 2045, [2070, 2093], [2137, 2139], 2184, [2192, 2193], [2200, 2207], [2249, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2417, 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3270, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3654, 3662], 3761, [3764, 3772], 3782, [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, 4348, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6103, 6109, [6155, 6159], 6211, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, 6823, [6832, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7288, 7293], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7468, 7530], 7544, [7579, 7679], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [8203, 8207], [8216, 8217], 8228, 8231, [8234, 8238], [8288, 8292], [8294, 8303], 8305, 8319, [8336, 8348], [8400, 8432], [11388, 11389], [11503, 11505], 11631, 11647, [11744, 11775], 11823, 12293, [12330, 12333], [12337, 12341], 12347, [12441, 12446], [12540, 12542], 40981, [42232, 42237], 42508, [42607, 42610], [42612, 42621], 42623, [42652, 42655], [42736, 42737], [42752, 42785], 42864, [42888, 42890], [42994, 42996], [43e3, 43001], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43471, [43493, 43494], [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43632, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, 43741, [43756, 43757], [43763, 43764], 43766, [43867, 43871], [43881, 43883], 44005, 44008, 44013, 64286, [64434, 64450], [65024, 65039], 65043, [65056, 65071], 65106, 65109, 65279, 65287, 65294, 65306, 65342, 65344, 65392, [65438, 65439], 65507, [65529, 65531], 66045, 66272, [66422, 66426], [67456, 67461], [67463, 67504], [67506, 67514], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69821, 69826, 69837, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, [78896, 78912], [78919, 78933], [92912, 92916], [92976, 92982], [92992, 92995], 94031, [94095, 94111], [94176, 94177], [94179, 94180], [110576, 110579], [110581, 110587], [110589, 110590], [113821, 113822], [113824, 113827], [118528, 118573], [118576, 118598], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123184, 123197], 123566, [123628, 123631], [124139, 124143], [125136, 125142], [125252, 125259], [127995, 127999], 917505, [917536, 917631], [917760, 917999]];
var Case_Ignorable_default = _8;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Cased.js
var _9 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 442], [444, 447], [452, 659], [661, 696], [704, 705], [736, 740], 837, [880, 883], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], [1376, 1416], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4351], [5024, 5109], [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8500], 8505, [8508, 8511], [8517, 8521], 8526, [8544, 8575], [8579, 8580], [9398, 9449], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [42560, 42605], [42624, 42653], [42786, 42887], [42891, 42894], [42896, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 42998], [43e3, 43002], [43824, 43866], [43868, 43881], [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [66560, 66639], [66736, 66771], [66776, 66811], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], 67456, [67459, 67461], [67463, 67504], [67506, 67514], [68736, 68786], [68800, 68850], [71840, 71903], [93760, 93823], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122633], [122635, 122654], [122661, 122666], [122928, 122989], [125184, 125251], [127280, 127305], [127312, 127337], [127344, 127369]];
var Cased_default = _9;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Casefolded.js
var _10 = [[65, 90], 181, [192, 214], [216, 223], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, [329, 330], 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, 383, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, [452, 453], [455, 456], [458, 459], 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, [497, 498], 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 837, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 962, [975, 977], [981, 982], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, [1008, 1009], [1012, 1013], 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], 1415, [4256, 4293], 4295, 4301, [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, [7834, 7835], 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8064, 8111], [8114, 8116], [8119, 8124], [8130, 8132], [8135, 8140], [8152, 8155], [8168, 8172], [8178, 8180], [8183, 8188], 8486, [8490, 8491], 8498, [8544, 8559], 8579, [9398, 9423], [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [125184, 125217]];
var Changes_When_Casefolded_default = _10;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Casemapped.js
var _11 = [[65, 90], [97, 122], 181, [192, 214], [216, 246], [248, 311], [313, 396], [398, 410], [412, 425], [428, 441], [444, 445], 447, [452, 544], [546, 563], [570, 596], [598, 599], 601, [603, 604], [608, 609], 611, [613, 614], [616, 620], 623, [625, 626], 629, 637, 640, [642, 643], [647, 652], 658, [669, 670], 837, [880, 883], [886, 887], [891, 893], 895, 902, [904, 906], 908, [910, 929], [931, 977], [981, 1013], [1015, 1019], [1021, 1153], [1162, 1327], [1329, 1366], [1377, 1415], [4256, 4293], 4295, 4301, [4304, 4346], [4349, 4351], [5024, 5109], [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], 7545, 7549, 7566, [7680, 7835], 7838, [7840, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8486, [8490, 8491], 8498, 8526, [8544, 8575], [8579, 8580], [9398, 9449], [11264, 11376], [11378, 11379], [11381, 11382], [11390, 11491], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [42560, 42605], [42624, 42651], [42786, 42799], [42802, 42863], [42873, 42887], [42891, 42893], [42896, 42900], [42902, 42926], [42928, 42954], [42960, 42961], [42966, 42969], [42997, 42998], 43859, [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [66560, 66639], [66736, 66771], [66776, 66811], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68736, 68786], [68800, 68850], [71840, 71903], [93760, 93823], [125184, 125251]];
var Changes_When_Casemapped_default = _11;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Lowercased.js
var _12 = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, [452, 453], [455, 456], [458, 459], 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, [497, 498], 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8072, 8079], [8088, 8095], [8104, 8111], [8120, 8124], [8136, 8140], [8152, 8155], [8168, 8172], [8184, 8188], 8486, [8490, 8491], 8498, [8544, 8559], 8579, [9398, 9423], [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [125184, 125217]];
var Changes_When_Lowercased_default = _12;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_NFKC_Casefolded.js
var _13 = [[65, 90], 160, 168, 170, 173, 175, [178, 181], [184, 186], [188, 190], [192, 214], [216, 223], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, [306, 308], 310, 313, 315, 317, [319, 321], 323, 325, 327, [329, 330], 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, 383, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, [452, 461], 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, [497, 500], [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, [688, 696], [728, 733], [736, 740], [832, 833], [835, 837], 847, 880, 882, 884, 886, 890, [894, 895], [900, 906], 908, [910, 911], [913, 929], [931, 939], 962, [975, 982], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, [1008, 1010], [1012, 1013], 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], 1415, 1564, [1653, 1656], [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3635, 3763, [3804, 3805], 3852, 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3961], 3969, 3987, 3997, 4002, 4007, 4012, 4025, [4256, 4293], 4295, 4301, 4348, [4447, 4448], [5112, 5117], [6068, 6069], [6155, 6159], [7296, 7304], [7312, 7354], [7357, 7359], [7468, 7470], [7472, 7482], [7484, 7501], [7503, 7530], 7544, [7579, 7615], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, [7834, 7835], 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], 8049, 8051, 8053, 8055, 8057, 8059, 8061, [8064, 8111], [8114, 8116], [8119, 8132], [8135, 8143], 8147, [8152, 8155], [8157, 8159], 8163, [8168, 8175], [8178, 8180], [8183, 8190], [8192, 8207], 8209, 8215, [8228, 8230], [8234, 8239], [8243, 8244], [8246, 8247], 8252, 8254, [8263, 8265], 8279, [8287, 8305], [8308, 8334], [8336, 8348], 8360, [8448, 8451], [8453, 8455], [8457, 8467], [8469, 8470], [8473, 8477], [8480, 8482], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8507, 8512], [8517, 8521], [8528, 8575], 8579, 8585, [8748, 8749], [8751, 8752], [9001, 9002], [9312, 9450], 10764, [10868, 10870], 10972, [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11388, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 11631, 11935, 12019, [12032, 12245], 12288, 12342, [12344, 12346], [12443, 12444], 12447, 12543, [12593, 12686], [12690, 12703], [12800, 12830], [12832, 12871], [12880, 12926], [12928, 13311], 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, [42652, 42653], 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42864, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, [42994, 42997], [43e3, 43001], [43868, 43871], 43881, [43888, 43967], [63744, 64013], 64016, 64018, [64021, 64030], 64032, 64034, [64037, 64038], [64042, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65024, 65049], [65072, 65092], [65095, 65106], [65108, 65126], [65128, 65131], [65136, 65138], 65140, [65142, 65276], 65279, [65281, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65504, 65510], [65512, 65518], [65520, 65528], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [67457, 67461], [67463, 67504], [67506, 67514], [68736, 68786], [71840, 71871], [93760, 93791], [113824, 113827], [119134, 119140], [119155, 119162], [119227, 119232], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [122928, 122989], [125184, 125217], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [127232, 127242], [127248, 127278], [127280, 127311], [127338, 127340], 127376, [127488, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [130032, 130041], [194560, 195101], [917504, 921599]];
var Changes_When_NFKC_Casefolded_default = _13;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Titlecased.js
var _14 = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, 311, 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, 396, 402, 405, [409, 410], 414, 417, 419, 421, 424, 429, 432, 436, 438, 441, 445, 447, 452, [454, 455], [457, 458], 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 497], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 547, 549, 551, 553, 555, 557, 559, 561, 563, 572, [575, 576], 578, 583, 585, 587, 589, [591, 596], [598, 599], 601, [603, 604], [608, 609], 611, [613, 614], [616, 620], 623, [625, 626], 629, 637, 640, [642, 643], [647, 652], 658, [669, 670], 837, 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, 1019, [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1377, 1415], [5112, 5117], [7296, 7304], 7545, 7549, 7566, 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7835], 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8526, [8560, 8575], 8580, [9424, 9449], [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11379, 11382, 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, 11491, 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, 42799, 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42897, [42899, 42900], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42967, 42969, 42998, 43859, [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [71872, 71903], [93792, 93823], [125218, 125251]];
var Changes_When_Titlecased_default = _14;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Uppercased.js
var _15 = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, 311, 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, 396, 402, 405, [409, 410], 414, 417, 419, 421, 424, 429, 432, 436, 438, 441, 445, 447, [453, 454], [456, 457], [459, 460], 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], [498, 499], 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 547, 549, 551, 553, 555, 557, 559, 561, 563, 572, [575, 576], 578, 583, 585, 587, 589, [591, 596], [598, 599], 601, [603, 604], [608, 609], 611, [613, 614], [616, 620], 623, [625, 626], 629, 637, 640, [642, 643], [647, 652], 658, [669, 670], 837, 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, 1019, [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1377, 1415], [4304, 4346], [4349, 4351], [5112, 5117], [7296, 7304], 7545, 7549, 7566, 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7835], 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8116], [8118, 8119], 8124, 8126, [8130, 8132], [8134, 8135], 8140, [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8188, 8526, [8560, 8575], 8580, [9424, 9449], [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11379, 11382, 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, 11491, 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, 42799, 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42897, [42899, 42900], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42967, 42969, 42998, 43859, [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [71872, 71903], [93792, 93823], [125218, 125251]];
var Changes_When_Uppercased_default = _15;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Composition_Exclusion.js
var _16 = [[2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3907, 3917, 3922, 3927, 3932, 3945, 3958, 3960, 3987, 3997, 4002, 4007, 4012, 4025, 10972, 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], [119134, 119140], [119227, 119232]];
var Composition_Exclusion_default = _16;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Dash.js
var _17 = [45, 1418, 1470, 5120, 6150, [8208, 8213], 8275, 8315, 8331, 8722, 11799, 11802, [11834, 11835], 11840, 11869, 12316, 12336, 12448, [65073, 65074], 65112, 65123, 65293, 69293];
var Dash_default = _17;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Default_Ignorable_Code_Point.js
var _18 = [173, 847, 1564, [4447, 4448], [6068, 6069], [6155, 6159], [8203, 8207], [8234, 8238], [8288, 8303], 12644, [65024, 65039], 65279, 65440, [65520, 65528], [113824, 113827], [119155, 119162], [917504, 921599]];
var Default_Ignorable_Code_Point_default = _18;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Deprecated.js
var _19 = [329, 1651, 3959, 3961, [6051, 6052], [8298, 8303], [9001, 9002], 917505];
var Deprecated_default = _19;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Diacritic.js
var _20 = [94, 96, 168, 175, 180, [183, 184], [688, 846], [848, 855], [861, 866], [884, 885], 890, [900, 901], [1155, 1159], 1369, [1425, 1441], [1443, 1469], 1471, [1473, 1474], 1476, [1611, 1618], [1623, 1624], [1759, 1760], [1765, 1766], [1770, 1772], [1840, 1866], [1958, 1968], [2027, 2037], [2072, 2073], [2200, 2207], [2249, 2258], [2275, 2302], 2364, 2381, [2385, 2388], 2417, 2492, 2509, 2620, 2637, 2748, 2765, [2813, 2815], 2876, 2893, 2901, 3021, 3132, 3149, 3260, 3277, [3387, 3388], 3405, 3530, [3655, 3660], 3662, 3770, [3784, 3788], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3970, 3972], [3974, 3975], 4038, 4151, [4153, 4154], [4195, 4196], [4201, 4205], [4231, 4237], 4239, [4250, 4251], [4957, 4959], [5908, 5909], [6089, 6099], 6109, [6457, 6459], [6773, 6780], 6783, [6832, 6846], [6849, 6859], 6964, 6980, [7019, 7027], [7082, 7083], [7222, 7223], [7288, 7293], [7376, 7400], 7405, 7412, [7415, 7417], [7468, 7530], [7620, 7631], [7669, 7679], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [11503, 11505], 11823, [12330, 12335], [12441, 12444], 12540, 42607, [42620, 42621], 42623, [42652, 42653], [42736, 42737], [42752, 42785], [42888, 42890], [43e3, 43001], 43204, [43232, 43249], [43307, 43310], 43347, 43443, 43456, 43493, [43643, 43645], [43711, 43714], 43766, [43867, 43871], [43881, 43883], [44012, 44013], 64286, [65056, 65071], 65342, 65344, 65392, [65438, 65439], 65507, 66272, [67456, 67461], [67463, 67504], [67506, 67514], [68325, 68326], [68898, 68903], [69373, 69375], [69446, 69456], [69506, 69509], 69702, 69744, [69817, 69818], [69939, 69940], 70003, 70080, [70090, 70092], [70197, 70198], [70377, 70378], 70460, 70477, [70502, 70508], [70512, 70516], 70722, 70726, [70850, 70851], [71103, 71104], 71231, [71350, 71351], 71467, [71737, 71738], [71997, 71998], 72003, 72160, 72244, 72263, 72345, 72767, 73026, [73028, 73029], 73111, [78919, 78933], [92912, 92916], [92976, 92982], [94095, 94111], [94192, 94193], [110576, 110579], [110581, 110587], [110589, 110590], [118528, 118573], [118576, 118598], [119143, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [122928, 122989], [123184, 123190], 123566, [123628, 123631], [125136, 125142], [125252, 125254], [125256, 125258]];
var Diacritic_default = _20;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji.js
var _21 = [35, 42, [48, 57], 169, 174, 8252, 8265, 8482, 8505, [8596, 8601], [8617, 8618], [8986, 8987], 9e3, 9167, [9193, 9203], [9208, 9210], 9410, [9642, 9643], 9654, 9664, [9723, 9726], [9728, 9732], 9742, 9745, [9748, 9749], 9752, 9757, 9760, [9762, 9763], 9766, 9770, [9774, 9775], [9784, 9786], 9792, 9794, [9800, 9811], [9823, 9824], 9827, [9829, 9830], 9832, 9851, [9854, 9855], [9874, 9879], 9881, [9883, 9884], [9888, 9889], 9895, [9898, 9899], [9904, 9905], [9917, 9918], [9924, 9925], 9928, [9934, 9935], 9937, [9939, 9940], [9961, 9962], [9968, 9973], [9975, 9978], 9981, 9986, 9989, [9992, 9997], 9999, 10002, 10004, 10006, 10013, 10017, 10024, [10035, 10036], 10052, 10055, 10060, 10062, [10067, 10069], 10071, [10083, 10084], [10133, 10135], 10145, 10160, 10175, [10548, 10549], [11013, 11015], [11035, 11036], 11088, 11093, 12336, 12349, 12951, 12953, 126980, 127183, [127344, 127345], [127358, 127359], 127374, [127377, 127386], [127462, 127487], [127489, 127490], 127514, 127535, [127538, 127546], [127568, 127569], [127744, 127777], [127780, 127891], [127894, 127895], [127897, 127899], [127902, 127984], [127987, 127989], [127991, 128253], [128255, 128317], [128329, 128334], [128336, 128359], [128367, 128368], [128371, 128378], 128391, [128394, 128397], 128400, [128405, 128406], [128420, 128421], 128424, [128433, 128434], 128444, [128450, 128452], [128465, 128467], [128476, 128478], 128481, 128483, 128488, 128495, 128499, [128506, 128591], [128640, 128709], [128715, 128722], [128725, 128727], [128732, 128741], 128745, [128747, 128748], 128752, [128755, 128764], [128992, 129003], 129008, [129292, 129338], [129340, 129349], [129351, 129535], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784]];
var Emoji_default = _21;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Component.js
var _22 = [35, 42, [48, 57], 8205, 8419, 65039, [127462, 127487], [127995, 127999], [129456, 129459], [917536, 917631]];
var Emoji_Component_default = _22;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Modifier.js
var _23 = [[127995, 127999]];
var Emoji_Modifier_default = _23;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Modifier_Base.js
var _24 = [9757, 9977, [9994, 9997], 127877, [127938, 127940], 127943, [127946, 127948], [128066, 128067], [128070, 128080], [128102, 128120], 128124, [128129, 128131], [128133, 128135], 128143, 128145, 128170, [128372, 128373], 128378, 128400, [128405, 128406], [128581, 128583], [128587, 128591], 128675, [128692, 128694], 128704, 128716, 129292, 129295, [129304, 129311], 129318, [129328, 129337], [129340, 129342], 129399, [129461, 129462], [129464, 129465], 129467, [129485, 129487], [129489, 129501], [129731, 129733], [129776, 129784]];
var Emoji_Modifier_Base_default = _24;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Presentation.js
var _25 = [[8986, 8987], [9193, 9196], 9200, 9203, [9725, 9726], [9748, 9749], [9800, 9811], 9855, 9875, 9889, [9898, 9899], [9917, 9918], [9924, 9925], 9934, 9940, 9962, [9970, 9971], 9973, 9978, 9981, 9989, [9994, 9995], 10024, 10060, 10062, [10067, 10069], 10071, [10133, 10135], 10160, 10175, [11035, 11036], 11088, 11093, 126980, 127183, 127374, [127377, 127386], [127462, 127487], 127489, 127514, 127535, [127538, 127542], [127544, 127546], [127568, 127569], [127744, 127776], [127789, 127797], [127799, 127868], [127870, 127891], [127904, 127946], [127951, 127955], [127968, 127984], 127988, [127992, 128062], 128064, [128066, 128252], [128255, 128317], [128331, 128334], [128336, 128359], 128378, [128405, 128406], 128420, [128507, 128591], [128640, 128709], 128716, [128720, 128722], [128725, 128727], [128732, 128735], [128747, 128748], [128756, 128764], [128992, 129003], 129008, [129292, 129338], [129340, 129349], [129351, 129535], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784]];
var Emoji_Presentation_default = _25;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFC.js
var _26 = [836, [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3958], 3960, 3969, 3987, 3997, 4002, 4007, 4012, 4025, 10972, 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], [119134, 119140], [119227, 119232]];
var Expands_On_NFC_default = _26;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFD.js
var _27 = [[192, 197], [199, 207], [209, 214], [217, 221], [224, 229], [231, 239], [241, 246], [249, 253], [255, 271], [274, 293], [296, 304], [308, 311], [313, 318], [323, 328], [332, 337], [340, 357], [360, 382], [416, 417], [431, 432], [461, 476], [478, 483], [486, 496], [500, 501], [504, 539], [542, 543], [550, 563], 836, [901, 902], [904, 906], 908, [910, 912], [938, 944], [970, 974], [979, 980], [1024, 1025], 1027, 1031, [1036, 1038], 1049, 1081, [1104, 1105], 1107, 1111, [1116, 1118], [1142, 1143], [1217, 1218], [1232, 1235], [1238, 1239], [1242, 1247], [1250, 1255], [1258, 1269], [1272, 1273], [1570, 1574], 1728, 1730, 1747, 2345, 2353, 2356, [2392, 2399], [2507, 2508], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, 2888, [2891, 2892], [2908, 2909], 2964, [3018, 3020], 3144, 3264, [3271, 3272], [3274, 3275], [3402, 3404], 3546, [3548, 3550], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3958], 3960, 3969, 3987, 3997, 4002, 4007, 4012, 4025, 4134, 6918, 6920, 6922, 6924, 6926, 6930, 6971, 6973, [6976, 6977], 6979, [7680, 7833], 7835, [7840, 7929], [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], [8129, 8132], [8134, 8147], [8150, 8155], [8157, 8174], [8178, 8180], [8182, 8188], 8491, [8602, 8603], 8622, [8653, 8655], 8708, 8713, 8716, 8740, 8742, 8769, 8772, 8775, 8777, 8800, 8802, [8813, 8817], [8820, 8821], [8824, 8825], [8832, 8833], [8836, 8837], [8840, 8841], [8876, 8879], [8928, 8931], [8938, 8941], 10972, 12364, 12366, 12368, 12370, 12372, 12374, 12376, 12378, 12380, 12382, 12384, 12386, 12389, 12391, 12393, [12400, 12401], [12403, 12404], [12406, 12407], [12409, 12410], [12412, 12413], 12436, 12446, 12460, 12462, 12464, 12466, 12468, 12470, 12472, 12474, 12476, 12478, 12480, 12482, 12485, 12487, 12489, [12496, 12497], [12499, 12500], [12502, 12503], [12505, 12506], [12508, 12509], 12532, [12535, 12538], 12542, [44032, 55203], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], 69786, 69788, 69803, [69934, 69935], [70475, 70476], [70843, 70844], 70846, [71098, 71099], 71992, [119134, 119140], [119227, 119232]];
var Expands_On_NFD_default = _27;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFKC.js
var _28 = [168, 175, 180, 184, [188, 190], [306, 307], [319, 320], 329, [452, 460], [497, 499], [728, 733], 836, 890, [900, 901], 1415, [1653, 1656], [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3635, 3763, [3804, 3805], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3961], 3969, 3987, 3997, 4002, 4007, 4012, 4025, 7834, 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8174], [8189, 8190], 8215, [8229, 8230], [8243, 8244], [8246, 8247], 8252, 8254, [8263, 8265], 8279, 8360, [8448, 8449], 8451, [8453, 8454], 8457, 8470, [8480, 8482], 8507, [8528, 8543], [8545, 8547], [8549, 8552], [8554, 8555], [8561, 8563], [8565, 8568], [8570, 8571], 8585, [8748, 8749], [8751, 8752], [9321, 9397], 10764, [10868, 10870], 10972, [12443, 12444], 12447, 12543, [12800, 12830], [12832, 12867], [12880, 12895], [12924, 12925], [12977, 13007], [13055, 13311], [64256, 64262], [64275, 64279], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335], 64477, [64490, 64507], [64512, 64829], [64848, 64911], [64914, 64967], [65008, 65020], 65049, 65072, [65097, 65100], [65136, 65138], 65140, [65142, 65151], [65269, 65276], 65507, [119134, 119140], [119227, 119232], [127232, 127242], [127248, 127274], [127277, 127278], [127306, 127311], [127338, 127340], 127376, [127488, 127489], [127552, 127560]];
var Expands_On_NFKC_default = _28;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFKD.js
var _29 = [168, 175, 180, 184, [188, 190], [192, 197], [199, 207], [209, 214], [217, 221], [224, 229], [231, 239], [241, 246], [249, 253], [255, 271], [274, 293], [296, 304], [306, 311], [313, 320], [323, 329], [332, 337], [340, 357], [360, 382], [416, 417], [431, 432], [452, 476], [478, 483], [486, 501], [504, 539], [542, 543], [550, 563], [728, 733], 836, 890, [900, 902], [904, 906], 908, [910, 912], [938, 944], [970, 974], [979, 980], [1024, 1025], 1027, 1031, [1036, 1038], 1049, 1081, [1104, 1105], 1107, 1111, [1116, 1118], [1142, 1143], [1217, 1218], [1232, 1235], [1238, 1239], [1242, 1247], [1250, 1255], [1258, 1269], [1272, 1273], 1415, [1570, 1574], [1653, 1656], 1728, 1730, 1747, 2345, 2353, 2356, [2392, 2399], [2507, 2508], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, 2888, [2891, 2892], [2908, 2909], 2964, [3018, 3020], 3144, 3264, [3271, 3272], [3274, 3275], [3402, 3404], 3546, [3548, 3550], 3635, 3763, [3804, 3805], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3961], 3969, 3987, 3997, 4002, 4007, 4012, 4025, 4134, 6918, 6920, 6922, 6924, 6926, 6930, 6971, 6973, [6976, 6977], 6979, [7680, 7835], [7840, 7929], [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8125], [8127, 8132], [8134, 8147], [8150, 8155], [8157, 8174], [8178, 8180], [8182, 8190], 8215, [8229, 8230], [8243, 8244], [8246, 8247], 8252, 8254, [8263, 8265], 8279, 8360, [8448, 8449], 8451, [8453, 8454], 8457, 8470, [8480, 8482], 8491, 8507, [8528, 8543], [8545, 8547], [8549, 8552], [8554, 8555], [8561, 8563], [8565, 8568], [8570, 8571], 8585, [8602, 8603], 8622, [8653, 8655], 8708, 8713, 8716, 8740, 8742, [8748, 8749], [8751, 8752], 8769, 8772, 8775, 8777, 8800, 8802, [8813, 8817], [8820, 8821], [8824, 8825], [8832, 8833], [8836, 8837], [8840, 8841], [8876, 8879], [8928, 8931], [8938, 8941], [9321, 9397], 10764, [10868, 10870], 10972, 12364, 12366, 12368, 12370, 12372, 12374, 12376, 12378, 12380, 12382, 12384, 12386, 12389, 12391, 12393, [12400, 12401], [12403, 12404], [12406, 12407], [12409, 12410], [12412, 12413], 12436, [12443, 12444], [12446, 12447], 12460, 12462, 12464, 12466, 12468, 12470, 12472, 12474, 12476, 12478, 12480, 12482, 12485, 12487, 12489, [12496, 12497], [12499, 12500], [12502, 12503], [12505, 12506], [12508, 12509], 12532, [12535, 12538], [12542, 12543], [12800, 12830], [12832, 12867], [12880, 12895], [12910, 12926], [12977, 13007], [13055, 13311], [44032, 55203], [64256, 64262], [64275, 64279], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335], [64420, 64421], [64432, 64433], 64477, [64490, 64507], [64512, 64829], [64848, 64911], [64914, 64967], [65008, 65020], 65049, 65072, [65097, 65100], [65136, 65138], 65140, [65142, 65151], [65153, 65164], [65269, 65276], 65507, 69786, 69788, 69803, [69934, 69935], [70475, 70476], [70843, 70844], 70846, [71098, 71099], 71992, [119134, 119140], [119227, 119232], [127232, 127242], [127248, 127274], [127277, 127278], [127306, 127311], [127338, 127340], 127376, [127488, 127489], 127507, [127552, 127560]];
var Expands_On_NFKD_default = _29;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Extended_Pictographic.js
var _30 = [169, 174, 8252, 8265, 8482, 8505, [8596, 8601], [8617, 8618], [8986, 8987], 9e3, 9096, 9167, [9193, 9203], [9208, 9210], 9410, [9642, 9643], 9654, 9664, [9723, 9726], [9728, 9733], [9735, 9746], [9748, 9861], [9872, 9989], [9992, 10002], 10004, 10006, 10013, 10017, 10024, [10035, 10036], 10052, 10055, 10060, 10062, [10067, 10069], 10071, [10083, 10087], [10133, 10135], 10145, 10160, 10175, [10548, 10549], [11013, 11015], [11035, 11036], 11088, 11093, 12336, 12349, 12951, 12953, [126976, 127231], [127245, 127247], 127279, [127340, 127345], [127358, 127359], 127374, [127377, 127386], [127405, 127461], [127489, 127503], 127514, 127535, [127538, 127546], [127548, 127551], [127561, 127994], [128e3, 128317], [128326, 128591], [128640, 128767], [128884, 128895], [128981, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129279], [129292, 129338], [129340, 129349], [129351, 129791], [130048, 131069]];
var Extended_Pictographic_default = _30;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Extender.js
var _31 = [183, [720, 721], 1600, 2042, 2901, 3654, 3782, 6154, 6211, 6823, 7222, 7291, 12293, [12337, 12341], [12445, 12446], [12540, 12542], 40981, 42508, 43471, 43494, 43632, 43741, [43763, 43764], 65392, [67457, 67458], 70493, [71110, 71112], 72344, [92994, 92995], [94176, 94177], 94179, [123196, 123197], [125252, 125254]];
var Extender_default = _31;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Full_Composition_Exclusion.js
var _32 = [[832, 833], [835, 836], 884, 894, 903, [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3958], 3960, 3969, 3987, 3997, 4002, 4007, 4012, 4025, 8049, 8051, 8053, 8055, 8057, 8059, 8061, 8123, 8126, 8137, 8139, 8147, 8155, 8163, 8171, [8174, 8175], 8185, 8187, 8189, [8192, 8193], 8486, [8490, 8491], [9001, 9002], 10972, [63744, 64013], 64016, 64018, [64021, 64030], 64032, 64034, [64037, 64038], [64042, 64109], [64112, 64217], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], [119134, 119140], [119227, 119232], [194560, 195101]];
var Full_Composition_Exclusion_default = _32;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Grapheme_Base.js
var _33 = [[32, 126], [160, 172], [174, 767], [880, 887], [890, 895], [900, 906], 908, [910, 929], [931, 1154], [1162, 1327], [1329, 1366], [1369, 1418], [1421, 1423], 1470, 1472, 1475, 1478, [1488, 1514], [1519, 1524], [1542, 1551], 1563, [1565, 1610], [1632, 1647], [1649, 1749], 1758, [1765, 1766], 1769, [1774, 1805], 1808, [1810, 1839], [1869, 1957], 1969, [1984, 2026], [2036, 2042], [2046, 2069], 2074, 2084, 2088, [2096, 2110], [2112, 2136], 2142, [2144, 2154], [2160, 2190], [2208, 2249], [2307, 2361], 2363, [2365, 2368], [2377, 2380], [2382, 2384], [2392, 2401], [2404, 2432], [2434, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, [2495, 2496], [2503, 2504], [2507, 2508], 2510, [2524, 2525], [2527, 2529], [2534, 2557], 2563, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2622, 2624], [2649, 2652], 2654, [2662, 2671], [2674, 2676], 2678, 2691, [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2752], 2761, [2763, 2764], 2768, [2784, 2785], [2790, 2801], 2809, [2818, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, 2880, [2887, 2888], [2891, 2892], [2908, 2909], [2911, 2913], [2918, 2935], 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3007, [3009, 3010], [3014, 3016], [3018, 3020], 3024, [3046, 3066], [3073, 3075], [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3137, 3140], [3160, 3162], 3165, [3168, 3169], [3174, 3183], [3191, 3200], [3202, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3262], [3264, 3265], [3267, 3268], [3271, 3272], [3274, 3275], [3293, 3294], [3296, 3297], [3302, 3311], [3313, 3315], [3330, 3340], [3342, 3344], [3346, 3386], 3389, [3391, 3392], [3398, 3400], [3402, 3404], [3406, 3407], [3412, 3414], [3416, 3425], [3430, 3455], [3458, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3536, 3537], [3544, 3550], [3558, 3567], [3570, 3572], [3585, 3632], [3634, 3635], [3647, 3654], [3663, 3675], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3792, 3801], [3804, 3807], [3840, 3863], [3866, 3892], 3894, 3896, [3898, 3911], [3913, 3948], 3967, 3973, [3976, 3980], [4030, 4037], [4039, 4044], [4046, 4058], [4096, 4140], 4145, 4152, [4155, 4156], [4159, 4183], [4186, 4189], [4193, 4208], [4213, 4225], [4227, 4228], [4231, 4236], [4238, 4252], [4254, 4293], 4295, 4301, [4304, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4960, 4988], [4992, 5017], [5024, 5109], [5112, 5117], [5120, 5788], [5792, 5880], [5888, 5905], 5909, [5919, 5937], [5940, 5942], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6070, [6078, 6085], [6087, 6088], [6100, 6108], [6112, 6121], [6128, 6137], [6144, 6154], [6160, 6169], [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], 6464, [6468, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6622, 6678], [6681, 6682], [6686, 6741], 6743, 6753, [6755, 6756], [6765, 6770], [6784, 6793], [6800, 6809], [6816, 6829], [6916, 6963], 6971, [6973, 6977], [6979, 6988], [6992, 7018], [7028, 7038], [7042, 7073], [7078, 7079], 7082, [7086, 7141], 7143, [7146, 7148], 7150, [7154, 7155], [7164, 7211], [7220, 7221], [7227, 7241], [7245, 7304], [7312, 7354], [7357, 7367], 7379, 7393, [7401, 7404], [7406, 7411], [7413, 7415], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], [8192, 8202], [8208, 8231], [8239, 8287], [8304, 8305], [8308, 8334], [8336, 8348], [8352, 8384], [8448, 8587], [8592, 9254], [9280, 9290], [9312, 11123], [11126, 11157], [11159, 11502], [11506, 11507], [11513, 11557], 11559, 11565, [11568, 11623], [11631, 11632], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11776, 11869], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12288, 12329], [12336, 12351], [12353, 12438], [12443, 12543], [12549, 12591], [12593, 12686], [12688, 12771], [12784, 12830], [12832, 42124], [42128, 42182], [42192, 42539], [42560, 42606], 42611, [42622, 42653], [42656, 42735], [42738, 42743], [42752, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43044], [43047, 43051], [43056, 43065], [43072, 43127], [43136, 43203], [43214, 43225], [43250, 43262], [43264, 43301], [43310, 43334], [43346, 43347], [43359, 43388], [43395, 43442], [43444, 43445], [43450, 43451], [43454, 43469], [43471, 43481], [43486, 43492], [43494, 43518], [43520, 43560], [43567, 43568], [43571, 43572], [43584, 43586], [43588, 43595], 43597, [43600, 43609], [43612, 43643], [43645, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43755], [43758, 43765], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43883], [43888, 44004], [44006, 44007], [44009, 44012], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64450], [64467, 64911], [64914, 64967], 64975, [65008, 65023], [65040, 65049], [65072, 65106], [65108, 65126], [65128, 65131], [65136, 65140], [65142, 65276], [65281, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65504, 65510], [65512, 65518], [65532, 65533], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65792, 65794], [65799, 65843], [65847, 65934], [65936, 65948], 65952, [66e3, 66044], [66176, 66204], [66208, 66256], [66273, 66299], [66304, 66339], [66349, 66378], [66384, 66421], [66432, 66461], [66463, 66499], [66504, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67671, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67871, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68096], [68112, 68115], [68117, 68119], [68121, 68149], [68160, 68168], [68176, 68184], [68192, 68255], [68288, 68324], [68331, 68342], [68352, 68405], [68409, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68899], [68912, 68921], [69216, 69246], [69248, 69289], 69293, [69296, 69297], [69376, 69415], [69424, 69445], [69457, 69465], [69488, 69505], [69510, 69513], [69552, 69579], [69600, 69622], 69632, [69634, 69687], [69703, 69709], [69714, 69743], [69745, 69746], 69749, [69762, 69810], [69815, 69816], [69819, 69820], [69822, 69825], [69840, 69864], [69872, 69881], [69891, 69926], 69932, [69942, 69959], [69968, 70002], [70004, 70006], [70018, 70069], [70079, 70088], [70093, 70094], [70096, 70111], [70113, 70132], [70144, 70161], [70163, 70190], [70194, 70195], 70197, [70200, 70205], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313], [70320, 70366], [70368, 70370], [70384, 70393], [70402, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70463, [70465, 70468], [70471, 70472], [70475, 70477], 70480, [70493, 70499], [70656, 70711], [70720, 70721], 70725, [70727, 70747], 70749, [70751, 70753], [70784, 70831], [70833, 70834], 70841, [70843, 70844], 70846, 70849, [70852, 70855], [70864, 70873], [71040, 71086], [71088, 71089], [71096, 71099], 71102, [71105, 71131], [71168, 71218], [71227, 71228], 71230, [71233, 71236], [71248, 71257], [71264, 71276], [71296, 71338], 71340, [71342, 71343], 71350, [71352, 71353], [71360, 71369], [71424, 71450], [71456, 71457], 71462, [71472, 71494], [71680, 71726], 71736, 71739, [71840, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], [71985, 71989], [71991, 71992], 71997, [71999, 72002], [72004, 72006], [72016, 72025], [72096, 72103], [72106, 72147], [72156, 72159], [72161, 72164], 72192, [72203, 72242], [72249, 72250], [72255, 72262], 72272, [72279, 72280], [72284, 72329], 72343, [72346, 72354], [72368, 72440], [72448, 72457], [72704, 72712], [72714, 72751], 72766, [72768, 72773], [72784, 72812], [72816, 72847], 72873, 72881, 72884, [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73107, 73108], 73110, 73112, [73120, 73129], [73440, 73458], [73461, 73464], [73474, 73488], [73490, 73525], [73534, 73535], 73537, [73539, 73561], 73648, [73664, 73713], [73727, 74649], [74752, 74862], [74864, 74868], [74880, 75075], [77712, 77810], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92782, 92862], [92864, 92873], [92880, 92909], 92917, [92928, 92975], [92983, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93850], [93952, 94026], [94032, 94087], [94099, 94111], [94176, 94179], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113820, 113823, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], 119142, [119146, 119149], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121483], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], [123200, 123209], [123214, 123215], [123536, 123565], [123584, 123627], [123632, 123641], 123647, [124112, 124139], [124144, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125127, 125135], [125184, 125251], 125259, [125264, 125273], [125278, 125279], [126065, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var Grapheme_Base_default = _33;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Grapheme_Extend.js
var _34 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, 2494, [2497, 2500], 2509, 2519, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, [2878, 2879], [2881, 2884], 2893, [2901, 2903], [2914, 2915], 2946, 3006, 3008, 3021, 3031, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3266, 3270, [3276, 3277], [3285, 3286], [3298, 3299], [3328, 3329], [3387, 3388], 3390, [3393, 3396], 3405, 3415, [3426, 3427], 3457, 3530, 3535, [3538, 3540], 3542, 3551, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6862], [6912, 6915], [6964, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], 8204, [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], [65438, 65439], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70462, 70464, 70487, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, 70832, [70835, 70840], 70842, 70845, [70847, 70848], [70850, 70851], 71087, [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], 71984, [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], 119141, [119143, 119145], [119150, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917536, 917631], [917760, 917999]];
var Grapheme_Extend_default = _34;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Grapheme_Link.js
var _35 = [2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, [3387, 3388], 3405, 3530, 3642, 3770, 3972, [4153, 4154], [5908, 5909], 5940, 6098, 6752, 6980, [7082, 7083], [7154, 7155], 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 68159, 69702, 69744, 69759, 69817, [69939, 69940], 70080, 70197, 70378, 70477, 70722, 70850, 71103, 71231, 71350, 71467, 71737, [71997, 71998], 72160, 72244, 72263, 72345, 72767, [73028, 73029], 73111, [73537, 73538]];
var Grapheme_Link_default = _35;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Hex_Digit.js
var _36 = [[48, 57], [65, 70], [97, 102], [65296, 65305], [65313, 65318], [65345, 65350]];
var Hex_Digit_default = _36;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Hyphen.js
var _37 = [45, 173, 1418, 6150, [8208, 8209], 11799, 12539, 65123, 65293, 65381];
var Hyphen_default = _37;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/IDS_Binary_Operator.js
var _38 = [[12272, 12273], [12276, 12283]];
var IDS_Binary_Operator_default = _38;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/IDS_Trinary_Operator.js
var _39 = [[12274, 12275]];
var IDS_Trinary_Operator_default = _39;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ID_Continue.js
var _40 = [[48, 57], [65, 90], 95, [97, 122], 170, 181, 183, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [768, 884], [886, 887], [890, 893], 895, [902, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1155, 1159], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1488, 1514], [1519, 1522], [1552, 1562], [1568, 1641], [1646, 1747], [1749, 1756], [1759, 1768], [1770, 1788], 1791, [1808, 1866], [1869, 1969], [1984, 2037], 2042, 2045, [2048, 2093], [2112, 2139], [2144, 2154], [2160, 2183], [2185, 2190], [2200, 2273], [2275, 2403], [2406, 2415], [2417, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2545], 2556, 2558, [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2677], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2799], [2809, 2815], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2927], 2929, [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3055], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3200, 3203], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3406], [3412, 3415], [3423, 3427], [3430, 3439], [3450, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3571], [3585, 3642], [3648, 3662], [3664, 3673], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807], 3840, [3864, 3865], [3872, 3881], 3893, 3895, 3897, [3902, 3911], [3913, 3948], [3953, 3972], [3974, 3991], [3993, 4028], 4038, [4096, 4169], [4176, 4253], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4959], [4969, 4977], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5909], [5919, 5940], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6099], 6103, [6108, 6109], [6112, 6121], [6155, 6157], [6159, 6169], [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6459], [6470, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6656, 6683], [6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], 6823, [6832, 6845], [6847, 6862], [6912, 6988], [6992, 7001], [7019, 7027], [7040, 7155], [7168, 7223], [7232, 7241], [7245, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7376, 7378], [7380, 7418], [7424, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], [8255, 8256], 8276, 8305, 8319, [8336, 8348], [8400, 8412], 8417, [8421, 8432], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11647, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11775], [12293, 12295], [12321, 12335], [12337, 12341], [12344, 12348], [12353, 12438], [12441, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42539], [42560, 42607], [42612, 42621], [42623, 42737], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43047], 43052, [43072, 43123], [43136, 43205], [43216, 43225], [43232, 43255], 43259, [43261, 43309], [43312, 43347], [43360, 43388], [43392, 43456], [43471, 43481], [43488, 43518], [43520, 43574], [43584, 43597], [43600, 43609], [43616, 43638], [43642, 43714], [43739, 43741], [43744, 43759], [43762, 43766], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44010], [44012, 44013], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65024, 65039], [65056, 65071], [65075, 65076], [65101, 65103], [65136, 65140], [65142, 65276], [65296, 65305], [65313, 65338], 65343, [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], 66045, [66176, 66204], [66208, 66256], 66272, [66304, 66335], [66349, 66378], [66384, 66426], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], [68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], 68159, [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68326], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68903], [68912, 68921], [69248, 69289], [69291, 69292], [69296, 69297], [69373, 69404], 69415, [69424, 69456], [69488, 69509], [69552, 69572], [69600, 69622], [69632, 69702], [69734, 69749], [69759, 69818], 69826, [69840, 69864], [69872, 69881], [69888, 69940], [69942, 69951], [69956, 69959], [69968, 70003], 70006, [70016, 70084], [70089, 70092], [70094, 70106], 70108, [70144, 70161], [70163, 70199], [70206, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70378], [70384, 70393], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [70656, 70730], [70736, 70745], [70750, 70753], [70784, 70853], 70855, [70864, 70873], [71040, 71093], [71096, 71104], [71128, 71133], [71168, 71232], 71236, [71248, 71257], [71296, 71352], [71360, 71369], [71424, 71450], [71453, 71467], [71472, 71481], [71488, 71494], [71680, 71738], [71840, 71913], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72003], [72016, 72025], [72096, 72103], [72106, 72151], [72154, 72161], [72163, 72164], [72192, 72254], 72263, [72272, 72345], 72349, [72368, 72440], [72704, 72712], [72714, 72758], [72760, 72768], [72784, 72793], [72818, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129], [73440, 73462], [73472, 73488], [73490, 73530], [73534, 73538], [73552, 73561], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78912, 78933], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92784, 92862], [92864, 92873], [92880, 92909], [92912, 92916], [92928, 92982], [92992, 92995], [93008, 93017], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94177], [94179, 94180], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [120782, 120831], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123184, 123197], [123200, 123209], 123214, [123536, 123566], [123584, 123641], [124112, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125136, 125142], [125184, 125259], [125264, 125273], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], [917760, 917999]];
var ID_Continue_default = _40;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ID_Start.js
var _41 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1488, 1514], [1519, 1522], [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3654], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6103, 6108, [6176, 6264], [6272, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], 6823, [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12293, 12295], [12321, 12329], [12337, 12341], [12344, 12348], [12353, 12438], [12443, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42735], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43488, 43492], [43494, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43741], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var ID_Start_default = _41;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Ideographic.js
var _42 = [[12294, 12295], [12321, 12329], [12344, 12346], [13312, 19903], [19968, 40959], [63744, 64109], [64112, 64217], 94180, [94208, 100343], [100352, 101589], [101632, 101640], [110960, 111355], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var Ideographic_default = _42;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Join_Control.js
var _43 = [[8204, 8205]];
var Join_Control_default = _43;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Logical_Order_Exception.js
var _44 = [[3648, 3652], [3776, 3780], [6581, 6583], 6586, [43701, 43702], 43705, [43707, 43708]];
var Logical_Order_Exception_default = _44;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Lowercase.js
var _45 = [[97, 122], 170, 181, 186, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, [311, 312], 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, [396, 397], 402, 405, [409, 411], 414, 417, 419, 421, 424, [426, 427], 429, 432, 436, 438, [441, 442], [445, 447], 454, 457, 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, [563, 569], 572, [575, 576], 578, 583, 585, 587, 589, [591, 659], [661, 696], [704, 705], [736, 740], 837, 881, 883, 887, [890, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, [1019, 1020], [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1376, 1416], [4304, 4346], [4348, 4351], [5112, 5117], [7296, 7304], [7424, 7615], 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7837], 7839, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8305, 8319, [8336, 8348], 8458, [8462, 8463], 8467, 8495, 8500, 8505, [8508, 8509], [8518, 8521], 8526, [8560, 8575], 8580, [9424, 9449], [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11377, [11379, 11380], [11382, 11389], 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, [11491, 11492], 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, [42651, 42653], 42787, 42789, 42791, 42793, 42795, 42797, [42799, 42801], 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, [42863, 42872], 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42894, 42897, [42899, 42901], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42927, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42963, 42965, 42967, 42969, [42994, 42996], 42998, [43e3, 43002], [43824, 43866], [43868, 43881], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], 67456, [67459, 67461], [67463, 67504], [67506, 67514], [68800, 68850], [71872, 71903], [93792, 93823], [119834, 119859], [119886, 119892], [119894, 119911], [119938, 119963], [119990, 119993], 119995, [119997, 120003], [120005, 120015], [120042, 120067], [120094, 120119], [120146, 120171], [120198, 120223], [120250, 120275], [120302, 120327], [120354, 120379], [120406, 120431], [120458, 120485], [120514, 120538], [120540, 120545], [120572, 120596], [120598, 120603], [120630, 120654], [120656, 120661], [120688, 120712], [120714, 120719], [120746, 120770], [120772, 120777], 120779, [122624, 122633], [122635, 122654], [122661, 122666], [122928, 122989], [125218, 125251]];
var Lowercase_default = _45;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Math.js
var _46 = [43, [60, 62], 94, 124, 126, 172, 177, 215, 247, [976, 978], 981, [1008, 1009], [1012, 1014], [1542, 1544], 8214, [8242, 8244], 8256, 8260, 8274, [8289, 8292], [8314, 8318], [8330, 8334], [8400, 8412], 8417, [8421, 8422], [8427, 8431], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, [8488, 8489], [8492, 8493], [8495, 8497], [8499, 8504], [8508, 8521], 8523, [8592, 8615], [8617, 8622], [8624, 8625], [8630, 8631], [8636, 8667], 8669, [8676, 8677], [8692, 8959], [8968, 8971], [8992, 8993], 9084, [9115, 9141], 9143, 9168, [9180, 9186], [9632, 9633], [9646, 9655], [9660, 9665], [9670, 9671], [9674, 9675], [9679, 9683], 9698, 9700, [9703, 9708], [9720, 9727], [9733, 9734], 9792, 9794, [9824, 9827], [9837, 9839], [10176, 10239], [10496, 11007], [11056, 11076], [11079, 11084], 64297, [65121, 65126], 65128, 65291, [65308, 65310], 65340, 65342, 65372, 65374, 65506, [65513, 65516], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705]];
var Math_default = _46;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Noncharacter_Code_Point.js
var _47 = [[64976, 65007], [65534, 65535], [131070, 131071], [196606, 196607], [262142, 262143], [327678, 327679], [393214, 393215], [458750, 458751], [524286, 524287], [589822, 589823], [655358, 655359], [720894, 720895], [786430, 786431], [851966, 851967], [917502, 917503], [983038, 983039], [1048574, 1048575], [1114110, 1114111]];
var Noncharacter_Code_Point_default = _47;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Alphabetic.js
var _48 = [837, [1456, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1623], [1625, 1631], 1648, [1750, 1756], [1761, 1764], [1767, 1768], 1773, 1809, [1840, 1855], [1958, 1968], [2070, 2071], [2075, 2083], [2085, 2087], [2089, 2092], [2260, 2271], [2275, 2281], [2288, 2307], [2362, 2363], [2366, 2380], [2382, 2383], [2389, 2391], [2402, 2403], [2433, 2435], [2494, 2500], [2503, 2504], [2507, 2508], 2519, [2530, 2531], [2561, 2563], [2622, 2626], [2631, 2632], [2635, 2636], 2641, [2672, 2673], 2677, [2689, 2691], [2750, 2757], [2759, 2761], [2763, 2764], [2786, 2787], [2810, 2812], [2817, 2819], [2878, 2884], [2887, 2888], [2891, 2892], [2902, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3020], 3031, [3072, 3076], [3134, 3140], [3142, 3144], [3146, 3148], [3157, 3158], [3170, 3171], [3201, 3203], [3262, 3268], [3270, 3272], [3274, 3276], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3390, 3396], [3398, 3400], [3402, 3404], 3415, [3426, 3427], [3457, 3459], [3535, 3540], 3542, [3544, 3551], [3570, 3571], 3633, [3636, 3642], 3661, 3761, [3764, 3769], [3771, 3772], 3789, [3953, 3971], [3981, 3991], [3993, 4028], [4139, 4150], 4152, [4155, 4158], [4182, 4185], [4190, 4192], [4194, 4196], [4199, 4205], [4209, 4212], [4226, 4237], 4239, [4250, 4253], [5906, 5907], [5938, 5939], [5970, 5971], [6002, 6003], [6070, 6088], [6277, 6278], 6313, [6432, 6443], [6448, 6456], [6679, 6683], [6741, 6750], [6753, 6772], [6847, 6848], [6860, 6862], [6912, 6916], [6965, 6979], [7040, 7042], [7073, 7081], [7084, 7085], [7143, 7153], [7204, 7222], [7655, 7668], [9398, 9449], [11744, 11775], [42612, 42619], [42654, 42655], 43010, 43019, [43043, 43047], [43136, 43137], [43188, 43203], 43205, 43263, [43302, 43306], [43335, 43346], [43392, 43395], [43444, 43455], 43493, [43561, 43574], 43587, [43596, 43597], [43643, 43645], 43696, [43698, 43700], [43703, 43704], 43710, [43755, 43759], 43765, [44003, 44010], 64286, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68900, 68903], [69291, 69292], [69632, 69634], [69688, 69701], [69747, 69748], [69760, 69762], [69808, 69816], 69826, [69888, 69890], [69927, 69938], [69957, 69958], [70016, 70018], [70067, 70079], [70094, 70095], [70188, 70196], 70199, 70206, 70209, [70367, 70376], [70400, 70403], [70462, 70468], [70471, 70472], [70475, 70476], 70487, [70498, 70499], [70709, 70721], [70723, 70725], [70832, 70849], [71087, 71093], [71096, 71102], [71132, 71133], [71216, 71230], 71232, [71339, 71349], [71453, 71466], [71724, 71736], [71984, 71989], [71991, 71992], [71995, 71996], 72e3, 72002, [72145, 72151], [72154, 72159], 72164, [72193, 72202], [72245, 72249], [72251, 72254], [72273, 72283], [72330, 72343], [72751, 72758], [72760, 72766], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73025], 73027, 73031, [73098, 73102], [73104, 73105], [73107, 73110], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73536], 94031, [94033, 94087], [94095, 94098], [94192, 94193], 113822, [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, 125255, [127280, 127305], [127312, 127337], [127344, 127369]];
var Other_Alphabetic_default = _48;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Default_Ignorable_Code_Point.js
var _49 = [847, [4447, 4448], [6068, 6069], 8293, 12644, 65440, [65520, 65528], 917504, [917506, 917535], [917632, 917759], [918e3, 921599]];
var Other_Default_Ignorable_Code_Point_default = _49;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Grapheme_Extend.js
var _50 = [2494, 2519, 2878, 2903, 3006, 3031, 3266, [3285, 3286], 3390, 3415, 3535, 3551, 6965, 8204, [12334, 12335], [65438, 65439], 70462, 70487, 70832, 70845, 71087, 71984, 119141, [119150, 119154], [917536, 917631]];
var Other_Grapheme_Extend_default = _50;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_ID_Continue.js
var _51 = [183, 903, [4969, 4977], 6618];
var Other_ID_Continue_default = _51;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_ID_Start.js
var _52 = [[6277, 6278], 8472, 8494, [12443, 12444]];
var Other_ID_Start_default = _52;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Lowercase.js
var _53 = [170, 186, [688, 696], [704, 705], [736, 740], 837, 890, 4348, [7468, 7530], 7544, [7579, 7615], 8305, 8319, [8336, 8348], [8560, 8575], [9424, 9449], [11388, 11389], [42652, 42653], 42864, [42994, 42996], [43e3, 43001], [43868, 43871], 43881, 67456, [67459, 67461], [67463, 67504], [67506, 67514], [122928, 122989]];
var Other_Lowercase_default = _53;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Math.js
var _54 = [94, [976, 978], 981, [1008, 1009], [1012, 1013], 8214, [8242, 8244], 8256, [8289, 8292], [8317, 8318], [8333, 8334], [8400, 8412], 8417, [8421, 8422], [8427, 8431], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, [8488, 8489], [8492, 8493], [8495, 8497], [8499, 8504], [8508, 8511], [8517, 8521], [8597, 8601], [8604, 8607], [8609, 8610], [8612, 8613], 8615, [8617, 8621], [8624, 8625], [8630, 8631], [8636, 8653], [8656, 8657], 8659, [8661, 8667], 8669, [8676, 8677], [8968, 8971], [9140, 9141], 9143, 9168, 9186, [9632, 9633], [9646, 9654], [9660, 9664], [9670, 9671], [9674, 9675], [9679, 9683], 9698, 9700, [9703, 9708], [9733, 9734], 9792, 9794, [9824, 9827], [9837, 9838], [10181, 10182], [10214, 10223], [10627, 10648], [10712, 10715], [10748, 10749], 65121, 65123, 65128, 65340, 65342, [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [120782, 120831], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651]];
var Other_Math_default = _54;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Uppercase.js
var _55 = [[8544, 8559], [9398, 9423], [127280, 127305], [127312, 127337], [127344, 127369]];
var Other_Uppercase_default = _55;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Pattern_Syntax.js
var _56 = [[33, 47], [58, 64], [91, 94], 96, [123, 126], [161, 167], 169, [171, 172], 174, [176, 177], 182, 187, 191, 215, 247, [8208, 8231], [8240, 8254], [8257, 8275], [8277, 8286], [8592, 9311], [9472, 10101], [10132, 11263], [11776, 11903], [12289, 12291], [12296, 12320], 12336, [64830, 64831], [65093, 65094]];
var Pattern_Syntax_default = _56;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Pattern_White_Space.js
var _57 = [[9, 13], 32, 133, [8206, 8207], [8232, 8233]];
var Pattern_White_Space_default = _57;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Prepended_Concatenation_Mark.js
var _58 = [[1536, 1541], 1757, 1807, [2192, 2193], 2274, 69821, 69837];
var Prepended_Concatenation_Mark_default = _58;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Quotation_Mark.js
var _59 = [34, 39, 171, 187, [8216, 8223], [8249, 8250], 11842, [12300, 12303], [12317, 12319], [65089, 65092], 65282, 65287, [65378, 65379]];
var Quotation_Mark_default = _59;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Radical.js
var _60 = [[11904, 11929], [11931, 12019], [12032, 12245]];
var Radical_default = _60;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Regional_Indicator.js
var _61 = [[127462, 127487]];
var Regional_Indicator_default = _61;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Sentence_Terminal.js
var _62 = [33, 46, 63, 1417, [1565, 1567], 1748, [1792, 1794], 2041, 2103, 2105, [2109, 2110], [2404, 2405], [4170, 4171], 4962, [4967, 4968], 5742, [5941, 5942], 6147, 6153, [6468, 6469], [6824, 6827], [7002, 7003], [7006, 7007], [7037, 7038], [7227, 7228], [7294, 7295], [8252, 8253], [8263, 8265], 11822, 11836, [11859, 11860], 12290, 42239, [42510, 42511], 42739, 42743, [43126, 43127], [43214, 43215], 43311, [43464, 43465], [43613, 43615], [43760, 43761], 44011, 65106, [65110, 65111], 65281, 65294, 65311, 65377, [68182, 68183], [69461, 69465], [69510, 69513], [69703, 69704], [69822, 69825], [69953, 69955], [70085, 70086], 70093, [70110, 70111], [70200, 70201], [70203, 70204], 70313, [70731, 70732], [71106, 71107], [71113, 71127], [71233, 71234], [71484, 71486], 72004, 72006, [72258, 72259], [72347, 72348], [72769, 72770], [73463, 73464], [73539, 73540], [92782, 92783], 92917, [92983, 92984], 92996, 93848, 113823, 121480];
var Sentence_Terminal_default = _62;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Soft_Dotted.js
var _63 = [[105, 106], 303, 585, 616, 669, 690, 1011, 1110, 1112, 7522, 7574, 7588, 7592, 7725, 7883, 8305, [8520, 8521], 11388, [119842, 119843], [119894, 119895], [119946, 119947], [119998, 119999], [120050, 120051], [120102, 120103], [120154, 120155], [120206, 120207], [120258, 120259], [120310, 120311], [120362, 120363], [120414, 120415], [120466, 120467], 122650, [122956, 122957], 122984];
var Soft_Dotted_default = _63;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Terminal_Punctuation.js
var _64 = [33, 44, 46, [58, 59], 63, 894, 903, 1417, 1475, 1548, 1563, [1565, 1567], 1748, [1792, 1802], 1804, [2040, 2041], [2096, 2110], 2142, [2404, 2405], [3674, 3675], 3848, [3853, 3858], [4170, 4171], [4961, 4968], 5742, [5867, 5869], [5941, 5942], [6100, 6102], 6106, [6146, 6149], [6152, 6153], [6468, 6469], [6824, 6827], [7002, 7003], [7005, 7007], [7037, 7038], [7227, 7231], [7294, 7295], [8252, 8253], [8263, 8265], 11822, 11836, 11841, 11852, [11854, 11855], [11859, 11860], [12289, 12290], [42238, 42239], [42509, 42511], [42739, 42743], [43126, 43127], [43214, 43215], 43311, [43463, 43465], [43613, 43615], 43743, [43760, 43761], 44011, [65104, 65106], [65108, 65111], 65281, 65292, 65294, [65306, 65307], 65311, 65377, 65380, 66463, 66512, 67671, 67871, [68182, 68183], [68336, 68341], [68410, 68415], [68505, 68508], [69461, 69465], [69510, 69513], [69703, 69709], [69822, 69825], [69953, 69955], [70085, 70086], 70093, [70110, 70111], [70200, 70204], 70313, [70731, 70733], [70746, 70747], [71106, 71109], [71113, 71127], [71233, 71234], [71484, 71486], 72004, 72006, [72258, 72259], [72347, 72348], [72353, 72354], [72769, 72771], 72817, [73463, 73464], [73539, 73540], [74864, 74868], [92782, 92783], 92917, [92983, 92985], 92996, [93847, 93848], 113823, [121479, 121482]];
var Terminal_Punctuation_default = _64;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Unified_Ideograph.js
var _65 = [[13312, 19903], [19968, 40959], [64014, 64015], 64017, [64019, 64020], 64031, 64033, [64035, 64036], [64039, 64041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [196608, 201546], [201552, 205743]];
var Unified_Ideograph_default = _65;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Uppercase.js
var _66 = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, 452, 455, 458, 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, 497, 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, [978, 980], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], 8450, 8455, [8459, 8461], [8464, 8466], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8496, 8499], [8510, 8511], 8517, [8544, 8559], 8579, [9398, 9423], [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [119808, 119833], [119860, 119885], [119912, 119937], 119964, [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119989], [120016, 120041], [120068, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120120, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120172, 120197], [120224, 120249], [120276, 120301], [120328, 120353], [120380, 120405], [120432, 120457], [120488, 120512], [120546, 120570], [120604, 120628], [120662, 120686], [120720, 120744], 120778, [125184, 125217], [127280, 127305], [127312, 127337], [127344, 127369]];
var Uppercase_default = _66;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Variation_Selector.js
var _67 = [[6155, 6157], 6159, [65024, 65039], [917760, 917999]];
var Variation_Selector_default = _67;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/White_Space.js
var _68 = [[9, 13], 32, 133, 160, 5760, [8192, 8202], [8232, 8233], 8239, 8287, 12288];
var White_Space_default = _68;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/XID_Continue.js
var _69 = [[48, 57], [65, 90], 95, [97, 122], 170, 181, 183, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [768, 884], [886, 887], [891, 893], 895, [902, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1155, 1159], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1488, 1514], [1519, 1522], [1552, 1562], [1568, 1641], [1646, 1747], [1749, 1756], [1759, 1768], [1770, 1788], 1791, [1808, 1866], [1869, 1969], [1984, 2037], 2042, 2045, [2048, 2093], [2112, 2139], [2144, 2154], [2160, 2183], [2185, 2190], [2200, 2273], [2275, 2403], [2406, 2415], [2417, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2545], 2556, 2558, [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2677], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2799], [2809, 2815], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2927], 2929, [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3055], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3200, 3203], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3406], [3412, 3415], [3423, 3427], [3430, 3439], [3450, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3571], [3585, 3642], [3648, 3662], [3664, 3673], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807], 3840, [3864, 3865], [3872, 3881], 3893, 3895, 3897, [3902, 3911], [3913, 3948], [3953, 3972], [3974, 3991], [3993, 4028], 4038, [4096, 4169], [4176, 4253], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4959], [4969, 4977], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5909], [5919, 5940], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6099], 6103, [6108, 6109], [6112, 6121], [6155, 6157], [6159, 6169], [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6459], [6470, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6656, 6683], [6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], 6823, [6832, 6845], [6847, 6862], [6912, 6988], [6992, 7001], [7019, 7027], [7040, 7155], [7168, 7223], [7232, 7241], [7245, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7376, 7378], [7380, 7418], [7424, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], [8255, 8256], 8276, 8305, 8319, [8336, 8348], [8400, 8412], 8417, [8421, 8432], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11647, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11775], [12293, 12295], [12321, 12335], [12337, 12341], [12344, 12348], [12353, 12438], [12441, 12442], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42539], [42560, 42607], [42612, 42621], [42623, 42737], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43047], 43052, [43072, 43123], [43136, 43205], [43216, 43225], [43232, 43255], 43259, [43261, 43309], [43312, 43347], [43360, 43388], [43392, 43456], [43471, 43481], [43488, 43518], [43520, 43574], [43584, 43597], [43600, 43609], [43616, 43638], [43642, 43714], [43739, 43741], [43744, 43759], [43762, 43766], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44010], [44012, 44013], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64605], [64612, 64829], [64848, 64911], [64914, 64967], [65008, 65017], [65024, 65039], [65056, 65071], [65075, 65076], [65101, 65103], 65137, 65139, 65143, 65145, 65147, 65149, [65151, 65276], [65296, 65305], [65313, 65338], 65343, [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], 66045, [66176, 66204], [66208, 66256], 66272, [66304, 66335], [66349, 66378], [66384, 66426], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], [68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], 68159, [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68326], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68903], [68912, 68921], [69248, 69289], [69291, 69292], [69296, 69297], [69373, 69404], 69415, [69424, 69456], [69488, 69509], [69552, 69572], [69600, 69622], [69632, 69702], [69734, 69749], [69759, 69818], 69826, [69840, 69864], [69872, 69881], [69888, 69940], [69942, 69951], [69956, 69959], [69968, 70003], 70006, [70016, 70084], [70089, 70092], [70094, 70106], 70108, [70144, 70161], [70163, 70199], [70206, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70378], [70384, 70393], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [70656, 70730], [70736, 70745], [70750, 70753], [70784, 70853], 70855, [70864, 70873], [71040, 71093], [71096, 71104], [71128, 71133], [71168, 71232], 71236, [71248, 71257], [71296, 71352], [71360, 71369], [71424, 71450], [71453, 71467], [71472, 71481], [71488, 71494], [71680, 71738], [71840, 71913], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72003], [72016, 72025], [72096, 72103], [72106, 72151], [72154, 72161], [72163, 72164], [72192, 72254], 72263, [72272, 72345], 72349, [72368, 72440], [72704, 72712], [72714, 72758], [72760, 72768], [72784, 72793], [72818, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129], [73440, 73462], [73472, 73488], [73490, 73530], [73534, 73538], [73552, 73561], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78912, 78933], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92784, 92862], [92864, 92873], [92880, 92909], [92912, 92916], [92928, 92982], [92992, 92995], [93008, 93017], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94177], [94179, 94180], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [120782, 120831], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123184, 123197], [123200, 123209], 123214, [123536, 123566], [123584, 123641], [124112, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125136, 125142], [125184, 125259], [125264, 125273], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], [917760, 917999]];
var XID_Continue_default = _69;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/XID_Start.js
var _70 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [880, 884], [886, 887], [891, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1488, 1514], [1519, 1522], [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], 3634, [3648, 3654], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], 3762, 3773, [3776, 3780], 3782, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6103, 6108, [6176, 6264], [6272, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], 6823, [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12293, 12295], [12321, 12329], [12337, 12341], [12344, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42735], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43488, 43492], [43494, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43741], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64605], [64612, 64829], [64848, 64911], [64914, 64967], [65008, 65017], 65137, 65139, 65143, 65145, 65147, 65149, [65151, 65276], [65313, 65338], [65345, 65370], [65382, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var XID_Start_default = _70;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/index.js
var General_Category_exports = {};
__export(General_Category_exports, {
  Cased_Letter: () => Cased_Letter_default,
  Close_Punctuation: () => Close_Punctuation_default,
  Connector_Punctuation: () => Connector_Punctuation_default,
  Control: () => Control_default,
  Currency_Symbol: () => Currency_Symbol_default,
  Dash_Punctuation: () => Dash_Punctuation_default,
  Decimal_Number: () => Decimal_Number_default,
  Enclosing_Mark: () => Enclosing_Mark_default,
  Final_Punctuation: () => Final_Punctuation_default,
  Format: () => Format_default,
  Initial_Punctuation: () => Initial_Punctuation_default,
  Letter: () => Letter_default,
  Letter_Number: () => Letter_Number_default,
  Line_Separator: () => Line_Separator_default,
  Lowercase_Letter: () => Lowercase_Letter_default,
  Mark: () => Mark_default,
  Math_Symbol: () => Math_Symbol_default,
  Modifier_Letter: () => Modifier_Letter_default,
  Modifier_Symbol: () => Modifier_Symbol_default,
  Nonspacing_Mark: () => Nonspacing_Mark_default,
  Number: () => Number_default,
  Open_Punctuation: () => Open_Punctuation_default,
  Other: () => Other_default,
  Other_Letter: () => Other_Letter_default,
  Other_Number: () => Other_Number_default,
  Other_Punctuation: () => Other_Punctuation_default,
  Other_Symbol: () => Other_Symbol_default,
  Paragraph_Separator: () => Paragraph_Separator_default,
  Private_Use: () => Private_Use_default,
  Punctuation: () => Punctuation_default,
  Separator: () => Separator_default,
  Space_Separator: () => Space_Separator_default,
  Spacing_Mark: () => Spacing_Mark_default,
  Surrogate: () => Surrogate_default,
  Symbol: () => Symbol_default,
  Titlecase_Letter: () => Titlecase_Letter_default,
  Unassigned: () => Unassigned_default,
  Uppercase_Letter: () => Uppercase_Letter_default
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Cased_Letter.js
var _71 = [[65, 90], [97, 122], 181, [192, 214], [216, 246], [248, 442], [444, 447], [452, 659], [661, 687], [880, 883], [886, 887], [891, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], [1376, 1416], [4256, 4293], 4295, 4301, [4304, 4346], [4349, 4351], [5024, 5109], [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], [7424, 7467], [7531, 7543], [7545, 7578], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8500], 8505, [8508, 8511], [8517, 8521], 8526, [8579, 8580], [11264, 11387], [11390, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [42560, 42605], [42624, 42651], [42786, 42863], [42865, 42887], [42891, 42894], [42896, 42954], [42960, 42961], 42963, [42965, 42969], [42997, 42998], 43002, [43824, 43866], [43872, 43880], [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [66560, 66639], [66736, 66771], [66776, 66811], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68736, 68786], [68800, 68850], [71840, 71903], [93760, 93823], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122633], [122635, 122654], [122661, 122666], [125184, 125251]];
var Cased_Letter_default = _71;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Close_Punctuation.js
var _72 = [41, 93, 125, 3899, 3901, 5788, 8262, 8318, 8334, 8969, 8971, 9002, 10089, 10091, 10093, 10095, 10097, 10099, 10101, 10182, 10215, 10217, 10219, 10221, 10223, 10628, 10630, 10632, 10634, 10636, 10638, 10640, 10642, 10644, 10646, 10648, 10713, 10715, 10749, 11811, 11813, 11815, 11817, 11862, 11864, 11866, 11868, 12297, 12299, 12301, 12303, 12305, 12309, 12311, 12313, 12315, [12318, 12319], 64830, 65048, 65078, 65080, 65082, 65084, 65086, 65088, 65090, 65092, 65096, 65114, 65116, 65118, 65289, 65341, 65373, 65376, 65379];
var Close_Punctuation_default = _72;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Connector_Punctuation.js
var _73 = [95, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];
var Connector_Punctuation_default = _73;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Control.js
var _74 = [[0, 31], [127, 159]];
var Control_default = _74;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Currency_Symbol.js
var _75 = [36, [162, 165], 1423, 1547, [2046, 2047], [2546, 2547], 2555, 2801, 3065, 3647, 6107, [8352, 8384], 43064, 65020, 65129, 65284, [65504, 65505], [65509, 65510], [73693, 73696], 123647, 126128];
var Currency_Symbol_default = _75;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Dash_Punctuation.js
var _76 = [45, 1418, 1470, 5120, 6150, [8208, 8213], 11799, 11802, [11834, 11835], 11840, 11869, 12316, 12336, 12448, [65073, 65074], 65112, 65123, 65293, 69293];
var Dash_Punctuation_default = _76;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Decimal_Number.js
var _77 = [[48, 57], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [66720, 66729], [68912, 68921], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71481], [71904, 71913], [72016, 72025], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [92768, 92777], [92864, 92873], [93008, 93017], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125264, 125273], [130032, 130041]];
var Decimal_Number_default = _77;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Enclosing_Mark.js
var _78 = [[1160, 1161], 6846, [8413, 8416], [8418, 8420], [42608, 42610]];
var Enclosing_Mark_default = _78;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Final_Punctuation.js
var _79 = [187, 8217, 8221, 8250, 11779, 11781, 11786, 11789, 11805, 11809];
var Final_Punctuation_default = _79;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Format.js
var _80 = [173, [1536, 1541], 1564, 1757, 1807, [2192, 2193], 2274, 6158, [8203, 8207], [8234, 8238], [8288, 8292], [8294, 8303], 65279, [65529, 65531], 69821, 69837, [78896, 78911], [113824, 113827], [119155, 119162], 917505, [917536, 917631]];
var Format_default = _80;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Initial_Punctuation.js
var _81 = [171, 8216, [8219, 8220], 8223, 8249, 11778, 11780, 11785, 11788, 11804, 11808];
var Initial_Punctuation_default = _81;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Letter.js
var _82 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1488, 1514], [1519, 1522], [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3654], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6103, 6108, [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], 6823, [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], 8526, [8579, 8580], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 11823, [12293, 12294], [12337, 12341], [12347, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42725], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43488, 43492], [43494, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43741], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66368], [66370, 66377], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var Letter_default = _82;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Letter_Number.js
var _83 = [[5870, 5872], [8544, 8578], [8581, 8584], 12295, [12321, 12329], [12344, 12346], [42726, 42735], [65856, 65908], 66369, 66378, [66513, 66517], [74752, 74862]];
var Letter_Number_default = _83;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Line_Separator.js
var _84 = [8232];
var Line_Separator_default = _84;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Lowercase_Letter.js
var _85 = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, [311, 312], 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, [396, 397], 402, 405, [409, 411], 414, 417, 419, 421, 424, [426, 427], 429, 432, 436, 438, [441, 442], [445, 447], 454, 457, 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, [563, 569], 572, [575, 576], 578, 583, 585, 587, 589, [591, 659], [661, 687], 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, [1019, 1020], [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1376, 1416], [4304, 4346], [4349, 4351], [5112, 5117], [7296, 7304], [7424, 7467], [7531, 7543], [7545, 7578], 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7837], 7839, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8458, [8462, 8463], 8467, 8495, 8500, 8505, [8508, 8509], [8518, 8521], 8526, 8580, [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11377, [11379, 11380], [11382, 11387], 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, [11491, 11492], 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, [42799, 42801], 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, [42865, 42872], 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42894, 42897, [42899, 42901], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42927, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42963, 42965, 42967, 42969, 42998, 43002, [43824, 43866], [43872, 43880], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [71872, 71903], [93792, 93823], [119834, 119859], [119886, 119892], [119894, 119911], [119938, 119963], [119990, 119993], 119995, [119997, 120003], [120005, 120015], [120042, 120067], [120094, 120119], [120146, 120171], [120198, 120223], [120250, 120275], [120302, 120327], [120354, 120379], [120406, 120431], [120458, 120485], [120514, 120538], [120540, 120545], [120572, 120596], [120598, 120603], [120630, 120654], [120656, 120661], [120688, 120712], [120714, 120719], [120746, 120770], [120772, 120777], 120779, [122624, 122633], [122635, 122654], [122661, 122666], [125218, 125251]];
var Lowercase_Letter_default = _85;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Mark.js
var _86 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2307], [2362, 2364], [2366, 2383], [2385, 2391], [2402, 2403], [2433, 2435], 2492, [2494, 2500], [2503, 2504], [2507, 2509], 2519, [2530, 2531], 2558, [2561, 2563], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2691], 2748, [2750, 2757], [2759, 2761], [2763, 2765], [2786, 2787], [2810, 2815], [2817, 2819], 2876, [2878, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3021], 3031, [3072, 3076], 3132, [3134, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3203], 3260, [3262, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3387, 3388], [3390, 3396], [3398, 3400], [3402, 3405], 3415, [3426, 3427], [3457, 3459], 3530, [3535, 3540], 3542, [3544, 3551], [3570, 3571], 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3953, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4139, 4158], [4182, 4185], [4190, 4192], [4194, 4196], [4199, 4205], [4209, 4212], [4226, 4237], 4239, [4250, 4253], [4957, 4959], [5906, 5909], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6443], [6448, 6459], [6679, 6683], [6741, 6750], [6752, 6780], 6783, [6832, 6862], [6912, 6916], [6964, 6980], [7019, 7027], [7040, 7042], [7073, 7085], [7142, 7155], [7204, 7223], [7376, 7378], [7380, 7400], 7405, 7412, [7415, 7417], [7616, 7679], [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43043, 43047], 43052, [43136, 43137], [43188, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43347], [43392, 43395], [43443, 43456], 43493, [43561, 43574], 43587, [43596, 43597], [43643, 43645], 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43755, 43759], [43765, 43766], [44003, 44010], [44012, 44013], 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], [69632, 69634], [69688, 69702], 69744, [69747, 69748], [69759, 69762], [69808, 69818], 69826, [69888, 69890], [69927, 69940], [69957, 69958], 70003, [70016, 70018], [70067, 70080], [70089, 70092], [70094, 70095], [70188, 70199], 70206, 70209, [70367, 70378], [70400, 70403], [70459, 70460], [70462, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70502, 70508], [70512, 70516], [70709, 70726], 70750, [70832, 70851], [71087, 71093], [71096, 71104], [71132, 71133], [71216, 71232], [71339, 71351], [71453, 71467], [71724, 71738], [71984, 71989], [71991, 71992], [71995, 71998], 72e3, [72002, 72003], [72145, 72151], [72154, 72160], 72164, [72193, 72202], [72243, 72249], [72251, 72254], 72263, [72273, 72283], [72330, 72345], [72751, 72758], [72760, 72767], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73098, 73102], [73104, 73105], [73107, 73111], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73538], 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94033, 94087], [94095, 94098], 94180, [94192, 94193], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917760, 917999]];
var Mark_default = _86;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Math_Symbol.js
var _87 = [43, [60, 62], 124, 126, 172, 177, 215, 247, 1014, [1542, 1544], 8260, 8274, [8314, 8316], [8330, 8332], 8472, [8512, 8516], 8523, [8592, 8596], [8602, 8603], 8608, 8611, 8614, 8622, [8654, 8655], 8658, 8660, [8692, 8959], [8992, 8993], 9084, [9115, 9139], [9180, 9185], 9655, 9665, [9720, 9727], 9839, [10176, 10180], [10183, 10213], [10224, 10239], [10496, 10626], [10649, 10711], [10716, 10747], [10750, 11007], [11056, 11076], [11079, 11084], 64297, 65122, [65124, 65126], 65291, [65308, 65310], 65372, 65374, 65506, [65513, 65516], 120513, 120539, 120571, 120597, 120629, 120655, 120687, 120713, 120745, 120771, [126704, 126705]];
var Math_Symbol_default = _87;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Modifier_Letter.js
var _88 = [[688, 705], [710, 721], [736, 740], 748, 750, 884, 890, 1369, 1600, [1765, 1766], [2036, 2037], 2042, 2074, 2084, 2088, 2249, 2417, 3654, 3782, 4348, 6103, 6211, 6823, [7288, 7293], [7468, 7530], 7544, [7579, 7615], 8305, 8319, [8336, 8348], [11388, 11389], 11631, 11823, 12293, [12337, 12341], 12347, [12445, 12446], [12540, 12542], 40981, [42232, 42237], 42508, 42623, [42652, 42653], [42775, 42783], 42864, 42888, [42994, 42996], [43e3, 43001], 43471, 43494, 43632, 43741, [43763, 43764], [43868, 43871], 43881, 65392, [65438, 65439], [67456, 67461], [67463, 67504], [67506, 67514], [92992, 92995], [94099, 94111], [94176, 94177], 94179, [110576, 110579], [110581, 110587], [110589, 110590], [122928, 122989], [123191, 123197], 124139, 125259];
var Modifier_Letter_default = _88;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Modifier_Symbol.js
var _89 = [94, 96, 168, 175, 180, 184, [706, 709], [722, 735], [741, 747], 749, [751, 767], 885, [900, 901], 2184, 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [12443, 12444], [42752, 42774], [42784, 42785], [42889, 42890], 43867, [43882, 43883], [64434, 64450], 65342, 65344, 65507, [127995, 127999]];
var Modifier_Symbol_default = _89;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Nonspacing_Mark.js
var _90 = [[768, 879], [1155, 1159], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3270, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6845], [6847, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8400, 8412], 8417, [8421, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12333], [12441, 12442], 42607, [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917760, 917999]];
var Nonspacing_Mark_default = _90;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Number.js
var _91 = [[48, 57], [178, 179], 185, [188, 190], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2548, 2553], [2662, 2671], [2790, 2799], [2918, 2927], [2930, 2935], [3046, 3058], [3174, 3183], [3192, 3198], [3302, 3311], [3416, 3422], [3430, 3448], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3891], [4160, 4169], [4240, 4249], [4969, 4988], [5870, 5872], [6112, 6121], [6128, 6137], [6160, 6169], [6470, 6479], [6608, 6618], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], 8304, [8308, 8313], [8320, 8329], [8528, 8578], [8581, 8585], [9312, 9371], [9450, 9471], [10102, 10131], 11517, 12295, [12321, 12329], [12344, 12346], [12690, 12693], [12832, 12841], [12872, 12879], [12881, 12895], [12928, 12937], [12977, 12991], [42528, 42537], [42726, 42735], [43056, 43061], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [65799, 65843], [65856, 65912], [65930, 65931], [66273, 66299], [66336, 66339], 66369, 66378, [66513, 66517], [66720, 66729], [67672, 67679], [67705, 67711], [67751, 67759], [67835, 67839], [67862, 67867], [68028, 68029], [68032, 68047], [68050, 68095], [68160, 68168], [68221, 68222], [68253, 68255], [68331, 68335], [68440, 68447], [68472, 68479], [68521, 68527], [68858, 68863], [68912, 68921], [69216, 69246], [69405, 69414], [69457, 69460], [69573, 69579], [69714, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70113, 70132], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71483], [71904, 71922], [72016, 72025], [72784, 72812], [73040, 73049], [73120, 73129], [73552, 73561], [73664, 73684], [74752, 74862], [92768, 92777], [92864, 92873], [93008, 93017], [93019, 93025], [93824, 93846], [119488, 119507], [119520, 119539], [119648, 119672], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125127, 125135], [125264, 125273], [126065, 126123], [126125, 126127], [126129, 126132], [126209, 126253], [126255, 126269], [127232, 127244], [130032, 130041]];
var Number_default = _91;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Open_Punctuation.js
var _92 = [40, 91, 123, 3898, 3900, 5787, 8218, 8222, 8261, 8317, 8333, 8968, 8970, 9001, 10088, 10090, 10092, 10094, 10096, 10098, 10100, 10181, 10214, 10216, 10218, 10220, 10222, 10627, 10629, 10631, 10633, 10635, 10637, 10639, 10641, 10643, 10645, 10647, 10712, 10714, 10748, 11810, 11812, 11814, 11816, 11842, 11861, 11863, 11865, 11867, 12296, 12298, 12300, 12302, 12304, 12308, 12310, 12312, 12314, 12317, 64831, 65047, 65077, 65079, 65081, 65083, 65085, 65087, 65089, 65091, 65095, 65113, 65115, 65117, 65288, 65339, 65371, 65375, 65378];
var Open_Punctuation_default = _92;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other.js
var _93 = [[0, 31], [127, 159], 173, [888, 889], [896, 899], 907, 909, 930, 1328, [1367, 1368], [1419, 1420], 1424, [1480, 1487], [1515, 1518], [1525, 1541], 1564, 1757, [1806, 1807], [1867, 1868], [1970, 1983], [2043, 2044], [2094, 2095], 2111, [2140, 2141], 2143, [2155, 2159], [2191, 2199], 2274, 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2679, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2802, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], [2936, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3067, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3190], 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3408, 3411], [3428, 3429], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3573, 3584], [3643, 3646], [3676, 3712], 3715, 3717, 3723, 3748, 3750, [3774, 3775], 3781, 3783, 3791, [3802, 3803], [3808, 3839], 3912, [3949, 3952], 3992, 4029, 4045, [4059, 4095], 4294, [4296, 4300], [4302, 4303], 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4989, 4991], [5018, 5023], [5110, 5111], [5118, 5119], [5789, 5791], [5881, 5887], [5910, 5918], [5943, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6110, 6111], [6122, 6127], [6138, 6143], 6158, [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6463], [6465, 6467], [6510, 6511], [6517, 6527], [6572, 6575], [6602, 6607], [6619, 6621], [6684, 6685], 6751, [6781, 6782], [6794, 6799], [6810, 6815], [6830, 6831], [6863, 6911], [6989, 6991], 7039, [7156, 7163], [7224, 7226], [7242, 7244], [7305, 7311], [7355, 7356], [7368, 7375], [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8133, [8148, 8149], 8156, [8176, 8177], 8181, 8191, [8203, 8207], [8234, 8238], [8288, 8303], [8306, 8307], 8335, [8349, 8351], [8385, 8399], [8433, 8447], [8588, 8591], [9255, 9279], [9291, 9311], [11124, 11125], 11158, [11508, 11512], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11633, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11870, 11903], 11930, [12020, 12031], [12246, 12271], [12284, 12287], 12352, [12439, 12440], [12544, 12548], 12592, 12687, [12772, 12783], 12831, [42125, 42127], [42183, 42191], [42540, 42559], [42744, 42751], [42955, 42959], 42962, 42964, [42970, 42993], [43053, 43055], [43066, 43071], [43128, 43135], [43206, 43213], [43226, 43231], [43348, 43358], [43389, 43391], 43470, [43482, 43485], 43519, [43575, 43583], [43598, 43599], [43610, 43611], [43715, 43738], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43884, 43887], [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 63743], [64110, 64111], [64218, 64255], [64263, 64274], [64280, 64284], 64311, 64317, 64319, 64322, 64325, [64451, 64466], [64912, 64913], [64968, 64974], [64976, 65007], [65050, 65055], 65107, 65127, [65132, 65135], 65141, [65277, 65280], [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65503], 65511, [65519, 65531], [65534, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65791], [65795, 65798], [65844, 65846], 65935, [65949, 65951], [65953, 65999], [66046, 66175], [66205, 66207], [66257, 66271], [66300, 66303], [66340, 66348], [66379, 66383], [66427, 66431], 66462, [66500, 66503], [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66926], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], 67670, [67743, 67750], [67760, 67807], 67827, [67830, 67834], [67868, 67870], [67898, 67902], [67904, 67967], [68024, 68027], [68048, 68049], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68169, 68175], [68185, 68191], [68256, 68287], [68327, 68330], [68343, 68351], [68406, 68408], [68438, 68439], [68467, 68471], [68498, 68504], [68509, 68520], [68528, 68607], [68681, 68735], [68787, 68799], [68851, 68857], [68904, 68911], [68922, 69215], 69247, 69290, [69294, 69295], [69298, 69372], [69416, 69423], [69466, 69487], [69514, 69551], [69580, 69599], [69623, 69631], [69710, 69713], [69750, 69758], 69821, [69827, 69839], [69865, 69871], [69882, 69887], 69941, [69960, 69967], [70007, 70015], 70112, [70133, 70143], 70162, [70210, 70271], 70279, 70281, 70286, 70302, [70314, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], 70748, [70754, 70783], [70856, 70863], [70874, 71039], [71094, 71095], [71134, 71167], [71237, 71247], [71258, 71263], [71277, 71295], [71354, 71359], [71370, 71423], [71451, 71452], [71468, 71471], [71495, 71679], [71740, 71839], [71923, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72007, 72015], [72026, 72095], [72104, 72105], [72152, 72153], [72165, 72191], [72264, 72271], [72355, 72367], [72441, 72447], [72458, 72703], 72713, 72759, [72774, 72783], [72813, 72815], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73465, 73471], 73489, [73531, 73533], [73562, 73647], [73649, 73663], [73714, 73726], [74650, 74751], 74863, [74869, 74879], [75076, 77711], [77811, 77823], [78896, 78911], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92781], 92863, [92874, 92879], [92910, 92911], [92918, 92927], [92998, 93007], 93018, 93026, [93048, 93052], [93072, 93759], [93851, 93951], [94027, 94030], [94088, 94094], [94112, 94175], [94181, 94191], [94194, 94207], [100344, 100351], [101590, 101631], [101641, 110575], 110580, 110588, 110591, [110883, 110897], [110899, 110927], [110931, 110932], [110934, 110947], [110952, 110959], [111356, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113819], [113824, 118527], [118574, 118575], [118599, 118607], [118724, 118783], [119030, 119039], [119079, 119080], [119155, 119162], [119275, 119295], [119366, 119487], [119508, 119519], [119540, 119551], [119639, 119647], [119673, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], [120780, 120781], [121484, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123216, 123535], [123567, 123583], [123642, 123646], [123648, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125126], [125143, 125183], [125260, 125263], [125274, 125277], [125280, 126064], [126133, 126208], [126270, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 126703], [126706, 126975], [127020, 127023], [127124, 127135], [127151, 127152], 127168, 127184, [127222, 127231], [127406, 127461], [127491, 127503], [127548, 127551], [127561, 127567], [127570, 127583], [127590, 127743], [128728, 128731], [128749, 128751], [128765, 128767], [128887, 128890], [128986, 128991], [129004, 129007], [129009, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129199], [129202, 129279], [129620, 129631], [129646, 129647], [129661, 129663], [129673, 129679], 129726, [129734, 129741], [129756, 129759], [129769, 129775], [129785, 129791], 129939, [129995, 130031], [130042, 131071], [173792, 173823], [177978, 177983], [178206, 178207], [183970, 183983], [191457, 194559], [195102, 196607], [201547, 201551], [205744, 917759], [918e3, 1114111]];
var Other_default = _93;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Letter.js
var _94 = [170, 186, 443, [448, 451], 660, [1488, 1514], [1519, 1522], [1568, 1599], [1601, 1610], [1646, 1647], [1649, 1747], 1749, [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2048, 2069], [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2248], [2308, 2361], 2365, 2384, [2392, 2401], [2418, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3653], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4352, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6108, [6176, 6210], [6212, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7287], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [8501, 8504], [11568, 11623], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 12294, 12348, [12353, 12438], 12447, [12449, 12538], 12543, [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 40980], [40982, 42124], [42192, 42231], [42240, 42507], [42512, 42527], [42538, 42539], 42606, [42656, 42725], 42895, 42999, [43003, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], [43488, 43492], [43495, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43631], [43633, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43740], [43744, 43754], 43762, [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43968, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65382, 65391], [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66368], [66370, 66377], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66640, 66717], [66816, 66855], [66864, 66915], [67072, 67382], [67392, 67413], [67424, 67431], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [93027, 93047], [93053, 93071], [93952, 94026], 94032, [94208, 100343], [100352, 101589], [101632, 101640], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 122634, [123136, 123180], 123214, [123536, 123565], [123584, 123627], [124112, 124138], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var Other_Letter_default = _94;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Number.js
var _95 = [[178, 179], 185, [188, 190], [2548, 2553], [2930, 2935], [3056, 3058], [3192, 3198], [3416, 3422], [3440, 3448], [3882, 3891], [4969, 4988], [6128, 6137], 6618, 8304, [8308, 8313], [8320, 8329], [8528, 8543], 8585, [9312, 9371], [9450, 9471], [10102, 10131], 11517, [12690, 12693], [12832, 12841], [12872, 12879], [12881, 12895], [12928, 12937], [12977, 12991], [43056, 43061], [65799, 65843], [65909, 65912], [65930, 65931], [66273, 66299], [66336, 66339], [67672, 67679], [67705, 67711], [67751, 67759], [67835, 67839], [67862, 67867], [68028, 68029], [68032, 68047], [68050, 68095], [68160, 68168], [68221, 68222], [68253, 68255], [68331, 68335], [68440, 68447], [68472, 68479], [68521, 68527], [68858, 68863], [69216, 69246], [69405, 69414], [69457, 69460], [69573, 69579], [69714, 69733], [70113, 70132], [71482, 71483], [71914, 71922], [72794, 72812], [73664, 73684], [93019, 93025], [93824, 93846], [119488, 119507], [119520, 119539], [119648, 119672], [125127, 125135], [126065, 126123], [126125, 126127], [126129, 126132], [126209, 126253], [126255, 126269], [127232, 127244]];
var Other_Number_default = _95;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Punctuation.js
var _96 = [[33, 35], [37, 39], 42, 44, [46, 47], [58, 59], [63, 64], 92, 161, 167, [182, 183], 191, 894, 903, [1370, 1375], 1417, 1472, 1475, 1478, [1523, 1524], [1545, 1546], [1548, 1549], 1563, [1565, 1567], [1642, 1645], 1748, [1792, 1805], [2039, 2041], [2096, 2110], 2142, [2404, 2405], 2416, 2557, 2678, 2800, 3191, 3204, 3572, 3663, [3674, 3675], [3844, 3858], 3860, 3973, [4048, 4052], [4057, 4058], [4170, 4175], 4347, [4960, 4968], 5742, [5867, 5869], [5941, 5942], [6100, 6102], [6104, 6106], [6144, 6149], [6151, 6154], [6468, 6469], [6686, 6687], [6816, 6822], [6824, 6829], [7002, 7008], [7037, 7038], [7164, 7167], [7227, 7231], [7294, 7295], [7360, 7367], 7379, [8214, 8215], [8224, 8231], [8240, 8248], [8251, 8254], [8257, 8259], [8263, 8273], 8275, [8277, 8286], [11513, 11516], [11518, 11519], 11632, [11776, 11777], [11782, 11784], 11787, [11790, 11798], [11800, 11801], 11803, [11806, 11807], [11818, 11822], [11824, 11833], [11836, 11839], 11841, [11843, 11855], [11858, 11860], [12289, 12291], 12349, 12539, [42238, 42239], [42509, 42511], 42611, 42622, [42738, 42743], [43124, 43127], [43214, 43215], [43256, 43258], 43260, [43310, 43311], 43359, [43457, 43469], [43486, 43487], [43612, 43615], [43742, 43743], [43760, 43761], 44011, [65040, 65046], 65049, 65072, [65093, 65094], [65097, 65100], [65104, 65106], [65108, 65111], [65119, 65121], 65128, [65130, 65131], [65281, 65283], [65285, 65287], 65290, 65292, [65294, 65295], [65306, 65307], [65311, 65312], 65340, 65377, [65380, 65381], [65792, 65794], 66463, 66512, 66927, 67671, 67871, 67903, [68176, 68184], 68223, [68336, 68342], [68409, 68415], [68505, 68508], [69461, 69465], [69510, 69513], [69703, 69709], [69819, 69820], [69822, 69825], [69952, 69955], [70004, 70005], [70085, 70088], 70093, 70107, [70109, 70111], [70200, 70205], 70313, [70731, 70735], [70746, 70747], 70749, 70854, [71105, 71127], [71233, 71235], [71264, 71276], 71353, [71484, 71486], 71739, [72004, 72006], 72162, [72255, 72262], [72346, 72348], [72350, 72354], [72448, 72457], [72769, 72773], [72816, 72817], [73463, 73464], [73539, 73551], 73727, [74864, 74868], [77809, 77810], [92782, 92783], 92917, [92983, 92987], 92996, [93847, 93850], 94178, 113823, [121479, 121483], [125278, 125279]];
var Other_Punctuation_default = _96;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Symbol.js
var _97 = [166, 169, 174, 176, 1154, [1421, 1422], [1550, 1551], 1758, 1769, [1789, 1790], 2038, 2554, 2928, [3059, 3064], 3066, 3199, 3407, 3449, [3841, 3843], 3859, [3861, 3863], [3866, 3871], 3892, 3894, 3896, [4030, 4037], [4039, 4044], [4046, 4047], [4053, 4056], [4254, 4255], [5008, 5017], 5741, 6464, [6622, 6655], [7009, 7018], [7028, 7036], [8448, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8471], [8478, 8483], 8485, 8487, 8489, 8494, [8506, 8507], 8522, [8524, 8525], 8527, [8586, 8587], [8597, 8601], [8604, 8607], [8609, 8610], [8612, 8613], [8615, 8621], [8623, 8653], [8656, 8657], 8659, [8661, 8691], [8960, 8967], [8972, 8991], [8994, 9e3], [9003, 9083], [9085, 9114], [9140, 9179], [9186, 9254], [9280, 9290], [9372, 9449], [9472, 9654], [9656, 9664], [9666, 9719], [9728, 9838], [9840, 10087], [10132, 10175], [10240, 10495], [11008, 11055], [11077, 11078], [11085, 11123], [11126, 11157], [11159, 11263], [11493, 11498], [11856, 11857], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], 12292, [12306, 12307], 12320, [12342, 12343], [12350, 12351], [12688, 12689], [12694, 12703], [12736, 12771], [12800, 12830], [12842, 12871], 12880, [12896, 12927], [12938, 12976], [12992, 13311], [19904, 19967], [42128, 42182], [43048, 43051], [43062, 43063], 43065, [43639, 43641], [64832, 64847], 64975, [65021, 65023], 65508, 65512, [65517, 65518], [65532, 65533], [65847, 65855], [65913, 65929], [65932, 65934], [65936, 65948], 65952, [66e3, 66044], [67703, 67704], 68296, 71487, [73685, 73692], [73697, 73713], [92988, 92991], 92997, 113820, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119552, 119638], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121478], 123215, 126124, 126254, [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127245, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 127994], [128e3, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994]];
var Other_Symbol_default = _97;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Paragraph_Separator.js
var _98 = [8233];
var Paragraph_Separator_default = _98;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Private_Use.js
var _99 = [[57344, 63743], [983040, 1048573], [1048576, 1114109]];
var Private_Use_default = _99;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Punctuation.js
var _100 = [[33, 35], [37, 42], [44, 47], [58, 59], [63, 64], [91, 93], 95, 123, 125, 161, 167, 171, [182, 183], 187, 191, 894, 903, [1370, 1375], [1417, 1418], 1470, 1472, 1475, 1478, [1523, 1524], [1545, 1546], [1548, 1549], 1563, [1565, 1567], [1642, 1645], 1748, [1792, 1805], [2039, 2041], [2096, 2110], 2142, [2404, 2405], 2416, 2557, 2678, 2800, 3191, 3204, 3572, 3663, [3674, 3675], [3844, 3858], 3860, [3898, 3901], 3973, [4048, 4052], [4057, 4058], [4170, 4175], 4347, [4960, 4968], 5120, 5742, [5787, 5788], [5867, 5869], [5941, 5942], [6100, 6102], [6104, 6106], [6144, 6154], [6468, 6469], [6686, 6687], [6816, 6822], [6824, 6829], [7002, 7008], [7037, 7038], [7164, 7167], [7227, 7231], [7294, 7295], [7360, 7367], 7379, [8208, 8231], [8240, 8259], [8261, 8273], [8275, 8286], [8317, 8318], [8333, 8334], [8968, 8971], [9001, 9002], [10088, 10101], [10181, 10182], [10214, 10223], [10627, 10648], [10712, 10715], [10748, 10749], [11513, 11516], [11518, 11519], 11632, [11776, 11822], [11824, 11855], [11858, 11869], [12289, 12291], [12296, 12305], [12308, 12319], 12336, 12349, 12448, 12539, [42238, 42239], [42509, 42511], 42611, 42622, [42738, 42743], [43124, 43127], [43214, 43215], [43256, 43258], 43260, [43310, 43311], 43359, [43457, 43469], [43486, 43487], [43612, 43615], [43742, 43743], [43760, 43761], 44011, [64830, 64831], [65040, 65049], [65072, 65106], [65108, 65121], 65123, 65128, [65130, 65131], [65281, 65283], [65285, 65290], [65292, 65295], [65306, 65307], [65311, 65312], [65339, 65341], 65343, 65371, 65373, [65375, 65381], [65792, 65794], 66463, 66512, 66927, 67671, 67871, 67903, [68176, 68184], 68223, [68336, 68342], [68409, 68415], [68505, 68508], 69293, [69461, 69465], [69510, 69513], [69703, 69709], [69819, 69820], [69822, 69825], [69952, 69955], [70004, 70005], [70085, 70088], 70093, 70107, [70109, 70111], [70200, 70205], 70313, [70731, 70735], [70746, 70747], 70749, 70854, [71105, 71127], [71233, 71235], [71264, 71276], 71353, [71484, 71486], 71739, [72004, 72006], 72162, [72255, 72262], [72346, 72348], [72350, 72354], [72448, 72457], [72769, 72773], [72816, 72817], [73463, 73464], [73539, 73551], 73727, [74864, 74868], [77809, 77810], [92782, 92783], 92917, [92983, 92987], 92996, [93847, 93850], 94178, 113823, [121479, 121483], [125278, 125279]];
var Punctuation_default = _100;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Separator.js
var _101 = [32, 160, 5760, [8192, 8202], [8232, 8233], 8239, 8287, 12288];
var Separator_default = _101;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Space_Separator.js
var _102 = [32, 160, 5760, [8192, 8202], 8239, 8287, 12288];
var Space_Separator_default = _102;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Spacing_Mark.js
var _103 = [2307, 2363, [2366, 2368], [2377, 2380], [2382, 2383], [2434, 2435], [2494, 2496], [2503, 2504], [2507, 2508], 2519, 2563, [2622, 2624], 2691, [2750, 2752], 2761, [2763, 2764], [2818, 2819], 2878, 2880, [2887, 2888], [2891, 2892], 2903, [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], 3031, [3073, 3075], [3137, 3140], [3202, 3203], 3262, [3264, 3268], [3271, 3272], [3274, 3275], [3285, 3286], 3315, [3330, 3331], [3390, 3392], [3398, 3400], [3402, 3404], 3415, [3458, 3459], [3535, 3537], [3544, 3551], [3570, 3571], [3902, 3903], 3967, [4139, 4140], 4145, 4152, [4155, 4156], [4182, 4183], [4194, 4196], [4199, 4205], [4227, 4228], [4231, 4236], 4239, [4250, 4252], 5909, 5940, 6070, [6078, 6085], [6087, 6088], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6681, 6682], 6741, 6743, 6753, [6755, 6756], [6765, 6770], 6916, 6965, 6971, [6973, 6977], [6979, 6980], 7042, 7073, [7078, 7079], 7082, 7143, [7146, 7148], 7150, [7154, 7155], [7204, 7211], [7220, 7221], 7393, 7415, [12334, 12335], [43043, 43044], 43047, [43136, 43137], [43188, 43203], [43346, 43347], 43395, [43444, 43445], [43450, 43451], [43454, 43456], [43567, 43568], [43571, 43572], 43597, 43643, 43645, 43755, [43758, 43759], 43765, [44003, 44004], [44006, 44007], [44009, 44010], 44012, 69632, 69634, 69762, [69808, 69810], [69815, 69816], 69932, [69957, 69958], 70018, [70067, 70069], [70079, 70080], 70094, [70188, 70190], [70194, 70195], 70197, [70368, 70370], [70402, 70403], [70462, 70463], [70465, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70709, 70711], [70720, 70721], 70725, [70832, 70834], 70841, [70843, 70846], 70849, [71087, 71089], [71096, 71099], 71102, [71216, 71218], [71227, 71228], 71230, 71340, [71342, 71343], 71350, [71456, 71457], 71462, [71724, 71726], 71736, [71984, 71989], [71991, 71992], 71997, 72e3, 72002, [72145, 72147], [72156, 72159], 72164, 72249, [72279, 72280], 72343, 72751, 72766, 72873, 72881, 72884, [73098, 73102], [73107, 73108], 73110, [73461, 73462], 73475, [73524, 73525], [73534, 73535], 73537, [94033, 94087], [94192, 94193], [119141, 119142], [119149, 119154]];
var Spacing_Mark_default = _103;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Surrogate.js
var _104 = [[55296, 57343]];
var Surrogate_default = _104;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Symbol.js
var _105 = [36, 43, [60, 62], 94, 96, 124, 126, [162, 166], [168, 169], 172, [174, 177], 180, 184, 215, 247, [706, 709], [722, 735], [741, 747], 749, [751, 767], 885, [900, 901], 1014, 1154, [1421, 1423], [1542, 1544], 1547, [1550, 1551], 1758, 1769, [1789, 1790], 2038, [2046, 2047], 2184, [2546, 2547], [2554, 2555], 2801, 2928, [3059, 3066], 3199, 3407, 3449, 3647, [3841, 3843], 3859, [3861, 3863], [3866, 3871], 3892, 3894, 3896, [4030, 4037], [4039, 4044], [4046, 4047], [4053, 4056], [4254, 4255], [5008, 5017], 5741, 6107, 6464, [6622, 6655], [7009, 7018], [7028, 7036], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], 8260, 8274, [8314, 8316], [8330, 8332], [8352, 8384], [8448, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8472], [8478, 8483], 8485, 8487, 8489, 8494, [8506, 8507], [8512, 8516], [8522, 8525], 8527, [8586, 8587], [8592, 8967], [8972, 9e3], [9003, 9254], [9280, 9290], [9372, 9449], [9472, 10087], [10132, 10180], [10183, 10213], [10224, 10626], [10649, 10711], [10716, 10747], [10750, 11123], [11126, 11157], [11159, 11263], [11493, 11498], [11856, 11857], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], 12292, [12306, 12307], 12320, [12342, 12343], [12350, 12351], [12443, 12444], [12688, 12689], [12694, 12703], [12736, 12771], [12800, 12830], [12842, 12871], 12880, [12896, 12927], [12938, 12976], [12992, 13311], [19904, 19967], [42128, 42182], [42752, 42774], [42784, 42785], [42889, 42890], [43048, 43051], [43062, 43065], [43639, 43641], 43867, [43882, 43883], 64297, [64434, 64450], [64832, 64847], 64975, [65020, 65023], 65122, [65124, 65126], 65129, 65284, 65291, [65308, 65310], 65342, 65344, 65372, 65374, [65504, 65510], [65512, 65518], [65532, 65533], [65847, 65855], [65913, 65929], [65932, 65934], [65936, 65948], 65952, [66e3, 66044], [67703, 67704], 68296, 71487, [73685, 73713], [92988, 92991], 92997, 113820, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119552, 119638], 120513, 120539, 120571, 120597, 120629, 120655, 120687, 120713, 120745, 120771, [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121478], 123215, 123647, 126124, 126128, 126254, [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127245, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994]];
var Symbol_default = _105;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Titlecase_Letter.js
var _106 = [453, 456, 459, 498, [8072, 8079], [8088, 8095], [8104, 8111], 8124, 8140, 8188];
var Titlecase_Letter_default = _106;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Unassigned.js
var _107 = [[888, 889], [896, 899], 907, 909, 930, 1328, [1367, 1368], [1419, 1420], 1424, [1480, 1487], [1515, 1518], [1525, 1535], 1806, [1867, 1868], [1970, 1983], [2043, 2044], [2094, 2095], 2111, [2140, 2141], 2143, [2155, 2159], 2191, [2194, 2199], 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2679, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2802, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], [2936, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3067, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3190], 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3408, 3411], [3428, 3429], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3573, 3584], [3643, 3646], [3676, 3712], 3715, 3717, 3723, 3748, 3750, [3774, 3775], 3781, 3783, 3791, [3802, 3803], [3808, 3839], 3912, [3949, 3952], 3992, 4029, 4045, [4059, 4095], 4294, [4296, 4300], [4302, 4303], 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4989, 4991], [5018, 5023], [5110, 5111], [5118, 5119], [5789, 5791], [5881, 5887], [5910, 5918], [5943, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6110, 6111], [6122, 6127], [6138, 6143], [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6463], [6465, 6467], [6510, 6511], [6517, 6527], [6572, 6575], [6602, 6607], [6619, 6621], [6684, 6685], 6751, [6781, 6782], [6794, 6799], [6810, 6815], [6830, 6831], [6863, 6911], [6989, 6991], 7039, [7156, 7163], [7224, 7226], [7242, 7244], [7305, 7311], [7355, 7356], [7368, 7375], [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8133, [8148, 8149], 8156, [8176, 8177], 8181, 8191, 8293, [8306, 8307], 8335, [8349, 8351], [8385, 8399], [8433, 8447], [8588, 8591], [9255, 9279], [9291, 9311], [11124, 11125], 11158, [11508, 11512], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11633, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11870, 11903], 11930, [12020, 12031], [12246, 12271], [12284, 12287], 12352, [12439, 12440], [12544, 12548], 12592, 12687, [12772, 12783], 12831, [42125, 42127], [42183, 42191], [42540, 42559], [42744, 42751], [42955, 42959], 42962, 42964, [42970, 42993], [43053, 43055], [43066, 43071], [43128, 43135], [43206, 43213], [43226, 43231], [43348, 43358], [43389, 43391], 43470, [43482, 43485], 43519, [43575, 43583], [43598, 43599], [43610, 43611], [43715, 43738], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43884, 43887], [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 55295], [64110, 64111], [64218, 64255], [64263, 64274], [64280, 64284], 64311, 64317, 64319, 64322, 64325, [64451, 64466], [64912, 64913], [64968, 64974], [64976, 65007], [65050, 65055], 65107, 65127, [65132, 65135], 65141, [65277, 65278], 65280, [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65503], 65511, [65519, 65528], [65534, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65791], [65795, 65798], [65844, 65846], 65935, [65949, 65951], [65953, 65999], [66046, 66175], [66205, 66207], [66257, 66271], [66300, 66303], [66340, 66348], [66379, 66383], [66427, 66431], 66462, [66500, 66503], [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66926], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], 67670, [67743, 67750], [67760, 67807], 67827, [67830, 67834], [67868, 67870], [67898, 67902], [67904, 67967], [68024, 68027], [68048, 68049], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68169, 68175], [68185, 68191], [68256, 68287], [68327, 68330], [68343, 68351], [68406, 68408], [68438, 68439], [68467, 68471], [68498, 68504], [68509, 68520], [68528, 68607], [68681, 68735], [68787, 68799], [68851, 68857], [68904, 68911], [68922, 69215], 69247, 69290, [69294, 69295], [69298, 69372], [69416, 69423], [69466, 69487], [69514, 69551], [69580, 69599], [69623, 69631], [69710, 69713], [69750, 69758], [69827, 69836], [69838, 69839], [69865, 69871], [69882, 69887], 69941, [69960, 69967], [70007, 70015], 70112, [70133, 70143], 70162, [70210, 70271], 70279, 70281, 70286, 70302, [70314, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], 70748, [70754, 70783], [70856, 70863], [70874, 71039], [71094, 71095], [71134, 71167], [71237, 71247], [71258, 71263], [71277, 71295], [71354, 71359], [71370, 71423], [71451, 71452], [71468, 71471], [71495, 71679], [71740, 71839], [71923, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72007, 72015], [72026, 72095], [72104, 72105], [72152, 72153], [72165, 72191], [72264, 72271], [72355, 72367], [72441, 72447], [72458, 72703], 72713, 72759, [72774, 72783], [72813, 72815], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73465, 73471], 73489, [73531, 73533], [73562, 73647], [73649, 73663], [73714, 73726], [74650, 74751], 74863, [74869, 74879], [75076, 77711], [77811, 77823], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92781], 92863, [92874, 92879], [92910, 92911], [92918, 92927], [92998, 93007], 93018, 93026, [93048, 93052], [93072, 93759], [93851, 93951], [94027, 94030], [94088, 94094], [94112, 94175], [94181, 94191], [94194, 94207], [100344, 100351], [101590, 101631], [101641, 110575], 110580, 110588, 110591, [110883, 110897], [110899, 110927], [110931, 110932], [110934, 110947], [110952, 110959], [111356, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113819], [113828, 118527], [118574, 118575], [118599, 118607], [118724, 118783], [119030, 119039], [119079, 119080], [119275, 119295], [119366, 119487], [119508, 119519], [119540, 119551], [119639, 119647], [119673, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], [120780, 120781], [121484, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123216, 123535], [123567, 123583], [123642, 123646], [123648, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125126], [125143, 125183], [125260, 125263], [125274, 125277], [125280, 126064], [126133, 126208], [126270, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 126703], [126706, 126975], [127020, 127023], [127124, 127135], [127151, 127152], 127168, 127184, [127222, 127231], [127406, 127461], [127491, 127503], [127548, 127551], [127561, 127567], [127570, 127583], [127590, 127743], [128728, 128731], [128749, 128751], [128765, 128767], [128887, 128890], [128986, 128991], [129004, 129007], [129009, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129199], [129202, 129279], [129620, 129631], [129646, 129647], [129661, 129663], [129673, 129679], 129726, [129734, 129741], [129756, 129759], [129769, 129775], [129785, 129791], 129939, [129995, 130031], [130042, 131071], [173792, 173823], [177978, 177983], [178206, 178207], [183970, 183983], [191457, 194559], [195102, 196607], [201547, 201551], [205744, 917504], [917506, 917535], [917632, 917759], [918e3, 983039], [1048574, 1048575], [1114110, 1114111]];
var Unassigned_default = _107;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Uppercase_Letter.js
var _108 = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, 452, 455, 458, 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, 497, 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, [978, 980], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], 8450, 8455, [8459, 8461], [8464, 8466], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8496, 8499], [8510, 8511], 8517, 8579, [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [119808, 119833], [119860, 119885], [119912, 119937], 119964, [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119989], [120016, 120041], [120068, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120120, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120172, 120197], [120224, 120249], [120276, 120301], [120328, 120353], [120380, 120405], [120432, 120457], [120488, 120512], [120546, 120570], [120604, 120628], [120662, 120686], [120720, 120744], 120778, [125184, 125217]];
var Uppercase_Letter_default = _108;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/index.js
var Bidi_Class_exports = {};
__export(Bidi_Class_exports, {
  Arabic_Letter: () => Arabic_Letter_default,
  Arabic_Number: () => Arabic_Number_default,
  Boundary_Neutral: () => Boundary_Neutral_default,
  Common_Separator: () => Common_Separator_default,
  European_Number: () => European_Number_default,
  European_Separator: () => European_Separator_default,
  European_Terminator: () => European_Terminator_default,
  First_Strong_Isolate: () => First_Strong_Isolate_default,
  Left_To_Right: () => Left_To_Right_default,
  Left_To_Right_Embedding: () => Left_To_Right_Embedding_default,
  Left_To_Right_Isolate: () => Left_To_Right_Isolate_default,
  Left_To_Right_Override: () => Left_To_Right_Override_default,
  Nonspacing_Mark: () => Nonspacing_Mark_default2,
  Other_Neutral: () => Other_Neutral_default,
  Paragraph_Separator: () => Paragraph_Separator_default2,
  Pop_Directional_Format: () => Pop_Directional_Format_default,
  Pop_Directional_Isolate: () => Pop_Directional_Isolate_default,
  Right_To_Left: () => Right_To_Left_default,
  Right_To_Left_Embedding: () => Right_To_Left_Embedding_default,
  Right_To_Left_Isolate: () => Right_To_Left_Isolate_default,
  Right_To_Left_Override: () => Right_To_Left_Override_default,
  Segment_Separator: () => Segment_Separator_default,
  White_Space: () => White_Space_default2
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Arabic_Letter.js
var _109 = [1544, 1547, 1549, [1563, 1610], [1645, 1647], [1649, 1749], [1765, 1766], [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], 1969, [2144, 2154], [2160, 2190], [2208, 2249], [64336, 64450], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65136, 65140], [65142, 65276], [68864, 68899], [69424, 69445], [69457, 69465], [126065, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651]];
var Arabic_Letter_default = _109;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Arabic_Number.js
var _110 = [[1536, 1541], [1632, 1641], [1643, 1644], 1757, [2192, 2193], 2274, [68912, 68921], [69216, 69246]];
var Arabic_Number_default = _110;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Boundary_Neutral.js
var _111 = [[0, 8], [14, 27], [127, 132], [134, 159], 173, 6158, [8203, 8205], [8288, 8292], [8298, 8303], 65279, [113824, 113827], [119155, 119162], 917505, [917536, 917631]];
var Boundary_Neutral_default = _111;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Common_Separator.js
var _112 = [44, [46, 47], 58, 160, 1548, 8239, 8260, 65104, 65106, 65109, 65292, [65294, 65295], 65306];
var Common_Separator_default = _112;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/European_Number.js
var _113 = [[48, 57], [178, 179], 185, [1776, 1785], 8304, [8308, 8313], [8320, 8329], [9352, 9371], [65296, 65305], [66273, 66299], [120782, 120831], [127232, 127242], [130032, 130041]];
var European_Number_default = _113;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/European_Separator.js
var _114 = [43, 45, [8314, 8315], [8330, 8331], 8722, 64297, [65122, 65123], 65291, 65293];
var European_Separator_default = _114;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/European_Terminator.js
var _115 = [[35, 37], [162, 165], [176, 177], 1423, [1545, 1546], 1642, [2546, 2547], 2555, 2801, 3065, 3647, 6107, [8240, 8244], [8352, 8384], 8494, 8723, [43064, 43065], 65119, [65129, 65130], [65283, 65285], [65504, 65505], [65509, 65510], [73693, 73696], 123647];
var European_Terminator_default = _115;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/First_Strong_Isolate.js
var _116 = [8296];
var First_Strong_Isolate_default = _116;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right.js
var _117 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 696], [699, 705], [720, 721], [736, 740], 750, [880, 883], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1154], [1162, 1327], [1329, 1366], [1369, 1417], [2307, 2361], 2363, [2365, 2368], [2377, 2380], [2382, 2384], [2392, 2401], [2404, 2432], [2434, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2493, 2496], [2503, 2504], [2507, 2508], 2510, 2519, [2524, 2525], [2527, 2529], [2534, 2545], [2548, 2554], [2556, 2557], 2563, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2622, 2624], [2649, 2652], 2654, [2662, 2671], [2674, 2676], 2678, 2691, [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2752], 2761, [2763, 2764], 2768, [2784, 2785], [2790, 2800], 2809, [2818, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2877, 2878], 2880, [2887, 2888], [2891, 2892], 2903, [2908, 2909], [2911, 2913], [2918, 2935], 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], 3024, 3031, [3046, 3058], [3073, 3075], [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3137, 3140], [3160, 3162], 3165, [3168, 3169], [3174, 3183], 3191, [3199, 3200], [3202, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3268], [3270, 3272], [3274, 3275], [3285, 3286], [3293, 3294], [3296, 3297], [3302, 3311], [3313, 3315], [3330, 3340], [3342, 3344], [3346, 3386], [3389, 3392], [3398, 3400], [3402, 3404], [3406, 3407], [3412, 3425], [3430, 3455], [3458, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3535, 3537], [3544, 3551], [3558, 3567], [3570, 3572], [3585, 3632], [3634, 3635], [3648, 3654], [3663, 3675], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3792, 3801], [3804, 3807], [3840, 3863], [3866, 3892], 3894, 3896, [3902, 3911], [3913, 3948], 3967, 3973, [3976, 3980], [4030, 4037], [4039, 4044], [4046, 4058], [4096, 4140], 4145, 4152, [4155, 4156], [4159, 4183], [4186, 4189], [4193, 4208], [4213, 4225], [4227, 4228], [4231, 4236], [4238, 4252], [4254, 4293], 4295, 4301, [4304, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4960, 4988], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5759], [5761, 5786], [5792, 5880], [5888, 5905], 5909, [5919, 5937], [5940, 5942], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6070, [6078, 6085], [6087, 6088], [6100, 6106], 6108, [6112, 6121], [6160, 6169], [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6470, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6656, 6678], [6681, 6682], [6686, 6741], 6743, 6753, [6755, 6756], [6765, 6770], [6784, 6793], [6800, 6809], [6816, 6829], [6916, 6963], 6965, 6971, [6973, 6977], [6979, 6988], [6992, 7018], [7028, 7038], [7042, 7073], [7078, 7079], 7082, [7086, 7141], 7143, [7146, 7148], 7150, [7154, 7155], [7164, 7211], [7220, 7221], [7227, 7241], [7245, 7304], [7312, 7354], [7357, 7367], 7379, 7393, [7401, 7404], [7406, 7411], [7413, 7415], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8206, 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], [8526, 8527], [8544, 8584], [9014, 9082], 9109, [9372, 9449], 9900, [10240, 10495], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], [11631, 11632], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12293, 12295], [12321, 12329], [12334, 12335], [12337, 12341], [12344, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12688, 12735], [12784, 12828], [12832, 12879], [12896, 12923], [12927, 12976], [12992, 13003], [13008, 13174], [13179, 13277], [13280, 13310], [13312, 19903], [19968, 42124], [42192, 42508], [42512, 42539], [42560, 42606], [42624, 42653], [42656, 42735], [42738, 42743], [42786, 42887], [42889, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43044], 43047, [43056, 43063], [43072, 43123], [43136, 43203], [43214, 43225], [43250, 43262], [43264, 43301], [43310, 43334], [43346, 43347], [43359, 43388], [43395, 43442], [43444, 43445], [43450, 43451], [43454, 43469], [43471, 43481], [43486, 43492], [43494, 43518], [43520, 43560], [43567, 43568], [43571, 43572], [43584, 43586], [43588, 43595], 43597, [43600, 43609], [43612, 43643], [43645, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43755], [43758, 43765], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43881], [43888, 44004], [44006, 44007], [44009, 44012], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [55296, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], 65792, 65794, [65799, 65843], [65847, 65855], [65933, 65934], [66e3, 66044], [66176, 66204], [66208, 66256], [66304, 66339], [66349, 66378], [66384, 66421], [66432, 66461], [66463, 66499], [66504, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], 69632, [69634, 69687], [69703, 69709], [69734, 69743], [69745, 69746], 69749, [69762, 69810], [69815, 69816], [69819, 69825], 69837, [69840, 69864], [69872, 69881], [69891, 69926], 69932, [69942, 69959], [69968, 70002], [70004, 70006], [70018, 70069], [70079, 70088], [70093, 70094], [70096, 70111], [70113, 70132], [70144, 70161], [70163, 70190], [70194, 70195], 70197, [70200, 70205], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313], [70320, 70366], [70368, 70370], [70384, 70393], [70402, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70461, 70463], [70465, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70656, 70711], [70720, 70721], 70725, [70727, 70747], 70749, [70751, 70753], [70784, 70834], 70841, [70843, 70846], 70849, [70852, 70855], [70864, 70873], [71040, 71089], [71096, 71099], 71102, [71105, 71131], [71168, 71218], [71227, 71228], 71230, [71233, 71236], [71248, 71257], [71296, 71338], 71340, [71342, 71343], 71350, [71352, 71353], [71360, 71369], [71424, 71450], [71456, 71457], 71462, [71472, 71494], [71680, 71726], 71736, 71739, [71840, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], 71997, [71999, 72002], [72004, 72006], [72016, 72025], [72096, 72103], [72106, 72147], [72156, 72159], [72161, 72164], 72192, [72199, 72200], [72203, 72242], [72249, 72250], [72255, 72262], 72272, [72279, 72280], [72284, 72329], 72343, [72346, 72354], [72368, 72440], [72448, 72457], [72704, 72712], [72714, 72751], [72766, 72773], [72784, 72812], [72816, 72847], 72873, 72881, 72884, [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73107, 73108], 73110, 73112, [73120, 73129], [73440, 73458], [73461, 73464], [73474, 73488], [73490, 73525], [73534, 73535], 73537, [73539, 73561], 73648, [73664, 73684], [73727, 74649], [74752, 74862], [74864, 74868], [74880, 75075], [77712, 77810], [77824, 78911], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92782, 92862], [92864, 92873], [92880, 92909], 92917, [92928, 92975], [92983, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93850], [93952, 94026], [94032, 94087], [94099, 94111], [94176, 94177], 94179, [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113820, 113823, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119142], [119146, 119154], [119171, 119172], [119180, 119209], [119214, 119272], [119488, 119507], [119520, 119539], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120538], [120540, 120596], [120598, 120654], [120656, 120712], [120714, 120770], [120772, 120779], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121483], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], [123200, 123209], [123214, 123215], [123536, 123565], [123584, 123627], [123632, 123641], [124112, 124139], [124144, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [127248, 127278], [127280, 127337], [127344, 127404], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], [983040, 1048573], [1048576, 1114109]];
var Left_To_Right_default = _117;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right_Embedding.js
var _118 = [8234];
var Left_To_Right_Embedding_default = _118;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right_Isolate.js
var _119 = [8294];
var Left_To_Right_Isolate_default = _119;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right_Override.js
var _120 = [8237];
var Left_To_Right_Override_default = _120;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Nonspacing_Mark.js
var _121 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12333], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72198], [72201, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917760, 917999]];
var Nonspacing_Mark_default2 = _121;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Other_Neutral.js
var _122 = [[33, 34], [38, 42], [59, 64], [91, 96], [123, 126], 161, [166, 169], [171, 172], [174, 175], 180, [182, 184], [187, 191], 215, 247, [697, 698], [706, 719], [722, 735], [741, 749], [751, 767], [884, 885], 894, [900, 901], 903, 1014, 1418, [1421, 1422], [1542, 1543], [1550, 1551], 1758, 1769, [2038, 2041], [3059, 3064], 3066, [3192, 3198], [3898, 3901], [5008, 5017], 5120, [5787, 5788], [6128, 6137], [6144, 6154], 6464, [6468, 6469], [6622, 6655], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [8208, 8231], [8245, 8259], [8261, 8286], [8316, 8318], [8332, 8334], [8448, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8472], [8478, 8483], 8485, 8487, 8489, [8506, 8507], [8512, 8516], [8522, 8525], [8528, 8543], [8585, 8587], [8592, 8721], [8724, 9013], [9083, 9108], [9110, 9254], [9280, 9290], [9312, 9351], [9450, 9899], [9901, 10239], [10496, 11123], [11126, 11157], [11159, 11263], [11493, 11498], [11513, 11519], [11776, 11869], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12289, 12292], [12296, 12320], 12336, [12342, 12343], [12349, 12351], [12443, 12444], 12448, 12539, [12736, 12771], [12829, 12830], [12880, 12895], [12924, 12926], [12977, 12991], [13004, 13007], [13175, 13178], [13278, 13279], 13311, [19904, 19967], [42128, 42182], [42509, 42511], 42611, [42622, 42623], [42752, 42785], 42888, [43048, 43051], [43124, 43127], [43882, 43883], [64830, 64847], 64975, [65021, 65023], [65040, 65049], [65072, 65103], 65105, 65108, [65110, 65118], [65120, 65121], [65124, 65126], 65128, 65131, [65281, 65282], [65286, 65290], [65307, 65312], [65339, 65344], [65371, 65381], [65506, 65508], [65512, 65518], [65529, 65533], 65793, [65856, 65932], [65936, 65948], 65952, 67871, [68409, 68415], [69714, 69733], [71264, 71276], [73685, 73692], [73697, 73713], 94178, [119273, 119274], [119296, 119361], 119365, [119552, 119638], 120539, 120597, 120655, 120713, 120771, [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127243, 127247], 127279, [127338, 127343], 127405, [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994]];
var Other_Neutral_default = _122;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Paragraph_Separator.js
var _123 = [10, 13, [28, 30], 133, 8233];
var Paragraph_Separator_default2 = _123;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Pop_Directional_Format.js
var _124 = [8236];
var Pop_Directional_Format_default = _124;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Pop_Directional_Isolate.js
var _125 = [8297];
var Pop_Directional_Isolate_default = _125;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left.js
var _126 = [1470, 1472, 1475, 1478, [1488, 1514], [1519, 1524], [1984, 2026], [2036, 2037], 2042, [2046, 2069], 2074, 2084, 2088, [2096, 2110], [2112, 2136], 2142, 8207, 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67671, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67872, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68096], [68112, 68115], [68117, 68119], [68121, 68149], [68160, 68168], [68176, 68184], [68192, 68255], [68288, 68324], [68331, 68342], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68863], [69248, 69289], 69293, [69296, 69297], [69376, 69415], [69488, 69505], [69510, 69513], [69552, 69579], [69600, 69622], [124928, 125124], [125127, 125135], [125184, 125251], 125259, [125264, 125273], [125278, 125279]];
var Right_To_Left_default = _126;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left_Embedding.js
var _127 = [8235];
var Right_To_Left_Embedding_default = _127;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left_Isolate.js
var _128 = [8295];
var Right_To_Left_Isolate_default = _128;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left_Override.js
var _129 = [8238];
var Right_To_Left_Override_default = _129;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Segment_Separator.js
var _130 = [9, 11, 31];
var Segment_Separator_default = _130;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/White_Space.js
var _131 = [12, 32, 5760, [8192, 8202], 8232, 8287, 12288];
var White_Space_default2 = _131;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/index.js
var Script_exports = {};
__export(Script_exports, {
  Adlam: () => Adlam_default,
  Ahom: () => Ahom_default,
  Anatolian_Hieroglyphs: () => Anatolian_Hieroglyphs_default,
  Arabic: () => Arabic_default,
  Armenian: () => Armenian_default,
  Avestan: () => Avestan_default,
  Balinese: () => Balinese_default,
  Bamum: () => Bamum_default,
  Bassa_Vah: () => Bassa_Vah_default,
  Batak: () => Batak_default,
  Bengali: () => Bengali_default,
  Bhaiksuki: () => Bhaiksuki_default,
  Bopomofo: () => Bopomofo_default,
  Brahmi: () => Brahmi_default,
  Braille: () => Braille_default,
  Buginese: () => Buginese_default,
  Buhid: () => Buhid_default,
  Canadian_Aboriginal: () => Canadian_Aboriginal_default,
  Carian: () => Carian_default,
  Caucasian_Albanian: () => Caucasian_Albanian_default,
  Chakma: () => Chakma_default,
  Cham: () => Cham_default,
  Cherokee: () => Cherokee_default,
  Chorasmian: () => Chorasmian_default,
  Common: () => Common_default,
  Coptic: () => Coptic_default,
  Cuneiform: () => Cuneiform_default,
  Cypriot: () => Cypriot_default,
  Cypro_Minoan: () => Cypro_Minoan_default,
  Cyrillic: () => Cyrillic_default,
  Deseret: () => Deseret_default,
  Devanagari: () => Devanagari_default,
  Dives_Akuru: () => Dives_Akuru_default,
  Dogra: () => Dogra_default,
  Duployan: () => Duployan_default,
  Egyptian_Hieroglyphs: () => Egyptian_Hieroglyphs_default,
  Elbasan: () => Elbasan_default,
  Elymaic: () => Elymaic_default,
  Ethiopic: () => Ethiopic_default,
  Georgian: () => Georgian_default,
  Glagolitic: () => Glagolitic_default,
  Gothic: () => Gothic_default,
  Grantha: () => Grantha_default,
  Greek: () => Greek_default,
  Gujarati: () => Gujarati_default,
  Gunjala_Gondi: () => Gunjala_Gondi_default,
  Gurmukhi: () => Gurmukhi_default,
  Han: () => Han_default,
  Hangul: () => Hangul_default,
  Hanifi_Rohingya: () => Hanifi_Rohingya_default,
  Hanunoo: () => Hanunoo_default,
  Hatran: () => Hatran_default,
  Hebrew: () => Hebrew_default,
  Hiragana: () => Hiragana_default,
  Imperial_Aramaic: () => Imperial_Aramaic_default,
  Inherited: () => Inherited_default,
  Inscriptional_Pahlavi: () => Inscriptional_Pahlavi_default,
  Inscriptional_Parthian: () => Inscriptional_Parthian_default,
  Javanese: () => Javanese_default,
  Kaithi: () => Kaithi_default,
  Kannada: () => Kannada_default,
  Katakana: () => Katakana_default,
  Kawi: () => Kawi_default,
  Kayah_Li: () => Kayah_Li_default,
  Kharoshthi: () => Kharoshthi_default,
  Khitan_Small_Script: () => Khitan_Small_Script_default,
  Khmer: () => Khmer_default,
  Khojki: () => Khojki_default,
  Khudawadi: () => Khudawadi_default,
  Lao: () => Lao_default,
  Latin: () => Latin_default,
  Lepcha: () => Lepcha_default,
  Limbu: () => Limbu_default,
  Linear_A: () => Linear_A_default,
  Linear_B: () => Linear_B_default,
  Lisu: () => Lisu_default,
  Lycian: () => Lycian_default,
  Lydian: () => Lydian_default,
  Mahajani: () => Mahajani_default,
  Makasar: () => Makasar_default,
  Malayalam: () => Malayalam_default,
  Mandaic: () => Mandaic_default,
  Manichaean: () => Manichaean_default,
  Marchen: () => Marchen_default,
  Masaram_Gondi: () => Masaram_Gondi_default,
  Medefaidrin: () => Medefaidrin_default,
  Meetei_Mayek: () => Meetei_Mayek_default,
  Mende_Kikakui: () => Mende_Kikakui_default,
  Meroitic_Cursive: () => Meroitic_Cursive_default,
  Meroitic_Hieroglyphs: () => Meroitic_Hieroglyphs_default,
  Miao: () => Miao_default,
  Modi: () => Modi_default,
  Mongolian: () => Mongolian_default,
  Mro: () => Mro_default,
  Multani: () => Multani_default,
  Myanmar: () => Myanmar_default,
  Nabataean: () => Nabataean_default,
  Nag_Mundari: () => Nag_Mundari_default,
  Nandinagari: () => Nandinagari_default,
  New_Tai_Lue: () => New_Tai_Lue_default,
  Newa: () => Newa_default,
  Nko: () => Nko_default,
  Nushu: () => Nushu_default,
  Nyiakeng_Puachue_Hmong: () => Nyiakeng_Puachue_Hmong_default,
  Ogham: () => Ogham_default,
  Ol_Chiki: () => Ol_Chiki_default,
  Old_Hungarian: () => Old_Hungarian_default,
  Old_Italic: () => Old_Italic_default,
  Old_North_Arabian: () => Old_North_Arabian_default,
  Old_Permic: () => Old_Permic_default,
  Old_Persian: () => Old_Persian_default,
  Old_Sogdian: () => Old_Sogdian_default,
  Old_South_Arabian: () => Old_South_Arabian_default,
  Old_Turkic: () => Old_Turkic_default,
  Old_Uyghur: () => Old_Uyghur_default,
  Oriya: () => Oriya_default,
  Osage: () => Osage_default,
  Osmanya: () => Osmanya_default,
  Pahawh_Hmong: () => Pahawh_Hmong_default,
  Palmyrene: () => Palmyrene_default,
  Pau_Cin_Hau: () => Pau_Cin_Hau_default,
  Phags_Pa: () => Phags_Pa_default,
  Phoenician: () => Phoenician_default,
  Psalter_Pahlavi: () => Psalter_Pahlavi_default,
  Rejang: () => Rejang_default,
  Runic: () => Runic_default,
  Samaritan: () => Samaritan_default,
  Saurashtra: () => Saurashtra_default,
  Sharada: () => Sharada_default,
  Shavian: () => Shavian_default,
  Siddham: () => Siddham_default,
  SignWriting: () => SignWriting_default,
  Sinhala: () => Sinhala_default,
  Sogdian: () => Sogdian_default,
  Sora_Sompeng: () => Sora_Sompeng_default,
  Soyombo: () => Soyombo_default,
  Sundanese: () => Sundanese_default,
  Syloti_Nagri: () => Syloti_Nagri_default,
  Syriac: () => Syriac_default,
  Tagalog: () => Tagalog_default,
  Tagbanwa: () => Tagbanwa_default,
  Tai_Le: () => Tai_Le_default,
  Tai_Tham: () => Tai_Tham_default,
  Tai_Viet: () => Tai_Viet_default,
  Takri: () => Takri_default,
  Tamil: () => Tamil_default,
  Tangsa: () => Tangsa_default,
  Tangut: () => Tangut_default,
  Telugu: () => Telugu_default,
  Thaana: () => Thaana_default,
  Thai: () => Thai_default,
  Tibetan: () => Tibetan_default,
  Tifinagh: () => Tifinagh_default,
  Tirhuta: () => Tirhuta_default,
  Toto: () => Toto_default,
  Ugaritic: () => Ugaritic_default,
  Vai: () => Vai_default,
  Vithkuqi: () => Vithkuqi_default,
  Wancho: () => Wancho_default,
  Warang_Citi: () => Warang_Citi_default,
  Yezidi: () => Yezidi_default,
  Yi: () => Yi_default,
  Zanabazar_Square: () => Zanabazar_Square_default
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Adlam.js
var _132 = [[125184, 125259], [125264, 125273], [125278, 125279]];
var Adlam_default = _132;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ahom.js
var _133 = [[71424, 71450], [71453, 71467], [71472, 71494]];
var Ahom_default = _133;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Anatolian_Hieroglyphs.js
var _134 = [[82944, 83526]];
var Anatolian_Hieroglyphs_default = _134;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Arabic.js
var _135 = [[1536, 1540], [1542, 1547], [1549, 1562], [1564, 1566], [1568, 1599], [1601, 1610], [1622, 1647], [1649, 1756], [1758, 1791], [1872, 1919], [2160, 2190], [2192, 2193], [2200, 2273], [2275, 2303], [64336, 64450], [64467, 64829], [64832, 64911], [64914, 64967], 64975, [65008, 65023], [65136, 65140], [65142, 65276], [69216, 69246], [69373, 69375], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705]];
var Arabic_default = _135;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Armenian.js
var _136 = [[1329, 1366], [1369, 1418], [1421, 1423], [64275, 64279]];
var Armenian_default = _136;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Avestan.js
var _137 = [[68352, 68405], [68409, 68415]];
var Avestan_default = _137;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Balinese.js
var _138 = [[6912, 6988], [6992, 7038]];
var Balinese_default = _138;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bamum.js
var _139 = [[42656, 42743], [92160, 92728]];
var Bamum_default = _139;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bassa_Vah.js
var _140 = [[92880, 92909], [92912, 92917]];
var Bassa_Vah_default = _140;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Batak.js
var _141 = [[7104, 7155], [7164, 7167]];
var Batak_default = _141;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bengali.js
var _142 = [[2432, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2558]];
var Bengali_default = _142;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bhaiksuki.js
var _143 = [[72704, 72712], [72714, 72758], [72760, 72773], [72784, 72812]];
var Bhaiksuki_default = _143;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bopomofo.js
var _144 = [[746, 747], [12549, 12591], [12704, 12735]];
var Bopomofo_default = _144;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Brahmi.js
var _145 = [[69632, 69709], [69714, 69749], 69759];
var Brahmi_default = _145;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Braille.js
var _146 = [[10240, 10495]];
var Braille_default = _146;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Buginese.js
var _147 = [[6656, 6683], [6686, 6687]];
var Buginese_default = _147;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Buhid.js
var _148 = [[5952, 5971]];
var Buhid_default = _148;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Canadian_Aboriginal.js
var _149 = [[5120, 5759], [6320, 6389], [72368, 72383]];
var Canadian_Aboriginal_default = _149;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Carian.js
var _150 = [[66208, 66256]];
var Carian_default = _150;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Caucasian_Albanian.js
var _151 = [[66864, 66915], 66927];
var Caucasian_Albanian_default = _151;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Chakma.js
var _152 = [[69888, 69940], [69942, 69959]];
var Chakma_default = _152;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cham.js
var _153 = [[43520, 43574], [43584, 43597], [43600, 43609], [43612, 43615]];
var Cham_default = _153;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cherokee.js
var _154 = [[5024, 5109], [5112, 5117], [43888, 43967]];
var Cherokee_default = _154;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Chorasmian.js
var _155 = [[69552, 69579]];
var Chorasmian_default = _155;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Common.js
var _156 = [[0, 64], [91, 96], [123, 169], [171, 185], [187, 191], 215, 247, [697, 735], [741, 745], [748, 767], 884, 894, 901, 903, 1541, 1548, 1563, 1567, 1600, 1757, 2274, [2404, 2405], 3647, [4053, 4056], 4347, [5867, 5869], [5941, 5942], [6146, 6147], 6149, 7379, 7393, [7401, 7404], [7406, 7411], [7413, 7415], 7418, [8192, 8203], [8206, 8292], [8294, 8304], [8308, 8318], [8320, 8334], [8352, 8384], [8448, 8485], [8487, 8489], [8492, 8497], [8499, 8525], [8527, 8543], [8585, 8587], [8592, 9254], [9280, 9290], [9312, 10239], [10496, 11123], [11126, 11157], [11159, 11263], [11776, 11869], [12272, 12283], [12288, 12292], 12294, [12296, 12320], [12336, 12343], [12348, 12351], [12443, 12444], 12448, [12539, 12540], [12688, 12703], [12736, 12771], [12832, 12895], [12927, 13007], 13055, [13144, 13311], [19904, 19967], [42752, 42785], [42888, 42890], [43056, 43065], 43310, 43471, 43867, [43882, 43883], [64830, 64831], [65040, 65049], [65072, 65106], [65108, 65126], [65128, 65131], 65279, [65281, 65312], [65339, 65344], [65371, 65381], 65392, [65438, 65439], [65504, 65510], [65512, 65518], [65529, 65533], [65792, 65794], [65799, 65843], [65847, 65855], [65936, 65948], [66e3, 66044], [66273, 66299], [113824, 113827], [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119142], [119146, 119162], [119171, 119172], [119180, 119209], [119214, 119274], [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [126065, 126132], [126209, 126269], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127487], [127489, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], 917505, [917536, 917631]];
var Common_default = _156;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Coptic.js
var _157 = [[994, 1007], [11392, 11507], [11513, 11519]];
var Coptic_default = _157;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cuneiform.js
var _158 = [[73728, 74649], [74752, 74862], [74864, 74868], [74880, 75075]];
var Cuneiform_default = _158;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cypriot.js
var _159 = [[67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, 67647];
var Cypriot_default = _159;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cypro_Minoan.js
var _160 = [[77712, 77810]];
var Cypro_Minoan_default = _160;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cyrillic.js
var _161 = [[1024, 1156], [1159, 1327], [7296, 7304], 7467, 7544, [11744, 11775], [42560, 42655], [65070, 65071], [122928, 122989], 123023];
var Cyrillic_default = _161;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Deseret.js
var _162 = [[66560, 66639]];
var Deseret_default = _162;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Devanagari.js
var _163 = [[2304, 2384], [2389, 2403], [2406, 2431], [43232, 43263], [72448, 72457]];
var Devanagari_default = _163;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Dives_Akuru.js
var _164 = [[71936, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72006], [72016, 72025]];
var Dives_Akuru_default = _164;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Dogra.js
var _165 = [[71680, 71739]];
var Dogra_default = _165;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Duployan.js
var _166 = [[113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113820, 113823]];
var Duployan_default = _166;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Egyptian_Hieroglyphs.js
var _167 = [[77824, 78933]];
var Egyptian_Hieroglyphs_default = _167;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Elbasan.js
var _168 = [[66816, 66855]];
var Elbasan_default = _168;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Elymaic.js
var _169 = [[69600, 69622]];
var Elymaic_default = _169;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ethiopic.js
var _170 = [[4608, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4988], [4992, 5017], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926]];
var Ethiopic_default = _170;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Georgian.js
var _171 = [[4256, 4293], 4295, 4301, [4304, 4346], [4348, 4351], [7312, 7354], [7357, 7359], [11520, 11557], 11559, 11565];
var Georgian_default = _171;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Glagolitic.js
var _172 = [[11264, 11359], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922]];
var Glagolitic_default = _172;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gothic.js
var _173 = [[66352, 66378]];
var Gothic_default = _173;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Grantha.js
var _174 = [[70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70460, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516]];
var Grantha_default = _174;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Greek.js
var _175 = [[880, 883], [885, 887], [890, 893], 895, 900, 902, [904, 906], 908, [910, 929], [931, 993], [1008, 1023], [7462, 7466], [7517, 7521], [7526, 7530], 7615, [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], 8486, 43877, [65856, 65934], 65952, [119296, 119365]];
var Greek_default = _175;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gujarati.js
var _176 = [[2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2801], [2809, 2815]];
var Gujarati_default = _176;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gunjala_Gondi.js
var _177 = [[73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129]];
var Gunjala_Gondi_default = _177;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gurmukhi.js
var _178 = [[2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2678]];
var Gurmukhi_default = _178;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Han.js
var _179 = [[11904, 11929], [11931, 12019], [12032, 12245], 12293, 12295, [12321, 12329], [12344, 12347], [13312, 19903], [19968, 40959], [63744, 64109], [64112, 64217], [94178, 94179], [94192, 94193], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var Han_default = _179;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hangul.js
var _180 = [[4352, 4607], [12334, 12335], [12593, 12686], [12800, 12830], [12896, 12926], [43360, 43388], [44032, 55203], [55216, 55238], [55243, 55291], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500]];
var Hangul_default = _180;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hanifi_Rohingya.js
var _181 = [[68864, 68903], [68912, 68921]];
var Hanifi_Rohingya_default = _181;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hanunoo.js
var _182 = [[5920, 5940]];
var Hanunoo_default = _182;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hatran.js
var _183 = [[67808, 67826], [67828, 67829], [67835, 67839]];
var Hatran_default = _183;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hebrew.js
var _184 = [[1425, 1479], [1488, 1514], [1519, 1524], [64285, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
var Hebrew_default = _184;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hiragana.js
var _185 = [[12353, 12438], [12445, 12447], [110593, 110879], 110898, [110928, 110930], 127488];
var Hiragana_default = _185;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Imperial_Aramaic.js
var _186 = [[67648, 67669], [67671, 67679]];
var Imperial_Aramaic_default = _186;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Inherited.js
var _187 = [[768, 879], [1157, 1158], [1611, 1621], 1648, [2385, 2388], [6832, 6862], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8204, 8205], [8400, 8432], [12330, 12333], [12441, 12442], [65024, 65039], [65056, 65069], 66045, 66272, 70459, [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [917760, 917999]];
var Inherited_default = _187;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Inscriptional_Pahlavi.js
var _188 = [[68448, 68466], [68472, 68479]];
var Inscriptional_Pahlavi_default = _188;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Inscriptional_Parthian.js
var _189 = [[68416, 68437], [68440, 68447]];
var Inscriptional_Parthian_default = _189;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Javanese.js
var _190 = [[43392, 43469], [43472, 43481], [43486, 43487]];
var Javanese_default = _190;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kaithi.js
var _191 = [[69760, 69826], 69837];
var Kaithi_default = _191;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kannada.js
var _192 = [[3200, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315]];
var Kannada_default = _192;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Katakana.js
var _193 = [[12449, 12538], [12541, 12543], [12784, 12799], [13008, 13054], [13056, 13143], [65382, 65391], [65393, 65437], [110576, 110579], [110581, 110587], [110589, 110590], 110592, [110880, 110882], 110933, [110948, 110951]];
var Katakana_default = _193;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kawi.js
var _194 = [[73472, 73488], [73490, 73530], [73534, 73561]];
var Kawi_default = _194;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kayah_Li.js
var _195 = [[43264, 43309], 43311];
var Kayah_Li_default = _195;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kharoshthi.js
var _196 = [[68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], [68159, 68168], [68176, 68184]];
var Kharoshthi_default = _196;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khitan_Small_Script.js
var _197 = [94180, [101120, 101589]];
var Khitan_Small_Script_default = _197;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khmer.js
var _198 = [[6016, 6109], [6112, 6121], [6128, 6137], [6624, 6655]];
var Khmer_default = _198;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khojki.js
var _199 = [[70144, 70161], [70163, 70209]];
var Khojki_default = _199;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khudawadi.js
var _200 = [[70320, 70378], [70384, 70393]];
var Khudawadi_default = _200;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lao.js
var _201 = [[3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807]];
var Lao_default = _201;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Latin.js
var _202 = [[65, 90], [97, 122], 170, 186, [192, 214], [216, 246], [248, 696], [736, 740], [7424, 7461], [7468, 7516], [7522, 7525], [7531, 7543], [7545, 7614], [7680, 7935], 8305, 8319, [8336, 8348], [8490, 8491], 8498, 8526, [8544, 8584], [11360, 11391], [42786, 42887], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43007], [43824, 43866], [43868, 43876], [43878, 43881], [64256, 64262], [65313, 65338], [65345, 65370], [67456, 67461], [67463, 67504], [67506, 67514], [122624, 122654], [122661, 122666]];
var Latin_default = _202;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lepcha.js
var _203 = [[7168, 7223], [7227, 7241], [7245, 7247]];
var Lepcha_default = _203;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Limbu.js
var _204 = [[6400, 6430], [6432, 6443], [6448, 6459], 6464, [6468, 6479]];
var Limbu_default = _204;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Linear_A.js
var _205 = [[67072, 67382], [67392, 67413], [67424, 67431]];
var Linear_A_default = _205;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Linear_B.js
var _206 = [[65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786]];
var Linear_B_default = _206;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lisu.js
var _207 = [[42192, 42239], 73648];
var Lisu_default = _207;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lycian.js
var _208 = [[66176, 66204]];
var Lycian_default = _208;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lydian.js
var _209 = [[67872, 67897], 67903];
var Lydian_default = _209;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mahajani.js
var _210 = [[69968, 70006]];
var Mahajani_default = _210;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Makasar.js
var _211 = [[73440, 73464]];
var Makasar_default = _211;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Malayalam.js
var _212 = [[3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3407], [3412, 3427], [3430, 3455]];
var Malayalam_default = _212;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mandaic.js
var _213 = [[2112, 2139], 2142];
var Mandaic_default = _213;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Manichaean.js
var _214 = [[68288, 68326], [68331, 68342]];
var Manichaean_default = _214;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Marchen.js
var _215 = [[72816, 72847], [72850, 72871], [72873, 72886]];
var Marchen_default = _215;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Masaram_Gondi.js
var _216 = [[72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049]];
var Masaram_Gondi_default = _216;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Medefaidrin.js
var _217 = [[93760, 93850]];
var Medefaidrin_default = _217;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Meetei_Mayek.js
var _218 = [[43744, 43766], [43968, 44013], [44016, 44025]];
var Meetei_Mayek_default = _218;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mende_Kikakui.js
var _219 = [[124928, 125124], [125127, 125142]];
var Mende_Kikakui_default = _219;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Meroitic_Cursive.js
var _220 = [[68e3, 68023], [68028, 68047], [68050, 68095]];
var Meroitic_Cursive_default = _220;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Meroitic_Hieroglyphs.js
var _221 = [[67968, 67999]];
var Meroitic_Hieroglyphs_default = _221;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Miao.js
var _222 = [[93952, 94026], [94031, 94087], [94095, 94111]];
var Miao_default = _222;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Modi.js
var _223 = [[71168, 71236], [71248, 71257]];
var Modi_default = _223;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mongolian.js
var _224 = [[6144, 6145], 6148, [6150, 6169], [6176, 6264], [6272, 6314], [71264, 71276]];
var Mongolian_default = _224;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mro.js
var _225 = [[92736, 92766], [92768, 92777], [92782, 92783]];
var Mro_default = _225;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Multani.js
var _226 = [[70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313]];
var Multani_default = _226;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Myanmar.js
var _227 = [[4096, 4255], [43488, 43518], [43616, 43647]];
var Myanmar_default = _227;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nabataean.js
var _228 = [[67712, 67742], [67751, 67759]];
var Nabataean_default = _228;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nag_Mundari.js
var _229 = [[124112, 124153]];
var Nag_Mundari_default = _229;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nandinagari.js
var _230 = [[72096, 72103], [72106, 72151], [72154, 72164]];
var Nandinagari_default = _230;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/New_Tai_Lue.js
var _231 = [[6528, 6571], [6576, 6601], [6608, 6618], [6622, 6623]];
var New_Tai_Lue_default = _231;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Newa.js
var _232 = [[70656, 70747], [70749, 70753]];
var Newa_default = _232;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nko.js
var _233 = [[1984, 2042], [2045, 2047]];
var Nko_default = _233;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nushu.js
var _234 = [94177, [110960, 111355]];
var Nushu_default = _234;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nyiakeng_Puachue_Hmong.js
var _235 = [[123136, 123180], [123184, 123197], [123200, 123209], [123214, 123215]];
var Nyiakeng_Puachue_Hmong_default = _235;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ogham.js
var _236 = [[5760, 5788]];
var Ogham_default = _236;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ol_Chiki.js
var _237 = [[7248, 7295]];
var Ol_Chiki_default = _237;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Hungarian.js
var _238 = [[68736, 68786], [68800, 68850], [68858, 68863]];
var Old_Hungarian_default = _238;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Italic.js
var _239 = [[66304, 66339], [66349, 66351]];
var Old_Italic_default = _239;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_North_Arabian.js
var _240 = [[68224, 68255]];
var Old_North_Arabian_default = _240;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Permic.js
var _241 = [[66384, 66426]];
var Old_Permic_default = _241;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Persian.js
var _242 = [[66464, 66499], [66504, 66517]];
var Old_Persian_default = _242;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Sogdian.js
var _243 = [[69376, 69415]];
var Old_Sogdian_default = _243;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_South_Arabian.js
var _244 = [[68192, 68223]];
var Old_South_Arabian_default = _244;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Turkic.js
var _245 = [[68608, 68680]];
var Old_Turkic_default = _245;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Uyghur.js
var _246 = [[69488, 69513]];
var Old_Uyghur_default = _246;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Oriya.js
var _247 = [[2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2935]];
var Oriya_default = _247;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Osage.js
var _248 = [[66736, 66771], [66776, 66811]];
var Osage_default = _248;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Osmanya.js
var _249 = [[66688, 66717], [66720, 66729]];
var Osmanya_default = _249;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Pahawh_Hmong.js
var _250 = [[92928, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071]];
var Pahawh_Hmong_default = _250;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Palmyrene.js
var _251 = [[67680, 67711]];
var Palmyrene_default = _251;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Pau_Cin_Hau.js
var _252 = [[72384, 72440]];
var Pau_Cin_Hau_default = _252;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Phags_Pa.js
var _253 = [[43072, 43127]];
var Phags_Pa_default = _253;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Phoenician.js
var _254 = [[67840, 67867], 67871];
var Phoenician_default = _254;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Psalter_Pahlavi.js
var _255 = [[68480, 68497], [68505, 68508], [68521, 68527]];
var Psalter_Pahlavi_default = _255;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Rejang.js
var _256 = [[43312, 43347], 43359];
var Rejang_default = _256;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Runic.js
var _257 = [[5792, 5866], [5870, 5880]];
var Runic_default = _257;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Samaritan.js
var _258 = [[2048, 2093], [2096, 2110]];
var Samaritan_default = _258;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Saurashtra.js
var _259 = [[43136, 43205], [43214, 43225]];
var Saurashtra_default = _259;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sharada.js
var _260 = [[70016, 70111]];
var Sharada_default = _260;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Shavian.js
var _261 = [[66640, 66687]];
var Shavian_default = _261;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Siddham.js
var _262 = [[71040, 71093], [71096, 71133]];
var Siddham_default = _262;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/SignWriting.js
var _263 = [[120832, 121483], [121499, 121503], [121505, 121519]];
var SignWriting_default = _263;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sinhala.js
var _264 = [[3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3572], [70113, 70132]];
var Sinhala_default = _264;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sogdian.js
var _265 = [[69424, 69465]];
var Sogdian_default = _265;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sora_Sompeng.js
var _266 = [[69840, 69864], [69872, 69881]];
var Sora_Sompeng_default = _266;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Soyombo.js
var _267 = [[72272, 72354]];
var Soyombo_default = _267;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sundanese.js
var _268 = [[7040, 7103], [7360, 7367]];
var Sundanese_default = _268;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Syloti_Nagri.js
var _269 = [[43008, 43052]];
var Syloti_Nagri_default = _269;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Syriac.js
var _270 = [[1792, 1805], [1807, 1866], [1869, 1871], [2144, 2154]];
var Syriac_default = _270;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tagalog.js
var _271 = [[5888, 5909], 5919];
var Tagalog_default = _271;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tagbanwa.js
var _272 = [[5984, 5996], [5998, 6e3], [6002, 6003]];
var Tagbanwa_default = _272;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tai_Le.js
var _273 = [[6480, 6509], [6512, 6516]];
var Tai_Le_default = _273;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tai_Tham.js
var _274 = [[6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], [6816, 6829]];
var Tai_Tham_default = _274;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tai_Viet.js
var _275 = [[43648, 43714], [43739, 43743]];
var Tai_Viet_default = _275;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Takri.js
var _276 = [[71296, 71353], [71360, 71369]];
var Takri_default = _276;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tamil.js
var _277 = [[2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3066], [73664, 73713], 73727];
var Tamil_default = _277;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tangsa.js
var _278 = [[92784, 92862], [92864, 92873]];
var Tangsa_default = _278;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tangut.js
var _279 = [94176, [94208, 100343], [100352, 101119], [101632, 101640]];
var Tangut_default = _279;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Telugu.js
var _280 = [[3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3191, 3199]];
var Telugu_default = _280;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Thaana.js
var _281 = [[1920, 1969]];
var Thaana_default = _281;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Thai.js
var _282 = [[3585, 3642], [3648, 3675]];
var Thai_default = _282;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tibetan.js
var _283 = [[3840, 3911], [3913, 3948], [3953, 3991], [3993, 4028], [4030, 4044], [4046, 4052], [4057, 4058]];
var Tibetan_default = _283;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tifinagh.js
var _284 = [[11568, 11623], [11631, 11632], 11647];
var Tifinagh_default = _284;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tirhuta.js
var _285 = [[70784, 70855], [70864, 70873]];
var Tirhuta_default = _285;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Toto.js
var _286 = [[123536, 123566]];
var Toto_default = _286;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ugaritic.js
var _287 = [[66432, 66461], 66463];
var Ugaritic_default = _287;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Vai.js
var _288 = [[42240, 42539]];
var Vai_default = _288;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Vithkuqi.js
var _289 = [[66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004]];
var Vithkuqi_default = _289;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Wancho.js
var _290 = [[123584, 123641], 123647];
var Wancho_default = _290;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Warang_Citi.js
var _291 = [[71840, 71922], 71935];
var Warang_Citi_default = _291;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Yezidi.js
var _292 = [[69248, 69289], [69291, 69293], [69296, 69297]];
var Yezidi_default = _292;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Yi.js
var _293 = [[40960, 42124], [42128, 42182]];
var Yi_default = _293;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Zanabazar_Square.js
var _294 = [[72192, 72263]];
var Zanabazar_Square_default = _294;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/index.js
var Script_Extensions_exports = {};
__export(Script_Extensions_exports, {
  Adlam: () => Adlam_default2,
  Ahom: () => Ahom_default2,
  Anatolian_Hieroglyphs: () => Anatolian_Hieroglyphs_default2,
  Arabic: () => Arabic_default2,
  Armenian: () => Armenian_default2,
  Avestan: () => Avestan_default2,
  Balinese: () => Balinese_default2,
  Bamum: () => Bamum_default2,
  Bassa_Vah: () => Bassa_Vah_default2,
  Batak: () => Batak_default2,
  Bengali: () => Bengali_default2,
  Bhaiksuki: () => Bhaiksuki_default2,
  Bopomofo: () => Bopomofo_default2,
  Brahmi: () => Brahmi_default2,
  Braille: () => Braille_default2,
  Buginese: () => Buginese_default2,
  Buhid: () => Buhid_default2,
  Canadian_Aboriginal: () => Canadian_Aboriginal_default2,
  Carian: () => Carian_default2,
  Caucasian_Albanian: () => Caucasian_Albanian_default2,
  Chakma: () => Chakma_default2,
  Cham: () => Cham_default2,
  Cherokee: () => Cherokee_default2,
  Chorasmian: () => Chorasmian_default2,
  Common: () => Common_default2,
  Coptic: () => Coptic_default2,
  Cuneiform: () => Cuneiform_default2,
  Cypriot: () => Cypriot_default2,
  Cypro_Minoan: () => Cypro_Minoan_default2,
  Cyrillic: () => Cyrillic_default2,
  Deseret: () => Deseret_default2,
  Devanagari: () => Devanagari_default2,
  Dives_Akuru: () => Dives_Akuru_default2,
  Dogra: () => Dogra_default2,
  Duployan: () => Duployan_default2,
  Egyptian_Hieroglyphs: () => Egyptian_Hieroglyphs_default2,
  Elbasan: () => Elbasan_default2,
  Elymaic: () => Elymaic_default2,
  Ethiopic: () => Ethiopic_default2,
  Georgian: () => Georgian_default2,
  Glagolitic: () => Glagolitic_default2,
  Gothic: () => Gothic_default2,
  Grantha: () => Grantha_default2,
  Greek: () => Greek_default2,
  Gujarati: () => Gujarati_default2,
  Gunjala_Gondi: () => Gunjala_Gondi_default2,
  Gurmukhi: () => Gurmukhi_default2,
  Han: () => Han_default2,
  Hangul: () => Hangul_default2,
  Hanifi_Rohingya: () => Hanifi_Rohingya_default2,
  Hanunoo: () => Hanunoo_default2,
  Hatran: () => Hatran_default2,
  Hebrew: () => Hebrew_default2,
  Hiragana: () => Hiragana_default2,
  Imperial_Aramaic: () => Imperial_Aramaic_default2,
  Inherited: () => Inherited_default2,
  Inscriptional_Pahlavi: () => Inscriptional_Pahlavi_default2,
  Inscriptional_Parthian: () => Inscriptional_Parthian_default2,
  Javanese: () => Javanese_default2,
  Kaithi: () => Kaithi_default2,
  Kannada: () => Kannada_default2,
  Katakana: () => Katakana_default2,
  Kawi: () => Kawi_default2,
  Kayah_Li: () => Kayah_Li_default2,
  Kharoshthi: () => Kharoshthi_default2,
  Khitan_Small_Script: () => Khitan_Small_Script_default2,
  Khmer: () => Khmer_default2,
  Khojki: () => Khojki_default2,
  Khudawadi: () => Khudawadi_default2,
  Lao: () => Lao_default2,
  Latin: () => Latin_default2,
  Lepcha: () => Lepcha_default2,
  Limbu: () => Limbu_default2,
  Linear_A: () => Linear_A_default2,
  Linear_B: () => Linear_B_default2,
  Lisu: () => Lisu_default2,
  Lycian: () => Lycian_default2,
  Lydian: () => Lydian_default2,
  Mahajani: () => Mahajani_default2,
  Makasar: () => Makasar_default2,
  Malayalam: () => Malayalam_default2,
  Mandaic: () => Mandaic_default2,
  Manichaean: () => Manichaean_default2,
  Marchen: () => Marchen_default2,
  Masaram_Gondi: () => Masaram_Gondi_default2,
  Medefaidrin: () => Medefaidrin_default2,
  Meetei_Mayek: () => Meetei_Mayek_default2,
  Mende_Kikakui: () => Mende_Kikakui_default2,
  Meroitic_Cursive: () => Meroitic_Cursive_default2,
  Meroitic_Hieroglyphs: () => Meroitic_Hieroglyphs_default2,
  Miao: () => Miao_default2,
  Modi: () => Modi_default2,
  Mongolian: () => Mongolian_default2,
  Mro: () => Mro_default2,
  Multani: () => Multani_default2,
  Myanmar: () => Myanmar_default2,
  Nabataean: () => Nabataean_default2,
  Nag_Mundari: () => Nag_Mundari_default2,
  Nandinagari: () => Nandinagari_default2,
  New_Tai_Lue: () => New_Tai_Lue_default2,
  Newa: () => Newa_default2,
  Nko: () => Nko_default2,
  Nushu: () => Nushu_default2,
  Nyiakeng_Puachue_Hmong: () => Nyiakeng_Puachue_Hmong_default2,
  Ogham: () => Ogham_default2,
  Ol_Chiki: () => Ol_Chiki_default2,
  Old_Hungarian: () => Old_Hungarian_default2,
  Old_Italic: () => Old_Italic_default2,
  Old_North_Arabian: () => Old_North_Arabian_default2,
  Old_Permic: () => Old_Permic_default2,
  Old_Persian: () => Old_Persian_default2,
  Old_Sogdian: () => Old_Sogdian_default2,
  Old_South_Arabian: () => Old_South_Arabian_default2,
  Old_Turkic: () => Old_Turkic_default2,
  Old_Uyghur: () => Old_Uyghur_default2,
  Oriya: () => Oriya_default2,
  Osage: () => Osage_default2,
  Osmanya: () => Osmanya_default2,
  Pahawh_Hmong: () => Pahawh_Hmong_default2,
  Palmyrene: () => Palmyrene_default2,
  Pau_Cin_Hau: () => Pau_Cin_Hau_default2,
  Phags_Pa: () => Phags_Pa_default2,
  Phoenician: () => Phoenician_default2,
  Psalter_Pahlavi: () => Psalter_Pahlavi_default2,
  Rejang: () => Rejang_default2,
  Runic: () => Runic_default2,
  Samaritan: () => Samaritan_default2,
  Saurashtra: () => Saurashtra_default2,
  Sharada: () => Sharada_default2,
  Shavian: () => Shavian_default2,
  Siddham: () => Siddham_default2,
  SignWriting: () => SignWriting_default2,
  Sinhala: () => Sinhala_default2,
  Sogdian: () => Sogdian_default2,
  Sora_Sompeng: () => Sora_Sompeng_default2,
  Soyombo: () => Soyombo_default2,
  Sundanese: () => Sundanese_default2,
  Syloti_Nagri: () => Syloti_Nagri_default2,
  Syriac: () => Syriac_default2,
  Tagalog: () => Tagalog_default2,
  Tagbanwa: () => Tagbanwa_default2,
  Tai_Le: () => Tai_Le_default2,
  Tai_Tham: () => Tai_Tham_default2,
  Tai_Viet: () => Tai_Viet_default2,
  Takri: () => Takri_default2,
  Tamil: () => Tamil_default2,
  Tangsa: () => Tangsa_default2,
  Tangut: () => Tangut_default2,
  Telugu: () => Telugu_default2,
  Thaana: () => Thaana_default2,
  Thai: () => Thai_default2,
  Tibetan: () => Tibetan_default2,
  Tifinagh: () => Tifinagh_default2,
  Tirhuta: () => Tirhuta_default2,
  Toto: () => Toto_default2,
  Ugaritic: () => Ugaritic_default2,
  Vai: () => Vai_default2,
  Vithkuqi: () => Vithkuqi_default2,
  Wancho: () => Wancho_default2,
  Warang_Citi: () => Warang_Citi_default2,
  Yezidi: () => Yezidi_default2,
  Yi: () => Yi_default2,
  Zanabazar_Square: () => Zanabazar_Square_default2
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Adlam.js
var _295 = [1567, 1600, [125184, 125259], [125264, 125273], [125278, 125279]];
var Adlam_default2 = _295;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ahom.js
var _296 = [[71424, 71450], [71453, 71467], [71472, 71494]];
var Ahom_default2 = _296;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Anatolian_Hieroglyphs.js
var _297 = [[82944, 83526]];
var Anatolian_Hieroglyphs_default2 = _297;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Arabic.js
var _298 = [[1536, 1540], [1542, 1756], [1758, 1791], [1872, 1919], [2160, 2190], [2192, 2193], [2200, 2273], [2275, 2303], [64336, 64450], [64467, 64911], [64914, 64967], 64975, [65008, 65023], [65136, 65140], [65142, 65276], [66272, 66299], [69216, 69246], [69373, 69375], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705]];
var Arabic_default2 = _298;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Armenian.js
var _299 = [[1329, 1366], [1369, 1418], [1421, 1423], [64275, 64279]];
var Armenian_default2 = _299;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Avestan.js
var _300 = [[68352, 68405], [68409, 68415]];
var Avestan_default2 = _300;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Balinese.js
var _301 = [[6912, 6988], [6992, 7038]];
var Balinese_default2 = _301;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bamum.js
var _302 = [[42656, 42743], [92160, 92728]];
var Bamum_default2 = _302;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bassa_Vah.js
var _303 = [[92880, 92909], [92912, 92917]];
var Bassa_Vah_default2 = _303;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Batak.js
var _304 = [[7104, 7155], [7164, 7167]];
var Batak_default2 = _304;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bengali.js
var _305 = [[2385, 2386], [2404, 2405], [2432, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2558], 7376, 7378, [7381, 7382], 7384, 7393, 7402, 7405, 7410, [7413, 7415], 43249];
var Bengali_default2 = _305;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bhaiksuki.js
var _306 = [[72704, 72712], [72714, 72758], [72760, 72773], [72784, 72812]];
var Bhaiksuki_default2 = _306;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bopomofo.js
var _307 = [[746, 747], [12289, 12291], [12296, 12305], [12307, 12319], [12330, 12333], 12336, 12343, 12539, [12549, 12591], [12704, 12735], [65093, 65094], [65377, 65381]];
var Bopomofo_default2 = _307;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Brahmi.js
var _308 = [[69632, 69709], [69714, 69749], 69759];
var Brahmi_default2 = _308;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Braille.js
var _309 = [[10240, 10495]];
var Braille_default2 = _309;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Buginese.js
var _310 = [[6656, 6683], [6686, 6687], 43471];
var Buginese_default2 = _310;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Buhid.js
var _311 = [[5941, 5942], [5952, 5971]];
var Buhid_default2 = _311;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Canadian_Aboriginal.js
var _312 = [[5120, 5759], [6320, 6389], [72368, 72383]];
var Canadian_Aboriginal_default2 = _312;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Carian.js
var _313 = [[66208, 66256]];
var Carian_default2 = _313;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Caucasian_Albanian.js
var _314 = [[66864, 66915], 66927];
var Caucasian_Albanian_default2 = _314;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Chakma.js
var _315 = [[2534, 2543], [4160, 4169], [69888, 69940], [69942, 69959]];
var Chakma_default2 = _315;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cham.js
var _316 = [[43520, 43574], [43584, 43597], [43600, 43609], [43612, 43615]];
var Cham_default2 = _316;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cherokee.js
var _317 = [[5024, 5109], [5112, 5117], [43888, 43967]];
var Cherokee_default2 = _317;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Chorasmian.js
var _318 = [[69552, 69579]];
var Chorasmian_default2 = _318;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Common.js
var _319 = [[0, 64], [91, 96], [123, 169], [171, 185], [187, 191], 215, 247, [697, 735], [741, 745], [748, 767], 884, 894, 901, 903, 1541, 1757, 2274, 3647, [4053, 4056], [5867, 5869], [8192, 8203], [8206, 8238], [8240, 8292], [8294, 8304], [8308, 8318], [8320, 8334], [8352, 8384], [8448, 8485], [8487, 8489], [8492, 8497], [8499, 8525], [8527, 8543], [8585, 8587], [8592, 9254], [9280, 9290], [9312, 10239], [10496, 11123], [11126, 11157], [11159, 11263], [11776, 11842], [11844, 11869], [12272, 12283], 12288, 12292, 12306, 12320, 12342, [12872, 12895], 12927, [12977, 12991], [13004, 13007], [13169, 13178], [13184, 13279], 13311, [19904, 19967], [42760, 42785], [42888, 42890], 43867, [43882, 43883], [65040, 65049], [65072, 65092], [65095, 65106], [65108, 65126], [65128, 65131], 65279, [65281, 65312], [65339, 65344], [65371, 65376], [65504, 65510], [65512, 65518], [65529, 65533], [65936, 65948], [66e3, 66044], [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119142], [119146, 119162], [119171, 119172], [119180, 119209], [119214, 119274], [119488, 119507], [119520, 119539], [119552, 119638], [119666, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [126065, 126132], [126209, 126269], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127487], [127489, 127490], [127504, 127547], [127552, 127560], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], 917505, [917536, 917631]];
var Common_default2 = _319;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Coptic.js
var _320 = [[994, 1007], [11392, 11507], [11513, 11519], [66272, 66299]];
var Coptic_default2 = _320;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cuneiform.js
var _321 = [[73728, 74649], [74752, 74862], [74864, 74868], [74880, 75075]];
var Cuneiform_default2 = _321;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cypriot.js
var _322 = [[65792, 65794], [65799, 65843], [65847, 65855], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, 67647];
var Cypriot_default2 = _322;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cypro_Minoan.js
var _323 = [[65792, 65793], [77712, 77810]];
var Cypro_Minoan_default2 = _323;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cyrillic.js
var _324 = [[1024, 1327], [7296, 7304], 7467, 7544, 7672, [11744, 11775], 11843, [42560, 42655], [65070, 65071], [122928, 122989], 123023];
var Cyrillic_default2 = _324;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Deseret.js
var _325 = [[66560, 66639]];
var Deseret_default2 = _325;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Devanagari.js
var _326 = [[2304, 2386], [2389, 2431], [7376, 7414], [7416, 7417], 8432, [43056, 43065], [43232, 43263], [72448, 72457]];
var Devanagari_default2 = _326;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Dives_Akuru.js
var _327 = [[71936, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72006], [72016, 72025]];
var Dives_Akuru_default2 = _327;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Dogra.js
var _328 = [[2404, 2415], [43056, 43065], [71680, 71739]];
var Dogra_default2 = _328;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Duployan.js
var _329 = [[113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113820, 113827]];
var Duployan_default2 = _329;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Egyptian_Hieroglyphs.js
var _330 = [[77824, 78933]];
var Egyptian_Hieroglyphs_default2 = _330;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Elbasan.js
var _331 = [[66816, 66855]];
var Elbasan_default2 = _331;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Elymaic.js
var _332 = [[69600, 69622]];
var Elymaic_default2 = _332;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ethiopic.js
var _333 = [[4608, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4988], [4992, 5017], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926]];
var Ethiopic_default2 = _333;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Georgian.js
var _334 = [[4256, 4293], 4295, 4301, [4304, 4351], [7312, 7354], [7357, 7359], [11520, 11557], 11559, 11565];
var Georgian_default2 = _334;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Glagolitic.js
var _335 = [1156, 1159, [11264, 11359], 11843, 42607, [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922]];
var Glagolitic_default2 = _335;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gothic.js
var _336 = [[66352, 66378]];
var Gothic_default2 = _336;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Grantha.js
var _337 = [[2385, 2386], [2404, 2405], [3046, 3059], 7376, [7378, 7379], [7410, 7412], [7416, 7417], 8432, [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [73680, 73681], 73683];
var Grantha_default2 = _337;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Greek.js
var _338 = [834, 837, [880, 883], [885, 887], [890, 893], 895, 900, 902, [904, 906], 908, [910, 929], [931, 993], [1008, 1023], [7462, 7466], [7517, 7521], [7526, 7530], [7615, 7617], [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], 8486, 43877, [65856, 65934], 65952, [119296, 119365]];
var Greek_default2 = _338;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gujarati.js
var _339 = [[2385, 2386], [2404, 2405], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2801], [2809, 2815], [43056, 43065]];
var Gujarati_default2 = _339;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gunjala_Gondi.js
var _340 = [[2404, 2405], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129]];
var Gunjala_Gondi_default2 = _340;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gurmukhi.js
var _341 = [[2385, 2386], [2404, 2405], [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2678], [43056, 43065]];
var Gurmukhi_default2 = _341;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Han.js
var _342 = [[11904, 11929], [11931, 12019], [12032, 12245], [12289, 12291], [12293, 12305], [12307, 12319], [12321, 12333], 12336, [12343, 12351], 12539, [12688, 12703], [12736, 12771], [12832, 12871], [12928, 12976], [12992, 13003], 13055, [13144, 13168], [13179, 13183], [13280, 13310], [13312, 19903], [19968, 40959], [42752, 42759], [63744, 64109], [64112, 64217], [65093, 65094], [65377, 65381], [94178, 94179], [94192, 94193], [119648, 119665], [127568, 127569], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
var Han_default2 = _342;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hangul.js
var _343 = [[4352, 4607], [12289, 12291], [12296, 12305], [12307, 12319], [12334, 12336], 12343, 12539, [12593, 12686], [12800, 12830], [12896, 12926], [43360, 43388], [44032, 55203], [55216, 55238], [55243, 55291], [65093, 65094], [65377, 65381], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500]];
var Hangul_default2 = _343;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hanifi_Rohingya.js
var _344 = [1548, 1563, 1567, 1600, 1748, [68864, 68903], [68912, 68921]];
var Hanifi_Rohingya_default2 = _344;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hanunoo.js
var _345 = [[5920, 5942]];
var Hanunoo_default2 = _345;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hatran.js
var _346 = [[67808, 67826], [67828, 67829], [67835, 67839]];
var Hatran_default2 = _346;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hebrew.js
var _347 = [[1425, 1479], [1488, 1514], [1519, 1524], [64285, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
var Hebrew_default2 = _347;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hiragana.js
var _348 = [[12289, 12291], [12296, 12305], [12307, 12319], [12336, 12341], 12343, [12348, 12349], [12353, 12438], [12441, 12448], [12539, 12540], [65093, 65094], [65377, 65381], 65392, [65438, 65439], [110593, 110879], 110898, [110928, 110930], 127488];
var Hiragana_default2 = _348;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Imperial_Aramaic.js
var _349 = [[67648, 67669], [67671, 67679]];
var Imperial_Aramaic_default2 = _349;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Inherited.js
var _350 = [[768, 833], [835, 836], [838, 866], [2387, 2388], [6832, 6862], [7618, 7671], 7673, [7675, 7679], [8204, 8205], [8400, 8431], [65024, 65039], [65056, 65069], 66045, [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [917760, 917999]];
var Inherited_default2 = _350;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Inscriptional_Pahlavi.js
var _351 = [[68448, 68466], [68472, 68479]];
var Inscriptional_Pahlavi_default2 = _351;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Inscriptional_Parthian.js
var _352 = [[68416, 68437], [68440, 68447]];
var Inscriptional_Parthian_default2 = _352;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Javanese.js
var _353 = [[43392, 43469], [43471, 43481], [43486, 43487]];
var Javanese_default2 = _353;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kaithi.js
var _354 = [[2406, 2415], [43056, 43065], [69760, 69826], 69837];
var Kaithi_default2 = _354;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kannada.js
var _355 = [[2385, 2386], [2404, 2405], [3200, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], 7376, 7378, 7386, 7410, 7412, [43056, 43061]];
var Kannada_default2 = _355;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Katakana.js
var _356 = [[12289, 12291], [12296, 12305], [12307, 12319], [12336, 12341], 12343, [12348, 12349], [12441, 12444], [12448, 12543], [12784, 12799], [13008, 13054], [13056, 13143], [65093, 65094], [65377, 65439], [110576, 110579], [110581, 110587], [110589, 110590], 110592, [110880, 110882], 110933, [110948, 110951]];
var Katakana_default2 = _356;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kawi.js
var _357 = [[73472, 73488], [73490, 73530], [73534, 73561]];
var Kawi_default2 = _357;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kayah_Li.js
var _358 = [[43264, 43311]];
var Kayah_Li_default2 = _358;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kharoshthi.js
var _359 = [[68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], [68159, 68168], [68176, 68184]];
var Kharoshthi_default2 = _359;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khitan_Small_Script.js
var _360 = [94180, [101120, 101589]];
var Khitan_Small_Script_default2 = _360;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khmer.js
var _361 = [[6016, 6109], [6112, 6121], [6128, 6137], [6624, 6655]];
var Khmer_default2 = _361;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khojki.js
var _362 = [[2790, 2799], [43056, 43065], [70144, 70161], [70163, 70209]];
var Khojki_default2 = _362;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khudawadi.js
var _363 = [[2404, 2405], [43056, 43065], [70320, 70378], [70384, 70393]];
var Khudawadi_default2 = _363;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lao.js
var _364 = [[3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807]];
var Lao_default2 = _364;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Latin.js
var _365 = [[65, 90], [97, 122], 170, 186, [192, 214], [216, 246], [248, 696], [736, 740], [867, 879], [1157, 1158], [2385, 2386], 4347, [7424, 7461], [7468, 7516], [7522, 7525], [7531, 7543], [7545, 7614], [7680, 7935], 8239, 8305, 8319, [8336, 8348], 8432, [8490, 8491], 8498, 8526, [8544, 8584], [11360, 11391], [42752, 42759], [42786, 42887], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43007], 43310, [43824, 43866], [43868, 43876], [43878, 43881], [64256, 64262], [65313, 65338], [65345, 65370], [67456, 67461], [67463, 67504], [67506, 67514], [122624, 122654], [122661, 122666]];
var Latin_default2 = _365;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lepcha.js
var _366 = [[7168, 7223], [7227, 7241], [7245, 7247]];
var Lepcha_default2 = _366;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Limbu.js
var _367 = [2405, [6400, 6430], [6432, 6443], [6448, 6459], 6464, [6468, 6479]];
var Limbu_default2 = _367;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Linear_A.js
var _368 = [[65799, 65843], [67072, 67382], [67392, 67413], [67424, 67431]];
var Linear_A_default2 = _368;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Linear_B.js
var _369 = [[65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65792, 65794], [65799, 65843], [65847, 65855]];
var Linear_B_default2 = _369;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lisu.js
var _370 = [[42192, 42239], 73648];
var Lisu_default2 = _370;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lycian.js
var _371 = [[66176, 66204]];
var Lycian_default2 = _371;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lydian.js
var _372 = [[67872, 67897], 67903];
var Lydian_default2 = _372;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mahajani.js
var _373 = [[2404, 2415], [43056, 43065], [69968, 70006]];
var Mahajani_default2 = _373;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Makasar.js
var _374 = [[73440, 73464]];
var Makasar_default2 = _374;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Malayalam.js
var _375 = [[2385, 2386], [2404, 2405], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3407], [3412, 3427], [3430, 3455], 7386, [43056, 43058]];
var Malayalam_default2 = _375;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mandaic.js
var _376 = [1600, [2112, 2139], 2142];
var Mandaic_default2 = _376;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Manichaean.js
var _377 = [1600, [68288, 68326], [68331, 68342]];
var Manichaean_default2 = _377;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Marchen.js
var _378 = [[72816, 72847], [72850, 72871], [72873, 72886]];
var Marchen_default2 = _378;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Masaram_Gondi.js
var _379 = [[2404, 2405], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049]];
var Masaram_Gondi_default2 = _379;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Medefaidrin.js
var _380 = [[93760, 93850]];
var Medefaidrin_default2 = _380;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Meetei_Mayek.js
var _381 = [[43744, 43766], [43968, 44013], [44016, 44025]];
var Meetei_Mayek_default2 = _381;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mende_Kikakui.js
var _382 = [[124928, 125124], [125127, 125142]];
var Mende_Kikakui_default2 = _382;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Meroitic_Cursive.js
var _383 = [[68e3, 68023], [68028, 68047], [68050, 68095]];
var Meroitic_Cursive_default2 = _383;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Meroitic_Hieroglyphs.js
var _384 = [[67968, 67999]];
var Meroitic_Hieroglyphs_default2 = _384;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Miao.js
var _385 = [[93952, 94026], [94031, 94087], [94095, 94111]];
var Miao_default2 = _385;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Modi.js
var _386 = [[43056, 43065], [71168, 71236], [71248, 71257]];
var Modi_default2 = _386;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mongolian.js
var _387 = [[6144, 6169], [6176, 6264], [6272, 6314], 8239, [71264, 71276]];
var Mongolian_default2 = _387;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mro.js
var _388 = [[92736, 92766], [92768, 92777], [92782, 92783]];
var Mro_default2 = _388;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Multani.js
var _389 = [[2662, 2671], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313]];
var Multani_default2 = _389;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Myanmar.js
var _390 = [[4096, 4255], 43310, [43488, 43518], [43616, 43647]];
var Myanmar_default2 = _390;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nabataean.js
var _391 = [[67712, 67742], [67751, 67759]];
var Nabataean_default2 = _391;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nag_Mundari.js
var _392 = [[124112, 124153]];
var Nag_Mundari_default2 = _392;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nandinagari.js
var _393 = [[2404, 2405], [3302, 3311], 7401, 7410, 7418, [43056, 43061], [72096, 72103], [72106, 72151], [72154, 72164]];
var Nandinagari_default2 = _393;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/New_Tai_Lue.js
var _394 = [[6528, 6571], [6576, 6601], [6608, 6618], [6622, 6623]];
var New_Tai_Lue_default2 = _394;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Newa.js
var _395 = [[70656, 70747], [70749, 70753]];
var Newa_default2 = _395;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nko.js
var _396 = [1548, 1563, 1567, [1984, 2042], [2045, 2047], [64830, 64831]];
var Nko_default2 = _396;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nushu.js
var _397 = [94177, [110960, 111355]];
var Nushu_default2 = _397;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nyiakeng_Puachue_Hmong.js
var _398 = [[123136, 123180], [123184, 123197], [123200, 123209], [123214, 123215]];
var Nyiakeng_Puachue_Hmong_default2 = _398;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ogham.js
var _399 = [[5760, 5788]];
var Ogham_default2 = _399;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ol_Chiki.js
var _400 = [[7248, 7295]];
var Ol_Chiki_default2 = _400;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Hungarian.js
var _401 = [[68736, 68786], [68800, 68850], [68858, 68863]];
var Old_Hungarian_default2 = _401;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Italic.js
var _402 = [[66304, 66339], [66349, 66351]];
var Old_Italic_default2 = _402;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_North_Arabian.js
var _403 = [[68224, 68255]];
var Old_North_Arabian_default2 = _403;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Permic.js
var _404 = [1155, [66384, 66426]];
var Old_Permic_default2 = _404;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Persian.js
var _405 = [[66464, 66499], [66504, 66517]];
var Old_Persian_default2 = _405;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Sogdian.js
var _406 = [[69376, 69415]];
var Old_Sogdian_default2 = _406;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_South_Arabian.js
var _407 = [[68192, 68223]];
var Old_South_Arabian_default2 = _407;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Turkic.js
var _408 = [[68608, 68680]];
var Old_Turkic_default2 = _408;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Uyghur.js
var _409 = [1600, 68338, [69488, 69513]];
var Old_Uyghur_default2 = _409;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Oriya.js
var _410 = [[2385, 2386], [2404, 2405], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2935], 7386, 7410];
var Oriya_default2 = _410;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Osage.js
var _411 = [[66736, 66771], [66776, 66811]];
var Osage_default2 = _411;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Osmanya.js
var _412 = [[66688, 66717], [66720, 66729]];
var Osmanya_default2 = _412;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Pahawh_Hmong.js
var _413 = [[92928, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071]];
var Pahawh_Hmong_default2 = _413;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Palmyrene.js
var _414 = [[67680, 67711]];
var Palmyrene_default2 = _414;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Pau_Cin_Hau.js
var _415 = [[72384, 72440]];
var Pau_Cin_Hau_default2 = _415;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Phags_Pa.js
var _416 = [[6146, 6147], 6149, [43072, 43127]];
var Phags_Pa_default2 = _416;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Phoenician.js
var _417 = [[67840, 67867], 67871];
var Phoenician_default2 = _417;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Psalter_Pahlavi.js
var _418 = [1600, [68480, 68497], [68505, 68508], [68521, 68527]];
var Psalter_Pahlavi_default2 = _418;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Rejang.js
var _419 = [[43312, 43347], 43359];
var Rejang_default2 = _419;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Runic.js
var _420 = [[5792, 5866], [5870, 5880]];
var Runic_default2 = _420;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Samaritan.js
var _421 = [[2048, 2093], [2096, 2110]];
var Samaritan_default2 = _421;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Saurashtra.js
var _422 = [[43136, 43205], [43214, 43225]];
var Saurashtra_default2 = _422;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sharada.js
var _423 = [2385, 7383, 7385, [7388, 7389], 7392, [70016, 70111]];
var Sharada_default2 = _423;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Shavian.js
var _424 = [[66640, 66687]];
var Shavian_default2 = _424;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Siddham.js
var _425 = [[71040, 71093], [71096, 71133]];
var Siddham_default2 = _425;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/SignWriting.js
var _426 = [[120832, 121483], [121499, 121503], [121505, 121519]];
var SignWriting_default2 = _426;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sinhala.js
var _427 = [[2404, 2405], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3572], [70113, 70132]];
var Sinhala_default2 = _427;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sogdian.js
var _428 = [1600, [69424, 69465]];
var Sogdian_default2 = _428;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sora_Sompeng.js
var _429 = [[69840, 69864], [69872, 69881]];
var Sora_Sompeng_default2 = _429;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Soyombo.js
var _430 = [[72272, 72354]];
var Soyombo_default2 = _430;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sundanese.js
var _431 = [[7040, 7103], [7360, 7367]];
var Sundanese_default2 = _431;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Syloti_Nagri.js
var _432 = [[2404, 2405], [2534, 2543], [43008, 43052]];
var Syloti_Nagri_default2 = _432;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Syriac.js
var _433 = [1548, [1563, 1564], 1567, 1600, [1611, 1621], 1648, [1792, 1805], [1807, 1866], [1869, 1871], [2144, 2154], 7672, 7674];
var Syriac_default2 = _433;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tagalog.js
var _434 = [[5888, 5909], 5919, [5941, 5942]];
var Tagalog_default2 = _434;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tagbanwa.js
var _435 = [[5941, 5942], [5984, 5996], [5998, 6e3], [6002, 6003]];
var Tagbanwa_default2 = _435;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tai_Le.js
var _436 = [[4160, 4169], [6480, 6509], [6512, 6516]];
var Tai_Le_default2 = _436;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tai_Tham.js
var _437 = [[6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], [6816, 6829]];
var Tai_Tham_default2 = _437;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tai_Viet.js
var _438 = [[43648, 43714], [43739, 43743]];
var Tai_Viet_default2 = _438;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Takri.js
var _439 = [[2404, 2405], [43056, 43065], [71296, 71353], [71360, 71369]];
var Takri_default2 = _439;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tamil.js
var _440 = [[2385, 2386], [2404, 2405], [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3066], 7386, 43251, 70401, 70403, [70459, 70460], [73664, 73713], 73727];
var Tamil_default2 = _440;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tangsa.js
var _441 = [[92784, 92862], [92864, 92873]];
var Tangsa_default2 = _441;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tangut.js
var _442 = [94176, [94208, 100343], [100352, 101119], [101632, 101640]];
var Tangut_default2 = _442;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Telugu.js
var _443 = [[2385, 2386], [2404, 2405], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3191, 3199], 7386, 7410];
var Telugu_default2 = _443;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Thaana.js
var _444 = [1548, [1563, 1564], 1567, [1632, 1641], [1920, 1969], 65010, 65021];
var Thaana_default2 = _444;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Thai.js
var _445 = [[3585, 3642], [3648, 3675]];
var Thai_default2 = _445;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tibetan.js
var _446 = [[3840, 3911], [3913, 3948], [3953, 3991], [3993, 4028], [4030, 4044], [4046, 4052], [4057, 4058]];
var Tibetan_default2 = _446;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tifinagh.js
var _447 = [[11568, 11623], [11631, 11632], 11647];
var Tifinagh_default2 = _447;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tirhuta.js
var _448 = [[2385, 2386], [2404, 2405], 7410, [43056, 43065], [70784, 70855], [70864, 70873]];
var Tirhuta_default2 = _448;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Toto.js
var _449 = [[123536, 123566]];
var Toto_default2 = _449;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ugaritic.js
var _450 = [[66432, 66461], 66463];
var Ugaritic_default2 = _450;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Vai.js
var _451 = [[42240, 42539]];
var Vai_default2 = _451;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Vithkuqi.js
var _452 = [[66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004]];
var Vithkuqi_default2 = _452;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Wancho.js
var _453 = [[123584, 123641], 123647];
var Wancho_default2 = _453;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Warang_Citi.js
var _454 = [[71840, 71922], 71935];
var Warang_Citi_default2 = _454;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Yezidi.js
var _455 = [1548, 1563, 1567, [1632, 1641], [69248, 69289], [69291, 69293], [69296, 69297]];
var Yezidi_default2 = _455;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Yi.js
var _456 = [[12289, 12290], [12296, 12305], [12308, 12315], 12539, [40960, 42124], [42128, 42182], [65377, 65381]];
var Yi_default2 = _456;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Zanabazar_Square.js
var _457 = [[72192, 72263]];
var Zanabazar_Square_default2 = _457;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/index.js
var Case_Folding_exports = {};
__export(Case_Folding_exports, {
  C: () => C_default,
  F: () => F_default,
  S: () => S_default,
  T: () => T_default
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/C.js
var _458 = [];
var C_default = _458;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/F.js
var _459 = [];
var F_default = _459;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/S.js
var _460 = [];
var S_default = _460;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/T.js
var _461 = [];
var T_default = _461;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/index.js
var Block_exports = {};
__export(Block_exports, {
  Adlam: () => Adlam_default3,
  Aegean_Numbers: () => Aegean_Numbers_default,
  Ahom: () => Ahom_default3,
  Alchemical_Symbols: () => Alchemical_Symbols_default,
  Alphabetic_Presentation_Forms: () => Alphabetic_Presentation_Forms_default,
  Anatolian_Hieroglyphs: () => Anatolian_Hieroglyphs_default3,
  Ancient_Greek_Musical_Notation: () => Ancient_Greek_Musical_Notation_default,
  Ancient_Greek_Numbers: () => Ancient_Greek_Numbers_default,
  Ancient_Symbols: () => Ancient_Symbols_default,
  Arabic: () => Arabic_default3,
  Arabic_Extended_A: () => Arabic_Extended_A_default,
  Arabic_Mathematical_Alphabetic_Symbols: () => Arabic_Mathematical_Alphabetic_Symbols_default,
  Arabic_Presentation_Forms_A: () => Arabic_Presentation_Forms_A_default,
  Arabic_Presentation_Forms_B: () => Arabic_Presentation_Forms_B_default,
  Arabic_Supplement: () => Arabic_Supplement_default,
  Armenian: () => Armenian_default3,
  Arrows: () => Arrows_default,
  Avestan: () => Avestan_default3,
  Balinese: () => Balinese_default3,
  Bamum: () => Bamum_default3,
  Bamum_Supplement: () => Bamum_Supplement_default,
  Basic_Latin: () => Basic_Latin_default,
  Bassa_Vah: () => Bassa_Vah_default3,
  Batak: () => Batak_default3,
  Bengali: () => Bengali_default3,
  Bhaiksuki: () => Bhaiksuki_default3,
  Block_Elements: () => Block_Elements_default,
  Bopomofo: () => Bopomofo_default3,
  Bopomofo_Extended: () => Bopomofo_Extended_default,
  Box_Drawing: () => Box_Drawing_default,
  Brahmi: () => Brahmi_default3,
  Braille_Patterns: () => Braille_Patterns_default,
  Buginese: () => Buginese_default3,
  Buhid: () => Buhid_default3,
  Byzantine_Musical_Symbols: () => Byzantine_Musical_Symbols_default,
  CJK_Compatibility: () => CJK_Compatibility_default,
  CJK_Compatibility_Forms: () => CJK_Compatibility_Forms_default,
  CJK_Compatibility_Ideographs: () => CJK_Compatibility_Ideographs_default,
  CJK_Compatibility_Ideographs_Supplement: () => CJK_Compatibility_Ideographs_Supplement_default,
  CJK_Radicals_Supplement: () => CJK_Radicals_Supplement_default,
  CJK_Strokes: () => CJK_Strokes_default,
  CJK_Symbols_And_Punctuation: () => CJK_Symbols_And_Punctuation_default,
  CJK_Unified_Ideographs: () => CJK_Unified_Ideographs_default,
  CJK_Unified_Ideographs_Extension_A: () => CJK_Unified_Ideographs_Extension_A_default,
  CJK_Unified_Ideographs_Extension_B: () => CJK_Unified_Ideographs_Extension_B_default,
  CJK_Unified_Ideographs_Extension_C: () => CJK_Unified_Ideographs_Extension_C_default,
  CJK_Unified_Ideographs_Extension_D: () => CJK_Unified_Ideographs_Extension_D_default,
  CJK_Unified_Ideographs_Extension_E: () => CJK_Unified_Ideographs_Extension_E_default,
  CJK_Unified_Ideographs_Extension_F: () => CJK_Unified_Ideographs_Extension_F_default,
  Carian: () => Carian_default3,
  Caucasian_Albanian: () => Caucasian_Albanian_default3,
  Chakma: () => Chakma_default3,
  Cham: () => Cham_default3,
  Cherokee: () => Cherokee_default3,
  Cherokee_Supplement: () => Cherokee_Supplement_default,
  Chess_Symbols: () => Chess_Symbols_default,
  Combining_Diacritical_Marks: () => Combining_Diacritical_Marks_default,
  Combining_Diacritical_Marks_Extended: () => Combining_Diacritical_Marks_Extended_default,
  Combining_Diacritical_Marks_For_Symbols: () => Combining_Diacritical_Marks_For_Symbols_default,
  Combining_Diacritical_Marks_Supplement: () => Combining_Diacritical_Marks_Supplement_default,
  Combining_Half_Marks: () => Combining_Half_Marks_default,
  Common_Indic_Number_Forms: () => Common_Indic_Number_Forms_default,
  Control_Pictures: () => Control_Pictures_default,
  Coptic: () => Coptic_default3,
  Coptic_Epact_Numbers: () => Coptic_Epact_Numbers_default,
  Counting_Rod_Numerals: () => Counting_Rod_Numerals_default,
  Cuneiform: () => Cuneiform_default3,
  Cuneiform_Numbers_And_Punctuation: () => Cuneiform_Numbers_And_Punctuation_default,
  Currency_Symbols: () => Currency_Symbols_default,
  Cypriot_Syllabary: () => Cypriot_Syllabary_default,
  Cyrillic: () => Cyrillic_default3,
  Cyrillic_Extended_A: () => Cyrillic_Extended_A_default,
  Cyrillic_Extended_B: () => Cyrillic_Extended_B_default,
  Cyrillic_Extended_C: () => Cyrillic_Extended_C_default,
  Cyrillic_Supplement: () => Cyrillic_Supplement_default,
  Deseret: () => Deseret_default3,
  Devanagari: () => Devanagari_default3,
  Devanagari_Extended: () => Devanagari_Extended_default,
  Dingbats: () => Dingbats_default,
  Dogra: () => Dogra_default3,
  Domino_Tiles: () => Domino_Tiles_default,
  Duployan: () => Duployan_default3,
  Early_Dynastic_Cuneiform: () => Early_Dynastic_Cuneiform_default,
  Egyptian_Hieroglyphs: () => Egyptian_Hieroglyphs_default3,
  Elbasan: () => Elbasan_default3,
  Emoticons: () => Emoticons_default,
  Enclosed_Alphanumeric_Supplement: () => Enclosed_Alphanumeric_Supplement_default,
  Enclosed_Alphanumerics: () => Enclosed_Alphanumerics_default,
  Enclosed_CJK_Letters_And_Months: () => Enclosed_CJK_Letters_And_Months_default,
  Enclosed_Ideographic_Supplement: () => Enclosed_Ideographic_Supplement_default,
  Ethiopic: () => Ethiopic_default3,
  Ethiopic_Extended: () => Ethiopic_Extended_default,
  Ethiopic_Extended_A: () => Ethiopic_Extended_A_default,
  Ethiopic_Supplement: () => Ethiopic_Supplement_default,
  General_Punctuation: () => General_Punctuation_default,
  Geometric_Shapes: () => Geometric_Shapes_default,
  Geometric_Shapes_Extended: () => Geometric_Shapes_Extended_default,
  Georgian: () => Georgian_default3,
  Georgian_Extended: () => Georgian_Extended_default,
  Georgian_Supplement: () => Georgian_Supplement_default,
  Glagolitic: () => Glagolitic_default3,
  Glagolitic_Supplement: () => Glagolitic_Supplement_default,
  Gothic: () => Gothic_default3,
  Grantha: () => Grantha_default3,
  Greek_And_Coptic: () => Greek_And_Coptic_default,
  Greek_Extended: () => Greek_Extended_default,
  Gujarati: () => Gujarati_default3,
  Gunjala_Gondi: () => Gunjala_Gondi_default3,
  Gurmukhi: () => Gurmukhi_default3,
  Halfwidth_And_Fullwidth_Forms: () => Halfwidth_And_Fullwidth_Forms_default,
  Hangul_Compatibility_Jamo: () => Hangul_Compatibility_Jamo_default,
  Hangul_Jamo: () => Hangul_Jamo_default,
  Hangul_Jamo_Extended_A: () => Hangul_Jamo_Extended_A_default,
  Hangul_Jamo_Extended_B: () => Hangul_Jamo_Extended_B_default,
  Hangul_Syllables: () => Hangul_Syllables_default,
  Hanifi_Rohingya: () => Hanifi_Rohingya_default3,
  Hanunoo: () => Hanunoo_default3,
  Hatran: () => Hatran_default3,
  Hebrew: () => Hebrew_default3,
  High_Private_Use_Surrogates: () => High_Private_Use_Surrogates_default,
  High_Surrogates: () => High_Surrogates_default,
  Hiragana: () => Hiragana_default3,
  IPA_Extensions: () => IPA_Extensions_default,
  Ideographic_Description_Characters: () => Ideographic_Description_Characters_default,
  Ideographic_Symbols_And_Punctuation: () => Ideographic_Symbols_And_Punctuation_default,
  Imperial_Aramaic: () => Imperial_Aramaic_default3,
  Indic_Siyaq_Numbers: () => Indic_Siyaq_Numbers_default,
  Inscriptional_Pahlavi: () => Inscriptional_Pahlavi_default3,
  Inscriptional_Parthian: () => Inscriptional_Parthian_default3,
  Javanese: () => Javanese_default3,
  Kaithi: () => Kaithi_default3,
  Kana_Extended_A: () => Kana_Extended_A_default,
  Kana_Supplement: () => Kana_Supplement_default,
  Kanbun: () => Kanbun_default,
  Kangxi_Radicals: () => Kangxi_Radicals_default,
  Kannada: () => Kannada_default3,
  Katakana: () => Katakana_default3,
  Katakana_Phonetic_Extensions: () => Katakana_Phonetic_Extensions_default,
  Kayah_Li: () => Kayah_Li_default3,
  Kharoshthi: () => Kharoshthi_default3,
  Khmer: () => Khmer_default3,
  Khmer_Symbols: () => Khmer_Symbols_default,
  Khojki: () => Khojki_default3,
  Khudawadi: () => Khudawadi_default3,
  Lao: () => Lao_default3,
  Latin_1_Supplement: () => Latin_1_Supplement_default,
  Latin_Extended_A: () => Latin_Extended_A_default,
  Latin_Extended_Additional: () => Latin_Extended_Additional_default,
  Latin_Extended_B: () => Latin_Extended_B_default,
  Latin_Extended_C: () => Latin_Extended_C_default,
  Latin_Extended_D: () => Latin_Extended_D_default,
  Latin_Extended_E: () => Latin_Extended_E_default,
  Lepcha: () => Lepcha_default3,
  Letterlike_Symbols: () => Letterlike_Symbols_default,
  Limbu: () => Limbu_default3,
  Linear_A: () => Linear_A_default3,
  Linear_B_Ideograms: () => Linear_B_Ideograms_default,
  Linear_B_Syllabary: () => Linear_B_Syllabary_default,
  Lisu: () => Lisu_default3,
  Low_Surrogates: () => Low_Surrogates_default,
  Lycian: () => Lycian_default3,
  Lydian: () => Lydian_default3,
  Mahajani: () => Mahajani_default3,
  Mahjong_Tiles: () => Mahjong_Tiles_default,
  Makasar: () => Makasar_default3,
  Malayalam: () => Malayalam_default3,
  Mandaic: () => Mandaic_default3,
  Manichaean: () => Manichaean_default3,
  Marchen: () => Marchen_default3,
  Masaram_Gondi: () => Masaram_Gondi_default3,
  Mathematical_Alphanumeric_Symbols: () => Mathematical_Alphanumeric_Symbols_default,
  Mathematical_Operators: () => Mathematical_Operators_default,
  Mayan_Numerals: () => Mayan_Numerals_default,
  Medefaidrin: () => Medefaidrin_default3,
  Meetei_Mayek: () => Meetei_Mayek_default3,
  Meetei_Mayek_Extensions: () => Meetei_Mayek_Extensions_default,
  Mende_Kikakui: () => Mende_Kikakui_default3,
  Meroitic_Cursive: () => Meroitic_Cursive_default3,
  Meroitic_Hieroglyphs: () => Meroitic_Hieroglyphs_default3,
  Miao: () => Miao_default3,
  Miscellaneous_Mathematical_Symbols_A: () => Miscellaneous_Mathematical_Symbols_A_default,
  Miscellaneous_Mathematical_Symbols_B: () => Miscellaneous_Mathematical_Symbols_B_default,
  Miscellaneous_Symbols: () => Miscellaneous_Symbols_default,
  Miscellaneous_Symbols_And_Arrows: () => Miscellaneous_Symbols_And_Arrows_default,
  Miscellaneous_Symbols_And_Pictographs: () => Miscellaneous_Symbols_And_Pictographs_default,
  Miscellaneous_Technical: () => Miscellaneous_Technical_default,
  Modi: () => Modi_default3,
  Modifier_Tone_Letters: () => Modifier_Tone_Letters_default,
  Mongolian: () => Mongolian_default3,
  Mongolian_Supplement: () => Mongolian_Supplement_default,
  Mro: () => Mro_default3,
  Multani: () => Multani_default3,
  Musical_Symbols: () => Musical_Symbols_default,
  Myanmar: () => Myanmar_default3,
  Myanmar_Extended_A: () => Myanmar_Extended_A_default,
  Myanmar_Extended_B: () => Myanmar_Extended_B_default,
  NKo: () => NKo_default,
  Nabataean: () => Nabataean_default3,
  New_Tai_Lue: () => New_Tai_Lue_default3,
  Newa: () => Newa_default3,
  Number_Forms: () => Number_Forms_default,
  Nushu: () => Nushu_default3,
  Ogham: () => Ogham_default3,
  Ol_Chiki: () => Ol_Chiki_default3,
  Old_Hungarian: () => Old_Hungarian_default3,
  Old_Italic: () => Old_Italic_default3,
  Old_North_Arabian: () => Old_North_Arabian_default3,
  Old_Permic: () => Old_Permic_default3,
  Old_Persian: () => Old_Persian_default3,
  Old_Sogdian: () => Old_Sogdian_default3,
  Old_South_Arabian: () => Old_South_Arabian_default3,
  Old_Turkic: () => Old_Turkic_default3,
  Optical_Character_Recognition: () => Optical_Character_Recognition_default,
  Oriya: () => Oriya_default3,
  Ornamental_Dingbats: () => Ornamental_Dingbats_default,
  Osage: () => Osage_default3,
  Osmanya: () => Osmanya_default3,
  Pahawh_Hmong: () => Pahawh_Hmong_default3,
  Palmyrene: () => Palmyrene_default3,
  Pau_Cin_Hau: () => Pau_Cin_Hau_default3,
  Phags_Pa: () => Phags_Pa_default3,
  Phaistos_Disc: () => Phaistos_Disc_default,
  Phoenician: () => Phoenician_default3,
  Phonetic_Extensions: () => Phonetic_Extensions_default,
  Phonetic_Extensions_Supplement: () => Phonetic_Extensions_Supplement_default,
  Playing_Cards: () => Playing_Cards_default,
  Private_Use_Area: () => Private_Use_Area_default,
  Psalter_Pahlavi: () => Psalter_Pahlavi_default3,
  Rejang: () => Rejang_default3,
  Rumi_Numeral_Symbols: () => Rumi_Numeral_Symbols_default,
  Runic: () => Runic_default3,
  Samaritan: () => Samaritan_default3,
  Saurashtra: () => Saurashtra_default3,
  Sharada: () => Sharada_default3,
  Shavian: () => Shavian_default3,
  Shorthand_Format_Controls: () => Shorthand_Format_Controls_default,
  Siddham: () => Siddham_default3,
  Sinhala: () => Sinhala_default3,
  Sinhala_Archaic_Numbers: () => Sinhala_Archaic_Numbers_default,
  Small_Form_Variants: () => Small_Form_Variants_default,
  Sogdian: () => Sogdian_default3,
  Sora_Sompeng: () => Sora_Sompeng_default3,
  Soyombo: () => Soyombo_default3,
  Spacing_Modifier_Letters: () => Spacing_Modifier_Letters_default,
  Specials: () => Specials_default,
  Sundanese: () => Sundanese_default3,
  Sundanese_Supplement: () => Sundanese_Supplement_default,
  Superscripts_And_Subscripts: () => Superscripts_And_Subscripts_default,
  Supplemental_Arrows_A: () => Supplemental_Arrows_A_default,
  Supplemental_Arrows_B: () => Supplemental_Arrows_B_default,
  Supplemental_Arrows_C: () => Supplemental_Arrows_C_default,
  Supplemental_Mathematical_Operators: () => Supplemental_Mathematical_Operators_default,
  Supplemental_Punctuation: () => Supplemental_Punctuation_default,
  Supplemental_Symbols_And_Pictographs: () => Supplemental_Symbols_And_Pictographs_default,
  Supplementary_Private_Use_Area_A: () => Supplementary_Private_Use_Area_A_default,
  Supplementary_Private_Use_Area_B: () => Supplementary_Private_Use_Area_B_default,
  Sutton_SignWriting: () => Sutton_SignWriting_default,
  Syloti_Nagri: () => Syloti_Nagri_default3,
  Syriac: () => Syriac_default3,
  Syriac_Supplement: () => Syriac_Supplement_default,
  Tagalog: () => Tagalog_default3,
  Tagbanwa: () => Tagbanwa_default3,
  Tags: () => Tags_default,
  Tai_Le: () => Tai_Le_default3,
  Tai_Tham: () => Tai_Tham_default3,
  Tai_Viet: () => Tai_Viet_default3,
  Tai_Xuan_Jing_Symbols: () => Tai_Xuan_Jing_Symbols_default,
  Takri: () => Takri_default3,
  Tamil: () => Tamil_default3,
  Tangut: () => Tangut_default3,
  Tangut_Components: () => Tangut_Components_default,
  Telugu: () => Telugu_default3,
  Thaana: () => Thaana_default3,
  Thai: () => Thai_default3,
  Tibetan: () => Tibetan_default3,
  Tifinagh: () => Tifinagh_default3,
  Tirhuta: () => Tirhuta_default3,
  Transport_And_Map_Symbols: () => Transport_And_Map_Symbols_default,
  Ugaritic: () => Ugaritic_default3,
  Unified_Canadian_Aboriginal_Syllabics: () => Unified_Canadian_Aboriginal_Syllabics_default,
  Unified_Canadian_Aboriginal_Syllabics_Extended: () => Unified_Canadian_Aboriginal_Syllabics_Extended_default,
  Vai: () => Vai_default3,
  Variation_Selectors: () => Variation_Selectors_default,
  Variation_Selectors_Supplement: () => Variation_Selectors_Supplement_default,
  Vedic_Extensions: () => Vedic_Extensions_default,
  Vertical_Forms: () => Vertical_Forms_default,
  Warang_Citi: () => Warang_Citi_default3,
  Yi_Radicals: () => Yi_Radicals_default,
  Yi_Syllables: () => Yi_Syllables_default,
  Yijing_Hexagram_Symbols: () => Yijing_Hexagram_Symbols_default,
  Zanabazar_Square: () => Zanabazar_Square_default3,
  undefined: () => undefined_default
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Adlam.js
var _462 = [[125184, 125279]];
var Adlam_default3 = _462;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Aegean_Numbers.js
var _463 = [[65792, 65855]];
var Aegean_Numbers_default = _463;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ahom.js
var _464 = [[71424, 71503]];
var Ahom_default3 = _464;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Alchemical_Symbols.js
var _465 = [[128768, 128895]];
var Alchemical_Symbols_default = _465;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Alphabetic_Presentation_Forms.js
var _466 = [[64256, 64335]];
var Alphabetic_Presentation_Forms_default = _466;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Anatolian_Hieroglyphs.js
var _467 = [[82944, 83583]];
var Anatolian_Hieroglyphs_default3 = _467;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ancient_Greek_Musical_Notation.js
var _468 = [[119296, 119375]];
var Ancient_Greek_Musical_Notation_default = _468;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ancient_Greek_Numbers.js
var _469 = [[65856, 65935]];
var Ancient_Greek_Numbers_default = _469;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ancient_Symbols.js
var _470 = [[65936, 65999]];
var Ancient_Symbols_default = _470;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic.js
var _471 = [[1536, 1791]];
var Arabic_default3 = _471;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Extended_A.js
var _472 = [[2208, 2303]];
var Arabic_Extended_A_default = _472;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Mathematical_Alphabetic_Symbols.js
var _473 = [[126464, 126719]];
var Arabic_Mathematical_Alphabetic_Symbols_default = _473;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Presentation_Forms_A.js
var _474 = [[64336, 65023]];
var Arabic_Presentation_Forms_A_default = _474;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Presentation_Forms_B.js
var _475 = [[65136, 65279]];
var Arabic_Presentation_Forms_B_default = _475;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Supplement.js
var _476 = [[1872, 1919]];
var Arabic_Supplement_default = _476;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Armenian.js
var _477 = [[1328, 1423]];
var Armenian_default3 = _477;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arrows.js
var _478 = [[8592, 8703]];
var Arrows_default = _478;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Avestan.js
var _479 = [[68352, 68415]];
var Avestan_default3 = _479;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Balinese.js
var _480 = [[6912, 7039]];
var Balinese_default3 = _480;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bamum.js
var _481 = [[42656, 42751]];
var Bamum_default3 = _481;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bamum_Supplement.js
var _482 = [[92160, 92735]];
var Bamum_Supplement_default = _482;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Basic_Latin.js
var _483 = [[0, 127]];
var Basic_Latin_default = _483;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bassa_Vah.js
var _484 = [[92880, 92927]];
var Bassa_Vah_default3 = _484;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Batak.js
var _485 = [[7104, 7167]];
var Batak_default3 = _485;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bengali.js
var _486 = [[2432, 2559]];
var Bengali_default3 = _486;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bhaiksuki.js
var _487 = [[72704, 72815]];
var Bhaiksuki_default3 = _487;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Block_Elements.js
var _488 = [[9600, 9631]];
var Block_Elements_default = _488;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bopomofo.js
var _489 = [[12544, 12591]];
var Bopomofo_default3 = _489;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bopomofo_Extended.js
var _490 = [[12704, 12735]];
var Bopomofo_Extended_default = _490;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Box_Drawing.js
var _491 = [[9472, 9599]];
var Box_Drawing_default = _491;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Brahmi.js
var _492 = [[69632, 69759]];
var Brahmi_default3 = _492;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Braille_Patterns.js
var _493 = [[10240, 10495]];
var Braille_Patterns_default = _493;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Buginese.js
var _494 = [[6656, 6687]];
var Buginese_default3 = _494;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Buhid.js
var _495 = [[5952, 5983]];
var Buhid_default3 = _495;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Byzantine_Musical_Symbols.js
var _496 = [[118784, 119039]];
var Byzantine_Musical_Symbols_default = _496;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility.js
var _497 = [[13056, 13311]];
var CJK_Compatibility_default = _497;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility_Forms.js
var _498 = [[65072, 65103]];
var CJK_Compatibility_Forms_default = _498;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility_Ideographs.js
var _499 = [[63744, 64255]];
var CJK_Compatibility_Ideographs_default = _499;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility_Ideographs_Supplement.js
var _500 = [[194560, 195103]];
var CJK_Compatibility_Ideographs_Supplement_default = _500;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Radicals_Supplement.js
var _501 = [[11904, 12031]];
var CJK_Radicals_Supplement_default = _501;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Strokes.js
var _502 = [[12736, 12783]];
var CJK_Strokes_default = _502;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Symbols_And_Punctuation.js
var _503 = [[12288, 12351]];
var CJK_Symbols_And_Punctuation_default = _503;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs.js
var _504 = [[19968, 40959]];
var CJK_Unified_Ideographs_default = _504;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_A.js
var _505 = [[13312, 19903]];
var CJK_Unified_Ideographs_Extension_A_default = _505;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_B.js
var _506 = [[131072, 173791]];
var CJK_Unified_Ideographs_Extension_B_default = _506;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_C.js
var _507 = [[173824, 177983]];
var CJK_Unified_Ideographs_Extension_C_default = _507;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_D.js
var _508 = [[177984, 178207]];
var CJK_Unified_Ideographs_Extension_D_default = _508;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_E.js
var _509 = [[178208, 183983]];
var CJK_Unified_Ideographs_Extension_E_default = _509;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_F.js
var _510 = [[183984, 191471]];
var CJK_Unified_Ideographs_Extension_F_default = _510;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Carian.js
var _511 = [[66208, 66271]];
var Carian_default3 = _511;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Caucasian_Albanian.js
var _512 = [[66864, 66927]];
var Caucasian_Albanian_default3 = _512;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Chakma.js
var _513 = [[69888, 69967]];
var Chakma_default3 = _513;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cham.js
var _514 = [[43520, 43615]];
var Cham_default3 = _514;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cherokee.js
var _515 = [[5024, 5119]];
var Cherokee_default3 = _515;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cherokee_Supplement.js
var _516 = [[43888, 43967]];
var Cherokee_Supplement_default = _516;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Chess_Symbols.js
var _517 = [[129536, 129647]];
var Chess_Symbols_default = _517;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks.js
var _518 = [[768, 879]];
var Combining_Diacritical_Marks_default = _518;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks_Extended.js
var _519 = [[6832, 6911]];
var Combining_Diacritical_Marks_Extended_default = _519;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks_For_Symbols.js
var _520 = [[8400, 8447]];
var Combining_Diacritical_Marks_For_Symbols_default = _520;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks_Supplement.js
var _521 = [[7616, 7679]];
var Combining_Diacritical_Marks_Supplement_default = _521;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Half_Marks.js
var _522 = [[65056, 65071]];
var Combining_Half_Marks_default = _522;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Common_Indic_Number_Forms.js
var _523 = [[43056, 43071]];
var Common_Indic_Number_Forms_default = _523;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Control_Pictures.js
var _524 = [[9216, 9279]];
var Control_Pictures_default = _524;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Coptic.js
var _525 = [[11392, 11519]];
var Coptic_default3 = _525;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Coptic_Epact_Numbers.js
var _526 = [[66272, 66303]];
var Coptic_Epact_Numbers_default = _526;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Counting_Rod_Numerals.js
var _527 = [[119648, 119679]];
var Counting_Rod_Numerals_default = _527;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cuneiform.js
var _528 = [[73728, 74751]];
var Cuneiform_default3 = _528;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cuneiform_Numbers_And_Punctuation.js
var _529 = [[74752, 74879]];
var Cuneiform_Numbers_And_Punctuation_default = _529;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Currency_Symbols.js
var _530 = [[8352, 8399]];
var Currency_Symbols_default = _530;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cypriot_Syllabary.js
var _531 = [[67584, 67647]];
var Cypriot_Syllabary_default = _531;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic.js
var _532 = [[1024, 1279]];
var Cyrillic_default3 = _532;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Extended_A.js
var _533 = [[11744, 11775]];
var Cyrillic_Extended_A_default = _533;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Extended_B.js
var _534 = [[42560, 42655]];
var Cyrillic_Extended_B_default = _534;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Extended_C.js
var _535 = [[7296, 7311]];
var Cyrillic_Extended_C_default = _535;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Supplement.js
var _536 = [[1280, 1327]];
var Cyrillic_Supplement_default = _536;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Deseret.js
var _537 = [[66560, 66639]];
var Deseret_default3 = _537;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Devanagari.js
var _538 = [[2304, 2431]];
var Devanagari_default3 = _538;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Devanagari_Extended.js
var _539 = [[43232, 43263]];
var Devanagari_Extended_default = _539;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Dingbats.js
var _540 = [[9984, 10175]];
var Dingbats_default = _540;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Dogra.js
var _541 = [[71680, 71759]];
var Dogra_default3 = _541;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Domino_Tiles.js
var _542 = [[127024, 127135]];
var Domino_Tiles_default = _542;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Duployan.js
var _543 = [[113664, 113823]];
var Duployan_default3 = _543;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Early_Dynastic_Cuneiform.js
var _544 = [[74880, 75087]];
var Early_Dynastic_Cuneiform_default = _544;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Egyptian_Hieroglyphs.js
var _545 = [[77824, 78895]];
var Egyptian_Hieroglyphs_default3 = _545;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Elbasan.js
var _546 = [[66816, 66863]];
var Elbasan_default3 = _546;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Emoticons.js
var _547 = [[128512, 128591]];
var Emoticons_default = _547;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_Alphanumeric_Supplement.js
var _548 = [[127232, 127487]];
var Enclosed_Alphanumeric_Supplement_default = _548;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_Alphanumerics.js
var _549 = [[9312, 9471]];
var Enclosed_Alphanumerics_default = _549;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_CJK_Letters_And_Months.js
var _550 = [[12800, 13055]];
var Enclosed_CJK_Letters_And_Months_default = _550;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_Ideographic_Supplement.js
var _551 = [[127488, 127743]];
var Enclosed_Ideographic_Supplement_default = _551;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic.js
var _552 = [[4608, 4991]];
var Ethiopic_default3 = _552;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic_Extended.js
var _553 = [[11648, 11743]];
var Ethiopic_Extended_default = _553;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic_Extended_A.js
var _554 = [[43776, 43823]];
var Ethiopic_Extended_A_default = _554;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic_Supplement.js
var _555 = [[4992, 5023]];
var Ethiopic_Supplement_default = _555;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/General_Punctuation.js
var _556 = [[8192, 8303]];
var General_Punctuation_default = _556;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Geometric_Shapes.js
var _557 = [[9632, 9727]];
var Geometric_Shapes_default = _557;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Geometric_Shapes_Extended.js
var _558 = [[128896, 129023]];
var Geometric_Shapes_Extended_default = _558;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Georgian.js
var _559 = [[4256, 4351]];
var Georgian_default3 = _559;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Georgian_Extended.js
var _560 = [[7312, 7359]];
var Georgian_Extended_default = _560;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Georgian_Supplement.js
var _561 = [[11520, 11567]];
var Georgian_Supplement_default = _561;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Glagolitic.js
var _562 = [[11264, 11359]];
var Glagolitic_default3 = _562;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Glagolitic_Supplement.js
var _563 = [[122880, 122927]];
var Glagolitic_Supplement_default = _563;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gothic.js
var _564 = [[66352, 66383]];
var Gothic_default3 = _564;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Grantha.js
var _565 = [[70400, 70527]];
var Grantha_default3 = _565;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Greek_And_Coptic.js
var _566 = [[880, 1023]];
var Greek_And_Coptic_default = _566;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Greek_Extended.js
var _567 = [[7936, 8191]];
var Greek_Extended_default = _567;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gujarati.js
var _568 = [[2688, 2815]];
var Gujarati_default3 = _568;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gunjala_Gondi.js
var _569 = [[73056, 73135]];
var Gunjala_Gondi_default3 = _569;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gurmukhi.js
var _570 = [[2560, 2687]];
var Gurmukhi_default3 = _570;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Halfwidth_And_Fullwidth_Forms.js
var _571 = [[65280, 65519]];
var Halfwidth_And_Fullwidth_Forms_default = _571;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Compatibility_Jamo.js
var _572 = [[12592, 12687]];
var Hangul_Compatibility_Jamo_default = _572;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Jamo.js
var _573 = [[4352, 4607]];
var Hangul_Jamo_default = _573;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Jamo_Extended_A.js
var _574 = [[43360, 43391]];
var Hangul_Jamo_Extended_A_default = _574;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Jamo_Extended_B.js
var _575 = [[55216, 55295]];
var Hangul_Jamo_Extended_B_default = _575;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Syllables.js
var _576 = [[44032, 55215]];
var Hangul_Syllables_default = _576;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hanifi_Rohingya.js
var _577 = [[68864, 68927]];
var Hanifi_Rohingya_default3 = _577;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hanunoo.js
var _578 = [[5920, 5951]];
var Hanunoo_default3 = _578;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hatran.js
var _579 = [[67808, 67839]];
var Hatran_default3 = _579;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hebrew.js
var _580 = [[1424, 1535]];
var Hebrew_default3 = _580;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/High_Private_Use_Surrogates.js
var _581 = [[56192, 56319]];
var High_Private_Use_Surrogates_default = _581;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/High_Surrogates.js
var _582 = [[55296, 56191]];
var High_Surrogates_default = _582;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hiragana.js
var _583 = [[12352, 12447]];
var Hiragana_default3 = _583;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/IPA_Extensions.js
var _584 = [[592, 687]];
var IPA_Extensions_default = _584;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ideographic_Description_Characters.js
var _585 = [[12272, 12287]];
var Ideographic_Description_Characters_default = _585;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ideographic_Symbols_And_Punctuation.js
var _586 = [[94176, 94207]];
var Ideographic_Symbols_And_Punctuation_default = _586;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Imperial_Aramaic.js
var _587 = [[67648, 67679]];
var Imperial_Aramaic_default3 = _587;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Indic_Siyaq_Numbers.js
var _588 = [[126064, 126143]];
var Indic_Siyaq_Numbers_default = _588;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Inscriptional_Pahlavi.js
var _589 = [[68448, 68479]];
var Inscriptional_Pahlavi_default3 = _589;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Inscriptional_Parthian.js
var _590 = [[68416, 68447]];
var Inscriptional_Parthian_default3 = _590;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Javanese.js
var _591 = [[43392, 43487]];
var Javanese_default3 = _591;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kaithi.js
var _592 = [[69760, 69839]];
var Kaithi_default3 = _592;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kana_Extended_A.js
var _593 = [[110848, 110895]];
var Kana_Extended_A_default = _593;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kana_Supplement.js
var _594 = [[110592, 110847]];
var Kana_Supplement_default = _594;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kanbun.js
var _595 = [[12688, 12703]];
var Kanbun_default = _595;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kangxi_Radicals.js
var _596 = [[12032, 12255]];
var Kangxi_Radicals_default = _596;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kannada.js
var _597 = [[3200, 3327]];
var Kannada_default3 = _597;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Katakana.js
var _598 = [[12448, 12543]];
var Katakana_default3 = _598;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Katakana_Phonetic_Extensions.js
var _599 = [[12784, 12799]];
var Katakana_Phonetic_Extensions_default = _599;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kayah_Li.js
var _600 = [[43264, 43311]];
var Kayah_Li_default3 = _600;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kharoshthi.js
var _601 = [[68096, 68191]];
var Kharoshthi_default3 = _601;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khmer.js
var _602 = [[6016, 6143]];
var Khmer_default3 = _602;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khmer_Symbols.js
var _603 = [[6624, 6655]];
var Khmer_Symbols_default = _603;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khojki.js
var _604 = [[70144, 70223]];
var Khojki_default3 = _604;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khudawadi.js
var _605 = [[70320, 70399]];
var Khudawadi_default3 = _605;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lao.js
var _606 = [[3712, 3839]];
var Lao_default3 = _606;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_1_Supplement.js
var _607 = [[128, 255]];
var Latin_1_Supplement_default = _607;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_A.js
var _608 = [[256, 383]];
var Latin_Extended_A_default = _608;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_Additional.js
var _609 = [[7680, 7935]];
var Latin_Extended_Additional_default = _609;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_B.js
var _610 = [[384, 591]];
var Latin_Extended_B_default = _610;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_C.js
var _611 = [[11360, 11391]];
var Latin_Extended_C_default = _611;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_D.js
var _612 = [[42784, 43007]];
var Latin_Extended_D_default = _612;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_E.js
var _613 = [[43824, 43887]];
var Latin_Extended_E_default = _613;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lepcha.js
var _614 = [[7168, 7247]];
var Lepcha_default3 = _614;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Letterlike_Symbols.js
var _615 = [[8448, 8527]];
var Letterlike_Symbols_default = _615;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Limbu.js
var _616 = [[6400, 6479]];
var Limbu_default3 = _616;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Linear_A.js
var _617 = [[67072, 67455]];
var Linear_A_default3 = _617;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Linear_B_Ideograms.js
var _618 = [[65664, 65791]];
var Linear_B_Ideograms_default = _618;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Linear_B_Syllabary.js
var _619 = [[65536, 65663]];
var Linear_B_Syllabary_default = _619;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lisu.js
var _620 = [[42192, 42239]];
var Lisu_default3 = _620;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Low_Surrogates.js
var _621 = [[56320, 57343]];
var Low_Surrogates_default = _621;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lycian.js
var _622 = [[66176, 66207]];
var Lycian_default3 = _622;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lydian.js
var _623 = [[67872, 67903]];
var Lydian_default3 = _623;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mahajani.js
var _624 = [[69968, 70015]];
var Mahajani_default3 = _624;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mahjong_Tiles.js
var _625 = [[126976, 127023]];
var Mahjong_Tiles_default = _625;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Makasar.js
var _626 = [[73440, 73471]];
var Makasar_default3 = _626;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Malayalam.js
var _627 = [[3328, 3455]];
var Malayalam_default3 = _627;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mandaic.js
var _628 = [[2112, 2143]];
var Mandaic_default3 = _628;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Manichaean.js
var _629 = [[68288, 68351]];
var Manichaean_default3 = _629;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Marchen.js
var _630 = [[72816, 72895]];
var Marchen_default3 = _630;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Masaram_Gondi.js
var _631 = [[72960, 73055]];
var Masaram_Gondi_default3 = _631;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mathematical_Alphanumeric_Symbols.js
var _632 = [[119808, 120831]];
var Mathematical_Alphanumeric_Symbols_default = _632;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mathematical_Operators.js
var _633 = [[8704, 8959]];
var Mathematical_Operators_default = _633;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mayan_Numerals.js
var _634 = [[119520, 119551]];
var Mayan_Numerals_default = _634;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Medefaidrin.js
var _635 = [[93760, 93855]];
var Medefaidrin_default3 = _635;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meetei_Mayek.js
var _636 = [[43968, 44031]];
var Meetei_Mayek_default3 = _636;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meetei_Mayek_Extensions.js
var _637 = [[43744, 43775]];
var Meetei_Mayek_Extensions_default = _637;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mende_Kikakui.js
var _638 = [[124928, 125151]];
var Mende_Kikakui_default3 = _638;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meroitic_Cursive.js
var _639 = [[68e3, 68095]];
var Meroitic_Cursive_default3 = _639;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meroitic_Hieroglyphs.js
var _640 = [[67968, 67999]];
var Meroitic_Hieroglyphs_default3 = _640;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miao.js
var _641 = [[93952, 94111]];
var Miao_default3 = _641;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Mathematical_Symbols_A.js
var _642 = [[10176, 10223]];
var Miscellaneous_Mathematical_Symbols_A_default = _642;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Mathematical_Symbols_B.js
var _643 = [[10624, 10751]];
var Miscellaneous_Mathematical_Symbols_B_default = _643;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Symbols.js
var _644 = [[9728, 9983]];
var Miscellaneous_Symbols_default = _644;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Symbols_And_Arrows.js
var _645 = [[11008, 11263]];
var Miscellaneous_Symbols_And_Arrows_default = _645;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Symbols_And_Pictographs.js
var _646 = [[127744, 128511]];
var Miscellaneous_Symbols_And_Pictographs_default = _646;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Technical.js
var _647 = [[8960, 9215]];
var Miscellaneous_Technical_default = _647;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Modi.js
var _648 = [[71168, 71263]];
var Modi_default3 = _648;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Modifier_Tone_Letters.js
var _649 = [[42752, 42783]];
var Modifier_Tone_Letters_default = _649;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mongolian.js
var _650 = [[6144, 6319]];
var Mongolian_default3 = _650;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mongolian_Supplement.js
var _651 = [[71264, 71295]];
var Mongolian_Supplement_default = _651;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mro.js
var _652 = [[92736, 92783]];
var Mro_default3 = _652;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Multani.js
var _653 = [[70272, 70319]];
var Multani_default3 = _653;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Musical_Symbols.js
var _654 = [[119040, 119295]];
var Musical_Symbols_default = _654;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Myanmar.js
var _655 = [[4096, 4255]];
var Myanmar_default3 = _655;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Myanmar_Extended_A.js
var _656 = [[43616, 43647]];
var Myanmar_Extended_A_default = _656;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Myanmar_Extended_B.js
var _657 = [[43488, 43519]];
var Myanmar_Extended_B_default = _657;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/NKo.js
var _658 = [[1984, 2047]];
var NKo_default = _658;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Nabataean.js
var _659 = [[67712, 67759]];
var Nabataean_default3 = _659;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/New_Tai_Lue.js
var _660 = [[6528, 6623]];
var New_Tai_Lue_default3 = _660;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Newa.js
var _661 = [[70656, 70783]];
var Newa_default3 = _661;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Number_Forms.js
var _662 = [[8528, 8591]];
var Number_Forms_default = _662;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Nushu.js
var _663 = [[110960, 111359]];
var Nushu_default3 = _663;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ogham.js
var _664 = [[5760, 5791]];
var Ogham_default3 = _664;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ol_Chiki.js
var _665 = [[7248, 7295]];
var Ol_Chiki_default3 = _665;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Hungarian.js
var _666 = [[68736, 68863]];
var Old_Hungarian_default3 = _666;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Italic.js
var _667 = [[66304, 66351]];
var Old_Italic_default3 = _667;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_North_Arabian.js
var _668 = [[68224, 68255]];
var Old_North_Arabian_default3 = _668;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Permic.js
var _669 = [[66384, 66431]];
var Old_Permic_default3 = _669;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Persian.js
var _670 = [[66464, 66527]];
var Old_Persian_default3 = _670;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Sogdian.js
var _671 = [[69376, 69423]];
var Old_Sogdian_default3 = _671;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_South_Arabian.js
var _672 = [[68192, 68223]];
var Old_South_Arabian_default3 = _672;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Turkic.js
var _673 = [[68608, 68687]];
var Old_Turkic_default3 = _673;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Optical_Character_Recognition.js
var _674 = [[9280, 9311]];
var Optical_Character_Recognition_default = _674;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Oriya.js
var _675 = [[2816, 2943]];
var Oriya_default3 = _675;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ornamental_Dingbats.js
var _676 = [[128592, 128639]];
var Ornamental_Dingbats_default = _676;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Osage.js
var _677 = [[66736, 66815]];
var Osage_default3 = _677;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Osmanya.js
var _678 = [[66688, 66735]];
var Osmanya_default3 = _678;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Pahawh_Hmong.js
var _679 = [[92928, 93071]];
var Pahawh_Hmong_default3 = _679;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Palmyrene.js
var _680 = [[67680, 67711]];
var Palmyrene_default3 = _680;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Pau_Cin_Hau.js
var _681 = [[72384, 72447]];
var Pau_Cin_Hau_default3 = _681;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phags_Pa.js
var _682 = [[43072, 43135]];
var Phags_Pa_default3 = _682;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phaistos_Disc.js
var _683 = [[66e3, 66047]];
var Phaistos_Disc_default = _683;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phoenician.js
var _684 = [[67840, 67871]];
var Phoenician_default3 = _684;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phonetic_Extensions.js
var _685 = [[7424, 7551]];
var Phonetic_Extensions_default = _685;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phonetic_Extensions_Supplement.js
var _686 = [[7552, 7615]];
var Phonetic_Extensions_Supplement_default = _686;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Playing_Cards.js
var _687 = [[127136, 127231]];
var Playing_Cards_default = _687;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Private_Use_Area.js
var _688 = [[57344, 63743]];
var Private_Use_Area_default = _688;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Psalter_Pahlavi.js
var _689 = [[68480, 68527]];
var Psalter_Pahlavi_default3 = _689;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Rejang.js
var _690 = [[43312, 43359]];
var Rejang_default3 = _690;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Rumi_Numeral_Symbols.js
var _691 = [[69216, 69247]];
var Rumi_Numeral_Symbols_default = _691;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Runic.js
var _692 = [[5792, 5887]];
var Runic_default3 = _692;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Samaritan.js
var _693 = [[2048, 2111]];
var Samaritan_default3 = _693;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Saurashtra.js
var _694 = [[43136, 43231]];
var Saurashtra_default3 = _694;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sharada.js
var _695 = [[70016, 70111]];
var Sharada_default3 = _695;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Shavian.js
var _696 = [[66640, 66687]];
var Shavian_default3 = _696;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Shorthand_Format_Controls.js
var _697 = [[113824, 113839]];
var Shorthand_Format_Controls_default = _697;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Siddham.js
var _698 = [[71040, 71167]];
var Siddham_default3 = _698;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sinhala.js
var _699 = [[3456, 3583]];
var Sinhala_default3 = _699;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sinhala_Archaic_Numbers.js
var _700 = [[70112, 70143]];
var Sinhala_Archaic_Numbers_default = _700;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Small_Form_Variants.js
var _701 = [[65104, 65135]];
var Small_Form_Variants_default = _701;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sogdian.js
var _702 = [[69424, 69487]];
var Sogdian_default3 = _702;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sora_Sompeng.js
var _703 = [[69840, 69887]];
var Sora_Sompeng_default3 = _703;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Soyombo.js
var _704 = [[72272, 72367]];
var Soyombo_default3 = _704;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Spacing_Modifier_Letters.js
var _705 = [[688, 767]];
var Spacing_Modifier_Letters_default = _705;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Specials.js
var _706 = [[65520, 65535]];
var Specials_default = _706;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sundanese.js
var _707 = [[7040, 7103]];
var Sundanese_default3 = _707;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sundanese_Supplement.js
var _708 = [[7360, 7375]];
var Sundanese_Supplement_default = _708;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Superscripts_And_Subscripts.js
var _709 = [[8304, 8351]];
var Superscripts_And_Subscripts_default = _709;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Arrows_A.js
var _710 = [[10224, 10239]];
var Supplemental_Arrows_A_default = _710;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Arrows_B.js
var _711 = [[10496, 10623]];
var Supplemental_Arrows_B_default = _711;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Arrows_C.js
var _712 = [[129024, 129279]];
var Supplemental_Arrows_C_default = _712;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Mathematical_Operators.js
var _713 = [[10752, 11007]];
var Supplemental_Mathematical_Operators_default = _713;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Punctuation.js
var _714 = [[11776, 11903]];
var Supplemental_Punctuation_default = _714;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Symbols_And_Pictographs.js
var _715 = [[129280, 129535]];
var Supplemental_Symbols_And_Pictographs_default = _715;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplementary_Private_Use_Area_A.js
var _716 = [[983040, 1048575]];
var Supplementary_Private_Use_Area_A_default = _716;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplementary_Private_Use_Area_B.js
var _717 = [[1048576, 1114111]];
var Supplementary_Private_Use_Area_B_default = _717;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sutton_SignWriting.js
var _718 = [[120832, 121519]];
var Sutton_SignWriting_default = _718;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Syloti_Nagri.js
var _719 = [[43008, 43055]];
var Syloti_Nagri_default3 = _719;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Syriac.js
var _720 = [[1792, 1871]];
var Syriac_default3 = _720;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Syriac_Supplement.js
var _721 = [[2144, 2159]];
var Syriac_Supplement_default = _721;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tagalog.js
var _722 = [[5888, 5919]];
var Tagalog_default3 = _722;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tagbanwa.js
var _723 = [[5984, 6015]];
var Tagbanwa_default3 = _723;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tags.js
var _724 = [[917504, 917631]];
var Tags_default = _724;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Le.js
var _725 = [[6480, 6527]];
var Tai_Le_default3 = _725;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Tham.js
var _726 = [[6688, 6831]];
var Tai_Tham_default3 = _726;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Viet.js
var _727 = [[43648, 43743]];
var Tai_Viet_default3 = _727;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Xuan_Jing_Symbols.js
var _728 = [[119552, 119647]];
var Tai_Xuan_Jing_Symbols_default = _728;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Takri.js
var _729 = [[71296, 71375]];
var Takri_default3 = _729;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tamil.js
var _730 = [[2944, 3071]];
var Tamil_default3 = _730;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tangut.js
var _731 = [[94208, 100351]];
var Tangut_default3 = _731;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tangut_Components.js
var _732 = [[100352, 101119]];
var Tangut_Components_default = _732;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Telugu.js
var _733 = [[3072, 3199]];
var Telugu_default3 = _733;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Thaana.js
var _734 = [[1920, 1983]];
var Thaana_default3 = _734;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Thai.js
var _735 = [[3584, 3711]];
var Thai_default3 = _735;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tibetan.js
var _736 = [[3840, 4095]];
var Tibetan_default3 = _736;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tifinagh.js
var _737 = [[11568, 11647]];
var Tifinagh_default3 = _737;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tirhuta.js
var _738 = [[70784, 70879]];
var Tirhuta_default3 = _738;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Transport_And_Map_Symbols.js
var _739 = [[128640, 128767]];
var Transport_And_Map_Symbols_default = _739;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ugaritic.js
var _740 = [[66432, 66463]];
var Ugaritic_default3 = _740;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Unified_Canadian_Aboriginal_Syllabics.js
var _741 = [[5120, 5759]];
var Unified_Canadian_Aboriginal_Syllabics_default = _741;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Unified_Canadian_Aboriginal_Syllabics_Extended.js
var _742 = [[6320, 6399]];
var Unified_Canadian_Aboriginal_Syllabics_Extended_default = _742;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Vai.js
var _743 = [[42240, 42559]];
var Vai_default3 = _743;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Variation_Selectors.js
var _744 = [[65024, 65039]];
var Variation_Selectors_default = _744;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Variation_Selectors_Supplement.js
var _745 = [[917760, 917999]];
var Variation_Selectors_Supplement_default = _745;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Vedic_Extensions.js
var _746 = [[7376, 7423]];
var Vedic_Extensions_default = _746;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Vertical_Forms.js
var _747 = [[65040, 65055]];
var Vertical_Forms_default = _747;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Warang_Citi.js
var _748 = [[71840, 71935]];
var Warang_Citi_default3 = _748;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Yi_Radicals.js
var _749 = [[42128, 42191]];
var Yi_Radicals_default = _749;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Yi_Syllables.js
var _750 = [[40960, 42127]];
var Yi_Syllables_default = _750;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Yijing_Hexagram_Symbols.js
var _751 = [[19904, 19967]];
var Yijing_Hexagram_Symbols_default = _751;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Zanabazar_Square.js
var _752 = [[72192, 72271]];
var Zanabazar_Square_default3 = _752;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/undefined.js
var _753 = [[2160, 2207], [66928, 67007], [67456, 67519], [69248, 69375], [69488, 69631], [71936, 72031], [72096, 72191], [72368, 72383], [72448, 72543], [73472, 73567], [73648, 73727], [77712, 77823], [78896, 78943], [92784, 92879], [101120, 101759], [110576, 110591], [110896, 110959], [118528, 118735], [119488, 119519], [122624, 122879], [122928, 123023], [123136, 123215], [123536, 123647], [124112, 124159], [124896, 124927], [126208, 126287], [129648, 130047], [196608, 205743]];
var undefined_default = _753;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Mirroring_Glyph/index.js
var Bidi_Mirroring_Glyph_exports = {};

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/index.js
var Bidi_Paired_Bracket_Type_exports = {};
__export(Bidi_Paired_Bracket_Type_exports, {
  Close: () => Close_default,
  None: () => None_default,
  Open: () => Open_default
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/Close.js
var _754 = [41, 93, 125, 3899, 3901, 5788, 8262, 8318, 8334, 8969, 8971, 9002, 10089, 10091, 10093, 10095, 10097, 10099, 10101, 10182, 10215, 10217, 10219, 10221, 10223, 10628, 10630, 10632, 10634, 10636, 10638, 10640, 10642, 10644, 10646, 10648, 10713, 10715, 10749, 11811, 11813, 11815, 11817, 11862, 11864, 11866, 11868, 12297, 12299, 12301, 12303, 12305, 12309, 12311, 12313, 12315, 65114, 65116, 65118, 65289, 65341, 65373, 65376, 65379];
var Close_default = _754;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/None.js
var _755 = [[0, 39], [42, 90], 92, [94, 122], 124, [126, 3897], [3902, 5786], [5789, 8260], [8263, 8316], [8319, 8332], [8335, 8967], [8972, 9e3], [9003, 10087], [10102, 10180], [10183, 10213], [10224, 10626], [10649, 10711], [10716, 10747], [10750, 11809], [11818, 11860], [11869, 12295], [12306, 12307], [12316, 65112], [65119, 65287], [65290, 65338], 65340, [65342, 65370], 65372, 65374, 65377, [65380, 1114111]];
var None_default = _755;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/Open.js
var _756 = [40, 91, 123, 3898, 3900, 5787, 8261, 8317, 8333, 8968, 8970, 9001, 10088, 10090, 10092, 10094, 10096, 10098, 10100, 10181, 10214, 10216, 10218, 10220, 10222, 10627, 10629, 10631, 10633, 10635, 10637, 10639, 10641, 10643, 10645, 10647, 10712, 10714, 10748, 11810, 11812, 11814, 11816, 11861, 11863, 11865, 11867, 12296, 12298, 12300, 12302, 12304, 12308, 12310, 12312, 12314, 65113, 65115, 65117, 65288, 65339, 65371, 65375, 65378];
var Open_default = _756;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/index.js
var Line_Break_exports = {};
__export(Line_Break_exports, {
  Alphabetic: () => Alphabetic_default2,
  Ambiguous: () => Ambiguous_default,
  Break_After: () => Break_After_default,
  Break_Before: () => Break_Before_default,
  Break_Both: () => Break_Both_default,
  Break_Symbols: () => Break_Symbols_default,
  Carriage_Return: () => Carriage_Return_default,
  Close_Parenthesis: () => Close_Parenthesis_default,
  Close_Punctuation: () => Close_Punctuation_default2,
  Combining_Mark: () => Combining_Mark_default,
  Complex_Context: () => Complex_Context_default,
  Conditional_Japanese_Starter: () => Conditional_Japanese_Starter_default,
  Contingent_Break: () => Contingent_Break_default,
  E_Base: () => E_Base_default,
  E_Modifier: () => E_Modifier_default,
  Exclamation: () => Exclamation_default,
  Glue: () => Glue_default,
  H2: () => H2_default,
  H3: () => H3_default,
  Hebrew_Letter: () => Hebrew_Letter_default,
  Hyphen: () => Hyphen_default2,
  Ideographic: () => Ideographic_default2,
  Infix_Numeric: () => Infix_Numeric_default,
  Inseparable: () => Inseparable_default,
  JL: () => JL_default,
  JT: () => JT_default,
  JV: () => JV_default,
  Line_Feed: () => Line_Feed_default,
  Mandatory_Break: () => Mandatory_Break_default,
  Next_Line: () => Next_Line_default,
  Nonstarter: () => Nonstarter_default,
  Numeric: () => Numeric_default,
  Open_Punctuation: () => Open_Punctuation_default2,
  Postfix_Numeric: () => Postfix_Numeric_default,
  Prefix_Numeric: () => Prefix_Numeric_default,
  Quotation: () => Quotation_default,
  Regional_Indicator: () => Regional_Indicator_default2,
  Space: () => Space_default,
  Surrogate: () => Surrogate_default2,
  Unknown: () => Unknown_default,
  Word_Joiner: () => Word_Joiner_default,
  ZWJ: () => ZWJ_default,
  ZWSpace: () => ZWSpace_default
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Alphabetic.js
var _757 = [35, 38, 42, [60, 62], [64, 90], [94, 122], 126, 166, 169, 172, [174, 175], 181, [192, 214], [216, 246], [248, 710], [718, 719], [721, 727], 732, 734, [736, 767], [880, 887], [890, 893], 895, [900, 906], 908, [910, 929], [931, 1154], [1162, 1327], [1329, 1366], [1369, 1416], [1421, 1422], 1472, 1475, [1523, 1524], [1536, 1544], [1550, 1551], [1568, 1610], [1645, 1647], [1649, 1747], 1749, [1757, 1758], [1765, 1766], 1769, [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2039], 2042, [2048, 2069], 2074, 2084, 2088, [2096, 2110], [2112, 2136], 2142, [2144, 2154], [2160, 2190], [2192, 2193], [2208, 2249], 2274, [2308, 2361], 2365, 2384, [2392, 2401], [2416, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], [2548, 2552], 2554, [2556, 2557], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], 2678, [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2800, 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], [2928, 2935], 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3056, 3064], 3066, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], [3192, 3200], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, [3406, 3407], [3412, 3414], [3416, 3425], [3440, 3448], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3572, 3663, 3840, 3845, 3859, [3861, 3863], [3866, 3871], [3882, 3891], 3894, 3896, [3904, 3911], [3913, 3948], [3976, 3980], [4032, 4037], [4039, 4044], [4046, 4047], [4052, 4056], [4172, 4175], [4256, 4293], 4295, 4301, [4304, 4351], [4608, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], 4960, [4962, 4988], [4992, 5017], [5024, 5109], [5112, 5117], [5121, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], 6105, [6128, 6137], [6144, 6145], 6151, 6154, [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], 6464, [6624, 6678], [6686, 6687], [6917, 6963], [6981, 6988], 7004, [7009, 7018], [7028, 7036], [7043, 7072], [7086, 7087], [7098, 7141], [7164, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7367], 7379, [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8188], 8190, 8215, [8226, 8227], 8248, [8254, 8259], [8266, 8277], 8284, [8289, 8292], [8304, 8305], [8309, 8316], 8320, [8325, 8332], [8336, 8348], [8448, 8450], 8452, [8454, 8456], [8458, 8466], [8468, 8469], [8471, 8480], [8483, 8490], [8492, 8531], [8534, 8538], [8540, 8541], 8543, [8556, 8559], [8570, 8584], [8586, 8587], [8602, 8657], 8659, [8661, 8703], 8705, [8708, 8710], [8713, 8714], [8716, 8718], 8720, 8724, [8726, 8729], [8731, 8732], [8737, 8738], 8740, 8742, 8749, [8751, 8755], [8760, 8763], [8766, 8775], [8777, 8779], [8781, 8785], [8787, 8799], [8802, 8803], [8808, 8809], [8812, 8813], [8816, 8833], [8836, 8837], [8840, 8852], [8854, 8856], [8858, 8868], [8870, 8894], [8896, 8942], [8944, 8967], [8972, 8977], [8979, 8985], [8988, 9e3], [9003, 9199], [9204, 9254], [9280, 9290], 9471, [9548, 9551], [9589, 9599], [9616, 9617], [9622, 9631], 9634, [9642, 9649], [9652, 9653], [9656, 9659], [9662, 9663], [9666, 9669], [9673, 9674], [9676, 9677], [9682, 9697], [9702, 9710], [9712, 9727], 9732, [9735, 9736], [9738, 9741], [9744, 9747], 9753, [9760, 9784], [9788, 9791], 9793, [9795, 9823], 9826, 9830, 9835, 9838, [9840, 9854], [9856, 9885], [9888, 9916], 9934, 9954, [9956, 9959], [9989, 9991], [9998, 10070], [10072, 10074], 10081, [10085, 10087], [10132, 10180], [10183, 10213], [10224, 10626], [10649, 10711], [10716, 10747], [10750, 11092], [11098, 11123], [11126, 11157], [11159, 11502], [11506, 11507], 11517, [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 11798, [11802, 11803], [11806, 11807], 11823, 11826, [11829, 11833], 11839, 11851, 11853, [11856, 11858], [19904, 19967], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], 42611, [42622, 42653], [42656, 42735], 42738, [42752, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43048, 43051], [43056, 43063], 43065, [43072, 43123], [43138, 43187], [43250, 43259], [43261, 43262], [43274, 43301], [43312, 43334], 43359, [43396, 43442], [43457, 43462], [43466, 43469], 43471, [43486, 43487], [43520, 43560], [43584, 43586], [43588, 43595], 43612, [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43883], [43888, 44002], [64256, 64262], [64275, 64279], 64297, [64336, 64450], [64467, 64829], [64832, 64911], [64914, 64967], 64975, [65008, 65019], [65021, 65023], [65136, 65140], [65142, 65276], [65512, 65518], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65799, 65843], [65847, 65934], [65936, 65948], 65952, [66e3, 66044], [66176, 66204], [66208, 66256], [66273, 66299], [66304, 66339], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67672, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67872, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68096], [68112, 68115], [68117, 68119], [68121, 68149], [68160, 68168], 68184, [68192, 68255], [68288, 68324], [68331, 68335], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68899], [69216, 69246], [69248, 69289], [69296, 69297], [69376, 69415], [69424, 69445], [69457, 69465], [69488, 69505], [69510, 69513], [69552, 69579], [69600, 69622], [69635, 69687], [69705, 69709], [69714, 69733], [69745, 69746], 69749, [69763, 69807], [69819, 69821], 69837, [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70004, 70006, [70019, 70066], [70081, 70084], 70087, 70093, 70106, 70108, [70113, 70132], [70144, 70161], [70163, 70187], 70202, 70205, [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], 70735, 70749, [70751, 70753], [70784, 70831], [70852, 70855], [71040, 71086], [71110, 71112], [71128, 71131], [71168, 71215], [71235, 71236], [71296, 71338], [71352, 71353], [71680, 71723], 71739, [71840, 71903], [71914, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72256, 72262, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72794, 72812], [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], [73463, 73464], 73474, [73476, 73488], [73490, 73523], 73648, [73664, 73692], [73697, 73713], [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77810], [77824, 78423], [78430, 78465], [78467, 78469], [78474, 78712], [78716, 78895], [78913, 78918], [82944, 83405], [83408, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92986, 92995], 92997, [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93846], [93849, 93850], [93952, 94026], 94032, [94099, 94111], [101120, 101589], [110576, 110579], [110581, 110587], [110589, 110590], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113820, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121478], 121483, [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], [123214, 123215], [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125127, 125135], [125184, 125251], 125259, [126065, 126123], [126125, 126127], [126129, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705], [127278, 127279], [127338, 127340], [127900, 127901], [127925, 127926], 127932, 128160, 128162, 128164, 128175, [128177, 128178], [128256, 128262], [128279, 128292], [128306, 128329], [128468, 128475], [128500, 128505], [128592, 128629], [128636, 128639], [128768, 128883], [128896, 128980], [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129280, 129291], [129536, 129619], [129792, 129938], [129940, 129994]];
var Alphabetic_default2 = _757;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Ambiguous.js
var _758 = [[167, 168], 170, [178, 179], [182, 186], [188, 190], 215, 247, 711, [713, 715], 717, 720, [728, 731], 733, [8213, 8214], [8224, 8225], 8251, 8308, 8319, [8321, 8324], 8453, 8467, [8481, 8482], 8491, [8532, 8533], 8539, 8542, [8544, 8555], [8560, 8569], 8585, [8592, 8601], 8658, 8660, 8704, [8706, 8707], [8711, 8712], 8715, 8719, 8721, 8725, 8730, [8733, 8736], 8739, 8741, [8743, 8748], 8750, [8756, 8759], [8764, 8765], 8776, 8780, 8786, [8800, 8801], [8804, 8807], [8810, 8811], [8814, 8815], [8834, 8835], [8838, 8839], 8853, 8857, 8869, 8895, 8978, [9312, 9470], [9472, 9547], [9552, 9588], [9600, 9615], [9618, 9621], [9632, 9633], [9635, 9641], [9650, 9651], [9654, 9655], [9660, 9661], [9664, 9665], [9670, 9672], 9675, [9678, 9681], [9698, 9701], 9711, [9733, 9734], 9737, [9742, 9743], [9750, 9751], 9792, 9794, [9824, 9825], [9827, 9829], 9831, [9833, 9834], [9836, 9837], 9839, [9886, 9887], [9929, 9932], 9938, [9941, 9943], [9946, 9947], [9949, 9950], 9955, [9960, 9961], [9963, 9968], 9974, [9979, 9980], 10071, [10102, 10131], [11093, 11097], [12872, 12879], 65533, [127232, 127244], [127248, 127277], [127280, 127337], [127344, 127404]];
var Ambiguous_default = _758;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_After.js
var _759 = [9, 124, 173, 1418, 1470, [2404, 2405], [3674, 3675], 3851, 3892, 3967, 3973, [4030, 4031], 4050, [4170, 4171], 4961, 5120, 5760, [5867, 5869], [5941, 5942], [6100, 6101], 6104, 6106, [6148, 6149], [7002, 7003], [7005, 7008], [7037, 7038], [7227, 7231], [7294, 7295], [8192, 8198], [8200, 8202], 8208, [8210, 8211], 8231, 8278, [8280, 8283], [8285, 8287], [11514, 11516], 11519, 11632, [11790, 11797], 11799, 11801, [11818, 11821], [11824, 11825], [11827, 11828], [11836, 11838], [11840, 11841], [11843, 11850], 11852, [11854, 11855], 11869, 12288, [42238, 42239], 42509, 42511, [42739, 42743], [43214, 43215], [43310, 43311], [43463, 43465], [43613, 43615], [43760, 43761], 44011, [65792, 65794], 66463, 66512, 67671, 67871, [68176, 68183], [68336, 68341], [68409, 68415], 69293, [69703, 69704], [69822, 69825], [69952, 69955], [70085, 70086], 70088, [70109, 70111], [70200, 70201], [70203, 70204], 70313, [70731, 70734], [70746, 70747], [71106, 71107], [71113, 71127], [71233, 71234], [71484, 71486], [72004, 72006], [72257, 72260], [72346, 72348], [72353, 72354], [72769, 72773], [73539, 73540], 73727, [74864, 74868], [92782, 92783], 92917, [92983, 92985], 92996, [93847, 93848], 113823, [121479, 121482]];
var Break_After_default = _759;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_Before.js
var _760 = [180, 712, 716, 735, 3191, 3204, [3841, 3844], [3846, 3847], [3849, 3850], [4048, 4049], 4051, 6150, 8189, [43124, 43125], 43260, 70005, 70107, 71105, [71264, 71276], 72162, 72255, 72261, [72350, 72352], [72448, 72457], 72816];
var Break_Before_default = _760;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_Both.js
var _761 = [8212, [11834, 11835]];
var Break_Both_default = _761;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_Symbols.js
var _762 = [47];
var Break_Symbols_default = _762;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Carriage_Return.js
var _763 = [13];
var Carriage_Return_default = _763;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Close_Parenthesis.js
var _764 = [41, 93];
var Close_Parenthesis_default = _764;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Close_Punctuation.js
var _765 = [125, 3899, 3901, 5788, 8262, 8318, 8334, 8969, 8971, 9002, 10089, 10091, 10093, 10095, 10097, 10099, 10101, 10182, 10215, 10217, 10219, 10221, 10223, 10628, 10630, 10632, 10634, 10636, 10638, 10640, 10642, 10644, 10646, 10648, 10713, 10715, 10749, 11811, 11813, 11815, 11817, 11862, 11864, 11866, 11868, [12289, 12290], 12297, 12299, 12301, 12303, 12305, 12309, 12311, 12313, 12315, [12318, 12319], 64830, [65041, 65042], 65048, 65078, 65080, 65082, 65084, 65086, 65088, 65090, 65092, 65096, 65104, 65106, 65114, 65116, 65118, 65289, 65292, 65294, 65341, 65373, [65376, 65377], [65379, 65380], [78427, 78429], 78466, 78471, 78473, [78714, 78715], 78904, 78909, 78911, 83407];
var Close_Punctuation_default2 = _765;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Combining_Mark.js
var _766 = [[0, 8], [14, 31], [127, 132], [134, 159], [768, 846], [848, 859], [867, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], 1564, [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2307], [2362, 2364], [2366, 2383], [2385, 2391], [2402, 2403], [2433, 2435], 2492, [2494, 2500], [2503, 2504], [2507, 2509], 2519, [2530, 2531], 2558, [2561, 2563], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2691], 2748, [2750, 2757], [2759, 2761], [2763, 2765], [2786, 2787], [2810, 2815], [2817, 2819], 2876, [2878, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3021], 3031, [3072, 3076], 3132, [3134, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3203], 3260, [3262, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3387, 3388], [3390, 3396], [3398, 3400], [3402, 3405], 3415, [3426, 3427], [3457, 3459], 3530, [3535, 3540], 3542, [3544, 3551], [3570, 3571], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4957, 4959], [5906, 5909], [5938, 5940], [5970, 5971], [6002, 6003], [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6443], [6448, 6459], [6679, 6683], 6783, [6832, 6862], [6912, 6916], [6964, 6980], [7019, 7027], [7040, 7042], [7073, 7085], [7142, 7155], [7204, 7223], [7376, 7378], [7380, 7400], 7405, 7412, [7415, 7417], [7616, 7628], [7630, 7675], [7677, 7679], 8204, [8206, 8207], [8234, 8238], [8294, 8303], [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], 12341, [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43043, 43047], 43052, [43136, 43137], [43188, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43347], [43392, 43395], [43443, 43456], [43561, 43574], 43587, [43596, 43597], [43755, 43759], [43765, 43766], [44003, 44010], [44012, 44013], 64286, [65024, 65039], [65056, 65071], [65529, 65531], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], [69632, 69634], [69688, 69702], 69744, [69747, 69748], [69759, 69762], [69808, 69818], 69826, [69888, 69890], [69927, 69940], [69957, 69958], 70003, [70016, 70018], [70067, 70080], [70089, 70092], [70094, 70095], [70188, 70199], 70206, 70209, [70367, 70378], [70400, 70403], [70459, 70460], [70462, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70502, 70508], [70512, 70516], [70709, 70726], 70750, [70832, 70851], [71087, 71093], [71096, 71104], [71132, 71133], [71216, 71232], [71339, 71351], [71724, 71738], [71984, 71989], [71991, 71992], [71995, 71998], 72e3, [72002, 72003], [72145, 72151], [72154, 72160], 72164, [72193, 72202], [72243, 72249], [72251, 72254], 72263, [72273, 72283], [72330, 72345], [72751, 72758], [72760, 72767], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73098, 73102], [73104, 73105], [73107, 73111], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73538], 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94033, 94087], [94095, 94098], [94192, 94193], [113821, 113822], [113824, 113827], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], 917505, [917536, 917631], [917760, 917999]];
var Combining_Mark_default = _766;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Complex_Context.js
var _767 = [[3585, 3642], [3648, 3662], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3804, 3807], [4096, 4159], [4176, 4239], [4250, 4255], [6016, 6099], 6103, [6108, 6109], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], 6618, [6622, 6623], [6688, 6750], [6752, 6780], [6816, 6829], [43488, 43503], [43514, 43518], [43616, 43714], [43739, 43743], [71424, 71450], [71453, 71467], [71482, 71483], [71487, 71494]];
var Complex_Context_default = _767;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Conditional_Japanese_Starter.js
var _768 = [12353, 12355, 12357, 12359, 12361, 12387, 12419, 12421, 12423, 12430, [12437, 12438], 12449, 12451, 12453, 12455, 12457, 12483, 12515, 12517, 12519, 12526, [12533, 12534], 12540, [12784, 12799], [65383, 65392], 110898, [110928, 110930], 110933, [110948, 110951]];
var Conditional_Japanese_Starter_default = _768;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Contingent_Break.js
var _769 = [65532];
var Contingent_Break_default = _769;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/E_Base.js
var _770 = [9757, 9977, [9994, 9997], 127877, [127938, 127940], 127943, [127946, 127948], [128066, 128067], [128070, 128080], [128102, 128120], 128124, [128129, 128131], [128133, 128135], 128143, 128145, 128170, [128372, 128373], 128378, 128400, [128405, 128406], [128581, 128583], [128587, 128591], 128675, [128692, 128694], 128704, 128716, 129292, 129295, [129304, 129311], 129318, [129328, 129337], [129340, 129342], 129399, [129461, 129462], [129464, 129465], 129467, [129485, 129487], [129489, 129501], [129731, 129733], [129776, 129784]];
var E_Base_default = _770;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/E_Modifier.js
var _771 = [[127995, 127999]];
var E_Modifier_default = _771;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Exclamation.js
var _772 = [33, 63, 1478, 1563, [1565, 1567], 1748, 2041, [3853, 3857], 3860, [6146, 6147], [6152, 6153], [6468, 6469], [10082, 10083], 11513, 11518, 11822, [11859, 11860], 42510, [43126, 43127], [65045, 65046], [65110, 65111], 65281, 65311, [71108, 71109], 72817];
var Exclamation_default = _772;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Glue.js
var _773 = [160, 847, [860, 866], 3848, 3852, 3858, [4057, 4058], 6158, 7629, 7676, 8199, 8209, 8239, [78896, 78902], [78905, 78907], 94180];
var Glue_default = _773;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/H2.js
var _774 = [44032, 44060, 44088, 44116, 44144, 44172, 44200, 44228, 44256, 44284, 44312, 44340, 44368, 44396, 44424, 44452, 44480, 44508, 44536, 44564, 44592, 44620, 44648, 44676, 44704, 44732, 44760, 44788, 44816, 44844, 44872, 44900, 44928, 44956, 44984, 45012, 45040, 45068, 45096, 45124, 45152, 45180, 45208, 45236, 45264, 45292, 45320, 45348, 45376, 45404, 45432, 45460, 45488, 45516, 45544, 45572, 45600, 45628, 45656, 45684, 45712, 45740, 45768, 45796, 45824, 45852, 45880, 45908, 45936, 45964, 45992, 46020, 46048, 46076, 46104, 46132, 46160, 46188, 46216, 46244, 46272, 46300, 46328, 46356, 46384, 46412, 46440, 46468, 46496, 46524, 46552, 46580, 46608, 46636, 46664, 46692, 46720, 46748, 46776, 46804, 46832, 46860, 46888, 46916, 46944, 46972, 47e3, 47028, 47056, 47084, 47112, 47140, 47168, 47196, 47224, 47252, 47280, 47308, 47336, 47364, 47392, 47420, 47448, 47476, 47504, 47532, 47560, 47588, 47616, 47644, 47672, 47700, 47728, 47756, 47784, 47812, 47840, 47868, 47896, 47924, 47952, 47980, 48008, 48036, 48064, 48092, 48120, 48148, 48176, 48204, 48232, 48260, 48288, 48316, 48344, 48372, 48400, 48428, 48456, 48484, 48512, 48540, 48568, 48596, 48624, 48652, 48680, 48708, 48736, 48764, 48792, 48820, 48848, 48876, 48904, 48932, 48960, 48988, 49016, 49044, 49072, 49100, 49128, 49156, 49184, 49212, 49240, 49268, 49296, 49324, 49352, 49380, 49408, 49436, 49464, 49492, 49520, 49548, 49576, 49604, 49632, 49660, 49688, 49716, 49744, 49772, 49800, 49828, 49856, 49884, 49912, 49940, 49968, 49996, 50024, 50052, 50080, 50108, 50136, 50164, 50192, 50220, 50248, 50276, 50304, 50332, 50360, 50388, 50416, 50444, 50472, 50500, 50528, 50556, 50584, 50612, 50640, 50668, 50696, 50724, 50752, 50780, 50808, 50836, 50864, 50892, 50920, 50948, 50976, 51004, 51032, 51060, 51088, 51116, 51144, 51172, 51200, 51228, 51256, 51284, 51312, 51340, 51368, 51396, 51424, 51452, 51480, 51508, 51536, 51564, 51592, 51620, 51648, 51676, 51704, 51732, 51760, 51788, 51816, 51844, 51872, 51900, 51928, 51956, 51984, 52012, 52040, 52068, 52096, 52124, 52152, 52180, 52208, 52236, 52264, 52292, 52320, 52348, 52376, 52404, 52432, 52460, 52488, 52516, 52544, 52572, 52600, 52628, 52656, 52684, 52712, 52740, 52768, 52796, 52824, 52852, 52880, 52908, 52936, 52964, 52992, 53020, 53048, 53076, 53104, 53132, 53160, 53188, 53216, 53244, 53272, 53300, 53328, 53356, 53384, 53412, 53440, 53468, 53496, 53524, 53552, 53580, 53608, 53636, 53664, 53692, 53720, 53748, 53776, 53804, 53832, 53860, 53888, 53916, 53944, 53972, 54e3, 54028, 54056, 54084, 54112, 54140, 54168, 54196, 54224, 54252, 54280, 54308, 54336, 54364, 54392, 54420, 54448, 54476, 54504, 54532, 54560, 54588, 54616, 54644, 54672, 54700, 54728, 54756, 54784, 54812, 54840, 54868, 54896, 54924, 54952, 54980, 55008, 55036, 55064, 55092, 55120, 55148, 55176];
var H2_default = _774;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/H3.js
var _775 = [[44033, 44059], [44061, 44087], [44089, 44115], [44117, 44143], [44145, 44171], [44173, 44199], [44201, 44227], [44229, 44255], [44257, 44283], [44285, 44311], [44313, 44339], [44341, 44367], [44369, 44395], [44397, 44423], [44425, 44451], [44453, 44479], [44481, 44507], [44509, 44535], [44537, 44563], [44565, 44591], [44593, 44619], [44621, 44647], [44649, 44675], [44677, 44703], [44705, 44731], [44733, 44759], [44761, 44787], [44789, 44815], [44817, 44843], [44845, 44871], [44873, 44899], [44901, 44927], [44929, 44955], [44957, 44983], [44985, 45011], [45013, 45039], [45041, 45067], [45069, 45095], [45097, 45123], [45125, 45151], [45153, 45179], [45181, 45207], [45209, 45235], [45237, 45263], [45265, 45291], [45293, 45319], [45321, 45347], [45349, 45375], [45377, 45403], [45405, 45431], [45433, 45459], [45461, 45487], [45489, 45515], [45517, 45543], [45545, 45571], [45573, 45599], [45601, 45627], [45629, 45655], [45657, 45683], [45685, 45711], [45713, 45739], [45741, 45767], [45769, 45795], [45797, 45823], [45825, 45851], [45853, 45879], [45881, 45907], [45909, 45935], [45937, 45963], [45965, 45991], [45993, 46019], [46021, 46047], [46049, 46075], [46077, 46103], [46105, 46131], [46133, 46159], [46161, 46187], [46189, 46215], [46217, 46243], [46245, 46271], [46273, 46299], [46301, 46327], [46329, 46355], [46357, 46383], [46385, 46411], [46413, 46439], [46441, 46467], [46469, 46495], [46497, 46523], [46525, 46551], [46553, 46579], [46581, 46607], [46609, 46635], [46637, 46663], [46665, 46691], [46693, 46719], [46721, 46747], [46749, 46775], [46777, 46803], [46805, 46831], [46833, 46859], [46861, 46887], [46889, 46915], [46917, 46943], [46945, 46971], [46973, 46999], [47001, 47027], [47029, 47055], [47057, 47083], [47085, 47111], [47113, 47139], [47141, 47167], [47169, 47195], [47197, 47223], [47225, 47251], [47253, 47279], [47281, 47307], [47309, 47335], [47337, 47363], [47365, 47391], [47393, 47419], [47421, 47447], [47449, 47475], [47477, 47503], [47505, 47531], [47533, 47559], [47561, 47587], [47589, 47615], [47617, 47643], [47645, 47671], [47673, 47699], [47701, 47727], [47729, 47755], [47757, 47783], [47785, 47811], [47813, 47839], [47841, 47867], [47869, 47895], [47897, 47923], [47925, 47951], [47953, 47979], [47981, 48007], [48009, 48035], [48037, 48063], [48065, 48091], [48093, 48119], [48121, 48147], [48149, 48175], [48177, 48203], [48205, 48231], [48233, 48259], [48261, 48287], [48289, 48315], [48317, 48343], [48345, 48371], [48373, 48399], [48401, 48427], [48429, 48455], [48457, 48483], [48485, 48511], [48513, 48539], [48541, 48567], [48569, 48595], [48597, 48623], [48625, 48651], [48653, 48679], [48681, 48707], [48709, 48735], [48737, 48763], [48765, 48791], [48793, 48819], [48821, 48847], [48849, 48875], [48877, 48903], [48905, 48931], [48933, 48959], [48961, 48987], [48989, 49015], [49017, 49043], [49045, 49071], [49073, 49099], [49101, 49127], [49129, 49155], [49157, 49183], [49185, 49211], [49213, 49239], [49241, 49267], [49269, 49295], [49297, 49323], [49325, 49351], [49353, 49379], [49381, 49407], [49409, 49435], [49437, 49463], [49465, 49491], [49493, 49519], [49521, 49547], [49549, 49575], [49577, 49603], [49605, 49631], [49633, 49659], [49661, 49687], [49689, 49715], [49717, 49743], [49745, 49771], [49773, 49799], [49801, 49827], [49829, 49855], [49857, 49883], [49885, 49911], [49913, 49939], [49941, 49967], [49969, 49995], [49997, 50023], [50025, 50051], [50053, 50079], [50081, 50107], [50109, 50135], [50137, 50163], [50165, 50191], [50193, 50219], [50221, 50247], [50249, 50275], [50277, 50303], [50305, 50331], [50333, 50359], [50361, 50387], [50389, 50415], [50417, 50443], [50445, 50471], [50473, 50499], [50501, 50527], [50529, 50555], [50557, 50583], [50585, 50611], [50613, 50639], [50641, 50667], [50669, 50695], [50697, 50723], [50725, 50751], [50753, 50779], [50781, 50807], [50809, 50835], [50837, 50863], [50865, 50891], [50893, 50919], [50921, 50947], [50949, 50975], [50977, 51003], [51005, 51031], [51033, 51059], [51061, 51087], [51089, 51115], [51117, 51143], [51145, 51171], [51173, 51199], [51201, 51227], [51229, 51255], [51257, 51283], [51285, 51311], [51313, 51339], [51341, 51367], [51369, 51395], [51397, 51423], [51425, 51451], [51453, 51479], [51481, 51507], [51509, 51535], [51537, 51563], [51565, 51591], [51593, 51619], [51621, 51647], [51649, 51675], [51677, 51703], [51705, 51731], [51733, 51759], [51761, 51787], [51789, 51815], [51817, 51843], [51845, 51871], [51873, 51899], [51901, 51927], [51929, 51955], [51957, 51983], [51985, 52011], [52013, 52039], [52041, 52067], [52069, 52095], [52097, 52123], [52125, 52151], [52153, 52179], [52181, 52207], [52209, 52235], [52237, 52263], [52265, 52291], [52293, 52319], [52321, 52347], [52349, 52375], [52377, 52403], [52405, 52431], [52433, 52459], [52461, 52487], [52489, 52515], [52517, 52543], [52545, 52571], [52573, 52599], [52601, 52627], [52629, 52655], [52657, 52683], [52685, 52711], [52713, 52739], [52741, 52767], [52769, 52795], [52797, 52823], [52825, 52851], [52853, 52879], [52881, 52907], [52909, 52935], [52937, 52963], [52965, 52991], [52993, 53019], [53021, 53047], [53049, 53075], [53077, 53103], [53105, 53131], [53133, 53159], [53161, 53187], [53189, 53215], [53217, 53243], [53245, 53271], [53273, 53299], [53301, 53327], [53329, 53355], [53357, 53383], [53385, 53411], [53413, 53439], [53441, 53467], [53469, 53495], [53497, 53523], [53525, 53551], [53553, 53579], [53581, 53607], [53609, 53635], [53637, 53663], [53665, 53691], [53693, 53719], [53721, 53747], [53749, 53775], [53777, 53803], [53805, 53831], [53833, 53859], [53861, 53887], [53889, 53915], [53917, 53943], [53945, 53971], [53973, 53999], [54001, 54027], [54029, 54055], [54057, 54083], [54085, 54111], [54113, 54139], [54141, 54167], [54169, 54195], [54197, 54223], [54225, 54251], [54253, 54279], [54281, 54307], [54309, 54335], [54337, 54363], [54365, 54391], [54393, 54419], [54421, 54447], [54449, 54475], [54477, 54503], [54505, 54531], [54533, 54559], [54561, 54587], [54589, 54615], [54617, 54643], [54645, 54671], [54673, 54699], [54701, 54727], [54729, 54755], [54757, 54783], [54785, 54811], [54813, 54839], [54841, 54867], [54869, 54895], [54897, 54923], [54925, 54951], [54953, 54979], [54981, 55007], [55009, 55035], [55037, 55063], [55065, 55091], [55093, 55119], [55121, 55147], [55149, 55175], [55177, 55203]];
var H3_default = _775;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Hebrew_Letter.js
var _776 = [[1488, 1514], [1519, 1522], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
var Hebrew_Letter_default = _776;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Hyphen.js
var _777 = [45];
var Hyphen_default2 = _777;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Ideographic.js
var _778 = [[8986, 8987], [9200, 9203], [9728, 9731], [9748, 9749], 9752, [9754, 9756], [9758, 9759], [9785, 9787], 9832, 9855, [9917, 9928], 9933, [9935, 9937], [9939, 9940], [9944, 9945], 9948, [9951, 9953], 9962, [9969, 9973], [9975, 9976], 9978, [9981, 9988], [9992, 9993], 10084, [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12291, 12292], [12294, 12295], [12306, 12307], [12320, 12329], [12336, 12340], [12342, 12346], [12349, 12351], 12354, 12356, 12358, 12360, [12362, 12386], [12388, 12418], 12420, 12422, [12424, 12429], [12431, 12436], 12447, 12450, 12452, 12454, 12456, [12458, 12482], [12484, 12514], 12516, 12518, [12520, 12525], [12527, 12532], [12535, 12538], 12543, [12549, 12591], [12593, 12686], [12688, 12771], [12800, 12830], [12832, 12871], [12880, 19903], [19968, 40980], [40982, 42124], [42128, 42182], [63744, 64255], [65072, 65076], [65093, 65094], [65097, 65103], 65105, 65112, [65119, 65126], 65128, 65131, [65282, 65283], [65286, 65287], [65290, 65291], 65293, [65295, 65305], [65308, 65310], [65312, 65338], 65340, [65342, 65370], 65372, 65374, 65382, [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65506, 65508], [73541, 73551], [94208, 100343], [100352, 101119], [101632, 101640], [110592, 110882], [110960, 111355], [126976, 127231], [127245, 127247], [127341, 127343], [127405, 127461], [127488, 127876], [127878, 127899], [127902, 127924], [127927, 127931], [127933, 127937], [127941, 127942], [127944, 127945], [127949, 127994], [128e3, 128065], [128068, 128069], [128081, 128101], [128121, 128123], [128125, 128128], 128132, [128136, 128142], 128144, [128146, 128159], 128161, 128163, [128165, 128169], [128171, 128174], 128176, [128179, 128255], [128263, 128278], [128293, 128305], [128330, 128371], [128374, 128377], [128379, 128399], [128401, 128404], [128407, 128467], [128476, 128499], [128506, 128580], [128584, 128586], [128640, 128674], [128676, 128691], [128695, 128703], [128705, 128715], [128717, 128767], [128884, 128895], [128981, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129279], [129293, 129294], [129296, 129303], [129312, 129317], [129319, 129327], [129338, 129339], [129343, 129398], [129400, 129460], 129463, 129466, [129468, 129484], 129488, [129502, 129535], [129620, 129730], [129734, 129775], [129785, 129791], [130048, 131069], [131072, 196605], [196608, 262141]];
var Ideographic_default2 = _778;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Infix_Numeric.js
var _779 = [44, 46, [58, 59], 894, 1417, [1548, 1549], 2040, 8260, 65040, [65043, 65044]];
var Infix_Numeric_default = _779;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Inseparable.js
var _780 = [[8228, 8230], 8943, 65049, 68342];
var Inseparable_default = _780;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/JL.js
var _781 = [[4352, 4447], [43360, 43388]];
var JL_default = _781;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/JT.js
var _782 = [[4520, 4607], [55243, 55291]];
var JT_default = _782;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/JV.js
var _783 = [[4448, 4519], [55216, 55238]];
var JV_default = _783;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Line_Feed.js
var _784 = [10];
var Line_Feed_default = _784;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Mandatory_Break.js
var _785 = [[11, 12], [8232, 8233]];
var Mandatory_Break_default = _785;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Next_Line.js
var _786 = [133];
var Next_Line_default = _786;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Nonstarter.js
var _787 = [6102, [8252, 8253], [8263, 8265], 12293, 12316, [12347, 12348], [12443, 12446], 12448, 12539, [12541, 12542], 40981, [65108, 65109], [65306, 65307], 65381, [65438, 65439], [94176, 94179], [128633, 128635]];
var Nonstarter_default = _787;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Numeric.js
var _788 = [[48, 57], [1632, 1641], [1643, 1644], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [66720, 66729], [68912, 68921], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71481], [71904, 71913], [72016, 72025], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [92768, 92777], [92864, 92873], [93008, 93017], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125264, 125273], [130032, 130041]];
var Numeric_default = _788;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Open_Punctuation.js
var _789 = [40, 91, 123, 161, 191, 3898, 3900, 5787, 8218, 8222, 8261, 8317, 8333, 8968, 8970, 9001, 10088, 10090, 10092, 10094, 10096, 10098, 10100, 10181, 10214, 10216, 10218, 10220, 10222, 10627, 10629, 10631, 10633, 10635, 10637, 10639, 10641, 10643, 10645, 10647, 10712, 10714, 10748, 11800, 11810, 11812, 11814, 11816, 11842, 11861, 11863, 11865, 11867, 12296, 12298, 12300, 12302, 12304, 12308, 12310, 12312, 12314, 12317, 64831, 65047, 65077, 65079, 65081, 65083, 65085, 65087, 65089, 65091, 65095, 65113, 65115, 65117, 65288, 65339, 65371, 65375, 65378, [78424, 78426], 78470, 78472, 78713, 78903, 78908, 78910, 83406, [125278, 125279]];
var Open_Punctuation_default2 = _789;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Postfix_Numeric.js
var _790 = [37, 162, 176, [1545, 1547], 1642, [2546, 2547], 2553, 3449, [8240, 8247], 8279, 8359, 8374, 8379, 8382, 8384, 8451, 8457, 43064, 65020, 65130, 65285, 65504, [73693, 73696], 126124, 126128];
var Postfix_Numeric_default = _790;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Prefix_Numeric.js
var _791 = [36, 43, 92, [163, 165], 177, 1423, [2046, 2047], 2555, 2801, 3065, 3647, 6107, [8352, 8358], [8360, 8373], [8375, 8378], [8380, 8381], 8383, [8385, 8399], 8470, [8722, 8723], 65129, 65284, 65505, [65509, 65510], 123647];
var Prefix_Numeric_default = _791;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Quotation.js
var _792 = [34, 39, 171, 187, [8216, 8217], [8219, 8221], 8223, [8249, 8250], [10075, 10080], [11776, 11789], [11804, 11805], [11808, 11809], [128630, 128632]];
var Quotation_default = _792;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Regional_Indicator.js
var _793 = [[127462, 127487]];
var Regional_Indicator_default2 = _793;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Space.js
var _794 = [32];
var Space_default = _794;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Surrogate.js
var _795 = [[55296, 57343]];
var Surrogate_default2 = _795;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Unknown.js
var _796 = [[888, 889], [896, 899], 907, 909, 930, 1328, [1367, 1368], [1419, 1420], 1424, [1480, 1487], [1515, 1518], [1525, 1535], 1806, [1867, 1868], [1970, 1983], [2043, 2044], [2094, 2095], 2111, [2140, 2141], 2143, [2155, 2159], 2191, [2194, 2199], 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2679, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2802, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], [2936, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3067, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3190], 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3408, 3411], [3428, 3429], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3573, 3584], [3643, 3646], [3676, 3712], 3715, 3717, 3723, 3748, 3750, [3774, 3775], 3781, 3783, 3791, [3802, 3803], [3808, 3839], 3912, [3949, 3952], 3992, 4029, 4045, [4059, 4095], 4294, [4296, 4300], [4302, 4303], 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4989, 4991], [5018, 5023], [5110, 5111], [5118, 5119], [5789, 5791], [5881, 5887], [5910, 5918], [5943, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6110, 6111], [6122, 6127], [6138, 6143], [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6463], [6465, 6467], [6510, 6511], [6517, 6527], [6572, 6575], [6602, 6607], [6619, 6621], [6684, 6685], 6751, [6781, 6782], [6794, 6799], [6810, 6815], [6830, 6831], [6863, 6911], [6989, 6991], 7039, [7156, 7163], [7224, 7226], [7242, 7244], [7305, 7311], [7355, 7356], [7368, 7375], [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8133, [8148, 8149], 8156, [8176, 8177], 8181, 8191, 8293, [8306, 8307], 8335, [8349, 8351], [8433, 8447], [8588, 8591], [9255, 9279], [9291, 9311], [11124, 11125], 11158, [11508, 11512], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11633, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11870, 11903], 11930, [12020, 12031], [12246, 12271], [12284, 12287], 12352, [12439, 12440], [12544, 12548], 12592, 12687, [12772, 12783], 12831, [42125, 42127], [42183, 42191], [42540, 42559], [42744, 42751], [42955, 42959], 42962, 42964, [42970, 42993], [43053, 43055], [43066, 43071], [43128, 43135], [43206, 43213], [43226, 43231], [43348, 43358], [43389, 43391], 43470, [43482, 43485], 43519, [43575, 43583], [43598, 43599], [43610, 43611], [43715, 43738], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43884, 43887], [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 55295], [57344, 63743], [64263, 64274], [64280, 64284], 64311, 64317, 64319, 64322, 64325, [64451, 64466], [64912, 64913], [64968, 64974], [64976, 65007], [65050, 65055], 65107, 65127, [65132, 65135], 65141, [65277, 65278], 65280, [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65503], 65511, [65519, 65528], [65534, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65791], [65795, 65798], [65844, 65846], 65935, [65949, 65951], [65953, 65999], [66046, 66175], [66205, 66207], [66257, 66271], [66300, 66303], [66340, 66348], [66379, 66383], [66427, 66431], 66462, [66500, 66503], [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66926], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], 67670, [67743, 67750], [67760, 67807], 67827, [67830, 67834], [67868, 67870], [67898, 67902], [67904, 67967], [68024, 68027], [68048, 68049], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68169, 68175], [68185, 68191], [68256, 68287], [68327, 68330], [68343, 68351], [68406, 68408], [68438, 68439], [68467, 68471], [68498, 68504], [68509, 68520], [68528, 68607], [68681, 68735], [68787, 68799], [68851, 68857], [68904, 68911], [68922, 69215], 69247, 69290, [69294, 69295], [69298, 69372], [69416, 69423], [69466, 69487], [69514, 69551], [69580, 69599], [69623, 69631], [69710, 69713], [69750, 69758], [69827, 69836], [69838, 69839], [69865, 69871], [69882, 69887], 69941, [69960, 69967], [70007, 70015], 70112, [70133, 70143], 70162, [70210, 70271], 70279, 70281, 70286, 70302, [70314, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], 70748, [70754, 70783], [70856, 70863], [70874, 71039], [71094, 71095], [71134, 71167], [71237, 71247], [71258, 71263], [71277, 71295], [71354, 71359], [71370, 71423], [71451, 71452], [71468, 71471], [71495, 71679], [71740, 71839], [71923, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72007, 72015], [72026, 72095], [72104, 72105], [72152, 72153], [72165, 72191], [72264, 72271], [72355, 72367], [72441, 72447], [72458, 72703], 72713, 72759, [72774, 72783], [72813, 72815], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73465, 73471], 73489, [73531, 73533], [73562, 73647], [73649, 73663], [73714, 73726], [74650, 74751], 74863, [74869, 74879], [75076, 77711], [77811, 77823], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92781], 92863, [92874, 92879], [92910, 92911], [92918, 92927], [92998, 93007], 93018, 93026, [93048, 93052], [93072, 93759], [93851, 93951], [94027, 94030], [94088, 94094], [94112, 94175], [94181, 94191], [94194, 94207], [100344, 100351], [101590, 101631], [101641, 110575], 110580, 110588, 110591, [110883, 110897], [110899, 110927], [110931, 110932], [110934, 110947], [110952, 110959], [111356, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113819], [113828, 118527], [118574, 118575], [118599, 118607], [118724, 118783], [119030, 119039], [119079, 119080], [119275, 119295], [119366, 119487], [119508, 119519], [119540, 119551], [119639, 119647], [119673, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], [120780, 120781], [121484, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123216, 123535], [123567, 123583], [123642, 123646], [123648, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125126], [125143, 125183], [125260, 125263], [125274, 125277], [125280, 126064], [126133, 126208], [126270, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 126703], [126706, 126975], [131070, 131071], [196606, 196607], [262142, 917504], [917506, 917535], [917632, 917759], [918e3, 1114111]];
var Unknown_default = _796;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Word_Joiner.js
var _797 = [8288, 65279];
var Word_Joiner_default = _797;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/ZWJ.js
var _798 = [8205];
var ZWJ_default = _798;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/ZWSpace.js
var _799 = [8203];
var ZWSpace_default = _799;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/index.js
var Word_Break_exports = {};
__export(Word_Break_exports, {
  ALetter: () => ALetter_default,
  CR: () => CR_default,
  Double_Quote: () => Double_Quote_default,
  Extend: () => Extend_default,
  ExtendNumLet: () => ExtendNumLet_default,
  Format: () => Format_default2,
  Hebrew_Letter: () => Hebrew_Letter_default2,
  Katakana: () => Katakana_default4,
  LF: () => LF_default,
  MidLetter: () => MidLetter_default,
  MidNum: () => MidNum_default,
  MidNumLet: () => MidNumLet_default,
  Newline: () => Newline_default,
  Numeric: () => Numeric_default2,
  Other: () => Other_default2,
  Regional_Indicator: () => Regional_Indicator_default3,
  Single_Quote: () => Single_Quote_default,
  WSegSpace: () => WSegSpace_default,
  ZWJ: () => ZWJ_default2
});

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/ALetter.js
var _800 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 727], [734, 767], [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], [1369, 1372], 1374, [1376, 1416], 1418, 1523, [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6656, 6678], [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [9398, 9449], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 11823, 12293, [12347, 12348], [12549, 12591], [12593, 12686], [12704, 12735], [40960, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42735], [42760, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43520, 43560], [43584, 43586], [43588, 43595], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [64256, 64262], [64275, 64279], [64336, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [127280, 127305], [127312, 127337], [127344, 127369]];
var ALetter_default = _800;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/CR.js
var _801 = [13];
var CR_default = _801;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Double_Quote.js
var _802 = [34];
var Double_Quote_default = _802;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Extend.js
var _803 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2307], [2362, 2364], [2366, 2383], [2385, 2391], [2402, 2403], [2433, 2435], 2492, [2494, 2500], [2503, 2504], [2507, 2509], 2519, [2530, 2531], 2558, [2561, 2563], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2691], 2748, [2750, 2757], [2759, 2761], [2763, 2765], [2786, 2787], [2810, 2815], [2817, 2819], 2876, [2878, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3021], 3031, [3072, 3076], 3132, [3134, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3203], 3260, [3262, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3387, 3388], [3390, 3396], [3398, 3400], [3402, 3405], 3415, [3426, 3427], [3457, 3459], 3530, [3535, 3540], 3542, [3544, 3551], [3570, 3571], 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3953, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4139, 4158], [4182, 4185], [4190, 4192], [4194, 4196], [4199, 4205], [4209, 4212], [4226, 4237], 4239, [4250, 4253], [4957, 4959], [5906, 5909], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6443], [6448, 6459], [6679, 6683], [6741, 6750], [6752, 6780], 6783, [6832, 6862], [6912, 6916], [6964, 6980], [7019, 7027], [7040, 7042], [7073, 7085], [7142, 7155], [7204, 7223], [7376, 7378], [7380, 7400], 7405, 7412, [7415, 7417], [7616, 7679], 8204, [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43043, 43047], 43052, [43136, 43137], [43188, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43347], [43392, 43395], [43443, 43456], 43493, [43561, 43574], 43587, [43596, 43597], [43643, 43645], 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43755, 43759], [43765, 43766], [44003, 44010], [44012, 44013], 64286, [65024, 65039], [65056, 65071], [65438, 65439], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], [69632, 69634], [69688, 69702], 69744, [69747, 69748], [69759, 69762], [69808, 69818], 69826, [69888, 69890], [69927, 69940], [69957, 69958], 70003, [70016, 70018], [70067, 70080], [70089, 70092], [70094, 70095], [70188, 70199], 70206, 70209, [70367, 70378], [70400, 70403], [70459, 70460], [70462, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70502, 70508], [70512, 70516], [70709, 70726], 70750, [70832, 70851], [71087, 71093], [71096, 71104], [71132, 71133], [71216, 71232], [71339, 71351], [71453, 71467], [71724, 71738], [71984, 71989], [71991, 71992], [71995, 71998], 72e3, [72002, 72003], [72145, 72151], [72154, 72160], 72164, [72193, 72202], [72243, 72249], [72251, 72254], 72263, [72273, 72283], [72330, 72345], [72751, 72758], [72760, 72767], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73098, 73102], [73104, 73105], [73107, 73111], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73538], 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94033, 94087], [94095, 94098], 94180, [94192, 94193], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [127995, 127999], [917536, 917631], [917760, 917999]];
var Extend_default = _803;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/ExtendNumLet.js
var _804 = [95, 8239, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];
var ExtendNumLet_default = _804;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Format.js
var _805 = [173, [1536, 1541], 1564, 1757, 1807, [2192, 2193], 2274, 6158, [8206, 8207], [8234, 8238], [8288, 8292], [8294, 8303], 65279, [65529, 65531], 69821, 69837, [78896, 78911], [113824, 113827], [119155, 119162], 917505];
var Format_default2 = _805;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Hebrew_Letter.js
var _806 = [[1488, 1514], [1519, 1522], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
var Hebrew_Letter_default2 = _806;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Katakana.js
var _807 = [[12337, 12341], [12443, 12444], [12448, 12538], [12540, 12543], [12784, 12799], [13008, 13054], [13056, 13143], [65382, 65437], [110576, 110579], [110581, 110587], [110589, 110590], 110592, [110880, 110882], 110933, [110948, 110951]];
var Katakana_default4 = _807;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/LF.js
var _808 = [10];
var LF_default = _808;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/MidLetter.js
var _809 = [58, 183, 903, 1375, 1524, 8231, 65043, 65109, 65306];
var MidLetter_default = _809;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/MidNum.js
var _810 = [44, 59, 894, 1417, [1548, 1549], 1644, 2040, 8260, 65040, 65044, 65104, 65108, 65292, 65307];
var MidNum_default = _810;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/MidNumLet.js
var _811 = [46, [8216, 8217], 8228, 65106, 65287, 65294];
var MidNumLet_default = _811;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Newline.js
var _812 = [[11, 12], 133, [8232, 8233]];
var Newline_default = _812;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Numeric.js
var _813 = [[48, 57], [1632, 1641], 1643, [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [66720, 66729], [68912, 68921], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71481], [71904, 71913], [72016, 72025], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [92768, 92777], [92864, 92873], [93008, 93017], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125264, 125273], [130032, 130041]];
var Numeric_default2 = _813;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Other.js
var _814 = [[0, 9], [14, 31], 33, [35, 38], [40, 43], 45, 47, [60, 64], [91, 94], 96, [123, 132], [134, 159], [161, 169], [171, 172], [174, 180], 182, [184, 185], [187, 191], 215, 247, [728, 733], 885, [888, 889], [896, 901], 907, 909, 930, 1014, 1154, 1328, [1367, 1368], 1373, [1419, 1424], 1470, 1472, 1475, 1478, [1480, 1487], [1515, 1518], [1525, 1535], [1542, 1547], [1550, 1551], 1563, [1565, 1567], 1642, 1645, 1748, 1769, [1789, 1790], [1792, 1806], [1867, 1868], [1970, 1983], [2038, 2039], 2041, [2043, 2044], [2046, 2047], [2094, 2111], [2140, 2143], [2155, 2159], 2184, 2191, [2194, 2199], [2404, 2405], 2416, 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2546, 2555], 2557, [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2678, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2800, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], 2928, [2930, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3056, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3199], 3204, 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3407, 3411], [3416, 3422], [3428, 3429], [3440, 3449], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3572, 3632], [3634, 3635], [3643, 3654], 3663, [3674, 3760], [3762, 3763], [3773, 3783], 3791, [3802, 3839], [3841, 3863], [3866, 3871], [3882, 3892], 3894, 3896, [3898, 3901], 3912, [3949, 3952], 3973, 3992, [4029, 4037], [4039, 4095], 4130, 4136, 4159, [4170, 4175], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4254, 4255], 4294, [4296, 4300], [4302, 4303], 4347, 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4960, 4991], [5008, 5023], [5110, 5111], [5118, 5120], [5741, 5742], [5787, 5791], [5867, 5869], [5881, 5887], [5910, 5918], [5941, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6100, 6102], [6104, 6107], [6110, 6111], [6122, 6154], [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6469], [6510, 6511], [6517, 6527], [6570, 6575], [6602, 6607], [6619, 6655], [6684, 6740], 6751, [6781, 6782], [6794, 6799], [6810, 6831], [6863, 6911], [6989, 6991], [7002, 7018], [7028, 7039], [7156, 7167], [7224, 7231], [7242, 7244], [7294, 7295], [7305, 7311], [7355, 7356], [7360, 7375], 7379, [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8125, [8127, 8129], 8133, [8141, 8143], [8148, 8149], [8156, 8159], [8173, 8177], 8181, [8189, 8191], 8199, [8208, 8215], [8218, 8227], [8229, 8230], [8240, 8254], [8257, 8259], [8261, 8275], [8277, 8286], 8293, 8304, [8306, 8318], [8320, 8335], [8349, 8399], [8433, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8472], [8478, 8483], 8485, 8487, 8489, 8494, [8506, 8507], [8512, 8516], [8522, 8525], [8527, 8543], [8585, 9397], [9450, 9756], [9758, 9791], 9793, [9795, 9876], [9879, 9976], [9978, 9991], 9993, [9998, 10083], [10085, 11263], [11493, 11498], [11508, 11519], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11632, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11776, 11822], [11824, 12287], [12289, 12292], [12294, 12329], 12336, [12342, 12346], [12349, 12440], [12445, 12447], 12539, [12544, 12548], 12592, [12687, 12703], [12736, 12783], [12800, 13007], 13055, [13144, 40959], [42125, 42191], [42238, 42239], [42509, 42511], [42540, 42559], 42611, 42622, [42738, 42759], [42955, 42959], 42962, 42964, [42970, 42993], [43048, 43051], [43053, 43071], [43124, 43135], [43206, 43215], [43226, 43231], [43256, 43258], 43260, [43310, 43311], [43348, 43359], [43389, 43391], [43457, 43470], [43482, 43492], [43494, 43503], [43514, 43519], [43575, 43583], [43598, 43599], [43610, 43642], [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, [43714, 43743], [43760, 43761], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43882, 43887], 44011, [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 64047], [64107, 64255], [64263, 64274], [64280, 64284], 64297, 64311, 64317, 64319, 64322, 64325, [64434, 64466], [64830, 64847], [64912, 64913], [64968, 65007], [65020, 65023], [65041, 65042], [65045, 65055], [65072, 65074], [65077, 65100], 65105, 65107, [65110, 65135], 65141, [65277, 65278], [65280, 65286], [65288, 65291], 65293, 65295, [65308, 65312], [65339, 65342], 65344, [65371, 65381], [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65528], [65532, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65855], [65909, 66044], [66046, 66175], [66205, 66207], [66257, 66271], [66273, 66303], [66336, 66348], [66379, 66383], [66427, 66431], [66462, 66463], [66500, 66503], 66512, [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66927], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], [67670, 67679], [67703, 67711], [67743, 67807], 67827, [67830, 67839], [67862, 67871], [67898, 67967], [68024, 68029], [68032, 68095], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68160, 68191], [68221, 68223], [68253, 68287], 68296, [68327, 68351], [68406, 68415], [68438, 68447], [68467, 68479], [68498, 68607], [68681, 68735], [68787, 68799], [68851, 68863], [68904, 68911], [68922, 69247], 69290, [69293, 69295], [69298, 69372], [69405, 69414], [69416, 69423], [69457, 69487], [69510, 69551], [69573, 69599], [69623, 69631], [69703, 69733], [69750, 69758], [69819, 69820], [69822, 69825], [69827, 69836], [69838, 69839], [69865, 69871], [69882, 69887], 69941, [69952, 69955], [69960, 69967], [70004, 70005], [70007, 70015], [70085, 70088], 70093, 70107, [70109, 70143], 70162, [70200, 70205], [70210, 70271], 70279, 70281, 70286, 70302, [70313, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], [70731, 70735], [70746, 70749], [70754, 70783], 70854, [70856, 70863], [70874, 71039], [71094, 71095], [71105, 71127], [71134, 71167], [71233, 71235], [71237, 71247], [71258, 71295], [71353, 71359], [71370, 71452], [71468, 71471], [71482, 71679], [71739, 71839], [71914, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72004, 72015], [72026, 72095], [72104, 72105], [72152, 72153], 72162, [72165, 72191], [72255, 72262], [72264, 72271], [72346, 72348], [72350, 72367], [72441, 72703], 72713, 72759, [72769, 72783], [72794, 72817], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73463, 73471], 73489, [73531, 73533], [73539, 73551], [73562, 73647], [73649, 73727], [74650, 74751], [74863, 74879], [75076, 77711], [77809, 77823], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92783], 92863, [92874, 92879], [92910, 92911], [92917, 92927], [92983, 92991], [92996, 93007], [93018, 93026], [93048, 93052], [93072, 93759], [93824, 93951], [94027, 94030], [94088, 94094], [94112, 94175], 94178, [94181, 94191], [94194, 110575], 110580, 110588, 110591, [110593, 110879], [110883, 110932], [110934, 110947], [110952, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113820], 113823, [113828, 118527], [118574, 118575], [118599, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119361], [119365, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], 120513, 120539, 120571, 120597, 120629, 120655, 120687, 120713, 120745, 120771, [120780, 120781], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123215, 123535], [123567, 123583], [123642, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125135], [125143, 125183], [125260, 125263], [125274, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 127279], [127306, 127311], [127338, 127343], [127370, 127461], [127488, 127751], [127753, 127805], [127807, 127858], [127860, 127876], [127878, 127890], [127892, 127907], [127909, 127911], [127913, 127937], [127941, 127942], [127944, 127945], [127949, 127978], 127980, [127982, 127994], [128e3, 128065], [128068, 128069], [128081, 128101], [128106, 128109], 128111, [128121, 128123], [128125, 128128], 128132, [128136, 128138], [128140, 128169], [128171, 128186], [128189, 128294], [128296, 128299], [128301, 128371], [128374, 128377], [128379, 128399], [128401, 128404], [128407, 128487], [128489, 128580], [128584, 128586], [128592, 128639], [128641, 128657], [128659, 128674], [128676, 128691], [128695, 128703], [128705, 128715], [128717, 129303], [129312, 129317], [129319, 129327], [129338, 129339], [129343, 129488], [129502, 130031], [130042, 917504], [917506, 917535], [917632, 917759], [918e3, 1114111]];
var Other_default2 = _814;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Regional_Indicator.js
var _815 = [[127462, 127487]];
var Regional_Indicator_default3 = _815;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Single_Quote.js
var _816 = [39];
var Single_Quote_default = _816;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/WSegSpace.js
var _817 = [32, 5760, [8192, 8198], [8200, 8202], 8287, 12288];
var WSegSpace_default = _817;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/ZWJ.js
var _818 = [8205];
var ZWJ_default2 = _818;

// ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/index.js
function unicode2(categories) {
  const keys = Object.keys(categories);
  if (keys.length === 0) {
    throw new Error(`Expected at least one category, but received 0.`);
  }
  if (keys.some((key) => {
    const subCategories = categories[key];
    return subCategories === void 0 || subCategories.length === 0;
  })) {
    throw new Error(`Expected at least one sub category, but received 0.`);
  }
  const charsets = keys.map((key) => {
    const subCategories = categories[key];
    const subCharsets = subCategories.map((_819) => getCharset(key, _819));
    return new Charset().union(...subCharsets);
  });
  return charsets.reduce((a, b) => a.intersect(b));
}
function getCharset(category, subCategory) {
  const categoryData = data_exports[category];
  const charsetInputs = categoryData[subCategory];
  return new Charset().union(...charsetInputs);
}

// ../node_modules/.pnpm/cjk-regex@3.1.0/node_modules/cjk-regex/lib/index.js
var cjkLetters = unicode2({
  Script: ["Han", "Katakana", "Hiragana", "Hangul", "Bopomofo"],
  General_Category: [
    "Other_Letter",
    "Letter_Number",
    "Other_Symbol",
    "Modifier_Letter"
  ]
});
var cjkPunctuations = unicode2({
  Block: [
    "CJK_Compatibility",
    "CJK_Symbols_And_Punctuation",
    "Vertical_Forms",
    "CJK_Compatibility_Forms",
    "Small_Form_Variants",
    "Halfwidth_And_Fullwidth_Forms",
    "Ideographic_Description_Characters",
    "Kanbun",
    "CJK_Strokes",
    "Enclosed_CJK_Letters_And_Months"
  ]
}).subtract(cjkLetters);
var cjkAll = charset(cjkLetters, cjkPunctuations);
function all() {
  return charset(cjkAll);
}
function letters() {
  return charset(cjkLetters);
}
function punctuations() {
  return charset(cjkPunctuations);
}

// ../packages/engine-render/src/components/docs/layout/shaping-engine/font-cache.ts
var DEFAULT_MEASURE_TEXT = "0";
var getDefaultBaselineOffset = (fontSize) => ({
  sbr: 0.6,
  sbo: fontSize,
  spr: 0.6,
  spo: fontSize
});
var FontCache = class {
  static get globalFontMeasureCache() {
    return this._globalFontMeasureCache;
  }
  static setFontMeasureCache(fontStyle, content, tm) {
    if (!this._globalFontMeasureCache.has(fontStyle)) {
      this._globalFontMeasureCache.set(fontStyle, /* @__PURE__ */ new Map());
    }
    const fontMeasureCache = this._globalFontMeasureCache.get(fontStyle);
    if (fontMeasureCache) {
      fontMeasureCache.set(content, tm);
    }
  }
  static clearFontMeasureCache(path) {
    var _a;
    const pathArr = path.split("/");
    if (pathArr.length === 1) {
      const fontStyle = pathArr[0];
      this._globalFontMeasureCache.delete(fontStyle);
    } else if (pathArr.length === 2) {
      const fontStyle = pathArr[0];
      const content = pathArr[1];
      (_a = this._globalFontMeasureCache.get(fontStyle)) == null ? void 0 : _a.delete(content);
    } else {
      return false;
    }
    return true;
  }
  static getFontMeasureCache(fontStyle, content) {
    var _a;
    return (_a = this._globalFontMeasureCache.get(fontStyle)) == null ? void 0 : _a.get(content);
  }
  // 自动清除文字缓存，阈值可调整，清除规则是触发上限后删除一半的缓存
  static autoCleanFontMeasureCache(cacheLimit = 1e6) {
    let allSize = 0;
    let isDelete = false;
    let i = 0;
    for (const item of this._globalFontMeasureCache) {
      const [, values] = item;
      allSize += values.size;
      if (allSize > cacheLimit) {
        isDelete = true;
        break;
      }
      i++;
    }
    if (isDelete) {
      let deleteAllSize = 0;
      for (const item of this._globalFontMeasureCache) {
        const [key, values] = item;
        deleteAllSize += values.size;
        if (deleteAllSize > cacheLimit / 2) {
          const limit = deleteAllSize - cacheLimit / 2;
          this._clearMeasureCache(limit, values);
          break;
        }
        this._globalFontMeasureCache.delete(key);
      }
      return true;
    }
    return false;
  }
  static getBaselineOffsetInfo(fontFamily, fontSize) {
    if (this._fontDataMap.size === 0) {
      return getDefaultBaselineOffset(fontSize);
    }
    const fontFamilyList = fontFamily.split(",");
    for (let ff of fontFamilyList) {
      ff = ff.replace(/'/g, "");
      const fontData = this._fontDataMap.get(ff);
      if (!fontData) {
        continue;
      }
      const { subscriptSizeRatio, subscriptOffset, superscriptSizeRatio, superscriptOffset } = fontData;
      return {
        sbr: subscriptSizeRatio,
        sbo: subscriptOffset * fontSize,
        spr: superscriptSizeRatio,
        spo: superscriptOffset * fontSize
      };
    }
    return getDefaultBaselineOffset(fontSize);
  }
  static getTextSizeByDom(text, fontStyle) {
    if (fontStyle in this._getTextHeightCache) {
      return this._getTextHeightCache[fontStyle];
    }
    let dom = document.getElementById("universheetTextSizeTest");
    const defaultStyle = "float:left;white-space:nowrap;visibility:hidden;margin:0;padding:0;";
    if (!dom) {
      dom = document.createElement("span");
      dom.id = "universheetTextSizeTest";
      document.getElementsByTagName("body")[0].appendChild(dom);
    }
    dom.style.cssText += `${defaultStyle};${fontStyle}`;
    dom.textContent = text;
    const rect = dom.getBoundingClientRect();
    const result = { width: rect.width, height: rect.height };
    this._getTextHeightCache[fontStyle] = result;
    return result;
  }
  static getTextSize(content, fontStyle) {
    const { fontString, fontSize, fontFamily } = fontStyle;
    let bBox = this._getBoundingBoxByFont(fontFamily, fontSize);
    if (!bBox) {
      const measureText = this.getMeasureText(content, fontString);
      bBox = this._calculateBoundingBoxByMeasureText(measureText, fontStyle);
    }
    return bBox;
  }
  static getBBoxFromGlyphInfo(glyphInfo, fontStyle) {
    var _a;
    const glyph = glyphInfo.glyph;
    const font = glyphInfo.font;
    const { y1, y2 } = glyphInfo.boundingBox;
    const scale = ptToPixel(fontStyle.fontSize) / font.unitsPerEm;
    const { ascender, descender } = font;
    return this._calculateBoundingBoxByMeasureText({
      width: ((_a = glyph.advanceWidth) != null ? _a : 0) * scale,
      fontBoundingBoxAscent: ascender * scale,
      fontBoundingBoxDescent: Math.abs(descender * scale),
      actualBoundingBoxAscent: y2 * scale,
      actualBoundingBoxDescent: Math.abs(y1 * scale)
    }, fontStyle);
  }
  /**
   * Measure text on another canvas.
   * @param content
   * @param fontString
   * @returns IMeasureTextCache
   */
  static getMeasureText(content, fontString) {
    if (!this._context) {
      const canvas = document.createElement("canvas");
      this._context = canvas.getContext("2d");
    }
    if (!this._context) {
      return {
        width: 0,
        fontBoundingBoxAscent: 0,
        fontBoundingBoxDescent: 0,
        actualBoundingBoxAscent: 0,
        actualBoundingBoxDescent: 0
      };
    }
    const ctx = this._context;
    const mtc = this.getFontMeasureCache(fontString, content);
    if (mtc != null) {
      return mtc;
    }
    ctx.font = fontString;
    const textMetrics = ctx.measureText(content);
    const {
      width,
      fontBoundingBoxAscent,
      fontBoundingBoxDescent,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent
    } = textMetrics;
    const cache = {
      width,
      fontBoundingBoxAscent,
      fontBoundingBoxDescent,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent
    };
    if (fontBoundingBoxAscent == null || fontBoundingBoxDescent == null || Number.isNaN(fontBoundingBoxAscent) || Number.isNaN(fontBoundingBoxDescent)) {
      const oneLineTextHeight = this.getTextSizeByDom(DEFAULT_MEASURE_TEXT, fontString).height;
      if (ctx.textBaseline === "top") {
        cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight;
        cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = 0;
      } else if (ctx.textBaseline === "middle") {
        cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = oneLineTextHeight / 2;
        cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight / 2;
      } else {
        cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = 0;
        cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight;
      }
    }
    this.setFontMeasureCache(fontString, content, cache);
    return cache;
  }
  static _clearMeasureCache(limit, values) {
    let valueIndex = 0;
    for (const txtItem of values) {
      const [txtKey] = txtItem;
      if (valueIndex > limit) {
        break;
      }
      values.delete(txtKey);
      valueIndex++;
    }
    return true;
  }
  /**
   * Vertical Metrics https://glyphsapp.com/learn/vertical-metrics
   * @param fontFamily
   * @param fontSize
   * @param content
   * @returns
   */
  static _getBoundingBoxByFont(fontFamily, fontSize = 28, content = "") {
    const fontData = this._fontDataMap.get(fontFamily);
    if (!fontData) {
      return;
    }
    const {
      notDefWidth,
      ascender,
      descender,
      typoAscender,
      typoDescender,
      strikeoutPosition,
      subscriptSizeRatio,
      subscriptOffset,
      superscriptSizeRatio,
      superscriptOffset,
      hdmxData,
      glyphHorizonMap
    } = fontData;
    const pixelsPerEmIndex = hdmxData == null ? void 0 : hdmxData.indexOf(Math.floor(fontSize));
    const glyph = glyphHorizonMap.get(content.charCodeAt(0));
    let widthResult = notDefWidth;
    if (glyph) {
      const { width, pixelsPerEm = [] } = glyph;
      if (pixelsPerEmIndex) {
        widthResult = pixelsPerEm[pixelsPerEmIndex];
      } else {
        widthResult = width;
      }
    }
    return {
      width: widthResult * fontSize,
      ba: ascender * fontSize,
      bd: descender * fontSize,
      aba: typoAscender * fontSize,
      abd: typoDescender * fontSize,
      sp: strikeoutPosition * fontSize,
      sbr: subscriptSizeRatio,
      sbo: subscriptOffset * fontSize,
      spr: superscriptSizeRatio,
      spo: superscriptOffset * fontSize
    };
  }
  static _calculateBoundingBoxByMeasureText(textCache, fontStyle) {
    const {
      width,
      fontBoundingBoxAscent,
      fontBoundingBoxDescent,
      actualBoundingBoxAscent: aba,
      actualBoundingBoxDescent: abd
    } = textCache;
    const { fontSize, originFontSize } = fontStyle;
    const scale = originFontSize / fontSize;
    const ba = fontBoundingBoxAscent * scale;
    const bd = fontBoundingBoxDescent * scale;
    return {
      width,
      ba,
      bd,
      aba,
      abd,
      sp: (fontBoundingBoxAscent + fontBoundingBoxDescent) / 2,
      sbr: 0.6,
      spr: 0.6,
      // https://en.wikipedia.org/wiki/Subscript_and_superscript Microsoft Word 2015
      sbo: (ba + bd) * 0.141,
      spo: (ba + bd) * 0.4
    };
  }
};
__publicField(FontCache, "_getTextHeightCache", {});
__publicField(FontCache, "_context");
__publicField(FontCache, "_fontDataMap", /* @__PURE__ */ new Map());
__publicField(FontCache, "_globalFontMeasureCache", /* @__PURE__ */ new Map());

// ../packages/engine-render/src/basics/tools.ts
var DEG180 = 180;
var PI_OVER_DEG180 = Math.PI / DEG180;
var DEG180_OVER_PI = DEG180 / Math.PI;
var RGB_PAREN = "rgb(";
var RGBA_PAREN = "rgba(";
var getColor = (RgbArray, opacity) => {
  if (!RgbArray) {
    return `${RGB_PAREN}0,0,0)`;
  }
  if (opacity != null) {
    return `${RGBA_PAREN + RgbArray.join(",")},${opacity})`;
  }
  return `${RGB_PAREN + RgbArray.join(",")})`;
};
var PERCENT_TO_NUMBER_DIVIDE = 100;
var toPx = (num, ReferenceValue) => {
  if (Tools.isNumber(num)) {
    return num;
  }
  if (ReferenceValue && num && Tools.isString(num) && num.substr(num.length - 1, 1) === "%") {
    const numFloat = Number.parseFloat(num) / PERCENT_TO_NUMBER_DIVIDE;
    return ReferenceValue * numFloat;
  }
  return 0;
};
var ONE_FRAME_NUMBER = 16;
var requestNewFrame = (func, requester) => {
  if (!requester) {
    requester = window;
  }
  if (requester.requestPostAnimationFrame) {
    return requester.requestPostAnimationFrame(func);
  }
  if (requester.requestAnimationFrame) {
    return requester.requestAnimationFrame(func);
  }
  if (requester.msRequestAnimationFrame) {
    return requester.msRequestAnimationFrame(func);
  }
  if (requester.webkitRequestAnimationFrame) {
    return requester.webkitRequestAnimationFrame(func);
  }
  if (requester.mozRequestAnimationFrame) {
    return requester.mozRequestAnimationFrame(func);
  }
  if (requester.oRequestAnimationFrame) {
    return requester.oRequestAnimationFrame(func);
  }
  return setTimeout(func, ONE_FRAME_NUMBER);
};
var cancelRequestFrame = (requestID, requester) => {
  if (!requester) {
    requester = window;
  }
  if (requester.requestPostAnimationFrame) {
    return requester.cancelPostAnimationFrame(requestID);
  }
  if (requester.requestAnimationFrame) {
    return requester.cancelAnimationFrame(requestID);
  }
  if (requester.msRequestAnimationFrame) {
    return requester.msCancelAnimationFrame(requestID);
  }
  if (requester.webkitRequestAnimationFrame) {
    return requester.webkitCancelAnimationFrame(requestID);
  }
  if (requester.mozRequestAnimationFrame) {
    return requester.mozCancelAnimationFrame(requestID);
  }
  if (requester.oRequestAnimationFrame) {
    return requester.oCancelAnimationFrame(requestID);
  }
  return clearTimeout(requestID);
};
var createCanvasElement = () => {
  const canvas = document.createElement("canvas");
  try {
    canvas.style = canvas.style || {};
  } catch (e) {
    console.error(e);
  }
  return canvas;
};
var radToDeg = (rad) => rad * DEG180_OVER_PI;
var degToRad = (deg) => deg * PI_OVER_DEG180;
var getPointerPrefix = () => {
  let eventPrefix = "pointer";
  if (typeof window !== "undefined" && !window.PointerEvent && typeof navigator !== "undefined") {
    eventPrefix = "mouse";
  }
  if (Tools.isTablet() && !Tools.isIPhone() && // And not ipad pros who claim to be macs...
  !(document && "ontouchend" in document)) {
    eventPrefix = "mouse";
  }
  return eventPrefix;
};
var IsSafari = () => {
  if (Tools.getBrowserType() === "safari") {
    return true;
  }
  return false;
};
var GENERATE_RANDOM_KEY_DEFAULT_LENGTH = 4;
var generateRandomKey = (prefix = "obj", keyLength = GENERATE_RANDOM_KEY_DEFAULT_LENGTH) => {
  const userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, "").split("");
  let mid = "";
  for (let i = 0; i < keyLength; i++) {
    mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];
  }
  const time = (/* @__PURE__ */ new Date()).getTime();
  return `${prefix}_${mid}_${time}`;
};
function getValueType(value) {
  return Object.prototype.toString.apply(value);
}
function isFunction(value) {
  return getValueType(value) === "[object Function]";
}
function isString(value) {
  return getValueType(value) === "[object String]";
}
function isObject(value) {
  return getValueType(value) === "[object Object]";
}
function precisionTo(num, accurate) {
  accurate = 10 ** accurate;
  return Math.round(num * accurate) / accurate;
}
function fixLineWidthByScale(num, scale) {
  return Math.round(num * scale) / scale;
}
function getFontStyleString(textStyle) {
  const defaultFont = DEFAULT_STYLES.ff;
  const defaultFontSize = DEFAULT_STYLES.fs;
  if (!textStyle) {
    const fontString2 = `${defaultFontSize}pt  ${defaultFont}`;
    return {
      fontCache: fontString2,
      fontString: fontString2,
      fontSize: defaultFontSize,
      originFontSize: defaultFontSize,
      fontFamily: defaultFont
    };
  }
  let italic = "italic" /* ITALIC */;
  if (textStyle.it === 0 || textStyle.it === void 0) {
    italic = "normal" /* NORMAL */;
  }
  let bold = "bold" /* BOLD */;
  if (textStyle.bl === 0 || textStyle.bl === void 0) {
    bold = "normal" /* NORMAL */;
  }
  let originFontSize = defaultFontSize;
  if (textStyle.fs) {
    originFontSize = Math.ceil(textStyle.fs);
  }
  let fontSize = originFontSize;
  let fontFamilyResult = defaultFont;
  if (textStyle.ff) {
    let fontFamily = textStyle.ff;
    fontFamily = fontFamily.replace(/"/g, "").replace(/'/g, "");
    if (fontFamily.indexOf(" ") > -1) {
      fontFamily = `"${fontFamily}"`;
    }
    if (fontFamily == null) {
      fontFamily = defaultFont;
    }
    fontFamilyResult = fontFamily;
  }
  const { va: baselineOffset } = textStyle;
  if (baselineOffset === 2 /* SUBSCRIPT */ || baselineOffset === 3 /* SUPERSCRIPT */) {
    const baselineOffsetInfo = FontCache.getBaselineOffsetInfo(fontFamilyResult, fontSize);
    const { sbr, spr } = baselineOffsetInfo;
    fontSize *= baselineOffset === 2 /* SUBSCRIPT */ ? sbr : spr;
  }
  const fontStringPure = `${italic} ${bold} ${fontSize}pt ${fontFamilyResult}`;
  const fontString = `${fontStringPure}, ${DEFAULT_FONTFACE_PLANE} `;
  return {
    fontCache: fontStringPure,
    fontString,
    fontSize,
    originFontSize,
    fontFamily: fontFamilyResult
  };
}
var CJK_LETTER_REG = letters().toRegExp();
function hasCJKText(text) {
  return CJK_LETTER_REG.test(text);
}
var CJK_ALL_REG = all().toRegExp();
function hasCJK(text) {
  return CJK_ALL_REG.test(text);
}
var CJK_PUNCTUATION_REG = punctuations().toRegExp();
function hasCJKPunctuation(text) {
  return CJK_PUNCTUATION_REG.test(text);
}
var EMOJI_REG = /^(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/g;
var EMOJI_REG_LOCAL = /^(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/;
function startWithEmoji(text) {
  return EMOJI_REG_LOCAL.test(text);
}
function hasArabic(text) {
  const pattern = /[\u0600-\u06FF]|[\u0750-\u0750]|[\u0870-\u08FF]|[\uFB50-\uFDFF]|[\uFE70-\uFEFF]/gi;
  return pattern.test(text);
}
function hasTibetan(text) {
  const pattern = /[\u0180-\u024F]/gi;
  return pattern.test(text);
}
function hasSpace(text) {
  const pattern = /\s+/g;
  return pattern.test(text);
}
function isCjkLeftAlignedPunctuation(text) {
  const LEFT_ALIGNED_PUNCTUATION = ["\u201D", "\u2019", "\uFF0C", "\u3002", "\uFF0E", "\u3001", "\uFF1A", "\uFF1B", "\uFF1F", "\uFF01", "\u300B", "\uFF09", "\u300F", "\u300D", "\u3011", "\u3017", "\u3015", "\u3009", "\uFF3D", "\uFF5D"];
  return LEFT_ALIGNED_PUNCTUATION.indexOf(text) > -1;
}
function isCjkRightAlignedPunctuation(text) {
  const RIGHT_ALIGNED_PUNCTUATION = ["\u201C", "\u2018", "\u300A", "\uFF08", "\u300E", "\u300C", "\u3010", "\u3016", "\u3014", "\u3008", "\uFF3B", "\uFF5B"];
  return RIGHT_ALIGNED_PUNCTUATION.indexOf(text) > -1;
}
function isCjkCenterAlignedPunctuation(text) {
  const CENTER_ALIGNED_PUNCTUATION = ["\u30FB", "\xB7"];
  return CENTER_ALIGNED_PUNCTUATION.indexOf(text) > -1;
}
function getScale(parentScale) {
  const { scaleX = 1, scaleY = 1 } = parentScale;
  return Math.max(scaleX, scaleY);
}
function pxToNum(unit) {
  return Number(unit.replace(/px/gi, ""));
}
function getSizeForDom(dom) {
  const style = getComputedStyle(dom);
  const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth, width, height } = style;
  return {
    top: pxToNum(borderTopWidth),
    left: pxToNum(borderLeftWidth),
    right: pxToNum(borderRightWidth),
    bottom: pxToNum(borderBottomWidth),
    width: pxToNum(width),
    height: pxToNum(height)
  };
}
var PX_TO_PT_RATIO = 0.75;
function ptToPixel(pt) {
  return pt / PX_TO_PT_RATIO;
}
function pixelToPt(px) {
  return px * PX_TO_PT_RATIO;
}
function inViewRanges(ranges, rowIndex, colIndex) {
  for (const range of ranges) {
    if (rowIndex >= range.startRow && rowIndex <= range.endRow && colIndex >= range.startColumn && colIndex <= range.endColumn) {
      return true;
    }
  }
  return false;
}
function clampRange(range, maxRow, maxColumn) {
  return {
    startRow: Tools.clamp(range.startRow, 0, maxRow),
    endRow: Tools.clamp(range.endRow, 0, maxRow),
    startColumn: Tools.clamp(range.startColumn, 0, maxColumn),
    endColumn: Tools.clamp(range.endColumn, 0, maxColumn)
  };
}
function getSystemHighlightColor() {
  const hiddenEle = document.createElement("div");
  hiddenEle.style.width = "0";
  hiddenEle.style.height = "0";
  hiddenEle.style.backgroundColor = "highlight";
  document.body.append(hiddenEle);
  const highlightColor = getComputedStyle(hiddenEle).backgroundColor;
  hiddenEle.remove();
  const colorParser = new ColorKit(highlightColor);
  return colorParser.toRgb();
}

// ../packages/engine-render/src/basics/vector2.ts
var Vector2 = class _Vector2 {
  /**
   * Creates a new Vector2 from the given x and y coordinates
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   */
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  // Statics
  /**
   * Gets a new Vector2(0, 0)
   * @returns a new Vector2
   */
  static Zero() {
    return new _Vector2(0, 0);
  }
  /**
   * Gets a new Vector2(1, 1)
   * @returns a new Vector2
   */
  static One() {
    return new _Vector2(1, 1);
  }
  /**
   * Gets a new Vector2 set from the given index element of the given array
   * @param array defines the data source
   * @param offset defines the offset in the data source
   * @returns a new Vector2
   */
  static FromArray(array, offset = 0) {
    return new _Vector2(array[offset], array[offset + 1]);
  }
  /**
   * Sets "result" from the given index element of the given array
   * @param array defines the data source
   * @param offset defines the offset in the data source
   * @param result defines the target vector
   */
  static FromArrayToRef(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
  }
  /**
   * Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
   * @param value1 defines 1st point of control
   * @param value2 defines 2nd point of control
   * @param value3 defines 3rd point of control
   * @param value4 defines 4th point of control
   * @param amount defines the interpolation factor
   * @returns a new Vector2
   */
  static CatmullRom(value1, value2, value3, value4, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
    const y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
    return new _Vector2(x, y);
  }
  /**
   * Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
   * If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
   * If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
   * @param value defines the value to clamp
   * @param min defines the lower limit
   * @param max defines the upper limit
   * @returns a new Vector2
   */
  static Clamp(value, min2, max2) {
    let x = value.x;
    x = x > max2.x ? max2.x : x;
    x = x < min2.x ? min2.x : x;
    let y = value.y;
    y = y > max2.y ? max2.y : y;
    y = y < min2.y ? min2.y : y;
    return new _Vector2(x, y);
  }
  /**
   * Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2"
   * @param value1 defines the 1st control point
   * @param tangent1 defines the outgoing tangent
   * @param value2 defines the 2nd control point
   * @param tangent2 defines the incoming tangent
   * @param amount defines the interpolation factor
   * @returns a new Vector2
   */
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
    const y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
    return new _Vector2(x, y);
  }
  /**
   * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @returns 1st derivative
   */
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = _Vector2.Zero();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  /**
   * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @param result define where the derivative will be stored
   */
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
  }
  /**
   * Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
   * @param start defines the start vector
   * @param end defines the end vector
   * @param amount defines the interpolation factor
   * @returns a new Vector2
   */
  static Lerp(start, end, amount) {
    const x = start.x + (end.x - start.x) * amount;
    const y = start.y + (end.y - start.y) * amount;
    return new _Vector2(x, y);
  }
  /**
   * Gets the dot product of the vector "left" and the vector "right"
   * @param left defines first vector
   * @param right defines second vector
   * @returns the dot product (float)
   */
  static Dot(left, right) {
    return left.x * right.x + left.y * right.y;
  }
  /**
   * Returns a new Vector2 equal to the normalized given vector
   * @param vector defines the vector to normalize
   * @returns a new Vector2
   */
  static Normalize(vector) {
    const newVector = _Vector2.Zero();
    this.NormalizeToRef(vector, newVector);
    return newVector;
  }
  /**
   * Normalize a given vector into a second one
   * @param vector defines the vector to normalize
   * @param result defines the vector where to store the result
   */
  static NormalizeToRef(vector, result) {
    const len = vector.length();
    if (len === 0) {
      return;
    }
    result.x = vector.x / len;
    result.y = vector.y / len;
  }
  /**
   * Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
   * @param left defines 1st vector
   * @param right defines 2nd vector
   * @returns a new Vector2
   */
  static Minimize(left, right) {
    const x = left.x < right.x ? left.x : right.x;
    const y = left.y < right.y ? left.y : right.y;
    return new _Vector2(x, y);
  }
  /**
   * Gets a new Vector2 set with the maximal coordinate values from the "left" and "right" vectors
   * @param left defines 1st vector
   * @param right defines 2nd vector
   * @returns a new Vector2
   */
  static Maximize(left, right) {
    const x = left.x > right.x ? left.x : right.x;
    const y = left.y > right.y ? left.y : right.y;
    return new _Vector2(x, y);
  }
  // /**
  //  * Transforms the given vector coordinates by the given transformation Transform and stores the result in the vector "result" coordinates
  //  * @param vector defines the vector to transform
  //  * @param transformation defines the Transform to apply
  //  * @param result defines the target vector
  //  */
  // static Transform(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Transform>, ignoreOffset: boolean = false) {
  //     const t = transformation as IKeyValue;
  //     const p = vector;
  //     if (ignoreOffset) {
  //         return new Vector2(t[0] * p.x + t[2] * p.y, t[1] * p.x + t[3] * p.y);
  //     }
  //     return new Vector2(t[0] * p.x + t[2] * p.y + t[4], t[1] * p.x + t[3] * p.y + t[5]);
  // }
  /**
   * Determines if a given vector is included in a triangle
   * @param p defines the vector to test
   * @param p0 defines 1st triangle point
   * @param p1 defines 2nd triangle point
   * @param p2 defines 3rd triangle point
   * @returns true if the point "p" is in the triangle defined by the vectors "p0", "p1", "p2"
   */
  static PointInTriangle(p, p0, p1, p2) {
    const a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
    const sign = a < 0 ? -1 : 1;
    const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
    const t2 = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
    return s > 0 && t2 > 0 && s + t2 < 2 * a * sign;
  }
  /**
   * Gets the distance between the vectors "value1" and "value2"
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @returns the distance between vectors
   */
  static Distance(value1, value2) {
    return Math.sqrt(_Vector2.DistanceSquared(value1, value2));
  }
  /**
   * Returns the squared distance between the vectors "value1" and "value2"
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @returns the squared distance between vectors
   */
  static DistanceSquared(value1, value2) {
    const x = value1.x - value2.x;
    const y = value1.y - value2.y;
    return x * x + y * y;
  }
  /**
   * Gets a new Vector2 located at the center of the vectors "value1" and "value2"
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @returns a new Vector2
   */
  static Center(value1, value2) {
    return _Vector2.CenterToRef(value1, value2, _Vector2.Zero());
  }
  /**
   * Gets the center of the vectors "value1" and "value2" and stores the result in the vector "ref"
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @param ref defines third vector
   * @returns ref
   */
  static CenterToRef(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
  }
  /**
   * Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
   * @param p defines the middle point
   * @param segA defines one point of the segment
   * @param segB defines the other point of the segment
   * @returns the shortest distance
   */
  static DistanceOfPointFromSegment(p, segA, segB) {
    const l2 = _Vector2.DistanceSquared(segA, segB);
    if (l2 === 0) {
      return _Vector2.Distance(p, segA);
    }
    const v = segB.subtract(segA);
    const t2 = Math.max(0, Math.min(1, _Vector2.Dot(p.subtract(segA), v) / l2));
    const proj = segA.add(v.multiplyByFloats(t2, t2));
    return _Vector2.Distance(p, proj);
  }
  static create(x, y) {
    return new _Vector2(x, y);
  }
  /**
   * Gets a string with the Vector2 coordinates
   * @returns a string with the Vector2 coordinates
   */
  toString() {
    return `{X: ${this.x} Y: ${this.y}}`;
  }
  /**
   * Gets class name
   * @returns the string "Vector2"
   */
  getClassName() {
    return "Vector2";
  }
  /**
   * Gets current vector hash code
   * @returns the Vector2 hash code as a number
   */
  getHashCode() {
    let hash = this.x | 0;
    hash = hash * 397 ^ (this.y | 0);
    return hash;
  }
  // Operators
  /**
   * Sets the Vector2 coordinates in the given array or Float32Array from the given index.
   * @param array defines the source array
   * @param index defines the offset in source array
   * @returns the current Vector2
   */
  toArray(array, index = 0) {
    array[index] = this.x;
    array[index + 1] = this.y;
    return this;
  }
  /**
   * Update the current vector from an array
   * @param array defines the destination array
   * @param index defines the offset in the destination array
   * @returns the current Vector3
   */
  fromArray(array, index = 0) {
    _Vector2.FromArrayToRef(array, index, this);
    return this;
  }
  /**
   * Copy the current vector to an array
   * @returns a new array with 2 elements: the Vector2 coordinates.
   */
  asArray() {
    const result = new Array();
    this.toArray(result, 0);
    return result;
  }
  /**
   * Sets the Vector2 coordinates with the given Vector2 coordinates
   * @param source defines the source Vector2
   * @returns the current updated Vector2
   */
  copyFrom(source) {
    this.x = source.x;
    this.y = source.y;
    return this;
  }
  /**
   * Sets the Vector2 coordinates with the given floats
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   * @returns the current updated Vector2
   */
  copyFromFloats(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  /**
   * Sets the Vector2 coordinates with the given floats
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   * @returns the current updated Vector2
   */
  set(x, y) {
    return this.copyFromFloats(x, y);
  }
  /**
   * Add another vector with the current one
   * @param otherVector defines the other vector
   * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates
   */
  add(otherVector) {
    return new _Vector2(this.x + otherVector.x, this.y + otherVector.y);
  }
  /**
   * Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns the unmodified current Vector2
   */
  addToRef(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    return this;
  }
  addByPoint(x, y) {
    return new _Vector2(this.x + x, this.y + y);
  }
  /**
   * Set the Vector2 coordinates by adding the given Vector2 coordinates
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  addInPlace(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    return this;
  }
  /**
   * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
   * @param otherVector defines the other vector
   * @returns a new Vector2
   */
  subtract(otherVector) {
    return new _Vector2(this.x - otherVector.x, this.y - otherVector.y);
  }
  subtractByPoint(x, y) {
    return new _Vector2(this.x - x, this.y - y);
  }
  /**
   * Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns the unmodified current Vector2
   */
  subtractToRef(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    return this;
  }
  /**
   * Sets the current Vector2 coordinates by subtracting from it the given one coordinates
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  subtractInPlace(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    return this;
  }
  /**
   * Multiplies in place the current Vector2 coordinates by the given ones
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  multiplyInPlace(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    return this;
  }
  /**
   * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
   * @param otherVector defines the other vector
   * @returns a new Vector2
   */
  multiply(otherVector) {
    return new _Vector2(this.x * otherVector.x, this.y * otherVector.y);
  }
  /**
   * Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns the unmodified current Vector2
   */
  multiplyToRef(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    return this;
  }
  /**
   * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   * @returns a new Vector2
   */
  multiplyByFloats(x, y) {
    return new _Vector2(this.x * x, this.y * y);
  }
  /**
   * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
   * @param otherVector defines the other vector
   * @returns a new Vector2
   */
  divide(otherVector) {
    return new _Vector2(this.x / otherVector.x, this.y / otherVector.y);
  }
  /**
   * Sets the "result" coordinates with the Vector2 divided by the given one coordinates
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns the unmodified current Vector2
   */
  divideToRef(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    return this;
  }
  /**
   * Divides the current Vector2 coordinates by the given ones
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  divideInPlace(otherVector) {
    return this.divideToRef(otherVector, this);
  }
  /**
   * Gets a new Vector2 with current Vector2 negated coordinates
   * @returns a new Vector2
   */
  negate() {
    return new _Vector2(-this.x, -this.y);
  }
  /**
   * Negate this vector in place
   * @returns this
   */
  negateInPlace() {
    this.x *= -1;
    this.y *= -1;
    return this;
  }
  /**
   * Negate the current Vector2 and stores the result in the given vector "result" coordinates
   * @param result defines the Vector3 object where to store the result
   * @returns the current Vector2
   */
  negateToRef(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1);
  }
  /**
   * Multiply the Vector2 coordinates by scale
   * @param scale defines the scaling factor
   * @returns the current updated Vector2
   */
  scaleInPlace(scale) {
    this.x *= scale;
    this.y *= scale;
    return this;
  }
  /**
   * Returns a new Vector2 scaled by "scale" from the current Vector2
   * @param scale defines the scaling factor
   * @returns a new Vector2
   */
  scale(scale) {
    const result = new _Vector2(0, 0);
    this.scaleToRef(scale, result);
    return result;
  }
  /**
   * Scale the current Vector2 values by a factor to a given Vector2
   * @param scale defines the scale factor
   * @param result defines the Vector2 object where to store the result
   * @returns the unmodified current Vector2
   */
  scaleToRef(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    return this;
  }
  /**
   * Scale the current Vector2 values by a factor and add the result to a given Vector2
   * @param scale defines the scale factor
   * @param result defines the Vector2 object where to store the result
   * @returns the unmodified current Vector2
   */
  scaleAndAddToRef(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    return this;
  }
  /**
   * Gets a boolean if two vectors are equals
   * @param otherVector defines the other vector
   * @returns true if the given vector coordinates strictly equal the current Vector2 ones
   */
  equals(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y;
  }
  /**
   * Gets a new Vector2 from current Vector2 floored values
   * eg (1.2, 2.31) returns (1, 2)
   * @returns a new Vector2
   */
  floor() {
    return new _Vector2(Math.floor(this.x), Math.floor(this.y));
  }
  /**
   * Gets a new Vector2 from current Vector2 fractional values
   * eg (1.2, 2.31) returns (0.2, 0.31)
   * @returns a new Vector2
   */
  fract() {
    return new _Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  }
  /**
   * Rotate the current vector into a given result vector
   * @param angle defines the rotation angle
   * @returns the current vector
   */
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const rx = cos * this.x - sin * this.y;
    const ry = sin * this.x + cos * this.y;
    this.x = rx;
    this.y = ry;
    return this;
  }
  /**
   * Rotate the current vector into a given result vector
   * @param angle defines the rotation angle
   * @param result defines the result vector where to store the rotated vector
   * @returns the current vector
   */
  rotateToRef(angle, result) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    result.x = cos * this.x - sin * this.y;
    result.y = sin * this.x + cos * this.y;
    return this;
  }
  rotateByPoint(angle, originPoint = _Vector2.create(0, 0)) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    const rx = originPoint.x + (this.x - originPoint.x) * cosA - (this.y - originPoint.y) * sinA;
    const ry = originPoint.y + (this.x - originPoint.x) * sinA + (this.y - originPoint.y) * cosA;
    this.x = rx;
    this.y = ry;
    return this;
  }
  transformCoordinateOnRotate(angle) {
    const hypotenuse = Math.sqrt(this.x ** 2 + this.y ** 2);
    const beta = Math.atan2(this.y, this.x);
    const theta = -angle + beta;
    this.x = hypotenuse * Math.cos(theta);
    this.y = hypotenuse * Math.sin(theta);
    return this;
  }
  // Properties
  /**
   * Gets the length of the vector
   * @returns the vector length (float)
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Gets the vector squared length
   * @returns the vector squared length (float)
   */
  lengthSquared() {
    return this.x * this.x + this.y * this.y;
  }
  // Methods
  /**
   * Normalize the vector
   * @returns the current updated Vector2
   */
  normalize() {
    _Vector2.NormalizeToRef(this, this);
    return this;
  }
  /**
   * Gets a new Vector2 copied from the Vector2
   * @returns a new Vector2
   */
  clone() {
    return new _Vector2(this.x, this.y);
  }
};

// ../packages/engine-render/src/basics/draw.ts
function getDevicePixelRatio() {
  let _pixelRatio = 1;
  const canvas = createCanvasElement();
  const context = canvas.getContext("2d");
  _pixelRatio = (() => {
    const devicePixelRatio = window.devicePixelRatio || 1;
    const backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
    return devicePixelRatio / backingStoreRatio;
  })();
  if (_pixelRatio < 1) {
    return 1;
  }
  return _pixelRatio;
}
function drawLineByBorderType(ctx, type2, lineWidthBuffer, position) {
  let drawStartX = 0;
  let drawStartY = 0;
  let drawEndX = 0;
  let drawEndY = 0;
  const { startX, startY, endX, endY } = position;
  if (type2 === "t" /* TOP */) {
    drawStartX = startX - lineWidthBuffer;
    drawStartY = startY;
    drawEndX = endX + lineWidthBuffer;
    drawEndY = startY;
  } else if (type2 === "b" /* BOTTOM */) {
    drawStartX = startX - lineWidthBuffer;
    drawStartY = endY;
    drawEndX = endX - lineWidthBuffer;
    drawEndY = endY;
  } else if (type2 === "l" /* LEFT */) {
    drawStartX = startX;
    drawStartY = startY - lineWidthBuffer;
    drawEndX = startX;
    drawEndY = endY + lineWidthBuffer;
  } else if (type2 === "r" /* RIGHT */) {
    drawStartX = endX;
    drawStartY = startY - lineWidthBuffer;
    drawEndX = endX;
    drawEndY = endY + lineWidthBuffer;
  }
  ctx.beginPath();
  ctx.moveToByPrecision(drawStartX, drawStartY);
  ctx.lineToByPrecision(drawEndX, drawEndY);
  ctx.stroke();
  ctx.closePathByEnv();
}
function drawDiagonalLineByBorderType(ctx, type2, position) {
  let drawStartX = 0;
  let drawStartY = 0;
  let drawEndX = 0;
  let drawEndY = 0;
  const { startX, startY, endX, endY } = position;
  switch (type2) {
    case "tl_br" /* TL_BR */:
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = endX;
      drawEndY = endY;
      break;
    case "tl_bc" /* TL_BC */:
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = (startX + endX) / 2;
      drawEndY = endY;
      break;
    case "tl_mr" /* TL_MR */:
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = endX;
      drawEndY = (startY + endY) / 2;
      break;
    case "bl_tr" /* BL_TR */:
      drawStartX = startX;
      drawStartY = endY;
      drawEndX = endX;
      drawEndY = startY;
      break;
    case "ml_tr" /* ML_TR */:
      drawStartX = startX;
      drawStartY = (startY + endY) / 2;
      drawEndX = endX;
      drawEndY = startY;
      break;
    case "bc_tr" /* BC_TR */:
      drawStartX = (startX + endX) / 2;
      drawStartY = endY;
      drawEndX = endX;
      drawEndY = startY;
      break;
  }
  ctx.beginPath();
  ctx.moveToByPrecision(drawStartX, drawStartY);
  ctx.lineToByPrecision(drawEndX, drawEndY);
  ctx.closePathByEnv();
  ctx.stroke();
}
function setLineType(ctx, style) {
  if (style === 2 /* HAIR */) {
    ctx.setLineDash([1, 1]);
  } else if (style === 6 /* DASH_DOT_DOT */ || style === 11 /* MEDIUM_DASH_DOT_DOT */) {
    ctx.setLineDash([2, 2, 5, 2, 2]);
  } else if (style === 5 /* DASH_DOT */ || style === 10 /* MEDIUM_DASH_DOT */ || style === 12 /* SLANT_DASH_DOT */) {
    ctx.setLineDash([2, 5, 2]);
  } else if (style === 3 /* DOTTED */) {
    ctx.setLineDash([2]);
  } else if (style === 4 /* DASHED */ || style === 9 /* MEDIUM_DASHED */) {
    ctx.setLineDash([3]);
  } else {
    ctx.setLineDash([0]);
  }
}
function getLineWidth(style) {
  let lineWidth = 1;
  if (style === 8 /* MEDIUM */ || style === 10 /* MEDIUM_DASH_DOT */ || style === 9 /* MEDIUM_DASHED */ || style === 11 /* MEDIUM_DASH_DOT_DOT */) {
    lineWidth = 2;
  } else if (style === 13 /* THICK */) {
    lineWidth = 3;
  }
  return lineWidth;
}
function calculateRectRotate(startPoint, centerPoint, radiusCenter, radiusVertex, offsetPoint = Vector2.create(0, 0)) {
  const rotationVector = startPoint.add(centerPoint).rotateByPoint(radiusVertex);
  const newVector = rotationVector.subtract(centerPoint);
  const finalAngle = radiusVertex - radiusCenter;
  const finalXY = newVector.rotateByPoint(finalAngle, rotationVector);
  const newXY = finalXY.add(offsetPoint).transformCoordinateOnRotate(finalAngle);
  return newXY;
}
function getRotateOrientation(angle) {
  return angle > 0 ? 1 /* DOWN */ : 0 /* UP */;
}
function getRotateOffsetAndFarthestHypotenuse(lines, rectWidth, vertexAngle) {
  var _a;
  const rotateTranslateXList = [];
  let rotateTranslateY = 0;
  let rotatedHeight = 0;
  let rotatedWidth = 0;
  let fixOffsetX = 0;
  let fixOffsetY = 0;
  const orientation = getRotateOrientation(vertexAngle);
  const linesCount = lines.length;
  vertexAngle = Math.abs(vertexAngle);
  const tanTheta = Math.tan(vertexAngle);
  const sinTheta = Math.sin(vertexAngle);
  const cosTheta = Math.cos(vertexAngle);
  if (orientation === 0 /* UP */) {
    let cumRectHeight = 0;
    for (let i = 0; i < linesCount; i++) {
      const line2 = lines[i];
      const { lineHeight: rectHeight = 0 } = line2;
      cumRectHeight += i === 0 ? 0 : rectHeight;
      const currentRotateHeight = rectWidth * sinTheta + rectHeight * cosTheta;
      rotateTranslateXList.push(cumRectHeight / tanTheta);
      if (currentRotateHeight > rotatedHeight) {
        rotatedHeight = currentRotateHeight;
      }
      if (i === 0) {
        rotatedWidth += rectHeight * sinTheta;
        fixOffsetY += rectHeight * cosTheta;
      }
    }
    rotatedWidth += cumRectHeight / sinTheta + rectWidth * cosTheta;
    fixOffsetY -= rotatedHeight;
  } else {
    let maxOffsetX = 0;
    let maxOffsetLineIndex = -1;
    const rotateOffsetXList = [];
    for (let i = linesCount - 1; i >= 0; i--) {
      const line2 = lines[i];
      const { lineHeight: rectHeight = 0 } = line2;
      const offsetX = rectHeight / tanTheta;
      const currentRotateHeight = (rectWidth + offsetX) * sinTheta;
      rotateOffsetXList.unshift(rectHeight / tanTheta);
      if (currentRotateHeight > rotatedHeight) {
        rotatedHeight = currentRotateHeight;
        maxOffsetX = offsetX;
        maxOffsetLineIndex = i;
      }
      if (i === 0) {
        rotatedWidth += rectHeight * sinTheta;
      } else if (i === linesCount - 1) {
        rotatedWidth += rectWidth * cosTheta + rectHeight / sinTheta;
      } else {
        rotatedWidth += rectHeight / sinTheta;
      }
    }
    let cumRotateHeightFix = ((_a = lines[maxOffsetLineIndex]) == null ? void 0 : _a.lineHeight) || 0;
    let cumBlowValue = 0;
    for (let i = maxOffsetLineIndex + 1; i <= linesCount - 1; i++) {
      const line2 = lines[i];
      const { lineHeight: rectHeight = 0 } = line2;
      cumRotateHeightFix += rectHeight;
      cumBlowValue += rotateOffsetXList[i] || 0;
      rotateTranslateXList[i] = -cumBlowValue;
    }
    cumBlowValue = 0;
    for (let i = maxOffsetLineIndex - 1; i >= 0; i--) {
      const line2 = lines[i];
      const { lineHeight: rectHeight = 0 } = line2;
      cumBlowValue += rotateOffsetXList[i + 1] || 0;
      rotateTranslateXList[i] = cumBlowValue;
      rotateTranslateY += rectHeight;
    }
    rotateTranslateXList[maxOffsetLineIndex] = 0;
    if (linesCount === 1) {
      rotatedWidth += rectWidth * cosTheta;
    }
    fixOffsetX = cumRotateHeightFix / sinTheta - maxOffsetX * cosTheta;
  }
  return {
    rotateTranslateXList,
    rotatedHeight,
    rotatedWidth,
    fixOffsetX,
    fixOffsetY,
    rotateTranslateY
  };
}

// ../packages/engine-render/src/context.ts
var UniverRenderingContext2D = class {
  constructor(context) {
    __publicField(this, "__mode", "rendering");
    __publicField(this, "_transformCache");
    __publicField(this, "canvas");
    __publicField(this, "_context");
    __publicField(this, "_systemType");
    __publicField(this, "_browserType");
    __publicField(this, "renderConfig", {});
    __publicField(this, "_id");
    __publicField(this, "_normalizedCachedFont");
    this.canvas = context.canvas;
    this._context = context;
  }
  getId() {
    return this._id;
  }
  setId(id) {
    this._id = id;
  }
  isContextLost() {
    return this._context.isContextLost();
  }
  // globalAlpha: number;
  get globalAlpha() {
    return this._context.globalAlpha;
  }
  set globalAlpha(val) {
    this._context.globalAlpha = val;
  }
  // globalCompositeOperation: GlobalCompositeOperation;
  get globalCompositeOperation() {
    return this._context.globalCompositeOperation;
  }
  set globalCompositeOperation(val) {
    this._context.globalCompositeOperation = val;
  }
  // fillStyle: string | CanvasGradient | CanvasPattern;
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(val) {
    this._context.fillStyle = val;
  }
  // strokeStyle: string | CanvasGradient | CanvasPattern;
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(val) {
    this._context.strokeStyle = val;
  }
  // filter: string;
  get filter() {
    return this._context.filter;
  }
  set filter(val) {
    this._context.filter = val;
  }
  // imageSmoothingEnabled: boolean;
  get imageSmoothingEnabled() {
    return this._context.imageSmoothingEnabled;
  }
  set imageSmoothingEnabled(val) {
    this._context.imageSmoothingEnabled = val;
  }
  // imageSmoothingQuality: ImageSmoothingQuality;
  get imageSmoothingQuality() {
    return this._context.imageSmoothingQuality;
  }
  set imageSmoothingQuality(val) {
    this._context.imageSmoothingQuality = val;
  }
  // lineCap: CanvasLineCap;
  get lineCap() {
    return this._context.lineCap;
  }
  set lineCap(val) {
    this._context.lineCap = val;
  }
  // lineDashOffset: number;
  get lineDashOffset() {
    return this._context.lineDashOffset;
  }
  set lineDashOffset(val) {
    this._context.lineDashOffset = val;
  }
  // lineJoin: CanvasLineJoin;
  get lineJoin() {
    return this._context.lineJoin;
  }
  set lineJoin(val) {
    this._context.lineJoin = val;
  }
  // lineWidth: number;
  get lineWidth() {
    return this._context.lineWidth;
  }
  set lineWidth(val) {
    this._context.lineWidth = val;
  }
  setLineWidthByPrecision(val) {
    const { scaleX, scaleY } = this._getScale();
    this._context.lineWidth = val / Math.max(scaleX, scaleY);
  }
  // miterLimit: number;
  get miterLimit() {
    return this._context.miterLimit;
  }
  set miterLimit(val) {
    this._context.miterLimit = val;
  }
  // shadowBlur: number;
  get shadowBlur() {
    return this._context.shadowBlur;
  }
  set shadowBlur(val) {
    this._context.shadowBlur = val;
  }
  // shadowColor: string;
  get shadowColor() {
    return this._context.shadowColor;
  }
  set shadowColor(val) {
    this._context.shadowColor = val;
  }
  // shadowOffsetX: number;
  get shadowOffsetX() {
    return this._context.shadowOffsetX;
  }
  set shadowOffsetX(val) {
    this._context.shadowOffsetX = val;
  }
  // shadowOffsetY: number;
  get shadowOffsetY() {
    return this._context.shadowOffsetY;
  }
  set shadowOffsetY(val) {
    this._context.shadowOffsetY = val;
  }
  // direction: CanvasDirection;
  get direction() {
    return this._context.direction;
  }
  set direction(val) {
    this._context.direction = val;
  }
  get font() {
    if (this._normalizedCachedFont) {
      return this._normalizedCachedFont;
    }
    const fontStr = this._context.font;
    this._normalizedCachedFont = fontStr;
    return fontStr;
  }
  set font(val) {
    this._context.font = val;
    this._normalizedCachedFont = "";
  }
  // fontKerning: CanvasFontKerning;
  get fontKerning() {
    return this._context.fontKerning;
  }
  set fontKerning(val) {
    this._context.fontKerning = val;
  }
  // fontStretch: CanvasFontStretch;
  get fontStretch() {
    return this._context.fontStretch;
  }
  set fontStretch(val) {
    this._context.fontStretch = val;
  }
  // fontVariantCaps: CanvasFontVariantCaps;
  get fontVariantCaps() {
    return this._context.fontVariantCaps;
  }
  set fontVariantCaps(val) {
    this._context.fontVariantCaps = val;
  }
  // letterSpacing: string;
  get letterSpacing() {
    return this._context.letterSpacing;
  }
  set letterSpacing(val) {
    this._context.letterSpacing = val;
  }
  // textRendering: CanvasTextRendering;
  get textRendering() {
    return this._context.textRendering;
  }
  set textRendering(val) {
    this._context.textRendering = val;
  }
  // wordSpacing: string;
  get wordSpacing() {
    return this._context.wordSpacing;
  }
  set wordSpacing(val) {
    this._context.wordSpacing = val;
  }
  // textAlign: CanvasTextAlign;
  get textAlign() {
    return this._context.textAlign;
  }
  set textAlign(val) {
    this._context.textAlign = val;
  }
  // textBaseline: CanvasTextBaseline;
  get textBaseline() {
    return this._context.textBaseline;
  }
  set textBaseline(val) {
    this._context.textBaseline = val;
  }
  /**
   * Get scale from ctx.
   * DOMMatrix.a DOMMatrix.d would affect by ctx.rotate()
   */
  _getScale() {
    const transform = this.getTransform();
    const { a, b, c, d } = transform;
    const scaleX = Math.sqrt(a * a + b * b);
    const scaleY = Math.sqrt(c * c + d * d);
    return {
      scaleX,
      scaleY
    };
  }
  getScale() {
    return this._getScale();
  }
  getContextAttributes() {
    return this._context.getContextAttributes();
  }
  isPointInStroke(...args) {
    return this._context.isPointInStroke(...args);
  }
  createConicGradient(startAngle, x, y) {
    return this._context.createConicGradient(startAngle, x, y);
  }
  roundRect(x, y, w, h, radii) {
    this._context.roundRect(x, y, w, h, radii);
  }
  roundRectByPrecision(x, y, w, h, radii) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    w = fixLineWidthByScale(w, scaleX);
    h = fixLineWidthByScale(h, scaleY);
    this.roundRect(x, y, w, h, radii);
  }
  getTransform() {
    const m = this._transformCache || this._context.getTransform();
    return m;
  }
  resetTransform() {
    this._transformCache = null;
    this._context.resetTransform();
  }
  drawFocusIfNeeded(...args) {
    return this._context.drawFocusIfNeeded(...args);
  }
  /**
   * reset canvas context transform
   * @method
   */
  reset() {
    this._transformCache = null;
    this._context.reset();
  }
  /**
   * arc function.
   * @method
   */
  arc(x, y, radius, startAngle, endAngle, counterClockwise) {
    this._context.arc(x, y, Math.max(0, radius), startAngle, endAngle, counterClockwise);
  }
  /**
   * arc function.
   * @method
   */
  arcByPrecision(x, y, radius, startAngle, endAngle, counterClockwise) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    this.arc(x, y, radius, startAngle, endAngle, counterClockwise);
  }
  /**
   * arcTo function.
   * @method
   *
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._context.arcTo(x1, y1, x2, y2, radius);
  }
  /**
   * arcTo function.
   * @method
   *
   */
  arcToByPrecision(x1, y1, x2, y2, radius) {
    const { scaleX, scaleY } = this._getScale();
    x1 = fixLineWidthByScale(x1, scaleX);
    y1 = fixLineWidthByScale(y1, scaleY);
    x2 = fixLineWidthByScale(x2, scaleX);
    y2 = fixLineWidthByScale(y2, scaleY);
    this.arcTo(x1, y1, x2, y2, radius);
  }
  /**
   * beginPath function.
   * @method
   */
  beginPath() {
    this._context.beginPath();
  }
  /**
   * bezierCurveTo function.
   * @method
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  /**
   * bezierCurveTo function precision.
   * @method
   */
  bezierCurveToByPrecision(cp1x, cp1y, cp2x, cp2y, x, y) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    cp1x = fixLineWidthByScale(cp1x, scaleX);
    cp1y = fixLineWidthByScale(cp1y, scaleY);
    cp2x = fixLineWidthByScale(cp2x, scaleX);
    cp2y = fixLineWidthByScale(cp2y, scaleY);
    this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  /**
   * clearRect function.
   * @method
   */
  clearRect(x, y, width, height) {
    this._context.clearRect(x, y, width, height);
  }
  /**
   * clearRect function.
   * @method
   */
  clearRectByPrecision(x, y, width, height) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    width = fixLineWidthByScale(width, scaleX);
    height = fixLineWidthByScale(height, scaleY);
    this.clearRect(x, y, width, height);
  }
  clip(...args) {
    this._context.clip(...args);
  }
  /**
   * closePath function.
   * @method
   */
  closePath() {
    this._context.closePath();
  }
  getSystemType() {
    if (!this._systemType) {
      this._systemType = Tools.getSystemType();
    }
    return this._systemType;
  }
  getBrowserType() {
    if (!this._browserType) {
      this._browserType = Tools.getBrowserType();
    }
    return this._browserType;
  }
  /**
   * Chrome hardware acceleration causes canvas stroke to fail to draw lines on Mac.
   */
  closePathByEnv() {
    const system = this.getSystemType();
    const isMac = system === "Mac";
    const browser = this.getBrowserType();
    const isChrome = browser === "Chrome";
    if (isMac && isChrome) {
      return;
    }
    this._context.closePath();
  }
  createImageData(...args) {
    if (args.length === 0) {
      throw new Error("arguments is zero");
    }
    if (args.length === 1) {
      return this._context.createImageData(args[0]);
    }
    if (args.length === 2) {
      return this._context.createImageData(args[0], args[1]);
    }
    return this._context.createImageData(args[0], args[1], args[1]);
  }
  /**
   * createLinearGradient function.
   * @method
   */
  createLinearGradient(x0, y0, x1, y1) {
    return this._context.createLinearGradient(x0, y0, x1, y1);
  }
  /**
   * createPattern function.
   * @method
   */
  createPattern(image, repetition) {
    return this._context.createPattern(image, repetition);
  }
  /**
   * createRadialGradient function.
   * @method
   */
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
  }
  drawImage(...args) {
    const a = args;
    const _context = this._context;
    if (a.length === 3) {
      _context.drawImage(args[0], args[1], args[2]);
    } else if (a.length === 5) {
      _context.drawImage(args[0], args[1], args[2], args[3], args[4]);
    } else if (a.length === 9) {
      _context.drawImage(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
    }
  }
  /**
   * ellipse function.
   * @method
   */
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
    this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);
  }
  isPointInPath(...args) {
    return this._context.isPointInPath(...args);
  }
  fill(...args) {
    this._context.fill(...args);
  }
  /**
   * fillRect function.
   * @method
   */
  fillRect(x, y, width, height) {
    this._context.fillRect(x, y, width, height);
  }
  /**
   * fillRect function precision.
   * @method
   */
  fillRectByPrecision(x, y, width, height) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    width = fixLineWidthByScale(width, scaleX);
    height = fixLineWidthByScale(height, scaleY);
    this.fillRect(x, y, width, height);
  }
  /**
   * strokeRect function.
   * @method
   */
  strokeRect(x, y, width, height) {
    this._context.strokeRect(x, y, width, height);
  }
  /**
   * strokeRect function precision.
   * @method
   */
  strokeRectPrecision(x, y, width, height) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    width = fixLineWidthByScale(width, scaleX);
    height = fixLineWidthByScale(height, scaleY);
    this.strokeRect(x, y, width, height);
  }
  /**
   * fillText function.
   * @method
   */
  fillText(text, x, y, maxWidth) {
    if (maxWidth) {
      this._context.fillText(text, x, y, maxWidth);
    } else {
      this._context.fillText(text, x, y);
    }
  }
  /**
   * fillText function.
   * @method
   */
  fillTextPrecision(text, x, y, maxWidth) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    if (maxWidth) {
      maxWidth = fixLineWidthByScale(maxWidth, scaleX);
      this._context.fillText(text, x, y, maxWidth);
    } else {
      this._context.fillText(text, x, y);
    }
  }
  /**
   * measureText function.
   * @method
   */
  measureText(text) {
    return this._context.measureText(text);
  }
  /**
   * getImageData function.
   * @method
   */
  getImageData(sx, sy, sw, sh) {
    return this._context.getImageData(sx, sy, sw, sh);
  }
  /**
   * lineTo function.
   * @method
   */
  lineTo(x, y) {
    this._context.lineTo(x, y);
  }
  /**
   * lineTo function precision.
   * @method
   */
  lineToByPrecision(x, y) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    this.lineTo(x, y);
  }
  /**
   * moveTo function.
   * @method
   */
  moveTo(x, y) {
    this._context.moveTo(x, y);
  }
  /**
   * moveTo function precision.
   * @method
   */
  moveToByPrecision(x, y) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    this.moveTo(x, y);
  }
  moveToByPrecisionLog(x, y) {
    const { scaleX, scaleY } = this._getScale();
    const afterX = fixLineWidthByScale(x, scaleX);
    const afterY = fixLineWidthByScale(y, scaleY);
    this.moveTo(afterX, afterY);
  }
  /**
   * rect function.
   * @method
   */
  rect(x, y, width, height) {
    this._context.rect(x, y, width, height);
  }
  /**
   * rect function.
   * @method
   */
  rectByPrecision(x, y, width, height) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    width = fixLineWidthByScale(width, scaleX);
    height = fixLineWidthByScale(height, scaleY);
    this.rect(x, y, width, height);
  }
  /**
   * putImageData function.
   * @method
   */
  putImageData(imageData, dx, dy) {
    this._context.putImageData(imageData, dx, dy);
  }
  /**
   * quadraticCurveTo function.
   * @method
   */
  quadraticCurveTo(cpx, cpy, x, y) {
    this._context.quadraticCurveTo(cpx, cpy, x, y);
  }
  /**
   * restore function.
   * @method
   */
  restore() {
    this._transformCache = null;
    this._normalizedCachedFont = "";
    this._context.restore();
  }
  /**
   * rotate function.
   * @method
   */
  rotate(angle) {
    this._transformCache = null;
    this._context.rotate(angle);
  }
  /**
   * save function.
   * @method
   */
  save() {
    this._context.save();
  }
  /**
   * scale function.
   * @method
   */
  scale(x, y) {
    this._transformCache = null;
    this._context.scale(x, y);
  }
  /**
   * setLineDash function.
   * @method
   */
  setLineDash(segments) {
    if (this._context.setLineDash) {
      this._context.setLineDash(segments);
    } else if ("mozDash" in this._context) {
      this._context.mozDash = segments;
    } else if ("webkitLineDash" in this._context) {
      this._context.webkitLineDash = segments;
    }
  }
  /**
   * getLineDash function.
   * @method
   */
  getLineDash() {
    return this._context.getLineDash();
  }
  setTransform(...args) {
    this._transformCache = null;
    this._normalizedCachedFont = "";
    this._context.setTransform(...args);
  }
  /**
   * stroke function.
   * @method
   */
  stroke(path2d) {
    if (path2d) {
      this._context.stroke(path2d);
    } else {
      this._context.stroke();
    }
  }
  /**
   * strokeText function.
   * @method
   */
  strokeText(text, x, y, maxWidth) {
    this._context.strokeText(text, x, y, maxWidth);
  }
  /**
   * strokeText function precision.
   * @method
   */
  strokeTextByPrecision(text, x, y, maxWidth) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    if (maxWidth) {
      maxWidth = fixLineWidthByScale(maxWidth, scaleX);
    }
    this.strokeText(text, x, y, maxWidth);
  }
  /**
   * transform function.
   * @method
   */
  transform(a, b, c, d, e, f) {
    this._transformCache = null;
    this._context.transform(a, b, c, d, e, f);
  }
  /**
   * translate function.
   * @method
   */
  translate(x, y) {
    this._transformCache = null;
    this._context.translate(x, y);
  }
  translateWithPrecision(x, y) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    this._transformCache = null;
    this._context.translate(x, y);
  }
  translateWithPrecisionRatio(x, y) {
    this._transformCache = null;
    const { scaleX, scaleY } = this._getScale();
    this._context.translate(x / scaleX, y / scaleY);
  }
  clearRectForTexture(x, y, width, height) {
    this.clearRectByPrecision(x, y, width, height);
  }
  setGlobalCompositeOperation(val) {
    this._context.globalCompositeOperation = val;
  }
};
var UniverRenderingContext = class extends UniverRenderingContext2D {
};
var UniverPrintingContext = class extends UniverRenderingContext2D {
  constructor() {
    super(...arguments);
    __publicField(this, "__mode", "printing");
  }
  clearRect(x, y, width, height) {
    const { scaleX, scaleY } = this._getScale();
    x = fixLineWidthByScale(x, scaleX);
    y = fixLineWidthByScale(y, scaleY);
    width = fixLineWidthByScale(width, scaleX);
    height = fixLineWidthByScale(height, scaleY);
    this._context.save();
    this._context.fillStyle = getColor([255, 255, 255]);
    this._context.fillRect(x, y, width, height);
    this._context.restore();
  }
  clearRectForTexture(x, y, width, height) {
  }
  setGlobalCompositeOperation(val) {
  }
};

// ../packages/engine-render/src/canvas.ts
var Canvas = class {
  constructor(props) {
    __publicField(this, "isCache", false);
    __publicField(this, "_pixelRatio", 1);
    __publicField(this, "_canvasEle");
    __publicField(this, "_context");
    __publicField(this, "_width", 0);
    __publicField(this, "_height", 0);
    props = props || {};
    this._canvasEle = createCanvasElement();
    this._canvasEle.style.padding = "0";
    this._canvasEle.style.margin = "0";
    this._canvasEle.style.border = "0";
    this._canvasEle.style.background = "transparent";
    this._canvasEle.style.position = "absolute";
    this._canvasEle.style.top = "0";
    this._canvasEle.style.left = "0";
    this._canvasEle.style.zIndex = "8";
    this._canvasEle.className = "univer-render-canvas";
    this._canvasEle.tabIndex = 1;
    this._canvasEle.style.touchAction = "none";
    this._canvasEle.style.outline = "0";
    const context = this._canvasEle.getContext("2d");
    if (context == null) {
      throw new Error("context is not support");
    }
    if (props.mode === 1 /* Printing */) {
      this._context = new UniverPrintingContext(context);
    } else {
      this._context = new UniverRenderingContext(context);
    }
    this.setSize(props.width, props.height, props.pixelRatio);
  }
  getCanvasEle() {
    return this._canvasEle;
  }
  /**
   * get canvas context
   * @method
   * @returns {CanvasContext} context
   */
  getContext() {
    return this._context;
  }
  getPixelRatio() {
    return this._pixelRatio;
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  setId(id) {
    this._canvasEle.id = id;
  }
  /**
   * Resize canvas when width or height or devicePixelRatio changed.
   * @param width
   * @param height
   * @param devicePixelRatio
   */
  setSize(width, height, devicePixelRatio) {
    var _a;
    this._pixelRatio = devicePixelRatio || getDevicePixelRatio();
    const canvasElement = this.getCanvasEle();
    if (canvasElement && width !== void 0) {
      canvasElement.width = width * this._pixelRatio;
      this._width = canvasElement.width / this._pixelRatio;
      canvasElement.style.width = `${this._width}px`;
    }
    if (canvasElement && height !== void 0) {
      canvasElement.height = height * this._pixelRatio;
      this._height = canvasElement.height / this._pixelRatio;
      canvasElement.style.height = `${this._height}px`;
    }
    (_a = this.getContext()) == null ? void 0 : _a.setTransform(this._pixelRatio, 0, 0, this._pixelRatio, 0, 0);
  }
  setPixelRatio(pixelRatio) {
    if (this._width === 0 || this._height === 0) {
      return;
    }
    if (pixelRatio < 1) {
      pixelRatio = 1;
    }
    this.setSize(this._width, this._height, pixelRatio);
  }
  dispose() {
    var _a;
    this.clear();
    (_a = this._canvasEle) == null ? void 0 : _a.remove();
    this._canvasEle = null;
    this._context = null;
  }
  clear() {
    const ctx = this.getContext();
    ctx.clearRect(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * to data url
   * @method
   * @param {string} mimeType
   * @param {number} quality between 0 and 1 for jpg mime types
   * @returns {string} data url string
   */
  toDataURL(mimeType, quality) {
    try {
      return this.getCanvasEle().toDataURL(mimeType, quality);
    } catch (e) {
      try {
        return this.getCanvasEle().toDataURL();
      } catch (err) {
        const { message: message2 } = err;
        console.error(
          `Unable to get data URL. ${message2} For more info read https://universheet.net/docs/Canvas.html.`
        );
        return "";
      }
    }
  }
};

// ../packages/engine-render/src/floating/util.ts
function observeClientRect(containerElement) {
  return new Observable((observer) => {
    const disposable = autoClientRect(containerElement, () => observer.next());
    return () => disposable();
  });
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io == null ? void 0 : io.disconnect();
    io = null;
  }
  function refresh(skip2 = false, threshold = 1) {
    cleanup();
    const { left, top, width, height } = element.getBoundingClientRect();
    if (!skip2) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = `${-insetTop}px ${-insetRight}px ${-insetBottom}px ${-insetLeft}px`;
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function getBoundingClientRect(reference) {
  return reference.getBoundingClientRect();
}
function autoClientRect(reference, update) {
  const ancestorScroll = true;
  const ancestorResize = true;
  const layoutShift = true;
  const animationFrame = false;
  const referenceEl = reference;
  const ancestors = ancestorScroll || ancestorResize ? [
    ...referenceEl ? getOverflowAncestors(referenceEl) : []
  ] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, { passive: true });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let resizeObserver = null;
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null ? void 0 : cleanupIo();
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

// ../packages/engine-render/src/engine.ts
var Engine = class extends Disposable {
  constructor(...args) {
    var _a, _b, _c, _d, _e, _f, _g;
    super();
    __publicField(this, "renderEvenInBackground", true);
    __publicField(this, "_beginFrame$", new Subject());
    __publicField(this, "beginFrame$", this._beginFrame$.asObservable());
    __publicField(this, "_endFrame$", new Subject());
    __publicField(this, "endFrame$", this._endFrame$.asObservable());
    __publicField(this, "renderFrameTimeMetric$", new Subject());
    __publicField(this, "renderFrameTags$", new Subject());
    /**
     * Pass event to scene.input-manager
     */
    __publicField(this, "onInputChanged$", new EventSubject());
    __publicField(this, "onTransformChange$", new EventSubject());
    __publicField(this, "_scenes", {});
    __publicField(this, "_activeScene", null);
    /**
     * time when render start, for elapsedTime
     */
    __publicField(this, "_renderStartTime", 0);
    __publicField(this, "_rect$", null);
    __publicField(this, "_container");
    __publicField(this, "_canvas");
    __publicField(this, "_renderingQueueLaunched", false);
    __publicField(this, "_renderFrameTasks", new Array());
    __publicField(this, "_requestNewFrameHandler", -1);
    /**
     * frameCount
     */
    __publicField(this, "_frameId", -1);
    __publicField(this, "_usingSafari", IsSafari());
    __publicField(this, "_resizeObserver");
    // FPS
    __publicField(this, "_fps", 60);
    __publicField(this, "_deltaTime", 0);
    __publicField(this, "_performanceMonitor");
    __publicField(this, "_pointerMoveEvent");
    __publicField(this, "_pointerDownEvent");
    __publicField(this, "_pointerUpEvent");
    __publicField(this, "_pointerOutEvent");
    __publicField(this, "_pointerCancelEvent");
    __publicField(this, "_pointerBlurEvent");
    __publicField(this, "_pointerWheelEvent");
    __publicField(this, "_pointerEnterEvent");
    __publicField(this, "_pointerLeaveEvent");
    __publicField(this, "_dragEnterEvent");
    __publicField(this, "_dragLeaveEvent");
    __publicField(this, "_dragOverEvent");
    __publicField(this, "_dropEvent");
    __publicField(this, "_remainCapture", -1);
    /** previous pointer position */
    __publicField(this, "_pointerPosRecord", {});
    __publicField(this, "_mouseId", -1);
    __publicField(this, "_isUsingFirefox", navigator.userAgent.indexOf("Firefox") !== -1);
    __publicField(this, "_previousWidth", -1e3);
    __publicField(this, "_previousHeight", -1e3);
    __publicField(this, "_unitId", "");
    __publicField(this, "_resizeListenerDisposable");
    /**
     * call itself by raf
     * Exec all function in _renderFrameTasks in _renderFrame()
     */
    __publicField(this, "_renderFunction", (timestamp) => {
      let shouldRender = true;
      if (!this.renderEvenInBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this._beginFrame(timestamp);
        this._renderFrame(timestamp);
        this._endFrame(timestamp);
      }
      if (this._renderFrameTasks.length > 0) {
        this._requestNewFrameHandler = requestNewFrame(this._renderFunction);
      } else {
        this._renderingQueueLaunched = false;
      }
    });
    let elemWidth = 1;
    let elemHeight = 1;
    let pixelRatio = 1;
    let renderMode = 0 /* Rendering */;
    if (args[0] && typeof args[0] === "string") {
      this._unitId = args[0];
      const options = (_a = args[1]) != null ? _a : {
        elemWidth: 1,
        elemHeight: 1,
        pixelRatio: 1,
        renderMode: 0 /* Rendering */
      };
      elemWidth = options.elementWidth;
      elemHeight = options.elementHeight;
      pixelRatio = (_b = options.pixelRatio) != null ? _b : 1;
      renderMode = (_c = options.renderMode) != null ? _c : 0 /* Rendering */;
    } else {
      elemWidth = (_d = args[0]) != null ? _d : 1;
      elemHeight = (_e = args[1]) != null ? _e : 1;
      pixelRatio = (_f = args[2]) != null ? _f : 1;
      renderMode = (_g = args[3]) != null ? _g : 0 /* Rendering */;
    }
    this._canvas = new Canvas({
      mode: renderMode,
      width: elemWidth,
      height: elemHeight,
      pixelRatio
    });
    this._init();
    this._handleKeyboardAction();
    this._handlePointerAction();
    this._handleDragAction();
    if (renderMode !== 1 /* Printing */) {
      this._matchMediaHandler();
    }
  }
  get clientRect$() {
    return this._rect$ || (this._rect$ = new Observable((subscriber) => {
      if (!this._container) {
        throw new Error("[Engine]: cannot subscribe to rect changes when container is not set!");
      }
      const sub = observeClientRect(this._container).subscribe(() => subscriber.next());
      return () => {
        sub.unsubscribe();
        this._rect$ = null;
      };
    })).pipe(shareReplay(1));
  }
  _init() {
    this._performanceMonitor = new PerformanceMonitor();
  }
  get unitId() {
    return this._unitId;
  }
  get elapsedTime() {
    return Tools.now() - this._renderStartTime;
  }
  get width() {
    return this.getCanvas().getWidth();
  }
  get height() {
    return this.getCanvas().getHeight();
  }
  get classType() {
    return "Engine" /* ENGINE */;
  }
  get activeScene() {
    return this._activeScene;
  }
  getScenes() {
    return this._scenes;
  }
  getScene(sceneKey) {
    return this._scenes[sceneKey];
  }
  hasScene(sceneKey) {
    return sceneKey in this._scenes;
  }
  addScene(sceneInstance) {
    const sceneKey = sceneInstance.sceneKey;
    if (this.hasScene(sceneKey)) {
      console.warn("Scenes has same key, it will be covered");
    }
    this._scenes[sceneKey] = sceneInstance;
    return sceneInstance;
  }
  setActiveScene(sceneKey) {
    const scene = this.getScene(sceneKey);
    if (scene) {
      this._activeScene = scene;
    }
    return scene;
  }
  hasActiveScene() {
    return this._activeScene != null;
  }
  get requestNewFrameHandler() {
    return this._requestNewFrameHandler;
  }
  /**
   * Gets the current frame id
   */
  get frameId() {
    return this._frameId;
  }
  setCanvasCursor(val) {
    const canvasEl = this.getCanvas().getCanvasEle();
    canvasEl.style.cursor = val;
  }
  clearCanvas() {
    this.getCanvas().clear();
  }
  getCanvas() {
    return this._canvas;
  }
  getCanvasElement() {
    return this.getCanvas().getCanvasEle();
  }
  /**
   * To ensure mouse events remain bound to the host element,
   * preventing the events from becoming ineffective once the mouse leaves the host.
   */
  setCapture() {
    try {
      this.getCanvasElement().setPointerCapture(this._remainCapture);
    } catch {
      console.warn("no capture");
    }
  }
  getPixelRatio() {
    return this.getCanvas().getPixelRatio();
  }
  /**
   * Mount the canvas to the element so it would be rendered on UI.
   * @param {HTMLElement} element - The element the canvas will mount on.
   * @param {true} [resize] If should perform resize when mounted and observe resize event.
   */
  mount(element, resize = true) {
    this.setContainer(element, resize);
  }
  /**
   * Unmount the canvas without disposing it so it can be mounted again.
   */
  unmount() {
    this._clearResizeListener();
    if (!this._container) {
      throw new Error("[Engine]: cannot unmount when container is not set!");
    }
    this._container.removeChild(this.getCanvasElement());
    this._container = null;
  }
  /**
   * Mount the canvas to the element so it would be rendered on UI.
   * @deprecated Please use `mount` instead.
   * @param {HTMLElement} element - The element the canvas will mount on.
   * @param {true} [resize] If should perform resize when mounted and observe resize event.
   */
  setContainer(element, resize = true) {
    if (this._container === element) {
      return;
    }
    this._container = element;
    this._container.appendChild(this.getCanvasElement());
    this._clearResizeListener();
    if (resize) {
      this.resize();
      let timer;
      this._resizeObserver = new ResizeObserver(() => {
        if (!timer) {
          timer = window.requestIdleCallback(() => {
            this.resize();
            timer = void 0;
          });
        }
      });
      this._resizeObserver.observe(this._container);
      this._resizeListenerDisposable = toDisposable(() => {
        this._resizeObserver.unobserve(this._container);
        if (timer !== void 0) window.cancelIdleCallback(timer);
      });
    }
  }
  _clearResizeListener() {
    var _a;
    (_a = this._resizeListenerDisposable) == null ? void 0 : _a.dispose();
    this._resizeListenerDisposable = void 0;
  }
  resize() {
    if (!this._container) {
      return;
    }
    const { width, height } = getSizeForDom(this._container);
    if (width === this._previousWidth && height === this._previousHeight) {
      return;
    }
    this._previousWidth = width;
    this._previousHeight = height;
    this.resizeBySize(width, height);
  }
  dprChange() {
    const width = this._previousWidth;
    const height = this._previousHeight;
    this.resizeBySize(width, height);
  }
  /**
   * set canvas element size
   * @param width
   * @param height
   */
  resizeBySize(width, height) {
    const preWidth = this.width;
    const preHeight = this.height;
    this.getCanvas().setSize(width, height);
    this.onTransformChange$.emitEvent({
      type: 1 /* resize */,
      value: {
        width,
        height
      },
      preValue: {
        width: preWidth,
        height: preHeight
      }
    });
  }
  dispose() {
    var _a;
    super.dispose();
    const scenes = { ...this.getScenes() };
    const sceneKeys = Object.keys(scenes);
    sceneKeys.forEach((key) => {
      scenes[key].dispose();
    });
    this._scenes = {};
    const eventPrefix = getPointerPrefix();
    const canvasEle = this.getCanvasElement();
    canvasEle.removeEventListener(`${eventPrefix}leave`, this._pointerLeaveEvent);
    canvasEle.removeEventListener(`${eventPrefix}enter`, this._pointerEnterEvent);
    canvasEle.removeEventListener(`${eventPrefix}move`, this._pointerMoveEvent);
    canvasEle.removeEventListener(`${eventPrefix}down`, this._pointerDownEvent);
    canvasEle.removeEventListener(`${eventPrefix}up`, this._pointerUpEvent);
    canvasEle.removeEventListener(`${eventPrefix}out`, this._pointerOutEvent);
    canvasEle.removeEventListener(`${eventPrefix}cancel`, this._pointerCancelEvent);
    canvasEle.removeEventListener("blur", this._pointerBlurEvent);
    canvasEle.removeEventListener("dragenter", this._dragEnterEvent);
    canvasEle.removeEventListener("dragleave", this._dragLeaveEvent);
    canvasEle.removeEventListener("dragover", this._dragOverEvent);
    canvasEle.removeEventListener("drop", this._dropEvent);
    canvasEle.removeEventListener(this._getWheelEventName(), this._pointerWheelEvent);
    this._renderFrameTasks = [];
    this._performanceMonitor.dispose();
    this.getCanvas().dispose();
    (_a = this._resizeObserver) == null ? void 0 : _a.disconnect();
    this.onTransformChange$.complete();
    this._beginFrame$.complete();
    this._endFrame$.complete();
    this.renderFrameTags$.complete();
    this.renderFrameTimeMetric$.complete();
    this._clearResizeListener();
    this._container = null;
  }
  addFunction2RenderLoop(renderFunction) {
    if (this._renderFrameTasks.indexOf(renderFunction) === -1) {
      this._renderFrameTasks.push(renderFunction);
    }
  }
  startRenderLoop() {
    if (!this._renderingQueueLaunched) {
      this._renderStartTime = performance.now();
      this._renderingQueueLaunched = true;
      this._requestNewFrameHandler = requestNewFrame(this._renderFunction);
    }
  }
  /**
   * Register and execute a render loop. The engine could manage more than one render function
   * @param renderFunction defines the function to continuously execute
   */
  runRenderLoop(renderFunction) {
    this.addFunction2RenderLoop(renderFunction);
    this.startRenderLoop();
  }
  /**
   * stop executing a render loop function and remove it from the execution array
   * @param renderFunction defines the function to be removed. If not provided all functions will be removed.
   */
  stopRenderLoop(renderFunction) {
    if (!renderFunction) {
      this._renderFrameTasks.length = 0;
      this._cancelFrame();
      return;
    }
    const index = this._renderFrameTasks.indexOf(renderFunction);
    if (index >= 0) {
      this._renderFrameTasks.splice(index, 1);
      if (this._renderFrameTasks.length === 0) {
        this._cancelFrame();
      }
    }
  }
  /**
   * Begin a new frame
   */
  _beginFrame(_timestamp) {
    this._frameId++;
    this._beginFrame$.next(this._frameId);
  }
  /**
   * End the current frame
   */
  _endFrame(timestamp) {
    this._performanceMonitor.endFrame(timestamp);
    this._fps = this._performanceMonitor.averageFPS;
    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
    this._endFrame$.next({
      FPS: this.getFps(),
      frameTime: this.getDeltaTime(),
      elapsedTime: this.elapsedTime
    });
  }
  /**
   * Gets the current framerate
   * @returns a number representing the framerate
   */
  getFps() {
    return this._fps;
  }
  /**
   * Gets the time spent between current and previous frame
   * @returns a number representing the delta time in ms
   */
  getDeltaTime() {
    return this._deltaTime;
  }
  /**
   * Exec all function in _renderFrameTasks
   */
  _renderFrame(_timestamp) {
    for (let index = 0; index < this._renderFrameTasks.length; index++) {
      const renderFunction = this._renderFrameTasks[index];
      renderFunction();
    }
  }
  _cancelFrame() {
    if (this._renderingQueueLaunched && this._requestNewFrameHandler) {
      this._renderingQueueLaunched = false;
      if (typeof window === "undefined") {
        if (typeof cancelAnimationFrame === "function") {
          return cancelAnimationFrame(this._requestNewFrameHandler);
        }
      } else {
        const { cancelAnimationFrame: cancelAnimationFrame2 } = this._getHostWindow() || window;
        if (typeof cancelAnimationFrame2 === "function") {
          return cancelAnimationFrame2(this._requestNewFrameHandler);
        }
      }
      return clearTimeout(this._requestNewFrameHandler);
    }
  }
  _getHostWindow() {
    var _a;
    if (typeof window === "undefined") {
      return null;
    }
    if ((_a = this.getCanvasElement().ownerDocument) == null ? void 0 : _a.defaultView) {
      return this.getCanvasElement().ownerDocument.defaultView;
    }
    return window;
  }
  _handleKeyboardAction() {
    const keyboardDownEvent = (evt) => {
      const deviceEvent = evt;
      deviceEvent.deviceType = 1 /* Keyboard */;
      deviceEvent.inputIndex = evt.keyCode;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    const keyboardUpEvent = (evt) => {
      const deviceEvent = evt;
      deviceEvent.deviceType = 1 /* Keyboard */;
      deviceEvent.inputIndex = evt.keyCode;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    const canvasEle = this.getCanvasElement();
    canvasEle.addEventListener("keydown", keyboardDownEvent);
    canvasEle.addEventListener("keyup", keyboardUpEvent);
  }
  // eslint-disable-next-line max-lines-per-function
  _handlePointerAction() {
    const eventPrefix = getPointerPrefix();
    this._pointerMoveEvent = (e) => {
      const evt = e;
      const deviceType = this._getPointerType(evt);
      this._pointerPosRecord[0 /* Horizontal */] = evt.clientX;
      this._pointerPosRecord[1 /* Vertical */] = evt.clientY;
      this._pointerPosRecord[10 /* DeltaHorizontal */] = evt.movementX;
      this._pointerPosRecord[11 /* DeltaVertical */] = evt.movementY;
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      deviceEvent.inputIndex = 0 /* Horizontal */;
      this.onInputChanged$.emitEvent(deviceEvent);
      if (!this._usingSafari) {
        deviceEvent.inputIndex = evt.button + 2;
        this.onInputChanged$.emitEvent(deviceEvent);
      }
    };
    this._pointerDownEvent = (nativeEvent) => {
      const evt = nativeEvent;
      const deviceType = this._getPointerType(evt);
      const previousHorizontal = this._pointerPosRecord[0 /* Horizontal */];
      const previousVertical = this._pointerPosRecord[1 /* Vertical */];
      if (deviceType === 2 /* Mouse */) {
        if (this._mouseId === -1) {
          if (evt.pointerId === void 0) {
            this._mouseId = this._isUsingFirefox ? 0 : 1;
          } else {
            this._mouseId = evt.pointerId;
          }
        }
        if (!document.pointerLockElement) {
          this._remainCapture = this._mouseId;
        }
      } else {
        if (evt.pointerId && !document.pointerLockElement) {
          this._remainCapture = evt.pointerId;
        }
      }
      this._pointerPosRecord[0 /* Horizontal */] = evt.clientX;
      this._pointerPosRecord[1 /* Vertical */] = evt.clientY;
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      if (previousHorizontal !== evt.clientX) {
        deviceEvent.inputIndex = 0 /* Horizontal */;
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      if (previousVertical !== evt.clientY) {
        deviceEvent.inputIndex = 1 /* Vertical */;
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      deviceEvent.inputIndex = evt.button + 2;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    this._pointerUpEvent = (_evt) => {
      const evt = _evt;
      const deviceType = this._getPointerType(evt);
      const previousHorizontal = this._pointerPosRecord[0 /* Horizontal */];
      const previousVertical = this._pointerPosRecord[1 /* Vertical */];
      this._pointerPosRecord[0 /* Horizontal */] = evt.clientX;
      this._pointerPosRecord[1 /* Vertical */] = evt.clientY;
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      if (previousHorizontal !== evt.clientX) {
        deviceEvent.inputIndex = 0 /* Horizontal */;
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      if (previousVertical !== evt.clientY) {
        deviceEvent.inputIndex = 1 /* Vertical */;
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      deviceEvent.inputIndex = evt.button + 2;
      const canvasEle2 = this.getCanvasElement();
      if (deviceType === 2 /* Mouse */ && this._mouseId >= 0 && canvasEle2.hasPointerCapture(this._mouseId)) {
        this._remainCapture = this._mouseId;
        canvasEle2.releasePointerCapture(this._mouseId);
      } else if (deviceEvent.pointerId && canvasEle2.hasPointerCapture(deviceEvent.pointerId)) {
        this._remainCapture = deviceEvent.pointerId;
        canvasEle2.releasePointerCapture(deviceEvent.pointerId);
      }
      this.onInputChanged$.emitEvent(deviceEvent);
      if (deviceType !== 2 /* Mouse */) {
        this._pointerPosRecord = {};
      }
    };
    this._pointerEnterEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    this._pointerLeaveEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    this._pointerOutEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    this._pointerCancelEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    this._pointerBlurEvent = () => {
      if (this._mouseId >= 0 && this.getCanvasElement().hasPointerCapture(this._mouseId)) {
      }
      this._pointerPosRecord = {};
    };
    this._pointerWheelEvent = (evt) => {
      const deviceType = 2 /* Mouse */;
      this._pointerPosRecord[7 /* MouseWheelX */] = evt.deltaX || 0;
      this._pointerPosRecord[8 /* MouseWheelY */] = evt.deltaY || evt.wheelDelta || 0;
      this._pointerPosRecord[9 /* MouseWheelZ */] = evt.deltaZ || 0;
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      if (this._pointerPosRecord[7 /* MouseWheelX */] !== 0) {
        deviceEvent.currentState = this._pointerPosRecord[7 /* MouseWheelX */];
      }
      if (this._pointerPosRecord[8 /* MouseWheelY */] !== 0) {
        deviceEvent.currentState = this._pointerPosRecord[8 /* MouseWheelY */];
      }
      if (this._pointerPosRecord[9 /* MouseWheelZ */] !== 0) {
        deviceEvent.currentState = this._pointerPosRecord[9 /* MouseWheelZ */];
      }
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    const canvasEle = this.getCanvasElement();
    canvasEle.addEventListener(`${eventPrefix}enter`, this._pointerEnterEvent);
    canvasEle.addEventListener(`${eventPrefix}leave`, this._pointerLeaveEvent);
    canvasEle.addEventListener(`${eventPrefix}move`, this._pointerMoveEvent);
    canvasEle.addEventListener(`${eventPrefix}down`, this._pointerDownEvent);
    canvasEle.addEventListener(`${eventPrefix}up`, this._pointerUpEvent);
    canvasEle.addEventListener(`${eventPrefix}out`, this._pointerOutEvent);
    canvasEle.addEventListener(`${eventPrefix}cancel`, this._pointerCancelEvent);
    canvasEle.addEventListener("blur", this._pointerBlurEvent);
    canvasEle.addEventListener(
      this._getWheelEventName(),
      this._pointerWheelEvent,
      this._getPassive() ? { passive: false } : false
    );
  }
  // eslint-disable-next-line max-lines-per-function
  _handleDragAction() {
    this._dragEnterEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      deviceEvent.currentState = 4;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    this._dragLeaveEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      deviceEvent.currentState = 5;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    this._dragOverEvent = (evt) => {
      evt.preventDefault();
      const deviceType = this._getPointerType(evt);
      const previousHorizontal = this._pointerPosRecord[0 /* Horizontal */];
      const previousVertical = this._pointerPosRecord[1 /* Vertical */];
      this._pointerPosRecord[0 /* Horizontal */] = evt.clientX;
      this._pointerPosRecord[1 /* Vertical */] = evt.clientY;
      this._pointerPosRecord[10 /* DeltaHorizontal */] = evt.movementX;
      this._pointerPosRecord[11 /* DeltaVertical */] = evt.movementY;
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      if (previousHorizontal !== evt.clientX) {
        deviceEvent.inputIndex = 0 /* Horizontal */;
        deviceEvent.currentState = this._pointerPosRecord[0 /* Horizontal */];
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      if (previousVertical !== evt.clientY) {
        deviceEvent.inputIndex = 1 /* Vertical */;
        deviceEvent.currentState = this._pointerPosRecord[1 /* Vertical */];
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      if (this._pointerPosRecord[10 /* DeltaHorizontal */] !== 0) {
        deviceEvent.inputIndex = 10 /* DeltaHorizontal */;
        deviceEvent.currentState = this._pointerPosRecord[10 /* DeltaHorizontal */];
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      if (this._pointerPosRecord[11 /* DeltaVertical */] !== 0) {
        deviceEvent.inputIndex = 11 /* DeltaVertical */;
        deviceEvent.currentState = this._pointerPosRecord[11 /* DeltaVertical */];
        this.onInputChanged$.emitEvent(deviceEvent);
      }
      if (!this._usingSafari) {
        deviceEvent.inputIndex = evt.button + 2;
        deviceEvent.currentState = this._pointerPosRecord[evt.button + 2];
        this.onInputChanged$.emitEvent(deviceEvent);
      }
    };
    this._dropEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceEvent = evt;
      deviceEvent.deviceType = deviceType;
      deviceEvent.currentState = 6;
      this.onInputChanged$.emitEvent(deviceEvent);
    };
    const canvasEle = this.getCanvasElement();
    canvasEle.addEventListener("dragenter", this._dragEnterEvent);
    canvasEle.addEventListener("dragleave", this._dragLeaveEvent);
    canvasEle.addEventListener("dragover", this._dragOverEvent);
    canvasEle.addEventListener("drop", this._dropEvent);
  }
  _getWheelEventName() {
    const wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    return wheelEventName;
  }
  _getPassive() {
    let passiveSupported = false;
    const noop = () => {
    };
    try {
      const options = {
        passive: {
          get() {
            passiveSupported = true;
          }
        }
      };
      const canvasEle = this.getCanvasElement();
      canvasEle.addEventListener("test", noop, options);
      canvasEle.removeEventListener("test", noop, options);
    } catch (e) {
    }
    return passiveSupported;
  }
  _getPointerType(evt) {
    let deviceType = 2 /* Mouse */;
    if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
      deviceType = 3 /* Touch */;
    }
    return deviceType;
  }
  _matchMediaHandler() {
    if (!(window == null ? void 0 : window.matchMedia)) {
      return;
    }
    const mediaQueryList = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
    const _handleMediaChange = () => {
      this.dprChange();
    };
    mediaQueryList.addEventListener("change", _handleMediaChange);
    this.disposeWithMe(
      toDisposable(() => {
        mediaQueryList.removeEventListener("change", _handleMediaChange);
      })
    );
  }
};

// ../packages/engine-render/src/basics/transform.ts
var INITIAL_MATRIX = [1, 0, 0, 1, 0, 0];
var Transform = class _Transform {
  constructor(m = INITIAL_MATRIX) {
    __publicField(this, "dirty", false);
    __publicField(this, "_m");
    this._m = m && m.slice() || INITIAL_MATRIX;
  }
  static create(m = INITIAL_MATRIX) {
    return new this(m);
  }
  reset() {
    this._m[0] = 1;
    this._m[1] = 0;
    this._m[2] = 0;
    this._m[3] = 1;
    this._m[4] = 0;
    this._m[5] = 0;
  }
  /**
   * Copy universheet.Transform object
   * @method
   * @name universheet.Transform#copy
   * @returns {universheet.Transform}
   * @example
   * const tr = shape.getTransform().copy()
   */
  copy() {
    return new _Transform(this._m);
  }
  copyInto(tr) {
    tr._m[0] = this._m[0];
    tr._m[1] = this._m[1];
    tr._m[2] = this._m[2];
    tr._m[3] = this._m[3];
    tr._m[4] = this._m[4];
    tr._m[5] = this._m[5];
  }
  /**
   * Transform point
   * @method
   * @name universheet.Transform#point
   * @param {object} point 2D point(x, y)
   * @returns {object} 2D point(x, y)
   */
  applyPoint(point, ignoreOffset = false) {
    const m = this._m;
    const xNew = m[0] * point.x + m[2] * point.y;
    const yNew = m[1] * point.x + m[3] * point.y;
    if (ignoreOffset) {
      return new Vector2(xNew, yNew);
    }
    return new Vector2(xNew + m[4], yNew + m[5]);
  }
  /**
   * Apply translation
   * @method
   * @name universheet.Transform#translate
   * @param {number} x
   * @param {number} y
   * @returns {universheet.Transform}
   */
  translate(x, y) {
    this._m[4] += this._m[0] * x + this._m[2] * y;
    this._m[5] += this._m[1] * x + this._m[3] * y;
    return this;
  }
  /**
   * Apply scale
   * @method
   * @name universheet.Transform#scale
   * @param {number} sx
   * @param {number} sy
   * @returns {universheet.Transform}
   */
  scale(sx, sy) {
    this._m[0] *= sx;
    this._m[1] *= sx;
    this._m[2] *= sy;
    this._m[3] *= sy;
    return this;
  }
  /**
   * Apply rotation
   * @method
   * @name universheet.Transform#rotate
   * @param {number} Degree  Angle in Degree
   * @returns {universheet.Transform}
   */
  rotate(deg) {
    const rad = degToRad(deg);
    const c = Math.cos(rad);
    const s = Math.sin(rad);
    const m11 = this._m[0] * c + this._m[2] * s;
    const m12 = this._m[1] * c + this._m[3] * s;
    const m21 = this._m[0] * -s + this._m[2] * c;
    const m22 = this._m[1] * -s + this._m[3] * c;
    this._m[0] = m11;
    this._m[1] = m12;
    this._m[2] = m21;
    this._m[3] = m22;
    return this;
  }
  /**
   * Returns the translation
   * @method
   * @name universheet.Transform#getTranslation
   * @returns {object} 2D point(x, y)
   */
  getTranslation() {
    return {
      x: this._m[4],
      y: this._m[5]
    };
  }
  /**
   * Apply skew
   * @method
   * @name universheet.Transform#skew
   * @param {number} sx
   * @param {number} sy
   * @returns {universheet.Transform}
   */
  skew(sx, sy) {
    const m11 = this._m[0] + this._m[2] * sy;
    const m12 = this._m[1] + this._m[3] * sy;
    const m21 = this._m[2] + this._m[0] * sx;
    const m22 = this._m[3] + this._m[1] * sx;
    this._m[0] = m11;
    this._m[1] = m12;
    this._m[2] = m21;
    this._m[3] = m22;
    return this;
  }
  /**
   * Transform multiplication
   * @method
   * @name universheet.Transform#multiply
   * @param {universheet.Transform} matrix
   * @returns {universheet.Transform}
   */
  multiply(matrix) {
    const m11 = this._m[0] * matrix._m[0] + this._m[2] * matrix._m[1];
    const m12 = this._m[1] * matrix._m[0] + this._m[3] * matrix._m[1];
    const m21 = this._m[0] * matrix._m[2] + this._m[2] * matrix._m[3];
    const m22 = this._m[1] * matrix._m[2] + this._m[3] * matrix._m[3];
    const dx = this._m[0] * matrix._m[4] + this._m[2] * matrix._m[5] + this._m[4];
    const dy = this._m[1] * matrix._m[4] + this._m[3] * matrix._m[5] + this._m[5];
    this._m[0] = m11;
    this._m[1] = m12;
    this._m[2] = m21;
    this._m[3] = m22;
    this._m[4] = dx;
    this._m[5] = dy;
    return this;
  }
  /**
   * Invert the matrix
   * @method
   * @name universheet.Transform#invert
   * @returns {universheet.Transform}
   */
  invert() {
    const d = 1 / (this._m[0] * this._m[3] - this._m[1] * this._m[2]);
    const m0 = this._m[3] * d;
    const m1 = -this._m[1] * d;
    const m2 = -this._m[2] * d;
    const m3 = this._m[0] * d;
    const m4 = d * (this._m[2] * this._m[5] - this._m[3] * this._m[4]);
    const m5 = d * (this._m[1] * this._m[4] - this._m[0] * this._m[5]);
    this._m[0] = m0;
    this._m[1] = m1;
    this._m[2] = m2;
    this._m[3] = m3;
    this._m[4] = m4;
    this._m[5] = m5;
    return this;
  }
  /**
   * return matrix
   * @method
   * @name universheet.Transform#getMatrix
   */
  getMatrix() {
    return this._m;
  }
  /**
   * return matrix
   * @method
   * @name universheet.Transform#getMatrix
   */
  getMatrixByAccurate(accurate = 3) {
    return this._m.map((value) => precisionTo(value, accurate));
  }
  /**
   * set to absolute position via translation
   * @method
   * @name universheet.Transform#setAbsolutePosition
   * @returns {universheet.Transform}
   */
  setAbsolutePosition(coord) {
    const m0 = this._m[0];
    const m1 = this._m[1];
    const m2 = this._m[2];
    const m3 = this._m[3];
    const m4 = this._m[4];
    const m5 = this._m[5];
    const yt = (m0 * (coord.y - m5) - m1 * (coord.x - m4)) / (m0 * m3 - m1 * m2);
    const xt = (coord.x - m4 - m2 * yt) / m0;
    return this.translate(xt, yt);
  }
  /**
   * convert transformation matrix back into node's attributes
   * @method
   * @name universheet.Transform#decompose
   * @returns {universheet.Transform}
   */
  decompose() {
    const a = this._m[0];
    const b = this._m[1];
    const c = this._m[2];
    const d = this._m[3];
    const e = this._m[4];
    const f = this._m[5];
    const delta = a * d - b * c;
    const result = {
      x: e,
      y: f,
      angle: 0,
      scaleX: 0,
      scaleY: 0,
      skewX: 0,
      skewY: 0
    };
    if (a !== 0 || b !== 0) {
      const r = Math.sqrt(a * a + b * b);
      result.angle = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
      result.scaleX = r;
      result.scaleY = delta / r;
      result.skewX = (a * c + b * d) / delta;
      result.skewY = 0;
    } else if (c !== 0 || d !== 0) {
      const s = Math.sqrt(c * c + d * d);
      result.angle = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
      result.scaleX = delta / s;
      result.scaleY = s;
      result.skewX = 0;
      result.skewY = (a * c + b * d) / delta;
    } else {
    }
    result.angle = radToDeg(result.angle);
    return result;
  }
  makeBoundingBoxFromPoints(points) {
    if (this) {
      for (let i = 0; i < points.length; i++) {
        points[i] = this.applyPoint(points[i]);
      }
    }
    const xPoints = [points[0].x, points[1].x, points[2].x, points[3].x];
    const minX = Math.min(...xPoints);
    const maxX = Math.max(...xPoints);
    const width = maxX - minX;
    const yPoints = [points[0].y, points[1].y, points[2].y, points[3].y];
    const minY = Math.min(...yPoints);
    const maxY = Math.max(...yPoints);
    const height = maxY - minY;
    return {
      left: minX,
      top: minY,
      width,
      height,
      points
    };
  }
  composeMatrix(options) {
    const matrix = new _Transform([1, 0, 0, 1, options.left || 0, options.top || 0]);
    if (options.angle) {
      matrix.rotate(options.angle);
    }
    if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {
      matrix.multiply(this._calcDimensionsMatrix(options));
    }
    this._m = matrix.getMatrix();
    return this;
  }
  clone() {
    return new _Transform([...this._m]);
  }
  /**
   * Returns a transform matrix starting from an object of the same kind of
   * the one returned from qrDecompose, useful also if you want to calculate some
   * transformations from an object that is not enLived yet.
   * is called DimensionsTransformMatrix because those properties are the one that influence
   * the size of the resulting box of the object.
   * @param  {object} options
   * @param  {number} [options.scaleX]
   * @param  {number} [options.scaleY]
   * @param  {boolean} [options.flipX]
   * @param  {boolean} [options.flipY]
   * @param  {number} [options.skewX]
   * @param  {number} [options.skewX]
   * @return {number[]} transform matrix
   */
  _calcDimensionsMatrix(options) {
    var _a, _b;
    const scaleX = (_a = options.scaleX) != null ? _a : 1;
    const scaleY = (_b = options.scaleY) != null ? _b : 1;
    const scaleMatrix = new _Transform([
      options.flipX ? -scaleX : scaleX,
      0,
      0,
      options.flipY ? -scaleY : scaleY,
      0,
      0
    ]);
    if (options.skewX) {
      scaleMatrix.multiply(new _Transform([1, 0, Math.tan(degToRad(options.skewX)), 1, 0, 0]));
    }
    if (options.skewY) {
      scaleMatrix.multiply(new _Transform([1, Math.tan(degToRad(options.skewY)), 0, 1, 0, 0]));
    }
    return scaleMatrix;
  }
  convert2DOMMatrix2D() {
    const m = this.getMatrix();
    return {
      a: m[0],
      b: m[1],
      c: m[2],
      d: m[3],
      e: m[4],
      f: m[5]
    };
  }
  // static createTransformByState(state: positionState) {
  //     const newTr = new this();
  //     let { x, y, angle, scaleX, scaleY, skewX, skewY, flipX, flipY } = state;
  //     x = x ?? 0;
  //     y = y ?? 0;
  //     newTr.translate(x, y);
  //     if (angle) {
  //         newTr.rotate(angle);
  //     }
  //     scaleX = scaleX ?? 1;
  //     scaleY = scaleY ?? 1;
  //     newTr.scale(scaleX, scaleY);
  //     return newTr;
  // }
};

// ../packages/engine-render/src/base-object.ts
var BASE_OBJECT_ARRAY = [
  "top",
  "left",
  "width",
  "height",
  "angle",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY",
  "flipX",
  "flipY",
  "strokeWidth"
];
var BaseObject = class extends Disposable {
  // TODO: @DR-Univer. Belong to layer
  constructor(key) {
    super();
    __publicField(this, "groupKey");
    __publicField(this, "isInGroup", false);
    __publicField(this, "objectType", 0 /* UNKNOWN */);
    __publicField(this, "onTransformChange$", new EventSubject());
    __publicField(this, "onPointerDown$", new EventSubject());
    __publicField(this, "onPointerMove$", new EventSubject());
    __publicField(this, "onPointerUp$", new EventSubject());
    __publicField(this, "onPointerOut$", new EventSubject());
    __publicField(this, "onPointerOver$", new EventSubject());
    __publicField(this, "onPointerLeave$", new EventSubject());
    __publicField(this, "onPointerEnter$", new EventSubject());
    __publicField(this, "onDblclick$", new EventSubject());
    __publicField(this, "onTripleClick$", new EventSubject());
    __publicField(this, "onMouseWheel$", new EventSubject());
    __publicField(this, "onDragLeave$", new EventSubject());
    __publicField(this, "onDragOver$", new EventSubject());
    __publicField(this, "onDragEnter$", new EventSubject());
    __publicField(this, "onDrop$", new EventSubject());
    __publicField(this, "onIsAddedToParent$", new EventSubject());
    __publicField(this, "onDispose$", new EventSubject());
    __publicField(this, "_oKey");
    __publicField(this, "_dirty", true);
    __publicField(this, "_forceDirty", true);
    __publicField(this, "_printable", false);
    __publicField(this, "_top", 0);
    __publicField(this, "_topOrigin", 0);
    __publicField(this, "_left", 0);
    __publicField(this, "_leftOrigin", 0);
    __publicField(this, "_width", 0);
    __publicField(this, "_widthOrigin", 0);
    __publicField(this, "_height", 0);
    __publicField(this, "_heightOrigin", 0);
    __publicField(this, "_angle", 0);
    __publicField(this, "_scaleX", 1);
    __publicField(this, "_scaleY", 1);
    __publicField(this, "_skewX", 0);
    __publicField(this, "_skewY", 0);
    __publicField(this, "_flipX", false);
    __publicField(this, "_flipY", false);
    __publicField(this, "_strokeWidth", 0);
    __publicField(this, "_parent");
    // TODO: @DR-Univer. The object must be mounted to a scene or group. 'Any' is used here to avoid circular dependencies. This will be resolved later through dependency injection.
    __publicField(this, "_zIndex", 0);
    __publicField(this, "_evented", true);
    __publicField(this, "_visible", true);
    __publicField(this, "_debounceParentDirty", true);
    __publicField(this, "_transform", new Transform());
    __publicField(this, "_cursor", "default" /* DEFAULT */);
    __publicField(this, "_transformerConfig");
    __publicField(this, "_forceRender", false);
    __publicField(this, "_layer");
    if (key) {
      this._oKey = key;
    } else {
      this._oKey = generateRandomKey();
    }
  }
  get transform() {
    const transform = this._transform.clone();
    return this.transformForAngle(transform);
  }
  transformForAngle(transform) {
    if (this._angle !== 0) {
      const cx = (this.width + this.strokeWidth) / 2;
      const cy = (this.height + this.strokeWidth) / 2;
      transform.rotate(-this._angle);
      transform.translate(cx, cy);
      transform.rotate(this.angle);
      transform.translate(-cx, -cy);
    }
    return transform;
  }
  get printable() {
    return this._printable;
  }
  get topOrigin() {
    return this._topOrigin;
  }
  get leftOrigin() {
    return this._leftOrigin;
  }
  get widthOrigin() {
    return this._widthOrigin;
  }
  get heightOrigin() {
    return this._heightOrigin;
  }
  get classType() {
    return "BaseObject" /* BASE_OBJECT */;
  }
  get top() {
    return this._top;
  }
  get left() {
    return this._left;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get strokeWidth() {
    return this._strokeWidth;
  }
  get angle() {
    return this._angle;
  }
  get scaleX() {
    return this._scaleX;
  }
  get scaleY() {
    return this._scaleY;
  }
  get ancestorScaleX() {
    var _a;
    const pScale = ((_a = this.getParent()) == null ? void 0 : _a.ancestorScaleX) || 1;
    return this.scaleX * pScale;
  }
  get ancestorScaleY() {
    var _a;
    const pScale = ((_a = this.getParent()) == null ? void 0 : _a.ancestorScaleY) || 1;
    return this.scaleY * pScale;
  }
  get ancestorLeft() {
    var _a;
    return this.left + (((_a = this.getParent()) == null ? void 0 : _a.ancestorLeft) || 0);
  }
  get ancestorTop() {
    var _a;
    return this.top + (((_a = this.getParent()) == null ? void 0 : _a.ancestorTop) || 0);
  }
  get ancestorTransform() {
    const parent = this.getParent();
    if (this.isInGroup && (parent == null ? void 0 : parent.classType) === "Group" /* GROUP */) {
      return parent == null ? void 0 : parent.ancestorTransform.multiply(this.transform);
    }
    return this.transform;
  }
  get ancestorGroup() {
    let group = null;
    let parent = this.getParent();
    while (parent != null) {
      if (parent.classType === "Group" /* GROUP */) {
        group = parent;
      }
      parent = parent.getParent();
    }
    return group;
  }
  get skewX() {
    return this._skewX;
  }
  get skewY() {
    return this._skewY;
  }
  get flipX() {
    return this._flipX;
  }
  get flipY() {
    return this._flipY;
  }
  get parent() {
    return this._parent;
  }
  get oKey() {
    return this._oKey;
  }
  get zIndex() {
    return this._zIndex;
  }
  get evented() {
    return this._evented;
  }
  get visible() {
    return this._visible;
  }
  get debounceParentDirty() {
    return this._debounceParentDirty;
  }
  get cursor() {
    return this._cursor;
  }
  get layer() {
    return this._layer;
  }
  set transform(trans) {
    this._transform = trans;
  }
  set zIndex(index) {
    this._zIndex = index;
  }
  set parent(o) {
    this._parent = o;
  }
  set evented(state) {
    this._evented = state;
  }
  set debounceParentDirty(state) {
    this._debounceParentDirty = state;
  }
  set cursor(val) {
    this.setCursor(val);
  }
  set layer(layer) {
    this._layer = layer;
  }
  set top(num) {
    var _a;
    this._topOrigin = num;
    this._top = toPx(num, (_a = this._parent) == null ? void 0 : _a.height);
  }
  set left(num) {
    var _a;
    this._leftOrigin = num;
    this._left = toPx(num, (_a = this._parent) == null ? void 0 : _a.width);
  }
  set width(num) {
    var _a;
    this._widthOrigin = num;
    this._width = toPx(num, (_a = this._parent) == null ? void 0 : _a.width);
  }
  set height(num) {
    var _a;
    this._heightOrigin = num;
    this._height = toPx(num, (_a = this._parent) == null ? void 0 : _a.height);
  }
  set strokeWidth(width) {
    this._strokeWidth = width;
  }
  set angle(angle) {
    this._angle = angle;
  }
  set scaleX(scaleX) {
    this._scaleX = scaleX;
  }
  set scaleY(scaleY) {
    this._scaleY = scaleY;
  }
  set skewX(skewX) {
    this._skewX = skewX;
  }
  set flipY(flipY) {
    this._flipY = flipY;
  }
  set flipX(flipX) {
    this._flipX = flipX;
  }
  set skewY(skewY) {
    this._skewY = skewY;
  }
  get transformerConfig() {
    return this._transformerConfig;
  }
  set transformerConfig(config) {
    this._transformerConfig = config;
  }
  get maxZIndex() {
    return this._zIndex;
  }
  makeDirty(state = true) {
    this._dirty = state;
    if (state) {
      if (this._layer == null) {
        this._dirty = false;
        return;
      }
      this._layer.makeDirtyWithDebounce(state);
    }
    return this;
  }
  makeForceDirty(state = true) {
    this._forceDirty = state;
  }
  makeDirtyNoDebounce(state = true) {
    var _a;
    this._dirty = state;
    if (state) {
      (_a = this._layer) == null ? void 0 : _a.makeDirty(state);
    }
    return this;
  }
  isDirty() {
    return this._dirty;
  }
  translate(x, y) {
    const preTop = this.top;
    if (y !== void 0) {
      this.top = y;
    }
    const preLeft = this.left;
    if (x !== void 0) {
      this.left = x;
    }
    this._setTransForm();
    this.onTransformChange$.emitEvent({
      type: 0 /* translate */,
      value: { top: this._top, left: this._left },
      preValue: { top: preTop, left: preLeft }
    });
    return this;
  }
  resize(width, height) {
    const preWidth = this.width;
    if (width !== void 0) {
      this.width = width;
    }
    const preHeight = this.height;
    if (height !== void 0) {
      this.height = height;
    }
    this._setTransForm();
    this.onTransformChange$.emitEvent({
      type: 1 /* resize */,
      value: { width: this._width, height: this._height },
      preValue: { width: preWidth, height: preHeight }
    });
    return this;
  }
  scale(scaleX, scaleY) {
    const preScaleX = this.scaleX;
    if (scaleX !== void 0) {
      this.scaleX = scaleX;
    }
    const preScaleY = this.scaleY;
    if (scaleY !== void 0) {
      this.scaleY = scaleY;
    }
    this._setTransForm();
    this.onTransformChange$.emitEvent({
      type: 2 /* scale */,
      value: { scaleX: this._scaleX, scaleY: this._scaleY },
      preValue: { scaleX: preScaleX, scaleY: preScaleY }
    });
    return this;
  }
  skew(skewX, skewY) {
    const preSkewX = skewX;
    if (skewX !== void 0) {
      this.skewX = skewX;
    }
    const preSkewY = skewY;
    if (skewY !== void 0) {
      this.skewY = skewY;
    }
    this._setTransForm();
    this.onTransformChange$.emitEvent({
      type: 3 /* skew */,
      value: { skewX: this._skewX, skewY: this._skewY },
      preValue: { skewX: preSkewX, skewY: preSkewY }
    });
    return this;
  }
  flip(flipX, flipY) {
    const preFlipX = flipX;
    if (flipX !== void 0) {
      this.flipX = flipX;
    }
    const preFlipY = flipY;
    if (flipY !== void 0) {
      this.flipY = flipY;
    }
    this._setTransForm();
    this.onTransformChange$.emitEvent({
      type: 4 /* flip */,
      value: { flipX: this._flipX, flipY: this._flipY },
      preValue: { flipX: preFlipX, flipY: preFlipY }
    });
    return this;
  }
  /**
   * this[pKey] = option[pKey]
   * @param option
   */
  transformByState(option) {
    const optionKeys = Object.keys(option);
    const preKeys = {};
    if (optionKeys.length === 0) {
      return;
    }
    optionKeys.forEach((pKey) => {
      if (option[pKey] !== void 0) {
        preKeys[pKey] = this[pKey];
        this[pKey] = option[pKey];
      }
    });
    this._setTransForm();
    this.onTransformChange$.emitEvent({
      type: 5 /* all */,
      value: option,
      preValue: preKeys
    });
    return this;
  }
  isRender(bounds) {
    if (this._forceRender) {
      return false;
    }
    return bounds && !this.isInGroup;
  }
  getParent() {
    return this._parent;
  }
  getState() {
    return {
      left: this.left,
      top: this.top,
      width: this.width,
      height: this.height,
      scaleX: this.scaleX,
      scaleY: this.scaleY,
      angle: this.angle,
      skewX: this.skewX,
      skewY: this.skewY,
      flipX: this.flipX,
      flipY: this.flipY
    };
  }
  hide() {
    this._visible = false;
    this._makeDirtyMix();
  }
  show() {
    this._visible = true;
    this._makeDirtyMix();
  }
  render(ctx, bounds) {
  }
  isHit(coord) {
    const oCoord = this.getInverseCoord(coord);
    if (oCoord.x >= -this.strokeWidth / 2 && oCoord.x <= this.width + this.strokeWidth / 2 && oCoord.y >= -this.strokeWidth / 2 && oCoord.y <= this.height + this.strokeWidth / 2) {
      return true;
    }
    return false;
  }
  triggerPointerMove(evt) {
    var _a, _b;
    if (!((_a = this.onPointerMove$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerMove(evt);
      return false;
    }
    return true;
  }
  triggerPointerDown(evt) {
    var _a, _b;
    if (!((_a = this.onPointerDown$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerDown(evt);
      return false;
    }
    return true;
  }
  triggerPointerUp(evt) {
    var _a, _b;
    if (!((_a = this.onPointerUp$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerUp(evt);
      return false;
    }
    return true;
  }
  triggerDblclick(evt) {
    var _a, _b;
    if (!((_a = this.onDblclick$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerDblclick(evt);
      return false;
    }
    return true;
  }
  triggerTripleClick(evt) {
    var _a, _b;
    if (!((_a = this.onTripleClick$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerTripleClick(evt);
      return false;
    }
    return true;
  }
  triggerMouseWheel(evt) {
    var _a, _b;
    if (!((_a = this.onMouseWheel$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerMouseWheel(evt);
      return false;
    }
    return true;
  }
  triggerPointerOut(evt) {
    var _a, _b;
    if (!((_a = this.onPointerOut$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerOut(evt);
      return false;
    }
    return true;
  }
  triggerPointerLeave(evt) {
    var _a, _b;
    if (!((_a = this.onPointerLeave$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerLeave(evt);
      return false;
    }
    return true;
  }
  triggerPointerOver(evt) {
    var _a;
    if (!this.onPointerOver$.emitEvent(evt)) {
      (_a = this._parent) == null ? void 0 : _a.triggerPointerOver(evt);
      return false;
    }
    return true;
  }
  triggerPointerEnter(evt) {
    var _a, _b;
    if (!((_a = this.onPointerEnter$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerEnter(evt);
      return false;
    }
    return true;
  }
  triggerPointerCancel(evt) {
    var _a, _b;
    if (!((_a = this.onPointerEnter$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerCancel(evt);
      return false;
    }
    return true;
  }
  triggerDragLeave(evt) {
    var _a, _b;
    if (!((_a = this.onDragLeave$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerDragLeave(evt);
      return false;
    }
    return true;
  }
  triggerDragOver(evt) {
    var _a, _b;
    if (!((_a = this.onDragOver$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerDragOver(evt);
      return false;
    }
    return true;
  }
  triggerDragEnter(evt) {
    var _a, _b;
    if (!((_a = this.onDragEnter$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerDragEnter(evt);
      return false;
    }
    return true;
  }
  triggerDrop(evt) {
    var _a, _b;
    if (!((_a = this.onDrop$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation)) {
      (_b = this._parent) == null ? void 0 : _b.triggerDrop(evt);
      return false;
    }
    return true;
  }
  dispose() {
    var _a;
    super.dispose();
    this.onTransformChange$.complete();
    this.onPointerDown$.complete();
    this.onPointerMove$.complete();
    this.onPointerUp$.complete();
    this.onMouseWheel$.complete();
    this.onPointerOut$.complete();
    this.onPointerLeave$.complete();
    this.onPointerOver$.complete();
    this.onPointerEnter$.complete();
    this.onDragLeave$.complete();
    this.onDragOver$.complete();
    this.onDragEnter$.complete();
    this.onDrop$.complete();
    this.onDblclick$.complete();
    this.onTripleClick$.complete();
    this.onIsAddedToParent$.complete();
    (_a = this.parent) == null ? void 0 : _a.removeObject(this);
    this.onDispose$.emitEvent(this);
    this._makeDirtyMix();
    this.onDispose$.complete();
    this._parent = null;
    this._layer = null;
    this.transform = null;
  }
  toJson() {
    const props = {};
    BASE_OBJECT_ARRAY.forEach((key) => {
      if (this[key]) {
        props[key] = this[key];
      }
    });
    return props;
  }
  getScene() {
    let parent = this.parent;
    while (parent) {
      if (parent.classType === "Scene" /* SCENE */) {
        return parent;
      }
      parent = parent.getParent();
    }
    return null;
  }
  resetCursor() {
    var _a;
    (_a = this.getScene()) == null ? void 0 : _a.resetCursor();
  }
  setCursor(val) {
    var _a;
    this._cursor = val;
    (_a = this.getScene()) == null ? void 0 : _a.setCursor(val);
  }
  getEngine() {
    let parent = this.getParent();
    while (parent != null) {
      if (parent.classType === "Engine" /* ENGINE */) {
        return parent;
      }
      parent = parent.getParent();
    }
    return null;
  }
  getObjects() {
    return [];
  }
  getLayerIndex() {
    if (this._layer == null) {
      return 1;
    }
    return this._layer.zIndex;
  }
  applyTransform() {
    var _a;
    (_a = this.getScene()) == null ? void 0 : _a.attachTransformerTo(this);
  }
  removeTransform() {
    var _a;
    (_a = this.getScene()) == null ? void 0 : _a.detachTransformerFrom(this);
  }
  getInverseCoord(coord) {
    return this.ancestorTransform.invert().applyPoint(coord);
  }
  _setTransForm() {
    const composeResult = Transform.create().composeMatrix({
      left: this.left + this.strokeWidth / 2,
      top: this.top + this.strokeWidth / 2,
      scaleX: this.scaleX,
      scaleY: this.scaleY,
      angle: this.angle,
      skewX: this.skewX,
      skewY: this.skewY,
      flipX: this.flipX,
      flipY: this.flipY
    });
    this.transform = composeResult;
    this._makeDirtyMix();
  }
  _makeDirtyMix() {
    if (this.debounceParentDirty) {
      this.makeDirty(true);
    } else {
      this.makeDirtyNoDebounce(true);
    }
  }
};

// ../packages/engine-render/src/layer.ts
var Layer = class extends Disposable {
  constructor(_scene, objects = [], _zIndex = 1, _allowCache = false) {
    super();
    this._scene = _scene;
    this._zIndex = _zIndex;
    this._allowCache = _allowCache;
    __publicField(this, "_objects", []);
    __publicField(this, "_cacheCanvas");
    __publicField(this, "_dirty", true);
    __publicField(this, "_debounceDirtyFunc");
    this.addObjects(objects);
    if (this._allowCache) {
      this._initialCacheCanvas();
    }
  }
  get scene() {
    return this._scene;
  }
  get zIndex() {
    return this._zIndex;
  }
  enableCache() {
    this._allowCache = true;
    this._initialCacheCanvas();
  }
  disableCache() {
    var _a;
    this._allowCache = false;
    (_a = this._cacheCanvas) == null ? void 0 : _a.dispose();
    this._cacheCanvas = null;
  }
  isAllowCache() {
    return this._allowCache;
  }
  /**
   * Get direct visible children in order. (direct means object is not in group), default order is ascending by z-index.
   * @returns {BaseObject[]} objects
   */
  getObjectsByOrder() {
    const objects = [];
    this._objects.sort(sortRules);
    for (const o of this._objects) {
      if (!o.isInGroup && o.visible) {
        objects.push(o);
      }
    }
    return objects;
  }
  /**
   * Get visible and evented objects.
   * @returns {BaseObject[]} objects
   */
  getObjectsByOrderForPick() {
    const objects = [];
    this._objects.sort(sortRules);
    for (const o of this._objects) {
      if (!(o.classType === "Group" /* GROUP */) && o.visible && o.evented) {
        objects.push(o);
      }
    }
    return objects;
  }
  getObjects() {
    return this._objects;
  }
  /**
   * Insert object to this._objects, if object is a group, insert all its children and group itself to _objects[]
   * @param o
   * @returns {Layer} this
   */
  addObject(o) {
    if (o.classType === "Group" /* GROUP */) {
      const objects = o.getObjects();
      for (const object of objects) {
        if (this.scene.getObject(object.oKey)) {
          continue;
        }
        this._objects.push(object);
        this.scene.setObjectBehavior(object);
        this._layerBehavior(object);
      }
    }
    this._objects.push(o);
    this.scene.setObjectBehavior(o);
    this._layerBehavior(o);
    this.makeDirty(true);
    return this;
  }
  removeObject(object) {
    const objects = this.getObjects();
    const objectsLength = objects.length;
    if (object instanceof BaseObject) {
      for (let i = 0; i < objectsLength; i++) {
        const o = objects[i];
        if (o === object) {
          objects.splice(i, 1);
          return;
        }
      }
    } else {
      for (let i = 0; i < objectsLength; i++) {
        const o = objects[i];
        if (o.oKey === object) {
          objects.splice(i, 1);
          return;
        }
      }
    }
  }
  /**
   * Insert objects to this._objects, if object is a group, insert all its children and group itself to _objects[]
   * @param objects
   * @returns {Layer} this
   */
  addObjects(objects) {
    objects.forEach((o) => {
      this.addObject(o);
    });
    return this;
  }
  removeObjects(objects) {
    const allObjects = this.getObjects();
    const allObjectsLength = allObjects.length;
    for (let i = allObjectsLength - 1; i >= 0; i--) {
      let o = allObjects[i];
      const objectsLength = objects.length;
      if (objectsLength === 0) break;
      for (let j = 0; j < objectsLength; j++) {
        const object = objects[j];
        o = object instanceof BaseObject ? o : o.oKey;
        if (o === object) {
          allObjects.splice(i, 1);
          break;
        }
      }
    }
  }
  makeDirty(state = true) {
    this._dirty = state;
    const parent = this.scene.getParent();
    if (parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      parent.makeDirty(true);
    }
    return this;
  }
  makeDirtyWithDebounce(state = true) {
    if (this._debounceDirtyFunc) {
      this._debounceDirtyFunc();
    }
    this._debounceDirtyFunc = requestImmediateMacroTask(() => {
      this.makeDirty(state);
      this._debounceDirtyFunc = null;
    });
  }
  isDirty() {
    return this._dirty;
  }
  render(parentCtx, isMaxLayer = false) {
    var _a;
    const mainCtx = parentCtx || ((_a = this._scene.getEngine()) == null ? void 0 : _a.getCanvas().getContext());
    if (mainCtx) {
      if (this._allowCache && this._cacheCanvas) {
        if (this.isDirty()) {
          const ctx = this._cacheCanvas.getContext();
          this._cacheCanvas.clear();
          ctx.save();
          ctx.setTransform(mainCtx.getTransform());
          this._draw(ctx, isMaxLayer);
          ctx.restore();
        }
        this._applyCache(mainCtx);
      } else {
        mainCtx.save();
        this._draw(mainCtx, isMaxLayer);
        mainCtx.restore();
      }
    }
    this.makeDirty(false);
    return this;
  }
  _layerBehavior(o) {
    this.disposeWithMe(
      toDisposable(
        o.onTransformChange$.subscribeEvent(() => {
          this.makeDirty(true);
        })
      )
    );
    o.layer = this;
  }
  _initialCacheCanvas() {
    this._cacheCanvas = new Canvas();
    const engine = this.scene.getEngine();
    if (engine) {
      this.disposeWithMe(engine.onTransformChange$.subscribeEvent(() => {
        this._resizeCacheCanvas();
      }));
    }
  }
  _draw(mainCtx, isMaxLayer) {
    const viewports = this._scene.getViewports().filter((vp) => vp.shouldIntoRender());
    const objects = this.getObjectsByOrder();
    for (const [_index, vp] of viewports.entries()) {
      vp.render(mainCtx, objects, isMaxLayer);
    }
    objects.forEach((o) => {
      var _a;
      o.makeDirty(false);
      (_a = o.makeForceDirty) == null ? void 0 : _a.call(o, false);
    });
  }
  _applyCache(ctx) {
    if (!ctx || this._cacheCanvas == null) {
      return;
    }
    const width = this._cacheCanvas.getWidth();
    const height = this._cacheCanvas.getHeight();
    if (width !== 0 && height !== 0) {
      ctx.drawImage(this._cacheCanvas.getCanvasEle(), 0, 0, width, height);
    }
  }
  _resizeCacheCanvas() {
    var _a;
    const engine = this._scene.getEngine();
    if (engine) {
      (_a = this._cacheCanvas) == null ? void 0 : _a.setSize(engine.width, engine.height);
    }
    this.makeDirty(true);
  }
  clear() {
    this._objects = [];
  }
  dispose() {
    var _a, _b;
    super.dispose();
    const objects = [...this.getObjects()];
    objects.forEach((o) => {
      o.dispose();
    });
    this.clear();
    (_a = this._debounceDirtyFunc) == null ? void 0 : _a.call(this);
    this._debounceDirtyFunc = null;
    (_b = this._cacheCanvas) == null ? void 0 : _b.dispose();
    this._cacheCanvas = null;
  }
};

// ../packages/engine-render/src/scene.input-manager.ts
var _InputManager = class _InputManager extends Disposable {
  constructor(scene) {
    super();
    __publicField(this, "_scene");
    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */
    __publicField(this, "_alreadyAttached", false);
    // WorkBookObserver
    __publicField(this, "_onInput$");
    __publicField(this, "_currentMouseEnterPicked");
    __publicField(this, "_startingPosition", new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY));
    __publicField(this, "_delayedTimeout", -1);
    __publicField(this, "_delayedTripeTimeout", -1);
    __publicField(this, "_doubleClickOccurred", 0);
    __publicField(this, "_tripleClickState", false);
    __publicField(this, "_currentObject");
    this._scene = scene;
  }
  /**
   * TODO: DR-Univer, fix as unknown as
   */
  dispose() {
    super.dispose();
    this.detachControl();
    this._scene = null;
    this._currentMouseEnterPicked = null;
    this._currentObject = null;
    this._startingPosition = null;
    clearTimeout(this._delayedTimeout);
    clearTimeout(this._delayedTripeTimeout);
    this._onPointerMove = null;
    this._onPointerDown = null;
    this._onPointerUp = null;
    this._onPointerEnter = null;
    this._onPointerLeave = null;
    this._onMouseWheel = null;
    this._onKeyDown = null;
    this._onKeyUp = null;
    this._onDragEnter = null;
    this._onDragLeave = null;
    this._onDragOver = null;
    this._onDrop = null;
  }
  // Handle events such as triggering mouseleave and mouseenter.
  mouseLeaveEnterHandler(evt) {
    var _a;
    const o = this._currentObject || this.capturedObject;
    if (o === null || o === void 0) {
      (_a = this._currentMouseEnterPicked) == null ? void 0 : _a.triggerPointerLeave(evt);
      this._currentMouseEnterPicked = null;
    } else if (o !== this._currentMouseEnterPicked) {
      const previousPicked = this._currentMouseEnterPicked;
      this._currentMouseEnterPicked = o;
      previousPicked == null ? void 0 : previousPicked.triggerPointerLeave(evt);
      o == null ? void 0 : o.triggerPointerEnter(evt);
    }
  }
  // Handle events such as triggering dragleave and dragenter.
  dragLeaveEnterHandler(evt) {
    var _a;
    const o = this._currentObject;
    if (o === null || o === void 0) {
      (_a = this._currentMouseEnterPicked) == null ? void 0 : _a.triggerDragLeave(evt);
      this._currentMouseEnterPicked = null;
    } else if (o !== this._currentMouseEnterPicked) {
      const previousPicked = this._currentMouseEnterPicked;
      this._currentMouseEnterPicked = o;
      previousPicked == null ? void 0 : previousPicked.triggerDragLeave(evt);
      o == null ? void 0 : o.triggerDragEnter(evt);
    }
  }
  _onPointerEnter(evt) {
    if (evt.pointerId === void 0) {
      evt.pointerId = 0;
    }
    this._currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    this.mouseLeaveEnterHandler(evt);
  }
  _onPointerLeave(evt) {
    if (evt.pointerId === void 0) {
      evt.pointerId = 0;
    }
    this._currentObject = null;
    this.mouseLeaveEnterHandler(evt);
  }
  _onPointerMove(evt) {
    var _a, _b;
    if (evt.pointerId === void 0) {
      evt.pointerId = 0;
    }
    const currentObject = this._currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    const isStop = (_a = currentObject || this.capturedObject) == null ? void 0 : _a.triggerPointerMove(evt);
    this.mouseLeaveEnterHandler(evt);
    if (!isStop && this._shouldDispatchEventToScene(currentObject)) {
      this._scene.onPointerMove$.emitEvent(evt);
      (_b = this._scene.getEngine()) == null ? void 0 : _b.setCapture();
    }
  }
  _onPointerDown(evt) {
    if (evt.pointerId === void 0) {
      evt.pointerId = 0;
    }
    const currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    const isStop = currentObject == null ? void 0 : currentObject.triggerPointerDown(evt);
    if (!isStop && this._shouldDispatchEventToScene(currentObject)) {
      this._scene.onPointerDown$.emitEvent(evt);
    }
  }
  _onPointerUp(evt) {
    if (evt.pointerId === void 0) {
      evt.pointerId = 0;
    }
    const currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    const isStop = currentObject == null ? void 0 : currentObject.triggerPointerUp(evt);
    if (!isStop && this._shouldDispatchEventToScene(currentObject)) {
      this._scene.onPointerUp$.emitEvent(evt);
    }
    this._prePointerDoubleOrTripleClick(evt);
  }
  _onPointerCancel(evt) {
    this._scene.onPointerCancel$.emitEvent(evt);
    const currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    currentObject == null ? void 0 : currentObject.triggerPointerCancel(evt);
  }
  _onPointerOut(evt) {
    this._scene.onPointerOut$.emitEvent(evt);
    const currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    currentObject == null ? void 0 : currentObject.triggerPointerOut(evt);
  }
  _onMouseWheel(evt) {
    const currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    const isStop = currentObject == null ? void 0 : currentObject.triggerMouseWheel(evt);
    const viewportMain = this._scene.getMainViewport();
    viewportMain.onMouseWheel$.emitEvent(evt);
    if (!isStop && this._shouldDispatchEventToScene(currentObject)) {
      this._scene.onMouseWheel$.emitEvent(evt);
    }
  }
  _onKeyDown(evt) {
    this._scene.onKeyDown$.emitEvent(evt);
  }
  _onKeyUp(evt) {
    this._scene.onKeyUp$.emitEvent(evt);
  }
  _onDragEnter(evt) {
    var _a;
    this._currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    (_a = this._currentObject) == null ? void 0 : _a.triggerDragOver(evt);
    this.dragLeaveEnterHandler(evt);
  }
  _onDragLeave(evt) {
    this._currentObject = null;
    this.dragLeaveEnterHandler(evt);
  }
  _onDragOver(evt) {
    var _a, _b;
    this._currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    const isStop = (_a = this._currentObject) == null ? void 0 : _a.triggerDragOver(evt);
    this.dragLeaveEnterHandler(evt);
    if (!isStop && this._shouldDispatchEventToScene(this._currentObject)) {
      this._scene.onDragOver$.emitEvent(evt);
      (_b = this._scene.getEngine()) == null ? void 0 : _b.setCapture();
    }
  }
  _onDrop(evt) {
    const currentObject = this._getObjectAtPos(evt.offsetX, evt.offsetY);
    const isStop = currentObject == null ? void 0 : currentObject.triggerDrop(evt);
    if (!isStop && this._shouldDispatchEventToScene(currentObject)) {
      this._scene.onDrop$.emitEvent(evt);
    }
  }
  // eslint-disable-next-line max-lines-per-function
  attachControl(options) {
    var _a, _b, _c, _d, _e, _f;
    const enableDown = (_a = options == null ? void 0 : options.enableDown) != null ? _a : true;
    const enableUp = (_b = options == null ? void 0 : options.enableUp) != null ? _b : true;
    const enableMove = (_c = options == null ? void 0 : options.enableMove) != null ? _c : true;
    const enableWheel = (_d = options == null ? void 0 : options.enableWheel) != null ? _d : true;
    const enableEnter = (_e = options == null ? void 0 : options.enableEnter) != null ? _e : true;
    const enableLeave = (_f = options == null ? void 0 : options.enableLeave) != null ? _f : true;
    const engine = this._scene.getEngine();
    if (!engine) return;
    this._onInput$ = engine.onInputChanged$.subscribeEvent((eventData) => {
      const evt = eventData;
      if (eventData.deviceType === 1 /* Keyboard */) {
        switch (eventData.type) {
          case "keydown":
            this._onKeyDown(evt);
            break;
          case "keyup":
            this._onKeyUp(evt);
            break;
        }
      }
      if (eventData.deviceType === 2 /* Mouse */ || eventData.deviceType === 3 /* Touch */) {
        switch (eventData.type) {
          case "wheel":
          case "DOMMouseScroll":
          case "mousewheel":
            if (enableWheel) {
              this._onMouseWheel(evt);
            }
            break;
          case "pointerout":
            this._onPointerOut(evt);
            break;
          case "pointercancel":
            this._onPointerCancel(evt);
            break;
          case "pointerleave":
            this._onPointerLeave(evt);
            break;
          case "pointermove":
            if (enableMove) {
              this._onPointerMove(evt);
            }
            break;
          case "pointerup":
            if (enableUp && eventData.inputIndex >= 2 /* LeftClick */ && eventData.inputIndex <= 4 /* RightClick */) {
              this._onPointerUp(evt);
            }
            break;
          case "pointerdown":
            if (enableDown && eventData.inputIndex >= 2 /* LeftClick */ && eventData.inputIndex <= 4 /* RightClick */) {
              this._onPointerDown(evt);
            }
            break;
        }
      }
      if (eventData.dataTransfer) {
        switch (eventData.type) {
          case "dragenter":
            if (enableEnter) {
              this._onDragEnter(evt);
            }
            break;
          case "dragover": {
            const validIndex = eventData.inputIndex === 0 /* Horizontal */ || eventData.inputIndex === 1 /* Vertical */ || eventData.inputIndex === 10 /* DeltaHorizontal */ || eventData.inputIndex === 11 /* DeltaVertical */;
            if (enableMove && validIndex) {
              this._onDragOver(evt);
            }
            break;
          }
          case "dragleave":
            if (enableLeave) {
              this._onDragLeave(evt);
            }
            break;
          case "drop":
            this._onDrop(evt);
            break;
        }
      }
    });
    this.disposeWithMe(toDisposable(this._onInput$));
    this._alreadyAttached = true;
  }
  /**
   * Detaches all event handlers
   */
  detachControl() {
    var _a;
    if (!this._alreadyAttached) {
      return;
    }
    const engine = this._scene.getEngine();
    if (!engine) {
      return;
    }
    (_a = this._onInput$) == null ? void 0 : _a.unsubscribe();
    this._alreadyAttached = false;
  }
  /**
   * Get the object under the pointer, if scene.event is disabled, return null.
   * @param offsetX
   * @param offsetY
   */
  _getObjectAtPos(offsetX, offsetY) {
    var _a;
    return (_a = this._scene) == null ? void 0 : _a.pick(Vector2.FromArray([offsetX, offsetY]));
  }
  /**
   *
   * If currentObject is null, return true
   * @param isTrigger
   * @param currentObject
   * @returns
   */
  // The return value of this method is so weird! return type is object and boolean???
  // TODO @lumixraku
  // private _shouldDispatchEventToScene(isTrigger: boolean, currentObject: Nullable<Scene | BaseObject>) {
  // let notObject = false;
  // if (currentObject == null) {
  //     notObject = true;
  // }
  // let isNotInSceneViewer = true;
  // if (currentObject && currentObject.classType === RENDER_CLASS_TYPE.BASE_OBJECT) {
  //     const scene = (currentObject as BaseObject).getScene() as Scene;
  //     if (scene) {
  //         const parent = scene.getParent();
  //         isNotInSceneViewer = parent.classType !== RENDER_CLASS_TYPE.SCENE_VIEWER;
  //     }
  // }
  // return (!this._scene.objectsEvented && isTrigger && isNotInSceneViewer) || notObject;
  // }
  _shouldDispatchEventToScene(currentObject) {
    if (currentObject == null) {
      return true;
    }
    if (this._scene.objectsEvented) {
      return false;
    }
    return !this._isObjectInSceneViewer(currentObject);
  }
  _isObjectInSceneViewer(obj) {
    if (obj && obj.classType === "BaseObject" /* BASE_OBJECT */) {
      const scene = obj.getScene();
      if (scene) {
        const parent = scene.getParent();
        return parent.classType === "SceneViewer" /* SCENE_VIEWER */;
      }
    }
    return false;
  }
  /**
   * @hidden
   * @returns Boolean if delta for pointer exceeds drag movement threshold
   */
  _isPointerSwiping(pointerX, pointerY) {
    return Math.abs(this._startingPosition.x - pointerX) > _InputManager.DragMovementThreshold || Math.abs(this._startingPosition.y - pointerY) > _InputManager.DragMovementThreshold;
  }
  _prePointerDoubleOrTripleClick(evt) {
    var _a, _b, _c, _d;
    const { clientX, clientY } = evt;
    const isMoveThreshold = this._isPointerSwiping(clientX, clientY);
    if (isMoveThreshold) {
      this._resetDoubleClickParam();
    }
    this._delayedTimeout = setTimeout(() => {
      this._resetDoubleClickParam();
    }, _InputManager.DoubleClickDelay);
    this._doubleClickOccurred += 1;
    if (this._tripleClickState) {
      (_b = (_a = this._scene) == null ? void 0 : _a.pick(Vector2.FromArray([evt.offsetX, evt.offsetY]))) == null ? void 0 : _b.triggerTripleClick(evt);
      this._scene.onTripleClick$.emitEvent(evt);
    }
    if (this._doubleClickOccurred === 2) {
      (_d = (_c = this._scene) == null ? void 0 : _c.pick(Vector2.FromArray([evt.offsetX, evt.offsetY]))) == null ? void 0 : _d.triggerDblclick(evt);
      this._scene.onDblclick$.emitEvent(evt);
      this._resetDoubleClickParam();
      this._tripleClickState = true;
      clearTimeout(this._delayedTripeTimeout);
      this._delayedTripeTimeout = setTimeout(() => {
        this._tripleClickState = false;
      }, _InputManager.TripleClickDelay);
    }
    this._startingPosition.x = clientX;
    this._startingPosition.y = clientY;
  }
  _resetDoubleClickParam() {
    this._doubleClickOccurred = 0;
    clearTimeout(this._delayedTimeout);
  }
  get capturedObject() {
    return this._scene._capturedObject;
  }
};
/** The distance in pixel that you have to move to prevent some events */
__publicField(_InputManager, "DragMovementThreshold", 2);
// in pixels
/** Time in milliseconds to wait to raise long press events if button is still pressed */
__publicField(_InputManager, "LongPressDelay", 500);
// in milliseconds
/** Time in milliseconds with two consecutive clicks will be considered as a double or triple click */
__publicField(_InputManager, "DoubleClickDelay", 500);
// in milliseconds
__publicField(_InputManager, "TripleClickDelay", 300);
// in milliseconds
/** If you need to check double click without raising a single click at first click, enable this flag */
__publicField(_InputManager, "ExclusiveDoubleClickMode", false);
var InputManager = _InputManager;

// ../packages/engine-render/src/basics/offset-rotation-axis.ts
function offsetRotationAxis(referenceCoords, angleDegree, vertexCoords, centerCoords) {
  const angleRad = degToRad(angleDegree);
  const newVertexCoords = vertexCoords.clone().rotateByPoint(angleRad, referenceCoords);
  const newCenterCoords = centerCoords.clone().rotateByPoint(angleRad, referenceCoords);
  const finalPoint = newVertexCoords.clone();
  finalPoint.rotateByPoint(degToRad(-angleDegree), newCenterCoords);
  return finalPoint;
}

// ../packages/engine-render/src/basics/scroll-xy.ts
function getCurrentScrollXY(scrollTimer) {
  const scene = scrollTimer.getScene();
  const viewport = scene.findViewportByPosToScene(Vector2.FromArray([scrollTimer.offsetX, scrollTimer.offsetY]));
  const scrollX = 0;
  const scrollY = 0;
  if (!viewport) {
    return {
      scrollX,
      scrollY
    };
  }
  const actualScroll = viewport.transScroll2ViewportScrollValue(viewport.scrollX, viewport.scrollY);
  return {
    scrollX: actualScroll.x,
    scrollY: actualScroll.y
  };
}

// ../packages/engine-render/src/basics/group-transform.ts
function getGroupState(parentLeft, parentTop, objectStates) {
  let groupLeft = Number.MAX_SAFE_INTEGER;
  let groupTop = Number.MAX_SAFE_INTEGER;
  let groupRight = Number.MIN_SAFE_INTEGER;
  let groupBottom = Number.MIN_SAFE_INTEGER;
  objectStates.forEach((o) => {
    const { left = 0, top = 0, width = 0, height = 0 } = o;
    groupLeft = Math.min(groupLeft, left);
    groupTop = Math.min(groupTop, top);
    groupRight = Math.max(groupRight, left + width);
    groupBottom = Math.max(groupBottom, top + height);
  });
  const groupWidth = groupRight - groupLeft;
  const groupHeight = groupBottom - groupTop;
  return {
    left: groupLeft + parentLeft,
    top: groupTop + parentTop,
    width: groupWidth,
    height: groupHeight,
    angle: 0,
    scaleX: 1,
    scaleY: 1
  };
}
function transformObjectOutOfGroup(child, parent, groupOriginWidth, groupOriginHeight) {
  const { left = 0, top = 0, width = 0, height = 0, angle = 0 } = child;
  const { left: groupLeft = 0, top: groupTop = 0, angle: groupAngle = 0 } = parent;
  const groupCenterX = groupLeft + groupOriginWidth / 2;
  const groupCenterY = groupTop + groupOriginHeight / 2;
  const objectX = left + groupLeft;
  const objectY = top + groupTop;
  const objectCenterX = objectX + width / 2;
  const objectCenterY = objectY + height / 2;
  const finalPoint = offsetRotationAxis(new Vector2(groupCenterX, groupCenterY), groupAngle, new Vector2(objectX, objectY), new Vector2(objectCenterX, objectCenterY));
  return {
    left: finalPoint.x,
    top: finalPoint.y,
    angle: groupAngle + angle
  };
}

// ../packages/engine-render/src/group.ts
var Group = class extends BaseObject {
  constructor(key, ...objects) {
    super(key);
    __publicField(this, "_objects", []);
    __publicField(this, "_selfSizeMode", false);
    this.addObjects(...objects);
  }
  get classType() {
    return "Group" /* GROUP */;
  }
  set cursor(val) {
    this.setCursor(val);
  }
  getState() {
    if (this._selfSizeMode) {
      return super.getState();
    }
    return getGroupState(this.left, this.top, this._objects.map((o) => o.getState()));
  }
  get width() {
    if (this._selfSizeMode) {
      return super.width;
    }
    return this.getState().width || 0;
  }
  get height() {
    if (this._selfSizeMode) {
      return super.height;
    }
    return this.getState().height || 0;
  }
  set width(val) {
    if (this._selfSizeMode) {
      super.width = val;
      return;
    }
    const preWidth = this.width;
    const numDelta = val - preWidth;
    this._objects.forEach((o) => {
      o.resize(o.width + numDelta);
    });
  }
  set height(val) {
    if (this._selfSizeMode) {
      super.height = val;
      return;
    }
    const preHeight = this.height;
    const numDelta = val - preHeight;
    this._objects.forEach((o) => {
      o.resize(void 0, o.height + numDelta);
    });
  }
  get maxZIndex() {
    let maxZIndex = 0;
    for (const object of this._objects) {
      maxZIndex = Math.max(maxZIndex, object.zIndex);
    }
    return maxZIndex;
  }
  openSelfSizeMode() {
    this._selfSizeMode = true;
  }
  closeSelfSizeMode() {
    this._selfSizeMode = false;
  }
  reCalculateObjects() {
    if (this._selfSizeMode) {
      return;
    }
    const state = this.getState();
    const { left = 0, top = 0 } = state;
    for (const object of this._objects) {
      object.transformByState({
        left: object.left - left,
        top: object.top - top
      });
    }
    this.transformByState({
      left,
      top
    });
  }
  addObjects(...objects) {
    for (const object of objects) {
      this.addObject(object);
    }
  }
  addObject(o) {
    let object = o;
    if (isString(o)) {
      const scene = this.getScene();
      object = scene == null ? void 0 : scene.getObject(o);
      if (!object) {
        return;
      }
      object.parent = this;
      object.isInGroup = true;
      object.groupKey = this.oKey;
      this._objects.push(object);
    } else {
      o.parent = this;
      o.isInGroup = true;
      o.groupKey = this.oKey;
      this._objects.push(o);
    }
  }
  removeObject(object) {
    const objects = this.getObjects();
    const objectsLength = objects.length;
    if (isString(object)) {
      for (let i = 0; i < objectsLength; i++) {
        const o = objects[i];
        if (o.oKey === object) {
          objects.splice(i, 1);
          this.parent.removeObject(o);
          return;
        }
      }
    } else {
      for (let i = 0; i < objectsLength; i++) {
        const o = objects[i];
        if (o === object) {
          objects.splice(i, 1);
          this.parent.removeObject(o);
          return;
        }
      }
    }
  }
  removeSelfObjectAndTransform(oKey, width, height, isTransform = false) {
    const objects = [...this.getObjects()];
    const objectsLength = objects.length;
    if (width == null) {
      width = this.width;
    }
    if (height == null) {
      height = this.height;
    }
    for (let i = 0; i < objectsLength; i++) {
      const o = objects[i];
      if (o.oKey === oKey) {
        objects.splice(i, 1);
        isTransform && this._transformObject(o, width, height);
        o.parent = this.parent;
        o.groupKey = void 0;
        o.isInGroup = false;
        this._objects = objects;
        return;
      }
    }
  }
  _transformObject(object, groupWidth, groupHeight) {
    const transform = transformObjectOutOfGroup(object.getState(), this.getState(), groupWidth, groupHeight);
    if (object.classType === "Group" /* GROUP */) {
      object.transformByState({
        left: transform.left,
        top: transform.top
      });
    } else {
      object.transformByState(transform);
    }
  }
  getObjectsByOrder() {
    const objects = [];
    this._objects.sort(sortRules);
    for (const o of this._objects) {
      if (o.visible) {
        objects.push(o);
      }
    }
    return objects;
  }
  getObjects() {
    return this._objects;
  }
  render(ctx, bounds) {
    ctx.save();
    const m = this.transform.getMatrix();
    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    const objects = this.getObjectsByOrder();
    for (let i = 0; i < objects.length; i++) {
      const object = objects[i];
      object.render(ctx, bounds);
    }
    ctx.restore();
  }
  // override resize(width?: number | string, height?: number | string) {
  //     return this;
  // }
  // override scale(scaleX?: number, scaleY?: number) {
  //     return this;
  // }
  // override skew(skewX?: number, skewY?: number) {
  //     return this;
  // }
  // override flip(flipX?: boolean, flipY?: boolean) {
  //     return this;
  // }
  // override isHit(coord: Vector2) {
  //     return true;
  // }
  _clear() {
    this._objects = [];
  }
  dispose() {
    const objects = [...this.getObjects()];
    objects.forEach((o) => {
      o.dispose();
    });
    this._clear();
    super.dispose();
  }
};

// ../packages/engine-render/src/scroll-timer.ts
var THRESHOLD_TO_AUTO_MOVE = { t: 0, b: 15, l: 0, r: 60 };
var ScrollTimer = class _ScrollTimer {
  constructor(_scene, _scrollTimerType = 3 /* ALL */, _thresholdAutoMove = THRESHOLD_TO_AUTO_MOVE) {
    this._scene = _scene;
    this._scrollTimerType = _scrollTimerType;
    this._thresholdAutoMove = _thresholdAutoMove;
    __publicField(this, "_requestNewFrameNumber", -1);
    __publicField(this, "_viewport");
    __publicField(this, "_offsetX", 0);
    __publicField(this, "_offsetY", 0);
    __publicField(this, "_moveX", 0);
    __publicField(this, "_moveY", 0);
    __publicField(this, "_scrollX", 0);
    __publicField(this, "_scrollY", 0);
    /**
     * Customize scroll function.
     */
    __publicField(this, "_scrollFunction");
  }
  static create(scene, scrollTimerType = 3 /* ALL */, padding) {
    return new _ScrollTimer(scene, scrollTimerType, padding);
  }
  get offsetX() {
    return this._offsetX;
  }
  get offsetY() {
    return this._offsetY;
  }
  set scrollTimerType(type2) {
    this._scrollTimerType = type2;
  }
  get scrollTimerType() {
    return this._scrollTimerType;
  }
  setActiveViewport(viewport) {
    this._viewport = viewport;
  }
  getActiveViewport() {
    return this._viewport;
  }
  startScroll(offsetX, offsetY, targetViewport) {
    this._offsetX = offsetX;
    this._offsetY = offsetY;
    this._moveX = offsetX;
    this._moveY = offsetY;
    if (targetViewport != null) {
      this._viewport = targetViewport;
    } else {
      this._viewport = this._scene.findViewportByPosToScene(Vector2.FromArray([offsetX, offsetY]));
    }
    this._runRenderLoop();
  }
  //eslint-disable-next-line complexity
  _autoScroll(viewport) {
    const topBounding = (viewport == null ? void 0 : viewport.top) || 0;
    const bottomBounding = topBounding + ((viewport == null ? void 0 : viewport.height) || 0);
    const leftBounding = (viewport == null ? void 0 : viewport.left) || 0;
    const rightBounding = leftBounding + ((viewport == null ? void 0 : viewport.width) || 0);
    const { t: t2 = 0, b = 0, r = 0, l = 0 } = this._thresholdAutoMove;
    let x = 0;
    let y = 0;
    let shouldScroll = false;
    if (this._scrollTimerType & 1 /* X */) {
      if (this._moveX < leftBounding + l) {
        x = this._moveX - leftBounding - l;
        shouldScroll = true;
      }
      if (this._moveX > rightBounding - r) {
        x = this._moveX - rightBounding + r;
        shouldScroll = true;
      }
    }
    if (this._scrollTimerType & 2 /* Y */) {
      if (this._moveY < topBounding + t2) {
        y = this._moveY - topBounding - t2;
        shouldScroll = true;
      }
      if (this._moveY > bottomBounding - b) {
        y = this._moveY - bottomBounding + b;
        shouldScroll = true;
      }
    }
    if (!shouldScroll) {
      return;
    }
    const scrolled = viewport == null ? void 0 : viewport.scrollByViewportDeltaVal({
      viewportScrollX: x,
      viewportScrollY: y
    });
    const viewportScrollVal = viewport == null ? void 0 : viewport.transScroll2ViewportScrollValue(x, y);
    this._scrollX = (viewportScrollVal == null ? void 0 : viewportScrollVal.x) || 0;
    this._scrollY = (viewportScrollVal == null ? void 0 : viewportScrollVal.y) || 0;
  }
  scrolling(offsetX, offsetY, scrollFunction) {
    this._moveX = offsetX;
    this._moveY = offsetY;
    this._scrollFunction = scrollFunction;
  }
  stopScroll() {
    cancelRequestFrame(this._requestNewFrameNumber);
  }
  dispose() {
    this.stopScroll();
    delete this._scrollFunction;
  }
  getScene() {
    return this._scene;
  }
  _runRenderLoop() {
    this._autoScroll(this._viewport);
    if (this._scrollFunction) {
      this._scrollFunction(this._scrollX, this._scrollY);
    }
    this._requestNewFrameNumber = requestNewFrame(this._runRenderLoop.bind(this));
  }
};

// ../packages/engine-render/src/shape/shape.ts
var BASE_OBJECT_ARRAY_Set = new Set(BASE_OBJECT_ARRAY);
var SHAPE_OBJECT_ARRAY = [
  "hoverCursor",
  "moveCursor",
  "fillRule",
  "globalCompositeOperation",
  "paintFirst",
  "stroke",
  "strokeScaleEnabled",
  "fill",
  "fillAfterStrokeEnabled",
  "hitStrokeWidth",
  "strokeLineJoin",
  "strokeLineCap",
  "shadowColor",
  "shadowBlur",
  "shadowOffset",
  "shadowOffsetX",
  "shadowOffsetY",
  "shadowOpacity",
  "shadowEnabled",
  "shadowForStrokeEnabled",
  "strokeDashArray",
  "strokeDashOffset",
  "strokeMiterLimit"
];
var Shape = class extends BaseObject {
  constructor(key, props) {
    super(key);
    __publicField(this, "_hoverCursor");
    __publicField(this, "_moveCursor", null);
    __publicField(this, "_fillRule", "nonzero");
    __publicField(this, "_globalCompositeOperation", "source-over");
    __publicField(this, "_paintFirst", "fill");
    __publicField(this, "_stroke");
    __publicField(this, "_strokeScaleEnabled", false);
    // strokeUniform: boolean;
    __publicField(this, "_fill");
    __publicField(this, "_fillAfterStrokeEnabled", false);
    __publicField(this, "_hitStrokeWidth", 0);
    __publicField(this, "_strokeLineJoin", "round");
    __publicField(this, "_strokeLineCap", "round");
    __publicField(this, "_shadowColor");
    __publicField(this, "_shadowBlur", 0);
    __publicField(this, "_shadowOffset");
    __publicField(this, "_shadowOffsetX", 0);
    __publicField(this, "_shadowOffsetY", 0);
    __publicField(this, "_shadowOpacity", 0);
    __publicField(this, "_shadowEnabled", false);
    __publicField(this, "_shadowForStrokeEnabled", false);
    __publicField(this, "_strokeDashArray");
    __publicField(this, "_strokeDashOffset", 0);
    __publicField(this, "_strokeMiterLimit", 0);
    __publicField(this, "_type", "rect" /* RECT */);
    __publicField(this, "objectType", 2 /* SHAPE */);
    this._initialProps(props);
  }
  get hoverCursor() {
    return this._hoverCursor;
  }
  get moveCursor() {
    return this._moveCursor;
  }
  get fillRule() {
    return this._fillRule;
  }
  get globalCompositeOperation() {
    return this._globalCompositeOperation;
  }
  get paintFirst() {
    return this._paintFirst;
  }
  get stroke() {
    return this._stroke;
  }
  get strokeScaleEnabled() {
    return this._strokeScaleEnabled;
  }
  get fill() {
    return this._fill;
  }
  get fillAfterStrokeEnabled() {
    return this._fillAfterStrokeEnabled;
  }
  get hitStrokeWidth() {
    return this._hitStrokeWidth;
  }
  get strokeLineJoin() {
    return this._strokeLineJoin;
  }
  get strokeLineCap() {
    return this._strokeLineCap;
  }
  get shadowColor() {
    return this._shadowColor;
  }
  get shadowBlur() {
    return this._shadowBlur;
  }
  get shadowOffset() {
    return this._shadowOffset;
  }
  get shadowOffsetX() {
    return this._shadowOffsetX;
  }
  get shadowOffsetY() {
    return this._shadowOffsetY;
  }
  get shadowOpacity() {
    return this._shadowOpacity;
  }
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  get shadowForStrokeEnabled() {
    return this._shadowForStrokeEnabled;
  }
  get strokeDashArray() {
    return this._strokeDashArray;
  }
  get strokeDashOffset() {
    return this._strokeDashOffset;
  }
  get strokeMiterLimit() {
    return this._strokeMiterLimit;
  }
  static drawWith(ctx, props) {
  }
  static _renderPaintInOrder(ctx, props) {
    if (props.paintFirst === "stroke") {
      this._renderStroke(ctx, props);
      this._renderFill(ctx, props);
    } else {
      this._renderFill(ctx, props);
      this._renderStroke(ctx, props);
    }
  }
  /**
   * @private
   * @param {UniverRenderingContext} ctx SheetContext to render on
   */
  static _renderFill(ctx, props) {
    if (!props.fill) {
      return;
    }
    ctx.save();
    this._setFillStyles(ctx, props);
    if (props.fillRule === "evenodd") {
      ctx.fill("evenodd");
    } else {
      ctx.fill();
    }
    ctx.restore();
  }
  /**
   * @private
   * @param {UniverRenderingContext} ctx SheetContext to render on
   */
  static _renderStroke(ctx, props) {
    const { stroke, strokeWidth, strokeScaleEnabled } = props;
    if (!stroke || strokeWidth === 0) {
      return;
    }
    ctx.save();
    this._setStrokeStyles(ctx, props);
    ctx.stroke();
    ctx.restore();
  }
  // private static _getObjectScaling() {
  //     return { scaleX: 1, scaleY: 1 };
  // }
  static _removeShadow(ctx) {
  }
  static _setFillStyles(ctx, props) {
    ctx.fillStyle = props.fill;
  }
  static _setStrokeStyles(ctx, props) {
    const { strokeWidth, strokeLineCap, strokeDashOffset, strokeLineJoin, strokeMiterLimit, stroke } = props;
    ctx.lineWidth = strokeWidth;
    ctx.lineCap = strokeLineCap;
    ctx.lineDashOffset = strokeDashOffset;
    ctx.lineJoin = strokeLineJoin;
    ctx.miterLimit = strokeMiterLimit;
    ctx.strokeStyle = stroke;
  }
  render(mainCtx, bounds) {
    if (!this.visible) {
      this.makeDirty(false);
      return this;
    }
    if (this.isRender(bounds)) {
      const { top, left, bottom, right } = bounds.viewBound;
      if (this.width + this.strokeWidth + this.left < left || right < this.left || this.height + this.strokeWidth + this.top < top || bottom < this.top) {
        return this;
      }
    }
    const m = this.transform.getMatrix();
    mainCtx.save();
    mainCtx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    this._draw(mainCtx, bounds);
    mainCtx.restore();
    this.makeDirty(false);
    return this;
  }
  /**
   * if BASE_OBJECT_ARRAY_Set.has(key) not exist, then this[_key] = props[key],
   * @param props
   */
  setProps(props) {
    if (!props) {
      return this;
    }
    const themeKeys = Object.keys(props);
    if (themeKeys.length === 0) {
      return this;
    }
    themeKeys.forEach((key) => {
      if (props[key] === void 0) {
        return true;
      }
      if (!BASE_OBJECT_ARRAY_Set.has(key)) {
        this[`_${key}`] = props[key];
      }
    });
    this.makeDirty(true);
    return this;
  }
  toJson() {
    const props = {};
    SHAPE_OBJECT_ARRAY.forEach((key) => {
      if (this[key]) {
        props[key] = this[key];
      }
    });
    return {
      ...super.toJson(),
      ...props
    };
  }
  _draw(ctx, bounds) {
  }
  _initialProps(props) {
    if (!props) {
      return;
    }
    const themeKeys = Object.keys(props);
    if (themeKeys.length === 0) {
      return;
    }
    const transformState = {};
    let hasTransformState = false;
    const hasRotateEnabled = (props == null ? void 0 : props.rotateEnabled) !== void 0;
    const hasResizeEnabled = (props == null ? void 0 : props.resizeEnabled) !== void 0;
    const hasBorderEnabled = (props == null ? void 0 : props.borderEnabled) !== void 0;
    if (hasRotateEnabled || hasResizeEnabled || hasBorderEnabled) {
      const transformerConfig = this.transformerConfig || {};
      if (hasRotateEnabled) {
        transformerConfig.rotateEnabled = props == null ? void 0 : props.rotateEnabled;
      }
      if (hasResizeEnabled) {
        transformerConfig.resizeEnabled = props == null ? void 0 : props.resizeEnabled;
      }
      if (hasBorderEnabled) {
        transformerConfig.borderEnabled = props == null ? void 0 : props.borderEnabled;
      }
      this.transformerConfig = { ...transformerConfig };
    }
    themeKeys.forEach((key) => {
      if (props[key] === void 0) {
        return true;
      }
      if (BASE_OBJECT_ARRAY_Set.has(key)) {
        transformState[key] = props[key];
        hasTransformState = true;
      } else {
        this[`_${key}`] = props[key];
      }
    });
    if (hasTransformState) {
      this.transformByState(transformState);
    }
    this.makeDirty(true);
  }
};

// ../packages/engine-render/src/shape/rect.ts
var RECT_OBJECT_ARRAY = ["radius"];
var Rect = class _Rect extends Shape {
  constructor(key, props) {
    super(key, props);
    __publicField(this, "objectType", 4 /* RECT */);
    __publicField(this, "_radius", 0);
    __publicField(this, "_opacity", 1);
    /**
     * For rendering, in many case object size is bigger than visual size for better user interaction.
     */
    __publicField(this, "_visualHeight");
    __publicField(this, "_visualWidth");
    if (props == null ? void 0 : props.radius) {
      this._radius = props.radius;
    }
    if (props == null ? void 0 : props.visualHeight) {
      this._visualHeight = props.visualHeight;
    }
    if (props == null ? void 0 : props.visualWidth) {
      this._visualWidth = props.visualWidth;
    }
  }
  get visualHeight() {
    return this._visualHeight;
  }
  get visualWidth() {
    return this._visualWidth;
  }
  get radius() {
    return this._radius;
  }
  get opacity() {
    return this._opacity;
  }
  setObjectType(type2) {
    this.objectType = type2;
  }
  setOpacity(opacity) {
    this._opacity = opacity;
  }
  static drawWith(ctx, props) {
    let { radius, width, height } = props;
    radius = radius != null ? radius : 0;
    width = width != null ? width : 0;
    height = height != null ? height : 0;
    ctx.save();
    ctx.beginPath();
    if (props.strokeDashArray) {
      ctx.setLineDash(props.strokeDashArray);
    }
    if (props.visualHeight) {
      ctx.translate(0, (height - (props.visualHeight || 0)) / 2);
      height = props.visualHeight;
    }
    if (props.visualWidth) {
      ctx.translate((width - (props.visualWidth || 0)) / 2, 0);
      width = props.visualWidth;
    }
    if (!radius) {
      ctx.rect(0, 0, width, height);
    } else {
      let topLeft = 0;
      let topRight = 0;
      let bottomLeft = 0;
      let bottomRight = 0;
      topLeft = topRight = bottomLeft = bottomRight = Math.min(radius, width / 2, height / 2);
      ctx.moveTo(topLeft, 0);
      ctx.lineTo(width - topRight, 0);
      ctx.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
      ctx.lineTo(width, height - bottomRight);
      ctx.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
      ctx.lineTo(bottomLeft, height);
      ctx.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
      ctx.lineTo(0, topLeft);
      ctx.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
    }
    ctx.closePath();
    this._renderPaintInOrder(ctx, props);
    ctx.restore();
  }
  toJson() {
    const props = {};
    RECT_OBJECT_ARRAY.forEach((key) => {
      if (this[key]) {
        props[key] = this[key];
      }
    });
    return {
      ...super.toJson(),
      ...props
    };
  }
  _draw(ctx) {
    _Rect.drawWith(ctx, this);
  }
};

// ../packages/engine-render/src/shape/regular-polygon.ts
var REGULAR_POLYGON_OBJECT_ARRAY = ["pointsGroup"];
var RegularPolygon = class _RegularPolygon extends Shape {
  constructor(key, props) {
    super(key, props);
    __publicField(this, "_pointsGroup");
    this._pointsGroup = (props == null ? void 0 : props.pointsGroup) || [[]];
    this._setFixBoundingBox();
    this.onTransformChange$.subscribeEvent((changeState) => {
      const { type: type2, value, preValue } = changeState;
      if (type2 === 1 /* resize */ || type2 === 5 /* all */) {
        this.resizePolygon(preValue);
      }
    });
  }
  get pointsGroup() {
    return this._pointsGroup;
  }
  static drawWith(ctx, props) {
    let { pointsGroup } = props;
    pointsGroup = pointsGroup != null ? pointsGroup : [[]];
    if (props.strokeDashArray) {
      ctx.setLineDash(props.strokeDashArray);
    }
    ctx.beginPath();
    for (const points of pointsGroup) {
      ctx.moveTo(points[0].x, points[0].y);
      for (let n = 1; n < points.length; n++) {
        const point = points[n];
        ctx.lineTo(point.x, point.y);
      }
    }
    ctx.closePath();
    this._renderPaintInOrder(ctx, props);
  }
  isHit(coord) {
    const oCoord = this.getInverseCoord(coord);
    if (oCoord.x >= -this.strokeWidth / 2 && oCoord.x <= this.width + this.strokeWidth / 2 && oCoord.y >= -this.strokeWidth / 2 && oCoord.y <= this.height + this.strokeWidth / 2 && this._contains(oCoord)) {
      return true;
    }
    return false;
  }
  // 判断点是否在多边形内（包括处理洞）
  _contains(point) {
    let inside = false;
    for (const vertices of this._pointsGroup) {
      let count = 0;
      const n = vertices.length;
      for (let i = 0; i < n; i++) {
        const v1 = vertices[i];
        const v2 = vertices[(i + 1) % n];
        if (this._isOnLine(point, v1, v2)) {
          return true;
        }
        if (v1.y > point.y !== v2.y > point.y) {
          const xCross = v1.x + (point.y - v1.y) * (v2.x - v1.x) / (v2.y - v1.y);
          if (point.x < xCross) {
            count++;
          }
        }
      }
      if (count % 2 !== 0) {
        inside = !inside;
      }
    }
    return inside;
  }
  // 辅助函数：判断点是否在给定的线段上
  _isOnLine(point, v1, v2) {
    const area = (v1.x - point.x) * (v2.y - point.y) - (v2.x - point.x) * (v1.y - point.y);
    if (area !== 0) return false;
    return point.x >= Math.min(v1.x, v2.x) && point.x <= Math.max(v1.x, v2.x) && point.y >= Math.min(v1.y, v2.y) && point.y <= Math.max(v1.y, v2.y);
  }
  updatePointGroup(pointGroup) {
    this._pointsGroup = pointGroup;
    this._setFixBoundingBox();
  }
  resizePolygon(preValue) {
    const { left, top, width, height } = this._getSelfRect();
    const { width: preWidth, height: preHeight } = preValue;
    let fixX;
    let fixY;
    if (!preWidth) {
      fixX = 0;
    } else {
      fixX = this.width - preWidth;
    }
    if (!preHeight) {
      fixY = 0;
    } else {
      fixY = this.height - preHeight;
    }
    const increaseScaleX = fixX / width;
    const increaseScaleY = fixY / height;
    this.scaleX += increaseScaleX;
    this.scaleY += increaseScaleY;
    this.left = this.left - left * increaseScaleX;
    this.top = this.top - top * increaseScaleY;
    this._setTransForm();
  }
  toJson() {
    const props = {};
    REGULAR_POLYGON_OBJECT_ARRAY.forEach((key) => {
      if (this[key]) {
        props[key] = this[key];
      }
    });
    return {
      ...super.toJson(),
      ...props
    };
  }
  getState() {
    const { left, top, width, height } = this.getRect();
    return {
      left,
      top,
      width,
      height,
      scaleX: this.scaleX,
      scaleY: this.scaleY,
      angle: this.angle,
      skewX: this.skewX,
      skewY: this.skewY,
      flipX: this.flipX,
      flipY: this.flipY
    };
  }
  getRect() {
    const { left, top, width, height } = this._getSelfRect();
    return {
      left: left * this.scaleX + this.left,
      top: top * this.scaleY + this.top,
      width: width * this.scaleX,
      height: height * this.scaleY
    };
  }
  _draw(ctx) {
    _RegularPolygon.drawWith(ctx, this);
  }
  _setFixBoundingBox() {
    const { width, height, left, top } = this._getSelfRect();
    this.left = this.left + left;
    this.top = this.top + top;
    this.width = width;
    this.height = height;
    const pointsGroup = this.pointsGroup;
    for (const points of pointsGroup) {
      for (const point of points) {
        point.x -= left;
        point.y -= top;
      }
    }
    this._setTransForm();
  }
  _getSelfRect() {
    const pointsGroup = this.pointsGroup;
    let minX = pointsGroup[0][0].x;
    let maxX = pointsGroup[0][0].x;
    let minY = pointsGroup[0][0].y;
    let maxY = pointsGroup[0][0].y;
    for (const points of pointsGroup) {
      for (const point of points) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
    }
    return {
      left: minX,
      top: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
};

// ../packages/engine-render/src/scene.transformer.ts
var TransformerManagerTypeArray = [
  "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */,
  "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */,
  "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */,
  "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */,
  "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */,
  "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */,
  "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */,
  "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */
];
var DEFAULT_TRANSFORMER_LAYER_INDEX = 2;
var MINI_WIDTH_LIMIT = 20;
var MINI_HEIGHT_LIMIT = 20;
var DEFAULT_CONTROL_PLUS_INDEX = 5e3;
var SINGLE_ACTIVE_OBJECT_TYPE_MAP = /* @__PURE__ */ new Set([
  6 /* CHART */
]);
var Transformer = class extends Disposable {
  constructor(_scene, config) {
    super();
    this._scene = _scene;
    __publicField(this, "isCropper", false);
    __publicField(this, "hoverEnabled", false);
    __publicField(this, "hoverEnterFunc");
    __publicField(this, "hoverLeaveFunc");
    __publicField(this, "resizeEnabled", true);
    __publicField(this, "rotateEnabled", true);
    __publicField(this, "rotationSnaps", []);
    __publicField(this, "rotationSnapTolerance", 5);
    __publicField(this, "rotateAnchorOffset", 50);
    __publicField(this, "rotateSize", 10);
    __publicField(this, "rotateCornerRadius", 10);
    __publicField(this, "borderEnabled", true);
    __publicField(this, "borderStroke", "rgb(97, 97, 97)");
    __publicField(this, "borderStrokeWidth", 1);
    __publicField(this, "borderDash", []);
    __publicField(this, "borderSpacing", 0);
    __publicField(this, "anchorFill", "rgb(255, 255, 255)");
    __publicField(this, "anchorStroke", "rgb(185, 185, 185)");
    __publicField(this, "anchorStrokeWidth", 1);
    __publicField(this, "anchorSize", 10);
    __publicField(this, "anchorCornerRadius", 10);
    __publicField(this, "keepRatio", true);
    __publicField(this, "centeredScaling", false);
    __publicField(this, "zeroLeft", 0);
    __publicField(this, "zeroTop", 0);
    /**
     * leftTop centerTop rightTop
     * leftMiddle rightMiddle
     * leftBottom centerBottom rightBottom
     */
    __publicField(this, "enabledAnchors", [1, 1, 1, 1, 1, 1, 1, 1]);
    __publicField(this, "flipEnabled", false);
    __publicField(this, "ignoreStroke", false);
    __publicField(this, "boundBoxFunc");
    __publicField(this, "useSingleNodeRotation", false);
    __publicField(this, "shouldOverdrawWholeArea", false);
    __publicField(this, "_changeStart$", new Subject());
    /**
     * actually pointer down on a object,
     * trigger when pick an object even object not change.
     */
    __publicField(this, "changeStart$", this._changeStart$.asObservable());
    __publicField(this, "_changing$", new Subject());
    __publicField(this, "changing$", this._changing$.asObservable());
    __publicField(this, "_changeEnd$", new Subject());
    __publicField(this, "changeEnd$", this._changeEnd$.asObservable());
    __publicField(this, "_clearControl$", new Subject());
    __publicField(this, "clearControl$", this._clearControl$.asObservable());
    __publicField(this, "_createControl$", new Subject());
    __publicField(this, "createControl$", this._createControl$.asObservable());
    __publicField(this, "_startOffsetX", -1);
    __publicField(this, "_startOffsetY", -1);
    __publicField(this, "_startStateMap", /* @__PURE__ */ new Map());
    __publicField(this, "_viewportScrollX", -1);
    __publicField(this, "_viewportScrollY", -1);
    __publicField(this, "_topScenePointerMoveSub");
    __publicField(this, "_topScenePointerUpSub");
    __publicField(this, "_cancelFocusSubscription");
    __publicField(this, "_transformerControlMap", /* @__PURE__ */ new Map());
    __publicField(this, "_selectedObjectMap", /* @__PURE__ */ new Map());
    __publicField(this, "_subscriptionObjectMap", /* @__PURE__ */ new Map());
    __publicField(this, "_copperControl");
    __publicField(this, "_copperSelectedObject");
    __publicField(this, "_moveBufferSkip", false);
    __publicField(this, "_debounceClearFunc");
    this._initialProps(config);
  }
  updateZeroPoint(left, top) {
    this.zeroLeft = left;
    this.zeroTop = top;
  }
  changeNotification() {
    this._changing$.next({
      objects: this._selectedObjectMap,
      type: 0 /* MOVE_START */
    });
    return this;
  }
  getSelectedObjectMap() {
    return this._selectedObjectMap;
  }
  resetProps(config) {
    this._initialProps(config);
  }
  getScene() {
    return this._scene;
  }
  clearControls(changeSelf = false) {
    this._clearControls(changeSelf);
  }
  updateControl() {
    this._updateControl();
  }
  debounceRefreshControls() {
    if (this._debounceClearFunc) {
      this._debounceClearFunc();
    }
    this._debounceClearFunc = requestImmediateMacroTask(() => {
      this.refreshControls();
      this._debounceClearFunc = null;
    });
  }
  clearSelectedObjects() {
    var _a;
    this._selectedObjectMap.clear();
    (_a = this._cancelFocusSubscription) == null ? void 0 : _a.unsubscribe();
    this._cancelFocusSubscription = null;
    this._clearControls(true);
  }
  refreshControls() {
    this._clearControlMap();
    this._selectedObjectMap.forEach((object) => {
      this._createControl(object);
    });
    return this;
  }
  createControlForCopper(applyObject) {
    this._createControl(applyObject, false);
  }
  clearCopperControl() {
    var _a;
    (_a = this._copperControl) == null ? void 0 : _a.dispose();
    this._copperControl = null;
  }
  setSelectedControl(applyObject) {
    applyObject = this._findGroupObject(applyObject);
    this._selectedObjectMap.set(applyObject.oKey, applyObject);
    this._createControl(applyObject);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _getConfig(applyObject) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C;
    const objectTransformerConfig = applyObject.transformerConfig;
    let {
      isCropper,
      hoverEnabled,
      hoverEnterFunc,
      hoverLeaveFunc,
      resizeEnabled,
      rotateEnabled,
      rotationSnaps,
      rotationSnapTolerance,
      rotateAnchorOffset,
      rotateSize,
      rotateCornerRadius,
      borderEnabled,
      borderStroke,
      borderStrokeWidth,
      borderDash,
      borderSpacing,
      anchorFill,
      anchorStroke,
      anchorStrokeWidth,
      anchorSize,
      anchorCornerRadius,
      keepRatio,
      centeredScaling,
      enabledAnchors,
      flipEnabled,
      ignoreStroke,
      boundBoxFunc,
      useSingleNodeRotation,
      shouldOverdrawWholeArea
    } = this;
    if (objectTransformerConfig != null) {
      isCropper = (_a = objectTransformerConfig.isCropper) != null ? _a : isCropper;
      hoverEnabled = (_b = objectTransformerConfig.hoverEnabled) != null ? _b : hoverEnabled;
      hoverEnterFunc = (_c = objectTransformerConfig.hoverEnterFunc) != null ? _c : hoverEnterFunc;
      hoverLeaveFunc = (_d = objectTransformerConfig.hoverLeaveFunc) != null ? _d : hoverLeaveFunc;
      resizeEnabled = (_e = objectTransformerConfig.resizeEnabled) != null ? _e : resizeEnabled;
      rotateEnabled = (_f = objectTransformerConfig.rotateEnabled) != null ? _f : rotateEnabled;
      rotationSnaps = (_g = objectTransformerConfig.rotationSnaps) != null ? _g : rotationSnaps;
      rotationSnapTolerance = (_h = objectTransformerConfig.rotationSnapTolerance) != null ? _h : rotationSnapTolerance;
      rotateAnchorOffset = (_i = objectTransformerConfig.rotateAnchorOffset) != null ? _i : rotateAnchorOffset;
      rotateSize = (_j = objectTransformerConfig.rotateSize) != null ? _j : rotateSize;
      rotateCornerRadius = (_k = objectTransformerConfig.rotateCornerRadius) != null ? _k : rotateCornerRadius;
      borderEnabled = (_l = objectTransformerConfig.borderEnabled) != null ? _l : borderEnabled;
      borderStroke = (_m = objectTransformerConfig.borderStroke) != null ? _m : borderStroke;
      borderStrokeWidth = (_n = objectTransformerConfig.borderStrokeWidth) != null ? _n : borderStrokeWidth;
      borderDash = (_o = objectTransformerConfig.borderDash) != null ? _o : borderDash;
      borderSpacing = (_p = objectTransformerConfig.borderSpacing) != null ? _p : borderSpacing;
      anchorFill = (_q = objectTransformerConfig.anchorFill) != null ? _q : anchorFill;
      anchorStroke = (_r = objectTransformerConfig.anchorStroke) != null ? _r : anchorStroke;
      anchorStrokeWidth = (_s = objectTransformerConfig.anchorStrokeWidth) != null ? _s : anchorStrokeWidth;
      anchorSize = (_t = objectTransformerConfig.anchorSize) != null ? _t : anchorSize;
      anchorCornerRadius = (_u = objectTransformerConfig.anchorCornerRadius) != null ? _u : anchorCornerRadius;
      keepRatio = (_v = objectTransformerConfig.keepRatio) != null ? _v : keepRatio;
      centeredScaling = (_w = objectTransformerConfig.centeredScaling) != null ? _w : centeredScaling;
      enabledAnchors = (_x = objectTransformerConfig.enabledAnchors) != null ? _x : enabledAnchors;
      flipEnabled = (_y = objectTransformerConfig.flipEnabled) != null ? _y : flipEnabled;
      ignoreStroke = (_z = objectTransformerConfig.ignoreStroke) != null ? _z : ignoreStroke;
      boundBoxFunc = (_A = objectTransformerConfig.boundBoxFunc) != null ? _A : boundBoxFunc;
      useSingleNodeRotation = (_B = objectTransformerConfig.useSingleNodeRotation) != null ? _B : useSingleNodeRotation;
      shouldOverdrawWholeArea = (_C = objectTransformerConfig.shouldOverdrawWholeArea) != null ? _C : shouldOverdrawWholeArea;
    }
    return {
      isCropper,
      hoverEnabled,
      hoverEnterFunc,
      hoverLeaveFunc,
      resizeEnabled,
      rotateEnabled,
      rotationSnaps,
      rotationSnapTolerance,
      rotateAnchorOffset,
      rotateSize,
      rotateCornerRadius,
      borderEnabled,
      borderStroke,
      borderStrokeWidth,
      borderDash,
      borderSpacing,
      anchorFill,
      anchorStroke,
      anchorStrokeWidth,
      anchorSize,
      anchorCornerRadius,
      keepRatio,
      centeredScaling,
      enabledAnchors,
      flipEnabled,
      ignoreStroke,
      boundBoxFunc,
      useSingleNodeRotation,
      shouldOverdrawWholeArea
    };
  }
  // eslint-disable-next-line max-lines-per-function
  attachTo(applyObject) {
    if (this.hoverEnabled) {
      this.hoverEnterFunc && applyObject.onPointerEnter$.subscribeEvent(this.hoverEnterFunc);
      this.hoverLeaveFunc && applyObject.onPointerLeave$.subscribeEvent(this.hoverLeaveFunc);
    }
    const observer = applyObject.onPointerDown$.subscribeEvent((evt, state) => {
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
      this._startOffsetX = evtOffsetX;
      this._startOffsetY = evtOffsetY;
      const { isCropper } = this._getConfig(applyObject);
      const scene = this._getTopScene();
      if (!scene) {
        return;
      }
      this._addCancelObserver(scene);
      scene.disableObjectsEvent();
      const scrollTimer = ScrollTimer.create(scene);
      scrollTimer.startScroll(evtOffsetX, evtOffsetY);
      const { scrollX, scrollY } = getCurrentScrollXY(scrollTimer);
      this._viewportScrollX = scrollX;
      this._viewportScrollY = scrollY;
      if (!isCropper) {
        this._updateActiveObjectList(applyObject, evt);
        this._changeStart$.next({
          target: applyObject,
          objects: this._selectedObjectMap,
          type: 0 /* MOVE_START */
        });
      } else {
        this._copperSelectedObject = applyObject;
        this._changeStart$.next({
          target: applyObject,
          objects: /* @__PURE__ */ new Map([[applyObject.oKey, applyObject]]),
          type: 0 /* MOVE_START */
        });
      }
      this._moveBufferSkip = false;
      const scenePointerMoveSub = scene.onPointerMove$.subscribeEvent((moveEvt) => {
        const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
        this._moving(moveOffsetX, moveOffsetY, scrollTimer, isCropper);
        !isCropper && this._clearControlMap();
        scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
          this._moving(moveOffsetX, moveOffsetY, scrollTimer, isCropper);
        });
      });
      const scenePointerUpSub = scene.onPointerUp$.subscribeEvent((event) => {
        scenePointerMoveSub == null ? void 0 : scenePointerMoveSub.unsubscribe();
        scenePointerUpSub == null ? void 0 : scenePointerUpSub.unsubscribe();
        scene.enableObjectsEvent();
        !isCropper && this.refreshControls();
        scrollTimer.dispose();
        const { offsetX, offsetY } = event;
        if (!isCropper) {
          this._changeEnd$.next({
            objects: this._selectedObjectMap,
            type: 2 /* MOVE_END */,
            offsetX,
            offsetY
          });
        } else {
          this._changeEnd$.next({
            objects: /* @__PURE__ */ new Map([[applyObject.oKey, applyObject]]),
            type: 2 /* MOVE_END */,
            offsetX,
            offsetY
          });
        }
      });
      state.stopPropagation();
    });
    this.disposeWithMe(toDisposable(observer));
    this._subscriptionObjectMap.set(applyObject.oKey, observer);
    return applyObject;
  }
  detachFrom(applyObject) {
    const subscription = this._subscriptionObjectMap.get(applyObject.oKey);
    if (subscription) {
      subscription.unsubscribe();
      this._subscriptionObjectMap.delete(applyObject.oKey);
    }
    return applyObject;
  }
  dispose() {
    var _a, _b, _c;
    super.dispose();
    (_a = this._topScenePointerMoveSub) == null ? void 0 : _a.unsubscribe();
    (_b = this._topScenePointerUpSub) == null ? void 0 : _b.unsubscribe();
    (_c = this._cancelFocusSubscription) == null ? void 0 : _c.unsubscribe();
    this._cancelFocusSubscription = null;
    this._topScenePointerMoveSub = null;
    this._topScenePointerUpSub = null;
    this._cancelFocusSubscription = null;
    this._transformerControlMap.forEach((control) => control.dispose());
    this._selectedObjectMap.forEach((control) => control.dispose());
    this._changeStart$.complete();
    this._changing$.complete();
    this._changeEnd$.complete();
  }
  _initialProps(props) {
    if (!props) {
      return;
    }
    const propsKeys = Object.keys(props);
    if (propsKeys.length === 0) {
      return;
    }
    propsKeys.forEach((key) => {
      if (props[key] === void 0) {
        return true;
      }
      this[key] = props[key];
    });
  }
  _checkMoveBoundary(moveObject, moveLeft, moveTop, ancestorLeft, ancestorTop, topSceneWidth, topSceneHeight) {
    const { left, top, width, height } = moveObject;
    if (moveLeft + left + ancestorLeft < this.zeroLeft) {
      moveLeft = -ancestorLeft;
    }
    if (moveTop + top + ancestorTop < this.zeroTop) {
      moveTop = -ancestorTop;
    }
    if (moveLeft + left + width + ancestorLeft > topSceneWidth + this.zeroLeft) {
      moveLeft = this.zeroLeft + topSceneWidth - width - left - ancestorLeft;
    }
    if (moveTop + top + height + ancestorTop > topSceneHeight + this.zeroTop) {
      moveTop = this.zeroTop + topSceneHeight - height - top - ancestorTop;
    }
    return {
      moveLeft,
      moveTop
    };
  }
  _moving(moveOffsetX, moveOffsetY, scrollTimer, isCropper = false) {
    const { scrollX, scrollY } = getCurrentScrollXY(scrollTimer);
    const x = moveOffsetX - this._viewportScrollX + scrollX;
    const y = moveOffsetY - this._viewportScrollY + scrollY;
    const { ancestorScaleX, ancestorScaleY, ancestorLeft, ancestorTop } = this._scene;
    let moveLeft = this._smoothAccuracy((x - this._startOffsetX) / ancestorScaleX, isCropper);
    let moveTop = this._smoothAccuracy((y - this._startOffsetY) / ancestorScaleY, isCropper);
    if (this._moveBufferBlocker(moveOffsetX, moveOffsetY)) {
      return;
    }
    const topScene = this._getTopScene();
    if (!topScene) {
      return;
    }
    const { width: topSceneWidth, height: topSceneHeight } = topScene;
    if (!isCropper) {
      const selectedObjects = Array.from(this._selectedObjectMap.values());
      for (let i = 0; i < selectedObjects.length; i++) {
        const moveObject = selectedObjects[i];
        const boundary = this._checkMoveBoundary(
          moveObject,
          moveLeft,
          moveTop,
          ancestorLeft,
          ancestorTop,
          topSceneWidth,
          topSceneHeight
        );
        moveLeft = boundary.moveLeft;
        moveTop = boundary.moveTop;
      }
      this._selectedObjectMap.forEach((moveObject) => {
        moveObject.translate(moveLeft + moveObject.left, moveTop + moveObject.top);
      });
      this._changing$.next({
        objects: this._selectedObjectMap,
        moveX: moveLeft,
        moveY: moveTop,
        type: 1 /* MOVING */,
        offsetX: moveOffsetX,
        offsetY: moveOffsetY
      });
    } else if (this._copperSelectedObject) {
      const cropper = this._copperSelectedObject;
      const boundary = this._checkMoveBoundary(cropper, moveLeft, moveTop, ancestorLeft, ancestorTop, topSceneWidth, topSceneHeight);
      moveLeft = boundary.moveLeft;
      moveTop = boundary.moveTop;
      cropper.translate(moveLeft + cropper.left, moveTop + cropper.top);
      this._changing$.next({
        objects: /* @__PURE__ */ new Map([[cropper.oKey, cropper]]),
        moveX: moveLeft,
        moveY: moveTop,
        type: 1 /* MOVING */,
        offsetX: moveOffsetX,
        offsetY: moveOffsetY
      });
    }
    this._startOffsetX = x;
    this._startOffsetY = y;
  }
  _moveBufferBlocker(x, y) {
    if (!this._moveBufferSkip && Math.abs(x - this._startOffsetX) < MOVE_BUFFER_VALUE && Math.abs(y - this._startOffsetY) < MOVE_BUFFER_VALUE) {
      return true;
    }
    this._moveBufferSkip = true;
    return false;
  }
  _anchorMoving(type2, moveOffsetX, moveOffsetY, scrollTimer, keepRatio, isCropper = false, applyObject) {
    const { scrollX, scrollY } = getCurrentScrollXY(scrollTimer);
    const x = moveOffsetX - this._viewportScrollX + scrollX;
    const y = moveOffsetY - this._viewportScrollY + scrollY;
    if (this._moveBufferBlocker(moveOffsetX, moveOffsetY)) {
      return;
    }
    const isGroup = applyObject instanceof Group;
    if (!isCropper) {
      this._selectedObjectMap.forEach((moveObject) => {
        this._moveFunc(moveObject, type2, x, y, keepRatio, isCropper, isGroup);
      });
      this._changing$.next({
        objects: this._selectedObjectMap,
        type: 1 /* MOVING */,
        offsetX: moveOffsetX,
        offsetY: moveOffsetY
      });
    } else {
      this._moveFunc(applyObject, type2, x, y, keepRatio, isCropper, isGroup);
      this._changing$.next({
        objects: /* @__PURE__ */ new Map([[applyObject.oKey, applyObject]]),
        type: 1 /* MOVING */,
        offsetX: moveOffsetX,
        offsetY: moveOffsetY
      });
    }
    if (!(keepRatio && type2 !== "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */ && type2 !== "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */ && type2 !== "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */ && type2 !== "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */ && !isGroup)) {
      this._startOffsetX = x;
      this._startOffsetY = y;
    }
  }
  _moveFunc(moveObject, type2, x, y, keepRatio, isCropper = false, isGroup = false) {
    const { left, top, width, height, angle } = moveObject;
    const originState = this._startStateMap.get(moveObject.oKey) || {};
    let state = {};
    const { moveLeft, moveTop } = this._getMovePoint(x, y, moveObject);
    if (keepRatio && type2 !== "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */ && type2 !== "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */ && type2 !== "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */ && type2 !== "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */ && !isGroup) {
      switch (type2) {
        case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
          state = this._resizeLeftTop(moveObject, moveLeft, moveTop, originState);
          break;
        case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
          state = this._resizeRightTop(moveObject, moveLeft, moveTop, originState);
          break;
        case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
          state = this._resizeLeftBottom(moveObject, moveLeft, moveTop, originState);
          break;
        case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
          state = this._resizeRightBottom(moveObject, moveLeft, moveTop, originState);
          break;
      }
    } else {
      state = this._updateCloseKeepRatioState(type2, left, top, width, height, moveLeft, moveTop);
    }
    moveObject.transformByState(this._applyRotationForResult(state, { left, top, width, height }, angle, isCropper));
  }
  _getMovePoint(x, y, moveObject) {
    const { ancestorScaleX, ancestorScaleY } = this._scene;
    const { left, top, width, height, angle } = moveObject;
    const cx = left + width / 2;
    const cy = top + height / 2;
    const centerPoint = new Vector2(cx, cy);
    const xyPoint = new Vector2(x, y);
    xyPoint.rotateByPoint(degToRad(-angle), centerPoint);
    const startPoint = new Vector2(this._startOffsetX, this._startOffsetY);
    startPoint.rotateByPoint(degToRad(-angle), centerPoint);
    const moveLeft = (xyPoint.x - startPoint.x) / ancestorScaleX;
    const moveTop = (xyPoint.y - startPoint.y) / ancestorScaleY;
    return {
      moveLeft,
      moveTop
    };
  }
  /**
   *
   */
  _applyRotationForResult(newsState, oldState, angle, isCropper = false) {
    if (angle === 0) {
      return newsState;
    }
    const { left = 0, top = 0, width = 0, height = 0 } = newsState;
    const { left: oldLeft = 0, top: oldTop = 0, width: oldWidth = 0, height: oldHeight = 0 } = oldState;
    const oldCx = oldWidth / 2;
    const oldCy = oldHeight / 2;
    const newCx = width / 2 + left - oldLeft;
    const newCy = height / 2 + top - oldTop;
    const finalPoint = offsetRotationAxis(new Vector2(oldCx, oldCy), angle, new Vector2(left, top), new Vector2(newCx, newCy));
    return {
      width: this._smoothAccuracy(width, isCropper),
      height: this._smoothAccuracy(height, isCropper),
      left: this._smoothAccuracy(finalPoint.x, isCropper),
      top: this._smoothAccuracy(finalPoint.y, isCropper)
    };
  }
  // eslint-disable-next-line complexity
  _updateCloseKeepRatioState(type2, left, top, width, height, moveLeft, moveTop) {
    const state = { left, top, width, height };
    switch (type2) {
      case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
        state.width = width - moveLeft < MINI_WIDTH_LIMIT ? MINI_WIDTH_LIMIT : width - moveLeft;
        state.height = height - moveTop < MINI_HEIGHT_LIMIT ? MINI_HEIGHT_LIMIT : height - moveTop;
        state.left = left + width - state.width;
        state.top = top + height - state.height;
        break;
      case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
        state.height = height - moveTop < MINI_HEIGHT_LIMIT ? MINI_HEIGHT_LIMIT : height - moveTop;
        state.top = top + height - state.height;
        break;
      case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
        state.width = width + moveLeft < MINI_WIDTH_LIMIT ? MINI_WIDTH_LIMIT : width + moveLeft;
        state.height = height - moveTop < MINI_HEIGHT_LIMIT ? MINI_HEIGHT_LIMIT : height - moveTop;
        state.top = top + height - state.height;
        break;
      case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
        state.width = width - moveLeft < MINI_WIDTH_LIMIT ? MINI_WIDTH_LIMIT : width - moveLeft;
        state.left = left + width - state.width;
        break;
      case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
        state.width = moveLeft + width < MINI_WIDTH_LIMIT ? MINI_WIDTH_LIMIT : moveLeft + width;
        break;
      case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
        state.width = width - moveLeft < MINI_WIDTH_LIMIT ? MINI_WIDTH_LIMIT : width - moveLeft;
        state.height = height + moveTop < MINI_HEIGHT_LIMIT ? MINI_HEIGHT_LIMIT : height + moveTop;
        state.left = state.width <= MINI_WIDTH_LIMIT ? left : left + moveLeft;
        break;
      case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
        state.height = moveTop + height < MINI_HEIGHT_LIMIT ? MINI_HEIGHT_LIMIT : moveTop + height;
        break;
      case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
        state.width = moveLeft + width < MINI_WIDTH_LIMIT ? MINI_WIDTH_LIMIT : moveLeft + width;
        state.height = moveTop + height < MINI_HEIGHT_LIMIT ? MINI_HEIGHT_LIMIT : moveTop + height;
        break;
    }
    return state;
  }
  _getLimitedSize(newWidth, newHeight) {
    let limitWidth = MINI_WIDTH_LIMIT;
    let limitHeight = MINI_HEIGHT_LIMIT;
    if (newWidth > newHeight) {
      limitWidth = limitWidth * Math.abs(newWidth / newHeight);
    } else {
      limitHeight = limitHeight * Math.abs(newHeight / newWidth);
    }
    return {
      limitWidth,
      limitHeight
    };
  }
  _resizeLeftTop(moveObject, moveLeft, moveTop, originState) {
    const { left = 0, top = 0, width = 0, height = 0 } = moveObject.getState();
    const { width: originWidth = width, height: originHeight = height, left: originLeft = left, top: originTop = top } = originState;
    const aspectRatio = originWidth / originHeight;
    const { moveLeft: moveLeftFix, moveTop: moveTopFix } = this._fixMoveLtRb(moveLeft, moveTop, originWidth, originHeight, aspectRatio);
    let newWidth = originWidth - moveLeftFix;
    let newHeight = originHeight - moveTopFix;
    const { limitWidth, limitHeight } = this._getLimitedSize(originWidth, originHeight);
    if (newWidth < limitWidth) {
      newWidth = limitWidth;
    }
    if (newHeight < limitHeight) {
      newHeight = limitHeight;
    }
    return {
      left: left + width - newWidth,
      top: top + height - newHeight,
      width: newWidth,
      height: newHeight
    };
  }
  _resizeRightBottom(moveObject, moveLeft, moveTop, originState) {
    const { left = 0, top = 0, width = 0, height = 0 } = moveObject.getState();
    const { width: originWidth = width, height: originHeight = height, left: originLeft = left, top: originTop = top } = originState;
    const aspectRatio = originWidth / originHeight;
    const { moveLeft: moveLeftFix, moveTop: moveTopFix } = this._fixMoveLtRb(moveLeft, moveTop, originWidth, originHeight, aspectRatio);
    let newWidth = originWidth + moveLeftFix;
    let newHeight = originHeight + moveTopFix;
    const { limitWidth, limitHeight } = this._getLimitedSize(originWidth, originHeight);
    if (newWidth < limitWidth) {
      newWidth = limitWidth;
    }
    if (newHeight < limitHeight) {
      newHeight = limitHeight;
    }
    return {
      left,
      top,
      width: newWidth,
      height: newHeight
    };
  }
  _resizeLeftBottom(moveObject, moveLeft, moveTop, originState) {
    const { left = 0, top = 0, width = 0, height = 0 } = moveObject.getState();
    const { width: originWidth = width, height: originHeight = height, left: originLeft = left, top: originTop = top } = originState;
    const aspectRatio = originWidth / originHeight;
    const { moveLeft: moveLeftFix, moveTop: moveTopFix } = this._fixMoveLbRt(moveLeft, moveTop, originWidth, originHeight, aspectRatio);
    let newWidth = originWidth - moveLeftFix;
    let newHeight = originHeight + moveTopFix;
    const { limitWidth, limitHeight } = this._getLimitedSize(originWidth, originHeight);
    if (newWidth < limitWidth) {
      newWidth = limitWidth;
    }
    if (newHeight < limitHeight) {
      newHeight = limitHeight;
    }
    return {
      left: left + width - newWidth,
      top,
      width: newWidth,
      height: newHeight
    };
  }
  _resizeRightTop(moveObject, moveLeft, moveTop, originState) {
    const { left = 0, top = 0, width = 0, height = 0 } = moveObject.getState();
    const { width: originWidth = width, height: originHeight = height, left: originLeft = left, top: originTop = top } = originState;
    const aspectRatio = originWidth / originHeight;
    const { moveLeft: moveLeftFix, moveTop: moveTopFix } = this._fixMoveLbRt(moveLeft, moveTop, originWidth, originHeight, aspectRatio);
    let newWidth = originWidth + moveLeftFix;
    let newHeight = originHeight - moveTopFix;
    const { limitWidth, limitHeight } = this._getLimitedSize(originWidth, originHeight);
    if (newWidth < limitWidth) {
      newWidth = limitWidth;
    }
    if (newHeight < limitHeight) {
      newHeight = limitHeight;
    }
    return {
      left,
      top: top + height - newHeight,
      width: newWidth,
      height: newHeight
    };
  }
  _fixMoveLtRb(moveLeft, moveTop, originWidth, originHeight, aspectRatio) {
    let moveLeftFix = moveLeft;
    let moveTopFix = moveTop;
    if ((originWidth + moveLeftFix) / (originHeight + moveTopFix) > aspectRatio) {
      moveTopFix = moveLeftFix / aspectRatio;
    } else {
      moveLeftFix = moveTopFix * aspectRatio;
    }
    return {
      moveLeft: moveLeftFix,
      moveTop: moveTopFix
    };
  }
  _fixMoveLbRt(moveLeft, moveTop, originWidth, originHeight, aspectRatio) {
    let moveLeftFix = moveLeft;
    let moveTopFix = moveTop;
    if (Math.abs((originWidth - moveLeftFix) / (originHeight + moveTopFix)) > aspectRatio) {
      moveTopFix = -moveLeftFix / aspectRatio;
    } else {
      moveLeftFix = -moveTopFix * aspectRatio;
    }
    return {
      moveLeft: moveLeftFix,
      moveTop: moveTopFix
    };
  }
  // eslint-disable-next-line max-lines-per-function
  _attachEventToAnchor(anchor, type2 = "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */, applyObject) {
    this.disposeWithMe(
      toDisposable(
        // eslint-disable-next-line max-lines-per-function
        anchor.onPointerDown$.subscribeEvent((evt, state) => {
          const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
          this._startOffsetX = evtOffsetX;
          this._startOffsetY = evtOffsetY;
          const topScene = this._getTopScene();
          const { keepRatio, isCropper } = this._getConfig(applyObject);
          if (topScene == null) {
            return;
          }
          topScene.disableObjectsEvent();
          const scrollTimer = ScrollTimer.create(topScene);
          scrollTimer.startScroll(evtOffsetX, evtOffsetY);
          const { scrollX, scrollY } = getCurrentScrollXY(scrollTimer);
          this._viewportScrollX = scrollX;
          this._viewportScrollY = scrollY;
          const { ancestorLeft, ancestorTop } = this._scene;
          const { width: topSceneWidth, height: topSceneHeight } = topScene;
          const cursor = this._getRotateAnchorCursor(type2);
          if (!isCropper) {
            this._clearControlMap();
            this._changeStart$.next({
              objects: this._selectedObjectMap,
              type: 0 /* MOVE_START */
            });
            this._selectedObjectMap.forEach((moveObject) => {
              const { width, height, left, top } = moveObject.getState();
              this._startStateMap.set(moveObject.oKey, { width, height, left, top });
            });
          } else {
            this._changeStart$.next({
              objects: /* @__PURE__ */ new Map([[applyObject.oKey, applyObject]]),
              type: 0 /* MOVE_START */
            });
            const { width, height, left, top } = applyObject.getState();
            this._startStateMap.set(applyObject.oKey, { width, height, left, top });
          }
          this._moveBufferSkip = false;
          this._topScenePointerMoveSub = topScene.onPointerMove$.subscribeEvent((moveEvt) => {
            const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
            this._anchorMoving(type2, moveOffsetX, moveOffsetY, scrollTimer, keepRatio, isCropper, applyObject);
            scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
              this._anchorMoving(type2, moveOffsetX, moveOffsetY, scrollTimer, keepRatio, isCropper, applyObject);
            });
            topScene.setCursor(cursor);
          });
          this._topScenePointerUpSub = topScene.onPointerUp$.subscribeEvent((event) => {
            var _a, _b;
            (_a = this._topScenePointerMoveSub) == null ? void 0 : _a.unsubscribe();
            (_b = this._topScenePointerUpSub) == null ? void 0 : _b.unsubscribe();
            topScene.enableObjectsEvent();
            topScene.resetCursor();
            scrollTimer.dispose();
            this._startStateMap.clear();
            const { offsetX, offsetY } = event;
            if (!isCropper) {
              this._recoverySizeBoundary(Array.from(this._selectedObjectMap.values()), ancestorLeft, ancestorTop, topSceneWidth, topSceneHeight);
              this._changeEnd$.next({
                objects: this._selectedObjectMap,
                type: 2 /* MOVE_END */,
                offsetX,
                offsetY
              });
            } else {
              this._recoverySizeBoundary([applyObject], ancestorLeft, ancestorTop, topSceneWidth, topSceneHeight);
              this._changeEnd$.next({
                objects: /* @__PURE__ */ new Map([[applyObject.oKey, applyObject]]),
                type: 2 /* MOVE_END */,
                offsetX,
                offsetY
              });
            }
            this.refreshControls();
          });
          state.stopPropagation();
        })
      )
    );
  }
  _recoverySizeBoundary(selectedObjects, ancestorLeft, ancestorTop, topSceneWidth, topSceneHeight) {
    for (let i = 0; i < selectedObjects.length; i++) {
      const moveObject = selectedObjects[i];
      const { left, top, width, height } = moveObject;
      const newTransform = {};
      if (left + ancestorLeft < this.zeroLeft) {
        newTransform.left = this.zeroLeft - ancestorLeft;
        newTransform.width = width + left;
      } else if (left + width + ancestorLeft > topSceneWidth + this.zeroLeft) {
        newTransform.width = this.zeroLeft + topSceneWidth - left - ancestorLeft;
      }
      if (top + ancestorTop < this.zeroTop) {
        newTransform.top = this.zeroTop - ancestorTop;
        newTransform.height = height + top;
      } else if (top + height + ancestorTop > topSceneHeight + this.zeroTop) {
        newTransform.height = this.zeroTop + topSceneHeight - top - ancestorTop;
      }
      moveObject.transformByState(newTransform);
    }
  }
  _attachEventToRotate(rotateControl, applyObject) {
    this.disposeWithMe(
      toDisposable(
        rotateControl.onPointerDown$.subscribeEvent((evt, state) => {
          const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
          this._startOffsetX = evtOffsetX;
          this._startOffsetY = evtOffsetY;
          const topScene = this._getTopScene();
          if (topScene == null) {
            return;
          }
          topScene.disableObjectsEvent();
          const viewportActualXY = topScene.getScrollXYInfoByViewport(Vector2.create(evtOffsetX, evtOffsetY));
          this._viewportScrollX = viewportActualXY.x;
          this._viewportScrollY = viewportActualXY.y;
          const cursor = this._getRotateAnchorCursor("__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */);
          const { ancestorLeft, ancestorTop, width, height, angle: agentOrigin } = applyObject;
          const centerX = width / 2 + ancestorLeft;
          const centerY = height / 2 + ancestorTop;
          this._clearControlMap();
          this._changeStart$.next({
            objects: this._selectedObjectMap,
            type: 0 /* MOVE_START */
          });
          this._moveBufferSkip = false;
          const topScenePointerMoveSub = topScene.onPointerMove$.subscribeEvent((moveEvt) => {
            const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
            this._rotateMoving(moveOffsetX, moveOffsetY, centerX, centerY, agentOrigin);
            topScene.setCursor(cursor);
          });
          const topScenePointerUpSub = topScene.onPointerUp$.subscribeEvent((event) => {
            topScenePointerMoveSub == null ? void 0 : topScenePointerMoveSub.unsubscribe();
            topScenePointerUpSub == null ? void 0 : topScenePointerUpSub.unsubscribe();
            topScene.enableObjectsEvent();
            topScene.resetCursor();
            this.refreshControls();
            const { offsetX, offsetY } = event;
            this._changeEnd$.next({
              objects: this._selectedObjectMap,
              type: 2 /* MOVE_END */,
              offsetX,
              offsetY
            });
          });
          state.stopPropagation();
        })
      )
    );
  }
  _rotateMoving(moveOffsetX, moveOffsetY, centerX, centerY, agentOrigin) {
    const { ancestorScaleX, ancestorScaleY } = this._scene;
    if (this._moveBufferBlocker(moveOffsetX, moveOffsetY)) {
      return;
    }
    const angle1 = Math.atan2(
      (moveOffsetY - centerY) / ancestorScaleY + this._viewportScrollY,
      (moveOffsetX - centerX) / ancestorScaleX + this._viewportScrollX
    );
    const angle2 = Math.atan2(
      (this._startOffsetY - centerY) / ancestorScaleY + this._viewportScrollY,
      (this._startOffsetX - centerX) / ancestorScaleX + this._viewportScrollX
    );
    let angle = agentOrigin + radToDeg(angle1 - angle2);
    if (angle < 0) {
      angle = 360 + angle;
    }
    angle %= 360;
    angle = this._smoothAccuracy(angle);
    this._selectedObjectMap.forEach((moveObject) => {
      moveObject.transformByState({ angle });
    });
    this._changing$.next({
      objects: this._selectedObjectMap,
      angle,
      type: 1 /* MOVING */,
      offsetX: moveOffsetX,
      offsetY: moveOffsetY
    });
  }
  _getOutlinePosition(width, height, borderSpacing, borderStrokeWidth) {
    return {
      left: borderSpacing - borderStrokeWidth,
      top: -borderSpacing - this.borderStrokeWidth,
      width: width + borderSpacing * 2,
      height: height + borderSpacing * 2
    };
  }
  _getRotateAnchorCursor(type2) {
    let cursor = "nw-resize" /* NORTH_WEST_RESIZE */;
    switch (type2) {
      case "__SpreadsheetTransformerRotate__" /* ROTATE */:
        cursor = "move" /* MOVE */;
        break;
      case "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */:
        cursor = "move" /* MOVE */;
        break;
      case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
        break;
      case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
        cursor = "n-resize" /* NORTH_RESIZE */;
        break;
      case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
        cursor = "ne-resize" /* NORTH_EAST_RESIZE */;
        break;
      case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
        cursor = "w-resize" /* WEST_RESIZE */;
        break;
      case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
        cursor = "e-resize" /* EAST_RESIZE */;
        break;
      case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
        cursor = "sw-resize" /* SOUTH_WEST_RESIZE */;
        break;
      case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
        cursor = "s-resize" /* SOUTH_RESIZE */;
        break;
      case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
        cursor = "se-resize" /* SOUTH_EAST_RESIZE */;
        break;
    }
    return cursor;
  }
  _getCopperAnchorPosition(type2, height, width, applyObject) {
    const { borderStrokeWidth, borderSpacing, anchorSize } = this._getConfig(applyObject);
    let left = 0;
    let top = 0;
    const longEdge = anchorSize;
    const shortEdge = anchorSize / 4;
    switch (type2) {
      case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
        left += -borderSpacing - borderStrokeWidth;
        top += -borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
        left += width / 2 - longEdge / 2;
        top += -borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
        left += width + borderSpacing - borderStrokeWidth - longEdge;
        top += -borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
        left += borderSpacing - borderStrokeWidth;
        top += height / 2 - longEdge / 2;
        break;
      case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
        left += width + borderSpacing - borderStrokeWidth - shortEdge;
        top += height / 2 - longEdge / 2;
        break;
      case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
        left += -this.borderSpacing - borderStrokeWidth;
        top += height + borderSpacing - borderStrokeWidth - longEdge;
        break;
      case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
        left += width / 2 - longEdge / 2;
        top += height + borderSpacing - borderStrokeWidth - shortEdge;
        break;
      case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
        left += width + borderSpacing - borderStrokeWidth - longEdge;
        top += height + borderSpacing - borderStrokeWidth - longEdge;
        break;
    }
    return {
      left,
      top
    };
  }
  _getRotateAnchorPosition(type2, height, width, applyObject) {
    const { rotateAnchorOffset, rotateSize, borderStrokeWidth, borderSpacing, anchorSize } = this._getConfig(applyObject);
    let left = -anchorSize / 2;
    let top = -anchorSize / 2;
    switch (type2) {
      case "__SpreadsheetTransformerRotate__" /* ROTATE */:
        left = width / 2 - rotateSize / 2;
        top = -rotateAnchorOffset - borderSpacing - borderStrokeWidth * 2 - rotateSize;
        break;
      case "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */:
        left = width / 2;
        top = -rotateAnchorOffset - borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
        left += -borderSpacing - borderStrokeWidth;
        top += -borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
        left += width / 2;
        top += -borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
        left += width + borderSpacing - borderStrokeWidth;
        top += -borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
        left += borderSpacing - borderStrokeWidth;
        top += height / 2;
        break;
      case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
        left += width + borderSpacing - borderStrokeWidth;
        top += height / 2;
        break;
      case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
        left += -this.borderSpacing - borderStrokeWidth;
        top += height + borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
        left += width / 2;
        top += height + borderSpacing - borderStrokeWidth;
        break;
      case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
        left += width + borderSpacing - borderStrokeWidth;
        top += height + borderSpacing - borderStrokeWidth;
        break;
    }
    return {
      left,
      top
    };
  }
  _createResizeAnchor(type2, applyObject, zIndex) {
    const { height = 0, width = 0, scaleX = 1, scaleY = 1 } = applyObject.getState();
    const { anchorFill, anchorStroke, anchorStrokeWidth, anchorCornerRadius, anchorSize } = this._getConfig(applyObject);
    const { left, top } = this._getRotateAnchorPosition(type2, height, width, applyObject);
    const cursor = this._getRotateAnchorCursor(type2);
    const anchor = new Rect(`${type2}_${zIndex}`, {
      zIndex: zIndex - 1,
      fill: anchorFill,
      stroke: anchorStroke,
      strokeWidth: anchorStrokeWidth,
      width: anchorSize,
      height: anchorSize,
      radius: anchorCornerRadius,
      left,
      top
    });
    this._attachHover(anchor, cursor, "default" /* DEFAULT */);
    return anchor;
  }
  _createCopperResizeAnchor(type2, applyObject, zIndex) {
    const { height = 0, width = 0, scaleX = 1, scaleY = 1 } = applyObject.getState();
    const { anchorFill, anchorStroke, anchorStrokeWidth, anchorSize } = this._getConfig(applyObject);
    const { left, top } = this._getCopperAnchorPosition(type2, height, width, applyObject);
    const cursor = this._getRotateAnchorCursor(type2);
    let anchor;
    const oKey = `${type2}_${zIndex}`;
    const config = {
      zIndex: zIndex - 1,
      fill: anchorFill,
      stroke: anchorStroke,
      strokeWidth: anchorStrokeWidth,
      width: anchorSize,
      height: anchorSize,
      left,
      top
    };
    const longEdge = anchorSize;
    const shortEdge = anchorSize / 4;
    if (cursor === "e-resize" /* EAST_RESIZE */) {
      config.width = shortEdge;
      config.height = longEdge;
      anchor = new Rect(oKey, config);
    } else if (cursor === "w-resize" /* WEST_RESIZE */) {
      config.width = shortEdge;
      config.height = longEdge;
      anchor = new Rect(oKey, config);
    } else if (cursor === "n-resize" /* NORTH_RESIZE */) {
      config.width = longEdge;
      config.height = shortEdge;
      anchor = new Rect(oKey, config);
    } else if (cursor === "s-resize" /* SOUTH_RESIZE */) {
      config.width = longEdge;
      config.height = shortEdge;
      anchor = new Rect(oKey, config);
    } else if (cursor === "ne-resize" /* NORTH_EAST_RESIZE */) {
      config.pointsGroup = this._getNorthEastPoints(longEdge, shortEdge);
      anchor = new RegularPolygon(oKey, config);
    } else if (cursor === "nw-resize" /* NORTH_WEST_RESIZE */) {
      config.pointsGroup = this._getNorthWestPoints(longEdge, shortEdge);
      anchor = new RegularPolygon(oKey, config);
    } else if (cursor === "se-resize" /* SOUTH_EAST_RESIZE */) {
      config.pointsGroup = this._getSouthEastPoints(longEdge, shortEdge);
      anchor = new RegularPolygon(oKey, config);
    } else if (cursor === "sw-resize" /* SOUTH_WEST_RESIZE */) {
      config.pointsGroup = this._getSouthWestPoints(longEdge, shortEdge);
      anchor = new RegularPolygon(oKey, config);
    }
    this._attachHover(anchor, cursor, "default" /* DEFAULT */);
    return anchor;
  }
  _getNorthEastPoints(longEdge, shortEdge) {
    const minusL_S = longEdge - shortEdge;
    return [
      [
        { x: 0, y: 0 },
        { x: longEdge, y: 0 },
        { x: longEdge, y: longEdge },
        { x: minusL_S, y: longEdge },
        { x: minusL_S, y: shortEdge },
        { x: 0, y: shortEdge }
      ]
    ];
  }
  _getNorthWestPoints(longEdge, shortEdge) {
    return [
      [
        { x: 0, y: 0 },
        { x: longEdge, y: 0 },
        { x: longEdge, y: shortEdge },
        { x: shortEdge, y: shortEdge },
        { x: shortEdge, y: longEdge },
        { x: 0, y: longEdge }
      ]
    ];
  }
  _getSouthEastPoints(longEdge, shortEdge) {
    const minusL_S = longEdge - shortEdge;
    return [
      [
        { x: minusL_S, y: 0 },
        { x: longEdge, y: 0 },
        { x: longEdge, y: longEdge },
        { x: 0, y: longEdge },
        { x: 0, y: minusL_S },
        { x: minusL_S, y: minusL_S },
        { x: minusL_S, y: 0 }
      ]
    ];
  }
  _getSouthWestPoints(longEdge, shortEdge) {
    const minusL_S = longEdge - shortEdge;
    return [
      [
        { x: 0, y: 0 },
        { x: shortEdge, y: 0 },
        { x: shortEdge, y: minusL_S },
        { x: longEdge, y: minusL_S },
        { x: longEdge, y: longEdge },
        { x: 0, y: longEdge },
        { x: 0, y: 0 }
      ]
    ];
  }
  _checkTransformerType(oKey) {
    if (oKey.indexOf("__SpreadsheetTransformerOutline__" /* OUTLINE */) > -1) {
      return "__SpreadsheetTransformerOutline__" /* OUTLINE */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerRotate__" /* ROTATE */) > -1) {
      return "__SpreadsheetTransformerRotate__" /* ROTATE */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */) > -1) {
      return "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */) > -1) {
      return "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */) > -1) {
      return "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */) > -1) {
      return "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */) > -1) {
      return "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */) > -1) {
      return "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */) > -1) {
      return "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */) > -1) {
      return "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */;
    }
    if (oKey.indexOf("__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */) > -1) {
      return "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */;
    }
  }
  _updateControlIterator(func) {
    this._transformerControlMap.forEach((control, oKey) => {
      const applyObject = this._selectedObjectMap.get(oKey);
      if (!applyObject) {
        return true;
      }
      func(control, applyObject);
    });
  }
  _updateControl() {
    this._updateControlIterator((control, applyObject) => {
      const { left, top, height, width, angle } = applyObject.getState();
      control.transformByState({
        left,
        top,
        height,
        width,
        angle
      });
      control.show();
      control.makeDirty(true);
    });
  }
  _hideControl() {
    this._transformerControlMap.forEach((control) => {
      control.hide();
      control.makeDirty(true);
    });
  }
  _attachHover(o, cursorIn, cursorOut) {
    this.disposeWithMe(
      toDisposable(
        o.onPointerEnter$.subscribeEvent(() => {
          o.cursor = cursorIn;
        })
      )
    );
    this.disposeWithMe(
      toDisposable(
        o.onPointerLeave$.subscribeEvent(() => {
          o.cursor = cursorOut;
        })
      )
    );
  }
  _clearControls(changeSelf = false) {
    this._clearControlMap();
    this._clearControl$.next(changeSelf);
  }
  /**
   * @description Clear the control of the object with the specified id
   * @param {string[]} ids the id of the object to be cleared
   */
  clearControlByIds(ids) {
    for (const id of ids) {
      this._selectedObjectMap.delete(id);
    }
    this.refreshControls();
  }
  _clearControlMap() {
    this._transformerControlMap.forEach((control) => {
      control.dispose();
    });
    this._transformerControlMap.clear();
  }
  _createControl(applyObject, isSkipOnCropper = true) {
    const { left = 0, top = 0, height = 0, width = 0 } = applyObject.getState();
    const angle = applyObject.angle;
    const { isCropper, resizeEnabled, rotateEnabled, rotateAnchorOffset, rotateSize, rotateCornerRadius, borderEnabled, borderStroke, borderStrokeWidth, borderSpacing, enabledAnchors } = this._getConfig(applyObject);
    if (isSkipOnCropper && isCropper) {
      return;
    }
    const oKey = applyObject.oKey;
    const zIndex = this._selectedObjectMap.size + applyObject.maxZIndex + DEFAULT_CONTROL_PLUS_INDEX;
    const layerIndex = applyObject.getLayerIndex() || DEFAULT_TRANSFORMER_LAYER_INDEX;
    const groupElements = [];
    if (borderEnabled && !isCropper) {
      const outline = new Rect(`${"__SpreadsheetTransformerOutline__" /* OUTLINE */}_${zIndex}`, {
        zIndex: zIndex - 1,
        evented: false,
        strokeWidth: borderStrokeWidth,
        stroke: borderStroke,
        ...this._getOutlinePosition(width, height, borderSpacing, borderStrokeWidth)
      });
      groupElements.push(outline);
    }
    if (resizeEnabled && !isCropper) {
      const { left: lineLeft, top: lineTop } = this._getRotateAnchorPosition(
        "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */,
        height,
        width,
        applyObject
      );
      if (rotateEnabled) {
        const rotateLine = new Rect(`${"__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          evented: false,
          left: lineLeft,
          top: lineTop,
          height: rotateAnchorOffset,
          width: 1,
          strokeWidth: borderStrokeWidth,
          stroke: borderStroke
        });
        const { left: left2, top: top2 } = this._getRotateAnchorPosition("__SpreadsheetTransformerRotate__" /* ROTATE */, height, width, applyObject);
        const cursor = this._getRotateAnchorCursor("__SpreadsheetTransformerRotate__" /* ROTATE */);
        const rotate = new Rect(`${"__SpreadsheetTransformerRotate__" /* ROTATE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          left: left2,
          top: top2,
          height: rotateSize,
          width: rotateSize,
          radius: rotateCornerRadius,
          strokeWidth: borderStrokeWidth * 2,
          stroke: borderStroke
        });
        this._attachEventToRotate(rotate, applyObject);
        this._attachHover(rotate, cursor, "default" /* DEFAULT */);
        groupElements.push(rotateLine, rotate);
      }
    }
    if (resizeEnabled) {
      for (let i = 0, len = enabledAnchors.length; i < len; i++) {
        const isEnable = enabledAnchors[i];
        if (isEnable !== 1) {
          continue;
        }
        const type2 = TransformerManagerTypeArray[i];
        let anchor;
        if (!isCropper) {
          anchor = this._createResizeAnchor(type2, applyObject, zIndex);
        } else {
          anchor = this._createCopperResizeAnchor(type2, applyObject, zIndex);
        }
        this._attachEventToAnchor(anchor, type2, applyObject);
        groupElements.push(anchor);
      }
    }
    const transformerControl = new Group(`${"__SpreadsheetTransformer__" /* GROUP */}_${oKey}`, ...groupElements);
    transformerControl.zIndex = zIndex;
    transformerControl.evented = false;
    transformerControl.openSelfSizeMode();
    transformerControl.transformByState({ left, top, angle, width, height });
    const scene = this.getScene();
    scene.addObject(transformerControl, layerIndex);
    if (!isCropper) {
      if (this._transformerControlMap.has(oKey)) {
        this._transformerControlMap.get(oKey).dispose();
      }
      this._transformerControlMap.set(oKey, transformerControl);
      this._createControl$.next(transformerControl);
    } else {
      this._copperControl = transformerControl;
    }
    return transformerControl;
  }
  _getTopScene() {
    var _a;
    const currentScene = this.getScene();
    return (_a = currentScene.getEngine()) == null ? void 0 : _a.activeScene;
  }
  activeAnObject(applyObject) {
    this._updateActiveObjectList(applyObject, {});
    this._changeStart$.next({
      target: applyObject,
      objects: this._selectedObjectMap,
      type: 0 /* MOVE_START */
    });
  }
  _updateActiveObjectList(applyObject, evt) {
    const { isCropper } = this._getConfig(applyObject);
    applyObject = this._findGroupObject(applyObject);
    if (this._selectedObjectMap.has(applyObject.oKey)) {
      return;
    }
    if (!evt.ctrlKey || SINGLE_ACTIVE_OBJECT_TYPE_MAP.has(applyObject.objectType)) {
      this._selectedObjectMap.clear();
      this._clearControlMap();
    }
    if (!isCropper) {
      this._selectedObjectMap.set(applyObject.oKey, applyObject);
    }
    this._createControl(applyObject);
  }
  _findGroupObject(applyObject) {
    if (!applyObject.isInGroup) {
      return applyObject;
    }
    const group = applyObject.ancestorGroup;
    if (!group) {
      return applyObject;
    } else {
      return group;
    }
  }
  _addCancelObserver(scene) {
    var _a;
    (_a = this._cancelFocusSubscription) == null ? void 0 : _a.unsubscribe();
    this._cancelFocusSubscription = scene.onPointerDown$.subscribeEvent(() => {
      this.clearSelectedObjects();
    });
  }
  _smoothAccuracy(num, isCropper = false, accuracy = 1) {
    if (isCropper) {
      return precisionTo(num, 3);
    }
    return precisionTo(num, accuracy);
  }
};

// ../packages/engine-render/src/scene.ts
var MAIN_VIEW_PORT_KEY = "viewMain";
var Scene = class extends Disposable {
  constructor(sceneKey, _parent, state) {
    var _a;
    super();
    this._parent = _parent;
    __publicField(this, "_sceneKey", "");
    /**
     * Width of scene content, does not affected by zoom.
     */
    __publicField(this, "_width", 100);
    /**
     * Height of scene content, does not affected by zoom.
     */
    __publicField(this, "_height", 100);
    __publicField(this, "_scaleX", 1);
    __publicField(this, "_scaleY", 1);
    __publicField(this, "_transform", new Transform());
    __publicField(this, "_evented", true);
    __publicField(this, "_layers", []);
    __publicField(this, "_viewports", []);
    __publicField(this, "_cursor", "default" /* DEFAULT */);
    __publicField(this, "_defaultCursor", "default" /* DEFAULT */);
    __publicField(this, "_addObject$", new BehaviorSubject(this));
    __publicField(this, "addObject$", this._addObject$.asObservable());
    __publicField(this, "onTransformChange$", new EventSubject());
    __publicField(this, "onFileLoaded$", new EventSubject());
    __publicField(this, "onPointerDown$", new EventSubject());
    __publicField(this, "onPointerMove$", new EventSubject());
    __publicField(this, "onPointerUp$", new EventSubject());
    __publicField(this, "onPointerEnter$", new EventSubject());
    __publicField(this, "onPointerOut$", new EventSubject());
    __publicField(this, "onPointerCancel$", new EventSubject());
    __publicField(this, "onPointerLeave$", new EventSubject());
    __publicField(this, "onDragEnter$", new EventSubject());
    __publicField(this, "onDragOver$", new EventSubject());
    __publicField(this, "onDragLeave$", new EventSubject());
    __publicField(this, "onDrop$", new EventSubject());
    __publicField(this, "onDblclick$", new EventSubject());
    __publicField(this, "onTripleClick$", new EventSubject());
    __publicField(this, "onMouseWheel$", new EventSubject());
    /**
     * @deprecated  use `fromGlobalEvent('keydown')` from rx.js instead.
     */
    __publicField(this, "onKeyDown$", new EventSubject());
    /**
     * @deprecated  use `fromGlobalEvent('keyup')` from rx.js instead.
     */
    __publicField(this, "onKeyUp$", new EventSubject());
    __publicField(this, "_beforeRender$", new BehaviorSubject(null));
    __publicField(this, "beforeRender$", this._beforeRender$.asObservable());
    __publicField(this, "_afterRender$", new BehaviorSubject(null));
    __publicField(this, "afterRender$", this._afterRender$.asObservable());
    /**
     * Transformer constructor.  Transformer is a special type of group that allow you transform
     * primitives and shapes. Transforming tool is not changing `width` and `height` properties of nodes
     * when you resize them. Instead it changes `scaleX` and `scaleY` properties.
     */
    __publicField(this, "_transformer");
    /** @hidden */
    __publicField(this, "_inputManager");
    __publicField(this, "_capturedObject", null);
    this._sceneKey = sceneKey;
    if (state) {
      this.transformByState(state);
    }
    if (this._parent.classType === "Engine" /* ENGINE */) {
      const parent = this._parent;
      parent.addScene(this);
      if (!parent.hasActiveScene()) {
        parent.setActiveScene(sceneKey);
      }
      this._inputManager = new InputManager(this);
    } else if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      const parent = this._parent;
      parent.addSubScene(this);
    }
    this.disposeWithMe(
      toDisposable(
        (_a = this._parent) == null ? void 0 : _a.onTransformChange$.subscribeEvent((_change) => {
          this._transformHandler();
        })
      )
    );
  }
  get classType() {
    return "Scene" /* SCENE */;
  }
  get transform() {
    return this._transform;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get scaleX() {
    return this._scaleX;
  }
  get scaleY() {
    return this._scaleY;
  }
  get sceneKey() {
    return this._sceneKey;
  }
  get objectsEvented() {
    return this._evented;
  }
  set transform(trans) {
    this._transform = trans;
  }
  set width(num) {
    this._width = num;
  }
  set height(num) {
    this._height = num;
  }
  set scaleX(scaleX) {
    this._scaleX = scaleX;
  }
  set scaleY(scaleY) {
    this._scaleY = scaleY;
  }
  /**
   * ancestorScaleX means this.scaleX * ancestorScaleX
   */
  get ancestorScaleX() {
    const p = this.getParent();
    let pScale = 1;
    if (p.classType === "SceneViewer" /* SCENE_VIEWER */) {
      pScale = p.ancestorScaleX;
    }
    return this.scaleX * pScale;
  }
  /**
   * ancestorScaleY means this.scaleY * ancestorScaleY
   */
  get ancestorScaleY() {
    const p = this.getParent();
    let pScale = 1;
    if (p.classType === "SceneViewer" /* SCENE_VIEWER */) {
      pScale = p.ancestorScaleY;
    }
    return this.scaleY * pScale;
  }
  getAncestorScale() {
    return {
      scaleX: this.ancestorScaleX || 1,
      scaleY: this.ancestorScaleY || 1
    };
  }
  get ancestorLeft() {
    const p = this.getParent();
    let pOffsetX = 0;
    if (p.classType === "SceneViewer" /* SCENE_VIEWER */) {
      pOffsetX = p.ancestorLeft;
    }
    return pOffsetX;
  }
  get ancestorTop() {
    const p = this.getParent();
    let pOffsetY = 0;
    if (p.classType === "SceneViewer" /* SCENE_VIEWER */) {
      pOffsetY = p.ancestorTop;
    }
    return pOffsetY;
  }
  set cursor(val) {
    this.setCursor(val);
  }
  attachControl(options) {
    var _a;
    if (!(this._parent.classType === "Engine" /* ENGINE */)) {
      return;
    }
    (_a = this._inputManager) == null ? void 0 : _a.attachControl(options);
    return this;
  }
  detachControl() {
    var _a;
    (_a = this._inputManager) == null ? void 0 : _a.detachControl();
    return this;
  }
  makeDirty(state = true) {
    var _a;
    this._layers.forEach((layer) => {
      layer.makeDirty(state);
    });
    if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_a = this._parent) == null ? void 0 : _a.makeDirty(state);
    }
    return this;
  }
  makeDirtyNoParent(state = true) {
    this._layers.forEach((layer) => {
      layer.makeDirty(state);
    });
    return this;
  }
  enableLayerCache(...layerIndexes) {
    layerIndexes.forEach((zIndex) => {
      this.getLayer(zIndex).enableCache();
    });
  }
  disableLayerCache(...layerIndexes) {
    layerIndexes.forEach((zIndex) => {
      this.getLayer(zIndex).disableCache();
    });
  }
  isDirty() {
    for (let i = 0; i < this._layers.length; i++) {
      const layer = this._layers[i];
      if (layer.isDirty() === true) {
        return true;
      }
    }
    return false;
  }
  getCursor() {
    return this._cursor;
  }
  resetCursor() {
    this.setCursor(this._defaultCursor);
  }
  setCursor(val) {
    this._cursor = val;
    const engine = this.getEngine();
    if (!engine) {
      return;
    }
    engine.setCanvasCursor(val);
  }
  setDefaultCursor(val) {
    this._defaultCursor = val;
    this.resetCursor();
  }
  /**
   * @deprecated use transformByState instead.
   * @param width
   * @param height
   */
  resize(width, height) {
    const preWidth = this.width;
    if (width !== void 0) {
      this.width = width;
    }
    const preHeight = this.height;
    if (height !== void 0) {
      this.height = height;
    }
    this._transformHandler();
    this.onTransformChange$.emitEvent({
      type: 1 /* resize */,
      value: {
        width: this.width,
        height: this.height
      },
      preValue: { width: preWidth, height: preHeight }
    });
    return this;
  }
  /**
   * Unlike @scale, this method doesn't emit event.
   * @param scaleX
   * @param scaleY
   */
  setScaleValueOnly(scaleX, scaleY) {
    if (scaleX !== void 0) {
      this.scaleX = scaleX;
    }
    if (scaleY !== void 0) {
      this.scaleY = scaleY;
    }
  }
  /**
   * Set scale, and then emit event to update Viewport scroll state.
   * @param scaleX
   * @param scaleY
   * @returns Scene
   */
  scale(scaleX, scaleY) {
    const preScaleX = this.scaleX;
    const preScaleY = this.scaleY;
    this.setScaleValueOnly(scaleX || 1, scaleY || 1);
    this._transformHandler();
    this.onTransformChange$.emitEvent({
      type: 2 /* scale */,
      value: {
        scaleX: this.scaleX,
        scaleY: this.scaleY
      },
      preValue: { scaleX: preScaleX, scaleY: preScaleY }
    });
    return this;
  }
  /**
   * Apply scaleXY base on current scaleX and scaleY
   */
  scaleBy(deltaScaleX, deltaScaleY) {
    const preScaleX = this.scaleX;
    if (deltaScaleX !== void 0) {
      this.scaleX += deltaScaleX;
    }
    const preScaleY = this.scaleY;
    if (deltaScaleY !== void 0) {
      this.scaleY += deltaScaleY;
    }
    this.scaleX = precisionTo(this.scaleX, 1);
    this.scaleY = precisionTo(this.scaleY, 1);
    this._transformHandler();
    this.onTransformChange$.emitEvent({
      type: 2 /* scale */,
      value: {
        scaleX: this.scaleX,
        scaleY: this.scaleY
      },
      preValue: { scaleX: preScaleX, scaleY: preScaleY }
    });
    return this;
  }
  /**
   * Reset canvas size and update scroll
   * @param state
   */
  transformByState(state) {
    const transformStateKeys = Object.keys(state);
    const preKeys = {};
    if (transformStateKeys.length === 0) {
      return;
    }
    transformStateKeys.forEach((pKey) => {
      if (state[pKey] !== void 0) {
        preKeys[pKey] = this[pKey];
        this[pKey] = state[pKey];
      }
    });
    this._transformHandler();
    this.onTransformChange$.emitEvent({
      type: 5 /* all */,
      value: state,
      preValue: preKeys
    });
  }
  getParent() {
    return this._parent;
  }
  getEngine() {
    if (this._parent.classType === "Engine" /* ENGINE */) {
      return this._parent;
    }
    let parent = this._parent;
    while (parent) {
      if (parent.classType === "Engine" /* ENGINE */) {
        return parent;
      }
      parent = parent == null ? void 0 : parent.getParent();
    }
    return null;
  }
  getLayers() {
    return this._layers;
  }
  getLayer(zIndex = 1) {
    for (const layer of this._layers) {
      if (layer.zIndex === zIndex) {
        return layer;
      }
    }
    return this._createDefaultLayer(zIndex);
  }
  findLayerByZIndex(zIndex = 1) {
    for (const layer of this.getLayers()) {
      if (layer.zIndex === zIndex) {
        return layer;
      }
    }
  }
  getLayerMaxZIndex() {
    let maxIndex = Number.MIN_VALUE;
    for (let i = 0; i < this._layers.length; i++) {
      const layer = this._layers[i];
      if (layer.zIndex >= maxIndex) {
        maxIndex = layer.zIndex;
      }
    }
    return maxIndex;
  }
  addLayer(...argument2) {
    this._layers.push(...argument2);
  }
  /**
   * Add objects to Layer( Layer is specfied by zIndex)
   * If object is a group, insert all its children and group itself to _objects[].
   * @param objects
   * @param zIndex
   * @returns {Scene} this
   */
  addObjects(objects, zIndex = 1) {
    var _a;
    (_a = this.getLayer(zIndex)) == null ? void 0 : _a.addObjects(objects);
    this._addObject$.next(this);
    return this;
  }
  /**
   * Add object to Layer (Layer is specified by zIndex).
   * If object is a group, insert all its children and group itself to _objects[].
   * @param o
   * @param zIndex layer index
   * @returns {Scene} scene
   */
  addObject(o, zIndex = 1) {
    var _a;
    (_a = this.getLayer(zIndex)) == null ? void 0 : _a.addObject(o);
    this._addObject$.next(this);
    return this;
  }
  /**
   * Set Scene as object parent, if object has no parent.
   * @param o
   * @returns {void}
   */
  setObjectBehavior(o) {
    if (!o.parent) {
      o.parent = this;
    }
    o.onIsAddedToParent$.emitEvent(this);
  }
  // Why? return values is so strange! removeObject should return true/false, or didn't return anything.
  removeObject(object) {
    if (object == null) {
      return;
    }
    const layers = this.getLayers();
    for (const layer of layers) {
      layer.removeObject(object);
    }
    return this;
  }
  removeObjects(objects) {
    if (objects == null) {
      return;
    }
    const layers = this.getLayers();
    for (const layer of layers) {
      layer.removeObjects(objects);
    }
    return this;
  }
  // addBackObjects(...argument: BaseObject[]) {
  //     argument.forEach((o: BaseObject) => {
  //         this.addObjectBack(o);
  //     });
  //     return this;
  // }
  // addForwardObjects(...argument: BaseObject[]) {
  //     argument.forEach((o: BaseObject) => {
  //         this.addObjectForward(o);
  //     });
  //     return this;
  // }
  getObjectsByLayer(zIndex) {
    const objects = [];
    this._layers.sort(sortRules);
    for (const layer of this._layers) {
      if (layer.zIndex === zIndex) {
        objects.push(...layer.getObjects());
      }
    }
    return objects;
  }
  /**
   * Get all objects of each Layer.
   * @returns {BaseObject[]} objects
   */
  getAllObjects() {
    const objects = [];
    this._layers.sort(sortRules);
    for (const layer of this._layers) {
      objects.push(...layer.getObjects());
    }
    return objects;
  }
  /**
   * Get objects which is visible and not in a group in each layer.
   * @returns BaseObject[]
   */
  getAllObjectsByOrder() {
    const objects = [];
    this._layers.sort(sortRules);
    for (const layer of this._layers) {
      objects.push(...layer.getObjectsByOrder());
    }
    return objects;
  }
  /**
   * get objects which is visible and not in a group.
   * @param isDesc
   * @returns BaseObject[]
   */
  getAllObjectsByDescOrder(isDesc = false) {
    const objects = [];
    const useSortRules = isDesc ? sortRulesByDesc : sortRules;
    this._layers.sort(useSortRules);
    for (const layer of this._layers) {
      objects.push(...layer.getObjectsByOrder().sort(useSortRules));
    }
    return objects;
  }
  /**
   * Get visible and evented objects.
   * @param isDesc
   * @returns {BaseObject[]} objects
   */
  getAllObjectsByOrderForPick(isDesc = false) {
    const objects = [];
    const useSortRules = isDesc ? sortRulesByDesc : sortRules;
    this._layers.sort(useSortRules);
    for (const layer of this._layers) {
      objects.push(...layer.getObjectsByOrderForPick().sort(useSortRules));
    }
    return objects;
  }
  /**
   * Get object in all layers by okey.
   * @param oKey
   * @returns
   */
  getObject(oKey) {
    for (const layer of this._layers) {
      const objects = layer.getObjectsByOrder();
      for (const object of objects) {
        if (object.oKey === oKey) {
          return object;
        }
      }
    }
  }
  getObjectIncludeInGroup(oKey) {
    for (const layer of this._layers) {
      const objects = layer.getObjects();
      for (const object of objects) {
        if (object.oKey === oKey) {
          return object;
        }
      }
    }
  }
  fuzzyMathObjects(oKey, matchStart = false) {
    const results = [];
    for (const layer of this._layers) {
      const objects = layer.getObjectsByOrder();
      for (const object of objects) {
        if (matchStart ? object.oKey.startsWith(oKey) : object.oKey.indexOf(oKey) > -1) {
          results.push(object);
        }
      }
    }
    return results;
  }
  addViewport(...viewport) {
    this._viewports.push(...viewport);
    return this;
  }
  removeViewport(key) {
    for (let i = 0, len = this._viewports.length; i < len; i++) {
      const viewport = this._viewports[i];
      if (viewport.viewportKey === key) {
        this._viewports.splice(i, 1);
        return viewport;
      }
    }
  }
  getViewports() {
    return this._viewports;
  }
  getMainViewport() {
    return this.getViewport(MAIN_VIEW_PORT_KEY);
  }
  getViewport(key) {
    for (const viewport of this._viewports) {
      if (viewport.viewportKey === key) {
        return viewport;
      }
    }
  }
  render(parentCtx) {
    var _a, _b;
    if (!this.isDirty()) {
      return;
    }
    !parentCtx && ((_a = this.getEngine()) == null ? void 0 : _a.clearCanvas());
    const layers = this._layers.sort(sortRules);
    const canvasInstance = (_b = this.getEngine()) == null ? void 0 : _b.getCanvas();
    this._beforeRender$.next(canvasInstance);
    for (let i = 0, len = layers.length; i < len; i++) {
      layers[i].render(parentCtx, i === len - 1);
    }
    this._afterRender$.next(canvasInstance);
  }
  async requestRender(parentCtx) {
    return new Promise((resolve, _reject) => {
      this.render(parentCtx);
      requestNewFrame(resolve);
    });
  }
  /**
   * create transformer if not exist, and then transformer attach to object that passed in by parameter.
   * @param o
   */
  attachTransformerTo(o) {
    var _a;
    if (!this._transformer) {
      this.initTransformer();
    }
    (_a = this._transformer) == null ? void 0 : _a.attachTo(o);
  }
  detachTransformerFrom(o) {
    var _a;
    (_a = this._transformer) == null ? void 0 : _a.detachFrom(o);
  }
  initTransformer(config) {
    if (this._transformer) {
      this._transformer.resetProps(config);
      return;
    }
    this._transformer = new Transformer(this, config);
  }
  getTransformerByCreate() {
    if (!this._transformer) {
      this.initTransformer();
    }
    return this._transformer;
  }
  getTransformer() {
    return this._transformer;
  }
  updateTransformerZero(left, top) {
    var _a;
    (_a = this._transformer) == null ? void 0 : _a.updateZeroPoint(left, top);
  }
  /**
   * Get viewport by cursor position.
   * Position is relative to canvas(event offsetXY).
   * @param coord
   * @returns
   */
  findViewportByPosToScene(coord) {
    return this._viewports.find((vp) => vp.isHit(coord));
  }
  getActiveViewportByCoord(coord) {
    coord = this.getCoordRelativeToViewport(coord);
    return this.findViewportByPosToScene(coord);
  }
  /**
   * @deprecated use `getScrollXYInfoByViewport` instead.
   * @param pos
   * @param viewPort
   */
  getVpScrollXYInfoByPosToVp(pos, viewPort) {
    return this.getScrollXYInfoByViewport(pos, viewPort);
  }
  /**
   * getViewportScrollXYInfo by viewport under cursor position
   * prev getScrollXYByRelativeCoords
   * @param pos
   * @param viewPort
   */
  getScrollXYInfoByViewport(pos, viewPort) {
    if (!viewPort) {
      viewPort = this.findViewportByPosToScene(pos) || this.getDefaultViewport();
    }
    return this.getViewportScrollXY(viewPort);
  }
  getDefaultViewport() {
    return this.getViewport("viewMain");
  }
  getViewportScrollXY(viewPort) {
    let x = 0;
    let y = 0;
    if (viewPort) {
      const actualX = viewPort.viewportScrollX || 0;
      const actualY = viewPort.viewportScrollY || 0;
      x += actualX;
      y += actualY;
    }
    return {
      x,
      y
    };
  }
  /**
   * @deprecated use `getCoordRelativeToViewport` instead
   * @param coord
   * @returns
   */
  getRelativeToViewportCoord(coord) {
    return this.getCoordRelativeToViewport(coord);
  }
  /**
   * Get coord to active viewport.
   * In a nested scene scenario, it is necessary to obtain the relative offsets layer by layer.
   *
   * origin name: getRelativeToViewportCoord
   * @param coord Coordinates to be converted.
   * @returns
   */
  getCoordRelativeToViewport(coord) {
    let parent = this.getParent();
    const parentList = [];
    while (parent) {
      if (parent.classType === "Scene" /* SCENE */ || parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        parentList.push(parent);
      }
      parent = (parent == null ? void 0 : parent.getParent) && (parent == null ? void 0 : parent.getParent());
    }
    parentList.reverse();
    for (const parent2 of parentList) {
      if (parent2.classType === "Scene" /* SCENE */) {
        const scene = parent2;
        const viewPort = scene.getActiveViewportByCoord(coord);
        if (viewPort) {
          const actualX = viewPort.viewportScrollX || 0;
          const actualY = viewPort.viewportScrollY || 0;
          coord = coord.addByPoint(actualX, actualY);
        }
      } else if (parent2.classType === "SceneViewer" /* SCENE_VIEWER */) {
        const sv = parent2;
        const transform = sv.transform.clone().invert();
        coord = transform.applyPoint(coord);
      }
    }
    return coord;
  }
  // transformToSceneCoord(coord: Vector2) {
  //     const pickedViewport = this.getActiveViewportByCoord(coord);
  //     return pickedViewport?.getRelativeVector(coord);
  // }
  clearLayer() {
    this._layers = [];
  }
  clearViewports() {
    this._viewports = [];
  }
  getPrecisionScale() {
    var _a;
    const pixelRatio = ((_a = this.getEngine()) == null ? void 0 : _a.getPixelRatio()) || 1;
    const { scaleX, scaleY } = this.getAncestorScale();
    return {
      scaleX: scaleX * pixelRatio,
      scaleY: scaleY * pixelRatio
    };
  }
  dispose() {
    var _a, _b, _c;
    let layers = [...this.getLayers()];
    layers.forEach((layer) => {
      layer.dispose();
    });
    layers = [];
    let viewports = [...this.getViewports()];
    viewports.forEach((viewport) => {
      viewport.dispose();
    });
    viewports = [];
    this.clearLayer();
    this.clearViewports();
    this.detachControl();
    (_a = this.onTransformChange$) == null ? void 0 : _a.complete();
    (_b = this._inputManager) == null ? void 0 : _b.dispose();
    this._inputManager = null;
    (_c = this._transformer) == null ? void 0 : _c.dispose();
    this._transformer = null;
    this.onFileLoaded$.complete();
    this.onPointerDown$.complete();
    this.onPointerMove$.complete();
    this.onPointerUp$.complete();
    this.onPointerEnter$.complete();
    this.onPointerLeave$.complete();
    this.onPointerOut$.complete();
    this.onPointerCancel$.complete();
    this.onDragEnter$.complete();
    this.onDragOver$.complete();
    this.onDragLeave$.complete();
    this.onDrop$.complete();
    this.onDblclick$.complete();
    this.onTripleClick$.complete();
    this.onMouseWheel$.complete();
    this.onKeyDown$.complete();
    this.onKeyUp$.complete();
    this._addObject$.complete();
    super.dispose();
  }
  /**
   * Get the object under the pointer, if scene.event is disabled, return null.
   * @param {Vector2} coord
   * @return {Nullable<BaseObject | Scene>} object under the pointer
   */
  pick(coord) {
    let pickedViewport = this.getActiveViewportByCoord(coord);
    if (!pickedViewport) {
      pickedViewport = this._viewports[0];
    }
    if (!this.objectsEvented || !pickedViewport) {
      return null;
    }
    const scrollBarRect = pickedViewport.pickScrollBar(coord);
    if (scrollBarRect) {
      return scrollBarRect;
    }
    const vecFromSheetContent = pickedViewport.transformVector2SceneCoord(coord);
    let isPickedObject = null;
    const objectOrder = this.getAllObjectsByOrderForPick().reverse();
    const objectLength = objectOrder.length;
    for (let i = 0; i < objectLength; i++) {
      const o = objectOrder[i];
      if (!o.visible || !o.evented || o.classType === "Group" /* GROUP */) {
        continue;
      }
      const svCoord = vecFromSheetContent;
      if (o.isHit(svCoord)) {
        if (o.classType === "SceneViewer" /* SCENE_VIEWER */) {
          const pickedObject = o.pick(svCoord);
          if (pickedObject) {
            isPickedObject = pickedObject;
          } else {
            isPickedObject = o.getActiveSubScene();
          }
        } else {
          isPickedObject = o;
        }
        break;
      } else if (o.classType === "SceneViewer" /* SCENE_VIEWER */ && o.allowSelectedClipElement()) {
        const pickedObject = o.pick(svCoord);
        if (pickedObject) {
          isPickedObject = pickedObject;
          break;
        }
      }
    }
    if (!isPickedObject && this._parent.classType === "Engine" /* ENGINE */) {
      return this;
    }
    return isPickedObject;
  }
  // triggerKeyDown(evt: IKeyboardEvent) {
  //     this.onKeyDown$.emitEvent(evt);
  // if (this._parent instanceof SceneViewer) {
  //     this._parent?.triggerKeyDown(evt);
  // }
  // }
  // triggerKeyUp(evt: IKeyboardEvent) {
  //     this.onKeyUp$.emitEvent(evt);
  // if (this._parent instanceof SceneViewer) {
  //     this._parent?.triggerKeyUp(evt);
  // }
  // }
  triggerPointerUp(evt) {
    var _a, _b;
    if (!((_a = this.onPointerUp$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerUp(evt);
      return false;
    }
    return true;
  }
  triggerMouseWheel(evt) {
    var _a, _b;
    if (!((_a = this.onMouseWheel$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerMouseWheel(evt);
      return false;
    }
    return true;
  }
  triggerPointerMove(evt) {
    var _a, _b;
    if (!((_a = this.onPointerMove$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerMove(evt);
      return false;
    }
    return true;
  }
  triggerDblclick(evt) {
    var _a, _b;
    if (!((_a = this.onDblclick$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerDblclick(evt);
      return false;
    }
    return true;
  }
  triggerTripleClick(evt) {
    var _a, _b;
    if (!((_a = this.onTripleClick$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerTripleClick(evt);
      return false;
    }
    return true;
  }
  triggerPointerDown(evt) {
    var _a, _b;
    if (!((_a = this.onPointerDown$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerDown(evt);
      return false;
    }
    return true;
  }
  triggerPointerOut(evt) {
    var _a;
    if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_a = this._parent) == null ? void 0 : _a.triggerPointerOut(evt);
      return false;
    }
    return true;
  }
  triggerPointerLeave(evt) {
    var _a, _b;
    if (!((_a = this.onPointerLeave$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerLeave(evt);
      return false;
    }
    return true;
  }
  triggerPointerOver(evt) {
    var _a;
    if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_a = this._parent) == null ? void 0 : _a.triggerPointerOver(evt);
      return false;
    }
    return true;
  }
  triggerPointerCancel(evt) {
    var _a;
    if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_a = this._parent) == null ? void 0 : _a.triggerPointerCancel(evt);
      return false;
    }
    return true;
  }
  triggerPointerEnter(evt) {
    var _a, _b;
    if (!((_a = this.onPointerEnter$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerPointerEnter(evt);
      return false;
    }
    return true;
  }
  triggerDragLeave(evt) {
    var _a, _b;
    if (!((_a = this.onDragLeave$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerDragLeave(evt);
      return false;
    }
    return true;
  }
  triggerDragOver(evt) {
    var _a, _b;
    if (!((_a = this.onDragOver$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerDragOver(evt);
      return false;
    }
    return true;
  }
  triggerDragEnter(evt) {
    var _a, _b;
    if (!((_a = this.onDragEnter$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerDragEnter(evt);
      return false;
    }
    return true;
  }
  triggerDrop(evt) {
    var _a, _b;
    if (!((_a = this.onDrop$.emitEvent(evt)) == null ? void 0 : _a.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      (_b = this._parent) == null ? void 0 : _b.triggerDrop(evt);
      return false;
    }
    return true;
  }
  _createDefaultLayer(zIndex = 1) {
    const defaultLayer = new Layer(this, [], zIndex);
    this.addLayer(defaultLayer);
    return defaultLayer;
  }
  /**
   * Triggered when scale, resize of scene.
   * origin name: _setTransForm
   *
   */
  _transformHandler() {
    const composeResult = Transform.create().composeMatrix({
      scaleX: this.scaleX,
      scaleY: this.scaleY
    });
    this.transform = composeResult;
    this.getViewports().forEach((vp) => {
      vp.resetCanvasSizeAndUpdateScroll();
    });
    this.makeDirty(true);
  }
  /**
   * If scene.event is disabled, scene.pick(cursor Pos) return null.
   * Then only scene itself can response to pointer event, all objects under the scene would not.
   * see sceneInputManager@_onPointerMove
   */
  // 禁用对象事件
  disableObjectsEvent() {
    this._evented = false;
  }
  enableObjectsEvent() {
    this._evented = true;
  }
  get capturedObject() {
    return this._capturedObject;
  }
  setCaptureObject(o) {
    this._capturedObject = o;
  }
  releaseCapturedObject() {
    this._capturedObject = null;
  }
};

// ../packages/engine-render/src/render-manager/render-unit.ts
var RenderUnit = class extends Disposable {
  constructor(init, parentInjector) {
    super();
    __publicField(this, "isRenderUnit", true);
    __publicField(this, "_activated$", new BehaviorSubject(true));
    __publicField(this, "activated$", this._activated$.pipe(distinctUntilChanged()));
    __publicField(this, "_injector");
    __publicField(this, "_renderContext");
    this._injector = parentInjector.createChild();
    this._renderContext = {
      unit: init.unit,
      unitId: init.unit.getUnitId(),
      type: init.unit.type,
      components: /* @__PURE__ */ new Map(),
      mainComponent: null,
      isMainScene: init.isMainScene,
      engine: init.engine,
      scene: init.scene,
      activated$: this.activated$,
      activate: () => this._activated$.next(true),
      deactivate: () => this._activated$.next(false)
    };
  }
  get unitId() {
    return this._renderContext.unitId;
  }
  get type() {
    return this._renderContext.type;
  }
  set isMainScene(is) {
    this._renderContext.isMainScene = is;
  }
  get isMainScene() {
    return this._renderContext.isMainScene;
  }
  set engine(engine) {
    this._renderContext.engine = engine;
  }
  get engine() {
    return this._renderContext.engine;
  }
  set mainComponent(component) {
    this._renderContext.mainComponent = component;
  }
  get mainComponent() {
    return this._renderContext.mainComponent;
  }
  set scene(scene) {
    this._renderContext.scene = scene;
  }
  get scene() {
    return this._renderContext.scene;
  }
  get components() {
    return this._renderContext.components;
  }
  dispose() {
    this._injector.dispose();
    super.dispose();
    this._activated$.next(false);
    this._activated$.complete();
  }
  /**
   * Get a dependency from the RenderUnit's injector.
   */
  with(dependency) {
    return this._injector.get(dependency);
  }
  /**
   * Add render dependencies to the RenderUnit's injector. Note that the dependencies would be initialized immediately
   * after being added.
   */
  addRenderDependencies(dependencies) {
    this._initDependencies(dependencies);
  }
  _initDependencies(dependencies) {
    const j = this._injector;
    dependencies.forEach((dep) => {
      const [identifier, implOrNull] = Array.isArray(dep) ? dep : [dep, null];
      if (!implOrNull) {
        j.add([identifier, {
          useFactory: () => j.createInstance(identifier, this._renderContext)
        }]);
      } else if (isClassDependencyItem(implOrNull)) {
        j.add([identifier, {
          useFactory: () => j.createInstance(implOrNull.useClass, this._renderContext)
        }]);
      } else {
        throw new Error("[RenderUnit]: render dependency could only be an class!");
      }
    });
    dependencies.forEach((dep) => {
      const [identifier] = Array.isArray(dep) ? dep : [dep, null];
      j.get(identifier);
    });
  }
  getRenderContext() {
    return this._renderContext;
  }
  activate() {
    this._renderContext.activate();
  }
  deactivate() {
    this._renderContext.deactivate();
  }
};
RenderUnit = __decorateClass([
  __decorateParam(1, Inject(Injector))
], RenderUnit);

// ../packages/engine-render/src/render-manager/render-manager.service.ts
var DEFAULT_SCENE_SIZE = { width: 1500, height: 1e3 };
var SCENE_NAMESPACE = "_UNIVER_SCENE_";
var RenderManagerService = class extends Disposable {
  constructor(_injector, _univerInstanceService) {
    super();
    this._injector = _injector;
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_defaultEngine");
    __publicField(this, "_renderMap", /* @__PURE__ */ new Map());
    __publicField(this, "_createRender$", new Subject());
    /** @deprecated */
    __publicField(this, "createRender$", this._createRender$.asObservable());
    __publicField(this, "_renderCreated$", new Subject());
    __publicField(this, "created$", this._renderCreated$.asObservable());
    __publicField(this, "_renderDisposed$", new Subject());
    __publicField(this, "disposed$", this._renderDisposed$.asObservable());
    __publicField(this, "_renderDependencies", /* @__PURE__ */ new Map());
  }
  get defaultEngine() {
    if (!this._defaultEngine) {
      this._defaultEngine = new Engine();
    }
    return this._defaultEngine;
  }
  dispose() {
    super.dispose();
    this._renderMap.forEach((item) => this._disposeItem(item));
    this._renderDependencies.clear();
    this._renderMap.clear();
    this._renderCreated$.complete();
    this._renderDisposed$.complete();
  }
  registerRenderModules(type2, deps) {
    if (!this._renderDependencies.has(type2)) {
      this._renderDependencies.set(type2, []);
    }
    const dependencies = this._renderDependencies.get(type2);
    dependencies.push(...deps);
    for (const [_819, render2] of this._renderMap) {
      const renderType = render2.type;
      if (renderType === type2) {
        this._tryAddRenderDependencies(render2, deps);
      }
    }
    return toDisposable(() => {
      deps.forEach((dep) => remove(dependencies, dep));
    });
  }
  /**
   * add dep to _renderDependencies(type, dep)
   * @param type
   * @param depCtor
   */
  registerRenderModule(type2, depCtor) {
    if (!this._renderDependencies.has(type2)) {
      this._renderDependencies.set(type2, []);
    }
    const dependencies = this._renderDependencies.get(type2);
    dependencies.push(depCtor);
    for (const [_819, render2] of this._renderMap) {
      const renderType = render2.type;
      if (renderType === type2) {
        this._tryAddRenderDependencies(render2, [depCtor]);
      }
    }
    return toDisposable(() => remove(dependencies, depCtor));
  }
  /**
   * get render dependencies from _renderDependencies
   * @param type
   * @returns Dependency[]
   */
  _getRenderDepsByType(type2) {
    var _a;
    return Array.from((_a = this._renderDependencies.get(type2)) != null ? _a : []);
  }
  create(unitId) {
    this._createRender$.next(unitId);
  }
  /**
   * create renderUnit & init deps from renderDependencies
   * @param unitId
   * @returns renderUnit:IRender
   */
  createRender(unitId) {
    const renderer = this._createRender(unitId, new Engine(unitId));
    this._renderCreated$.next(renderer);
    return renderer;
  }
  getAllRenderersOfType(type2) {
    const renderUnits = [];
    for (const [_819, render2] of this._renderMap) {
      const renderType = render2.type;
      if (renderType === type2) {
        renderUnits.push(render2);
      }
    }
    return renderUnits;
  }
  /**
   * init deps by injector.get(dep), and injector derives from renderer.
   * @param renderer
   * @param deps
   */
  _tryAddRenderDependencies(renderer, deps) {
    if (renderer instanceof RenderUnit) {
      renderer.addRenderDependencies(deps);
    }
  }
  /**
   * create renderUnit & init deps from renderDependencies by renderUnit's type
   * @param unitId
   * @param engine
   * @param isMainScene
   * @returns renderUnit:IRender
   */
  _createRender(unitId, engine, isMainScene = true) {
    const existItem = this.getRenderById(unitId);
    let shouldDestroyEngine = true;
    if (existItem != null) {
      const existEngine = existItem.engine;
      if (existEngine === engine) {
        shouldDestroyEngine = false;
      }
    }
    this._disposeItem(existItem, shouldDestroyEngine);
    const { width, height } = DEFAULT_SCENE_SIZE;
    const scene = new Scene(SCENE_NAMESPACE + unitId, engine, {
      width,
      height
    });
    const unit = this._univerInstanceService.getUnit(unitId);
    let renderUnit;
    if (unit) {
      const type2 = this._univerInstanceService.getUnitType(unitId);
      const ctorOfDeps = this._getRenderDepsByType(type2);
      renderUnit = this._injector.createInstance(RenderUnit, {
        unit,
        engine,
        scene,
        isMainScene
      });
      this._addRenderUnit(unitId, renderUnit);
      this._tryAddRenderDependencies(renderUnit, ctorOfDeps);
    } else {
      renderUnit = {
        isThumbNail: true,
        type: O.UNIVER_SLIDE,
        unitId,
        engine,
        scene,
        mainComponent: null,
        components: /* @__PURE__ */ new Map(),
        isMainScene,
        // @ts-ignore
        with(_dependency) {
          return null;
        }
      };
      this._addRenderUnit(unitId, renderUnit);
    }
    return renderUnit;
  }
  addRender(unitId, renderUnit) {
    this._addRenderUnit(unitId, renderUnit);
  }
  _addRenderUnit(unitId, renderUnit) {
    this._renderMap.set(unitId, renderUnit);
  }
  removeRender(unitId) {
    const item = this._renderMap.get(unitId);
    if (item != null) {
      this._disposeItem(item);
    }
    this._renderMap.delete(unitId);
  }
  has(unitId) {
    return this._renderMap.has(unitId);
  }
  /**
   * @deprecated use getRenderUnitById instead
   * Get RenderUnit from this._renderMap.
   * @param unitId
   * @returns RenderUnit, aka IRender
   */
  getRenderById(unitId) {
    return this._renderMap.get(unitId);
  }
  getRenderUnitById(unitId) {
    return this._renderMap.get(unitId);
  }
  getRenderAll() {
    return this._renderMap;
  }
  _disposeItem(item, shouldDestroyEngine = true) {
    if (item == null) {
      return;
    }
    const { engine, scene, components } = item;
    components == null ? void 0 : components.forEach((component) => component.dispose());
    scene.dispose();
    if (isDisposable(item)) {
      item.dispose();
    }
    if (shouldDestroyEngine) {
      engine.dispose();
    }
    this._renderDisposed$.next(item.unitId);
  }
};
RenderManagerService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IUniverInstanceService)
], RenderManagerService);
var IRenderManagerService = createIdentifier("engine-render.render-manager.service");
function isDisposable(thing) {
  return !!thing && typeof thing.dispose === "function";
}
function getCurrentTypeOfRenderer(type2, instanceService, renderManageService) {
  const currentUnit = instanceService.getCurrentUnitForType(type2);
  if (currentUnit == null) {
    return null;
  }
  return renderManageService.getRenderUnitById(currentUnit.getUnitId());
}
function withCurrentTypeOfRenderer(type2, id, instanceService, renderManagerService) {
  const renderer = getCurrentTypeOfRenderer(type2, instanceService, renderManagerService);
  if (renderer) return renderer.with(id);
  return null;
}

// ../packages/engine-render/src/plugin.ts
var IRenderingEngine = createIdentifier("univer.render-engine");
var PLUGIN_NAME = "UNIVER_RENDER_ENGINE_PLUGIN";
var UniverRenderEnginePlugin = class extends Plugin {
  constructor(_config = defaultPluginConfig, _injector, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    const { ...rest } = merge_default(
      {},
      defaultPluginConfig,
      this._config
    );
    this._configService.setConfig(ENGINE_RENDER_PLUGIN_CONFIG_KEY, rest);
    registerDependencies(this._injector, [
      [IRenderingEngine, { useFactory: () => new Engine() }],
      [IRenderManagerService, { useClass: RenderManagerService }]
    ]);
  }
};
__publicField(UniverRenderEnginePlugin, "pluginName", PLUGIN_NAME);
UniverRenderEnginePlugin = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], UniverRenderEnginePlugin);

// ../packages/engine-render/src/basics/document-node-tools.ts
function hasListGlyph(glyph) {
  var _a;
  const divide = glyph == null ? void 0 : glyph.parent;
  if (divide == null) {
    return false;
  }
  const glyphGroup = divide.glyphGroup;
  return ((_a = glyphGroup[0]) == null ? void 0 : _a.glyphType) === 2 /* LIST */;
}
function isIndentByGlyph(glyph, body) {
  const paragraph = getParagraphByGlyph(glyph, body);
  if (paragraph == null) {
    return false;
  }
  const { paragraphStyle } = paragraph;
  if (paragraphStyle == null) {
    return false;
  }
  return checkParagraphHasIndentByStyle(paragraphStyle);
}
function isFirstGlyph(glyph) {
  const divide = glyph == null ? void 0 : glyph.parent;
  const line2 = divide == null ? void 0 : divide.parent;
  const glyphGroup = divide == null ? void 0 : divide.glyphGroup;
  const divides = line2 == null ? void 0 : line2.divides;
  if (glyphGroup && glyph && divides && divide) {
    const glyphIndex = glyphGroup.indexOf(glyph);
    const divideIndex = divides.indexOf(divide);
    if (divideIndex === 0 && glyphIndex === 0) {
      return true;
    }
    if (divideIndex === 0 && glyphIndex === 1 && glyphGroup[0].glyphType === 2 /* LIST */) {
      return true;
    }
  }
  return false;
}
function getParagraphByGlyph(glyph, body) {
  var _a, _b;
  const line2 = (_a = glyph == null ? void 0 : glyph.parent) == null ? void 0 : _a.parent;
  if (line2 == null || body == null) {
    return;
  }
  const paragraphs = body.paragraphs;
  if (paragraphs == null) {
    return;
  }
  for (let i = 0; i < paragraphs.length; i++) {
    const paragraph = paragraphs[i];
    const prevParagraph = paragraphs[i - 1];
    if (paragraph.startIndex === line2.paragraphIndex) {
      return {
        ...paragraph,
        paragraphStart: ((_b = prevParagraph == null ? void 0 : prevParagraph.startIndex) != null ? _b : -1) + 1,
        paragraphEnd: paragraph.startIndex
      };
    }
  }
}

// ../packages/engine-render/src/basics/path2.ts
var INITIAL_Path2 = [new Vector2(0, 0), new Vector2(1, 1)];
var Path2 = class {
  constructor(_lines = INITIAL_Path2) {
    this._lines = _lines;
  }
  intersection(lines) {
    if (this._lines.length < 1 || lines.length < 1) {
      return;
    }
    const crossPoint = [];
    for (let o = 1; o < this._lines.length; o++) {
      const from = this._lines[o - 1];
      const to = this._lines[o];
      for (let n = 1; n < lines.length; n++) {
        const contrastFrom = this._lines[o - 1];
        const contrastTo = this._lines[o];
        const point = this._intersection(
          {
            from,
            to
          },
          {
            from: contrastFrom,
            to: contrastTo
          }
        );
        if (point) {
          crossPoint.push(point);
        }
      }
    }
    return crossPoint;
  }
  _intersection(line1, line2) {
    const a = line1.from;
    const b = line1.to;
    const c = line2.from;
    const d = line2.to;
    const area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
    const area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);
    if (area_abc * area_abd >= 0) {
      return false;
    }
    const area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);
    const area_cdb = area_cda + area_abc - area_abd;
    if (area_cda * area_cdb >= 0) {
      return false;
    }
    const t2 = area_cda / (area_abd - area_abc);
    const dx = t2 * (b.x - a.x);
    const dy = t2 * (b.y - a.y);
    return new Vector2(a.x + dx, a.y + dy);
  }
};

// ../packages/engine-render/src/basics/range.ts
var NORMAL_TEXT_SELECTION_PLUGIN_STYLE = {
  strokeWidth: 1.5,
  stroke: "rgba(0, 0, 0, 0)",
  strokeActive: "rgba(0, 0, 0, 1)",
  fill: "rgba(0, 0, 0, 0.2)"
};

// ../packages/engine-render/src/basics/text-rotation.ts
var VERTICAL_ROTATE_ANGLE = 90;
function convertTextRotation(textRotation) {
  const { a: angle = 0, v: isVertical = 0 /* FALSE */ } = textRotation || { a: 0, v: 0 /* FALSE */ };
  let centerAngle = 0;
  let vertexAngle = angle;
  if (isVertical === 1 /* TRUE */) {
    centerAngle = VERTICAL_ROTATE_ANGLE;
    vertexAngle = VERTICAL_ROTATE_ANGLE;
  }
  return { centerAngle, vertexAngle };
}

// ../packages/engine-render/src/basics/position.ts
function getOffsetRectForDom(ele) {
  const box = ele.getBoundingClientRect();
  const body = document.body;
  const docElem = document.documentElement;
  const scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
  const scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
  const clientTop = docElem.clientTop || body.clientTop;
  const clientLeft = docElem.clientLeft || body.clientLeft;
  const top = box.top + scrollTop - clientTop;
  const left = box.left + scrollLeft - clientLeft;
  return {
    // Math.round 兼容火狐浏览器 bug
    top,
    left
  };
}

// ../packages/engine-render/src/components/component.ts
var RenderComponent = class extends BaseObject {
  constructor() {
    super(...arguments);
    __publicField(this, "_extensions", /* @__PURE__ */ new Map());
  }
  get extensions() {
    return this._extensions;
  }
  register(...extensions) {
    const disposableCollection = new DisposableCollection();
    for (const extension of extensions) {
      extension.parent = this;
      this._extensions.set(extension.uKey, extension);
      disposableCollection.add(
        toDisposable(() => {
          this._extensions.delete(extension.uKey);
          extension.parent = null;
        })
      );
    }
    this.disposeWithMe(disposableCollection);
    return disposableCollection;
  }
  getExtensionsByOrder() {
    const extensionArray = Array.from(this._extensions.values());
    extensionArray.sort(sortRules);
    return extensionArray;
  }
  getExtensionByKey(uKey) {
    return this._extensions.get(uKey);
  }
  draw(ctx, bounds) {
  }
  dispose() {
    super.dispose();
    for (const extension of this._extensions.values()) {
      extension.dispose();
    }
    this._extensions.clear();
  }
};

// ../packages/engine-render/src/components/extension.ts
var ComponentExtension = class {
  constructor() {
    __publicField(this, "uKey", "");
    __publicField(this, "type");
    __publicField(this, "Z_INDEX", 0);
    __publicField(this, "parent");
    __publicField(this, "translateX", 0);
    __publicField(this, "translateY", 0);
    __publicField(this, "extensionOffset", {});
  }
  get zIndex() {
    return this.Z_INDEX;
  }
  draw(_ctx, _parentScale, _skeleton, _diff, _more) {
  }
  clearCache() {
  }
  _getScale(parentScale) {
    return getScale(parentScale);
  }
  dispose() {
    this.extensionOffset = {};
    this.parent = null;
  }
};
var SpreadsheetExtensionRegistry = Registry.create();
var SheetRowHeaderExtensionRegistry = Registry.create();
var SheetColumnHeaderExtensionRegistry = Registry.create();
var DocumentsSpanAndLineExtensionRegistry = Registry.create();

// ../packages/engine-render/src/components/sheets/sheet-component.ts
var SheetComponent = class extends RenderComponent {
  constructor(oKey, _skeleton) {
    super(oKey);
    this._skeleton = _skeleton;
  }
  getSkeleton() {
    return this._skeleton;
  }
  updateSkeleton(spreadsheetSkeleton) {
    var _a;
    this._skeleton = spreadsheetSkeleton;
    (_a = this.getScene()) == null ? void 0 : _a.updateTransformerZero(spreadsheetSkeleton.rowHeaderWidth, spreadsheetSkeleton.columnHeaderHeight);
  }
  render(mainCtx, bounds) {
    if (!this.visible) {
      this.makeDirty(false);
      return this;
    }
    mainCtx.save();
    this._draw(mainCtx, bounds);
    mainCtx.restore();
  }
  getParentScale() {
    let { scaleX = 1, scaleY = 1 } = this.parent;
    if (this.parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      scaleX = this.parent.ancestorScaleX || 1;
      scaleY = this.parent.ancestorScaleY || 1;
    }
    return {
      scaleX,
      scaleY
    };
  }
  getScrollXYByRelativeCoords(coord) {
    return { x: 0, y: 0 };
  }
  /**
   * TODO: DR-Univer, fix as unknown as
   */
  dispose() {
    super.dispose();
    this._skeleton = null;
  }
};
var SpreadsheetHeader = class extends SheetComponent {
  _draw(ctx, bounds) {
    this.draw(ctx, bounds);
  }
};

// ../packages/engine-render/src/components/sheets/column-header.ts
var SpreadsheetColumnHeader = class extends SpreadsheetHeader {
  constructor(oKey, spreadsheetSkeleton) {
    super(oKey, spreadsheetSkeleton);
    __publicField(this, "_columnHeaderLayoutExtension");
    this._initialDefaultExtension();
    this.makeDirty(true);
  }
  getDocuments() {
    throw new Error("Method not implemented.");
  }
  getNoMergeCellPositionByIndex(rowIndex, columnIndex) {
    throw new Error("Method not implemented.");
  }
  getSelectionBounding(startRow, startColumn, endRow, endColumn) {
    throw new Error("Method not implemented.");
  }
  get columnHeaderLayoutExtension() {
    return this._columnHeaderLayoutExtension;
  }
  draw(ctx, bounds) {
    const spreadsheetSkeleton = this.getSkeleton();
    if (!spreadsheetSkeleton) return;
    const parentScale = this.getParentScale();
    spreadsheetSkeleton.updateVisibleRange(bounds);
    const segment = spreadsheetSkeleton.rowColumnSegment;
    if (!segment) return;
    if (segment.startColumn === -1 && segment.endColumn === -1) return;
    const { rowHeaderWidth } = spreadsheetSkeleton;
    ctx.translateWithPrecision(rowHeaderWidth, 0);
    const extensions = this.getExtensionsByOrder();
    for (const extension of extensions) {
      extension.draw(ctx, parentScale, spreadsheetSkeleton);
    }
  }
  isHit(coord) {
    const oCoord = this.getInverseCoord(coord);
    const skeleton = this.getSkeleton();
    if (!skeleton) {
      return false;
    }
    const { rowHeaderWidth, columnHeaderHeight } = skeleton;
    if (oCoord.x > rowHeaderWidth && oCoord.y >= 0 && oCoord.y <= columnHeaderHeight) {
      return true;
    }
    return false;
  }
  _initialDefaultExtension() {
    SheetColumnHeaderExtensionRegistry.getData().forEach((extension) => {
      this.register(extension);
    });
    this._columnHeaderLayoutExtension = this.getExtensionByKey(
      "DefaultColumnHeaderLayoutExtension"
    );
  }
  /**
   * Customize column header, such as custom header text and background.
   * @param cfg
   */
  setCustomHeader(cfg) {
    this.makeDirty(true);
    this._columnHeaderLayoutExtension.configHeaderColumn(cfg);
  }
};

// ../packages/engine-render/src/components/sheets/constants.ts
var FONT_EXTENSION_Z_INDEX = 45;
var EXPAND_SIZE_FOR_RENDER_OVERFLOW = 20;
var sheetContentViewportKeys = ["viewMain" /* VIEW_MAIN */, "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */, "viewMainTop" /* VIEW_MAIN_TOP */, "viewMainLeft" /* VIEW_MAIN_LEFT */];
var sheetHeaderViewportKeys = ["viewRowTop" /* VIEW_ROW_TOP */, "viewRowBottom" /* VIEW_ROW_BOTTOM */, "viewColumnLeft" /* VIEW_COLUMN_LEFT */, "viewColumnRight" /* VIEW_COLUMN_RIGHT */, "viewLeftTop" /* VIEW_LEFT_TOP */];
var MEASURE_EXTENT = 1e4;
var MEASURE_EXTENT_FOR_PARAGRAPH = MEASURE_EXTENT / 10;

// ../packages/engine-render/src/components/sheets/extensions/sheet-extension.ts
var SHEET_EXTENSION_PREFIX = "sheet-ext-";
var SheetExtension = class extends ComponentExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "type", 0 /* GRID */);
  }
  isRenderDiffRangesByCell(rangeP, diffRanges) {
    if (diffRanges == null || diffRanges.length === 0) {
      return true;
    }
    for (const range of diffRanges) {
      const { startRow, startColumn, endRow, endColumn } = range;
      const isIntersect = Rectangle.intersects(rangeP, {
        startRow,
        endRow,
        startColumn,
        endColumn
      });
      if (isIntersect) {
        return true;
      }
    }
    return false;
  }
  isRenderDiffRangesByColumn(curStartColumn, curEndColumn, diffRanges) {
    if (diffRanges == null || diffRanges.length === 0) {
      return true;
    }
    for (const range of diffRanges) {
      const { startColumn, endColumn } = range;
      const isIntersect = Rectangle.intersects(
        {
          startRow: 0,
          endRow: 0,
          startColumn: curStartColumn,
          endColumn: curEndColumn
        },
        {
          startRow: 0,
          endRow: 0,
          startColumn,
          endColumn
        }
      );
      if (isIntersect) {
        return true;
      }
    }
    return false;
  }
  isRenderDiffRangesByRow(curStartRow, curEndRow, diffRanges) {
    if (diffRanges == null || diffRanges.length === 0) {
      return true;
    }
    for (const range of diffRanges) {
      const { startRow, endRow } = range;
      const isIntersect = Rectangle.intersects(
        {
          startRow: curStartRow,
          endRow: curEndRow,
          startColumn: 0,
          endColumn: 0
        },
        {
          startRow,
          endRow,
          startColumn: 0,
          endColumn: 0
        }
      );
      if (isIntersect) {
        return true;
      }
    }
    return false;
  }
  /**
   * Check if row range is in view ranges
   * @param curStartRow
   * @param curEndRow
   * @param viewranges
   */
  isRowInRanges(curStartRow, curEndRow, viewranges) {
    if (viewranges == null || viewranges.length === 0) {
      return true;
    }
    for (const range of viewranges) {
      const { startRow, endRow } = range;
      if (curStartRow >= startRow && curStartRow <= endRow) {
        return true;
      }
      if (curEndRow >= startRow && curEndRow <= endRow) {
        return true;
      }
      const isIntersect = Rectangle.intersects(
        {
          startRow: curStartRow,
          endRow: curEndRow,
          startColumn: 0,
          endColumn: 0
        },
        {
          startRow,
          endRow,
          startColumn: 0,
          endColumn: 0
        }
      );
      if (isIntersect) {
        return true;
      }
    }
    return false;
  }
};

// ../packages/engine-render/src/components/sheets/extensions/background.ts
var UNIQUE_KEY = "DefaultBackgroundExtension";
var DOC_EXTENSION_Z_INDEX = 21;
var PRINTING_Z_INDEX = 21;
var Background = class extends SheetExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "uKey", UNIQUE_KEY);
    __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX);
    __publicField(this, "PRINTING_Z_INDEX", PRINTING_Z_INDEX);
  }
  get zIndex() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.isPrinting) ? this.PRINTING_Z_INDEX : this.Z_INDEX;
  }
  // eslint-disable-next-line max-lines-per-function
  draw(ctx, _parentScale, spreadsheetSkeleton, diffRanges, { viewRanges, checkOutOfViewBound }) {
    const { stylesCache, worksheet, rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
    const { background: bgMatrixCacheByColor, backgroundPositions } = stylesCache;
    if (!worksheet || !bgMatrixCacheByColor) return;
    if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
      return;
    }
    ctx.save();
    const { scaleX, scaleY } = ctx.getScale();
    const renderBGContext = {
      ctx,
      backgroundPositions,
      scaleX,
      scaleY,
      checkOutOfViewBound,
      viewRanges,
      diffRanges,
      spreadsheetSkeleton
    };
    const mergeRanges = [];
    viewRanges.forEach((range) => {
      const intersectMergeRangesInViewRanges = spreadsheetSkeleton.worksheet.getMergedCellRange(range.startRow, range.startColumn, range.endRow, range.endColumn);
      mergeRanges.push(...intersectMergeRangesInViewRanges);
    });
    const renderBGCore = (rgb) => {
      const bgColorMatrix = bgMatrixCacheByColor[rgb];
      const rangeForEachFn = (row, col, bgConfigParam) => {
        const index = spreadsheetSkeleton.worksheet.getSpanModel().getMergeDataIndex(row, col);
        if (index !== -1) {
          return;
        }
        const cellInfo = spreadsheetSkeleton.getCellByIndexWithNoHeader(row, col);
        if (!cellInfo) return;
        const bgConfig = bgConfigParam || bgColorMatrix.getValue(row, col);
        if (bgConfig) {
          renderBGContext.cellInfo = cellInfo;
          this.renderBGByCell(renderBGContext, row, col);
        }
      };
      ctx.fillStyle = rgb || getColor([255, 255, 255]);
      const backgroundPaths = new Path2D();
      renderBGContext.backgroundPaths = backgroundPaths;
      ctx.beginPath();
      const matrixSize = bgColorMatrix.getSizeOf();
      const cellCountInRanges = viewRanges.reduce((sum, range) => {
        return sum + (range.endRow - range.startRow) * (range.endColumn - range.startColumn);
      }, 0);
      if (cellCountInRanges < matrixSize) {
        viewRanges.forEach((range) => {
          Range.foreach(range, rangeForEachFn);
        });
      } else {
        bgColorMatrix.forValue(rangeForEachFn);
      }
      ctx.fill(backgroundPaths);
      ctx.closePath();
    };
    const renderBGForMergedCells = (rgb) => {
      const bgColorMatrix = bgMatrixCacheByColor[rgb];
      ctx.fillStyle = rgb || getColor([255, 255, 255]);
      const backgroundPaths = new Path2D();
      renderBGContext.backgroundPaths = backgroundPaths;
      ctx.beginPath();
      mergeRanges.forEach((range) => {
        const bgConfig = bgColorMatrix.getValue(range.startRow, range.startColumn);
        if (bgConfig) {
          const cellInfo = spreadsheetSkeleton.getCellWithCoordByIndex(range.startRow, range.startColumn, false);
          if (!cellInfo) return;
          renderBGContext.cellInfo = cellInfo;
          this.renderBGByCell(renderBGContext, range.startRow, range.startColumn);
        }
      });
      ctx.fill(backgroundPaths);
      ctx.closePath();
    };
    const rgbList = Object.keys(bgMatrixCacheByColor);
    for (let index = 0; index < rgbList.length; index++) {
      const rgb = rgbList[index];
      renderBGCore(rgb);
      renderBGForMergedCells(rgb);
    }
    ctx.restore();
  }
  renderBGByCell(bgContext, row, col) {
    const { spreadsheetSkeleton, backgroundPaths, scaleX, scaleY, viewRanges, diffRanges, cellInfo } = bgContext;
    let { startY, endY, startX, endX } = cellInfo;
    const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
    const renderRange = diffRanges && diffRanges.length > 0 ? diffRanges : viewRanges;
    startY = mergeInfo.startY;
    endY = mergeInfo.endY;
    startX = mergeInfo.startX;
    endX = mergeInfo.endX;
    if (!isMerged && !isMergedMainCell && !inViewRanges(renderRange, row, col)) {
      return true;
    }
    const visibleRow = spreadsheetSkeleton.worksheet.getRowVisible(row);
    const visibleCol = spreadsheetSkeleton.worksheet.getColVisible(col);
    if (!visibleRow || !visibleCol) return true;
    const startXPrecise = fixLineWidthByScale(startX, scaleX);
    const startYPrecise = fixLineWidthByScale(startY, scaleY);
    const endXPrecise = fixLineWidthByScale(endX, scaleX);
    const endYPrecise = fixLineWidthByScale(endY, scaleY);
    backgroundPaths.rect(startXPrecise, startYPrecise, endXPrecise - startXPrecise, endYPrecise - startYPrecise);
  }
};
SpreadsheetExtensionRegistry.add(Background);

// ../packages/engine-render/src/components/sheets/extensions/border.ts
var UNIQUE_KEY2 = "DefaultBorderExtension";
var BORDER_Z_INDEX = 50;
var Border = class extends SheetExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "uKey", UNIQUE_KEY2);
    __publicField(this, "Z_INDEX", BORDER_Z_INDEX);
    __publicField(this, "preStyle");
    __publicField(this, "preColor");
  }
  draw(ctx, _parentScale, spreadsheetSkeleton, diffRanges, { viewRanges }) {
    const { stylesCache, overflowCache, worksheet, rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
    if (!worksheet) return;
    if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
      return;
    }
    ctx.save();
    ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
    const precisionScale = this._getScale(ctx.getScale());
    const { border } = stylesCache;
    if (!border) return;
    const renderBorderContext = {
      ctx,
      precisionScale,
      overflowCache,
      diffRanges,
      viewRanges,
      spreadsheetSkeleton
    };
    ctx.beginPath();
    viewRanges.forEach((range) => {
      Range.foreach(range, (row, col) => {
        const borderConfig = border.getValue(row, col);
        if (borderConfig) {
          this.renderBorderByCell(renderBorderContext, row, col, borderConfig);
        }
      });
    });
    ctx.closePath();
    ctx.restore();
  }
  renderBorderByCell(renderBorderContext, row, col, borderCacheItem) {
    const { ctx, precisionScale, overflowCache, spreadsheetSkeleton, diffRanges } = renderBorderContext;
    const cellInfo = spreadsheetSkeleton.getCellWithCoordByIndex(row, col, false);
    const { startY: cellStartY, endY: cellEndY, startX: cellStartX, endX: cellEndX } = cellInfo;
    const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
    if (!isMerged) {
      const visibleRow = spreadsheetSkeleton.worksheet.getRowVisible(row);
      const visibleCol = spreadsheetSkeleton.worksheet.getColVisible(col);
      if (!visibleRow || !visibleCol) return true;
    }
    if (!this.isRenderDiffRangesByRow(mergeInfo.startRow, mergeInfo.endRow, diffRanges)) {
      return true;
    }
    for (const key in borderCacheItem) {
      const { type: type2, style, color } = borderCacheItem[key];
      if (style === 0 /* NONE */) {
        continue;
      }
      let startY = cellStartY;
      let endY = cellEndY;
      let startX = cellStartX;
      let endX = cellEndX;
      if (type2 !== "t" /* TOP */ && type2 !== "b" /* BOTTOM */ && type2 !== "l" /* LEFT */ && type2 !== "r" /* RIGHT */) {
        if (isMerged) {
          return true;
        }
        if (isMergedMainCell) {
          startY = mergeInfo.startY;
          endY = mergeInfo.endY;
          startX = mergeInfo.startX;
          endX = mergeInfo.endX;
        }
      }
      const lineWidth = getLineWidth(style);
      setLineType(ctx, style);
      ctx.setLineWidthByPrecision(lineWidth);
      ctx.strokeStyle = color || COLOR_BLACK_RGB;
      drawDiagonalLineByBorderType(ctx, type2, {
        startX,
        startY,
        endX,
        endY
      });
      if (this._getOverflowExclusion(overflowCache, type2, row, col)) {
        continue;
      }
      drawLineByBorderType(ctx, type2, (lineWidth - 1) / 2 / precisionScale, {
        startX,
        startY,
        endX,
        endY
      });
    }
  }
  _getOverflowExclusion(overflowCache, type2, borderRow, borderColumn) {
    let isDraw = false;
    if (type2 === "t" /* TOP */ || type2 === "b" /* BOTTOM */) {
      return isDraw;
    }
    overflowCache == null ? void 0 : overflowCache.forRow((row, rowArray) => {
      if (row !== borderRow) {
        return true;
      }
      rowArray.forEach((column) => {
        const rectangle = overflowCache.getValue(row, column);
        const { startColumn, endColumn } = rectangle;
        if (type2 === "l" /* LEFT */ && borderColumn > startColumn && borderColumn <= endColumn) {
          isDraw = true;
          return false;
        }
        if (type2 === "r" /* RIGHT */ && borderColumn >= startColumn && borderColumn < endColumn) {
          isDraw = true;
          return false;
        }
      });
    });
    return isDraw;
  }
};
SpreadsheetExtensionRegistry.add(Border);

// ../packages/engine-render/src/components/sheets/extensions/column-header-layout.ts
var UNIQUE_KEY3 = "DefaultColumnHeaderLayoutExtension";
var DEFAULT_COLUMN_STYLE = {
  fontSize: 13,
  fontFamily: DEFAULT_FONTFACE_PLANE,
  fontColor: "#000000",
  backgroundColor: getColor([248, 249, 250]),
  borderColor: getColor([217, 217, 217]),
  textAlign: "center",
  textBaseline: "middle"
};
var ColumnHeaderLayout = class extends SheetExtension {
  constructor(cfg) {
    super();
    __publicField(this, "uKey", UNIQUE_KEY3);
    __publicField(this, "Z_INDEX", 10);
    __publicField(this, "columnsCfg", []);
    __publicField(this, "headerStyle", {
      fontSize: DEFAULT_COLUMN_STYLE.fontSize,
      fontFamily: DEFAULT_COLUMN_STYLE.fontFamily,
      fontColor: DEFAULT_COLUMN_STYLE.fontColor,
      backgroundColor: DEFAULT_COLUMN_STYLE.backgroundColor,
      borderColor: DEFAULT_COLUMN_STYLE.borderColor,
      textAlign: DEFAULT_COLUMN_STYLE.textAlign,
      textBaseline: DEFAULT_COLUMN_STYLE.textBaseline
    });
    if (cfg) {
      this.configHeaderColumn(cfg);
    }
  }
  configHeaderColumn(cfg) {
    this.columnsCfg = cfg.columnsCfg || [];
    this.headerStyle = { ...this.headerStyle, ...cfg.headerStyle };
  }
  getCfgOfCurrentColumn(colIndex) {
    let mergeWithSpecCfg;
    let curColSpecCfg;
    const columnsCfg = this.columnsCfg || [];
    if (columnsCfg[colIndex]) {
      if (typeof columnsCfg[colIndex] == "string") {
        columnsCfg[colIndex] = { text: columnsCfg[colIndex] };
      }
      curColSpecCfg = columnsCfg[colIndex];
      mergeWithSpecCfg = { ...this.headerStyle, ...curColSpecCfg };
    } else {
      mergeWithSpecCfg = { ...this.headerStyle, text: numberToABC(colIndex) };
    }
    const specStyle = Object.keys(curColSpecCfg || {}).length > 1;
    return [mergeWithSpecCfg, specStyle];
  }
  setStyleToCtx(ctx, columnStyle) {
    if (columnStyle.textAlign) ctx.textAlign = columnStyle.textAlign;
    if (columnStyle.textBaseline) ctx.textBaseline = columnStyle.textBaseline;
    if (columnStyle.fontColor) ctx.fillStyle = columnStyle.fontColor;
    if (columnStyle.borderColor) ctx.strokeStyle = columnStyle.borderColor;
    if (columnStyle.fontSize) ctx.font = `${columnStyle.fontSize}px ${DEFAULT_FONTFACE_PLANE}`;
  }
  // eslint-disable-next-line max-lines-per-function
  draw(ctx, parentScale, spreadsheetSkeleton) {
    const { rowColumnSegment, columnHeaderHeight = 0 } = spreadsheetSkeleton;
    const { startColumn, endColumn } = rowColumnSegment;
    if (!spreadsheetSkeleton || columnHeaderHeight === 0) {
      return;
    }
    const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
    if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
      return;
    }
    const scale = this._getScale(parentScale);
    this.setStyleToCtx(ctx, this.headerStyle);
    ctx.save();
    ctx.fillStyle = this.headerStyle.backgroundColor;
    ctx.fillRectByPrecision(0, 0, columnTotalWidth, columnHeaderHeight);
    ctx.restore();
    ctx.setLineWidthByPrecision(1);
    ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
    let preColumnPosition = 0;
    for (let c = startColumn - 1; c <= endColumn; c++) {
      if (c < 0 || c > columnWidthAccumulation.length - 1) {
        continue;
      }
      const columnEndPosition = columnWidthAccumulation[c];
      if (preColumnPosition === columnEndPosition) {
        continue;
      }
      const cellBound = { left: preColumnPosition, top: 0, right: columnEndPosition, bottom: columnHeaderHeight, width: columnEndPosition - preColumnPosition, height: columnHeaderHeight };
      const [curColumnCfg, specStyle] = this.getCfgOfCurrentColumn(c);
      if (specStyle && curColumnCfg.backgroundColor) {
        ctx.save();
        ctx.fillStyle = curColumnCfg.backgroundColor;
        ctx.fillRectByPrecision(cellBound.left, cellBound.top, cellBound.width, cellBound.height);
        ctx.restore();
      }
      ctx.beginPath();
      ctx.moveToByPrecision(cellBound.right, 0);
      ctx.lineToByPrecision(cellBound.right, cellBound.height);
      ctx.stroke();
      const textX = (() => {
        switch (curColumnCfg.textAlign) {
          case "center":
            return cellBound.left + (cellBound.right - cellBound.left) / 2;
          case "right":
            return cellBound.right - MIDDLE_CELL_POS_MAGIC_NUMBER * 3;
          case "left":
            return cellBound.left + MIDDLE_CELL_POS_MAGIC_NUMBER * 3;
          default:
            return cellBound.left + (cellBound.right - cellBound.left) / 2;
        }
      })();
      const middleYCellRect = cellBound.height / 2 + MIDDLE_CELL_POS_MAGIC_NUMBER;
      if (specStyle) {
        ctx.save();
        ctx.beginPath();
        this.setStyleToCtx(ctx, curColumnCfg);
        ctx.rectByPrecision(cellBound.left, cellBound.top, cellBound.width, cellBound.height);
        ctx.clip();
      }
      ctx.fillText(curColumnCfg.text, textX, middleYCellRect);
      if (specStyle) {
        ctx.restore();
      }
      preColumnPosition = columnEndPosition;
    }
    const columnHeaderHeightFix = columnHeaderHeight - 0.5 / scale;
    ctx.beginPath();
    ctx.moveToByPrecision(0, columnHeaderHeightFix);
    ctx.lineToByPrecision(columnTotalWidth, columnHeaderHeightFix);
    ctx.stroke();
  }
};
SheetColumnHeaderExtensionRegistry.add(new ColumnHeaderLayout());

// ../packages/engine-render/src/components/sheets/extensions/custom.ts
var UNIQUE_KEY4 = "DefaultCustomExtension";
var Z_INDEX = 55;
var stringifyRange = (range) => {
  const { startRow, endRow, startColumn, endColumn } = range;
  return `${startRow}-${endRow}-${startColumn}-${endColumn}`;
};
var Custom = class extends SheetExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "Z_INDEX", Z_INDEX);
    __publicField(this, "uKey", UNIQUE_KEY4);
  }
  draw(ctx, _parentScale, skeleton, diffRanges) {
    const { worksheet, rowColumnSegment } = skeleton;
    if (!worksheet) {
      return;
    }
    const mergeCellRendered = /* @__PURE__ */ new Set();
    const subUnitId = worksheet.getSheetId();
    Range.foreach(rowColumnSegment, (row, col) => {
      if (!worksheet.getRowVisible(row) || !worksheet.getColVisible(col)) {
        return;
      }
      let cellData = worksheet.getCell(row, col);
      if (!(cellData == null ? void 0 : cellData.customRender)) {
        return;
      }
      let primaryWithCoord = skeleton.getCellWithCoordByIndex(row, col, false);
      const { mergeInfo } = primaryWithCoord;
      if (!this.isRenderDiffRangesByRow(mergeInfo.startRow, mergeInfo.endRow, diffRanges)) {
        return true;
      }
      if (primaryWithCoord.isMerged || primaryWithCoord.isMergedMainCell) {
        const rangeStr = stringifyRange(mergeInfo);
        if (mergeCellRendered.has(rangeStr)) {
          return;
        }
        mergeCellRendered.add(rangeStr);
      }
      if (primaryWithCoord.isMerged) {
        const mainCell = {
          row: mergeInfo.startRow,
          col: mergeInfo.startColumn
        };
        cellData = worksheet.getCell(mainCell.row, mainCell.col);
        if (!(cellData == null ? void 0 : cellData.customRender)) {
          return;
        }
        primaryWithCoord = skeleton.getCellWithCoordByIndex(mainCell.row, mainCell.col);
      }
      const renderInfo = {
        data: cellData,
        style: skeleton.getStyles().getStyleByCell(cellData),
        primaryWithCoord,
        subUnitId,
        row,
        col,
        worksheet,
        unitId: worksheet.unitId
      };
      const customRender = cellData.customRender.sort(sortRules);
      ctx.save();
      customRender.forEach((item) => {
        item.drawWith(ctx, renderInfo, skeleton, this.parent);
      });
      ctx.restore();
    });
  }
};
SpreadsheetExtensionRegistry.add(Custom);

// ../packages/engine-render/src/components/docs/liquid.ts
var Liquid = class {
  constructor() {
    __publicField(this, "_translateX", 0);
    __publicField(this, "_translateY", 0);
    __publicField(this, "_translateSaveList", []);
  }
  get x() {
    return this._translateX;
  }
  get y() {
    return this._translateY;
  }
  reset() {
    this.translateBy(0, 0);
    this._translateSaveList = [];
  }
  translateBy(x = 0, y = 0) {
    this._translateX = x;
    this._translateY = y;
  }
  translate(x = 0, y = 0) {
    this._translateX += x;
    this._translateY += y;
  }
  translateSave() {
    this._translateSaveList.push({
      x: this._translateX,
      y: this._translateY
    });
  }
  translateRestore() {
    const save = this._translateSaveList.pop();
    if (save) {
      this._translateX = save.x;
      this._translateY = save.y;
    }
  }
  translatePagePadding(page) {
    const {
      marginTop: pagePaddingTop = 0,
      marginBottom: _pagePaddingBottom = 0,
      marginLeft: pagePaddingLeft = 0,
      marginRight: _pagePaddingRight = 0
    } = page;
    this.translate(pagePaddingLeft, pagePaddingTop);
  }
  restorePagePadding(page) {
    const {
      marginTop: pagePaddingTop = 0,
      marginBottom: _pagePaddingBottom = 0,
      marginLeft: pagePaddingLeft = 0,
      marginRight: _pagePaddingRight = 0
    } = page;
    this.translate(-pagePaddingLeft, -pagePaddingTop);
  }
  translatePage(page, type2 = 0 /* VERTICAL */, left = 0, top = 0, _right = 0, _bottom = 0) {
    const {
      // sections,
      // marginTop: pagePaddingTop = 0,
      // marginBottom: pagePaddingBottom = 0,
      // marginLeft: pagePaddingLeft = 0,
      // marginRight: pagePaddingRight = 0,
      pageWidth,
      pageHeight
      // width,
      // height,
      // pageNumber = 1,
      // renderConfig = {},
    } = page;
    let pageTop = 0;
    let pageLeft = 0;
    if (type2 === 0 /* VERTICAL */) {
      pageTop += pageHeight + top;
    } else if (type2 === 1 /* HORIZONTAL */) {
      pageLeft += pageWidth + left;
    }
    this.translate(pageLeft, pageTop);
    return {
      x: pageLeft,
      y: pageTop
    };
  }
  translateSection(section) {
    const { top: sectionTop = 0 } = section;
    this.translate(0, sectionTop);
    return {
      x: 0,
      y: sectionTop
    };
  }
  translateColumn(column) {
    const { left: columnLeft } = column;
    this.translate(columnLeft, 0);
    return {
      x: columnLeft,
      y: 0
    };
  }
  translateLine(line2, includeMarginTop = false, includePaddingTop = false) {
    const {
      top: lineTop,
      marginBottom: _lineMarginBottom = 0,
      marginTop: lineMarginTop = 0,
      paddingTop: linePaddingTop = 0,
      paddingBottom: _linePaddingBottom = 0
    } = line2;
    const lineOffset = lineTop + (includeMarginTop ? lineMarginTop : 0) + (includePaddingTop ? linePaddingTop : 0);
    this.translate(0, lineOffset);
    return {
      x: 0,
      y: lineOffset
    };
  }
  translateDivide(divide) {
    const { left: divideLeft, paddingLeft: dividePaddingLeft } = divide;
    const left = divideLeft + dividePaddingLeft;
    this.translate(left, 0);
    return {
      x: left,
      y: 0
    };
  }
  translateGlyph(glyph) {
    const { left: spanLeft } = glyph;
    this.translate(spanLeft, 0);
    return {
      x: spanLeft,
      y: 0
    };
  }
};

// ../packages/engine-render/src/components/docs/view-model/data-stream-tree-node.ts
var DataStreamTreeNode = class _DataStreamTreeNode {
  constructor(nodeType, content) {
    this.nodeType = nodeType;
    this.content = content;
    __publicField(this, "children", []);
    __publicField(this, "parent");
    __publicField(this, "startIndex", -1);
    __publicField(this, "endIndex", -1);
    // isBullet: boolean = false;
    // isIndent: boolean = false;
    __publicField(this, "blocks", []);
  }
  static create(nodeType, content) {
    return new _DataStreamTreeNode(nodeType, content);
  }
  dispose() {
    this.children.forEach((child) => {
      child.dispose();
    });
    this.parent = null;
    this.blocks = [];
  }
  getProps() {
    const { children, parent, startIndex, endIndex, nodeType, content } = this;
    return {
      children,
      parent,
      startIndex,
      endIndex,
      nodeType,
      content
    };
  }
  addBlocks(blocks) {
    this.blocks = this.blocks.concat(blocks);
  }
  setIndexRange(startIndex, endIndex) {
    this.startIndex = startIndex;
    this.endIndex = endIndex;
  }
  insertText(text, insertIndex) {
    this.content = insertTextToContent(this.content || "", insertIndex - this.startIndex, text);
  }
  exclude(index) {
    const { startIndex, endIndex } = this;
    return index < startIndex || index > endIndex;
  }
  plus(len) {
    this.startIndex += len;
    this.endIndex += len;
    this._addIndexForBlock(len);
  }
  selfPlus(len, index) {
    this.endIndex += len;
    if (index == null) {
      index = this.startIndex;
    }
    this._addIndexForBlock(len, index);
  }
  split(index) {
    const { children, parent, startIndex, nodeType, content = "" } = this.getProps();
    if (this.exclude(index)) {
      return;
    }
    const firstStartIndex = 0;
    const firstEndIndex = index - startIndex;
    const lastStartIndex = firstEndIndex;
    const firstNodeContent = content.slice(firstStartIndex, firstEndIndex);
    const firstNode = _DataStreamTreeNode.create(nodeType, firstNodeContent);
    firstNode.parent = parent;
    firstNode.setIndexRange(firstStartIndex, firstEndIndex - 1);
    const lastNodeContent = content.slice(lastStartIndex);
    const lastNode = _DataStreamTreeNode.create(nodeType, lastNodeContent);
    lastNode.parent = parent;
    lastNode.setIndexRange(lastStartIndex, lastStartIndex + lastNodeContent.length - 1);
    const firstChildNodes = [];
    const lastChildNodes = [];
    for (const node of children) {
      const { startIndex: childStartIndex } = node;
      if (node.exclude(index)) {
        if (index < childStartIndex) {
          firstChildNodes.push(node);
        } else {
          lastChildNodes.push(node);
        }
      } else {
        const splitData = node.split(index);
        if (splitData == null) {
          firstChildNodes.push(node);
          continue;
        }
        const { firstNode: firstNode2, lastNode: lastNode2 } = splitData;
        firstChildNodes.push(firstNode2);
        firstChildNodes.push(lastNode2);
      }
    }
    firstNode.children = firstChildNodes;
    lastNode.children = lastChildNodes;
    firstNode._resetBlocks();
    lastNode._resetBlocks();
    return {
      firstNode,
      lastNode
    };
  }
  getPositionInParent() {
    var _a;
    const index = (_a = this.parent) == null ? void 0 : _a.children.indexOf(this);
    if (index == null) {
      return -1;
    }
    return index;
  }
  remove() {
    this.children = [];
    if (this.parent == null) {
      return;
    }
    this.parent.children.splice(this.getPositionInParent(), 1);
    this.parent = null;
  }
  minus(startIndex, endIndex) {
    const segments = horizontalLineSegmentsSubtraction(this.startIndex, this.endIndex, startIndex, endIndex);
    if (segments.length === 0) {
      return;
    }
    const originStartIndex = this.startIndex;
    this.startIndex = segments[0];
    this.endIndex = segments[1];
    if (this.content != null) {
      this.content = deleteContent(
        this.content || "",
        startIndex - originStartIndex,
        endIndex - originStartIndex + 1
      );
    }
  }
  merge(node) {
    const { startIndex, endIndex, children } = node;
    this.endIndex += endIndex - startIndex + 1;
    this.children.push(...children);
    this.content += node.content || "";
    node.remove();
  }
  _addIndexForBlock(addLen, index = Number.NEGATIVE_INFINITY) {
    for (let i = 0, len = this.blocks.length; i < len; i++) {
      const block = this.blocks[i];
      if (block >= index) {
        this.blocks[i] = block + addLen;
      }
    }
  }
  _resetBlocks() {
    if (this.nodeType !== "PARAGRAPH" /* PARAGRAPH */) {
      return;
    }
    if (this.content == null) {
      return;
    }
    if (this.content.length === 0) {
      return;
    }
    this.blocks = [];
    for (let i = 0, len = this.content.length; i < len; i++) {
      const char = this.content[i];
      if (char === "\b" /* CUSTOM_BLOCK */) {
        this.blocks.push(this.startIndex + i);
      }
    }
  }
};

// ../packages/engine-render/src/components/docs/view-model/document-view-model.ts
function batchParent(parent, children, nodeType = "SECTION_BREAK" /* SECTION_BREAK */) {
  if (children.length === 0) {
    throw new Error("Missing `paragraphs` or `sectionBreaks` fields, or doesn't correspond to the location in `dataStream`.");
  }
  for (const child of children) {
    child.parent = parent;
    parent.children.push(child);
  }
  const startOffset = nodeType === "SECTION_BREAK" /* SECTION_BREAK */ ? 0 : 1;
  const allChildren = parent.children;
  parent.setIndexRange(allChildren[0].startIndex - startOffset, allChildren[allChildren.length - 1].endIndex + 1);
}
function parseDataStreamToTree(dataStream, tables) {
  let content = "";
  const dataStreamLen = dataStream.length;
  const sectionList = [];
  const tableNodeCache = /* @__PURE__ */ new Map();
  const paragraphList = [];
  const cellParagraphList = [];
  const tableList2 = [];
  const tableRowList = [];
  const tableCellList = [];
  const currentBlocks = [];
  for (let i = 0; i < dataStreamLen; i++) {
    const char = dataStream[i];
    if (char === "\r" /* PARAGRAPH */) {
      content += "\r" /* PARAGRAPH */;
      const paragraphNode = DataStreamTreeNode.create("PARAGRAPH" /* PARAGRAPH */, content);
      const lastTableCache = tableList2[tableList2.length - 1];
      if (lastTableCache && lastTableCache.isFinished) {
        batchParent(paragraphNode, [lastTableCache.table], "PARAGRAPH" /* PARAGRAPH */);
        if (tables) {
          const table2 = tables.find((table3) => table3.startIndex === lastTableCache.table.startIndex && table3.endIndex === lastTableCache.table.endIndex + 1);
          if (table2) {
            tableNodeCache.set(table2.tableId, { table: lastTableCache.table });
          }
        }
        tableList2.pop();
      }
      paragraphNode.setIndexRange(i - content.length + 1, i);
      paragraphNode.addBlocks(currentBlocks);
      currentBlocks.length = 0;
      content = "";
      if (tableCellList.length > 0) {
        cellParagraphList.push(paragraphNode);
      } else {
        paragraphList.push(paragraphNode);
      }
    } else if (char === "\n" /* SECTION_BREAK */) {
      const sectionNode = DataStreamTreeNode.create("SECTION_BREAK" /* SECTION_BREAK */);
      const tempParagraphList = tableCellList.length > 0 ? cellParagraphList : paragraphList;
      batchParent(sectionNode, tempParagraphList);
      const lastNode = tempParagraphList[tempParagraphList.length - 1];
      if (lastNode && lastNode.content) {
        lastNode.content += "\n" /* SECTION_BREAK */;
      }
      if (tableCellList.length > 0) {
        const lastCell = tableCellList[tableCellList.length - 1];
        batchParent(lastCell, [sectionNode], "TABLE_CELL" /* TABLE_CELL */);
      } else {
        sectionList.push(sectionNode);
      }
      tempParagraphList.length = 0;
    } else if (char === "" /* TABLE_START */) {
      const tableNode = DataStreamTreeNode.create("TABLE" /* TABLE */);
      tableList2.push({
        table: tableNode,
        isFinished: false
      });
    } else if (char === "\x1B" /* TABLE_ROW_START */) {
      const rowNode = DataStreamTreeNode.create("TABLE_ROW" /* TABLE_ROW */);
      tableRowList.push(rowNode);
    } else if (char === "" /* TABLE_CELL_START */) {
      const cellNode = DataStreamTreeNode.create("TABLE_CELL" /* TABLE_CELL */);
      tableCellList.push(cellNode);
    } else if (char === "" /* TABLE_END */) {
      const lastTable = tableList2[tableList2.length - 1];
      lastTable.isFinished = true;
      content = "";
    } else if (char === "" /* TABLE_ROW_END */) {
      const rowNode = tableRowList.pop();
      const lastTableCache = tableList2[tableList2.length - 1];
      batchParent(lastTableCache.table, [rowNode], "TABLE" /* TABLE */);
    } else if (char === "" /* TABLE_CELL_END */) {
      const cellNode = tableCellList.pop();
      const lastRow = tableRowList[tableRowList.length - 1];
      batchParent(lastRow, [cellNode], "TABLE_ROW" /* TABLE_ROW */);
    } else if (char === "\b" /* CUSTOM_BLOCK */) {
      currentBlocks.push(i);
      content += char;
    } else {
      content += char;
    }
  }
  return { sectionList, tableNodeCache };
}
var DocumentViewModel = class _DocumentViewModel {
  constructor(_documentDataModel) {
    this._documentDataModel = _documentDataModel;
    __publicField(this, "_interceptor", null);
    __publicField(this, "_cacheSize", 1e3);
    __publicField(this, "_textRunsCache", /* @__PURE__ */ new Map());
    __publicField(this, "_paragraphCache", /* @__PURE__ */ new Map());
    __publicField(this, "_sectionBreakCache", /* @__PURE__ */ new Map());
    __publicField(this, "_customBlockCache", /* @__PURE__ */ new Map());
    __publicField(this, "_tableCache", /* @__PURE__ */ new Map());
    __publicField(this, "_tableNodeCache", /* @__PURE__ */ new Map());
    __publicField(this, "_children", []);
    __publicField(this, "_editArea", "BODY" /* BODY */);
    __publicField(this, "_editAreaChange$", new BehaviorSubject(null));
    __publicField(this, "editAreaChange$", this._editAreaChange$.asObservable());
    __publicField(this, "_headerTreeMap", /* @__PURE__ */ new Map());
    __publicField(this, "_footerTreeMap", /* @__PURE__ */ new Map());
    __publicField(this, "_segmentViewModels$", new BehaviorSubject([]));
    __publicField(this, "segmentViewModels$", this._segmentViewModels$.asObservable());
    if (_documentDataModel.getBody() == null) {
      return;
    }
    const body = _documentDataModel.getBody();
    const { sectionList, tableNodeCache } = parseDataStreamToTree(body.dataStream, body.tables);
    this._buildAllCache();
    this._children = sectionList;
    this._tableNodeCache = tableNodeCache;
    this._buildHeaderFooterViewModel();
  }
  registerCustomRangeInterceptor(interceptor) {
    this._interceptor = interceptor;
    return toDisposable(() => this._interceptor = null);
  }
  dispose() {
    this._children.forEach((child) => {
      child.dispose();
    });
    this._textRunsCache.clear();
    this._paragraphCache.clear();
    this._sectionBreakCache.clear();
    this._customBlockCache.clear();
    this._tableCache.clear();
    this._tableNodeCache.clear();
  }
  getHeaderFooterTreeMap() {
    return {
      headerTreeMap: this._headerTreeMap,
      footerTreeMap: this._footerTreeMap
    };
  }
  getEditArea() {
    return this._editArea;
  }
  setEditArea(editArea) {
    if (editArea !== this._editArea) {
      this._editArea = editArea;
      this._editAreaChange$.next(editArea);
    }
  }
  getChildren() {
    return this._children;
  }
  getBody() {
    return this._documentDataModel.getBody();
  }
  getSnapshot() {
    return this._documentDataModel.getSnapshot();
  }
  getDataModel() {
    return this._documentDataModel;
  }
  getSelfOrHeaderFooterViewModel(segmentId) {
    if (segmentId == null) {
      return this;
    }
    if (this._headerTreeMap.has(segmentId)) {
      return this._headerTreeMap.get(segmentId);
    }
    if (this._footerTreeMap.has(segmentId)) {
      return this._footerTreeMap.get(segmentId);
    }
    return this;
  }
  reset(documentDataModel) {
    this._documentDataModel = documentDataModel;
    const body = documentDataModel.getBody();
    const { sectionList, tableNodeCache } = parseDataStreamToTree(body.dataStream, body.tables);
    this._children = sectionList;
    this._tableNodeCache = tableNodeCache;
    this._buildAllCache();
    this._buildHeaderFooterViewModel();
  }
  getSectionBreak(index) {
    return this._sectionBreakCache.get(index);
  }
  getParagraph(index) {
    return this._paragraphCache.get(index);
  }
  getTextRun(index) {
    const cacheIndex = Math.floor(index / this._cacheSize);
    const textRunsCache = this._textRunsCache.get(cacheIndex);
    return textRunsCache == null ? void 0 : textRunsCache.get(index % this._cacheSize);
  }
  getCustomBlock(index) {
    return this._customBlockCache.get(index);
  }
  getCustomBlockWithoutSetCurrentIndex(index) {
    const customBlocks = this.getBody().customBlocks;
    if (customBlocks == null) {
      return;
    }
    for (let i = 0; i < customBlocks.length; i++) {
      const customBlock = customBlocks[i];
      if (customBlock.startIndex === index) {
        return customBlock;
      }
    }
  }
  getTableByStartIndex(index) {
    return this._tableCache.get(index);
  }
  findTableNodeById(id) {
    var _a;
    return (_a = this._tableNodeCache.get(id)) == null ? void 0 : _a.table;
  }
  getCustomRangeRaw(index) {
    const customRanges = this.getBody().customRanges;
    if (customRanges == null) {
      return;
    }
    for (let i = 0, customRangesLen = customRanges.length; i < customRangesLen; i++) {
      const customRange = customRanges[i];
      if (index >= customRange.startIndex && index <= customRange.endIndex) {
        return customRange;
      }
    }
  }
  getCustomRange(index) {
    if (this._interceptor) {
      return this._interceptor.getCustomRange(index);
    }
    return this.getCustomRangeRaw(index);
  }
  getCustomDecorationRaw(index) {
    const customDecorations = this.getBody().customDecorations;
    if (customDecorations == null) {
      return;
    }
    for (let i = 0, customDecorationsLen = customDecorations.length; i < customDecorationsLen; i++) {
      const customDecoration = customDecorations[i];
      if (index >= customDecoration.startIndex && index <= customDecoration.endIndex) {
        return customDecoration;
      }
    }
  }
  getCustomDecoration(index) {
    if (this._interceptor) {
      return this._interceptor.getCustomDecoration(index);
    }
    return this.getCustomDecorationRaw(index);
  }
  _buildAllCache() {
    this._buildTextRunsCache();
    this._buildParagraphCache();
    this._buildSectionBreakCache();
    this._buildCustomBlockCache();
    this._buildTableCache();
  }
  _buildParagraphCache() {
    var _a, _b;
    this._paragraphCache.clear();
    const paragraphs = (_b = (_a = this.getBody()) == null ? void 0 : _a.paragraphs) != null ? _b : [];
    for (const paragraph of paragraphs) {
      const { startIndex } = paragraph;
      this._paragraphCache.set(startIndex, paragraph);
    }
  }
  _buildSectionBreakCache() {
    var _a, _b;
    this._sectionBreakCache.clear();
    const sectionBreaks = (_b = (_a = this.getBody()) == null ? void 0 : _a.sectionBreaks) != null ? _b : [];
    for (const sectionBreak of sectionBreaks) {
      const { startIndex } = sectionBreak;
      this._sectionBreakCache.set(startIndex, sectionBreak);
    }
  }
  _buildCustomBlockCache() {
    var _a, _b;
    this._customBlockCache.clear();
    const customBlocks = (_b = (_a = this.getBody()) == null ? void 0 : _a.customBlocks) != null ? _b : [];
    for (const customBlock of customBlocks) {
      const { startIndex } = customBlock;
      this._customBlockCache.set(startIndex, customBlock);
    }
  }
  _buildTableCache() {
    var _a;
    this._tableCache.clear();
    const tables = (_a = this.getBody()) == null ? void 0 : _a.tables;
    const tableConfig = this.getSnapshot().tableSource;
    if (tables == null || tableConfig == null) {
      return;
    }
    for (const table2 of tables) {
      const { startIndex, tableId } = table2;
      const tableSource = tableConfig[tableId];
      if (tableSource == null) {
        continue;
      }
      this._tableCache.set(startIndex, {
        table: table2,
        tableSource
      });
    }
  }
  _buildTextRunsCache() {
    var _a, _b;
    const textRuns = (_b = (_a = this.getBody()) == null ? void 0 : _a.textRuns) != null ? _b : [];
    this._textRunsCache.clear();
    for (const textRun of textRuns) {
      const { st, ed } = textRun;
      for (let i = st; i < ed; i++) {
        const cacheIndex = Math.floor(i / this._cacheSize);
        if (!this._textRunsCache.has(cacheIndex)) {
          this._textRunsCache.set(cacheIndex, /* @__PURE__ */ new Map());
        }
        this._textRunsCache.get(cacheIndex).set(i % this._cacheSize, textRun);
      }
    }
  }
  _buildHeaderFooterViewModel() {
    const { headerModelMap, footerModelMap } = this._documentDataModel;
    const viewModels = [];
    for (const [headerId, headerModel] of headerModelMap) {
      this._headerTreeMap.set(headerId, new _DocumentViewModel(headerModel));
      viewModels.push(this._headerTreeMap.get(headerId));
    }
    for (const [footerId, footerModel] of footerModelMap) {
      this._footerTreeMap.set(footerId, new _DocumentViewModel(footerModel));
      viewModels.push(this._footerTreeMap.get(footerId));
    }
    this._segmentViewModels$.next(viewModels);
  }
};

// ../packages/engine-render/src/components/docs/layout/line-breaker/break.ts
var Break = class {
  constructor(position, type2 = "Normal" /* Normal */) {
    this.position = position;
    this.type = type2;
  }
};

// ../packages/engine-render/src/components/docs/layout/model/glyph.ts
function isSpace(char) {
  const SPACE_CHARS = [" ", "\xA0", "\u3000"];
  return SPACE_CHARS.includes(char);
}
function isJustifiable(content) {
  return isSpace(content) || hasCJKText(content) || isCjkLeftAlignedPunctuation(content) || isCjkRightAlignedPunctuation(content) || isCjkCenterAlignedPunctuation(content);
}
function baseAdjustability(content, width) {
  if (isSpace(content)) {
    return {
      // The number for spaces is from Knuth-Plass' paper
      stretchability: [0, width / 2],
      shrinkability: [0, width / 3]
    };
  } else if (isCjkLeftAlignedPunctuation(content)) {
    return {
      stretchability: [0, 0],
      shrinkability: [0, width / 2]
    };
  } else if (isCjkRightAlignedPunctuation(content)) {
    return {
      stretchability: [0, 0],
      shrinkability: [width / 2, 0]
    };
  } else if (isCjkCenterAlignedPunctuation(content)) {
    return {
      stretchability: [0, 0],
      shrinkability: [width / 4, width / 4]
    };
  } else {
    return {
      stretchability: [0, 0],
      shrinkability: [0, 0]
    };
  }
}
function createSkeletonWordGlyph(content, config, glyphWidth) {
  return _createSkeletonWordOrLetter(1 /* WORD */, content, config, glyphWidth);
}
function createSkeletonLetterGlyph(content, config, glyphWidth, glyphInfo) {
  return _createSkeletonWordOrLetter(0 /* LETTER */, content, config, glyphWidth, glyphInfo);
}
function createSkeletonTabGlyph(config, glyphWidth) {
  return _createSkeletonWordOrLetter(4 /* TAB */, "	" /* TAB */, config, glyphWidth);
}
function createHyphenDashGlyph(config) {
  const dashLetterGlyph = _createSkeletonWordOrLetter(0 /* LETTER */, "-", config);
  dashLetterGlyph.count = 0;
  return dashLetterGlyph;
}
function createSkeletonCustomBlockGlyph(config, glyphWidth = 0, glyphHeight = 0, drawingId = "") {
  const { fontStyle, textStyle } = config;
  const content = "\b" /* CUSTOM_BLOCK */;
  return {
    content: "",
    raw: content,
    ts: textStyle,
    fontStyle,
    width: glyphWidth,
    bBox: {
      width: 0,
      ba: glyphHeight,
      // Or 1/2 glyphHeight each for ba and bd.
      bd: 0,
      aba: 0,
      abd: 0,
      sp: 0,
      sbr: 0,
      sbo: 0,
      spr: 0,
      spo: 0
    },
    xOffset: 0,
    left: 0,
    isJustifiable: false,
    adjustability: baseAdjustability(content, 0),
    glyphType: 3 /* PLACEHOLDER */,
    streamType: content,
    count: 1,
    drawingId
  };
}
function _createSkeletonWordOrLetter(glyphType, content, config, glyphWidth, glyphInfo) {
  const { fontStyle, textStyle, charSpace = 1, gridType = 1 /* LINES */, snapToGrid = 0 /* FALSE */ } = config;
  const skipWidthList = [
    "\n" /* SECTION_BREAK */,
    "" /* TABLE_START */,
    "" /* TABLE_END */,
    "\x1B" /* TABLE_ROW_START */,
    "" /* TABLE_ROW_END */,
    "" /* TABLE_CELL_START */,
    "" /* TABLE_CELL_END */,
    "" /* CUSTOM_RANGE_START */,
    "" /* CUSTOM_RANGE_END */,
    "\v" /* COLUMN_BREAK */,
    "\f" /* PAGE_BREAK */,
    "\0" /* DOCS_END */,
    "\b" /* CUSTOM_BLOCK */
  ];
  let streamType = "" /* LETTER */;
  if (skipWidthList.indexOf(content) > -1) {
    return {
      content: "",
      raw: content,
      ts: textStyle,
      fontStyle,
      width: 0,
      bBox: {
        width: 0,
        ba: 0,
        bd: 0,
        aba: 0,
        abd: 0,
        sp: 0,
        sbr: 0,
        sbo: 0,
        spr: 0,
        spo: 0
      },
      xOffset: 0,
      left: 0,
      isJustifiable: false,
      adjustability: baseAdjustability(content, 0),
      glyphType: 3 /* PLACEHOLDER */,
      streamType: content,
      count: 1
    };
  }
  if (content === "\r" /* PARAGRAPH */) {
    streamType = "\r" /* PARAGRAPH */;
  }
  let bBox = null;
  let xOffset = 0;
  if (glyphInfo && glyphInfo.boundingBox && glyphInfo.font) {
    bBox = FontCache.getBBoxFromGlyphInfo(glyphInfo, fontStyle);
  } else {
    bBox = FontCache.getTextSize(content, fontStyle);
  }
  const { width: contentWidth = 0 } = bBox;
  let width = glyphWidth != null ? glyphWidth : contentWidth;
  if (validationGrid(gridType, snapToGrid)) {
    width = contentWidth + (hasCJK(content) ? charSpace : charSpace / 2);
    if (gridType === 3 /* SNAP_TO_CHARS */) {
      xOffset = (width - contentWidth) / 2;
    }
  }
  if (glyphInfo && glyphInfo.kerning !== 0 && glyphInfo.font) {
    const radio = ptToPixel(fontStyle.fontSize) / glyphInfo.font.unitsPerEm;
    const delta = glyphInfo.kerning * radio;
    width += delta;
    xOffset += delta;
  }
  return {
    content,
    ts: textStyle,
    fontStyle,
    width,
    bBox,
    xOffset,
    left: 0,
    glyphType,
    streamType,
    isJustifiable: isJustifiable(content),
    adjustability: baseAdjustability(content, width),
    count: content.length,
    raw: content
  };
}
function createSkeletonBulletGlyph(glyph, bulletSkeleton, charSpaceApply) {
  const {
    // bBox: boundingBox,
    symbol: content,
    // ts: textStyle,
    // fontStyle,
    bulletAlign = 1 /* START */,
    bulletType = false
  } = bulletSkeleton;
  const { fontStyle } = glyph;
  const boundingBox = FontCache.getTextSize(content, fontStyle);
  const contentWidth = boundingBox.width;
  const multiple = Math.ceil(contentWidth / charSpaceApply);
  let width = (multiple < 2 ? 2 : multiple) * charSpaceApply;
  let left = 0;
  if (bulletType) {
    if (bulletAlign === 2 /* CENTER */) {
      left = -contentWidth / 2;
      width -= left;
    } else if (bulletAlign === 3 /* END */) {
      left = -contentWidth;
      width -= left;
    }
  }
  const bBox = _getMaxBoundingBox(glyph, boundingBox);
  return {
    content,
    ts: {
      ...glyph.ts,
      // ...textStyle,
      st: {
        s: 0 /* FALSE */
      }
    },
    fontStyle,
    width,
    xOffset: 0,
    bBox,
    left,
    isJustifiable: isJustifiable(content),
    adjustability: baseAdjustability(content, width),
    glyphType: 2 /* LIST */,
    streamType: "" /* LETTER */,
    // Deliberately set to 0 so that there is no need to count when calculating the cursor.
    count: 0,
    raw: content
  };
}
function setGlyphGroupLeft(glyphGroup, left = 0) {
  const spanGroupLen = glyphGroup.length;
  let preGlyph;
  for (let i = 0; i < spanGroupLen; i++) {
    const glyph = glyphGroup[i];
    glyph.left = preGlyph ? preGlyph.left + preGlyph.width : left;
    preGlyph = glyph;
  }
}
function addGlyphToDivide(divide, glyphGroup, offsetLeft = 0) {
  setGlyphGroupLeft(glyphGroup, offsetLeft);
  for (const glyph of glyphGroup) {
    glyph.parent = divide;
  }
  divide.glyphGroup.push(...glyphGroup);
}
function _getMaxBoundingBox(glyph, bulletBBox) {
  const { ba: spanAscent, bd: spanDescent } = glyph.bBox;
  const { ba: bulletAscent, bd: bulletDescent } = bulletBBox;
  if (spanAscent + spanDescent > bulletAscent + bulletDescent) {
    return glyph.bBox;
  }
  return bulletBBox;
}
function glyphShrinkRight(glyph, amount) {
  glyph.width -= amount;
  glyph.adjustability.shrinkability[1] -= amount;
}
function glyphShrinkLeft(glyph, amount) {
  glyph.width -= amount;
  glyph.xOffset -= amount;
  glyph.adjustability.shrinkability[0] -= amount;
}

// ../packages/engine-render/src/components/docs/layout/model/line.ts
function createSkeletonLine(paragraphIndex, lineType, lineBoundingBox, columnWidth, lineIndex = 0, isParagraphStart = false, paragraphConfig, page, headerPage, footerPage) {
  var _a, _b;
  const {
    lineHeight = 15.6,
    lineTop = 0,
    contentHeight = 0,
    paddingLeft = 0,
    paddingRight = 0,
    paddingTop = 0,
    paddingBottom = 0,
    marginTop = 0,
    spaceBelowApply = 0
  } = lineBoundingBox;
  const { skeTablesInParagraph } = paragraphConfig;
  const pageSkeDrawings = (_a = page.skeDrawings) != null ? _a : /* @__PURE__ */ new Map();
  const pageSkeTables = (_b = page.skeTables) != null ? _b : /* @__PURE__ */ new Map();
  const headersDrawings = headerPage == null ? void 0 : headerPage.skeDrawings;
  const footersDrawings = footerPage == null ? void 0 : footerPage.skeDrawings;
  const lineSke = _getLineSke(lineType, paragraphIndex);
  lineSke.lineIndex = lineIndex;
  lineSke.paragraphStart = isParagraphStart;
  lineSke.contentHeight = contentHeight;
  lineSke.top = lineTop;
  lineSke.lineHeight = lineHeight;
  lineSke.paddingTop = paddingTop;
  lineSke.paddingBottom = paddingBottom;
  lineSke.marginTop = marginTop;
  lineSke.spaceBelowApply = spaceBelowApply;
  if (isParagraphStart && Array.isArray(skeTablesInParagraph) && skeTablesInParagraph.length > 0) {
    const tableId = skeTablesInParagraph[skeTablesInParagraph.length - 1].tableId;
    lineSke.isBehindTable = true;
    lineSke.tableId = tableId;
  }
  const affectSkeDrawings = new Map(Array.from(pageSkeDrawings).filter(([_819, drawing]) => drawing.drawingOrigin.layoutType !== 0 /* INLINE */));
  const wrapTypeTables = new Map(Array.from(pageSkeTables).filter(([_819, table2]) => table2.tableSource.textWrap === 1 /* WRAP */));
  lineSke.divides = _calculateDividesByDrawings(
    lineHeight,
    lineTop,
    columnWidth,
    paddingLeft,
    paddingRight,
    page,
    headerPage,
    footerPage,
    affectSkeDrawings,
    headersDrawings,
    footersDrawings,
    wrapTypeTables
  );
  for (const divide of lineSke.divides) {
    divide.parent = lineSke;
  }
  return lineSke;
}
function calculateLineTopByDrawings(lineHeight = 15.6, lineTop = 0, page, headerPage, footerPage) {
  let maxTop = lineTop;
  const pageSkeDrawings = page.skeDrawings;
  const skeNonWrapTables = new Map(Array.from(page.skeTables).filter(([_819, table2]) => table2.tableSource.textWrap === 0 /* NONE */));
  const headersDrawings = headerPage == null ? void 0 : headerPage.skeDrawings;
  const footersDrawings = footerPage == null ? void 0 : footerPage.skeDrawings;
  if (headerPage && headersDrawings) {
    headersDrawings.forEach((drawing) => {
      const transformedDrawing = translateHeaderFooterDrawingPosition(drawing, headerPage, page, true);
      const top = _getLineTopWidthWrapTopBottom(transformedDrawing, lineHeight, lineTop);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
  }
  if (footerPage && footersDrawings) {
    footersDrawings.forEach((drawing) => {
      const transformedDrawing = translateHeaderFooterDrawingPosition(drawing, footerPage, page, false);
      const top = _getLineTopWidthWrapTopBottom(transformedDrawing, lineHeight, lineTop);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
  }
  pageSkeDrawings == null ? void 0 : pageSkeDrawings.forEach((drawing) => {
    const top = _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop);
    if (top) {
      maxTop = Math.max(maxTop, top);
    }
  });
  skeNonWrapTables == null ? void 0 : skeNonWrapTables.forEach((table2) => {
    const top = _getLineTopWidthWrapNone(table2, lineHeight, lineTop);
    if (top) {
      maxTop = Math.max(maxTop, top);
    }
  });
  return maxTop;
}
function _getLineTopWidthWrapNone(table2, lineHeight, lineTop) {
  const { top, height } = table2;
  if (top + height < lineTop || top > lineHeight + lineTop) {
    return;
  }
  return top + height;
}
function _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop) {
  const { aTop, height, aLeft, width, angle = 0, drawingOrigin } = drawing;
  const { layoutType, distT = 0, distB = 0 } = drawingOrigin;
  if (layoutType !== 6 /* WRAP_TOP_AND_BOTTOM */) {
    return;
  }
  if (angle === 0) {
    const newAtop = aTop - distT;
    const newHeight = distT + height + distB;
    if (newAtop + newHeight < lineTop || newAtop > lineHeight + lineTop) {
      return;
    }
    return newAtop + newHeight;
  }
  let { top: sTop = 0, height: sHeight = 0 } = getBoundingBox(angle, aLeft, width, aTop, height);
  sTop -= distT;
  sHeight += distB;
  if (sTop + sHeight < lineTop || sTop > lineHeight + lineTop) {
    return;
  }
  return sTop + sHeight;
}
function _calculateDividesByDrawings(lineHeight, lineTop, columnWidth, paddingLeft, paddingRight, page, headerPage, footerPage, paragraphNonInlineSkeDrawings, headersDrawings, footersDrawings, wrapTypeTables) {
  const drawingsMix = [];
  drawingsMix.push(
    {
      left: 0,
      width: paddingLeft
    },
    {
      left: columnWidth - paddingRight,
      width: paddingRight
    }
  );
  if (headerPage && headersDrawings) {
    headersDrawings.forEach((drawing) => {
      const transformedDrawing = translateHeaderFooterDrawingPosition(drawing, headerPage, page, true);
      const split = _calculateSplit(transformedDrawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
  }
  if (footerPage && footersDrawings) {
    footersDrawings.forEach((drawing) => {
      const transformedDrawing = translateHeaderFooterDrawingPosition(drawing, footerPage, page, false);
      const split = _calculateSplit(transformedDrawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
  }
  paragraphNonInlineSkeDrawings == null ? void 0 : paragraphNonInlineSkeDrawings.forEach((drawing) => {
    const split = _calculateSplit(drawing, lineHeight, lineTop, columnWidth);
    if (split) {
      drawingsMix.push(split);
    }
  });
  if (wrapTypeTables && wrapTypeTables.size > 0) {
    wrapTypeTables.forEach((table2) => {
      const { left, top, width, height, tableSource } = table2;
      const { dist } = tableSource;
      const split = __getSplitWidthNoAngle(top, height, left, width, lineTop, lineHeight, columnWidth, dist);
      if (split) {
        drawingsMix.push(split);
      }
    });
  }
  return _calculateDivideByDrawings(columnWidth, drawingsMix);
}
function updateDivideInfo(divide, states) {
  Object.assign(divide, states);
}
function setLineMarginBottom(line2, marginBottom) {
  line2.marginBottom = marginBottom;
}
function collisionDetection(floatObject, lineHeight, lineTop, columnLeft, columnWidth) {
  const { top: oTop, height: oHeight, left: oLeft, width: oWidth, angle = 0 } = floatObject;
  const { top = 0, left = 0, width = 0, height = 0 } = getBoundingBox(angle, oLeft, oWidth, oTop, oHeight);
  if (top + height < lineTop || top > lineHeight + lineTop) {
    return false;
  }
  if (left + width < columnLeft || left > columnLeft + columnWidth) {
    return false;
  }
  return true;
}
function _calculateSplit(drawing, lineHeight, lineTop, columnWidth) {
  const { aTop, height, aLeft, width, angle = 0, drawingOrigin } = drawing;
  const { layoutType } = drawingOrigin;
  if (layoutType === 1 /* WRAP_NONE */ || layoutType === 6 /* WRAP_TOP_AND_BOTTOM */) {
    return;
  }
  if (layoutType === 2 /* WRAP_POLYGON */) {
    const { start = [0, 0], lineTo } = drawingOrigin;
    if (!lineTo) {
      return;
    }
    const points = [];
    points.push(new Vector2(start[0], start[1]));
    for (let i = 0; i < lineTo.length; i++) {
      const point = lineTo[i];
      points.push(new Vector2(point[0], point[1]));
    }
    if (angle !== 0) {
      const transform = new Transform().rotate(angle);
      for (let i = 0; i < points.length; i++) {
        const point = points[i];
        points[i] = transform.applyPoint(point);
      }
    }
    return __getCrossPoint(points, lineTop, lineHeight, columnWidth);
  }
  const { distL = 0, distT = 0, distB = 0, distR = 0, wrapText } = drawingOrigin;
  const dist = { distL, distT, distB, distR };
  if (angle === 0) {
    return __getSplitWidthNoAngle(aTop, height, aLeft, width, lineTop, lineHeight, columnWidth, dist, layoutType, wrapText);
  }
  const boundingBox = getBoundingBox(angle, aLeft, width, aTop, height);
  if (layoutType === 3 /* WRAP_SQUARE */) {
    const { left: sLeft, width: sWidth, top: sTop, height: sHeight } = boundingBox;
    return __getSplitWidthNoAngle(
      sTop,
      sHeight,
      sLeft,
      sWidth,
      lineTop,
      lineHeight,
      columnWidth,
      dist,
      layoutType,
      wrapText
    );
  }
  return __getCrossPoint(boundingBox.points, lineTop, lineHeight, columnWidth);
}
function getBoundingBox(angle, left, width, top, height) {
  const centerX = left + width / 2;
  const centerY = top + height / 2;
  const transform = new Transform().translate(centerX, centerY).rotate(angle).translate(-centerX, -centerY);
  const lt = new Vector2(left, top);
  const lb = new Vector2(left, top + height);
  const rt = new Vector2(left + width, top);
  const rb = new Vector2(left + width, top + height);
  const boundingBox = transform.makeBoundingBoxFromPoints([lt, lb, rt, rb]);
  return boundingBox;
}
function translateHeaderFooterDrawingPosition(drawing, segmentPage, page, isHeader = true) {
  const { aTop: prevATop } = drawing;
  let aTop = prevATop;
  if (isHeader) {
    aTop = prevATop + segmentPage.marginTop - page.marginTop;
  } else {
    aTop = prevATop + segmentPage.marginTop + page.pageHeight - page.marginBottom - page.marginTop;
  }
  return {
    ...drawing,
    aTop
  };
}
function __getCrossPoint(points, lineTop, lineHeight, columnWidth) {
  const path = new Path2(points);
  const crossPointTop = path.intersection([new Vector2(0, lineTop), new Vector2(columnWidth, lineTop)]);
  const crossPointBottom = path.intersection([
    new Vector2(0, lineTop + lineHeight),
    new Vector2(columnWidth, lineTop + lineHeight)
  ]);
  if (!crossPointTop && !crossPointBottom) {
    return;
  }
  const range = ___getMaxAndMinAxis([...points, ...crossPointTop || [], ...crossPointBottom || []]);
  return {
    left: range.min,
    width: range.max
  };
}
function ___getMaxAndMinAxis(points, axis = 0 /* X */) {
  const result = [];
  for (let i = 0; i < points.length; i++) {
    const point = points[i];
    if (axis === 0 /* X */) {
      result.push(point.x);
    } else {
      result.push(point.y);
    }
  }
  return {
    max: Math.max(...result),
    min: Math.min(...result)
  };
}
function __getSplitWidthNoAngle(top, height, left, width, lineTop, lineHeight, columnWidth, dist, layoutType = 3 /* WRAP_SQUARE */, wrapText = 0 /* BOTH_SIDES */) {
  const {
    distL = 0,
    distR = 0,
    distT = 0,
    distB = 0
  } = dist;
  const newAtop = top - (layoutType === 3 /* WRAP_SQUARE */ ? distT : 0);
  const newHeight = height + (layoutType === 3 /* WRAP_SQUARE */ ? distB + distT : 0);
  if (newAtop + newHeight <= lineTop || newAtop >= lineHeight + lineTop) {
    return;
  }
  let resultLeft = left - distL;
  let resultWidth = width + distL + distR;
  const ruler = ___getWrapTextRuler(wrapText, resultLeft, resultWidth, columnWidth);
  if (ruler === 1 /* LEFT */) {
    resultWidth = columnWidth - resultLeft;
  } else if (ruler === 2 /* RIGHT */) {
    resultLeft = 0;
    resultWidth = left + width + distR;
  }
  return {
    left: resultLeft,
    width: resultWidth
  };
}
function ___getWrapTextRuler(wrapText, resultLeft, resultWidth, columnWidth) {
  let ruler = 0 /* BOTH */;
  if (wrapText === 1 /* LEFT */) {
    ruler = 1 /* LEFT */;
  } else if (wrapText === 2 /* RIGHT */) {
    ruler = 2 /* RIGHT */;
  } else if (wrapText === 3 /* LARGEST */) {
    if (resultLeft > columnWidth - resultLeft - resultWidth) {
      ruler = 1 /* LEFT */;
    } else {
      ruler = 2 /* RIGHT */;
    }
  }
  return ruler;
}
function _calculateDivideByDrawings(columnWidth, drawingSplit) {
  drawingSplit.sort((pre, next) => {
    if (pre.left > next.left) {
      return 1;
    }
    return -1;
  });
  const divideSkeleton = [];
  let start = 0;
  const splitLength = drawingSplit.length;
  for (let i = 0; i < splitLength; i++) {
    const split = drawingSplit[i];
    const { left, width } = split;
    if (left > start) {
      let width2 = left - start;
      width2 = width2 < columnWidth ? width2 : columnWidth - start;
      const divide = __getDivideSKe(start, width2);
      divideSkeleton.push(divide);
    }
    start = Math.max(left + width, start);
    if (i === splitLength - 1 && left + width < columnWidth) {
      const divide = __getDivideSKe(left + width, columnWidth - left - width);
      divideSkeleton.push(divide);
    }
  }
  return divideSkeleton;
}
function __getDivideSKe(left, width) {
  return {
    // divide 分割，为了适配插入对象、图片、表格等，图文混排
    glyphGroup: [],
    // glyphGroup
    width,
    // width 被分割后的总宽度
    left,
    // left 被对象分割后的偏移位置 | d1 | | d2 |
    paddingLeft: 0,
    // paddingLeft 根据horizonAlign和width计算对齐偏移
    isFull: false,
    // isFull， // 内容是否装满
    st: 0,
    // startIndex
    ed: 0
    // endIndex
  };
}
function _getLineSke(lineType, paragraphIndex) {
  return {
    paragraphIndex,
    type: lineType,
    divides: [],
    // /divides 受到对象影响，把行切分为 N 部分
    lineHeight: 0,
    // lineHeight =max(glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent, span2.....) + space
    contentHeight: 0,
    // contentHeight =max(glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent, span2.....)
    top: 0,
    // top paragraph(spaceAbove, spaceBelow, lineSpacing*PreLineHeight)
    asc: 0,
    // =max(glyph.textMetrics.ba) alphaBeta对齐，需要校准
    dsc: 0,
    // =max(glyph.textMetrics.bd) alphaBeta对齐，需要校准
    paddingTop: 0,
    // paddingTop 内容到顶部的距离
    paddingBottom: 0,
    // paddingBottom 内容到底部的距离
    marginTop: 0,
    // marginTop 针对段落的spaceAbove
    marginBottom: 0,
    // marginBottom 针对段落的spaceBelow
    spaceBelowApply: 0,
    // lineSpacingApply
    divideLen: 0,
    // divideLen 被对象分割为多少块
    st: -1,
    // startIndex 文本开始索引
    ed: -1,
    // endIndex 文本结束索引
    isBehindTable: false,
    // isBehindTable 是否在表格后面
    tableId: "",
    // tableId 表格id
    lineIndex: 0,
    // lineIndex 行号
    paragraphStart: false
  };
}
function createAndUpdateBlockAnchor(paragraphIndex, line2, top, drawingAnchor) {
  if (!drawingAnchor) {
    return;
  }
  if (drawingAnchor.has(paragraphIndex)) {
    const anchor = drawingAnchor.get(paragraphIndex);
    anchor == null ? void 0 : anchor.elements.push(line2);
  } else {
    drawingAnchor.set(paragraphIndex, {
      elements: [line2],
      paragraphIndex,
      top
    });
  }
}

// ../packages/engine-render/src/components/docs/layout/model/section.ts
function createSkeletonSection(columnProperties = [], columnSeparatorType = 1 /* NONE */, top = 0, left = 0, sectionWidth = Number.POSITIVE_INFINITY, sectionHeight = Number.POSITIVE_INFINITY) {
  const columns = [];
  let colWidth = 0;
  let spaceWidth = 0;
  if (columnProperties.length === 0) {
    columns.push(_getSkeletonColumn(left, sectionWidth, 0, 1 /* NONE */));
  } else {
    for (let i = 0; i < columnProperties.length; i++) {
      const { width, paddingEnd } = columnProperties[i];
      spaceWidth = paddingEnd;
      colWidth = width;
      columns.push(_getSkeletonColumn(left, colWidth, spaceWidth, columnSeparatorType));
      left += colWidth + spaceWidth;
      if (i === columnProperties.length - 1) {
        colWidth = sectionWidth !== Number.POSITIVE_INFINITY ? sectionWidth - colWidth : width;
        spaceWidth = 0;
        columns.push(_getSkeletonColumn(left, colWidth, spaceWidth, columnSeparatorType));
      }
    }
  }
  const newSection = {
    columns,
    colCount: (columnProperties == null ? void 0 : columnProperties.length) || 1,
    height: sectionHeight,
    top,
    st: 0,
    ed: 0
  };
  columns.forEach((column) => {
    column.parent = newSection;
  });
  return newSection;
}
function setColumnFullState(column, state) {
  column.isFull = state;
}
function _getSkeletonColumn(left, width, spaceWidth, columnSeparatorType) {
  return {
    lines: [],
    // column坐标系相对于section
    left,
    width,
    height: 0,
    spaceWidth,
    separator: columnSeparatorType,
    st: 0,
    ed: 0,
    drawingLRIds: [],
    isFull: false
  };
}

// ../packages/engine-render/src/components/docs/layout/block/table.ts
function createTableSkeleton(ctx, curPage, viewModel, tableNode, sectionBreakConfig) {
  var _a;
  const { startIndex, endIndex, children: rowNodes } = tableNode;
  const table2 = (_a = viewModel.getTableByStartIndex(startIndex)) == null ? void 0 : _a.tableSource;
  if (table2 == null) {
    throw new Error("Table not found");
  }
  const tableSkeleton = getNullTableSkeleton(startIndex, endIndex, table2);
  let rowTop = 0;
  let tableWidth = 0;
  for (const rowNode of rowNodes) {
    const { children: cellNodes, startIndex: startIndex2, endIndex: endIndex2 } = rowNode;
    const row = rowNodes.indexOf(rowNode);
    const rowSource = table2.tableRows[row];
    const { trHeight } = rowSource;
    const rowSkeleton = _getNullTableRowSkeleton(startIndex2, endIndex2, row, rowSource, false, tableSkeleton);
    const { hRule, val } = trHeight;
    tableSkeleton.rows.push(rowSkeleton);
    let left = 0;
    let rowHeight = 0;
    for (const cellNode of cellNodes) {
      const col = cellNodes.indexOf(cellNode);
      const cellPageSkeleton = createSkeletonCellPages(
        ctx,
        viewModel,
        cellNode,
        sectionBreakConfig,
        table2,
        row,
        col
      )[0];
      const { marginTop = 0, marginBottom = 0 } = cellPageSkeleton;
      const pageHeight = cellPageSkeleton.height + marginTop + marginBottom;
      cellPageSkeleton.left = left;
      left += cellPageSkeleton.pageWidth;
      cellPageSkeleton.parent = rowSkeleton;
      rowSkeleton.cells.push(cellPageSkeleton);
      rowHeight = Math.max(rowHeight, pageHeight);
    }
    if (hRule === 1 /* AT_LEAST */) {
      rowHeight = Math.max(rowHeight, val.v);
    } else if (hRule === 2 /* EXACT */) {
      rowHeight = val.v;
    }
    for (const cellPageSkeleton of rowSkeleton.cells) {
      cellPageSkeleton.pageHeight = rowHeight;
    }
    const rowConfig = table2.tableRows[row];
    for (let i = 0; i < rowConfig.tableCells.length; i++) {
      const cellConfig = rowConfig.tableCells[i];
      const cellPageSkeleton = rowSkeleton.cells[i];
      const { vAlign = 0 /* CONTENT_ALIGNMENT_UNSPECIFIED */ } = cellConfig;
      const { pageHeight, height, originMarginTop, originMarginBottom } = cellPageSkeleton;
      let marginTop = originMarginTop;
      switch (vAlign) {
        case 2 /* TOP */: {
          marginTop = originMarginTop;
          break;
        }
        case 3 /* CENTER */: {
          marginTop = (pageHeight - height) / 2;
          break;
        }
        case 4 /* BOTTOM */: {
          marginTop = pageHeight - height - originMarginBottom;
          break;
        }
        default:
          break;
      }
      marginTop = Math.max(originMarginTop, marginTop);
      cellPageSkeleton.marginTop = marginTop;
    }
    rowSkeleton.height = rowHeight;
    rowSkeleton.top = rowTop;
    rowTop += rowHeight;
    tableWidth = Math.max(tableWidth, left);
  }
  tableSkeleton.width = tableWidth;
  tableSkeleton.height = rowTop;
  const { pageWidth, marginLeft = 0, marginRight = 0 } = curPage;
  tableSkeleton.left = _getTableLeft(pageWidth - marginLeft - marginRight, tableWidth, table2.align, table2.indent);
  return tableSkeleton;
}
function rollbackListCache(listLevel, table2) {
  const { startIndex, endIndex } = table2;
  for (const paragraphLists of listLevel.values()) {
    for (const paragraphList of paragraphLists) {
      const paragraphListIndex = paragraphList.findIndex((p) => p.paragraph.startIndex > startIndex && p.paragraph.startIndex < endIndex);
      if (paragraphListIndex > -1) {
        paragraphList.splice(paragraphListIndex);
      }
    }
  }
}
function createTableSkeletons(ctx, curPage, viewModel, tableNode, sectionBreakConfig, availableHeight) {
  var _a;
  const skeTables = [];
  const { startIndex, endIndex, children: rowNodes } = tableNode;
  const table2 = (_a = viewModel.getTableByStartIndex(startIndex)) == null ? void 0 : _a.tableSource;
  if (table2 == null) {
    throw new Error("Table not found when creating table skeletons");
  }
  const needRepeatHeader = table2.tableRows[0].repeatHeaderRow === 1 /* TRUE */;
  const curTableSkeleton = getNullTableSkeleton(startIndex, endIndex, table2);
  const createCache = {
    rowTop: 0,
    tableWidth: 0,
    remainHeight: availableHeight,
    repeatRow: needRepeatHeader ? rowNodes[0] : null,
    repeatRowHeight: 0
  };
  skeTables.push(curTableSkeleton);
  for (const rowNode of rowNodes) {
    const row = rowNodes.indexOf(rowNode);
    dealWithTableRow(
      ctx,
      curPage,
      skeTables,
      viewModel,
      sectionBreakConfig,
      rowNode,
      row,
      table2,
      createCache
    );
  }
  updateTableSkeletonsPosition(createCache, curPage, skeTables, table2);
  const fromCurrentPage = skeTables[0].height <= availableHeight;
  return {
    skeTables,
    fromCurrentPage
  };
}
function updateTableSkeletonsPosition(cache, curPage, skeTables, table2) {
  const { pageWidth, marginLeft = 0, marginRight = 0 } = curPage;
  const { tableWidth } = cache;
  const tableLeft = _getTableLeft(pageWidth - marginLeft - marginRight, tableWidth, table2.align, table2.indent);
  let tableIndex = 0;
  for (const tableSkeleton of skeTables) {
    tableSkeleton.width = tableWidth;
    tableSkeleton.left = tableLeft;
    tableSkeleton.st = tableSkeleton.rows[0].st - 1;
    tableSkeleton.ed = tableSkeleton.rows[tableSkeleton.rows.length - 1].ed + 1;
    if (skeTables.length > 1) {
      tableSkeleton.tableId = getTableSliceId(table2.tableId, tableIndex);
      tableIndex++;
    }
  }
}
function getCurTableSkeleton(skeTables) {
  return skeTables[skeTables.length - 1];
}
function getAvailableHeight(curPage, cache, hasRepeatHeader) {
  const { marginTop, marginBottom, pageHeight } = curPage;
  let pageContentHeight = pageHeight - marginTop - marginBottom;
  if (hasRepeatHeader) {
    pageContentHeight -= cache.repeatRowHeight;
  }
  return pageContentHeight;
}
function dealWithTableRow(ctx, curPage, skeTables, viewModel, sectionBreakConfig, rowNode, row, table2, cache, isRepeatRow = false) {
  const pageContentHeight = getAvailableHeight(curPage, cache, false);
  const availableHeight = getAvailableHeight(curPage, cache, true);
  const { children: cellNodes, startIndex, endIndex } = rowNode;
  const rowSource = table2.tableRows[row];
  const { trHeight, cantSplit } = rowSource;
  const rowSkeletons = [];
  const { hRule, val } = trHeight;
  const canRowSplit = cantSplit === 1 /* TRUE */ && trHeight.hRule === 0 /* AUTO */;
  const MAX_FONT_SIZE2 = 72;
  const needOpenNewTable = cache.remainHeight <= MAX_FONT_SIZE2;
  let curTableSkeleton = getCurTableSkeleton(skeTables);
  const rowHeights = [0];
  for (const cellNode of cellNodes) {
    const col = cellNodes.indexOf(cellNode);
    const cellPageSkeletons = createSkeletonCellPages(
      ctx,
      viewModel,
      cellNode,
      sectionBreakConfig,
      table2,
      row,
      col,
      canRowSplit && !needOpenNewTable ? cache.remainHeight : availableHeight,
      pageContentHeight
    );
    while (rowSkeletons.length < cellPageSkeletons.length) {
      const rowSkeleton = _getNullTableRowSkeleton(startIndex, endIndex, row, rowSource, isRepeatRow);
      const colCount = cellNodes.length;
      rowSkeleton.cells = [...new Array(colCount)].map((_819, i) => {
        const cellSkeleton = createNullCellPage(
          ctx,
          sectionBreakConfig,
          table2,
          row,
          i
        ).page;
        cellSkeleton.parent = rowSkeleton;
        return cellSkeleton;
      });
      rowSkeletons.push(rowSkeleton);
    }
    while (rowHeights.length < cellPageSkeletons.length) {
      rowHeights.push(0);
    }
    for (const cellPageSkeleton of cellPageSkeletons) {
      const { marginTop: cellMarginTop = 0, marginBottom: cellMarginBottom = 0 } = cellPageSkeleton;
      const cellPageHeight = cellPageSkeleton.height + cellMarginTop + cellMarginBottom;
      const pageIndex = cellPageSkeletons.indexOf(cellPageSkeleton);
      const rowSke = rowSkeletons[pageIndex];
      cellPageSkeleton.parent = rowSke;
      rowSke.cells[col] = cellPageSkeleton;
      rowHeights[pageIndex] = Math.max(rowHeights[pageIndex], cellPageHeight);
    }
  }
  for (const rowSke of rowSkeletons) {
    const rowIndex = rowSkeletons.indexOf(rowSke);
    if (hRule === 1 /* AT_LEAST */) {
      rowHeights[rowIndex] = Math.max(rowHeights[rowIndex], val.v);
    } else if (hRule === 2 /* EXACT */) {
      rowHeights[rowIndex] = val.v;
    }
    rowHeights[rowIndex] = Math.min(rowHeights[rowIndex], pageContentHeight);
    let left = 0;
    for (const cellPageSkeleton of rowSke.cells) {
      cellPageSkeleton.left = left;
      cellPageSkeleton.pageHeight = rowHeights[rowIndex];
      left += cellPageSkeleton.pageWidth;
      cache.tableWidth = Math.max(cache.tableWidth, left);
    }
    rowSke.height = rowHeights[rowIndex];
  }
  if (row === 0 && cache.repeatRow) {
    cache.repeatRowHeight = rowHeights[rowHeights.length - 1];
  }
  for (const rowSkeleton of rowSkeletons) {
    _verticalAlignInCell(rowSkeleton, rowSource);
  }
  while (rowSkeletons.length > 0) {
    const rowSkeleton = rowSkeletons.shift();
    const lastRow = curTableSkeleton.rows[curTableSkeleton.rows.length - 1];
    if (cache.remainHeight < MAX_FONT_SIZE2 || cache.remainHeight < rowSkeleton.height) {
      cache.remainHeight = getAvailableHeight(curPage, cache, row !== 0 && rowSkeleton.index !== lastRow.index);
      cache.rowTop = 0;
      if (curTableSkeleton.rows.length > 0) {
        curTableSkeleton = getNullTableSkeleton(startIndex, endIndex, table2);
        skeTables.push(curTableSkeleton);
        if (cache.repeatRow && isRepeatRow === false && row !== 0 && rowSkeleton.index !== lastRow.index) {
          const FIRST_ROW_INDEX = 0;
          cache.remainHeight = getAvailableHeight(curPage, cache, false);
          dealWithTableRow(
            ctx,
            curPage,
            skeTables,
            viewModel,
            sectionBreakConfig,
            cache.repeatRow,
            FIRST_ROW_INDEX,
            table2,
            cache,
            true
          );
        }
      }
    }
    curTableSkeleton = getCurTableSkeleton(skeTables);
    rowSkeleton.top = cache.rowTop;
    curTableSkeleton.height += rowSkeleton.height;
    curTableSkeleton.rows.push(rowSkeleton);
    rowSkeleton.parent = curTableSkeleton;
    cache.remainHeight -= rowSkeleton.height;
    cache.rowTop += rowSkeleton.height;
  }
}
function _verticalAlignInCell(rowSkeleton, rowSource) {
  for (let i = 0; i < rowSource.tableCells.length; i++) {
    const cellConfig = rowSource.tableCells[i];
    const cellPageSkeleton = rowSkeleton.cells[i];
    if (cellPageSkeleton == null) {
      continue;
    }
    const { vAlign = 0 /* CONTENT_ALIGNMENT_UNSPECIFIED */ } = cellConfig;
    const { pageHeight, height, originMarginTop, originMarginBottom } = cellPageSkeleton;
    let marginTop = originMarginTop;
    switch (vAlign) {
      case 2 /* TOP */: {
        marginTop = originMarginTop;
        break;
      }
      case 3 /* CENTER */: {
        marginTop = (pageHeight - height) / 2;
        break;
      }
      case 4 /* BOTTOM */: {
        marginTop = pageHeight - height - originMarginBottom;
        break;
      }
      default:
        break;
    }
    marginTop = Math.max(originMarginTop, marginTop);
    cellPageSkeleton.marginTop = marginTop;
  }
}
function _getTableLeft(pageWidth, tableWidth, align, indent = { v: 0 }) {
  switch (align) {
    case 0 /* START */: {
      return indent.v;
    }
    case 2 /* END */: {
      return Math.max(0, pageWidth - tableWidth);
    }
    case 1 /* CENTER */: {
      return Math.max(0, (pageWidth - tableWidth) / 2);
    }
    default: {
      throw new Error("Unknown table alignment type");
    }
  }
}
function getNullTableSkeleton(st, ed, table2) {
  return {
    rows: [],
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    st,
    ed,
    tableId: table2.tableId,
    tableSource: table2
  };
}
function _getNullTableRowSkeleton(st, ed, index, rowSource, isRepeatRow = false, parent) {
  return {
    cells: [],
    index,
    height: 0,
    top: 0,
    st,
    ed,
    parent,
    rowSource,
    isRepeatRow
  };
}
function getTableSliceId(tableId, sliceIndex) {
  return `${tableId}#-#${sliceIndex}`;
}
function getTableIdAndSliceIndex(tableSliceId) {
  if (!tableSliceId.includes("#-#")) {
    return {
      tableId: tableSliceId,
      sliceIndex: 0
    };
  }
  const [tableId, sliceIndex] = tableSliceId.split("#-#");
  return {
    tableId,
    sliceIndex: Number(sliceIndex)
  };
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/layout-ruler.ts
function layoutParagraph(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType = "Normal" /* Normal */) {
  if (isParagraphFirstShapedText) {
    if (paragraphConfig.bulletSkeleton) {
      const { bulletSkeleton, paragraphStyle = {} } = paragraphConfig;
      const { gridType = 1 /* LINES */, charSpace = 0, defaultTabStop = 10.5 } = sectionBreakConfig;
      const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
      const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
      const bulletGlyph = createSkeletonBulletGlyph(glyphGroup[0], bulletSkeleton, charSpaceApply);
      const paragraphProperties = bulletSkeleton.paragraphProperties || {};
      paragraphConfig.paragraphStyle = mergeByV(paragraphConfig.paragraphStyle, { ...paragraphProperties, hanging: { v: bulletGlyph.width } }, "max");
      _lineOperator(ctx, [bulletGlyph, ...glyphGroup], pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType);
    } else {
      _lineOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType);
    }
  } else {
    _divideOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType);
  }
  return [...pages];
}
function isGlyphGroupEndWithWhiteSpaces(glyphGroup) {
  if (glyphGroup.length <= 1) {
    return false;
  }
  let isInWhiteSpace = false;
  for (const g of glyphGroup) {
    if (g.content === " " /* SPACE */) {
      isInWhiteSpace = true;
    }
    if (isInWhiteSpace && g.content !== " " /* SPACE */ && g.content !== "\r" /* PARAGRAPH */ && g.streamType !== "\n" /* SECTION_BREAK */) {
      return false;
    }
  }
  return isInWhiteSpace;
}
function isGlyphGroupBeyondContentBox(glyphGroup, left, divideWidth) {
  if (glyphGroup.length <= 1) {
    return false;
  }
  let width = left;
  let isBeyondContentBox = false;
  for (const g of glyphGroup) {
    if (g.content === " " /* SPACE */ || g.content === "\r" /* PARAGRAPH */ || g.streamType === "\n" /* SECTION_BREAK */) {
      break;
    }
    width += g.width;
    if (width > divideWidth) {
      isBeyondContentBox = true;
      break;
    }
  }
  return isBeyondContentBox;
}
function _getConsecutiveHyphenLineCount(divide) {
  var _a;
  const column = (_a = divide.parent) == null ? void 0 : _a.parent;
  if (column == null) {
    return 0;
  }
  let count = 0;
  for (let i = column.lines.length - 1; i >= 0; i--) {
    const line2 = column.lines[i];
    const lastDivide = line2.divides[line2.divides.length - 1];
    if (lastDivide.breakType === "Hyphen" /* Hyphen */) {
      count++;
    } else {
      break;
    }
  }
  return count;
}
function _popHyphenSlice(divide) {
  const glyphGroup = [];
  let lastGlyph = divide.glyphGroup.pop();
  while (lastGlyph && lastGlyph.content !== " ") {
    glyphGroup.unshift(lastGlyph);
    lastGlyph = divide.glyphGroup.pop();
  }
  if (divide.glyphGroup.length === 0) {
    divide.glyphGroup.push(...glyphGroup);
    glyphGroup.length = 0;
  }
  return glyphGroup;
}
function _divideOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType = "Normal" /* Normal */, defaultSpanLineHeight) {
  var _a;
  const lastPage = getLastPage(pages);
  const divideInfo = getLastNotFullDivideInfo(lastPage);
  if (divideInfo) {
    const width = __getGlyphGroupWidth(glyphGroup);
    const { divide, isLast } = divideInfo;
    const lastGlyph = (_a = divide == null ? void 0 : divide.glyphGroup) == null ? void 0 : _a[divide.glyphGroup.length - 1];
    const lastWidth = (lastGlyph == null ? void 0 : lastGlyph.width) || 0;
    const lastLeft = (lastGlyph == null ? void 0 : lastGlyph.left) || 0;
    const preOffsetLeft = lastWidth + lastLeft;
    const { hyphenationZone } = sectionBreakConfig;
    if (preOffsetLeft + width > divide.width) {
      updateDivideInfo(divide, {
        isFull: true
      });
      const hyphenLineCount = _getConsecutiveHyphenLineCount(divideInfo.divide);
      const { consecutiveHyphenLimit = Number.POSITIVE_INFINITY } = sectionBreakConfig;
      if (divideInfo.isLast && glyphGroup.length === 1 && (glyphGroup[0].content === " " /* SPACE */ || glyphGroup[0].content === "\r" /* PARAGRAPH */)) {
        addGlyphToDivide(divide, glyphGroup, preOffsetLeft);
      } else if (
        // If a line of text ends with consecutive spaces, the spaces should not be placed on the second line.
        divideInfo.isLast && !isGlyphGroupBeyondContentBox(glyphGroup, preOffsetLeft, divide.width) && isGlyphGroupEndWithWhiteSpaces(glyphGroup)
      ) {
        addGlyphToDivide(divide, glyphGroup, preOffsetLeft);
      } else if ((divide == null ? void 0 : divide.glyphGroup.length) === 0) {
        const sliceGlyphGroup = [];
        while (glyphGroup.length) {
          sliceGlyphGroup.push(glyphGroup.shift());
          const sliceGlyphGroupWidth = __getGlyphGroupWidth(sliceGlyphGroup);
          if (sliceGlyphGroupWidth > divide.width) {
            if (sliceGlyphGroup.length > 1) {
              glyphGroup.unshift(sliceGlyphGroup.pop());
            }
            break;
          }
        }
        if (sliceGlyphGroup.length > 0) {
          addGlyphToDivide(divide, sliceGlyphGroup, preOffsetLeft);
        }
        if (glyphGroup.length) {
          _divideOperator(
            ctx,
            glyphGroup,
            pages,
            sectionBreakConfig,
            paragraphConfig,
            false,
            breakPointType,
            defaultSpanLineHeight
          );
        }
      } else if (hyphenLineCount > consecutiveHyphenLimit) {
        const hyphenSliceGlyphGroup = _popHyphenSlice(divide);
        if (hyphenSliceGlyphGroup.length > 0) {
          updateDivideInfo(divide, {
            breakType: "Normal" /* Normal */
          });
          _divideOperator(ctx, hyphenSliceGlyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, "Hyphen" /* Hyphen */);
        }
        _divideOperator(
          ctx,
          glyphGroup,
          pages,
          sectionBreakConfig,
          paragraphConfig,
          isParagraphFirstShapedText,
          breakPointType,
          defaultSpanLineHeight
        );
      } else {
        _divideOperator(
          ctx,
          glyphGroup,
          pages,
          sectionBreakConfig,
          paragraphConfig,
          isParagraphFirstShapedText,
          breakPointType,
          defaultSpanLineHeight
        );
      }
    } else if (
      // Determine if first word slice appears inside the hyphenation zone.
      isLast && hyphenationZone && hyphenationZone > 0 && preOffsetLeft >= divide.width - hyphenationZone && breakPointType === "Hyphen" /* Hyphen */ && divide.breakType === "Normal" /* Normal */
    ) {
      updateDivideInfo(divide, {
        isFull: true
      });
      _divideOperator(
        ctx,
        glyphGroup,
        pages,
        sectionBreakConfig,
        paragraphConfig,
        isParagraphFirstShapedText,
        breakPointType,
        defaultSpanLineHeight
      );
    } else {
      const currentLine = divide.parent;
      const maxBox = __maxFontBoundingBoxByGlyphGroup(glyphGroup);
      if (currentLine && maxBox && !__isNullLine(currentLine)) {
        const { paragraphLineGapDefault, linePitch, lineSpacing, spacingRule, snapToGrid, gridType } = getLineHeightConfig(sectionBreakConfig, paragraphConfig);
        const { boundingBoxAscent, boundingBoxDescent } = maxBox;
        const spanLineHeight = boundingBoxAscent + boundingBoxDescent;
        const { contentHeight } = __getLineHeight(
          spanLineHeight,
          paragraphLineGapDefault,
          linePitch,
          gridType,
          lineSpacing,
          spacingRule,
          snapToGrid
        );
        if (currentLine.contentHeight < contentHeight) {
          const spanGroupCached = __getGlyphGroupByLine(currentLine);
          const spanGroupCachedLen = spanGroupCached.length;
          let newGlyphGroup = [];
          let startIndex = 1;
          if (spanGroupCachedLen > 2 && spanGroupCached[0].glyphType === 2 /* LIST */) {
            newGlyphGroup = [spanGroupCached[0], spanGroupCached[1]];
            startIndex = 2;
          } else {
            newGlyphGroup = [spanGroupCached[0]];
          }
          const column = currentLine.parent;
          const { paragraphStart: lineIsStart } = column == null ? void 0 : column.lines.pop();
          _lineOperator(
            ctx,
            newGlyphGroup,
            pages,
            sectionBreakConfig,
            paragraphConfig,
            lineIsStart,
            breakPointType,
            boundingBoxAscent + boundingBoxDescent
          );
          for (let i = startIndex; i < spanGroupCached.length; i++) {
            _divideOperator(
              ctx,
              [spanGroupCached[i]],
              pages,
              sectionBreakConfig,
              paragraphConfig,
              isParagraphFirstShapedText
            );
          }
          _divideOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType);
          return;
        }
      }
      addGlyphToDivide(divide, glyphGroup, preOffsetLeft);
      updateDivideInfo(divide, { breakType: breakPointType });
    }
  } else {
    _lineOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType, defaultSpanLineHeight);
  }
}
function _lineOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType = "Normal" /* Normal */, defaultGlyphLineHeight) {
  var _a, _b, _c, _d, _e, _f, _g;
  let lastPage = getLastPage(pages);
  let columnInfo = getLastNotFullColumnInfo(lastPage);
  if (!columnInfo || !columnInfo.column) {
    _pageOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, true, breakPointType);
    lastPage = getLastPage(pages);
    columnInfo = getLastNotFullColumnInfo(lastPage);
  }
  if (!columnInfo) return;
  const column = columnInfo.column;
  if (column.width <= 0) {
    console.error("The column width is less than 0, need to adjust page width to make it great than 0");
    return;
  }
  const preLine = getLastLineByColumn(column);
  const ascent = Math.max(...glyphGroup.map((glyph) => glyph.bBox.ba));
  const descent = Math.max(...glyphGroup.map((glyph) => glyph.bBox.bd));
  const glyphLineHeight = defaultGlyphLineHeight || ascent + descent;
  const {
    paragraphStyle = {},
    paragraphNonInlineSkeDrawings,
    skeTablesInParagraph,
    skeHeaders,
    skeFooters,
    pDrawingAnchor,
    paragraphIndex
  } = paragraphConfig;
  const {
    // direction,
    spaceAbove,
    spaceBelow,
    indentFirstLine,
    hanging,
    indentStart,
    indentEnd
  } = paragraphStyle;
  const {
    paragraphLineGapDefault,
    linePitch,
    lineSpacing,
    spacingRule,
    snapToGrid,
    gridType
  } = getLineHeightConfig(
    sectionBreakConfig,
    paragraphConfig
  );
  const { paddingTop, paddingBottom, contentHeight, lineSpacingApply } = __getLineHeight(
    glyphLineHeight,
    paragraphLineGapDefault,
    linePitch,
    gridType,
    lineSpacing,
    spacingRule,
    snapToGrid
  );
  const { marginTop, spaceBelowApply } = __getParagraphSpace(
    ctx,
    lineSpacingApply,
    spaceAbove,
    spaceBelow,
    isParagraphFirstShapedText,
    preLine
  );
  const lineHeight = marginTop + paddingTop + contentHeight + paddingBottom;
  let section = column.parent;
  if (!section) {
    section = getLastSection(lastPage);
  }
  const preLineHeight = (preLine == null ? void 0 : preLine.lineHeight) || 0;
  const preTop = (preLine == null ? void 0 : preLine.top) || 0;
  const lineTop = preLineHeight + preTop;
  const { pageWidth, headerId, footerId, segmentId } = lastPage;
  const headerPage = (_a = skeHeaders == null ? void 0 : skeHeaders.get(headerId)) == null ? void 0 : _a.get(pageWidth);
  const footerPage = (_b = skeFooters == null ? void 0 : skeFooters.get(footerId)) == null ? void 0 : _b.get(pageWidth);
  let needOpenNewPageByTableLayout = false;
  if (preLine) {
    const drawingsInLine = _getCustomBlockIdsInLine(preLine);
    if (drawingsInLine.length > 0) {
      const affectDrawings = (_d = (_c = ctx.paragraphConfigCache.get(segmentId)) == null ? void 0 : _c.get(preLine.paragraphIndex)) == null ? void 0 : _d.paragraphNonInlineSkeDrawings;
      const relativeLineDrawings = [...(_e = affectDrawings == null ? void 0 : affectDrawings.values()) != null ? _e : []].filter((drawing) => drawing.drawingOrigin.docTransform.positionV.relativeFrom === 2 /* LINE */).filter((drawing) => drawingsInLine.includes(drawing.drawingId));
      if (relativeLineDrawings.length > 0) {
        __updateAndPositionDrawings(ctx, preLine.top, preLine.lineHeight, column, relativeLineDrawings, preLine.paragraphIndex, isParagraphFirstShapedText);
      }
    }
  }
  if (paragraphNonInlineSkeDrawings != null && paragraphNonInlineSkeDrawings.size > 0) {
    const targetDrawings = [...paragraphNonInlineSkeDrawings.values()].filter((drawing) => drawing.drawingOrigin.docTransform.positionV.relativeFrom !== 2 /* LINE */);
    __updateAndPositionDrawings(ctx, lineTop, lineHeight, column, targetDrawings, paragraphConfig.paragraphIndex, isParagraphFirstShapedText, (_f = pDrawingAnchor == null ? void 0 : pDrawingAnchor.get(paragraphIndex)) == null ? void 0 : _f.top);
  }
  if (skeTablesInParagraph != null && skeTablesInParagraph.length > 0) {
    needOpenNewPageByTableLayout = _updateAndPositionTable(ctx, lineTop, lineHeight, lastPage, column, section, skeTablesInParagraph, paragraphConfig.paragraphIndex, sectionBreakConfig, (_g = pDrawingAnchor == null ? void 0 : pDrawingAnchor.get(paragraphIndex)) == null ? void 0 : _g.top);
  }
  const newLineTop = calculateLineTopByDrawings(
    lineHeight,
    lineTop,
    lastPage,
    headerPage,
    footerPage
  );
  if (lineHeight + newLineTop > section.height && column.lines.length > 0 && lastPage.sections.length > 0 || needOpenNewPageByTableLayout) {
    setColumnFullState(column, true);
    _columnOperator(
      ctx,
      glyphGroup,
      pages,
      sectionBreakConfig,
      paragraphConfig,
      isParagraphFirstShapedText,
      breakPointType,
      defaultGlyphLineHeight
    );
    if (isParagraphFirstShapedText && paragraphNonInlineSkeDrawings && paragraphNonInlineSkeDrawings.size > 0) {
      for (const drawing of paragraphNonInlineSkeDrawings.values()) {
        if (lastPage.skeDrawings.has(drawing.drawingId)) {
          lastPage.skeDrawings.delete(drawing.drawingId);
        }
        if (ctx.floatObjectsCache.has(drawing.drawingId)) {
          ctx.floatObjectsCache.delete(drawing.drawingId);
          ctx.isDirty = false;
          ctx.layoutStartPointer[segmentId] = null;
        }
      }
    }
    return;
  }
  const lineIndex = preLine ? preLine.lineIndex + 1 : 0;
  const { charSpace, defaultTabStop } = getCharSpaceConfig(sectionBreakConfig, paragraphConfig);
  const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
  let { paddingLeft, paddingRight } = __getIndentPadding(
    indentFirstLine,
    hanging,
    indentStart,
    indentEnd,
    charSpaceApply,
    isParagraphFirstShapedText
  );
  if (paddingLeft + paddingRight >= column.width) {
    const leftPercent = paddingLeft / (paddingLeft + paddingRight);
    paddingLeft = column.width * leftPercent - 0.5;
    paddingRight = column.width - paddingLeft - 0.5;
  }
  const newLine = createSkeletonLine(
    paragraphIndex,
    0 /* PARAGRAPH */,
    {
      lineHeight,
      contentHeight,
      lineTop: newLineTop,
      paddingLeft,
      paddingRight,
      paddingTop,
      paddingBottom,
      marginTop,
      spaceBelowApply
    },
    column.width,
    lineIndex,
    isParagraphFirstShapedText,
    paragraphConfig,
    lastPage,
    headerPage,
    footerPage
  );
  column.lines.push(newLine);
  newLine.parent = column;
  createAndUpdateBlockAnchor(paragraphIndex, newLine, lineTop, pDrawingAnchor);
  _divideOperator(
    ctx,
    glyphGroup,
    pages,
    sectionBreakConfig,
    paragraphConfig,
    isParagraphFirstShapedText,
    breakPointType,
    defaultGlyphLineHeight
  );
}
function __updateAndPositionDrawings(ctx, lineTop, lineHeight, column, targetDrawings, paragraphIndex, isParagraphFirstShapedText, drawingAnchorTop) {
  if (targetDrawings.length === 0) {
    return;
  }
  const drawings = __getDrawingPosition(
    lineTop,
    lineHeight,
    column,
    isParagraphFirstShapedText,
    drawingAnchorTop,
    targetDrawings
  );
  if (drawings == null || drawings.size === 0) {
    return;
  }
  const floatObjects = [...drawings.values()].filter((drawing) => {
    const layoutType = drawing.drawingOrigin.layoutType;
    return layoutType !== 0 /* INLINE */ && layoutType !== 1 /* WRAP_NONE */;
  }).map((drawing) => {
    const { drawingOrigin, drawingId: id, aTop: top, aLeft: left, width, height, angle } = drawing;
    const positionV = drawingOrigin.docTransform.positionV;
    return {
      id,
      top,
      left,
      width,
      height,
      angle,
      type: "IMAGE" /* IMAGE */,
      positionV
    };
  });
  _reLayoutCheck(ctx, floatObjects, column, paragraphIndex);
  __updateDrawingPosition(
    column,
    drawings
  );
}
function __updateWrapTablePosition(ctx, table2, lineTop, lineHeight, column, paragraphIndex, drawingAnchorTop) {
  const wrapTablePosition = __getWrapTablePosition(table2, column, lineTop, lineHeight, drawingAnchorTop);
  if (wrapTablePosition == null) {
    return;
  }
  const { tableId: id, width, height, tableSource } = table2;
  const { left, top } = wrapTablePosition;
  const floatObject = {
    id,
    top,
    left,
    width,
    height,
    angle: 0,
    type: "TABLE" /* TABLE */,
    positionV: tableSource.position.positionV
  };
  _reLayoutCheck(ctx, [floatObject], column, paragraphIndex);
  table2.top = top;
  table2.left = left;
}
function __getWrapTablePosition(table2, column, lineTop, lineHeight, drawingAnchorTop) {
  var _a, _b, _c;
  const page = (_a = column.parent) == null ? void 0 : _a.parent;
  if (page == null) {
    return;
  }
  const isPageBreak = __checkPageBreak(column);
  const { tableSource, width, height } = table2;
  const { positionH, positionV } = tableSource.position;
  const left = (_b = getPositionHorizon(positionH, column, page, width, isPageBreak)) != null ? _b : 0;
  const top = (_c = getPositionVertical(
    positionV,
    page,
    lineTop,
    lineHeight,
    height,
    drawingAnchorTop,
    isPageBreak
  )) != null ? _c : 0;
  return { left, top };
}
function _updateAndPositionTable(ctx, lineTop, lineHeight, page, column, section, skeTablesInParagraph, paragraphIndex, sectionBreakConfig, drawingAnchorTop) {
  if (skeTablesInParagraph.length === 0) {
    return false;
  }
  const firstUnPositionedTable = skeTablesInParagraph.find((table3) => table3.hasPositioned === false);
  if (firstUnPositionedTable == null) {
    return false;
  }
  const { tableId, table: table2 } = firstUnPositionedTable;
  const { tableSource } = table2;
  if (firstUnPositionedTable.isSlideTable === false) {
    switch (tableSource.textWrap) {
      case 0 /* NONE */: {
        table2.top = lineTop;
        break;
      }
      case 1 /* WRAP */: {
        __updateWrapTablePosition(
          ctx,
          table2,
          lineTop,
          lineHeight,
          column,
          paragraphIndex,
          drawingAnchorTop
        );
        break;
      }
      default: {
        throw new Error(`Unsupported table text wrap type: ${tableSource.textWrap}`);
      }
    }
  }
  const { top, left, height } = table2;
  if (!ctx.isDirty && top + height > section.height && firstUnPositionedTable.isSlideTable === false) {
    skeTablesInParagraph.pop();
    const availableHeight = section.height - top;
    const { segmentId } = page;
    const viewModel = ctx.viewModel.getSelfOrHeaderFooterViewModel(segmentId);
    const tableNode = firstUnPositionedTable.tableNode;
    rollbackListCache(ctx.skeletonResourceReference.skeListLevel, tableNode);
    const {
      fromCurrentPage,
      skeTables
    } = createTableSkeletons(
      ctx,
      page,
      viewModel,
      tableNode,
      sectionBreakConfig,
      availableHeight
    );
    skeTables.forEach((table3, i) => {
      table3.top = i === 0 && fromCurrentPage ? top : 0;
      table3.left = left;
    });
    if (fromCurrentPage) {
      const firstTable = skeTables.shift();
      page.skeTables.set(firstTable.tableId, firstTable);
      firstTable.parent = page;
      skeTablesInParagraph.push({
        table: firstTable,
        tableId: firstTable.tableId,
        hasPositioned: true,
        isSlideTable: true,
        tableNode
      });
    }
    skeTablesInParagraph.push(...skeTables.map((table3) => {
      return {
        table: table3,
        tableId: table3.tableId,
        hasPositioned: false,
        isSlideTable: true,
        tableNode
      };
    }));
    return true;
  } else {
    page.skeTables.set(tableId, table2);
    table2.parent = page;
    firstUnPositionedTable.hasPositioned = true;
    const isLastTable = firstUnPositionedTable === skeTablesInParagraph[skeTablesInParagraph.length - 1];
    return !isLastTable;
  }
}
function _getCustomBlockIdsInLine(line2) {
  const customBlockIds = [];
  for (const divide of line2.divides) {
    for (const glyph of divide.glyphGroup) {
      if (glyph.streamType === "\b" /* CUSTOM_BLOCK */) {
        customBlockIds.push(glyph.drawingId);
      }
    }
  }
  return customBlockIds;
}
function _reLayoutCheck(ctx, floatObjects, column, paragraphIndex) {
  var _a, _b, _c, _d, _e, _f, _g;
  const page = (_a = column.parent) == null ? void 0 : _a.parent;
  if (floatObjects.length === 0 || page == null) {
    return;
  }
  let needBreakLineIterator = false;
  for (const floatObject of floatObjects) {
    const floatObjectCache = ctx.floatObjectsCache.get(floatObject.id);
    if (floatObjectCache == null || floatObjectCache.page.segmentId !== page.segmentId) {
      continue;
    }
    const cachePageStartParagraphIndex = (_d = (_c = (_b = floatObjectCache.page.sections[0]) == null ? void 0 : _b.columns[0]) == null ? void 0 : _c.lines[0]) == null ? void 0 : _d.paragraphIndex;
    const startIndex = (_g = (_f = (_e = page.sections[0]) == null ? void 0 : _e.columns[0]) == null ? void 0 : _f.lines[0]) == null ? void 0 : _g.paragraphIndex;
    if (floatObjectCache.page && cachePageStartParagraphIndex && startIndex && cachePageStartParagraphIndex !== startIndex) {
      floatObjectCache.page.skeDrawings.delete(floatObject.id);
      ctx.floatObjectsCache.delete(floatObject.id);
      lineIterator([floatObjectCache.page], (line2) => {
        var _a2;
        const { lineHeight, top } = line2;
        const column2 = line2.parent;
        if (needBreakLineIterator || column2 == null) {
          return;
        }
        const { width: columnWidth, left: columnLeft } = column2;
        const collision = collisionDetection(floatObjectCache.floatObject, lineHeight, top, columnLeft, columnWidth);
        if (collision) {
          needBreakLineIterator = true;
          ctx.isDirty = true;
          ctx.layoutStartPointer[floatObjectCache.page.segmentId] = Math.min(line2.paragraphIndex, (_a2 = ctx.layoutStartPointer[floatObjectCache.page.segmentId]) != null ? _a2 : Number.POSITIVE_INFINITY);
          ctx.paragraphsOpenNewPage.add(paragraphIndex);
        }
      });
    }
  }
  needBreakLineIterator = false;
  lineIterator([page], (line2) => {
    var _a2, _b2;
    const { lineHeight, top } = line2;
    const { width: columnWidth, left: columnLeft } = column;
    if (needBreakLineIterator) {
      return;
    }
    for (const floatObject of floatObjects.values()) {
      let targetObject = floatObject;
      if (ctx.floatObjectsCache.has(floatObject.id)) {
        const drawingCache = ctx.floatObjectsCache.get(floatObject.id);
        const needRePosition = checkRelativeDrawingNeedRePosition(ctx, floatObject);
        if ((drawingCache == null ? void 0 : drawingCache.page.segmentId) !== page.segmentId) {
          continue;
        }
        if (needRePosition) {
          targetObject = (_a2 = drawingCache == null ? void 0 : drawingCache.floatObject) != null ? _a2 : floatObject;
        } else {
          continue;
        }
      }
      const collision = collisionDetection(targetObject, lineHeight, top, columnLeft, columnWidth);
      if (collision) {
        needBreakLineIterator = true;
        ctx.isDirty = true;
        ctx.layoutStartPointer[page.segmentId] = Math.min(line2.paragraphIndex, (_b2 = ctx.layoutStartPointer[page.segmentId]) != null ? _b2 : Number.POSITIVE_INFINITY);
        let drawingCache = ctx.floatObjectsCache.get(floatObject.id);
        if (drawingCache == null) {
          drawingCache = {
            count: 0,
            floatObject,
            page
          };
          ctx.floatObjectsCache.set(floatObject.id, drawingCache);
        }
        drawingCache.count++;
        drawingCache.floatObject = floatObject;
        drawingCache.page = page;
      }
    }
  });
}
function checkRelativeDrawingNeedRePosition(ctx, floatObject) {
  const { relativeFrom } = floatObject.positionV;
  const drawingCache = ctx.floatObjectsCache.get(floatObject.id);
  if (drawingCache == null) {
    return false;
  }
  if (relativeFrom === 1 /* PARAGRAPH */ || relativeFrom === 2 /* LINE */) {
    const { count, floatObject: prevObject } = drawingCache;
    if (count < 5 && Math.abs(floatObject.top - prevObject.top) > 5) {
      return true;
    }
  }
  return false;
}
function _columnOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType = "Normal" /* Normal */, defaultSpanLineHeight) {
  const lastPage = getLastPage(pages);
  const columnIsFull = isColumnFull(lastPage);
  if (columnIsFull === true) {
    _pageOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType, defaultSpanLineHeight);
  } else {
    _lineOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType, defaultSpanLineHeight);
  }
}
function _pageOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType = "Normal" /* Normal */, defaultSpanLineHeight) {
  const curSkeletonPage = getLastPage(pages);
  const { skeHeaders, skeFooters } = paragraphConfig;
  pages.push(createSkeletonPage(ctx, sectionBreakConfig, { skeHeaders, skeFooters }, (curSkeletonPage == null ? void 0 : curSkeletonPage.pageNumber) + 1));
  _columnOperator(ctx, glyphGroup, pages, sectionBreakConfig, paragraphConfig, isParagraphFirstShapedText, breakPointType, defaultSpanLineHeight);
}
function __getIndentPadding(indentFirstLine, hanging, indentStart, indentEnd, charSpaceApply, isParagraphFirstShapedText = false) {
  const indentFirstLineNumber = getNumberUnitValue(indentFirstLine, charSpaceApply);
  const hangingNumber = getNumberUnitValue(hanging, charSpaceApply);
  const indentStartNumber = getNumberUnitValue(indentStart, charSpaceApply);
  const indentEndNumber = getNumberUnitValue(indentEnd, charSpaceApply);
  let paddingLeft = indentStartNumber;
  const paddingRight = indentEndNumber;
  if (indentFirstLineNumber > 0 && isParagraphFirstShapedText) {
    paddingLeft += indentFirstLineNumber;
  }
  if (hangingNumber > 0 && !isParagraphFirstShapedText) {
    paddingLeft += hangingNumber;
  }
  return {
    paddingLeft,
    paddingRight
  };
}
function __getParagraphSpace(ctx, lineSpacing = 0, spaceAbove, spaceBelow, isParagraphFirstShapedText, preLine) {
  const spaceBelowApply = getNumberUnitValue(spaceBelow, lineSpacing);
  if (isParagraphFirstShapedText) {
    let marginTop = getNumberUnitValue(spaceAbove, lineSpacing);
    if (preLine) {
      const { spaceBelowApply: preSpaceBelowApply } = preLine;
      if (marginTop < preSpaceBelowApply) {
        const maxValue = Math.max(preSpaceBelowApply, marginTop);
        preLine.lineHeight += maxValue;
        setLineMarginBottom(preLine, maxValue);
        marginTop = 0;
      }
    }
    return {
      marginTop,
      spaceBelowApply
    };
  }
  return {
    marginTop: 0,
    spaceBelowApply
  };
}
function __getLineHeight(glyphLineHeight, paragraphLineGapDefault, linePitch, gridType, lineSpacing, spacingRule, snapToGrid) {
  let paddingTop = paragraphLineGapDefault;
  let paddingBottom = paragraphLineGapDefault;
  if (gridType === 0 /* DEFAULT */ || snapToGrid === 0 /* FALSE */) {
    if (spacingRule === 0 /* AUTO */) {
      return {
        paddingTop,
        paddingBottom,
        contentHeight: lineSpacing * glyphLineHeight,
        lineSpacingApply: glyphLineHeight
      };
    }
    return {
      paddingTop,
      paddingBottom,
      contentHeight: Math.max(lineSpacing, glyphLineHeight),
      lineSpacingApply: lineSpacing
    };
  }
  let lineSpacingApply = 0;
  if (spacingRule === 0 /* AUTO */) {
    lineSpacingApply = lineSpacing * linePitch;
  } else {
    lineSpacingApply = lineSpacing;
  }
  if (glyphLineHeight + paragraphLineGapDefault * 2 < lineSpacingApply) {
    paddingTop = paddingBottom = (lineSpacingApply - glyphLineHeight) / 2;
  } else {
    lineSpacingApply = glyphLineHeight;
  }
  return {
    paddingTop,
    paddingBottom,
    contentHeight: glyphLineHeight,
    lineSpacingApply
  };
}
function updateInlineDrawingPosition(line2, paragraphInlineSkeDrawings, blockAnchorTop) {
  var _a, _b;
  const column = line2.parent;
  const page = (_b = (_a = line2 == null ? void 0 : line2.parent) == null ? void 0 : _a.parent) == null ? void 0 : _b.parent;
  if (page == null || column == null) {
    return;
  }
  const isPageBreak = __checkPageBreak(column);
  const drawings = /* @__PURE__ */ new Map();
  const { top, lineHeight, marginBottom = 0 } = line2;
  for (const divide of line2.divides) {
    for (const glyph of divide.glyphGroup) {
      if (glyph.streamType === "\b" /* CUSTOM_BLOCK */ && glyph.width !== 0) {
        const { drawingId } = glyph;
        if (drawingId == null) {
          continue;
        }
        const drawing = paragraphInlineSkeDrawings == null ? void 0 : paragraphInlineSkeDrawings.get(drawingId);
        const drawingOrigin = drawing == null ? void 0 : drawing.drawingOrigin;
        if (drawingOrigin == null || drawing == null) {
          continue;
        }
        const { docTransform } = drawingOrigin;
        const { size, angle } = docTransform;
        const { width = 0, height = 0 } = size;
        const glyphHeight = glyph.bBox.bd + glyph.bBox.ba;
        drawing.aLeft = divide.left + divide.paddingLeft + glyph.left + 0.5 * glyph.width - 0.5 * width || 0;
        drawing.aTop = top + lineHeight - 0.5 * glyphHeight - 0.5 * height - marginBottom;
        drawing.width = width;
        drawing.height = height;
        drawing.angle = angle;
        drawing.isPageBreak = isPageBreak;
        drawing.lineTop = top;
        drawing.columnLeft = column.left;
        drawing.blockAnchorTop = blockAnchorTop != null ? blockAnchorTop : top;
        drawing.lineHeight = line2.lineHeight;
        drawings.set(drawing.drawingId, drawing);
      }
    }
  }
  const res = new Map([...page.skeDrawings, ...drawings]);
  page.skeDrawings = res;
}
function __getDrawingPosition(lineTop, lineHeight, column, isParagraphFirstShapedText, blockAnchorTop, needPositionDrawings = []) {
  var _a, _b, _c;
  const page = (_a = column.parent) == null ? void 0 : _a.parent;
  if (page == null || needPositionDrawings.length === 0) {
    return;
  }
  const drawings = /* @__PURE__ */ new Map();
  const isPageBreak = __checkPageBreak(column);
  if (isPageBreak && !isParagraphFirstShapedText) {
    return;
  }
  for (const drawing of needPositionDrawings) {
    const { drawingOrigin } = drawing;
    if (!drawingOrigin) {
      continue;
    }
    const { docTransform } = drawingOrigin;
    const { positionH, positionV, size, angle } = docTransform;
    const { width = 0, height = 0 } = size;
    drawing.aLeft = (_b = getPositionHorizon(positionH, column, page, width, isPageBreak)) != null ? _b : 0;
    drawing.aTop = (_c = getPositionVertical(
      positionV,
      page,
      lineTop,
      lineHeight,
      height,
      blockAnchorTop,
      isPageBreak
    )) != null ? _c : 0;
    drawing.width = width;
    drawing.height = height;
    drawing.angle = angle;
    drawing.initialState = true;
    drawing.columnLeft = column.left;
    drawing.lineTop = lineTop;
    drawing.lineHeight = lineHeight;
    drawing.isPageBreak = isPageBreak;
    drawing.blockAnchorTop = blockAnchorTop != null ? blockAnchorTop : lineTop;
    drawings.set(drawing.drawingId, drawing);
  }
  return drawings;
}
function __updateDrawingPosition(column, drawings) {
  var _a;
  const page = (_a = column.parent) == null ? void 0 : _a.parent;
  if (drawings == null || drawings.size === 0 || page == null) {
    return;
  }
  for (const drawing of drawings.values()) {
    const originDrawing = page.skeDrawings.get(drawing.drawingId);
    if (originDrawing) {
      if (originDrawing.drawingOrigin.layoutType === 6 /* WRAP_TOP_AND_BOTTOM */) {
        const lowerDrawing = originDrawing.aTop > drawing.aTop ? originDrawing : drawing;
        page.skeDrawings.set(drawing.drawingId, lowerDrawing);
      } else {
        page.skeDrawings.set(drawing.drawingId, drawing);
      }
    } else {
      page.skeDrawings.set(drawing.drawingId, drawing);
    }
  }
}
function __checkPageBreak(column) {
  const section = column.parent;
  if (!section) {
    return false;
  }
  const columns = section == null ? void 0 : section.columns;
  if (!columns) {
    return false;
  }
  const columnLength = columns.length;
  for (let c = columnLength - 1; c >= 0; c--) {
    const curColumn = columns[c];
    const lines = curColumn.lines;
    const lineLength = lines.length;
    if (lineLength <= 0) {
      continue;
    }
    for (let i = lineLength - 1; i >= 0; i--) {
      const line2 = lines[i];
      if (line2.paragraphStart) {
        return false;
      }
    }
  }
  return true;
}
function __getGlyphGroupWidth(glyphGroup) {
  const glyphGroupLen = glyphGroup.length;
  let width = 0;
  for (let i = 0; i < glyphGroupLen; i++) {
    const glyph = glyphGroup[i];
    width += glyph.width;
  }
  return width;
}
function __maxFontBoundingBoxByGlyphGroup(glyphGroup) {
  const glyphGroupLen = glyphGroup.length;
  let height = Number.NEGATIVE_INFINITY;
  let maxBox;
  for (let i = 0; i < glyphGroupLen; i++) {
    const glyph = glyphGroup[i];
    const { ba: boundingBoxAscent, bd: boundingBoxDescent } = glyph.bBox;
    if (height < boundingBoxAscent + boundingBoxDescent) {
      maxBox = { boundingBoxAscent, boundingBoxDescent };
    }
    height = boundingBoxAscent + boundingBoxDescent;
  }
  return maxBox;
}
function __getGlyphGroupByLine({ divides }) {
  return divides.flatMap((divide) => divide.glyphGroup);
}
function __isNullLine(line2) {
  return !line2.divides[0].glyphGroup[0];
}

// ../packages/engine-render/src/components/docs/layout/style/custom-decoration.ts
function getCustomDecorationStyle(customDecoration) {
  if (customDecoration.type === 0 /* COMMENT */) {
    return {
      bbl: {
        s: 1 /* TRUE */,
        cl: {
          rgb: "#fcdf7e"
        },
        c: 0 /* FALSE */
      },
      ...customDecoration.active ? { bg: { rgb: "#faedc2" } } : null
    };
  }
  return null;
}

// ../packages/engine-render/src/components/docs/layout/style/custom-range.ts
function getCustomRangeStyle(customRange) {
  var _a;
  if (customRange.rangeType === 0 /* HYPERLINK */ || customRange.rangeType === 6 /* MENTION */) {
    return {
      ...((_a = customRange.active) != null ? _a : true) ? { ul: { s: 1 /* TRUE */ } } : null,
      cl: { rgb: "#274fee" }
    };
  }
  return null;
}

// ../packages/engine-render/src/components/docs/layout/tools.ts
function getLastPage(pages) {
  return pages[pages.length - 1];
}
function getLastSection(page) {
  var _a;
  return (_a = page.sections) == null ? void 0 : _a[page.sections.length - 1];
}
function getLastColumn(page) {
  const columns = getLastSection(page).columns;
  return columns == null ? void 0 : columns[columns.length - 1];
}
function getLastLine(page) {
  var _a;
  const lines = (_a = getLastNotFullColumnInfo(page)) == null ? void 0 : _a.column.lines;
  return lines == null ? void 0 : lines[lines.length - 1];
}
function getLastLineByColumn(column) {
  return column.lines[column.lines.length - 1];
}
function getLastNotFullColumnInfo(page) {
  const section = getLastSection(page);
  for (let i = 0; i < section.columns.length; i++) {
    const column = section.columns[i];
    if (!column.isFull) {
      return {
        column,
        isLast: i === section.columns.length - 1,
        index: i
      };
    }
  }
}
function getLastNotFullDivideInfo(page) {
  const line2 = getLastLine(page);
  if (!line2) {
    return;
  }
  for (let i = 0; i < line2.divides.length; i++) {
    const divide = line2.divides[i];
    if (!divide.isFull) {
      return {
        divide,
        isLast: i === line2.divides.length - 1,
        index: i
      };
    }
  }
}
function isColumnFull(page) {
  const section = getLastSection(page);
  const columnsLen = section.columns.length;
  for (let i = 0; i < columnsLen; i++) {
    const column = section.columns[i];
    if (!column.isFull) {
      return false;
    }
  }
  return true;
}
function getNumberUnitValue(unitValue, benchMark) {
  if (!unitValue) {
    return 0;
  }
  const { v: value, u: unit } = unitValue;
  if (!unit) {
    return value;
  }
  if (unit === 3 /* PIXEL */) {
    return value;
  }
  return value * benchMark;
}
function getCharSpaceApply(charSpace = 0, defaultTabStop, gridType = 1 /* LINES */, snapToGrid = 1 /* TRUE */) {
  let charSpaceApply = 1;
  if (validationGrid(gridType, snapToGrid)) {
    charSpaceApply = charSpace;
  }
  charSpaceApply *= defaultTabStop;
  return charSpaceApply;
}
function validationGrid(gridType = 1 /* LINES */, snapToGrid = 0 /* FALSE */) {
  return snapToGrid === 1 /* TRUE */ && (gridType === 2 /* LINES_AND_CHARS */ || gridType === 3 /* SNAP_TO_CHARS */);
}
function getLineHeightConfig(sectionBreakConfig, paragraphConfig) {
  const { paragraphStyle = {} } = paragraphConfig;
  const { linePitch = 15.6, gridType = 1 /* LINES */, paragraphLineGapDefault = 0 } = sectionBreakConfig;
  const { lineSpacing = 0, spacingRule = 0 /* AUTO */, snapToGrid = 1 /* TRUE */ } = paragraphStyle;
  let lineSpacingApply = lineSpacing;
  if ((gridType === 1 /* LINES */ || gridType === 2 /* LINES_AND_CHARS */) && lineSpacing === 0 && spacingRule === 0 /* AUTO */) {
    lineSpacingApply = 1;
  }
  return { paragraphLineGapDefault, linePitch, gridType, lineSpacing: lineSpacingApply, spacingRule, snapToGrid };
}
function getCharSpaceConfig(sectionBreakConfig, paragraphConfig) {
  const { paragraphStyle = {} } = paragraphConfig;
  const {
    charSpace = 0,
    gridType = 1 /* LINES */,
    defaultTabStop = 36,
    documentTextStyle = {}
  } = sectionBreakConfig;
  const { fs: documentFontSize = DEFAULT_DOCUMENT_FONTSIZE } = documentTextStyle;
  const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
  return {
    charSpace,
    documentFontSize,
    defaultTabStop,
    gridType,
    snapToGrid
  };
}
function updateBlockIndex(pages, start = -1) {
  let prePageStartIndex = start;
  for (const page of pages) {
    const { sections, skeTables } = page;
    const pageStartIndex = prePageStartIndex;
    const pageEndIndex = pageStartIndex;
    let preSectionStartIndex = pageStartIndex;
    let maxContentWidth = Number.NEGATIVE_INFINITY;
    let contentHeight = 0;
    for (const section of sections) {
      const { columns } = section;
      const sectionStartIndex = preSectionStartIndex;
      const sectionEndIndex = pageStartIndex;
      let preColumnStartIndex = sectionStartIndex;
      let maxSectionHeight = Number.NEGATIVE_INFINITY;
      let sectionWidth = 0;
      for (const column of columns) {
        const { lines } = column;
        const columStartIndex = preColumnStartIndex;
        const columnEndIndex = columStartIndex;
        let preLineStartIndex = columStartIndex;
        let columnHeight = 0;
        let maxColumnWidth = Number.NEGATIVE_INFINITY;
        for (const line2 of lines) {
          const { divides, lineHeight, top, isBehindTable, tableId } = line2;
          let lineStartIndex = preLineStartIndex;
          if (isBehindTable && tableId) {
            const table2 = skeTables.get(tableId);
            if (table2) {
              lineStartIndex = table2.ed;
            }
          }
          const lineEndIndex = lineStartIndex;
          let preDivideStartIndex = lineStartIndex;
          let actualWidth = 0;
          let maxLineAsc = 0;
          let macLineDsc = 0;
          columnHeight = top + lineHeight;
          const divideLength = divides.length;
          let lineHasGlyph = false;
          for (let i = 0; i < divideLength; i++) {
            const divide = divides[i];
            const { glyphGroup } = divide;
            const divStartIndex = preDivideStartIndex;
            let divEndIndex = divStartIndex;
            for (const glyph of glyphGroup) {
              const increaseValue = glyph.glyphType === 2 /* LIST */ ? 0 : glyph.count;
              divEndIndex += increaseValue;
              const bBox = glyph.bBox;
              const { ba, bd } = bBox;
              maxLineAsc = Math.max(maxLineAsc, ba);
              macLineDsc = Math.max(macLineDsc, bd);
              if (i === divideLength - 1) {
                actualWidth += glyph.width;
              }
            }
            if (glyphGroup.length === 0) {
              continue;
            }
            lineHasGlyph = true;
            if (glyphGroup[0].xOffset !== 0 && i === divideLength - 1) {
              actualWidth -= glyphGroup[0].xOffset;
            }
            if (i === divideLength - 1) {
              actualWidth += divide.left;
            }
            divide.st = divStartIndex + 1;
            divide.ed = divEndIndex >= divide.st ? divEndIndex : divide.st;
            preDivideStartIndex = divide.ed;
          }
          line2.st = lineHasGlyph ? lineStartIndex + 1 : lineStartIndex;
          line2.ed = preDivideStartIndex >= line2.st ? preDivideStartIndex : line2.st;
          line2.width = actualWidth;
          line2.asc = maxLineAsc;
          line2.dsc = macLineDsc;
          maxColumnWidth = Math.max(maxColumnWidth, actualWidth);
          preLineStartIndex = line2.ed;
        }
        column.st = columStartIndex + 1;
        column.ed = preLineStartIndex >= column.st ? preLineStartIndex : column.st;
        column.height = columnHeight;
        column.width = maxColumnWidth;
        sectionWidth += maxColumnWidth;
        maxSectionHeight = Math.max(maxSectionHeight, column.height);
        preColumnStartIndex = column.ed;
      }
      section.st = sectionStartIndex + 1;
      section.ed = preColumnStartIndex >= section.st ? preColumnStartIndex : section.st;
      section.height = maxSectionHeight;
      contentHeight += maxSectionHeight;
      maxContentWidth = Math.max(maxContentWidth, sectionWidth);
      preSectionStartIndex = section.ed;
    }
    for (const table2 of skeTables.values()) {
      const { ed } = table2;
      preSectionStartIndex = Math.max(preSectionStartIndex, ed);
    }
    page.st = pageStartIndex + 1;
    page.ed = preSectionStartIndex >= page.st ? preSectionStartIndex : page.st;
    page.height = contentHeight;
    page.width = maxContentWidth;
    prePageStartIndex = page.ed;
  }
}
function updateInlineDrawingCoordsAndBorder(ctx, pages) {
  lineIterator(pages, (line2, _819, __, page) => {
    var _a, _b, _c, _d;
    const { segmentId } = page;
    const paragraphConfig = (_a = ctx.paragraphConfigCache.get(segmentId)) == null ? void 0 : _a.get(line2.paragraphIndex);
    const affectInlineDrawings = paragraphConfig == null ? void 0 : paragraphConfig.paragraphInlineSkeDrawings;
    const drawingAnchor = (_d = (_c = (_b = ctx.skeletonResourceReference) == null ? void 0 : _b.drawingAnchor) == null ? void 0 : _c.get(segmentId)) == null ? void 0 : _d.get(line2.paragraphIndex);
    if (affectInlineDrawings && affectInlineDrawings.size > 0) {
      updateInlineDrawingPosition(line2, affectInlineDrawings, drawingAnchor == null ? void 0 : drawingAnchor.top);
    }
    const paragraphStyle = paragraphConfig == null ? void 0 : paragraphConfig.paragraphStyle;
    const lastDivide = line2.divides[line2.divides.length - 1];
    const lastGlyph = lastDivide.glyphGroup[lastDivide.glyphGroup.length - 1];
    if (lastGlyph.streamType === "\r" /* PARAGRAPH */ && (paragraphStyle == null ? void 0 : paragraphStyle.borderBottom)) {
      line2.borderBottom = paragraphStyle.borderBottom;
    }
  });
}
function lineIterator(pagesOrCells, cb) {
  for (const pageOrCell of pagesOrCells) {
    const { sections } = pageOrCell;
    for (const section of sections) {
      const { columns } = section;
      for (const column of columns) {
        const { lines } = column;
        for (const line2 of lines) {
          if (cb && isFunction(cb)) {
            cb(line2, column, section, pageOrCell);
          }
        }
      }
    }
  }
}
function columnIterator(pages, iteratorFunction) {
  for (const page of pages) {
    const { sections } = page;
    for (const section of sections) {
      const { columns } = section;
      for (const column of columns) {
        if (iteratorFunction && isFunction(iteratorFunction)) {
          iteratorFunction(column);
        }
      }
    }
  }
}
function getPositionHorizon(positionH, column, page, objectWidth, isPageBreak = false) {
  const { relativeFrom, align, posOffset, percent } = positionH;
  if (align != null) {
    if (align === 1 /* INSIDE */ || align === 3 /* OUTSIDE */) {
      if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 0 /* PAGE */) {
      }
    } else {
      if (relativeFrom === 1 /* COLUMN */) {
        const { width, left } = column;
        let absoluteLeft = 0;
        if (align === 2 /* LEFT */) {
          absoluteLeft = left;
        } else if (align === 4 /* RIGHT */) {
          absoluteLeft = left + width - objectWidth;
        } else if (align === 0 /* CENTER */) {
          absoluteLeft = left + width / 2 - objectWidth / 2;
        }
        return absoluteLeft;
      }
      if (relativeFrom === 6 /* LEFT_MARGIN */) {
      } else if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
      } else if (relativeFrom === 4 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 0 /* PAGE */) {
        const { pageWidth } = page;
        let absoluteLeft = 0;
        if (align === 4 /* RIGHT */) {
          absoluteLeft = pageWidth - objectWidth;
        } else if (align === 0 /* CENTER */) {
          absoluteLeft = pageWidth / 2 - objectWidth / 2;
        }
        return absoluteLeft;
      }
    }
  } else if (posOffset) {
    const { pageWidth, marginLeft, marginRight } = page;
    const boundaryLeft = marginLeft;
    const boundaryRight = pageWidth - marginRight;
    let absoluteLeft = 0;
    if (relativeFrom === 1 /* COLUMN */) {
      absoluteLeft = (isPageBreak ? 0 : (column == null ? void 0 : column.left) || 0) + posOffset;
    } else if (relativeFrom === 6 /* LEFT_MARGIN */) {
    } else if (relativeFrom === 3 /* MARGIN */) {
      absoluteLeft = posOffset + marginLeft;
    } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
    } else if (relativeFrom === 4 /* INSIDE_MARGIN */) {
    } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
    } else if (relativeFrom === 0 /* PAGE */) {
      absoluteLeft = posOffset;
    }
    if (absoluteLeft + objectWidth > boundaryRight) {
      absoluteLeft = boundaryRight - objectWidth;
    }
    return absoluteLeft;
  } else if (percent) {
    const { pageWidth, marginLeft, marginRight } = page;
    if (relativeFrom === 6 /* LEFT_MARGIN */) {
    } else if (relativeFrom === 3 /* MARGIN */) {
    } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
    } else if (relativeFrom === 4 /* INSIDE_MARGIN */) {
    } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
    } else if (relativeFrom === 0 /* PAGE */) {
      return percent * pageWidth;
    }
  }
}
function getPositionVertical(positionV, page, lineTop, lineHeight, objectHeight, blockAnchorTop, isPageBreak = false) {
  const { relativeFrom, align, posOffset, percent } = positionV;
  if (align != null) {
    if (relativeFrom === 2 /* LINE */) {
      let absoluteTop = 0;
      if (align === 0 /* BOTTOM */) {
        absoluteTop = lineTop + lineHeight - objectHeight;
      } else if (align === 4 /* TOP */) {
        absoluteTop = lineTop;
      } else if (align === 1 /* CENTER */) {
        absoluteTop = lineTop + lineHeight / 2 - objectHeight / 2;
      }
      return absoluteTop;
    } else if (relativeFrom === 4 /* TOP_MARGIN */) {
    } else if (relativeFrom === 3 /* MARGIN */) {
    } else if (relativeFrom === 5 /* BOTTOM_MARGIN */) {
    } else if (relativeFrom === 6 /* INSIDE_MARGIN */) {
    } else if (relativeFrom === 7 /* OUTSIDE_MARGIN */) {
    } else if (relativeFrom === 0 /* PAGE */) {
      const { pageHeight } = page;
      let absoluteTop = 0;
      if (align === 0 /* BOTTOM */) {
        absoluteTop = pageHeight - objectHeight;
      } else if (align === 1 /* CENTER */) {
        absoluteTop = pageHeight / 2 - objectHeight / 2;
      }
      return absoluteTop;
    }
  } else if (posOffset != null) {
    let absoluteTop = 0;
    const { marginTop } = page;
    if (relativeFrom === 2 /* LINE */) {
      absoluteTop = (lineTop || 0) + posOffset;
    } else if (relativeFrom === 4 /* TOP_MARGIN */) {
    } else if (relativeFrom === 3 /* MARGIN */) {
      absoluteTop = posOffset;
    } else if (relativeFrom === 5 /* BOTTOM_MARGIN */) {
    } else if (relativeFrom === 6 /* INSIDE_MARGIN */) {
    } else if (relativeFrom === 7 /* OUTSIDE_MARGIN */) {
    } else if (relativeFrom === 0 /* PAGE */) {
      absoluteTop = posOffset - marginTop;
    } else if (relativeFrom === 1 /* PARAGRAPH */) {
      absoluteTop = (isPageBreak ? 0 : blockAnchorTop == null ? lineTop : blockAnchorTop) + posOffset;
    }
    return absoluteTop;
  } else if (percent != null) {
    const { pageHeight, marginBottom, marginTop } = page;
    if (relativeFrom === 4 /* TOP_MARGIN */) {
    } else if (relativeFrom === 3 /* MARGIN */) {
    } else if (relativeFrom === 5 /* BOTTOM_MARGIN */) {
    } else if (relativeFrom === 6 /* INSIDE_MARGIN */) {
    } else if (relativeFrom === 7 /* OUTSIDE_MARGIN */) {
    } else if (relativeFrom === 0 /* PAGE */) {
      return percent * pageHeight;
    }
  }
}
function getGlyphGroupWidth(divide) {
  let width = 0;
  for (const glyph of divide.glyphGroup) {
    width += glyph.width;
  }
  return width;
}
var fontCreateConfigCache = new ObjectMatrix();
function clearFontCreateConfigCache() {
  fontCreateConfigCache.reset();
}
function getFontConfigFromLastGlyph(glyph, sectionBreakConfig, paragraphStyle) {
  const { ts, fontStyle } = glyph;
  const {
    gridType = 1 /* LINES */,
    charSpace = 0,
    pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    },
    marginRight = 0,
    marginLeft = 0
  } = sectionBreakConfig;
  const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
  const pageWidth = pageSize.width || Number.POSITIVE_INFINITY - marginLeft - marginRight;
  const result = {
    fontStyle,
    textStyle: ts,
    charSpace,
    gridType,
    snapToGrid,
    pageWidth
  };
  return result;
}
function getBulletParagraphTextStyle(bullet, viewModel) {
  var _a;
  const { listType } = bullet;
  const lists = viewModel.getDataModel().getBulletPresetList();
  return (_a = lists[listType].nestingLevel[0].paragraphProperties) == null ? void 0 : _a.textStyle;
}
var DEFAULT_TEXT_RUN = { ts: {}, st: 0, ed: 0 };
function getFontCreateConfig(index, viewModel, paragraphNode, sectionBreakConfig, paragraph) {
  const {
    gridType = 1 /* LINES */,
    charSpace = 0,
    documentTextStyle = {},
    pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    },
    marginRight = 0,
    marginLeft = 0,
    // localeService,
    renderConfig = {}
  } = sectionBreakConfig;
  const { paragraphStyle = {}, bullet } = paragraph;
  const { isRenderStyle } = renderConfig;
  const { startIndex } = paragraphNode;
  const originTextRun = viewModel.getTextRun(index + startIndex);
  const textRun = isRenderStyle === 0 /* FALSE */ ? DEFAULT_TEXT_RUN : originTextRun != null ? originTextRun : DEFAULT_TEXT_RUN;
  const customDecoration = viewModel.getCustomDecoration(index + startIndex);
  const showCustomDecoration = customDecoration && customDecoration.show !== false;
  const customDecorationStyle = showCustomDecoration ? getCustomDecorationStyle(customDecoration) : null;
  const customRange = viewModel.getCustomRange(index + startIndex);
  const showCustomRange = customRange && customRange.show !== false;
  const customRangeStyle = showCustomRange ? getCustomRangeStyle(customRange) : null;
  const hasAddonStyle = showCustomRange || showCustomDecoration || !!bullet;
  const { st, ed } = textRun;
  let { ts: textStyle = {} } = textRun;
  const cache = fontCreateConfigCache.getValue(st, ed);
  if (cache && !hasAddonStyle && originTextRun) {
    return cache;
  }
  const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
  const bulletTextStyle = bullet ? getBulletParagraphTextStyle(bullet, viewModel) : null;
  textStyle = {
    ...documentTextStyle,
    ...textStyle,
    ...customDecorationStyle,
    ...customRangeStyle,
    ...bulletTextStyle
  };
  const fontStyle = getFontStyleString(textStyle);
  const mixTextStyle = {
    ...documentTextStyle,
    ...textStyle
  };
  const pageWidth = pageSize.width || Number.POSITIVE_INFINITY - marginLeft - marginRight;
  const result = {
    fontStyle,
    textStyle: mixTextStyle,
    charSpace,
    gridType,
    snapToGrid,
    pageWidth
  };
  if (!hasAddonStyle && originTextRun) {
    fontCreateConfigCache.setValue(st, ed, result);
  }
  return result;
}
function getNullSkeleton() {
  return {
    pages: [],
    left: 0,
    top: 0,
    st: 0,
    skeHeaders: /* @__PURE__ */ new Map(),
    skeFooters: /* @__PURE__ */ new Map(),
    skeListLevel: /* @__PURE__ */ new Map(),
    // TODO: 移到 context 中管理？
    drawingAnchor: /* @__PURE__ */ new Map()
    // TODO: 移到 context 中管理
  };
}
function setPageParent(pages, parent) {
  for (const page of pages) {
    page.parent = parent;
  }
}
var DEFAULT_SECTION_BREAK = {
  columnProperties: [],
  columnSeparatorType: 1 /* NONE */,
  sectionType: 0 /* SECTION_TYPE_UNSPECIFIED */,
  startIndex: 0
};
var DEFAULT_PAGE_SIZE = { width: Number.POSITIVE_INFINITY, height: Number.POSITIVE_INFINITY };
var DEFAULT_MODERN_DOCUMENT_STYLE = {
  pageNumberStart: 1,
  pageSize: {
    width: ptToPixel(595),
    height: Number.POSITIVE_INFINITY
  },
  marginTop: ptToPixel(50),
  marginBottom: ptToPixel(50),
  marginRight: ptToPixel(50),
  marginLeft: ptToPixel(50),
  renderConfig: {
    vertexAngle: 0,
    centerAngle: 0,
    background: {
      rgb: "#FFFFFF"
    }
  },
  defaultHeaderId: "",
  defaultFooterId: "",
  evenPageHeaderId: "",
  evenPageFooterId: "",
  firstPageHeaderId: "",
  firstPageFooterId: "",
  evenAndOddHeaders: 0 /* FALSE */,
  useFirstPageHeaderFooter: 0 /* FALSE */,
  marginHeader: 0,
  marginFooter: 0
};
var DEFAULT_MODERN_SECTION_BREAK = {
  columnProperties: [],
  columnSeparatorType: 1 /* NONE */,
  sectionType: 0 /* SECTION_TYPE_UNSPECIFIED */
};
function prepareSectionBreakConfig(ctx, nodeIndex) {
  var _a;
  const { viewModel, dataModel, docsConfig } = ctx;
  const sectionNode = viewModel.getChildren()[nodeIndex];
  let { documentStyle } = dataModel;
  const { documentFlavor } = documentStyle;
  let sectionBreak = viewModel.getSectionBreak(sectionNode.endIndex) || DEFAULT_SECTION_BREAK;
  if (documentFlavor === 2 /* MODERN */) {
    sectionBreak = Object.assign({}, sectionBreak, DEFAULT_MODERN_SECTION_BREAK);
    documentStyle = Object.assign({}, documentStyle, DEFAULT_MODERN_DOCUMENT_STYLE);
  }
  const {
    pageNumberStart: global_pageNumberStart = 1,
    // pageNumberStart
    pageSize: global_pageSize = DEFAULT_PAGE_SIZE,
    pageOrient: global_pageOrient = 0 /* PORTRAIT */,
    defaultHeaderId: global_defaultHeaderId,
    defaultFooterId: global_defaultFooterId,
    evenPageHeaderId: global_evenPageHeaderId,
    evenPageFooterId: global_evenPageFooterId,
    firstPageHeaderId: global_firstPageHeaderId,
    firstPageFooterId: global_firstPageFooterId,
    useFirstPageHeaderFooter: global_useFirstPageHeaderFooter,
    evenAndOddHeaders: global_evenAndOddHeaders,
    marginTop: global_marginTop = 0,
    marginBottom: global_marginBottom = 0,
    marginRight: global_marginRight = 0,
    marginLeft: global_marginLeft = 0,
    marginHeader: global_marginHeader = 0,
    marginFooter: global_marginFooter = 0,
    autoHyphenation = 0 /* FALSE */,
    doNotHyphenateCaps = 0 /* FALSE */,
    consecutiveHyphenLimit = Number.POSITIVE_INFINITY,
    hyphenationZone,
    renderConfig: global_renderConfig = {
      horizontalAlign: 1 /* LEFT */,
      verticalAlign: 1 /* TOP */,
      centerAngle: 0,
      vertexAngle: 0,
      wrapStrategy: 0 /* UNSPECIFIED */
    }
  } = documentStyle;
  const {
    charSpace = 0,
    // charSpace
    linePitch = 15.6,
    // linePitch pt
    gridType = 1 /* LINES */,
    // gridType
    pageNumberStart = global_pageNumberStart,
    pageSize = global_pageSize,
    pageOrient = global_pageOrient,
    marginTop = global_marginTop,
    marginBottom = global_marginBottom,
    marginRight = global_marginRight,
    marginLeft = global_marginLeft,
    marginHeader = global_marginHeader,
    marginFooter = global_marginFooter,
    defaultHeaderId = global_defaultHeaderId,
    defaultFooterId = global_defaultFooterId,
    evenPageHeaderId = global_evenPageHeaderId,
    evenPageFooterId = global_evenPageFooterId,
    firstPageHeaderId = global_firstPageHeaderId,
    firstPageFooterId = global_firstPageFooterId,
    useFirstPageHeaderFooter = global_useFirstPageHeaderFooter,
    evenAndOddHeaders = global_evenAndOddHeaders,
    columnProperties = [],
    columnSeparatorType = 1 /* NONE */,
    contentDirection,
    sectionType,
    textDirection,
    renderConfig = global_renderConfig
  } = sectionBreak;
  const sectionNodeNext = viewModel.getChildren()[nodeIndex + 1];
  const sectionTypeNext = (_a = viewModel.getSectionBreak(sectionNodeNext == null ? void 0 : sectionNodeNext.endIndex)) == null ? void 0 : _a.sectionType;
  const headerIds = { defaultHeaderId, evenPageHeaderId, firstPageHeaderId };
  const footerIds = { defaultFooterId, evenPageFooterId, firstPageFooterId };
  if (pageSize.width === null) {
    pageSize.width = Number.POSITIVE_INFINITY;
  }
  if (pageSize.height === null) {
    pageSize.height = Number.POSITIVE_INFINITY;
  }
  const sectionBreakConfig = {
    charSpace,
    linePitch,
    gridType,
    pageNumberStart,
    pageSize,
    pageOrient,
    marginTop,
    marginBottom,
    marginRight,
    marginLeft,
    marginHeader,
    marginFooter,
    headerIds,
    footerIds,
    useFirstPageHeaderFooter,
    evenAndOddHeaders,
    columnProperties,
    columnSeparatorType,
    contentDirection,
    sectionType,
    sectionTypeNext,
    textDirection,
    renderConfig,
    autoHyphenation,
    doNotHyphenateCaps,
    consecutiveHyphenLimit,
    hyphenationZone,
    ...docsConfig
  };
  return sectionBreakConfig;
}
function resetContext(ctx) {
  var _a;
  ctx.isDirty = false;
  (_a = ctx.skeleton.drawingAnchor) == null ? void 0 : _a.clear();
}
function mergeByV(object, originObject, type2) {
  const mergeIterator = (obj, originObj, key) => {
    if (key !== "v") {
      if (typeof originObj === "object") {
        return mergeWith_default(obj, originObj, mergeIterator);
      } else {
        return originObj != null ? originObj : obj;
      }
    }
    if (typeof originObj === "number") {
      if (typeof obj === "number") {
        return type2 === "max" ? Math.max(originObj, obj) : Math.min(originObj, obj);
      }
    }
    return originObj != null ? originObj : obj;
  };
  return mergeWith_default(object, originObject, mergeIterator);
}
function getPageFromPath(skeletonData, path) {
  var _a, _b, _c;
  const pathCopy = [...path];
  let page = null;
  while (pathCopy.length > 0) {
    const field = pathCopy.shift();
    if (field === "pages") {
      const pageIndex = pathCopy.shift();
      page = skeletonData.pages[pageIndex];
    } else if (field === "skeTables") {
      const tableId = pathCopy.shift();
      pathCopy.shift();
      const rowIndex = pathCopy.shift();
      pathCopy.shift();
      const cellIndex = pathCopy.shift();
      page = (_c = (_b = (_a = page.skeTables) == null ? void 0 : _a.get(tableId)) == null ? void 0 : _b.rows[rowIndex]) == null ? void 0 : _c.cells[cellIndex];
    }
  }
  return page;
}

// ../packages/engine-render/src/components/docs/layout/model/page.ts
function getHeaderFooterMaxHeight(pageHeight) {
  return (pageHeight - 100) / 2;
}
function createSkeletonPage(ctx, sectionBreakConfig, skeletonResourceReference, pageNumber = 1, breakType = 0 /* SECTION */) {
  var _a, _b, _c, _d;
  const page = _getNullPage();
  const {
    pageNumberStart = 1,
    pageSize = { width: Number.POSITIVE_INFINITY, height: Number.POSITIVE_INFINITY },
    pageOrient = 0 /* PORTRAIT */,
    headerIds = {},
    footerIds = {},
    useFirstPageHeaderFooter,
    evenAndOddHeaders,
    footerTreeMap,
    headerTreeMap,
    columnProperties = [],
    columnSeparatorType,
    marginTop = 0,
    marginBottom = 0,
    marginHeader: _marginHeader = 0,
    marginFooter: _marginFooter = 0,
    marginLeft = 0,
    marginRight = 0,
    renderConfig = {}
  } = sectionBreakConfig;
  const { skeHeaders, skeFooters } = skeletonResourceReference;
  const { width: pageWidth = Number.POSITIVE_INFINITY, height: pageHeight = Number.POSITIVE_INFINITY } = pageSize;
  page.pageNumber = pageNumber;
  page.pageNumberStart = pageNumberStart;
  page.renderConfig = renderConfig;
  page.marginLeft = marginLeft;
  page.marginRight = marginRight;
  page.breakType = breakType;
  page.pageWidth = pageWidth;
  page.width = 0;
  page.pageHeight = pageHeight;
  page.height = 0;
  page.pageOrient = pageOrient;
  const { defaultHeaderId, evenPageHeaderId, firstPageHeaderId } = headerIds;
  const { defaultFooterId, evenPageFooterId, firstPageFooterId } = footerIds;
  let headerId = defaultHeaderId != null ? defaultHeaderId : "";
  let footerId = defaultFooterId != null ? defaultFooterId : "";
  if (pageNumber === pageNumberStart && useFirstPageHeaderFooter === 1 /* TRUE */) {
    headerId = firstPageHeaderId != null ? firstPageHeaderId : "";
    footerId = firstPageFooterId != null ? firstPageFooterId : "";
  } else if (pageNumber % 2 === 0 && evenAndOddHeaders === 1 /* TRUE */) {
    headerId = evenPageHeaderId != null ? evenPageHeaderId : "";
    footerId = evenPageFooterId != null ? evenPageFooterId : "";
  }
  let header;
  let footer;
  if (headerId) {
    if ((_a = skeHeaders.get(headerId)) == null ? void 0 : _a.has(pageWidth)) {
      header = (_b = skeHeaders.get(headerId)) == null ? void 0 : _b.get(pageWidth);
    } else if (headerTreeMap && headerTreeMap.has(headerId)) {
      header = _createSkeletonHeaderFooter(
        ctx,
        headerTreeMap.get(headerId),
        sectionBreakConfig,
        skeletonResourceReference,
        headerId,
        true
      );
      skeHeaders.set(headerId, /* @__PURE__ */ new Map([[pageWidth, header]]));
    }
    page.headerId = headerId;
  }
  if (footerId) {
    if ((_c = skeFooters.get(footerId)) == null ? void 0 : _c.has(pageWidth)) {
      footer = (_d = skeFooters.get(footerId)) == null ? void 0 : _d.get(pageWidth);
    } else if (footerTreeMap && footerTreeMap.has(footerId)) {
      footer = _createSkeletonHeaderFooter(
        ctx,
        footerTreeMap.get(footerId),
        sectionBreakConfig,
        skeletonResourceReference,
        footerId,
        false
      );
      skeFooters.set(footerId, /* @__PURE__ */ new Map([[pageWidth, footer]]));
    }
    page.footerId = footerId;
  }
  page.originMarginTop = marginTop;
  page.originMarginBottom = marginBottom;
  page.marginTop = _getVerticalMargin(marginTop, header, pageHeight);
  page.marginBottom = _getVerticalMargin(marginBottom, footer, pageHeight);
  const sections = page.sections;
  const lastSection = sections[sections.length - 1];
  const { marginTop: curPageMT, marginBottom: curPageMB, marginLeft: curPageML, marginRight: curPageMR } = page;
  const pageContentWidth = pageWidth - curPageML - curPageMR;
  const pageContentHeight = pageHeight - curPageMT - curPageMB;
  let lastSectionBottom = 0;
  if (lastSection) {
    lastSectionBottom = lastSection.top + lastSection.height;
  }
  const newSection = createSkeletonSection(
    columnProperties,
    columnSeparatorType,
    lastSectionBottom,
    0,
    pageContentWidth,
    pageContentHeight - lastSectionBottom
  );
  newSection.parent = page;
  sections.push(newSection);
  return page;
}
function _getNullPage(type2 = 0 /* BODY */, segmentId = "") {
  return {
    sections: [],
    headerId: "",
    footerId: "",
    // page
    pageWidth: 0,
    pageHeight: 0,
    pageOrient: 0 /* PORTRAIT */,
    pageNumber: 1,
    pageNumberStart: 1,
    verticalAlign: false,
    angle: 0,
    width: 0,
    height: 0,
    // Only use in cell.
    left: 0,
    marginLeft: 0,
    marginRight: 0,
    originMarginTop: 0,
    marginTop: 0,
    originMarginBottom: 0,
    marginBottom: 0,
    breakType: 0 /* SECTION */,
    st: 0,
    ed: 0,
    skeDrawings: /* @__PURE__ */ new Map(),
    skeTables: /* @__PURE__ */ new Map(),
    type: type2,
    segmentId
  };
}
function _createSkeletonHeaderFooter(ctx, headerOrFooterViewModel, sectionBreakConfig, skeletonResourceReference, segmentId, isHeader = true, areaPage, count = 0) {
  const {
    lists,
    footerTreeMap,
    headerTreeMap,
    localeService,
    pageSize,
    drawings,
    marginLeft = 0,
    marginRight = 0,
    marginHeader = 0,
    marginFooter = 0
  } = sectionBreakConfig;
  const pageWidth = (pageSize == null ? void 0 : pageSize.width) || Number.POSITIVE_INFINITY;
  const pageHeight = (pageSize == null ? void 0 : pageSize.height) || Number.POSITIVE_INFINITY;
  const headerFooterConfig = {
    lists,
    footerTreeMap,
    headerTreeMap,
    pageSize: {
      width: pageWidth - marginLeft - marginRight,
      height: getHeaderFooterMaxHeight(pageHeight) - (isHeader ? marginHeader : marginFooter) - 5
    },
    localeService,
    drawings
  };
  if (areaPage == null) {
    areaPage = createSkeletonPage(ctx, headerFooterConfig, skeletonResourceReference);
    areaPage.type = isHeader ? 1 /* HEADER */ : 2 /* FOOTER */;
    areaPage.segmentId = segmentId;
  }
  const layoutAnchor = ctx.layoutStartPointer[segmentId];
  ctx.layoutStartPointer[segmentId] = null;
  const page = dealWithSection(
    ctx,
    headerOrFooterViewModel,
    headerOrFooterViewModel.getChildren()[0],
    areaPage,
    headerFooterConfig,
    layoutAnchor
  ).pages[0];
  if (ctx.isDirty && count < 10) {
    count++;
    resetContext(ctx);
    return _createSkeletonHeaderFooter(
      ctx,
      headerOrFooterViewModel,
      sectionBreakConfig,
      skeletonResourceReference,
      segmentId,
      isHeader,
      areaPage,
      count
    );
  }
  updateBlockIndex([page]);
  if (isHeader) {
    Object.assign(page, {
      marginTop: marginHeader,
      marginBottom: 5
      // Space between header and content
    });
  } else {
    Object.assign(page, {
      marginTop: 5,
      // Space between content and footer
      marginBottom: marginFooter
    });
  }
  return page;
}
function createNullCellPage(ctx, sectionBreakConfig, tableConfig, row, col, availableHeight = Number.POSITIVE_INFINITY, maxCellPageHeight = Number.POSITIVE_INFINITY) {
  var _a, _b;
  const { lists, footerTreeMap, headerTreeMap, localeService, drawings } = sectionBreakConfig;
  const { skeletonResourceReference } = ctx;
  const { cellMargin, tableRows, tableColumns, tableId } = tableConfig;
  const cellConfig = tableRows[row].tableCells[col];
  const {
    start = { v: 10 },
    end = { v: 10 },
    top = { v: 5 },
    bottom = { v: 5 }
  } = (_b = (_a = cellConfig.margin) != null ? _a : cellMargin) != null ? _b : {};
  const pageWidth = tableColumns[col].size.width.v;
  const pageHeight = maxCellPageHeight;
  const cellSectionBreakConfig = {
    lists,
    footerTreeMap,
    headerTreeMap,
    pageSize: {
      width: pageWidth,
      height: pageHeight
    },
    marginTop: top.v,
    marginBottom: bottom.v,
    marginLeft: start.v,
    marginRight: end.v,
    localeService,
    drawings
  };
  const areaPage = createSkeletonPage(
    ctx,
    // Set first page height to availableHeight.
    Object.assign({}, cellSectionBreakConfig, {
      pageSize: {
        width: pageWidth,
        height: Number.isFinite(availableHeight) ? availableHeight : pageHeight
      }
    }),
    skeletonResourceReference
  );
  areaPage.type = 3 /* CELL */;
  areaPage.segmentId = tableId;
  return {
    page: areaPage,
    sectionBreakConfig: cellSectionBreakConfig
  };
}
function createSkeletonCellPages(ctx, viewModel, cellNode, sectionBreakConfig, tableConfig, row, col, availableHeight = Number.POSITIVE_INFINITY, maxCellPageHeight = Number.POSITIVE_INFINITY) {
  const sectionNode = cellNode.children[0];
  const { page: areaPage, sectionBreakConfig: cellSectionBreakConfig } = createNullCellPage(
    ctx,
    sectionBreakConfig,
    tableConfig,
    row,
    col,
    availableHeight,
    maxCellPageHeight
  );
  const { pages } = dealWithSection(
    ctx,
    viewModel,
    sectionNode,
    areaPage,
    cellSectionBreakConfig
  );
  for (const p of pages) {
    p.type = 3 /* CELL */;
    p.segmentId = tableConfig.tableId;
  }
  updateBlockIndex(pages, cellNode.startIndex);
  updateInlineDrawingCoordsAndBorder(ctx, pages);
  return pages;
}
function _getVerticalMargin(marginTB, headerOrFooter, pageHeight) {
  if (!headerOrFooter || headerOrFooter.sections[0].columns[0].lines.length === 0) {
    return marginTB;
  }
  const HeaderFooterPageHeight = headerOrFooter.height + headerOrFooter.marginTop + headerOrFooter.marginBottom;
  const maxMargin = getHeaderFooterMaxHeight(pageHeight);
  return Math.min(maxMargin, Math.max(marginTB, HeaderFooterPageHeight));
}

// ../packages/engine-render/src/components/docs/layout/block/block-error.ts
function dealWithBlockError() {
  return [];
}

// ../packages/engine-render/src/components/docs/layout/line-breaker/enhancers/utils.ts
function isLetter(char) {
  return char.length > 0 && !/\s|(?![\'])[\!-\@\[-\`\{-\~\u2013-\u203C]/.test(char);
}
function getWord(str) {
  let word = "";
  for (let i = 0; i < str.length; i++) {
    if (isLetter(str[i])) {
      word += str[i];
    } else {
      break;
    }
  }
  return word;
}
function getSlicePosition(lastPos, hyphenSlice, index) {
  let position = lastPos;
  for (let i = 0; i <= index; i++) {
    position += hyphenSlice[i].length;
  }
  return position;
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/line-adjustment.ts
function overhang(c) {
  switch (c) {
    // Dashes.
    case "\u2013":
    case "\u2014": {
      return 0.2;
    }
    // Punctuation.
    case ".":
    case ",": {
      return 0.8;
    }
    case ":":
    case ";": {
      return 0.3;
    }
    // Arabic
    case "\u060C":
    case "\u06D4": {
      return 0.4;
    }
    default: {
      return 0;
    }
  }
}
function getDivideShrinkability(divide) {
  const { glyphGroup } = divide;
  let shrinkability = 0;
  for (const glyph of glyphGroup) {
    const [left, right] = glyph.adjustability.shrinkability;
    shrinkability += left + right;
  }
  return shrinkability;
}
function getDivideStretchability(divide) {
  const { glyphGroup } = divide;
  let stretchability = 0;
  for (const glyph of glyphGroup) {
    const [left, right] = glyph.adjustability.stretchability;
    stretchability += left + right;
  }
  return stretchability;
}
function getJustifiables(divide) {
  const justifiables = divide.glyphGroup.filter((glyph) => glyph.isJustifiable).length;
  const lastGlyph = divide.glyphGroup[divide.glyphGroup.length - 1];
  if (hasCJK(lastGlyph.content)) {
    return justifiables - 1;
  }
  return justifiables;
}
function adjustGlyphsInDivide(divide, justificationRatio, extraJustification) {
  for (const glyph of divide.glyphGroup) {
    const adjustabilityLeft = justificationRatio < 0 ? glyph.adjustability.shrinkability[0] : glyph.adjustability.stretchability[0];
    const adjustabilityRight = justificationRatio < 0 ? glyph.adjustability.shrinkability[1] : glyph.adjustability.stretchability[1];
    const justificationLeft = adjustabilityLeft * justificationRatio;
    let justificationRight = adjustabilityRight * justificationRatio;
    if (glyph.isJustifiable) {
      justificationRight += extraJustification;
    }
    glyph.width += justificationLeft + justificationRight;
    glyph.xOffset += justificationLeft;
  }
  setGlyphGroupLeft(divide.glyphGroup);
}
function horizontalAlignHandler(line2, horizontalAlign) {
  const { divides } = line2;
  for (let i = 0; i < divides.length; i++) {
    const divide = divides[i];
    const { width } = divide;
    let glyphGroupWidth = getGlyphGroupWidth(divide);
    if (width === Number.POSITIVE_INFINITY) {
      continue;
    }
    if (divide.isFull) {
      let remaining = width - glyphGroupWidth;
      if (divide.glyphGroup.length > 1) {
        const lastGlyph = divide.glyphGroup[divide.glyphGroup.length - 1];
        const amount = overhang(lastGlyph.content) * lastGlyph.width;
        remaining += amount;
      }
      let justificationRatio = 0;
      let extraJustification = 0;
      const shrink = getDivideShrinkability(divide);
      const stretch = getDivideStretchability(divide);
      if (remaining < 0 && shrink > 0) {
        justificationRatio = Math.max(remaining / shrink, -1);
        remaining = Math.min(remaining + shrink, 0);
      } else if (horizontalAlign === 4 /* JUSTIFIED */) {
        if (stretch > 0) {
          justificationRatio = Math.min(remaining / stretch, 1);
          remaining = Math.max(remaining - stretch, 0);
        }
        const justifiables = getJustifiables(divide);
        if (justifiables > 0 && remaining > 0) {
          extraJustification = remaining / justifiables;
          remaining = 0;
        }
      }
      if (justificationRatio !== 0 || extraJustification !== 0) {
        adjustGlyphsInDivide(divide, justificationRatio, extraJustification);
        glyphGroupWidth = getGlyphGroupWidth(divide);
      }
    }
    if (horizontalAlign === 2 /* CENTER */) {
      divide.paddingLeft = (width - glyphGroupWidth) / 2;
    } else if (horizontalAlign === 3 /* RIGHT */) {
      divide.paddingLeft = width - glyphGroupWidth;
    }
    divide.paddingLeft = Math.max(divide.paddingLeft, 0);
  }
}
function restoreLastCJKGlyphWidth(line2) {
  for (const divide of line2.divides) {
    const lastGlyph = divide.glyphGroup[divide.glyphGroup.length - 1];
    if (lastGlyph && divide.isFull && hasCJKText(lastGlyph.content) && lastGlyph.width - lastGlyph.xOffset > lastGlyph.bBox.width) {
      const shrinkAmount = lastGlyph.width - lastGlyph.xOffset - lastGlyph.bBox.width;
      lastGlyph.width -= shrinkAmount;
      lastGlyph.adjustability.shrinkability[1] = 0;
    }
  }
}
function shrinkStartAndEndCJKPunctuation(line2) {
  for (const divide of line2.divides) {
    const glyphGroupLength = divide.glyphGroup.length;
    if (glyphGroupLength < 2) {
      continue;
    }
    const firstGlyph = divide.glyphGroup[0];
    const lastGlyph = divide.glyphGroup[glyphGroupLength - 1];
    if (isCjkRightAlignedPunctuation(firstGlyph.content)) {
      const shrinkAmount = firstGlyph.adjustability.shrinkability[0];
      glyphShrinkLeft(firstGlyph, shrinkAmount);
    }
    if (isCjkLeftAlignedPunctuation(lastGlyph.content)) {
      const shrinkAmount = lastGlyph.adjustability.shrinkability[1];
      glyphShrinkRight(lastGlyph, shrinkAmount);
    }
    setGlyphGroupLeft(divide.glyphGroup);
  }
}
function addHyphenDash(line2, viewModel, paragraphNode, sectionBreakConfig, paragraphStyle) {
  for (const divide of line2.divides) {
    const { glyphGroup, breakType } = divide;
    const lastGlyph = glyphGroup[glyphGroup.length - 1];
    if (lastGlyph && isLetter(lastGlyph.content) && breakType === "Hyphen" /* Hyphen */) {
      const config = getFontConfigFromLastGlyph(lastGlyph, sectionBreakConfig, paragraphStyle);
      const hyphenDashGlyph = createHyphenDashGlyph(config);
      hyphenDashGlyph.parent = lastGlyph.parent;
      hyphenDashGlyph.left = lastGlyph.left + lastGlyph.width;
      divide.glyphGroup.push(hyphenDashGlyph);
      divide.width -= hyphenDashGlyph.width;
    }
  }
}
function lineAdjustment(pages, viewModel, paragraphNode, sectionBreakConfig) {
  const { endIndex } = paragraphNode;
  const paragraph = viewModel.getParagraph(endIndex) || { startIndex: 0 };
  lineIterator(pages, (line2) => {
    if (line2.paragraphIndex !== paragraph.startIndex) {
      return;
    }
    const { paragraphStyle = {} } = paragraph;
    const { horizontalAlign = 0 /* UNSPECIFIED */ } = paragraphStyle;
    shrinkStartAndEndCJKPunctuation(line2);
    restoreLastCJKGlyphWidth(line2);
    addHyphenDash(line2, viewModel, paragraphNode, sectionBreakConfig, paragraphStyle);
    horizontalAlignHandler(line2, horizontalAlign);
  });
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/bullet-ruler.ts
function getBulletOrderedSymbol(startIndex, startNumber, glyphType) {
  return generateOrderedSymbol(startIndex, startNumber, glyphType);
}
function generateOrderedSymbol(startIndex, startNumber, glyphType) {
  if (glyphType === 2 /* DECIMAL */) {
    return decimal(startIndex, startNumber);
  }
  if (glyphType === 3 /* DECIMAL_ZERO */) {
    return zeroDecimal(startIndex, startNumber);
  }
  if (glyphType === 4 /* UPPER_LETTER */) {
    return upperAlpha(startIndex, startNumber);
  }
  if (glyphType === 5 /* LOWER_LETTER */) {
    return alpha(startIndex, startNumber);
  }
  if (glyphType === 6 /* UPPER_ROMAN */) {
    return upperRoman(startIndex, startNumber);
  }
  if (glyphType === 7 /* LOWER_ROMAN */) {
    return roman(startIndex, startNumber);
  }
  return decimal(startIndex, startNumber);
}
function decimal(startIndex, startNumber) {
  const currentIndex = startIndex + startNumber;
  return currentIndex.toString();
}
function zeroDecimal(startIndex, startNumber) {
  const currentIndex = startIndex + startNumber;
  if (currentIndex < 10) {
    return `0${currentIndex}`;
  }
  return currentIndex.toString();
}
function upperAlpha(startIndex, startNumber) {
  return numberToListABC(startIndex + startNumber - 1, true);
}
function alpha(startIndex, startNumber) {
  return numberToListABC(startIndex + startNumber - 1, false);
}
function upperRoman(startIndex, startNumber) {
  return _convertRoman(startIndex + startNumber, true);
}
function roman(startIndex, startNumber) {
  return _convertRoman(startIndex + startNumber, false);
}
function _convertRoman(num, uppercase = false) {
  const upperLookup = {
    M: 1e3,
    CM: 900,
    D: 500,
    CD: 400,
    C: 100,
    XC: 90,
    L: 50,
    XL: 40,
    X: 10,
    IX: 9,
    V: 5,
    IV: 4,
    I: 1
  };
  const lowerLookup = {
    m: 1e3,
    cm: 900,
    d: 500,
    cd: 400,
    c: 100,
    xc: 90,
    l: 50,
    xl: 40,
    x: 10,
    ix: 9,
    v: 5,
    iv: 4,
    i: 1
  };
  let lookup = lowerLookup;
  if (uppercase) {
    lookup = upperLookup;
  }
  let romanStr = "";
  for (const i in lookup) {
    while (num >= lookup[i]) {
      romanStr += i;
      num -= lookup[i];
    }
  }
  return romanStr;
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/bullet.ts
function dealWithBullet(bullet, lists, listLevelAncestors, localeService) {
  var _a, _b;
  if (!bullet || !lists) {
    return;
  }
  const { listId, listType, nestingLevel = 0, textStyle } = bullet;
  const list = lists[listType];
  if (!list || !list.nestingLevel) {
    return getDefaultBulletSke(listId, (_a = listLevelAncestors == null ? void 0 : listLevelAncestors[nestingLevel]) == null ? void 0 : _a.startIndexItem);
  }
  const nesting = list.nestingLevel[nestingLevel];
  if (!nesting) {
    return getDefaultBulletSke(listId, (_b = listLevelAncestors == null ? void 0 : listLevelAncestors[nestingLevel]) == null ? void 0 : _b.startIndexItem);
  }
  const bulletSke = _getBulletSke(
    listId,
    nestingLevel,
    list.nestingLevel,
    listLevelAncestors,
    textStyle,
    localeService
  );
  return bulletSke;
}
function getDefaultBulletSke(listId, startIndex = 1) {
  return {
    listId,
    symbol: "\u25CF",
    // symbol 列表的内容
    ts: {
      // TODO: @jikkai @DR-Univer should read default font from configuration, not from locale service
      ff: "Arial",
      fs: 9
    },
    // 文字样式
    startIndexItem: startIndex,
    // bBox: {
    //     width: 8.4560546875,
    //     ba: 7,
    //     bd: -1,
    //     aba: 7,
    //     abd: -1,
    //     sp: -2,
    //     sbr: 0.5,
    //     sbo: 0,
    //     spr: 0.5,
    //     spo: 0,
    // },
    paragraphProperties: {
      indentFirstLine: { v: 0 },
      hanging: { v: 21 },
      indentStart: { v: 0 }
    }
  };
}
function _getBulletSke(listId, nestingLevel, nestings, listLevelAncestors, textStyleConfig, _localeService) {
  var _a, _b;
  const nesting = nestings[nestingLevel];
  const {
    bulletAlignment,
    glyphFormat,
    textStyle: textStyleFirst = {},
    // startNumber,
    glyphType,
    glyphSymbol
  } = nesting;
  const textStyle = { ...textStyleConfig, ...textStyleFirst };
  const fontStyle = getFontStyleString(textStyle);
  let symbolContent;
  if (glyphSymbol) {
    symbolContent = glyphSymbol;
  } else {
    symbolContent = __generateOrderedListSymbol(glyphFormat, nestingLevel, nestings, listLevelAncestors);
  }
  const startIndex = (_b = (_a = listLevelAncestors == null ? void 0 : listLevelAncestors[nestingLevel]) == null ? void 0 : _a.startIndexItem) != null ? _b : 1;
  return {
    listId,
    symbol: symbolContent,
    // symbol 列表的内容
    ts: textStyle,
    // 文字样式
    fontStyle,
    //
    startIndexItem: startIndex + 1,
    // bBox,
    nestingLevel: nesting,
    bulletAlign: bulletAlignment,
    bulletType: glyphSymbol ? false : !!glyphType,
    // 默认是无序列表，假如glyphSymbol为空且glyphType不为空才是有序列表
    paragraphProperties: nesting.paragraphProperties
  };
}
function __generateOrderedListSymbol(glyphFormat, nestingLevel, nestings, listLevelAncestors) {
  var _a;
  const glyphFormatSplit = glyphFormat.split("%");
  const prefix = glyphFormatSplit[0];
  const resultSymbol = [prefix];
  for (let i = 1; i < glyphFormatSplit.length; i++) {
    const levelAndSuffixPre = glyphFormatSplit[i];
    const { level, suffix } = ___getLevelAndSuffix(levelAndSuffixPre);
    let startIndexItem = ((_a = listLevelAncestors == null ? void 0 : listLevelAncestors[level]) == null ? void 0 : _a.startIndexItem) || 1;
    if (level !== nestingLevel && (listLevelAncestors == null ? void 0 : listLevelAncestors[level]) !== null) {
      startIndexItem -= 1;
    }
    const singleSymbol = ___getSymbolByBesting(startIndexItem, nestings[level]);
    resultSymbol.push(singleSymbol, suffix);
  }
  return resultSymbol.join("");
}
function ___getSymbolByBesting(startIndex = 1, nesting) {
  const { startNumber, glyphType, glyphSymbol } = nesting;
  if (glyphSymbol) {
    return glyphSymbol;
  }
  if (!glyphType) {
    return "\u25CF";
  }
  return getBulletOrderedSymbol(startIndex, startNumber, glyphType);
}
function ___getLevelAndSuffix(levelAndSuffixPre) {
  if (levelAndSuffixPre === "") {
    return {
      level: 0,
      suffix: ""
    };
  }
  const levelAndSuffixPreSpit = levelAndSuffixPre.split("");
  let level = "";
  let suffix = "";
  let isSuffixState = false;
  const digitReg = /[0-9]/g;
  levelAndSuffixPreSpit.forEach((w) => {
    if (!isSuffixState && digitReg.test(`${level}${w}`)) {
      level += w;
    } else {
      isSuffixState = true;
      suffix += w;
    }
  });
  return {
    level: Number.parseInt(level) - 1,
    suffix
  };
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/linebreaking.ts
function _getListLevelAncestors(bullet, listLevel) {
  var _a, _b;
  if (!bullet || !listLevel) {
    return;
  }
  const { listId, nestingLevel } = bullet;
  const sameList = listLevel == null ? void 0 : listLevel.get(listId);
  let level = nestingLevel;
  if (level < 0) {
    level = 0;
  }
  const listLevelAncestors = [];
  for (let i = level; i >= 0; i--) {
    if (Array.isArray(sameList == null ? void 0 : sameList[i])) {
      const len = sameList[i].length;
      listLevelAncestors[i] = (_b = (_a = sameList[i][len - 1]) == null ? void 0 : _a.bullet) != null ? _b : null;
    } else {
      listLevelAncestors[i] = null;
    }
  }
  return listLevelAncestors;
}
function _updateListLevelAncestors(paragraph, bullet, bulletSkeleton, listLevel) {
  if (!bullet || !bulletSkeleton) {
    return;
  }
  const { listId, nestingLevel } = bullet;
  const cacheItem = [...(listLevel == null ? void 0 : listLevel.get(listId)) || []];
  if (cacheItem[nestingLevel] == null) {
    cacheItem[nestingLevel] = [];
  }
  cacheItem[nestingLevel].push({
    bullet: bulletSkeleton,
    paragraph
  });
  cacheItem.splice(nestingLevel + 1);
  listLevel == null ? void 0 : listLevel.set(listId, cacheItem);
}
function _getDrawingSkeletonFormat(drawingOrigin) {
  const { drawingId } = drawingOrigin;
  return {
    drawingId,
    aLeft: 0,
    aTop: 0,
    width: 0,
    height: 0,
    angle: 0,
    initialState: false,
    drawingOrigin,
    columnLeft: 0,
    lineHeight: 0,
    lineTop: 0,
    blockAnchorTop: 0,
    isPageBreak: false
  };
}
function _getNextPageNumber(lastPage) {
  return lastPage.pageNumber + 1;
}
function lineBreaking(ctx, viewModel, shapedTextList, curPage, paragraphNode, sectionBreakConfig, tableSkeleton) {
  var _a;
  const { skeletonResourceReference } = ctx;
  const {
    lists,
    drawings = {},
    localeService
  } = sectionBreakConfig;
  const { endIndex, blocks = [], children } = paragraphNode;
  const { segmentId } = curPage;
  const paragraph = viewModel.getParagraph(endIndex) || { startIndex: 0 };
  const { paragraphStyle = {}, bullet } = paragraph;
  const { skeHeaders, skeFooters, skeListLevel, drawingAnchor } = skeletonResourceReference;
  const paragraphNonInlineSkeDrawings = /* @__PURE__ */ new Map();
  const paragraphInlineSkeDrawings = /* @__PURE__ */ new Map();
  let segmentDrawingAnchorCache = drawingAnchor == null ? void 0 : drawingAnchor.get(segmentId);
  if (segmentDrawingAnchorCache == null) {
    segmentDrawingAnchorCache = /* @__PURE__ */ new Map();
    drawingAnchor == null ? void 0 : drawingAnchor.set(segmentId, segmentDrawingAnchorCache);
  }
  const paragraphConfig = {
    paragraphIndex: endIndex,
    // TODO optimize this deepClone
    paragraphStyle: Tools.deepClone(paragraphStyle),
    paragraphNonInlineSkeDrawings,
    paragraphInlineSkeDrawings,
    skeTablesInParagraph: tableSkeleton ? [
      {
        tableId: tableSkeleton.tableId,
        table: tableSkeleton,
        hasPositioned: false,
        isSlideTable: false,
        tableNode: children[0]
      }
    ] : void 0,
    skeHeaders,
    skeFooters,
    pDrawingAnchor: segmentDrawingAnchorCache
  };
  let segmentParagraphCache = ctx.paragraphConfigCache.get(segmentId);
  if (segmentParagraphCache == null) {
    segmentParagraphCache = /* @__PURE__ */ new Map();
    ctx.paragraphConfigCache.set(segmentId, segmentParagraphCache);
  }
  if (segmentParagraphCache.has(endIndex)) {
    const bulletSkeleton = (_a = segmentParagraphCache.get(endIndex)) == null ? void 0 : _a.bulletSkeleton;
    paragraphConfig.bulletSkeleton = bulletSkeleton;
  } else {
    const listLevelAncestors = _getListLevelAncestors(bullet, skeListLevel);
    const bulletSkeleton = dealWithBullet(bullet, lists, listLevelAncestors, localeService);
    _updateListLevelAncestors(paragraph, bullet, bulletSkeleton, skeListLevel);
    paragraphConfig.bulletSkeleton = bulletSkeleton;
  }
  for (let i = 0, len = blocks.length; i < len; i++) {
    const charIndex = blocks[i];
    const customBlock = viewModel.getCustomBlock(charIndex);
    if (customBlock == null) {
      continue;
    }
    const { blockId } = customBlock;
    const drawingOrigin = drawings[blockId];
    if (drawingOrigin.layoutType === 0 /* INLINE */) {
      paragraphInlineSkeDrawings.set(blockId, _getDrawingSkeletonFormat(drawingOrigin));
    } else {
      paragraphNonInlineSkeDrawings.set(blockId, _getDrawingSkeletonFormat(drawingOrigin));
    }
  }
  segmentParagraphCache.set(endIndex, paragraphConfig);
  let allPages = [curPage];
  let isParagraphFirstShapedText = true;
  for (const [_index, { text, glyphs, breakPointType }] of shapedTextList.entries()) {
    const pushPending = () => {
      if (glyphs.length === 0) {
        return;
      }
      allPages = layoutParagraph(
        ctx,
        glyphs,
        allPages,
        sectionBreakConfig,
        paragraphConfig,
        isParagraphFirstShapedText,
        breakPointType
      );
      isParagraphFirstShapedText = false;
    };
    if (text.endsWith("\f" /* PAGE_BREAK */)) {
      pushPending();
      allPages.push(
        createSkeletonPage(
          ctx,
          sectionBreakConfig,
          skeletonResourceReference,
          _getNextPageNumber(allPages[allPages.length - 1]),
          1 /* PAGE */
        )
      );
      paragraphNonInlineSkeDrawings.clear();
      paragraphInlineSkeDrawings.clear();
      continue;
    } else if (text.endsWith("\v" /* COLUMN_BREAK */)) {
      pushPending();
      const lastPage = allPages[allPages.length - 1];
      const columnInfo = getLastNotFullColumnInfo(lastPage);
      if (columnInfo && !columnInfo.isLast) {
        setColumnFullState(columnInfo.column, true);
      } else {
        allPages.push(
          createSkeletonPage(
            ctx,
            sectionBreakConfig,
            skeletonResourceReference,
            _getNextPageNumber(lastPage),
            2 /* COLUMN */
          )
        );
      }
      continue;
    }
    pushPending();
  }
  return allPages;
}

// ../packages/engine-render/src/components/docs/layout/line-breaker/classes.ts
var NS = 5;
var AL = 12;
var HL = 13;
var HY = 16;
var BA = 17;
var WJ = 22;
var RI = 28;
var ZWJ = 31;
var AI = 33;
var BK = 34;
var CJ = 35;
var CR = 36;
var LF = 37;
var NL = 38;
var SA = 39;
var SG = 40;
var SP = 41;
var XX = 42;

// ../packages/engine-render/src/components/docs/layout/line-breaker/pairs.ts
var DI_BRK = 0;
var IN_BRK = 1;
var CI_BRK = 2;
var CP_BRK = 3;
var PR_BRK = 4;
var pairTable = [
  //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
  [
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    CP_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK
  ],
  // OP
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // CL
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // CP
  [
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK
  ],
  // QU
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK
  ],
  // GL
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // NS
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // EX
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // SY
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // IS
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK
  ],
  // PR
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // PO
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // NU
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // AL
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // HL
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // ID
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // IN
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // HY
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // BA
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK
  ],
  // BB
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    PR_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // B2
  [
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK
  ],
  // ZW
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // CM
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK
  ],
  // WJ
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // H2
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // H3
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // JL
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // JV
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // JT
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // RI
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK
  ],
  // EB
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // EM
  [
    IN_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    IN_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ],
  // ZWJ
  [
    DI_BRK,
    PR_BRK,
    PR_BRK,
    IN_BRK,
    IN_BRK,
    DI_BRK,
    PR_BRK,
    PR_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    PR_BRK,
    CI_BRK,
    PR_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    DI_BRK,
    IN_BRK,
    DI_BRK
  ]
  // CB
];

// ../packages/engine-render/src/components/docs/layout/line-breaker/rule.ts
var Rule = class {
  constructor() {
    __publicField(this, "_rules", /* @__PURE__ */ new Map());
  }
  add(key, rule) {
    this._rules.set(key, rule);
  }
  shouldBreak(codePoint, lastCodePoint, className) {
    for (const rule of this._rules.values()) {
      if (rule(codePoint, lastCodePoint, className)) {
        return true;
      }
    }
    return false;
  }
};

// ../packages/engine-render/src/components/docs/layout/line-breaker/trie-data.ts
var trie_data_default = new Uint8Array([
  0,
  8,
  14,
  0,
  0,
  0,
  0,
  0,
  176,
  232,
  0,
  0,
  1,
  181,
  15,
  74,
  240,
  237,
  157,
  11,
  140,
  93,
  69,
  25,
  199,
  231,
  178,
  187,
  183,
  123,
  31,
  187,
  237,
  46,
  108,
  193,
  194,
  22,
  104,
  41,
  200,
  242,
  48,
  128,
  104,
  16,
  129,
  152,
  162,
  64,
  42,
  10,
  193,
  42,
  24,
  121,
  104,
  2,
  65,
  177,
  4,
  9,
  69,
  41,
  193,
  104,
  73,
  35,
  193,
  84,
  20,
  104,
  144,
  152,
  74,
  140,
  109,
  80,
  1,
  149,
  87,
  12,
  175,
  68,
  64,
  162,
  60,
  42,
  9,
  136,
  196,
  70,
  194,
  35,
  40,
  132,
  84,
  222,
  34,
  40,
  18,
  255,
  195,
  153,
  113,
  103,
  103,
  231,
  253,
  58,
  183,
  244,
  158,
  228,
  151,
  57,
  103,
  158,
  223,
  124,
  243,
  205,
  227,
  204,
  57,
  231,
  222,
  141,
  3,
  132,
  220,
  0,
  110,
  5,
  119,
  129,
  191,
  129,
  127,
  128,
  127,
  130,
  255,
  130,
  129,
  65,
  66,
  58,
  131,
  254,
  238,
  56,
  88,
  0,
  22,
  129,
  41,
  240,
  1,
  240,
  97,
  135,
  116,
  71,
  128,
  163,
  12,
  225,
  199,
  130,
  229,
  224,
  100,
  112,
  58,
  88,
  1,
  86,
  130,
  11,
  193,
  197,
  66,
  188,
  75,
  192,
  247,
  193,
  85,
  224,
  26,
  176,
  17,
  220,
  0,
  174,
  7,
  183,
  128,
  59,
  193,
  239,
  192,
  67,
  224,
  81,
  240,
  56,
  75,
  251,
  36,
  115,
  159,
  3,
  47,
  129,
  55,
  192,
  155,
  128,
  12,
  17,
  50,
  12,
  230,
  129,
  113,
  176,
  0,
  44,
  2,
  83,
  96,
  95,
  112,
  16,
  56,
  20,
  44,
  101,
  225,
  203,
  192,
  9,
  44,
  156,
  94,
  127,
  30,
  124,
  9,
  124,
  5,
  124,
  21,
  156,
  7,
  46,
  4,
  23,
  179,
  240,
  239,
  130,
  43,
  192,
  143,
  216,
  245,
  79,
  193,
  117,
  67,
  85,
  249,
  55,
  195,
  189,
  3,
  220,
  203,
  242,
  167,
  242,
  61,
  0,
  247,
  17,
  176,
  25,
  252,
  21,
  60,
  11,
  30,
  27,
  168,
  174,
  183,
  128,
  87,
  216,
  245,
  91,
  112,
  27,
  205,
  42,
  77,
  11,
  238,
  24,
  152,
  0,
  147,
  205,
  42,
  124,
  11,
  139,
  191,
  164,
  89,
  185,
  123,
  179,
  184,
  156,
  3,
  154,
  211,
  28,
  194,
  56,
  2,
  124,
  140,
  33,
  198,
  53,
  113,
  12,
  226,
  30,
  47,
  197,
  63,
  11,
  229,
  157,
  228,
  145,
  135,
  11,
  95,
  20,
  242,
  251,
  50,
  206,
  87,
  128,
  149,
  224,
  34,
  176,
  166,
  57,
  93,
  223,
  181,
  56,
  95,
  7,
  214,
  75,
  229,
  111,
  196,
  245,
  213,
  194,
  245,
  181,
  184,
  254,
  21,
  248,
  141,
  144,
  150,
  114,
  23,
  75,
  119,
  159,
  224,
  191,
  137,
  234,
  20,
  60,
  209,
  172,
  236,
  158,
  242,
  44,
  206,
  159,
  3,
  47,
  130,
  55,
  192,
  59,
  160,
  57,
  7,
  233,
  160,
  251,
  209,
  57,
  85,
  30,
  19,
  112,
  39,
  193,
  30,
  115,
  166,
  203,
  221,
  23,
  231,
  7,
  206,
  209,
  215,
  243,
  35,
  8,
  59,
  220,
  16,
  238,
  194,
  39,
  144,
  254,
  83,
  224,
  179,
  224,
  20,
  112,
  6,
  56,
  27,
  156,
  15,
  190,
  9,
  86,
  131,
  75,
  193,
  229,
  96,
  29,
  88,
  15,
  54,
  176,
  50,
  175,
  99,
  238,
  205,
  112,
  239,
  0,
  247,
  130,
  7,
  193,
  163,
  96,
  51,
  11,
  123,
  6,
  238,
  243,
  224,
  37,
  141,
  156,
  175,
  9,
  254,
  111,
  225,
  188,
  49,
  60,
  147,
  237,
  132,
  243,
  54,
  24,
  5,
  243,
  193,
  66,
  176,
  4,
  236,
  7,
  14,
  6,
  135,
  129,
  143,
  131,
  99,
  193,
  114,
  112,
  50,
  56,
  29,
  172,
  0,
  43,
  135,
  171,
  252,
  47,
  128,
  251,
  109,
  240,
  29,
  118,
  253,
  61,
  184,
  235,
  134,
  253,
  117,
  182,
  158,
  165,
  217,
  0,
  247,
  58,
  143,
  244,
  55,
  7,
  148,
  117,
  187,
  148,
  230,
  30,
  225,
  250,
  90,
  102,
  99,
  15,
  192,
  239,
  17,
  176,
  121,
  184,
  234,
  207,
  207,
  12,
  251,
  241,
  2,
  120,
  21,
  252,
  155,
  234,
  187,
  5,
  61,
  131,
  241,
  86,
  117,
  190,
  160,
  101,
  78,
  187,
  72,
  8,
  159,
  178,
  196,
  237,
  211,
  167,
  79,
  58,
  248,
  56,
  80,
  183,
  28,
  125,
  250,
  244,
  233,
  211,
  167,
  79,
  159,
  62,
  125,
  182,
  46,
  246,
  239,
  209,
  251,
  182,
  131,
  91,
  51,
  247,
  67,
  180,
  251,
  32,
  173,
  106,
  47,
  143,
  158,
  31,
  129,
  243,
  95,
  10,
  97,
  71,
  181,
  236,
  233,
  63,
  141,
  56,
  159,
  99,
  241,
  78,
  129,
  251,
  49,
  184,
  147,
  224,
  12,
  156,
  159,
  205,
  242,
  62,
  31,
  238,
  69,
  96,
  13,
  88,
  11,
  126,
  0,
  174,
  6,
  63,
  105,
  85,
  251,
  56,
  63,
  135,
  123,
  99,
  107,
  230,
  254,
  16,
  229,
  54,
  248,
  253,
  204,
  80,
  246,
  221,
  8,
  191,
  31,
  60,
  0,
  30,
  4,
  15,
  129,
  77,
  224,
  143,
  224,
  225,
  126,
  88,
  63,
  172,
  31,
  214,
  15,
  235,
  135,
  37,
  15,
  251,
  51,
  120,
  2,
  60,
  213,
  170,
  246,
  76,
  235,
  228,
  249,
  86,
  189,
  212,
  93,
  255,
  62,
  125,
  122,
  153,
  216,
  117,
  236,
  203,
  232,
  99,
  111,
  130,
  183,
  91,
  225,
  207,
  233,
  72,
  91,
  237,
  63,
  12,
  255,
  121,
  96,
  39,
  176,
  43,
  216,
  75,
  138,
  183,
  15,
  174,
  15,
  2,
  135,
  130,
  165,
  96,
  25,
  56,
  174,
  93,
  201,
  117,
  34,
  220,
  211,
  218,
  245,
  143,
  63,
  59,
  204,
  173,
  184,
  18,
  252,
  9,
  116,
  231,
  233,
  57,
  26,
  92,
  2,
  238,
  84,
  132,
  189,
  45,
  93,
  127,
  112,
  140,
  144,
  243,
  192,
  45,
  96,
  203,
  88,
  229,
  183,
  219,
  56,
  33,
  95,
  0,
  87,
  130,
  95,
  131,
  151,
  193,
  211,
  173,
  74,
  119,
  167,
  130,
  107,
  192,
  147,
  84,
  135,
  29,
  66,
  14,
  0,
  4,
  247,
  31,
  159,
  233,
  84,
  215,
  34,
  23,
  131,
  43,
  26,
  211,
  220,
  203,
  226,
  114,
  182,
  224,
  122,
  223,
  46,
  33,
  159,
  4,
  95,
  3,
  95,
  7,
  55,
  129,
  87,
  193,
  129,
  35,
  240,
  3,
  55,
  130,
  87,
  70,
  102,
  230,
  179,
  173,
  49,
  54,
  58,
  83,
  111,
  125,
  250,
  244,
  233,
  179,
  45,
  113,
  252,
  168,
  121,
  238,
  63,
  19,
  243,
  209,
  57,
  154,
  249,
  159,
  114,
  110,
  123,
  246,
  154,
  133,
  135,
  173,
  66,
  216,
  106,
  41,
  237,
  26,
  92,
  175,
  101,
  126,
  203,
  53,
  239,
  94,
  209,
  247,
  178,
  214,
  37,
  126,
  47,
  203,
  196,
  101,
  154,
  250,
  173,
  51,
  212,
  155,
  178,
  30,
  225,
  251,
  209,
  119,
  229,
  20,
  241,
  126,
  193,
  252,
  110,
  178,
  228,
  97,
  227,
  118,
  133,
  126,
  85,
  240,
  248,
  247,
  176,
  248,
  191,
  23,
  202,
  125,
  152,
  157,
  63,
  46,
  248,
  109,
  166,
  235,
  48,
  240,
  119,
  232,
  249,
  5,
  184,
  175,
  180,
  171,
  119,
  195,
  222,
  130,
  219,
  192,
  250,
  97,
  78,
  167,
  186,
  158,
  11,
  119,
  71,
  176,
  51,
  187,
  190,
  0,
  105,
  23,
  119,
  166,
  247,
  21,
  247,
  193,
  249,
  65,
  157,
  105,
  25,
  14,
  197,
  249,
  249,
  112,
  151,
  194,
  93,
  6,
  142,
  5,
  203,
  193,
  201,
  29,
  181,
  204,
  13,
  216,
  224,
  233,
  157,
  105,
  185,
  22,
  130,
  21,
  138,
  184,
  60,
  254,
  42,
  176,
  82,
  40,
  143,
  198,
  191,
  8,
  215,
  107,
  88,
  30,
  107,
  225,
  174,
  99,
  225,
  116,
  15,
  116,
  61,
  206,
  55,
  26,
  242,
  187,
  161,
  163,
  214,
  59,
  221,
  119,
  165,
  123,
  171,
  183,
  34,
  252,
  174,
  206,
  204,
  52,
  247,
  225,
  122,
  19,
  245,
  3,
  127,
  1,
  79,
  179,
  60,
  158,
  135,
  251,
  50,
  59,
  127,
  29,
  238,
  219,
  154,
  114,
  229,
  250,
  12,
  98,
  93,
  214,
  1,
  243,
  192,
  68,
  119,
  118,
  89,
  147,
  221,
  234,
  124,
  73,
  119,
  186,
  110,
  54,
  246,
  67,
  220,
  131,
  187,
  213,
  187,
  127,
  135,
  9,
  121,
  30,
  137,
  243,
  163,
  193,
  113,
  221,
  114,
  253,
  203,
  133,
  19,
  123,
  76,
  158,
  58,
  56,
  141,
  233,
  224,
  76,
  131,
  46,
  206,
  210,
  132,
  157,
  11,
  255,
  85,
  93,
  55,
  219,
  200,
  73,
  104,
  221,
  87,
  39,
  108,
  127,
  250,
  110,
  226,
  165,
  221,
  233,
  115,
  58,
  151,
  92,
  198,
  174,
  175,
  130,
  251,
  227,
  66,
  182,
  182,
  81,
  83,
  206,
  245,
  221,
  234,
  221,
  201,
  27,
  133,
  246,
  186,
  173,
  155,
  255,
  153,
  86,
  104,
  61,
  238,
  102,
  114,
  222,
  223,
  3,
  246,
  85,
  39,
  155,
  28,
  219,
  232,
  49,
  196,
  219,
  12,
  158,
  242,
  108,
  211,
  103,
  183,
  2,
  253,
  202,
  182,
  177,
  165,
  59,
  253,
  174,
  249,
  182,
  202,
  235,
  158,
  227,
  201,
  127,
  104,
  252,
  17,
  232,
  83,
  177,
  54,
  236,
  140,
  148,
  25,
  155,
  82,
  49,
  15,
  242,
  238,
  144,
  64,
  102,
  170,
  199,
  93,
  70,
  42,
  119,
  49,
  220,
  41,
  112,
  192,
  72,
  253,
  246,
  46,
  218,
  61,
  253,
  70,
  64,
  23,
  78,
  229,
  62,
  132,
  233,
  225,
  112,
  184,
  75,
  71,
  102,
  167,
  95,
  6,
  191,
  19,
  60,
  116,
  117,
  34,
  139,
  123,
  90,
  132,
  30,
  232,
  122,
  239,
  204,
  204,
  122,
  212,
  201,
  127,
  206,
  200,
  204,
  240,
  111,
  20,
  104,
  207,
  111,
  49,
  157,
  173,
  73,
  212,
  143,
  14,
  115,
  144,
  217,
  54,
  174,
  175,
  69,
  30,
  151,
  143,
  84,
  223,
  145,
  252,
  144,
  185,
  235,
  71,
  170,
  176,
  13,
  35,
  254,
  243,
  248,
  245,
  72,
  115,
  11,
  184,
  19,
  252,
  86,
  72,
  255,
  7,
  156,
  63,
  12,
  30,
  7,
  79,
  10,
  254,
  207,
  225,
  252,
  69,
  240,
  58,
  248,
  23,
  120,
  135,
  133,
  13,
  226,
  222,
  191,
  51,
  58,
  29,
  111,
  28,
  231,
  243,
  217,
  245,
  66,
  184,
  123,
  142,
  206,
  94,
  55,
  236,
  47,
  236,
  23,
  156,
  202,
  210,
  125,
  136,
  249,
  125,
  148,
  185,
  71,
  194,
  125,
  77,
  40,
  255,
  152,
  209,
  106,
  159,
  129,
  158,
  159,
  196,
  220,
  83,
  225,
  158,
  33,
  229,
  191,
  255,
  232,
  204,
  122,
  158,
  141,
  235,
  115,
  13,
  251,
  19,
  180,
  63,
  174,
  26,
  245,
  215,
  223,
  123,
  137,
  213,
  84,
  183,
  131,
  225,
  115,
  87,
  47,
  141,
  177,
  161,
  108,
  24,
  104,
  252,
  159,
  9,
  66,
  172,
  140,
  129,
  37,
  96,
  17,
  99,
  15,
  135,
  52,
  174,
  236,
  13,
  112,
  187,
  65,
  32,
  22,
  193,
  208,
  75,
  90,
  228,
  221,
  199,
  103,
  239,
  158,
  83,
  63,
  122,
  108,
  39,
  132,
  161,
  9,
  201,
  60,
  230,
  210,
  45,
  185,
  142,
  35,
  195,
  140,
  174,
  64,
  83,
  186,
  206,
  13,
  97,
  117,
  216,
  174,
  96,
  153,
  114,
  249,
  180,
  45,
  27,
  236,
  122,
  130,
  244,
  143,
  169,
  109,
  28,
  85,
  159,
  220,
  83,
  227,
  159,
  131,
  65,
  214,
  14,
  180,
  207,
  183,
  4,
  168,
  125,
  238,
  206,
  224,
  231,
  124,
  140,
  24,
  35,
  211,
  54,
  205,
  211,
  241,
  184,
  227,
  82,
  90,
  145,
  1,
  233,
  154,
  144,
  188,
  253,
  109,
  247,
  204,
  249,
  247,
  122,
  249,
  189,
  6,
  183,
  15,
  209,
  6,
  248,
  181,
  171,
  206,
  100,
  155,
  18,
  211,
  140,
  91,
  210,
  150,
  160,
  84,
  191,
  221,
  26,
  24,
  12,
  76,
  163,
  35,
  68,
  134,
  208,
  118,
  148,
  215,
  42,
  182,
  182,
  173,
  219,
  238,
  114,
  66,
  117,
  65,
  199,
  124,
  62,
  103,
  113,
  255,
  22,
  209,
  207,
  97,
  189,
  206,
  152,
  208,
  110,
  19,
  138,
  243,
  38,
  115,
  109,
  243,
  247,
  72,
  15,
  193,
  219,
  197,
  103,
  253,
  161,
  91,
  175,
  139,
  237,
  223,
  22,
  144,
  215,
  241,
  62,
  58,
  111,
  10,
  46,
  167,
  110,
  219,
  206,
  61,
  118,
  187,
  222,
  31,
  181,
  53,
  186,
  207,
  61,
  182,
  52,
  137,
  189,
  238,
  29,
  75,
  28,
  89,
  127,
  170,
  184,
  60,
  142,
  171,
  62,
  82,
  183,
  235,
  123,
  193,
  166,
  228,
  241,
  247,
  189,
  132,
  143,
  30,
  186,
  196,
  111,
  140,
  115,
  25,
  239,
  114,
  218,
  95,
  78,
  157,
  200,
  105,
  232,
  216,
  204,
  251,
  180,
  120,
  143,
  41,
  222,
  215,
  149,
  144,
  85,
  39,
  191,
  236,
  175,
  139,
  87,
  210,
  214,
  115,
  149,
  43,
  218,
  155,
  207,
  253,
  191,
  169,
  125,
  83,
  244,
  159,
  208,
  121,
  44,
  119,
  25,
  49,
  245,
  207,
  105,
  19,
  41,
  245,
  107,
  203,
  203,
  87,
  190,
  49,
  70,
  201,
  113,
  77,
  238,
  47,
  117,
  180,
  143,
  216,
  127,
  82,
  180,
  143,
  152,
  167,
  169,
  175,
  202,
  126,
  54,
  29,
  133,
  206,
  59,
  124,
  189,
  173,
  202,
  155,
  251,
  183,
  20,
  229,
  169,
  198,
  209,
  186,
  219,
  39,
  5,
  166,
  118,
  177,
  201,
  16,
  179,
  14,
  80,
  245,
  75,
  87,
  123,
  81,
  233,
  160,
  116,
  123,
  196,
  234,
  59,
  181,
  28,
  33,
  253,
  161,
  69,
  236,
  237,
  95,
  106,
  62,
  42,
  213,
  255,
  67,
  108,
  90,
  182,
  185,
  58,
  250,
  189,
  78,
  206,
  84,
  122,
  55,
  233,
  192,
  54,
  78,
  228,
  186,
  15,
  224,
  227,
  176,
  235,
  250,
  110,
  107,
  232,
  255,
  174,
  109,
  146,
  187,
  255,
  155,
  218,
  208,
  117,
  191,
  95,
  148,
  185,
  244,
  51,
  130,
  146,
  99,
  145,
  105,
  76,
  138,
  209,
  127,
  76,
  93,
  234,
  208,
  117,
  10,
  189,
  187,
  150,
  151,
  219,
  254,
  93,
  242,
  214,
  173,
  19,
  101,
  82,
  142,
  199,
  190,
  54,
  233,
  219,
  223,
  197,
  118,
  112,
  29,
  211,
  57,
  123,
  245,
  8,
  178,
  92,
  173,
  200,
  252,
  186,
  30,
  122,
  228,
  247,
  133,
  189,
  170,
  27,
  174,
  31,
  95,
  187,
  80,
  233,
  100,
  92,
  66,
  244,
  27,
  20,
  206,
  199,
  216,
  117,
  83,
  193,
  32,
  75,
  39,
  63,
  147,
  176,
  141,
  7,
  169,
  239,
  187,
  229,
  231,
  82,
  220,
  165,
  71,
  67,
  112,
  99,
  198,
  215,
  84,
  107,
  179,
  49,
  7,
  255,
  210,
  115,
  162,
  235,
  24,
  197,
  251,
  71,
  236,
  216,
  46,
  218,
  150,
  110,
  109,
  193,
  159,
  95,
  199,
  140,
  139,
  58,
  121,
  99,
  251,
  160,
  107,
  249,
  186,
  244,
  239,
  171,
  153,
  5,
  53,
  179,
  115,
  205,
  228,
  90,
  75,
  153,
  198,
  13,
  121,
  157,
  100,
  234,
  71,
  185,
  169,
  179,
  236,
  210,
  229,
  211,
  163,
  65,
  102,
  142,
  31,
  190,
  178,
  218,
  198,
  189,
  80,
  92,
  215,
  129,
  161,
  178,
  251,
  148,
  175,
  91,
  251,
  228,
  148,
  193,
  167,
  222,
  169,
  203,
  159,
  138,
  40,
  63,
  245,
  154,
  142,
  235,
  126,
  72,
  184,
  230,
  182,
  39,
  174,
  127,
  83,
  237,
  3,
  164,
  106,
  63,
  190,
  14,
  228,
  242,
  143,
  75,
  254,
  178,
  141,
  241,
  247,
  209,
  114,
  200,
  95,
  199,
  189,
  179,
  205,
  174,
  74,
  174,
  205,
  100,
  253,
  136,
  215,
  188,
  61,
  98,
  215,
  45,
  177,
  247,
  114,
  190,
  246,
  107,
  186,
  167,
  203,
  133,
  73,
  191,
  60,
  78,
  93,
  247,
  125,
  220,
  182,
  92,
  245,
  23,
  75,
  234,
  241,
  47,
  246,
  222,
  73,
  164,
  228,
  145,
  67,
  54,
  81,
  159,
  163,
  142,
  240,
  113,
  86,
  60,
  23,
  253,
  92,
  112,
  145,
  223,
  71,
  22,
  213,
  218,
  182,
  14,
  66,
  108,
  136,
  167,
  141,
  221,
  143,
  208,
  29,
  161,
  118,
  227,
  187,
  254,
  201,
  57,
  159,
  200,
  118,
  230,
  243,
  222,
  132,
  78,
  230,
  212,
  251,
  63,
  185,
  112,
  93,
  247,
  219,
  218,
  75,
  182,
  185,
  24,
  91,
  21,
  219,
  220,
  212,
  23,
  84,
  182,
  145,
  178,
  239,
  132,
  126,
  91,
  144,
  2,
  185,
  236,
  58,
  108,
  131,
  175,
  117,
  117,
  125,
  132,
  51,
  40,
  93,
  239,
  192,
  100,
  222,
  85,
  144,
  95,
  142,
  183,
  61,
  153,
  249,
  173,
  206,
  0,
  153,
  254,
  174,
  116,
  64,
  113,
  45,
  198,
  165,
  204,
  21,
  160,
  249,
  241,
  111,
  96,
  117,
  186,
  108,
  91,
  16,
  101,
  160,
  229,
  12,
  49,
  116,
  186,
  25,
  102,
  178,
  53,
  132,
  184,
  166,
  248,
  166,
  254,
  215,
  86,
  232,
  180,
  43,
  93,
  207,
  87,
  164,
  245,
  89,
  103,
  200,
  253,
  216,
  229,
  27,
  52,
  94,
  63,
  241,
  123,
  42,
  249,
  27,
  43,
  151,
  244,
  161,
  247,
  99,
  226,
  248,
  210,
  50,
  208,
  182,
  132,
  251,
  166,
  109,
  43,
  206,
  99,
  202,
  104,
  121,
  180,
  147,
  235,
  156,
  21,
  179,
  159,
  192,
  237,
  93,
  110,
  195,
  54,
  113,
  107,
  23,
  49,
  157,
  207,
  187,
  195,
  174,
  118,
  147,
  227,
  251,
  72,
  83,
  217,
  170,
  239,
  12,
  85,
  223,
  169,
  154,
  208,
  149,
  231,
  155,
  206,
  85,
  47,
  114,
  251,
  230,
  40,
  207,
  71,
  166,
  208,
  186,
  168,
  228,
  146,
  253,
  84,
  225,
  220,
  149,
  191,
  75,
  182,
  181,
  173,
  74,
  23,
  114,
  29,
  76,
  186,
  51,
  217,
  144,
  139,
  61,
  132,
  180,
  181,
  173,
  220,
  20,
  253,
  193,
  164,
  27,
  211,
  117,
  10,
  251,
  73,
  149,
  191,
  171,
  206,
  98,
  117,
  23,
  43,
  151,
  47,
  115,
  19,
  200,
  64,
  15,
  241,
  57,
  113,
  168,
  172,
  252,
  222,
  216,
  167,
  204,
  28,
  58,
  149,
  239,
  213,
  99,
  242,
  138,
  153,
  87,
  117,
  248,
  206,
  31,
  57,
  233,
  6,
  166,
  145,
  237,
  34,
  135,
  92,
  62,
  125,
  40,
  69,
  89,
  161,
  50,
  184,
  234,
  210,
  39,
  31,
  213,
  181,
  171,
  191,
  156,
  71,
  108,
  253,
  92,
  245,
  238,
  154,
  38,
  71,
  255,
  54,
  213,
  219,
  166,
  55,
  158,
  15,
  15,
  31,
  85,
  148,
  51,
  73,
  210,
  140,
  39,
  33,
  117,
  212,
  233,
  48,
  133,
  46,
  99,
  218,
  93,
  101,
  115,
  92,
  127,
  170,
  56,
  41,
  100,
  46,
  165,
  127,
  91,
  189,
  75,
  227,
  186,
  191,
  45,
  219,
  178,
  201,
  166,
  119,
  215,
  196,
  87,
  245,
  7,
  57,
  76,
  236,
  119,
  58,
  61,
  169,
  228,
  80,
  229,
  163,
  146,
  103,
  210,
  80,
  174,
  10,
  149,
  174,
  38,
  37,
  74,
  217,
  136,
  120,
  61,
  160,
  129,
  134,
  241,
  231,
  146,
  178,
  252,
  244,
  104,
  4,
  184,
  57,
  230,
  225,
  80,
  123,
  231,
  50,
  149,
  236,
  35,
  174,
  122,
  170,
  163,
  76,
  95,
  183,
  78,
  189,
  149,
  44,
  187,
  148,
  173,
  164,
  178,
  107,
  25,
  211,
  62,
  170,
  252,
  14,
  130,
  188,
  135,
  219,
  36,
  110,
  207,
  87,
  108,
  184,
  190,
  183,
  164,
  123,
  54,
  163,
  27,
  163,
  108,
  152,
  246,
  253,
  197,
  125,
  106,
  34,
  213,
  83,
  28,
  3,
  197,
  107,
  122,
  152,
  250,
  132,
  156,
  63,
  127,
  199,
  70,
  181,
  47,
  174,
  210,
  211,
  246,
  12,
  221,
  94,
  58,
  81,
  148,
  161,
  171,
  147,
  174,
  44,
  62,
  166,
  187,
  212,
  197,
  247,
  249,
  119,
  46,
  248,
  239,
  75,
  54,
  4,
  191,
  33,
  225,
  220,
  86,
  23,
  34,
  165,
  181,
  197,
  27,
  18,
  206,
  197,
  116,
  161,
  207,
  238,
  117,
  113,
  85,
  254,
  252,
  89,
  140,
  232,
  71,
  219,
  96,
  49,
  59,
  183,
  185,
  185,
  41,
  85,
  142,
  173,
  124,
  151,
  122,
  219,
  194,
  22,
  147,
  217,
  207,
  128,
  135,
  36,
  120,
  155,
  244,
  154,
  254,
  83,
  213,
  95,
  101,
  127,
  139,
  137,
  218,
  14,
  99,
  100,
  142,
  193,
  150,
  191,
  109,
  125,
  152,
  163,
  29,
  66,
  117,
  227,
  251,
  188,
  43,
  102,
  206,
  77,
  53,
  127,
  235,
  214,
  19,
  190,
  239,
  75,
  164,
  150,
  65,
  156,
  227,
  68,
  92,
  245,
  43,
  203,
  228,
  251,
  30,
  71,
  14,
  125,
  234,
  100,
  240,
  177,
  15,
  215,
  103,
  161,
  161,
  240,
  239,
  131,
  248,
  90,
  194,
  231,
  253,
  26,
  159,
  103,
  194,
  49,
  239,
  51,
  185,
  148,
  239,
  139,
  143,
  126,
  92,
  236,
  199,
  86,
  94,
  142,
  239,
  26,
  114,
  63,
  187,
  167,
  101,
  212,
  241,
  205,
  148,
  169,
  189,
  235,
  60,
  66,
  244,
  77,
  15,
  221,
  252,
  97,
  122,
  167,
  116,
  74,
  227,
  239,
  75,
  157,
  223,
  223,
  77,
  101,
  212,
  171,
  171,
  45,
  139,
  58,
  158,
  32,
  246,
  123,
  46,
  57,
  239,
  16,
  157,
  135,
  126,
  199,
  228,
  58,
  110,
  248,
  212,
  223,
  119,
  140,
  146,
  243,
  142,
  29,
  175,
  119,
  4,
  59,
  21,
  164,
  116,
  121,
  190,
  123,
  32,
  41,
  191,
  237,
  148,
  243,
  174,
  227,
  251,
  78,
  89,
  134,
  247,
  215,
  76,
  206,
  181,
  82,
  87,
  211,
  166,
  244,
  183,
  141,
  39,
  136,
  223,
  239,
  32,
  231,
  254,
  141,
  229,
  210,
  240,
  61,
  151,
  210,
  229,
  202,
  235,
  227,
  216,
  117,
  225,
  48,
  153,
  222,
  43,
  226,
  191,
  37,
  45,
  239,
  179,
  209,
  247,
  96,
  114,
  173,
  79,
  85,
  243,
  9,
  47,
  215,
  213,
  149,
  211,
  153,
  230,
  170,
  134,
  224,
  82,
  249,
  249,
  94,
  129,
  248,
  188,
  200,
  86,
  142,
  13,
  254,
  222,
  170,
  234,
  158,
  185,
  14,
  91,
  229,
  101,
  207,
  103,
  46,
  175,
  167,
  44,
  171,
  74,
  135,
  13,
  201,
  245,
  217,
  99,
  144,
  247,
  25,
  154,
  158,
  121,
  196,
  66,
  2,
  101,
  207,
  85,
  62,
  215,
  109,
  67,
  58,
  231,
  122,
  74,
  181,
  167,
  84,
  130,
  148,
  123,
  108,
  190,
  136,
  253,
  137,
  218,
  110,
  75,
  10,
  231,
  239,
  166,
  218,
  250,
  155,
  235,
  26,
  70,
  28,
  175,
  118,
  35,
  213,
  190,
  92,
  29,
  253,
  217,
  182,
  222,
  239,
  133,
  177,
  134,
  207,
  73,
  41,
  101,
  240,
  93,
  115,
  202,
  109,
  87,
  151,
  30,
  100,
  157,
  184,
  220,
  207,
  213,
  37,
  31,
  183,
  165,
  58,
  202,
  157,
  146,
  202,
  143,
  89,
  79,
  228,
  182,
  55,
  151,
  103,
  152,
  174,
  182,
  224,
  210,
  246,
  186,
  114,
  76,
  107,
  178,
  18,
  246,
  228,
  170,
  19,
  91,
  63,
  176,
  201,
  95,
  234,
  247,
  40,
  196,
  113,
  126,
  76,
  145,
  62,
  102,
  12,
  138,
  197,
  197,
  190,
  75,
  247,
  145,
  28,
  121,
  166,
  236,
  167,
  42,
  221,
  213,
  113,
  152,
  246,
  73,
  117,
  123,
  161,
  185,
  214,
  162,
  174,
  242,
  202,
  178,
  211,
  195,
  69,
  215,
  252,
  55,
  251,
  82,
  218,
  149,
  139,
  29,
  119,
  200,
  236,
  113,
  199,
  117,
  191,
  144,
  143,
  49,
  165,
  214,
  43,
  57,
  199,
  179,
  208,
  57,
  211,
  71,
  46,
  213,
  248,
  94,
  215,
  24,
  192,
  203,
  20,
  191,
  151,
  118,
  25,
  15,
  228,
  124,
  228,
  247,
  143,
  84,
  118,
  198,
  207,
  125,
  126,
  95,
  96,
  92,
  202,
  63,
  100,
  125,
  229,
  219,
  150,
  186,
  247,
  181,
  38,
  164,
  60,
  235,
  154,
  203,
  92,
  234,
  108,
  122,
  14,
  94,
  114,
  124,
  201,
  209,
  127,
  85,
  101,
  212,
  113,
  136,
  178,
  168,
  108,
  222,
  7,
  158,
  223,
  148,
  116,
  174,
  170,
  187,
  202,
  159,
  191,
  31,
  40,
  30,
  49,
  242,
  184,
  180,
  163,
  107,
  251,
  152,
  214,
  56,
  170,
  177,
  208,
  119,
  28,
  229,
  54,
  45,
  143,
  51,
  186,
  50,
  93,
  230,
  178,
  88,
  251,
  228,
  191,
  159,
  202,
  223,
  195,
  145,
  127,
  131,
  215,
  118,
  15,
  20,
  114,
  63,
  32,
  150,
  47,
  199,
  245,
  105,
  191,
  216,
  250,
  203,
  191,
  93,
  236,
  66,
  233,
  241,
  49,
  102,
  190,
  183,
  233,
  52,
  86,
  127,
  177,
  196,
  254,
  14,
  156,
  239,
  243,
  123,
  209,
  54,
  67,
  127,
  115,
  174,
  174,
  246,
  143,
  89,
  243,
  233,
  214,
  107,
  177,
  71,
  204,
  28,
  66,
  132,
  115,
  121,
  61,
  227,
  242,
  110,
  28,
  37,
  100,
  15,
  57,
  70,
  255,
  169,
  219,
  132,
  183,
  203,
  184,
  144,
  87,
  9,
  187,
  19,
  235,
  31,
  99,
  63,
  41,
  177,
  149,
  45,
  251,
  169,
  214,
  219,
  99,
  158,
  186,
  244,
  109,
  191,
  82,
  54,
  33,
  207,
  161,
  226,
  252,
  227,
  211,
  63,
  114,
  216,
  187,
  13,
  83,
  249,
  117,
  204,
  177,
  114,
  253,
  67,
  222,
  195,
  245,
  157,
  111,
  82,
  233,
  143,
  191,
  187,
  154,
  186,
  109,
  98,
  237,
  211,
  5,
  23,
  125,
  218,
  250,
  123,
  170,
  246,
  136,
  237,
  15,
  49,
  99,
  187,
  73,
  254,
  84,
  135,
  234,
  158,
  206,
  197,
  182,
  197,
  249,
  120,
  130,
  148,
  63,
  196,
  242,
  67,
  246,
  71,
  93,
  143,
  148,
  227,
  71,
  105,
  218,
  100,
  246,
  111,
  232,
  229,
  28,
  163,
  117,
  196,
  62,
  47,
  228,
  121,
  132,
  142,
  189,
  37,
  244,
  47,
  30,
  13,
  1,
  57,
  158,
  236,
  199,
  227,
  19,
  77,
  252,
  220,
  50,
  235,
  228,
  244,
  205,
  103,
  208,
  0,
  47,
  71,
  229,
  199,
  93,
  211,
  26,
  41,
  247,
  92,
  18,
  99,
  31,
  169,
  218,
  45,
  116,
  62,
  10,
  221,
  47,
  54,
  245,
  53,
  221,
  252,
  234,
  211,
  231,
  98,
  229,
  240,
  89,
  227,
  170,
  224,
  97,
  169,
  215,
  103,
  37,
  198,
  146,
  216,
  54,
  85,
  205,
  213,
  177,
  253,
  40,
  197,
  189,
  141,
  136,
  252,
  13,
  170,
  238,
  127,
  150,
  108,
  235,
  143,
  94,
  155,
  143,
  93,
  203,
  143,
  217,
  123,
  168,
  123,
  61,
  34,
  203,
  31,
  35,
  71,
  236,
  119,
  179,
  169,
  72,
  209,
  94,
  185,
  222,
  93,
  44,
  49,
  230,
  152,
  198,
  96,
  219,
  115,
  159,
  82,
  253,
  205,
  54,
  246,
  228,
  30,
  223,
  82,
  143,
  129,
  190,
  117,
  46,
  217,
  246,
  190,
  243,
  98,
  110,
  114,
  181,
  173,
  74,
  175,
  185,
  230,
  65,
  159,
  54,
  20,
  227,
  170,
  158,
  141,
  197,
  140,
  185,
  41,
  116,
  22,
  59,
  255,
  196,
  150,
  149,
  218,
  206,
  83,
  146,
  66,
  63,
  177,
  117,
  9,
  181,
  83,
  223,
  126,
  159,
  123,
  158,
  74,
  161,
  203,
  16,
  185,
  100,
  157,
  197,
  236,
  23,
  250,
  252,
  6,
  123,
  142,
  242,
  83,
  180,
  75,
  234,
  249,
  223,
  102,
  159,
  114,
  250,
  208,
  250,
  243,
  163,
  14,
  27,
  18,
  105,
  91,
  174,
  125,
  9,
  249,
  13,
  65,
  113,
  125,
  153,
  250,
  119,
  9,
  83,
  231,
  215,
  205,
  32,
  111,
  142,
  117,
  250,
  46,
  133,
  80,
  149,
  61,
  169,
  241,
  79,
  129,
  170,
  13,
  74,
  150,
  161,
  243,
  23,
  127,
  75,
  84,
  165,
  7,
  85,
  120,
  105,
  22,
  42,
  144,
  229,
  83,
  201,
  107,
  35,
  133,
  108,
  62,
  229,
  249,
  200,
  163,
  146,
  79,
  142,
  235,
  90,
  151,
  73,
  67,
  158,
  62,
  182,
  165,
  114,
  117,
  101,
  233,
  210,
  134,
  246,
  1,
  211,
  216,
  29,
  219,
  134,
  174,
  115,
  68,
  206,
  188,
  115,
  213,
  205,
  102,
  183,
  46,
  237,
  23,
  154,
  191,
  107,
  153,
  41,
  40,
  173,
  199,
  144,
  114,
  76,
  125,
  189,
  212,
  239,
  58,
  139,
  191,
  117,
  106,
  250,
  31,
  175,
  212,
  54,
  225,
  59,
  238,
  250,
  150,
  153,
  218,
  174,
  82,
  235,
  61,
  119,
  249,
  169,
  229,
  79,
  37,
  95,
  174,
  254,
  26,
  91,
  63,
  221,
  122,
  199,
  197,
  126,
  125,
  214,
  18,
  62,
  246,
  238,
  179,
  70,
  40,
  185,
  46,
  203,
  85,
  134,
  106,
  45,
  19,
  83,
  158,
  105,
  125,
  20,
  179,
  38,
  172,
  99,
  13,
  28,
  187,
  126,
  141,
  189,
  55,
  143,
  221,
  31,
  41,
  165,
  39,
  215,
  122,
  255,
  15
]);

// ../packages/engine-render/src/components/docs/layout/line-breaker/swap.ts
var isBigEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
var swap = (b, n, m) => {
  const i = b[n];
  b[n] = b[m];
  b[m] = i;
};
var swap32 = (array) => {
  const len = array.length;
  for (let i = 0; i < len; i += 4) {
    swap(array, i, i + 3);
    swap(array, i + 1, i + 2);
  }
};
var swap32LE = (array) => {
  if (isBigEndian) {
    swap32(array);
  }
};

// ../packages/engine-render/src/components/docs/layout/line-breaker/tiny-inflate.ts
var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
var Tree = class {
  constructor() {
    __publicField(this, "table", new Uint16Array(16));
    /* table of code length counts */
    __publicField(this, "trans", new Uint16Array(288));
  }
  /* code -> symbol translation table */
};
var Data = class {
  constructor(source, dest) {
    __publicField(this, "source");
    __publicField(this, "dest");
    __publicField(this, "sourceIndex");
    __publicField(this, "tag");
    __publicField(this, "bitcount");
    __publicField(this, "destLen");
    __publicField(this, "ltree");
    __publicField(this, "dtree");
    this.source = source;
    this.sourceIndex = 0;
    this.tag = 0;
    this.bitcount = 0;
    this.dest = dest;
    this.destLen = 0;
    this.ltree = new Tree();
    this.dtree = new Tree();
  }
};
var sltree = new Tree();
var sdtree = new Tree();
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);
var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);
function tinf_build_bits_base(bits, base, delta, first2) {
  let i;
  let sum;
  for (i = 0; i < delta; ++i) bits[i] = 0;
  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;
  for (sum = first2, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}
function tinf_build_fixed_trees(lt, dt) {
  let i;
  for (i = 0; i < 7; ++i) lt.table[i] = 0;
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;
  for (i = 0; i < 5; ++i) dt.table[i] = 0;
  dt.table[5] = 32;
  for (i = 0; i < 32; ++i) dt.trans[i] = i;
}
var offs = new Uint16Array(16);
function tinf_build_tree(t2, lengths3, off, num) {
  let i;
  let sum;
  for (i = 0; i < 16; ++i) t2.table[i] = 0;
  for (i = 0; i < num; ++i) t2.table[lengths3[off + i]]++;
  t2.table[0] = 0;
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t2.table[i];
  }
  for (i = 0; i < num; ++i) {
    if (lengths3[off + i]) t2.trans[offs[lengths3[off + i]]++] = i;
  }
}
function tinf_getbit(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  const bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits(d, num, base) {
  if (!num) return base;
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  const val = d.tag & 65535 >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol(d, t2) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  let sum = 0;
  let cur = 0;
  let len = 0;
  let tag = d.tag;
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;
    sum += t2.table[len];
    cur -= t2.table[len];
  } while (cur >= 0);
  d.tag = tag;
  d.bitcount -= len;
  return t2.trans[sum + cur];
}
function tinf_decode_trees(d, lt, dt) {
  let i;
  let num;
  let length;
  const hlit = tinf_read_bits(d, 5, 257);
  const hdist = tinf_read_bits(d, 5, 1);
  const hclen = tinf_read_bits(d, 4, 4);
  for (i = 0; i < 19; ++i) lengths[i] = 0;
  for (i = 0; i < hclen; ++i) {
    const clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }
  tinf_build_tree(code_tree, lengths, 0, 19);
  for (num = 0; num < hlit + hdist; ) {
    const sym = tinf_decode_symbol(d, code_tree);
    switch (sym) {
      case 16: {
        const prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      }
      case 17:
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        lengths[num++] = sym;
        break;
    }
  }
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}
function tinf_inflate_block_data(d, lt, dt) {
  while (true) {
    let sym = tinf_decode_symbol(d, lt);
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      let i;
      sym -= 257;
      const length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
      const dist = tinf_decode_symbol(d, dt);
      const offs3 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
      for (i = offs3; i < offs3 + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}
function tinf_inflate_uncompressed_block(d) {
  let length;
  let invlength;
  let i;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length !== (~invlength & 65535)) return TINF_DATA_ERROR;
  d.sourceIndex += 4;
  for (i = length; i; --i) d.dest[d.destLen++] = d.source[d.sourceIndex++];
  d.bitcount = 0;
  return TINF_OK;
}
function tinf_uncompress(source, dest) {
  const d = new Data(source, dest);
  let bfinal;
  let btype;
  let res;
  do {
    bfinal = tinf_getbit(d);
    btype = tinf_read_bits(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK) throw new Error("Data error");
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === "function") return d.dest.slice(0, d.destLen);
    return d.dest.subarray(0, d.destLen);
  }
  return d.dest;
}
tinf_build_fixed_trees(sltree, sdtree);
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);
length_bits[28] = 0;
length_base[28] = 258;

// ../packages/engine-render/src/components/docs/layout/line-breaker/unicode-trie.ts
var SHIFT_1 = 6 + 5;
var SHIFT_2 = 5;
var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
var INDEX_SHIFT = 2;
var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
var DATA_MASK = DATA_BLOCK_LENGTH - 1;
var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
var DATA_GRANULARITY = 1 << INDEX_SHIFT;
var UnicodeTrie = class {
  constructor(data2) {
    __publicField(this, "highStart");
    __publicField(this, "errorValue");
    __publicField(this, "data");
    const isBuffer = typeof data2.readUInt32BE === "function" && typeof data2.slice === "function";
    if (isBuffer || data2 instanceof Uint8Array) {
      let uncompressedLength;
      if (isBuffer) {
        this.highStart = data2.readUInt32LE(0);
        this.errorValue = data2.readUInt32LE(4);
        uncompressedLength = data2.readUInt32LE(8);
        data2 = data2.slice(12);
      } else {
        const view = new DataView(data2.buffer);
        this.highStart = view.getUint32(0, true);
        this.errorValue = view.getUint32(4, true);
        uncompressedLength = view.getUint32(8, true);
        data2 = data2.subarray(12);
      }
      data2 = tinf_uncompress(data2, new Uint8Array(uncompressedLength));
      data2 = tinf_uncompress(data2, new Uint8Array(uncompressedLength));
      swap32LE(data2);
      this.data = new Uint32Array(data2.buffer);
    } else {
      ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data2);
    }
  }
  get(codePoint) {
    let index;
    if (codePoint < 0 || codePoint > 1114111) {
      return this.errorValue;
    }
    if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint <= 65535) {
      index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint < this.highStart) {
      index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
      index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    return this.data[this.data.length - DATA_GRANULARITY];
  }
};

// ../packages/engine-render/src/components/docs/layout/line-breaker/line-breaker.ts
var classTrie = new UnicodeTrie(trie_data_default);
function mapClass(c) {
  switch (c) {
    case AI:
      return AL;
    case SA:
    case SG:
    case XX:
      return AL;
    case CJ:
      return NS;
    default:
      return c;
  }
}
function mapFirst(c) {
  switch (c) {
    case LF:
    case NL:
      return BK;
    case SP:
      return WJ;
    default:
      return c;
  }
}
var LineBreaker = class {
  constructor(content) {
    this.content = content;
    __publicField(this, "_pos", 0);
    __publicField(this, "_lastPos", 0);
    __publicField(this, "_curClass", null);
    __publicField(this, "_codePoint", null);
    __publicField(this, "_lastCodePoint", null);
    __publicField(this, "_nextClass", null);
    __publicField(this, "_LB8a", false);
    __publicField(this, "_LB21a", false);
    __publicField(this, "_LB30a", 0);
    __publicField(this, "_rule", new Rule());
  }
  use(extension) {
    extension(this);
    return this;
  }
  addRule(key, rule) {
    this._rule.add(key, rule);
    return this;
  }
  nextBreakPoint() {
    if (this._curClass == null) {
      const firstClass = this._nextCharClass();
      this._curClass = mapFirst(firstClass);
      this._nextClass = firstClass;
      this._LB8a = firstClass === ZWJ;
      this._LB30a = 0;
    }
    while (this._pos < this.content.length) {
      this._lastPos = this._pos;
      const lastClass = this._nextClass;
      this._nextClass = this._nextCharClass();
      if (this._curClass === BK || this._curClass === CR && this._nextClass !== LF) {
        this._curClass = mapFirst(mapClass(this._nextClass));
        return new Break(this._lastPos, "Mandatory" /* Mandatory */);
      }
      if (this._rule.shouldBreak(this._codePoint, this._lastCodePoint, this._nextClass)) {
        this._curClass = mapFirst(mapClass(this._nextClass));
        return new Break(this._lastPos);
      }
      let shouldBreak = this._getSimpleBreak();
      if (shouldBreak === null) {
        shouldBreak = this._getPairTableBreak(lastClass);
      }
      this._LB8a = this._nextClass === ZWJ;
      if (shouldBreak) {
        return new Break(this._lastPos);
      }
    }
    if (this._lastPos < this.content.length) {
      this._lastPos = this.content.length;
      return new Break(this.content.length);
    }
    return null;
  }
  _getNextCodePoint() {
    const code = this.content.charCodeAt(this._pos++);
    const next = this.content.charCodeAt(this._pos);
    if (code >= 55296 && code <= 56319 && next >= 56320 && next <= 57343) {
      this._pos++;
      return (code - 55296) * 1024 + (next - 56320) + 65536;
    }
    return code;
  }
  _nextCharClass() {
    const nextCodePoint = this._getNextCodePoint();
    const rawClass = classTrie.get(nextCodePoint);
    this._lastCodePoint = this._codePoint;
    this._codePoint = nextCodePoint;
    return mapClass(rawClass);
  }
  _getSimpleBreak() {
    switch (this._nextClass) {
      case SP:
        return false;
      case BK:
      case LF:
      case NL:
        this._curClass = BK;
        return false;
      case CR:
        this._curClass = CR;
        return false;
    }
    return null;
  }
  _getPairTableBreak(lastClass) {
    let shouldBreak = false;
    switch (pairTable[this._curClass][this._nextClass]) {
      case DI_BRK:
        shouldBreak = true;
        break;
      case IN_BRK:
        shouldBreak = lastClass === SP;
        break;
      case CI_BRK:
        shouldBreak = lastClass === SP;
        if (!shouldBreak) {
          shouldBreak = false;
          return shouldBreak;
        }
        break;
      case CP_BRK:
        if (lastClass !== SP) {
          return shouldBreak;
        }
        break;
      case PR_BRK:
        break;
    }
    if (this._LB8a) {
      shouldBreak = false;
    }
    if (this._LB21a && (this._curClass === HY || this._curClass === BA)) {
      shouldBreak = false;
      this._LB21a = false;
    } else {
      this._LB21a = this._curClass === HL;
    }
    if (this._curClass === RI) {
      this._LB30a++;
      if (this._LB30a === 2 && this._nextClass === RI) {
        shouldBreak = true;
        this._LB30a = 0;
      }
    } else {
      this._LB30a = 0;
    }
    this._curClass = this._nextClass;
    return shouldBreak;
  }
};

// ../packages/engine-render/src/components/docs/layout/line-breaker/enhancers/hyphen-enhancer.ts
function isUpperCase(word) {
  return word.length > 0 && word === word.toUpperCase();
}
var LineBreakerHyphenEnhancer = class {
  constructor(_lineBreaker, _hyphen, _lang, _doNotHyphenateCaps = false) {
    this._lineBreaker = _lineBreaker;
    this._hyphen = _hyphen;
    this._lang = _lang;
    this._doNotHyphenateCaps = _doNotHyphenateCaps;
    __publicField(this, "_curBreak", null);
    __publicField(this, "_nextBreak", new Break(0));
    __publicField(this, "_isInWord", false);
    __publicField(this, "_word", "");
    __publicField(this, "_hyphenIndex", -1);
    __publicField(this, "_hyphenSlice", []);
    __publicField(this, "content", "");
    this.content = _lineBreaker.content;
  }
  nextBreakPoint() {
    if (!this._isInWord) {
      this._curBreak = this._nextBreak;
      this._nextBreak = this._lineBreaker.nextBreakPoint();
      if (this._nextBreak == null || this._curBreak == null) {
        return null;
      }
      const word = getWord(this.content.slice(this._curBreak.position, this._nextBreak.position));
      if (word.length && !(isUpperCase(word) && this._doNotHyphenateCaps) && this._nextBreak.type !== "Link" /* Link */) {
        this._isInWord = true;
        this._word = word;
        this._hyphenSlice = this._hyphen.hyphenate(this._word, this._lang);
        this._hyphenIndex = 0;
        return this.nextBreakPoint();
      } else {
        return this._nextBreak;
      }
    } else {
      if (this._hyphenIndex < this._hyphenSlice.length - 1) {
        const position = getSlicePosition(this._curBreak.position, this._hyphenSlice, this._hyphenIndex);
        this._hyphenIndex++;
        return new Break(position, "Hyphen" /* Hyphen */);
      } else {
        this._isInWord = false;
        this._word = "";
        this._hyphenSlice = [];
        this._hyphenIndex = -1;
        return this._nextBreak;
      }
    }
  }
};

// ../packages/engine-render/src/components/docs/layout/line-breaker/enhancers/link-enhancer.ts
function ofLinkCharType(char) {
  if (/[a-z]/i.test(char)) {
    return "Alphabetic" /* Alphabetic */;
  } else if (/[0-9]/.test(char)) {
    return "Digit" /* Digit */;
  } else if (char === "(" || char === "[") {
    return "Open" /* Open */;
  } else {
    return "Other" /* Other */;
  }
}
function linebreakLink(link) {
  const pieces = [];
  let offset = 0;
  let prevCharType = "Other" /* Other */;
  for (let i = 0; i < link.length; i++) {
    const char = link[i];
    const charType = ofLinkCharType(char);
    if (i > 0 && prevCharType !== "Open" /* Open */ && (charType === "Other" /* Other */ ? charType === "Other" /* Other */ : charType !== prevCharType)) {
      const piece = link.slice(offset, i);
      if (piece.length < 16) {
        pieces.push(piece);
      } else {
        for (let j = 0; j < piece.length; j++) {
          pieces.push(piece[j]);
        }
      }
      offset = i;
      prevCharType = charType;
    }
  }
  return pieces;
}
var LINK_CHAR_REG_EXP = /[a-z\d!#$%&*+,-./:;=?@_~\\]/i;
var LINK_CHAR_NO_TRAILING_REG_EXP = /[!,.;:?']$/g;
function extractLink(content, offset) {
  let link = "";
  for (let i = offset; i < content.length; i++) {
    const char = content[i];
    if (LINK_CHAR_REG_EXP.test(char)) {
      link += char;
    } else {
      break;
    }
  }
  link.replace(LINK_CHAR_NO_TRAILING_REG_EXP, "");
  return link;
}
var LineBreakerLinkEnhancer = class {
  constructor(_lineBreaker) {
    this._lineBreaker = _lineBreaker;
    __publicField(this, "_curBreak", null);
    __publicField(this, "_nextBreak", new Break(0));
    __publicField(this, "_isInLink", false);
    __publicField(this, "_link", "");
    __publicField(this, "_index", -1);
    __publicField(this, "_linkSlice", []);
    __publicField(this, "content", "");
    this.content = _lineBreaker.content;
  }
  nextBreakPoint() {
    if (!this._isInLink) {
      this._curBreak = this._nextBreak;
      this._nextBreak = this._lineBreaker.nextBreakPoint();
      if (this._nextBreak == null || this._curBreak == null) {
        return null;
      }
      const word = this.content.slice(this._curBreak.position, this._nextBreak.position);
      if (word.length && (word.endsWith("://") || word.startsWith("www."))) {
        this._isInLink = true;
        this._link = extractLink(this.content, this._curBreak.position);
        this._linkSlice = linebreakLink(this._link);
        this._index = 0;
        while (this._nextBreak && this._nextBreak.position < this._curBreak.position + this._link.length) {
          this._nextBreak = this._lineBreaker.nextBreakPoint();
        }
        return this.nextBreakPoint();
      } else {
        return this._nextBreak;
      }
    } else {
      if (this._index < this._linkSlice.length - 1) {
        const position = getSlicePosition(this._curBreak.position, this._linkSlice, this._index);
        this._index++;
        return new Break(position, "Link" /* Link */);
      } else {
        this._isInLink = false;
        this._link = "";
        this._linkSlice = [];
        this._index = -1;
        return this._nextBreak;
      }
    }
  }
};

// ../packages/engine-render/src/components/docs/layout/line-breaker/extensions/custom-block-linebreak-extension.ts
var SLASH_B_CODE_POINT = 8;
function customBlockLineBreakExtension(breaker) {
  breaker.addRule("break_before_and_after_slash_b", (codePoint, lastCodePoint) => {
    return codePoint === SLASH_B_CODE_POINT || lastCodePoint === SLASH_B_CODE_POINT;
  });
}

// ../packages/engine-render/src/components/docs/layout/line-breaker/extensions/tab-linebreak-extension.ts
var TAB_CODE_POINT = 9;
function tabLineBreakExtension(breaker) {
  breaker.addRule("break_before_tab", (codePoint) => {
    return codePoint === TAB_CODE_POINT;
  });
}

// ../packages/engine-render/src/components/docs/layout/shaping-engine/font-library.ts
function getFontInfoFromFontData(fontData) {
  const { family, style: styleString } = fontData;
  let style = 0 /* Normal */;
  let weight = 400 /* REGULAR */;
  if (/italic/i.test(styleString)) {
    style = 1 /* Italic */;
  }
  switch (true) {
    case /thin|hairline/i.test(styleString): {
      weight = 100 /* THIN */;
      break;
    }
    case /(extra|ultra) *light/i.test(styleString): {
      weight = 200 /* EXTRALIGHT */;
      break;
    }
    case /light/i.test(styleString): {
      weight = 300 /* LIGHT */;
      break;
    }
    case /medium/i.test(styleString): {
      weight = 500 /* MEDIUM */;
      break;
    }
    case /(semi|demi) *bold/i.test(styleString): {
      weight = 600 /* SEMIBOLD */;
      break;
    }
    case /bold/i.test(styleString): {
      weight = 700 /* BOLD */;
      break;
    }
    case /(extra|ultra) *bold/i.test(styleString): {
      weight = 800 /* EXTRABOLD */;
      break;
    }
    case /black|heavy/i.test(styleString): {
      weight = 900 /* BLACK */;
      break;
    }
  }
  return {
    family,
    variant: {
      style,
      weight
    }
  };
}
function getFontInfoFromTextStyle(style) {
  const { ff, bl = 0 /* FALSE */, it = 0 /* FALSE */ } = style;
  return {
    family: ff != null ? ff : "Arial",
    variant: {
      style: it === 1 /* TRUE */ ? 1 /* Italic */ : 0 /* Normal */,
      weight: bl === 1 /* TRUE */ ? 700 /* BOLD */ : 400 /* REGULAR */
    }
  };
}
function fontInfoDistance(a, b) {
  let styleDistance = Number.POSITIVE_INFINITY;
  if (a.variant.style === b.variant.style) {
    styleDistance = 0;
  } else if (a.variant.style !== 0 /* Normal */ && b.variant.style !== 0 /* Normal */) {
    styleDistance = 1;
  } else {
    styleDistance = 2;
  }
  const weightDistance = Math.abs(a.variant.weight - b.variant.weight);
  return [
    styleDistance,
    weightDistance
  ];
}
function compareFontInfoDistance(a, b) {
  if (a[0] === b[0] && a[1] === b[1]) {
    return 0 /* EQUAL */;
  }
  if (a[0] === b[0]) {
    return a[1] > b[1] ? 1 /* GREATER */ : 2 /* LESS */;
  }
  return a[0] > b[0] ? 1 /* GREATER */ : 2 /* LESS */;
}
async function checkLocalFontsPermission() {
  var _a;
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return false;
  }
  if (typeof window === "undefined") {
    return false;
  }
  if (window.navigator == null || ((_a = window.navigator) == null ? void 0 : _a.permissions) == null) {
    return false;
  }
  try {
    const status = await window.navigator.permissions.query({ name: "local-fonts" });
    return status.state === "granted";
  } catch (_err) {
    return false;
  }
}
var FontLibrary = class {
  constructor() {
    __publicField(this, "isReady", false);
    __publicField(this, "_fontBook", /* @__PURE__ */ new Map());
    this._loadFontsToBook();
  }
  async _loadFontsToBook() {
    if (this.isReady) {
      return;
    }
    const permissionStatus = await checkLocalFontsPermission();
    if (!permissionStatus) {
      return;
    }
    if (!("queryLocalFonts" in window)) {
      return;
    }
    try {
      const availableFonts = await window.queryLocalFonts();
      for (const font of availableFonts) {
        const { family, style } = font;
        let fontMap = this._fontBook.get(family);
        if (fontMap == null) {
          fontMap = /* @__PURE__ */ new Map();
          this._fontBook.set(family, fontMap);
        }
        const blob = await font.blob();
        const buffer = await blob.arrayBuffer();
        fontMap.set(style, {
          font,
          buffer
        });
      }
      this.isReady = true;
    } catch (err) {
      console.error(err);
    }
  }
  findBestMatchFontByStyle(style) {
    const ff = style.ff;
    const fontMap = this._fontBook.get(ff);
    if (fontMap == null) {
      return;
    }
    let bestFont = null;
    let bestDistance = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    for (const fontWithBuffer of fontMap.values()) {
      const { font } = fontWithBuffer;
      const currentFontInfo = getFontInfoFromFontData(font);
      const targetFontInfo = getFontInfoFromTextStyle(style);
      const distance = fontInfoDistance(currentFontInfo, targetFontInfo);
      if (bestFont == null) {
        bestFont = fontWithBuffer;
        bestDistance = distance;
      } else {
        const result = compareFontInfoDistance(bestDistance, distance);
        if (result === 1 /* GREATER */) {
          bestFont = fontWithBuffer;
          bestDistance = distance;
        }
      }
    }
    return bestFont;
  }
  getValidFontFamilies(families) {
    return families.filter((family) => this._fontBook.has(family));
  }
};
var fontLibrary = new FontLibrary();

// ../node_modules/.pnpm/opentype.js@1.3.4/node_modules/opentype.js/dist/opentype.module.js
if (!String.prototype.codePointAt) {
  (function() {
    var defineProperty = function() {
      try {
        var object = {};
        var $defineProperty = Object.defineProperty;
        var result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {
      }
      return result;
    }();
    var codePointAt = function(position) {
      if (this == null) {
        throw TypeError();
      }
      var string = String(this);
      var size = string.length;
      var index = position ? Number(position) : 0;
      if (index != index) {
        index = 0;
      }
      if (index < 0 || index >= size) {
        return void 0;
      }
      var first2 = string.charCodeAt(index);
      var second;
      if (
        // check if it’s the start of a surrogate pair
        first2 >= 55296 && first2 <= 56319 && // high surrogate
        size > index + 1
      ) {
        second = string.charCodeAt(index + 1);
        if (second >= 56320 && second <= 57343) {
          return (first2 - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first2;
    };
    if (defineProperty) {
      defineProperty(String.prototype, "codePointAt", {
        "value": codePointAt,
        "configurable": true,
        "writable": true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}
var TINF_OK2 = 0;
var TINF_DATA_ERROR2 = -3;
function Tree2() {
  this.table = new Uint16Array(16);
  this.trans = new Uint16Array(288);
}
function Data2(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree2();
  this.dtree = new Tree2();
}
var sltree2 = new Tree2();
var sdtree2 = new Tree2();
var length_bits2 = new Uint8Array(30);
var length_base2 = new Uint16Array(30);
var dist_bits2 = new Uint8Array(30);
var dist_base2 = new Uint16Array(30);
var clcidx2 = new Uint8Array([
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
]);
var code_tree2 = new Tree2();
var lengths2 = new Uint8Array(288 + 32);
function tinf_build_bits_base2(bits, base, delta, first2) {
  var i, sum;
  for (i = 0; i < delta; ++i) {
    bits[i] = 0;
  }
  for (i = 0; i < 30 - delta; ++i) {
    bits[i + delta] = i / delta | 0;
  }
  for (sum = first2, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}
function tinf_build_fixed_trees2(lt, dt) {
  var i;
  for (i = 0; i < 7; ++i) {
    lt.table[i] = 0;
  }
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i = 0; i < 24; ++i) {
    lt.trans[i] = 256 + i;
  }
  for (i = 0; i < 144; ++i) {
    lt.trans[24 + i] = i;
  }
  for (i = 0; i < 8; ++i) {
    lt.trans[24 + 144 + i] = 280 + i;
  }
  for (i = 0; i < 112; ++i) {
    lt.trans[24 + 144 + 8 + i] = 144 + i;
  }
  for (i = 0; i < 5; ++i) {
    dt.table[i] = 0;
  }
  dt.table[5] = 32;
  for (i = 0; i < 32; ++i) {
    dt.trans[i] = i;
  }
}
var offs2 = new Uint16Array(16);
function tinf_build_tree2(t2, lengths3, off, num) {
  var i, sum;
  for (i = 0; i < 16; ++i) {
    t2.table[i] = 0;
  }
  for (i = 0; i < num; ++i) {
    t2.table[lengths3[off + i]]++;
  }
  t2.table[0] = 0;
  for (sum = 0, i = 0; i < 16; ++i) {
    offs2[i] = sum;
    sum += t2.table[i];
  }
  for (i = 0; i < num; ++i) {
    if (lengths3[off + i]) {
      t2.trans[offs2[lengths3[off + i]]++] = i;
    }
  }
}
function tinf_getbit2(d) {
  if (!d.bitcount--) {
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}
function tinf_read_bits2(d, num, base) {
  if (!num) {
    return base;
  }
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & 65535 >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}
function tinf_decode_symbol2(d, t2) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;
    sum += t2.table[len];
    cur -= t2.table[len];
  } while (cur >= 0);
  d.tag = tag;
  d.bitcount -= len;
  return t2.trans[sum + cur];
}
function tinf_decode_trees2(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;
  hlit = tinf_read_bits2(d, 5, 257);
  hdist = tinf_read_bits2(d, 5, 1);
  hclen = tinf_read_bits2(d, 4, 4);
  for (i = 0; i < 19; ++i) {
    lengths2[i] = 0;
  }
  for (i = 0; i < hclen; ++i) {
    var clen = tinf_read_bits2(d, 3, 0);
    lengths2[clcidx2[i]] = clen;
  }
  tinf_build_tree2(code_tree2, lengths2, 0, 19);
  for (num = 0; num < hlit + hdist; ) {
    var sym = tinf_decode_symbol2(d, code_tree2);
    switch (sym) {
      case 16:
        var prev = lengths2[num - 1];
        for (length = tinf_read_bits2(d, 2, 3); length; --length) {
          lengths2[num++] = prev;
        }
        break;
      case 17:
        for (length = tinf_read_bits2(d, 3, 3); length; --length) {
          lengths2[num++] = 0;
        }
        break;
      case 18:
        for (length = tinf_read_bits2(d, 7, 11); length; --length) {
          lengths2[num++] = 0;
        }
        break;
      default:
        lengths2[num++] = sym;
        break;
    }
  }
  tinf_build_tree2(lt, lengths2, 0, hlit);
  tinf_build_tree2(dt, lengths2, hlit, hdist);
}
function tinf_inflate_block_data2(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol2(d, lt);
    if (sym === 256) {
      return TINF_OK2;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs3;
      var i;
      sym -= 257;
      length = tinf_read_bits2(d, length_bits2[sym], length_base2[sym]);
      dist = tinf_decode_symbol2(d, dt);
      offs3 = d.destLen - tinf_read_bits2(d, dist_bits2[dist], dist_base2[dist]);
      for (i = offs3; i < offs3 + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}
function tinf_inflate_uncompressed_block2(d) {
  var length, invlength;
  var i;
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];
  if (length !== (~invlength & 65535)) {
    return TINF_DATA_ERROR2;
  }
  d.sourceIndex += 4;
  for (i = length; i; --i) {
    d.dest[d.destLen++] = d.source[d.sourceIndex++];
  }
  d.bitcount = 0;
  return TINF_OK2;
}
function tinf_uncompress2(source, dest) {
  var d = new Data2(source, dest);
  var bfinal, btype, res;
  do {
    bfinal = tinf_getbit2(d);
    btype = tinf_read_bits2(d, 2, 0);
    switch (btype) {
      case 0:
        res = tinf_inflate_uncompressed_block2(d);
        break;
      case 1:
        res = tinf_inflate_block_data2(d, sltree2, sdtree2);
        break;
      case 2:
        tinf_decode_trees2(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data2(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR2;
    }
    if (res !== TINF_OK2) {
      throw new Error("Data error");
    }
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === "function") {
      return d.dest.slice(0, d.destLen);
    } else {
      return d.dest.subarray(0, d.destLen);
    }
  }
  return d.dest;
}
tinf_build_fixed_trees2(sltree2, sdtree2);
tinf_build_bits_base2(length_bits2, length_base2, 4, 3);
tinf_build_bits_base2(dist_bits2, dist_base2, 2, 1);
length_bits2[28] = 0;
length_base2[28] = 258;
var tinyInflate = tinf_uncompress2;
function derive(v0, v1, v2, v3, t2) {
  return Math.pow(1 - t2, 3) * v0 + 3 * Math.pow(1 - t2, 2) * t2 * v1 + 3 * (1 - t2) * Math.pow(t2, 2) * v2 + Math.pow(t2, 3) * v3;
}
function BoundingBox() {
  this.x1 = Number.NaN;
  this.y1 = Number.NaN;
  this.x2 = Number.NaN;
  this.y2 = Number.NaN;
}
BoundingBox.prototype.isEmpty = function() {
  return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};
BoundingBox.prototype.addPoint = function(x, y) {
  if (typeof x === "number") {
    if (isNaN(this.x1) || isNaN(this.x2)) {
      this.x1 = x;
      this.x2 = x;
    }
    if (x < this.x1) {
      this.x1 = x;
    }
    if (x > this.x2) {
      this.x2 = x;
    }
  }
  if (typeof y === "number") {
    if (isNaN(this.y1) || isNaN(this.y2)) {
      this.y1 = y;
      this.y2 = y;
    }
    if (y < this.y1) {
      this.y1 = y;
    }
    if (y > this.y2) {
      this.y2 = y;
    }
  }
};
BoundingBox.prototype.addX = function(x) {
  this.addPoint(x, null);
};
BoundingBox.prototype.addY = function(y) {
  this.addPoint(null, y);
};
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
  var p0 = [x0, y0];
  var p1 = [x1, y1];
  var p2 = [x2, y2];
  var p3 = [x, y];
  this.addPoint(x0, y0);
  this.addPoint(x, y);
  for (var i = 0; i <= 1; i++) {
    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
    var c = 3 * p1[i] - 3 * p0[i];
    if (a === 0) {
      if (b === 0) {
        continue;
      }
      var t2 = -c / b;
      if (0 < t2 && t2 < 1) {
        if (i === 0) {
          this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2));
        }
        if (i === 1) {
          this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2));
        }
      }
      continue;
    }
    var b2ac = Math.pow(b, 2) - 4 * c * a;
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
    if (0 < t1 && t1 < 1) {
      if (i === 0) {
        this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1));
      }
      if (i === 1) {
        this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1));
      }
    }
    var t22 = (-b - Math.sqrt(b2ac)) / (2 * a);
    if (0 < t22 && t22 < 1) {
      if (i === 0) {
        this.addX(derive(p0[i], p1[i], p2[i], p3[i], t22));
      }
      if (i === 1) {
        this.addY(derive(p0[i], p1[i], p2[i], p3[i], t22));
      }
    }
  }
};
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
  var cp1x = x0 + 2 / 3 * (x1 - x0);
  var cp1y = y0 + 2 / 3 * (y1 - y0);
  var cp2x = cp1x + 1 / 3 * (x - x0);
  var cp2y = cp1y + 1 / 3 * (y - y0);
  this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};
function Path() {
  this.commands = [];
  this.fill = "black";
  this.stroke = null;
  this.strokeWidth = 1;
}
Path.prototype.moveTo = function(x, y) {
  this.commands.push({
    type: "M",
    x,
    y
  });
};
Path.prototype.lineTo = function(x, y) {
  this.commands.push({
    type: "L",
    x,
    y
  });
};
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
  this.commands.push({
    type: "C",
    x1,
    y1,
    x2,
    y2,
    x,
    y
  });
};
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
  this.commands.push({
    type: "Q",
    x1,
    y1,
    x,
    y
  });
};
Path.prototype.close = Path.prototype.closePath = function() {
  this.commands.push({
    type: "Z"
  });
};
Path.prototype.extend = function(pathOrCommands) {
  if (pathOrCommands.commands) {
    pathOrCommands = pathOrCommands.commands;
  } else if (pathOrCommands instanceof BoundingBox) {
    var box = pathOrCommands;
    this.moveTo(box.x1, box.y1);
    this.lineTo(box.x2, box.y1);
    this.lineTo(box.x2, box.y2);
    this.lineTo(box.x1, box.y2);
    this.close();
    return;
  }
  Array.prototype.push.apply(this.commands, pathOrCommands);
};
Path.prototype.getBoundingBox = function() {
  var box = new BoundingBox();
  var startX = 0;
  var startY = 0;
  var prevX = 0;
  var prevY = 0;
  for (var i = 0; i < this.commands.length; i++) {
    var cmd = this.commands[i];
    switch (cmd.type) {
      case "M":
        box.addPoint(cmd.x, cmd.y);
        startX = prevX = cmd.x;
        startY = prevY = cmd.y;
        break;
      case "L":
        box.addPoint(cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Q":
        box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "C":
        box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        prevX = cmd.x;
        prevY = cmd.y;
        break;
      case "Z":
        prevX = startX;
        prevY = startY;
        break;
      default:
        throw new Error("Unexpected path command " + cmd.type);
    }
  }
  if (box.isEmpty()) {
    box.addPoint(0, 0);
  }
  return box;
};
Path.prototype.draw = function(ctx) {
  ctx.beginPath();
  for (var i = 0; i < this.commands.length; i += 1) {
    var cmd = this.commands[i];
    if (cmd.type === "M") {
      ctx.moveTo(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      ctx.lineTo(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      ctx.closePath();
    }
  }
  if (this.fill) {
    ctx.fillStyle = this.fill;
    ctx.fill();
  }
  if (this.stroke) {
    ctx.strokeStyle = this.stroke;
    ctx.lineWidth = this.strokeWidth;
    ctx.stroke();
  }
};
Path.prototype.toPathData = function(decimalPlaces) {
  decimalPlaces = decimalPlaces !== void 0 ? decimalPlaces : 2;
  function floatToString(v) {
    if (Math.round(v) === v) {
      return "" + Math.round(v);
    } else {
      return v.toFixed(decimalPlaces);
    }
  }
  function packValues() {
    var arguments$1 = arguments;
    var s = "";
    for (var i2 = 0; i2 < arguments.length; i2 += 1) {
      var v = arguments$1[i2];
      if (v >= 0 && i2 > 0) {
        s += " ";
      }
      s += floatToString(v);
    }
    return s;
  }
  var d = "";
  for (var i = 0; i < this.commands.length; i += 1) {
    var cmd = this.commands[i];
    if (cmd.type === "M") {
      d += "M" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "L") {
      d += "L" + packValues(cmd.x, cmd.y);
    } else if (cmd.type === "C") {
      d += "C" + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
    } else if (cmd.type === "Q") {
      d += "Q" + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
    } else if (cmd.type === "Z") {
      d += "Z";
    }
  }
  return d;
};
Path.prototype.toSVG = function(decimalPlaces) {
  var svg = '<path d="';
  svg += this.toPathData(decimalPlaces);
  svg += '"';
  if (this.fill && this.fill !== "black") {
    if (this.fill === null) {
      svg += ' fill="none"';
    } else {
      svg += ' fill="' + this.fill + '"';
    }
  }
  if (this.stroke) {
    svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
  }
  svg += "/>";
  return svg;
};
Path.prototype.toDOMElement = function(decimalPlaces) {
  var temporaryPath = this.toPathData(decimalPlaces);
  var newPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  newPath.setAttribute("d", temporaryPath);
  return newPath;
};
function fail(message2) {
  throw new Error(message2);
}
function argument(predicate, message2) {
  if (!predicate) {
    fail(message2);
  }
}
var check = { fail, argument, assert: argument };
var LIMIT16 = 32768;
var LIMIT32 = 2147483648;
var decode = {};
var encode = {};
var sizeOf = {};
function constant(v) {
  return function() {
    return v;
  };
}
encode.BYTE = function(v) {
  check.argument(v >= 0 && v <= 255, "Byte value should be between 0 and 255.");
  return [v];
};
sizeOf.BYTE = constant(1);
encode.CHAR = function(v) {
  return [v.charCodeAt(0)];
};
sizeOf.CHAR = constant(1);
encode.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    v = "";
    console.warn("Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.");
  }
  var b = [];
  for (var i = 0; i < v.length; i += 1) {
    b[i] = v.charCodeAt(i);
  }
  return b;
};
sizeOf.CHARARRAY = function(v) {
  if (typeof v === "undefined") {
    return 0;
  }
  return v.length;
};
encode.USHORT = function(v) {
  return [v >> 8 & 255, v & 255];
};
sizeOf.USHORT = constant(2);
encode.SHORT = function(v) {
  if (v >= LIMIT16) {
    v = -(2 * LIMIT16 - v);
  }
  return [v >> 8 & 255, v & 255];
};
sizeOf.SHORT = constant(2);
encode.UINT24 = function(v) {
  return [v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.UINT24 = constant(3);
encode.ULONG = function(v) {
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.ULONG = constant(4);
encode.LONG = function(v) {
  if (v >= LIMIT32) {
    v = -(2 * LIMIT32 - v);
  }
  return [v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONG = constant(4);
encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;
encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;
encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;
encode.LONGDATETIME = function(v) {
  return [0, 0, 0, 0, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.LONGDATETIME = constant(8);
encode.TAG = function(v) {
  check.argument(v.length === 4, "Tag should be exactly 4 ASCII characters.");
  return [
    v.charCodeAt(0),
    v.charCodeAt(1),
    v.charCodeAt(2),
    v.charCodeAt(3)
  ];
};
sizeOf.TAG = constant(4);
encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;
encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;
encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;
encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;
encode.NUMBER = function(v) {
  if (v >= -107 && v <= 107) {
    return [v + 139];
  } else if (v >= 108 && v <= 1131) {
    v = v - 108;
    return [(v >> 8) + 247, v & 255];
  } else if (v >= -1131 && v <= -108) {
    v = -v - 108;
    return [(v >> 8) + 251, v & 255];
  } else if (v >= -32768 && v <= 32767) {
    return encode.NUMBER16(v);
  } else {
    return encode.NUMBER32(v);
  }
};
sizeOf.NUMBER = function(v) {
  return encode.NUMBER(v).length;
};
encode.NUMBER16 = function(v) {
  return [28, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER16 = constant(3);
encode.NUMBER32 = function(v) {
  return [29, v >> 24 & 255, v >> 16 & 255, v >> 8 & 255, v & 255];
};
sizeOf.NUMBER32 = constant(5);
encode.REAL = function(v) {
  var value = v.toString();
  var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
  if (m) {
    var epsilon = parseFloat("1e" + ((m[2] ? +m[2] : 0) + m[1].length));
    value = (Math.round(v * epsilon) / epsilon).toString();
  }
  var nibbles = "";
  for (var i = 0, ii = value.length; i < ii; i += 1) {
    var c = value[i];
    if (c === "e") {
      nibbles += value[++i] === "-" ? "c" : "b";
    } else if (c === ".") {
      nibbles += "a";
    } else if (c === "-") {
      nibbles += "e";
    } else {
      nibbles += c;
    }
  }
  nibbles += nibbles.length & 1 ? "f" : "ff";
  var out = [30];
  for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
    out.push(parseInt(nibbles.substr(i$1, 2), 16));
  }
  return out;
};
sizeOf.REAL = function(v) {
  return encode.REAL(v).length;
};
encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;
encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;
decode.UTF8 = function(data2, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes;
  for (var j = 0; j < numChars; j++, offset += 1) {
    codePoints[j] = data2.getUint8(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
decode.UTF16 = function(data2, offset, numBytes) {
  var codePoints = [];
  var numChars = numBytes / 2;
  for (var j = 0; j < numChars; j++, offset += 2) {
    codePoints[j] = data2.getUint16(offset);
  }
  return String.fromCharCode.apply(null, codePoints);
};
encode.UTF16 = function(v) {
  var b = [];
  for (var i = 0; i < v.length; i += 1) {
    var codepoint = v.charCodeAt(i);
    b[b.length] = codepoint >> 8 & 255;
    b[b.length] = codepoint & 255;
  }
  return b;
};
sizeOf.UTF16 = function(v) {
  return v.length * 2;
};
var eightBitMacEncodings = {
  "x-mac-croatian": (
    // Python: 'mac_croatian'
    "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\u0160\u2122\xB4\xA8\u2260\u017D\xD8\u221E\xB1\u2264\u2265\u2206\xB5\u2202\u2211\u220F\u0161\u222B\xAA\xBA\u03A9\u017E\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u0106\xAB\u010C\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u0110\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\uF8FF\xA9\u2044\u20AC\u2039\u203A\xC6\xBB\u2013\xB7\u201A\u201E\u2030\xC2\u0107\xC1\u010D\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u0111\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u03C0\xCB\u02DA\xB8\xCA\xE6\u02C7"
  ),
  "x-mac-cyrillic": (
    // Python: 'mac_cyrillic'
    "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F\u2020\xB0\u0490\xA3\xA7\u2022\xB6\u0406\xAE\xA9\u2122\u0402\u0452\u2260\u0403\u0453\u221E\xB1\u2264\u2265\u0456\xB5\u0491\u0408\u0404\u0454\u0407\u0457\u0409\u0459\u040A\u045A\u0458\u0405\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\u040B\u045B\u040C\u045C\u0455\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u201E\u040E\u045E\u040F\u045F\u2116\u0401\u0451\u044F\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044A\u044B\u044C\u044D\u044E"
  ),
  "x-mac-gaelic": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u1E02\xB1\u2264\u2265\u1E03\u010A\u010B\u1E0A\u1E0B\u1E1E\u1E1F\u0120\u0121\u1E40\xE6\xF8\u1E41\u1E56\u1E57\u027C\u0192\u017F\u1E60\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\u1E61\u1E9B\xFF\u0178\u1E6A\u20AC\u2039\u203A\u0176\u0177\u1E6B\xB7\u1EF2\u1EF3\u204A\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\u2663\xD2\xDA\xDB\xD9\u0131\xDD\xFD\u0174\u0175\u1E84\u1E85\u1E80\u1E81\u1E82\u1E83"
  ),
  "x-mac-greek": (
    // Python: 'mac_greek'
    "\xC4\xB9\xB2\xC9\xB3\xD6\xDC\u0385\xE0\xE2\xE4\u0384\xA8\xE7\xE9\xE8\xEA\xEB\xA3\u2122\xEE\xEF\u2022\xBD\u2030\xF4\xF6\xA6\u20AC\xF9\xFB\xFC\u2020\u0393\u0394\u0398\u039B\u039E\u03A0\xDF\xAE\xA9\u03A3\u03AA\xA7\u2260\xB0\xB7\u0391\xB1\u2264\u2265\xA5\u0392\u0395\u0396\u0397\u0399\u039A\u039C\u03A6\u03AB\u03A8\u03A9\u03AC\u039D\xAC\u039F\u03A1\u2248\u03A4\xAB\xBB\u2026\xA0\u03A5\u03A7\u0386\u0388\u0153\u2013\u2015\u201C\u201D\u2018\u2019\xF7\u0389\u038A\u038C\u038E\u03AD\u03AE\u03AF\u03CC\u038F\u03CD\u03B1\u03B2\u03C8\u03B4\u03B5\u03C6\u03B3\u03B7\u03B9\u03BE\u03BA\u03BB\u03BC\u03BD\u03BF\u03C0\u03CE\u03C1\u03C3\u03C4\u03B8\u03C9\u03C2\u03C7\u03C5\u03B6\u03CA\u03CB\u0390\u03B0\xAD"
  ),
  "x-mac-icelandic": (
    // Python: 'mac_iceland'
    "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\xDD\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\xD0\xF0\xDE\xFE\xFD\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
  ),
  "x-mac-inuit": (
    // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    "\u1403\u1404\u1405\u1406\u140A\u140B\u1431\u1432\u1433\u1434\u1438\u1439\u1449\u144E\u144F\u1450\u1451\u1455\u1456\u1466\u146D\u146E\u146F\u1470\u1472\u1473\u1483\u148B\u148C\u148D\u148E\u1490\u1491\xB0\u14A1\u14A5\u14A6\u2022\xB6\u14A7\xAE\xA9\u2122\u14A8\u14AA\u14AB\u14BB\u14C2\u14C3\u14C4\u14C5\u14C7\u14C8\u14D0\u14EF\u14F0\u14F1\u14F2\u14F4\u14F5\u1505\u14D5\u14D6\u14D7\u14D8\u14DA\u14DB\u14EA\u1528\u1529\u152A\u152B\u152D\u2026\xA0\u152E\u153E\u1555\u1556\u1557\u2013\u2014\u201C\u201D\u2018\u2019\u1558\u1559\u155A\u155D\u1546\u1547\u1548\u1549\u154B\u154C\u1550\u157F\u1580\u1581\u1582\u1583\u1584\u1585\u158F\u1590\u1591\u1592\u1593\u1594\u1595\u1671\u1672\u1673\u1674\u1675\u1676\u1596\u15A0\u15A1\u15A2\u15A3\u15A4\u15A5\u15A6\u157C\u0141\u0142"
  ),
  "x-mac-ce": (
    // Python: 'mac_latin2'
    "\xC4\u0100\u0101\xC9\u0104\xD6\xDC\xE1\u0105\u010C\xE4\u010D\u0106\u0107\xE9\u0179\u017A\u010E\xED\u010F\u0112\u0113\u0116\xF3\u0117\xF4\xF6\xF5\xFA\u011A\u011B\xFC\u2020\xB0\u0118\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\u0119\xA8\u2260\u0123\u012E\u012F\u012A\u2264\u2265\u012B\u0136\u2202\u2211\u0142\u013B\u013C\u013D\u013E\u0139\u013A\u0145\u0146\u0143\xAC\u221A\u0144\u0147\u2206\xAB\xBB\u2026\xA0\u0148\u0150\xD5\u0151\u014C\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\u014D\u0154\u0155\u0158\u2039\u203A\u0159\u0156\u0157\u0160\u201A\u201E\u0161\u015A\u015B\xC1\u0164\u0165\xCD\u017D\u017E\u016A\xD3\xD4\u016B\u016E\xDA\u016F\u0170\u0171\u0172\u0173\xDD\xFD\u0137\u017B\u0141\u017C\u0122\u02C7"
  ),
  macintosh: (
    // Python: 'mac_roman'
    "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\uFB01\uFB02\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
  ),
  "x-mac-romanian": (
    // Python: 'mac_romanian'
    "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\u0102\u0218\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\u0103\u0219\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u2044\u20AC\u2039\u203A\u021A\u021B\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\u0131\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
  ),
  "x-mac-turkish": (
    // Python: 'mac_turkish'
    "\xC4\xC5\xC7\xC9\xD1\xD6\xDC\xE1\xE0\xE2\xE4\xE3\xE5\xE7\xE9\xE8\xEA\xEB\xED\xEC\xEE\xEF\xF1\xF3\xF2\xF4\xF6\xF5\xFA\xF9\xFB\xFC\u2020\xB0\xA2\xA3\xA7\u2022\xB6\xDF\xAE\xA9\u2122\xB4\xA8\u2260\xC6\xD8\u221E\xB1\u2264\u2265\xA5\xB5\u2202\u2211\u220F\u03C0\u222B\xAA\xBA\u03A9\xE6\xF8\xBF\xA1\xAC\u221A\u0192\u2248\u2206\xAB\xBB\u2026\xA0\xC0\xC3\xD5\u0152\u0153\u2013\u2014\u201C\u201D\u2018\u2019\xF7\u25CA\xFF\u0178\u011E\u011F\u0130\u0131\u015E\u015F\u2021\xB7\u201A\u201E\u2030\xC2\xCA\xC1\xCB\xC8\xCD\xCE\xCF\xCC\xD3\xD4\uF8FF\xD2\xDA\xDB\xD9\uF8A0\u02C6\u02DC\xAF\u02D8\u02D9\u02DA\xB8\u02DD\u02DB\u02C7"
  )
};
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
  var table2 = eightBitMacEncodings[encoding];
  if (table2 === void 0) {
    return void 0;
  }
  var result = "";
  for (var i = 0; i < dataLength; i++) {
    var c = dataView.getUint8(offset + i);
    if (c <= 127) {
      result += String.fromCharCode(c);
    } else {
      result += table2[c & 127];
    }
  }
  return result;
};
var macEncodingTableCache = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function(encoding) {
  if (!macEncodingCacheKeys) {
    macEncodingCacheKeys = {};
    for (var e in eightBitMacEncodings) {
      macEncodingCacheKeys[e] = new String(e);
    }
  }
  var cacheKey = macEncodingCacheKeys[encoding];
  if (cacheKey === void 0) {
    return void 0;
  }
  if (macEncodingTableCache) {
    var cachedTable = macEncodingTableCache.get(cacheKey);
    if (cachedTable !== void 0) {
      return cachedTable;
    }
  }
  var decodingTable = eightBitMacEncodings[encoding];
  if (decodingTable === void 0) {
    return void 0;
  }
  var encodingTable = {};
  for (var i = 0; i < decodingTable.length; i++) {
    encodingTable[decodingTable.charCodeAt(i)] = i + 128;
  }
  if (macEncodingTableCache) {
    macEncodingTableCache.set(cacheKey, encodingTable);
  }
  return encodingTable;
};
encode.MACSTRING = function(str, encoding) {
  var table2 = getMacEncodingTable(encoding);
  if (table2 === void 0) {
    return void 0;
  }
  var result = [];
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c >= 128) {
      c = table2[c];
      if (c === void 0) {
        return void 0;
      }
    }
    result[i] = c;
  }
  return result;
};
sizeOf.MACSTRING = function(str, encoding) {
  var b = encode.MACSTRING(str, encoding);
  if (b !== void 0) {
    return b.length;
  } else {
    return 0;
  }
};
function isByteEncodable(value) {
  return value >= -128 && value <= 127;
}
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
    ++pos;
    ++runLength;
  }
  result.push(128 | runLength - 1);
  return pos;
}
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (!isByteEncodable(value)) {
      break;
    }
    if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(runLength - 1);
  for (var i = offset; i < pos; ++i) {
    result.push(deltas[i] + 256 & 255);
  }
  return pos;
}
function encodeVarDeltaRunAsWords(deltas, offset, result) {
  var runLength = 0;
  var numDeltas = deltas.length;
  var pos = offset;
  while (pos < numDeltas && runLength < 64) {
    var value = deltas[pos];
    if (value === 0) {
      break;
    }
    if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
      break;
    }
    ++pos;
    ++runLength;
  }
  result.push(64 | runLength - 1);
  for (var i = offset; i < pos; ++i) {
    var val = deltas[i];
    result.push(val + 65536 >> 8 & 255, val + 256 & 255);
  }
  return pos;
}
encode.VARDELTAS = function(deltas) {
  var pos = 0;
  var result = [];
  while (pos < deltas.length) {
    var value = deltas[pos];
    if (value === 0) {
      pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
    } else if (value >= -128 && value <= 127) {
      pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
    } else {
      pos = encodeVarDeltaRunAsWords(deltas, pos, result);
    }
  }
  return result;
};
encode.INDEX = function(l) {
  var offset = 1;
  var offsets = [offset];
  var data2 = [];
  for (var i = 0; i < l.length; i += 1) {
    var v = encode.OBJECT(l[i]);
    Array.prototype.push.apply(data2, v);
    offset += v.length;
    offsets.push(offset);
  }
  if (data2.length === 0) {
    return [0, 0];
  }
  var encodedOffsets = [];
  var offSize = 1 + Math.floor(Math.log(offset) / Math.log(2)) / 8 | 0;
  var offsetEncoder = [void 0, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
  for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
    var encodedOffset = offsetEncoder(offsets[i$1]);
    Array.prototype.push.apply(encodedOffsets, encodedOffset);
  }
  return Array.prototype.concat(
    encode.Card16(l.length),
    encode.OffSize(offSize),
    encodedOffsets,
    data2
  );
};
sizeOf.INDEX = function(v) {
  return encode.INDEX(v).length;
};
encode.DICT = function(m) {
  var d = [];
  var keys = Object.keys(m);
  var length = keys.length;
  for (var i = 0; i < length; i += 1) {
    var k = parseInt(keys[i], 0);
    var v = m[k];
    d = d.concat(encode.OPERAND(v.value, v.type));
    d = d.concat(encode.OPERATOR(k));
  }
  return d;
};
sizeOf.DICT = function(m) {
  return encode.DICT(m).length;
};
encode.OPERATOR = function(v) {
  if (v < 1200) {
    return [v];
  } else {
    return [12, v - 1200];
  }
};
encode.OPERAND = function(v, type2) {
  var d = [];
  if (Array.isArray(type2)) {
    for (var i = 0; i < type2.length; i += 1) {
      check.argument(v.length === type2.length, "Not enough arguments given for type" + type2);
      d = d.concat(encode.OPERAND(v[i], type2[i]));
    }
  } else {
    if (type2 === "SID") {
      d = d.concat(encode.NUMBER(v));
    } else if (type2 === "offset") {
      d = d.concat(encode.NUMBER32(v));
    } else if (type2 === "number") {
      d = d.concat(encode.NUMBER(v));
    } else if (type2 === "real") {
      d = d.concat(encode.REAL(v));
    } else {
      throw new Error("Unknown operand type " + type2);
    }
  }
  return d;
};
encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;
var wmm = typeof WeakMap === "function" && /* @__PURE__ */ new WeakMap();
encode.CHARSTRING = function(ops) {
  if (wmm) {
    var cachedValue = wmm.get(ops);
    if (cachedValue !== void 0) {
      return cachedValue;
    }
  }
  var d = [];
  var length = ops.length;
  for (var i = 0; i < length; i += 1) {
    var op = ops[i];
    d = d.concat(encode[op.type](op.value));
  }
  if (wmm) {
    wmm.set(ops, d);
  }
  return d;
};
sizeOf.CHARSTRING = function(ops) {
  return encode.CHARSTRING(ops).length;
};
encode.OBJECT = function(v) {
  var encodingFunction = encode[v.type];
  check.argument(encodingFunction !== void 0, "No encoding function for type " + v.type);
  return encodingFunction(v.value);
};
sizeOf.OBJECT = function(v) {
  var sizeOfFunction = sizeOf[v.type];
  check.argument(sizeOfFunction !== void 0, "No sizeOf function for type " + v.type);
  return sizeOfFunction(v.value);
};
encode.TABLE = function(table2) {
  var d = [];
  var length = table2.fields.length;
  var subtables = [];
  var subtableOffsets = [];
  for (var i = 0; i < length; i += 1) {
    var field = table2.fields[i];
    var encodingFunction = encode[field.type];
    check.argument(encodingFunction !== void 0, "No encoding function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    var bytes = encodingFunction(value);
    if (field.type === "TABLE") {
      subtableOffsets.push(d.length);
      d = d.concat([0, 0]);
      subtables.push(bytes);
    } else {
      d = d.concat(bytes);
    }
  }
  for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
    var o = subtableOffsets[i$1];
    var offset = d.length;
    check.argument(offset < 65536, "Table " + table2.tableName + " too big.");
    d[o] = offset >> 8;
    d[o + 1] = offset & 255;
    d = d.concat(subtables[i$1]);
  }
  return d;
};
sizeOf.TABLE = function(table2) {
  var numBytes = 0;
  var length = table2.fields.length;
  for (var i = 0; i < length; i += 1) {
    var field = table2.fields[i];
    var sizeOfFunction = sizeOf[field.type];
    check.argument(sizeOfFunction !== void 0, "No sizeOf function for field type " + field.type + " (" + field.name + ")");
    var value = table2[field.name];
    if (value === void 0) {
      value = field.value;
    }
    numBytes += sizeOfFunction(value);
    if (field.type === "TABLE") {
      numBytes += 2;
    }
  }
  return numBytes;
};
encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;
encode.LITERAL = function(v) {
  return v;
};
sizeOf.LITERAL = function(v) {
  return v.length;
};
function Table(tableName, fields, options) {
  if (fields.length && (fields[0].name !== "coverageFormat" || fields[0].value === 1)) {
    for (var i = 0; i < fields.length; i += 1) {
      var field = fields[i];
      this[field.name] = field.value;
    }
  }
  this.tableName = tableName;
  this.fields = fields;
  if (options) {
    var optionKeys = Object.keys(options);
    for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
      var k = optionKeys[i$1];
      var v = options[k];
      if (this[k] !== void 0) {
        this[k] = v;
      }
    }
  }
}
Table.prototype.encode = function() {
  return encode.TABLE(this);
};
Table.prototype.sizeOf = function() {
  return sizeOf.TABLE(this);
};
function ushortList(itemName, list, count) {
  if (count === void 0) {
    count = list.length;
  }
  var fields = new Array(list.length + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i = 0; i < list.length; i++) {
    fields[i + 1] = { name: itemName + i, type: "USHORT", value: list[i] };
  }
  return fields;
}
function tableList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = new Array(count + 1);
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i = 0; i < count; i++) {
    fields[i + 1] = { name: itemName + i, type: "TABLE", value: itemCallback(records[i], i) };
  }
  return fields;
}
function recordList(itemName, records, itemCallback) {
  var count = records.length;
  var fields = [];
  fields[0] = { name: itemName + "Count", type: "USHORT", value: count };
  for (var i = 0; i < count; i++) {
    fields = fields.concat(itemCallback(records[i], i));
  }
  return fields;
}
function Coverage(coverageTable) {
  if (coverageTable.format === 1) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 1 }].concat(ushortList("glyph", coverageTable.glyphs))
    );
  } else if (coverageTable.format === 2) {
    Table.call(
      this,
      "coverageTable",
      [{ name: "coverageFormat", type: "USHORT", value: 2 }].concat(recordList("rangeRecord", coverageTable.ranges, function(RangeRecord) {
        return [
          { name: "startGlyphID", type: "USHORT", value: RangeRecord.start },
          { name: "endGlyphID", type: "USHORT", value: RangeRecord.end },
          { name: "startCoverageIndex", type: "USHORT", value: RangeRecord.index }
        ];
      }))
    );
  } else {
    check.assert(false, "Coverage format must be 1 or 2.");
  }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;
function ScriptList(scriptListTable) {
  Table.call(
    this,
    "scriptListTable",
    recordList("scriptRecord", scriptListTable, function(scriptRecord, i) {
      var script2 = scriptRecord.script;
      var defaultLangSys = script2.defaultLangSys;
      check.assert(!!defaultLangSys, "Unable to write GSUB: script " + scriptRecord.tag + " has no default language system.");
      return [
        { name: "scriptTag" + i, type: "TAG", value: scriptRecord.tag },
        { name: "script" + i, type: "TABLE", value: new Table("scriptTable", [
          { name: "defaultLangSys", type: "TABLE", value: new Table("defaultLangSys", [
            { name: "lookupOrder", type: "USHORT", value: 0 },
            { name: "reqFeatureIndex", type: "USHORT", value: defaultLangSys.reqFeatureIndex }
          ].concat(ushortList("featureIndex", defaultLangSys.featureIndexes))) }
        ].concat(recordList("langSys", script2.langSysRecords, function(langSysRecord, i2) {
          var langSys = langSysRecord.langSys;
          return [
            { name: "langSysTag" + i2, type: "TAG", value: langSysRecord.tag },
            { name: "langSys" + i2, type: "TABLE", value: new Table("langSys", [
              { name: "lookupOrder", type: "USHORT", value: 0 },
              { name: "reqFeatureIndex", type: "USHORT", value: langSys.reqFeatureIndex }
            ].concat(ushortList("featureIndex", langSys.featureIndexes))) }
          ];
        }))) }
      ];
    })
  );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;
function FeatureList(featureListTable) {
  Table.call(
    this,
    "featureListTable",
    recordList("featureRecord", featureListTable, function(featureRecord, i) {
      var feature = featureRecord.feature;
      return [
        { name: "featureTag" + i, type: "TAG", value: featureRecord.tag },
        { name: "feature" + i, type: "TABLE", value: new Table("featureTable", [
          { name: "featureParams", type: "USHORT", value: feature.featureParams }
        ].concat(ushortList("lookupListIndex", feature.lookupListIndexes))) }
      ];
    })
  );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;
function LookupList(lookupListTable, subtableMakers2) {
  Table.call(this, "lookupListTable", tableList("lookup", lookupListTable, function(lookupTable) {
    var subtableCallback = subtableMakers2[lookupTable.lookupType];
    check.assert(!!subtableCallback, "Unable to write GSUB lookup type " + lookupTable.lookupType + " tables.");
    return new Table("lookupTable", [
      { name: "lookupType", type: "USHORT", value: lookupTable.lookupType },
      { name: "lookupFlag", type: "USHORT", value: lookupTable.lookupFlag }
    ].concat(tableList("subtable", lookupTable.subtables, subtableCallback)));
  }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;
var table = {
  Table,
  Record: Table,
  Coverage,
  ScriptList,
  FeatureList,
  LookupList,
  ushortList,
  tableList,
  recordList
};
function getByte(dataView, offset) {
  return dataView.getUint8(offset);
}
function getUShort(dataView, offset) {
  return dataView.getUint16(offset, false);
}
function getShort(dataView, offset) {
  return dataView.getInt16(offset, false);
}
function getULong(dataView, offset) {
  return dataView.getUint32(offset, false);
}
function getFixed(dataView, offset) {
  var decimal2 = dataView.getInt16(offset, false);
  var fraction = dataView.getUint16(offset + 2, false);
  return decimal2 + fraction / 65535;
}
function getTag(dataView, offset) {
  var tag = "";
  for (var i = offset; i < offset + 4; i += 1) {
    tag += String.fromCharCode(dataView.getInt8(i));
  }
  return tag;
}
function getOffset(dataView, offset, offSize) {
  var v = 0;
  for (var i = 0; i < offSize; i += 1) {
    v <<= 8;
    v += dataView.getUint8(offset + i);
  }
  return v;
}
function getBytes(dataView, startOffset, endOffset) {
  var bytes = [];
  for (var i = startOffset; i < endOffset; i += 1) {
    bytes.push(dataView.getUint8(i));
  }
  return bytes;
}
function bytesToString(bytes) {
  var s = "";
  for (var i = 0; i < bytes.length; i += 1) {
    s += String.fromCharCode(bytes[i]);
  }
  return s;
}
var typeOffsets = {
  byte: 1,
  uShort: 2,
  short: 2,
  uLong: 4,
  fixed: 4,
  longDateTime: 8,
  tag: 4
};
function Parser(data2, offset) {
  this.data = data2;
  this.offset = offset;
  this.relativeOffset = 0;
}
Parser.prototype.parseByte = function() {
  var v = this.data.getUint8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser.prototype.parseChar = function() {
  var v = this.data.getInt8(this.offset + this.relativeOffset);
  this.relativeOffset += 1;
  return v;
};
Parser.prototype.parseCard8 = Parser.prototype.parseByte;
Parser.prototype.parseUShort = function() {
  var v = this.data.getUint16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;
Parser.prototype.parseShort = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset);
  this.relativeOffset += 2;
  return v;
};
Parser.prototype.parseF2Dot14 = function() {
  var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
  this.relativeOffset += 2;
  return v;
};
Parser.prototype.parseULong = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser.prototype.parseOffset32 = Parser.prototype.parseULong;
Parser.prototype.parseFixed = function() {
  var v = getFixed(this.data, this.offset + this.relativeOffset);
  this.relativeOffset += 4;
  return v;
};
Parser.prototype.parseString = function(length) {
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  var string = "";
  this.relativeOffset += length;
  for (var i = 0; i < length; i++) {
    string += String.fromCharCode(dataView.getUint8(offset + i));
  }
  return string;
};
Parser.prototype.parseTag = function() {
  return this.parseString(4);
};
Parser.prototype.parseLongDateTime = function() {
  var v = getULong(this.data, this.offset + this.relativeOffset + 4);
  v -= 2082844800;
  this.relativeOffset += 8;
  return v;
};
Parser.prototype.parseVersion = function(minorBase) {
  var major = getUShort(this.data, this.offset + this.relativeOffset);
  var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
  this.relativeOffset += 4;
  if (minorBase === void 0) {
    minorBase = 4096;
  }
  return major + minor / minorBase / 10;
};
Parser.prototype.skip = function(type2, amount) {
  if (amount === void 0) {
    amount = 1;
  }
  this.relativeOffset += typeOffsets[type2] * amount;
};
Parser.prototype.parseULongList = function(count) {
  if (count === void 0) {
    count = this.parseULong();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    offsets[i] = dataView.getUint32(offset);
    offset += 4;
  }
  this.relativeOffset += count * 4;
  return offsets;
};
Parser.prototype.parseOffset16List = Parser.prototype.parseUShortList = function(count) {
  if (count === void 0) {
    count = this.parseUShort();
  }
  var offsets = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    offsets[i] = dataView.getUint16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return offsets;
};
Parser.prototype.parseShortList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    list[i] = dataView.getInt16(offset);
    offset += 2;
  }
  this.relativeOffset += count * 2;
  return list;
};
Parser.prototype.parseByteList = function(count) {
  var list = new Array(count);
  var dataView = this.data;
  var offset = this.offset + this.relativeOffset;
  for (var i = 0; i < count; i++) {
    list[i] = dataView.getUint8(offset++);
  }
  this.relativeOffset += count;
  return list;
};
Parser.prototype.parseList = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseUShort();
  }
  var list = new Array(count);
  for (var i = 0; i < count; i++) {
    list[i] = itemCallback.call(this);
  }
  return list;
};
Parser.prototype.parseList32 = function(count, itemCallback) {
  if (!itemCallback) {
    itemCallback = count;
    count = this.parseULong();
  }
  var list = new Array(count);
  for (var i = 0; i < count; i++) {
    list[i] = itemCallback.call(this);
  }
  return list;
};
Parser.prototype.parseRecordList = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseUShort();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i = 0; i < count; i++) {
    var rec = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i] = rec;
  }
  return records;
};
Parser.prototype.parseRecordList32 = function(count, recordDescription) {
  if (!recordDescription) {
    recordDescription = count;
    count = this.parseULong();
  }
  var records = new Array(count);
  var fields = Object.keys(recordDescription);
  for (var i = 0; i < count; i++) {
    var rec = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = recordDescription[fieldName];
      rec[fieldName] = fieldType.call(this);
    }
    records[i] = rec;
  }
  return records;
};
Parser.prototype.parseStruct = function(description) {
  if (typeof description === "function") {
    return description.call(this);
  } else {
    var fields = Object.keys(description);
    var struct = {};
    for (var j = 0; j < fields.length; j++) {
      var fieldName = fields[j];
      var fieldType = description[fieldName];
      struct[fieldName] = fieldType.call(this);
    }
    return struct;
  }
};
Parser.prototype.parseValueRecord = function(valueFormat) {
  if (valueFormat === void 0) {
    valueFormat = this.parseUShort();
  }
  if (valueFormat === 0) {
    return;
  }
  var valueRecord = {};
  if (valueFormat & 1) {
    valueRecord.xPlacement = this.parseShort();
  }
  if (valueFormat & 2) {
    valueRecord.yPlacement = this.parseShort();
  }
  if (valueFormat & 4) {
    valueRecord.xAdvance = this.parseShort();
  }
  if (valueFormat & 8) {
    valueRecord.yAdvance = this.parseShort();
  }
  if (valueFormat & 16) {
    valueRecord.xPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 32) {
    valueRecord.yPlaDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 64) {
    valueRecord.xAdvDevice = void 0;
    this.parseShort();
  }
  if (valueFormat & 128) {
    valueRecord.yAdvDevice = void 0;
    this.parseShort();
  }
  return valueRecord;
};
Parser.prototype.parseValueRecordList = function() {
  var valueFormat = this.parseUShort();
  var valueCount = this.parseUShort();
  var values = new Array(valueCount);
  for (var i = 0; i < valueCount; i++) {
    values[i] = this.parseValueRecord(valueFormat);
  }
  return values;
};
Parser.prototype.parsePointer = function(description) {
  var structOffset = this.parseOffset16();
  if (structOffset > 0) {
    return new Parser(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser.prototype.parsePointer32 = function(description) {
  var structOffset = this.parseOffset32();
  if (structOffset > 0) {
    return new Parser(this.data, this.offset + structOffset).parseStruct(description);
  }
  return void 0;
};
Parser.prototype.parseListOfLists = function(itemCallback) {
  var offsets = this.parseOffset16List();
  var count = offsets.length;
  var relativeOffset = this.relativeOffset;
  var list = new Array(count);
  for (var i = 0; i < count; i++) {
    var start = offsets[i];
    if (start === 0) {
      list[i] = void 0;
      continue;
    }
    this.relativeOffset = start;
    if (itemCallback) {
      var subOffsets = this.parseOffset16List();
      var subList = new Array(subOffsets.length);
      for (var j = 0; j < subOffsets.length; j++) {
        this.relativeOffset = start + subOffsets[j];
        subList[j] = itemCallback.call(this);
      }
      list[i] = subList;
    } else {
      list[i] = this.parseUShortList();
    }
  }
  this.relativeOffset = relativeOffset;
  return list;
};
Parser.prototype.parseCoverage = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  var count = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      glyphs: this.parseUShortList(count)
    };
  } else if (format === 2) {
    var ranges = new Array(count);
    for (var i = 0; i < count; i++) {
      ranges[i] = {
        start: this.parseUShort(),
        end: this.parseUShort(),
        index: this.parseUShort()
      };
    }
    return {
      format: 2,
      ranges
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": Coverage format must be 1 or 2.");
};
Parser.prototype.parseClassDef = function() {
  var startOffset = this.offset + this.relativeOffset;
  var format = this.parseUShort();
  if (format === 1) {
    return {
      format: 1,
      startGlyph: this.parseUShort(),
      classes: this.parseUShortList()
    };
  } else if (format === 2) {
    return {
      format: 2,
      ranges: this.parseRecordList({
        start: Parser.uShort,
        end: Parser.uShort,
        classId: Parser.uShort
      })
    };
  }
  throw new Error("0x" + startOffset.toString(16) + ": ClassDef format must be 1 or 2.");
};
Parser.list = function(count, itemCallback) {
  return function() {
    return this.parseList(count, itemCallback);
  };
};
Parser.list32 = function(count, itemCallback) {
  return function() {
    return this.parseList32(count, itemCallback);
  };
};
Parser.recordList = function(count, recordDescription) {
  return function() {
    return this.parseRecordList(count, recordDescription);
  };
};
Parser.recordList32 = function(count, recordDescription) {
  return function() {
    return this.parseRecordList32(count, recordDescription);
  };
};
Parser.pointer = function(description) {
  return function() {
    return this.parsePointer(description);
  };
};
Parser.pointer32 = function(description) {
  return function() {
    return this.parsePointer32(description);
  };
};
Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
Parser.uLongList = Parser.prototype.parseULongList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;
var langSysTable = {
  reserved: Parser.uShort,
  reqFeatureIndex: Parser.uShort,
  featureIndexes: Parser.uShortList
};
Parser.prototype.parseScriptList = function() {
  return this.parsePointer(Parser.recordList({
    tag: Parser.tag,
    script: Parser.pointer({
      defaultLangSys: Parser.pointer(langSysTable),
      langSysRecords: Parser.recordList({
        tag: Parser.tag,
        langSys: Parser.pointer(langSysTable)
      })
    })
  })) || [];
};
Parser.prototype.parseFeatureList = function() {
  return this.parsePointer(Parser.recordList({
    tag: Parser.tag,
    feature: Parser.pointer({
      featureParams: Parser.offset16,
      lookupListIndexes: Parser.uShortList
    })
  })) || [];
};
Parser.prototype.parseLookupList = function(lookupTableParsers) {
  return this.parsePointer(Parser.list(Parser.pointer(function() {
    var lookupType = this.parseUShort();
    check.argument(1 <= lookupType && lookupType <= 9, "GPOS/GSUB lookup type " + lookupType + " unknown.");
    var lookupFlag = this.parseUShort();
    var useMarkFilteringSet = lookupFlag & 16;
    return {
      lookupType,
      lookupFlag,
      subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
      markFilteringSet: useMarkFilteringSet ? this.parseUShort() : void 0
    };
  }))) || [];
};
Parser.prototype.parseFeatureVariationsList = function() {
  return this.parsePointer32(function() {
    var majorVersion = this.parseUShort();
    var minorVersion = this.parseUShort();
    check.argument(majorVersion === 1 && minorVersion < 1, "GPOS/GSUB feature variations table unknown.");
    var featureVariations = this.parseRecordList32({
      conditionSetOffset: Parser.offset32,
      featureTableSubstitutionOffset: Parser.offset32
    });
    return featureVariations;
  }) || [];
};
var parse = {
  getByte,
  getCard8: getByte,
  getUShort,
  getCard16: getUShort,
  getShort,
  getULong,
  getFixed,
  getTag,
  getOffset,
  getBytes,
  bytesToString,
  Parser
};
function parseCmapTableFormat12(cmap2, p) {
  p.parseUShort();
  cmap2.length = p.parseULong();
  cmap2.language = p.parseULong();
  var groupCount;
  cmap2.groupCount = groupCount = p.parseULong();
  cmap2.glyphIndexMap = {};
  for (var i = 0; i < groupCount; i += 1) {
    var startCharCode = p.parseULong();
    var endCharCode = p.parseULong();
    var startGlyphId = p.parseULong();
    for (var c = startCharCode; c <= endCharCode; c += 1) {
      cmap2.glyphIndexMap[c] = startGlyphId;
      startGlyphId++;
    }
  }
}
function parseCmapTableFormat4(cmap2, p, data2, start, offset) {
  cmap2.length = p.parseUShort();
  cmap2.language = p.parseUShort();
  var segCount;
  cmap2.segCount = segCount = p.parseUShort() >> 1;
  p.skip("uShort", 3);
  cmap2.glyphIndexMap = {};
  var endCountParser = new parse.Parser(data2, start + offset + 14);
  var startCountParser = new parse.Parser(data2, start + offset + 16 + segCount * 2);
  var idDeltaParser = new parse.Parser(data2, start + offset + 16 + segCount * 4);
  var idRangeOffsetParser = new parse.Parser(data2, start + offset + 16 + segCount * 6);
  var glyphIndexOffset = start + offset + 16 + segCount * 8;
  for (var i = 0; i < segCount - 1; i += 1) {
    var glyphIndex = void 0;
    var endCount = endCountParser.parseUShort();
    var startCount = startCountParser.parseUShort();
    var idDelta = idDeltaParser.parseShort();
    var idRangeOffset = idRangeOffsetParser.parseUShort();
    for (var c = startCount; c <= endCount; c += 1) {
      if (idRangeOffset !== 0) {
        glyphIndexOffset = idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2;
        glyphIndexOffset += idRangeOffset;
        glyphIndexOffset += (c - startCount) * 2;
        glyphIndex = parse.getUShort(data2, glyphIndexOffset);
        if (glyphIndex !== 0) {
          glyphIndex = glyphIndex + idDelta & 65535;
        }
      } else {
        glyphIndex = c + idDelta & 65535;
      }
      cmap2.glyphIndexMap[c] = glyphIndex;
    }
  }
}
function parseCmapTable(data2, start) {
  var cmap2 = {};
  cmap2.version = parse.getUShort(data2, start);
  check.argument(cmap2.version === 0, "cmap table version should be 0.");
  cmap2.numTables = parse.getUShort(data2, start + 2);
  var offset = -1;
  for (var i = cmap2.numTables - 1; i >= 0; i -= 1) {
    var platformId = parse.getUShort(data2, start + 4 + i * 8);
    var encodingId = parse.getUShort(data2, start + 4 + i * 8 + 2);
    if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10) || platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4)) {
      offset = parse.getULong(data2, start + 4 + i * 8 + 4);
      break;
    }
  }
  if (offset === -1) {
    throw new Error("No valid cmap sub-tables found.");
  }
  var p = new parse.Parser(data2, start + offset);
  cmap2.format = p.parseUShort();
  if (cmap2.format === 12) {
    parseCmapTableFormat12(cmap2, p);
  } else if (cmap2.format === 4) {
    parseCmapTableFormat4(cmap2, p, data2, start, offset);
  } else {
    throw new Error("Only format 4 and 12 cmap tables are supported (found format " + cmap2.format + ").");
  }
  return cmap2;
}
function addSegment(t2, code, glyphIndex) {
  t2.segments.push({
    end: code,
    start: code,
    delta: -(code - glyphIndex),
    offset: 0,
    glyphIndex
  });
}
function addTerminatorSegment(t2) {
  t2.segments.push({
    end: 65535,
    start: 65535,
    delta: 1,
    offset: 0
  });
}
function makeCmapTable(glyphs) {
  var isPlan0Only = true;
  var i;
  for (i = glyphs.length - 1; i > 0; i -= 1) {
    var g = glyphs.get(i);
    if (g.unicode > 65535) {
      console.log("Adding CMAP format 12 (needed!)");
      isPlan0Only = false;
      break;
    }
  }
  var cmapTable = [
    { name: "version", type: "USHORT", value: 0 },
    { name: "numTables", type: "USHORT", value: isPlan0Only ? 1 : 2 },
    // CMAP 4 header
    { name: "platformID", type: "USHORT", value: 3 },
    { name: "encodingID", type: "USHORT", value: 1 },
    { name: "offset", type: "ULONG", value: isPlan0Only ? 12 : 12 + 8 }
  ];
  if (!isPlan0Only) {
    cmapTable = cmapTable.concat([
      // CMAP 12 header
      { name: "cmap12PlatformID", type: "USHORT", value: 3 },
      // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
      { name: "cmap12EncodingID", type: "USHORT", value: 10 },
      { name: "cmap12Offset", type: "ULONG", value: 0 }
    ]);
  }
  cmapTable = cmapTable.concat([
    // CMAP 4 Subtable
    { name: "format", type: "USHORT", value: 4 },
    { name: "cmap4Length", type: "USHORT", value: 0 },
    { name: "language", type: "USHORT", value: 0 },
    { name: "segCountX2", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  var t2 = new table.Table("cmap", cmapTable);
  t2.segments = [];
  for (i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs.get(i);
    for (var j = 0; j < glyph.unicodes.length; j += 1) {
      addSegment(t2, glyph.unicodes[j], i);
    }
    t2.segments = t2.segments.sort(function(a, b) {
      return a.start - b.start;
    });
  }
  addTerminatorSegment(t2);
  var segCount = t2.segments.length;
  var segCountToRemove = 0;
  var endCounts = [];
  var startCounts = [];
  var idDeltas = [];
  var idRangeOffsets = [];
  var glyphIds = [];
  var cmap12Groups = [];
  for (i = 0; i < segCount; i += 1) {
    var segment = t2.segments[i];
    if (segment.end <= 65535 && segment.start <= 65535) {
      endCounts = endCounts.concat({ name: "end_" + i, type: "USHORT", value: segment.end });
      startCounts = startCounts.concat({ name: "start_" + i, type: "USHORT", value: segment.start });
      idDeltas = idDeltas.concat({ name: "idDelta_" + i, type: "SHORT", value: segment.delta });
      idRangeOffsets = idRangeOffsets.concat({ name: "idRangeOffset_" + i, type: "USHORT", value: segment.offset });
      if (segment.glyphId !== void 0) {
        glyphIds = glyphIds.concat({ name: "glyph_" + i, type: "USHORT", value: segment.glyphId });
      }
    } else {
      segCountToRemove += 1;
    }
    if (!isPlan0Only && segment.glyphIndex !== void 0) {
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Start_" + i, type: "ULONG", value: segment.start });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12End_" + i, type: "ULONG", value: segment.end });
      cmap12Groups = cmap12Groups.concat({ name: "cmap12Glyph_" + i, type: "ULONG", value: segment.glyphIndex });
    }
  }
  t2.segCountX2 = (segCount - segCountToRemove) * 2;
  t2.searchRange = Math.pow(2, Math.floor(Math.log(segCount - segCountToRemove) / Math.log(2))) * 2;
  t2.entrySelector = Math.log(t2.searchRange / 2) / Math.log(2);
  t2.rangeShift = t2.segCountX2 - t2.searchRange;
  t2.fields = t2.fields.concat(endCounts);
  t2.fields.push({ name: "reservedPad", type: "USHORT", value: 0 });
  t2.fields = t2.fields.concat(startCounts);
  t2.fields = t2.fields.concat(idDeltas);
  t2.fields = t2.fields.concat(idRangeOffsets);
  t2.fields = t2.fields.concat(glyphIds);
  t2.cmap4Length = 14 + // Subtable header
  endCounts.length * 2 + 2 + // reservedPad
  startCounts.length * 2 + idDeltas.length * 2 + idRangeOffsets.length * 2 + glyphIds.length * 2;
  if (!isPlan0Only) {
    var cmap12Length = 16 + // Subtable header
    cmap12Groups.length * 4;
    t2.cmap12Offset = 12 + 2 * 2 + 4 + t2.cmap4Length;
    t2.fields = t2.fields.concat([
      { name: "cmap12Format", type: "USHORT", value: 12 },
      { name: "cmap12Reserved", type: "USHORT", value: 0 },
      { name: "cmap12Length", type: "ULONG", value: cmap12Length },
      { name: "cmap12Language", type: "ULONG", value: 0 },
      { name: "cmap12nGroups", type: "ULONG", value: cmap12Groups.length / 3 }
    ]);
    t2.fields = t2.fields.concat(cmap12Groups);
  }
  return t2;
}
var cmap = { parse: parseCmapTable, make: makeCmapTable };
var cffStandardStrings = [
  ".notdef",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "questiondown",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "AE",
  "ordfeminine",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "ae",
  "dotlessi",
  "lslash",
  "oslash",
  "oe",
  "germandbls",
  "onesuperior",
  "logicalnot",
  "mu",
  "trademark",
  "Eth",
  "onehalf",
  "plusminus",
  "Thorn",
  "onequarter",
  "divide",
  "brokenbar",
  "degree",
  "thorn",
  "threequarters",
  "twosuperior",
  "registered",
  "minus",
  "eth",
  "multiply",
  "threesuperior",
  "copyright",
  "Aacute",
  "Acircumflex",
  "Adieresis",
  "Agrave",
  "Aring",
  "Atilde",
  "Ccedilla",
  "Eacute",
  "Ecircumflex",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Ntilde",
  "Oacute",
  "Ocircumflex",
  "Odieresis",
  "Ograve",
  "Otilde",
  "Scaron",
  "Uacute",
  "Ucircumflex",
  "Udieresis",
  "Ugrave",
  "Yacute",
  "Ydieresis",
  "Zcaron",
  "aacute",
  "acircumflex",
  "adieresis",
  "agrave",
  "aring",
  "atilde",
  "ccedilla",
  "eacute",
  "ecircumflex",
  "edieresis",
  "egrave",
  "iacute",
  "icircumflex",
  "idieresis",
  "igrave",
  "ntilde",
  "oacute",
  "ocircumflex",
  "odieresis",
  "ograve",
  "otilde",
  "scaron",
  "uacute",
  "ucircumflex",
  "udieresis",
  "ugrave",
  "yacute",
  "ydieresis",
  "zcaron",
  "exclamsmall",
  "Hungarumlautsmall",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "266 ff",
  "onedotenleader",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "isuperior",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "ff",
  "ffi",
  "ffl",
  "parenleftinferior",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "Dotaccentsmall",
  "Macronsmall",
  "figuredash",
  "hypheninferior",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "zerosuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall",
  "001.000",
  "001.001",
  "001.002",
  "001.003",
  "Black",
  "Bold",
  "Book",
  "Light",
  "Medium",
  "Regular",
  "Roman",
  "Semibold"
];
var cffStandardEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quoteright",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "quoteleft",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdown",
  "cent",
  "sterling",
  "fraction",
  "yen",
  "florin",
  "section",
  "currency",
  "quotesingle",
  "quotedblleft",
  "guillemotleft",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "",
  "endash",
  "dagger",
  "daggerdbl",
  "periodcentered",
  "",
  "paragraph",
  "bullet",
  "quotesinglbase",
  "quotedblbase",
  "quotedblright",
  "guillemotright",
  "ellipsis",
  "perthousand",
  "",
  "questiondown",
  "",
  "grave",
  "acute",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "dieresis",
  "",
  "ring",
  "cedilla",
  "",
  "hungarumlaut",
  "ogonek",
  "caron",
  "emdash",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "AE",
  "",
  "ordfeminine",
  "",
  "",
  "",
  "",
  "Lslash",
  "Oslash",
  "OE",
  "ordmasculine",
  "",
  "",
  "",
  "",
  "",
  "ae",
  "",
  "",
  "",
  "dotlessi",
  "",
  "",
  "lslash",
  "oslash",
  "oe",
  "germandbls"
];
var cffExpertEncoding = [
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "space",
  "exclamsmall",
  "Hungarumlautsmall",
  "",
  "dollaroldstyle",
  "dollarsuperior",
  "ampersandsmall",
  "Acutesmall",
  "parenleftsuperior",
  "parenrightsuperior",
  "twodotenleader",
  "onedotenleader",
  "comma",
  "hyphen",
  "period",
  "fraction",
  "zerooldstyle",
  "oneoldstyle",
  "twooldstyle",
  "threeoldstyle",
  "fouroldstyle",
  "fiveoldstyle",
  "sixoldstyle",
  "sevenoldstyle",
  "eightoldstyle",
  "nineoldstyle",
  "colon",
  "semicolon",
  "commasuperior",
  "threequartersemdash",
  "periodsuperior",
  "questionsmall",
  "",
  "asuperior",
  "bsuperior",
  "centsuperior",
  "dsuperior",
  "esuperior",
  "",
  "",
  "isuperior",
  "",
  "",
  "lsuperior",
  "msuperior",
  "nsuperior",
  "osuperior",
  "",
  "",
  "rsuperior",
  "ssuperior",
  "tsuperior",
  "",
  "ff",
  "fi",
  "fl",
  "ffi",
  "ffl",
  "parenleftinferior",
  "",
  "parenrightinferior",
  "Circumflexsmall",
  "hyphensuperior",
  "Gravesmall",
  "Asmall",
  "Bsmall",
  "Csmall",
  "Dsmall",
  "Esmall",
  "Fsmall",
  "Gsmall",
  "Hsmall",
  "Ismall",
  "Jsmall",
  "Ksmall",
  "Lsmall",
  "Msmall",
  "Nsmall",
  "Osmall",
  "Psmall",
  "Qsmall",
  "Rsmall",
  "Ssmall",
  "Tsmall",
  "Usmall",
  "Vsmall",
  "Wsmall",
  "Xsmall",
  "Ysmall",
  "Zsmall",
  "colonmonetary",
  "onefitted",
  "rupiah",
  "Tildesmall",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "exclamdownsmall",
  "centoldstyle",
  "Lslashsmall",
  "",
  "",
  "Scaronsmall",
  "Zcaronsmall",
  "Dieresissmall",
  "Brevesmall",
  "Caronsmall",
  "",
  "Dotaccentsmall",
  "",
  "",
  "Macronsmall",
  "",
  "",
  "figuredash",
  "hypheninferior",
  "",
  "",
  "Ogoneksmall",
  "Ringsmall",
  "Cedillasmall",
  "",
  "",
  "",
  "onequarter",
  "onehalf",
  "threequarters",
  "questiondownsmall",
  "oneeighth",
  "threeeighths",
  "fiveeighths",
  "seveneighths",
  "onethird",
  "twothirds",
  "",
  "",
  "zerosuperior",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "foursuperior",
  "fivesuperior",
  "sixsuperior",
  "sevensuperior",
  "eightsuperior",
  "ninesuperior",
  "zeroinferior",
  "oneinferior",
  "twoinferior",
  "threeinferior",
  "fourinferior",
  "fiveinferior",
  "sixinferior",
  "seveninferior",
  "eightinferior",
  "nineinferior",
  "centinferior",
  "dollarinferior",
  "periodinferior",
  "commainferior",
  "Agravesmall",
  "Aacutesmall",
  "Acircumflexsmall",
  "Atildesmall",
  "Adieresissmall",
  "Aringsmall",
  "AEsmall",
  "Ccedillasmall",
  "Egravesmall",
  "Eacutesmall",
  "Ecircumflexsmall",
  "Edieresissmall",
  "Igravesmall",
  "Iacutesmall",
  "Icircumflexsmall",
  "Idieresissmall",
  "Ethsmall",
  "Ntildesmall",
  "Ogravesmall",
  "Oacutesmall",
  "Ocircumflexsmall",
  "Otildesmall",
  "Odieresissmall",
  "OEsmall",
  "Oslashsmall",
  "Ugravesmall",
  "Uacutesmall",
  "Ucircumflexsmall",
  "Udieresissmall",
  "Yacutesmall",
  "Thornsmall",
  "Ydieresissmall"
];
var standardNames = [
  ".notdef",
  ".null",
  "nonmarkingreturn",
  "space",
  "exclam",
  "quotedbl",
  "numbersign",
  "dollar",
  "percent",
  "ampersand",
  "quotesingle",
  "parenleft",
  "parenright",
  "asterisk",
  "plus",
  "comma",
  "hyphen",
  "period",
  "slash",
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "colon",
  "semicolon",
  "less",
  "equal",
  "greater",
  "question",
  "at",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "bracketleft",
  "backslash",
  "bracketright",
  "asciicircum",
  "underscore",
  "grave",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "braceleft",
  "bar",
  "braceright",
  "asciitilde",
  "Adieresis",
  "Aring",
  "Ccedilla",
  "Eacute",
  "Ntilde",
  "Odieresis",
  "Udieresis",
  "aacute",
  "agrave",
  "acircumflex",
  "adieresis",
  "atilde",
  "aring",
  "ccedilla",
  "eacute",
  "egrave",
  "ecircumflex",
  "edieresis",
  "iacute",
  "igrave",
  "icircumflex",
  "idieresis",
  "ntilde",
  "oacute",
  "ograve",
  "ocircumflex",
  "odieresis",
  "otilde",
  "uacute",
  "ugrave",
  "ucircumflex",
  "udieresis",
  "dagger",
  "degree",
  "cent",
  "sterling",
  "section",
  "bullet",
  "paragraph",
  "germandbls",
  "registered",
  "copyright",
  "trademark",
  "acute",
  "dieresis",
  "notequal",
  "AE",
  "Oslash",
  "infinity",
  "plusminus",
  "lessequal",
  "greaterequal",
  "yen",
  "mu",
  "partialdiff",
  "summation",
  "product",
  "pi",
  "integral",
  "ordfeminine",
  "ordmasculine",
  "Omega",
  "ae",
  "oslash",
  "questiondown",
  "exclamdown",
  "logicalnot",
  "radical",
  "florin",
  "approxequal",
  "Delta",
  "guillemotleft",
  "guillemotright",
  "ellipsis",
  "nonbreakingspace",
  "Agrave",
  "Atilde",
  "Otilde",
  "OE",
  "oe",
  "endash",
  "emdash",
  "quotedblleft",
  "quotedblright",
  "quoteleft",
  "quoteright",
  "divide",
  "lozenge",
  "ydieresis",
  "Ydieresis",
  "fraction",
  "currency",
  "guilsinglleft",
  "guilsinglright",
  "fi",
  "fl",
  "daggerdbl",
  "periodcentered",
  "quotesinglbase",
  "quotedblbase",
  "perthousand",
  "Acircumflex",
  "Ecircumflex",
  "Aacute",
  "Edieresis",
  "Egrave",
  "Iacute",
  "Icircumflex",
  "Idieresis",
  "Igrave",
  "Oacute",
  "Ocircumflex",
  "apple",
  "Ograve",
  "Uacute",
  "Ucircumflex",
  "Ugrave",
  "dotlessi",
  "circumflex",
  "tilde",
  "macron",
  "breve",
  "dotaccent",
  "ring",
  "cedilla",
  "hungarumlaut",
  "ogonek",
  "caron",
  "Lslash",
  "lslash",
  "Scaron",
  "scaron",
  "Zcaron",
  "zcaron",
  "brokenbar",
  "Eth",
  "eth",
  "Yacute",
  "yacute",
  "Thorn",
  "thorn",
  "minus",
  "multiply",
  "onesuperior",
  "twosuperior",
  "threesuperior",
  "onehalf",
  "onequarter",
  "threequarters",
  "franc",
  "Gbreve",
  "gbreve",
  "Idotaccent",
  "Scedilla",
  "scedilla",
  "Cacute",
  "cacute",
  "Ccaron",
  "ccaron",
  "dcroat"
];
function DefaultEncoding(font) {
  this.font = font;
}
DefaultEncoding.prototype.charToGlyphIndex = function(c) {
  var code = c.codePointAt(0);
  var glyphs = this.font.glyphs;
  if (glyphs) {
    for (var i = 0; i < glyphs.length; i += 1) {
      var glyph = glyphs.get(i);
      for (var j = 0; j < glyph.unicodes.length; j += 1) {
        if (glyph.unicodes[j] === code) {
          return i;
        }
      }
    }
  }
  return null;
};
function CmapEncoding(cmap2) {
  this.cmap = cmap2;
}
CmapEncoding.prototype.charToGlyphIndex = function(c) {
  return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
};
function CffEncoding(encoding, charset2) {
  this.encoding = encoding;
  this.charset = charset2;
}
CffEncoding.prototype.charToGlyphIndex = function(s) {
  var code = s.codePointAt(0);
  var charName = this.encoding[code];
  return this.charset.indexOf(charName);
};
function GlyphNames(post2) {
  switch (post2.version) {
    case 1:
      this.names = standardNames.slice();
      break;
    case 2:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i = 0; i < post2.numberOfGlyphs; i++) {
        if (post2.glyphNameIndex[i] < standardNames.length) {
          this.names[i] = standardNames[post2.glyphNameIndex[i]];
        } else {
          this.names[i] = post2.names[post2.glyphNameIndex[i] - standardNames.length];
        }
      }
      break;
    case 2.5:
      this.names = new Array(post2.numberOfGlyphs);
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        this.names[i$1] = standardNames[i$1 + post2.glyphNameIndex[i$1]];
      }
      break;
    case 3:
      this.names = [];
      break;
    default:
      this.names = [];
      break;
  }
}
GlyphNames.prototype.nameToGlyphIndex = function(name) {
  return this.names.indexOf(name);
};
GlyphNames.prototype.glyphIndexToName = function(gid) {
  return this.names[gid];
};
function addGlyphNamesAll(font) {
  var glyph;
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i = 0; i < charCodes.length; i += 1) {
    var c = charCodes[i];
    var glyphIndex = glyphIndexMap[c];
    glyph = font.glyphs.get(glyphIndex);
    glyph.addUnicode(parseInt(c));
  }
  for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
    glyph = font.glyphs.get(i$1);
    if (font.cffEncoding) {
      if (font.isCIDFont) {
        glyph.name = "gid" + i$1;
      } else {
        glyph.name = font.cffEncoding.charset[i$1];
      }
    } else if (font.glyphNames.names) {
      glyph.name = font.glyphNames.glyphIndexToName(i$1);
    }
  }
}
function addGlyphNamesToUnicodeMap(font) {
  font._IndexToUnicodeMap = {};
  var glyphIndexMap = font.tables.cmap.glyphIndexMap;
  var charCodes = Object.keys(glyphIndexMap);
  for (var i = 0; i < charCodes.length; i += 1) {
    var c = charCodes[i];
    var glyphIndex = glyphIndexMap[c];
    if (font._IndexToUnicodeMap[glyphIndex] === void 0) {
      font._IndexToUnicodeMap[glyphIndex] = {
        unicodes: [parseInt(c)]
      };
    } else {
      font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));
    }
  }
}
function addGlyphNames(font, opt) {
  if (opt.lowMemory) {
    addGlyphNamesToUnicodeMap(font);
  } else {
    addGlyphNamesAll(font);
  }
}
function line(ctx, x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}
var draw = { line };
function getPathDefinition(glyph, path) {
  var _path = path || new Path();
  return {
    configurable: true,
    get: function() {
      if (typeof _path === "function") {
        _path = _path();
      }
      return _path;
    },
    set: function(p) {
      _path = p;
    }
  };
}
function Glyph(options) {
  this.bindConstructorValues(options);
}
Glyph.prototype.bindConstructorValues = function(options) {
  this.index = options.index || 0;
  this.name = options.name || null;
  this.unicode = options.unicode || void 0;
  this.unicodes = options.unicodes || options.unicode !== void 0 ? [options.unicode] : [];
  if ("xMin" in options) {
    this.xMin = options.xMin;
  }
  if ("yMin" in options) {
    this.yMin = options.yMin;
  }
  if ("xMax" in options) {
    this.xMax = options.xMax;
  }
  if ("yMax" in options) {
    this.yMax = options.yMax;
  }
  if ("advanceWidth" in options) {
    this.advanceWidth = options.advanceWidth;
  }
  Object.defineProperty(this, "path", getPathDefinition(this, options.path));
};
Glyph.prototype.addUnicode = function(unicode3) {
  if (this.unicodes.length === 0) {
    this.unicode = unicode3;
  }
  this.unicodes.push(unicode3);
};
Glyph.prototype.getBoundingBox = function() {
  return this.path.getBoundingBox();
};
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  var commands;
  var hPoints;
  if (!options) {
    options = {};
  }
  var xScale = options.xScale;
  var yScale = options.yScale;
  if (options.hinting && font && font.hinting) {
    hPoints = this.path && font.hinting.exec(this, fontSize);
  }
  if (hPoints) {
    commands = font.hinting.getCommands(hPoints);
    x = Math.round(x);
    y = Math.round(y);
    xScale = yScale = 1;
  } else {
    commands = this.path.commands;
    var scale = 1 / (this.path.unitsPerEm || 1e3) * fontSize;
    if (xScale === void 0) {
      xScale = scale;
    }
    if (yScale === void 0) {
      yScale = scale;
    }
  }
  var p = new Path();
  for (var i = 0; i < commands.length; i += 1) {
    var cmd = commands[i];
    if (cmd.type === "M") {
      p.moveTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "L") {
      p.lineTo(x + cmd.x * xScale, y + -cmd.y * yScale);
    } else if (cmd.type === "Q") {
      p.quadraticCurveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "C") {
      p.curveTo(
        x + cmd.x1 * xScale,
        y + -cmd.y1 * yScale,
        x + cmd.x2 * xScale,
        y + -cmd.y2 * yScale,
        x + cmd.x * xScale,
        y + -cmd.y * yScale
      );
    } else if (cmd.type === "Z") {
      p.closePath();
    }
  }
  return p;
};
Glyph.prototype.getContours = function() {
  if (this.points === void 0) {
    return [];
  }
  var contours = [];
  var currentContour = [];
  for (var i = 0; i < this.points.length; i += 1) {
    var pt = this.points[i];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
};
Glyph.prototype.getMetrics = function() {
  var commands = this.path.commands;
  var xCoords = [];
  var yCoords = [];
  for (var i = 0; i < commands.length; i += 1) {
    var cmd = commands[i];
    if (cmd.type !== "Z") {
      xCoords.push(cmd.x);
      yCoords.push(cmd.y);
    }
    if (cmd.type === "Q" || cmd.type === "C") {
      xCoords.push(cmd.x1);
      yCoords.push(cmd.y1);
    }
    if (cmd.type === "C") {
      xCoords.push(cmd.x2);
      yCoords.push(cmd.y2);
    }
  }
  var metrics = {
    xMin: Math.min.apply(null, xCoords),
    yMin: Math.min.apply(null, yCoords),
    xMax: Math.max.apply(null, xCoords),
    yMax: Math.max.apply(null, yCoords),
    leftSideBearing: this.leftSideBearing
  };
  if (!isFinite(metrics.xMin)) {
    metrics.xMin = 0;
  }
  if (!isFinite(metrics.xMax)) {
    metrics.xMax = this.advanceWidth;
  }
  if (!isFinite(metrics.yMin)) {
    metrics.yMin = 0;
  }
  if (!isFinite(metrics.yMax)) {
    metrics.yMax = 0;
  }
  metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
  return metrics;
};
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
  this.getPath(x, y, fontSize, options).draw(ctx);
};
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
  function drawCircles(l, x2, y2, scale2) {
    ctx.beginPath();
    for (var j = 0; j < l.length; j += 1) {
      ctx.moveTo(x2 + l[j].x * scale2, y2 + l[j].y * scale2);
      ctx.arc(x2 + l[j].x * scale2, y2 + l[j].y * scale2, 2, 0, Math.PI * 2, false);
    }
    ctx.closePath();
    ctx.fill();
  }
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  var scale = 1 / this.path.unitsPerEm * fontSize;
  var blueCircles = [];
  var redCircles = [];
  var path = this.path;
  for (var i = 0; i < path.commands.length; i += 1) {
    var cmd = path.commands[i];
    if (cmd.x !== void 0) {
      blueCircles.push({ x: cmd.x, y: -cmd.y });
    }
    if (cmd.x1 !== void 0) {
      redCircles.push({ x: cmd.x1, y: -cmd.y1 });
    }
    if (cmd.x2 !== void 0) {
      redCircles.push({ x: cmd.x2, y: -cmd.y2 });
    }
  }
  ctx.fillStyle = "blue";
  drawCircles(blueCircles, x, y, scale);
  ctx.fillStyle = "red";
  drawCircles(redCircles, x, y, scale);
};
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
  var scale;
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 24;
  scale = 1 / this.path.unitsPerEm * fontSize;
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";
  draw.line(ctx, x, -1e4, x, 1e4);
  draw.line(ctx, -1e4, y, 1e4, y);
  var xMin = this.xMin || 0;
  var yMin = this.yMin || 0;
  var xMax = this.xMax || 0;
  var yMax = this.yMax || 0;
  var advanceWidth = this.advanceWidth || 0;
  ctx.strokeStyle = "blue";
  draw.line(ctx, x + xMin * scale, -1e4, x + xMin * scale, 1e4);
  draw.line(ctx, x + xMax * scale, -1e4, x + xMax * scale, 1e4);
  draw.line(ctx, -1e4, y + -yMin * scale, 1e4, y + -yMin * scale);
  draw.line(ctx, -1e4, y + -yMax * scale, 1e4, y + -yMax * scale);
  ctx.strokeStyle = "green";
  draw.line(ctx, x + advanceWidth * scale, -1e4, x + advanceWidth * scale, 1e4);
};
function defineDependentProperty(glyph, externalName, internalName) {
  Object.defineProperty(glyph, externalName, {
    get: function() {
      glyph.path;
      return glyph[internalName];
    },
    set: function(newValue) {
      glyph[internalName] = newValue;
    },
    enumerable: true,
    configurable: true
  });
}
function GlyphSet(font, glyphs) {
  this.font = font;
  this.glyphs = {};
  if (Array.isArray(glyphs)) {
    for (var i = 0; i < glyphs.length; i++) {
      var glyph = glyphs[i];
      glyph.path.unitsPerEm = font.unitsPerEm;
      this.glyphs[i] = glyph;
    }
  }
  this.length = glyphs && glyphs.length || 0;
}
GlyphSet.prototype.get = function(index) {
  if (this.glyphs[index] === void 0) {
    this.font._push(index);
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
    var glyph = this.glyphs[index];
    var unicodeObj = this.font._IndexToUnicodeMap[index];
    if (unicodeObj) {
      for (var j = 0; j < unicodeObj.unicodes.length; j++) {
        glyph.addUnicode(unicodeObj.unicodes[j]);
      }
    }
    if (this.font.cffEncoding) {
      if (this.font.isCIDFont) {
        glyph.name = "gid" + index;
      } else {
        glyph.name = this.font.cffEncoding.charset[index];
      }
    } else if (this.font.glyphNames.names) {
      glyph.name = this.font.glyphNames.glyphIndexToName(index);
    }
    this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
    this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
  } else {
    if (typeof this.glyphs[index] === "function") {
      this.glyphs[index] = this.glyphs[index]();
    }
  }
  return this.glyphs[index];
};
GlyphSet.prototype.push = function(index, loader) {
  this.glyphs[index] = loader;
  this.length++;
};
function glyphLoader(font, index) {
  return new Glyph({ index, font });
}
function ttfGlyphLoader(font, index, parseGlyph2, data2, position, buildPath2) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      parseGlyph2(glyph, data2, position);
      var path = buildPath2(font.glyphs, glyph);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    defineDependentProperty(glyph, "xMin", "_xMin");
    defineDependentProperty(glyph, "xMax", "_xMax");
    defineDependentProperty(glyph, "yMin", "_yMin");
    defineDependentProperty(glyph, "yMax", "_yMax");
    return glyph;
  };
}
function cffGlyphLoader(font, index, parseCFFCharstring2, charstring) {
  return function() {
    var glyph = new Glyph({ index, font });
    glyph.path = function() {
      var path = parseCFFCharstring2(font, glyph, charstring);
      path.unitsPerEm = font.unitsPerEm;
      return path;
    };
    return glyph;
  };
}
var glyphset = { GlyphSet, glyphLoader, ttfGlyphLoader, cffGlyphLoader };
function equals(a, b) {
  if (a === b) {
    return true;
  } else if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i += 1) {
      if (!equals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
function calcCFFSubroutineBias(subrs) {
  var bias;
  if (subrs.length < 1240) {
    bias = 107;
  } else if (subrs.length < 33900) {
    bias = 1131;
  } else {
    bias = 32768;
  }
  return bias;
}
function parseCFFIndex(data2, start, conversionFn) {
  var offsets = [];
  var objects = [];
  var count = parse.getCard16(data2, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data2, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i = 0; i < count + 1; i += 1) {
      offsets.push(parse.getOffset(data2, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
    var value = parse.getBytes(data2, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
    if (conversionFn) {
      value = conversionFn(value);
    }
    objects.push(value);
  }
  return { objects, startOffset: start, endOffset };
}
function parseCFFIndexLowMemory(data2, start) {
  var offsets = [];
  var count = parse.getCard16(data2, start);
  var objectOffset;
  var endOffset;
  if (count !== 0) {
    var offsetSize = parse.getByte(data2, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
    var pos = start + 3;
    for (var i = 0; i < count + 1; i += 1) {
      offsets.push(parse.getOffset(data2, pos, offsetSize));
      pos += offsetSize;
    }
    endOffset = objectOffset + offsets[count];
  } else {
    endOffset = start + 2;
  }
  return { offsets, startOffset: start, endOffset };
}
function getCffIndexObject(i, offsets, data2, start, conversionFn) {
  var count = parse.getCard16(data2, start);
  var objectOffset = 0;
  if (count !== 0) {
    var offsetSize = parse.getByte(data2, start + 2);
    objectOffset = start + (count + 1) * offsetSize + 2;
  }
  var value = parse.getBytes(data2, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
  if (conversionFn) {
    value = conversionFn(value);
  }
  return value;
}
function parseFloatOperand(parser) {
  var s = "";
  var eof = 15;
  var lookup = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "E", "E-", null, "-"];
  while (true) {
    var b = parser.parseByte();
    var n1 = b >> 4;
    var n2 = b & 15;
    if (n1 === eof) {
      break;
    }
    s += lookup[n1];
    if (n2 === eof) {
      break;
    }
    s += lookup[n2];
  }
  return parseFloat(s);
}
function parseOperand(parser, b0) {
  var b1;
  var b2;
  var b3;
  var b4;
  if (b0 === 28) {
    b1 = parser.parseByte();
    b2 = parser.parseByte();
    return b1 << 8 | b2;
  }
  if (b0 === 29) {
    b1 = parser.parseByte();
    b2 = parser.parseByte();
    b3 = parser.parseByte();
    b4 = parser.parseByte();
    return b1 << 24 | b2 << 16 | b3 << 8 | b4;
  }
  if (b0 === 30) {
    return parseFloatOperand(parser);
  }
  if (b0 >= 32 && b0 <= 246) {
    return b0 - 139;
  }
  if (b0 >= 247 && b0 <= 250) {
    b1 = parser.parseByte();
    return (b0 - 247) * 256 + b1 + 108;
  }
  if (b0 >= 251 && b0 <= 254) {
    b1 = parser.parseByte();
    return -(b0 - 251) * 256 - b1 - 108;
  }
  throw new Error("Invalid b0 " + b0);
}
function entriesToObject(entries) {
  var o = {};
  for (var i = 0; i < entries.length; i += 1) {
    var key = entries[i][0];
    var values = entries[i][1];
    var value = void 0;
    if (values.length === 1) {
      value = values[0];
    } else {
      value = values;
    }
    if (o.hasOwnProperty(key) && !isNaN(o[key])) {
      throw new Error("Object " + o + " already has key " + key);
    }
    o[key] = value;
  }
  return o;
}
function parseCFFDict(data2, start, size) {
  start = start !== void 0 ? start : 0;
  var parser = new parse.Parser(data2, start);
  var entries = [];
  var operands = [];
  size = size !== void 0 ? size : data2.length;
  while (parser.relativeOffset < size) {
    var op = parser.parseByte();
    if (op <= 21) {
      if (op === 12) {
        op = 1200 + parser.parseByte();
      }
      entries.push([op, operands]);
      operands = [];
    } else {
      operands.push(parseOperand(parser, op));
    }
  }
  return entriesToObject(entries);
}
function getCFFString(strings, index) {
  if (index <= 390) {
    index = cffStandardStrings[index];
  } else {
    index = strings[index - 391];
  }
  return index;
}
function interpretDict(dict, meta2, strings) {
  var newDict = {};
  var value;
  for (var i = 0; i < meta2.length; i += 1) {
    var m = meta2[i];
    if (Array.isArray(m.type)) {
      var values = [];
      values.length = m.type.length;
      for (var j = 0; j < m.type.length; j++) {
        value = dict[m.op] !== void 0 ? dict[m.op][j] : void 0;
        if (value === void 0) {
          value = m.value !== void 0 && m.value[j] !== void 0 ? m.value[j] : null;
        }
        if (m.type[j] === "SID") {
          value = getCFFString(strings, value);
        }
        values[j] = value;
      }
      newDict[m.name] = values;
    } else {
      value = dict[m.op];
      if (value === void 0) {
        value = m.value !== void 0 ? m.value : null;
      }
      if (m.type === "SID") {
        value = getCFFString(strings, value);
      }
      newDict[m.name] = value;
    }
  }
  return newDict;
}
function parseCFFHeader(data2, start) {
  var header = {};
  header.formatMajor = parse.getCard8(data2, start);
  header.formatMinor = parse.getCard8(data2, start + 1);
  header.size = parse.getCard8(data2, start + 2);
  header.offsetSize = parse.getCard8(data2, start + 3);
  header.startOffset = start;
  header.endOffset = start + 4;
  return header;
}
var TOP_DICT_META = [
  { name: "version", op: 0, type: "SID" },
  { name: "notice", op: 1, type: "SID" },
  { name: "copyright", op: 1200, type: "SID" },
  { name: "fullName", op: 2, type: "SID" },
  { name: "familyName", op: 3, type: "SID" },
  { name: "weight", op: 4, type: "SID" },
  { name: "isFixedPitch", op: 1201, type: "number", value: 0 },
  { name: "italicAngle", op: 1202, type: "number", value: 0 },
  { name: "underlinePosition", op: 1203, type: "number", value: -100 },
  { name: "underlineThickness", op: 1204, type: "number", value: 50 },
  { name: "paintType", op: 1205, type: "number", value: 0 },
  { name: "charstringType", op: 1206, type: "number", value: 2 },
  {
    name: "fontMatrix",
    op: 1207,
    type: ["real", "real", "real", "real", "real", "real"],
    value: [1e-3, 0, 0, 1e-3, 0, 0]
  },
  { name: "uniqueId", op: 13, type: "number" },
  { name: "fontBBox", op: 5, type: ["number", "number", "number", "number"], value: [0, 0, 0, 0] },
  { name: "strokeWidth", op: 1208, type: "number", value: 0 },
  { name: "xuid", op: 14, type: [], value: null },
  { name: "charset", op: 15, type: "offset", value: 0 },
  { name: "encoding", op: 16, type: "offset", value: 0 },
  { name: "charStrings", op: 17, type: "offset", value: 0 },
  { name: "private", op: 18, type: ["number", "offset"], value: [0, 0] },
  { name: "ros", op: 1230, type: ["SID", "SID", "number"] },
  { name: "cidFontVersion", op: 1231, type: "number", value: 0 },
  { name: "cidFontRevision", op: 1232, type: "number", value: 0 },
  { name: "cidFontType", op: 1233, type: "number", value: 0 },
  { name: "cidCount", op: 1234, type: "number", value: 8720 },
  { name: "uidBase", op: 1235, type: "number" },
  { name: "fdArray", op: 1236, type: "offset" },
  { name: "fdSelect", op: 1237, type: "offset" },
  { name: "fontName", op: 1238, type: "SID" }
];
var PRIVATE_DICT_META = [
  { name: "subrs", op: 19, type: "offset", value: 0 },
  { name: "defaultWidthX", op: 20, type: "number", value: 0 },
  { name: "nominalWidthX", op: 21, type: "number", value: 0 }
];
function parseCFFTopDict(data2, strings) {
  var dict = parseCFFDict(data2, 0, data2.byteLength);
  return interpretDict(dict, TOP_DICT_META, strings);
}
function parseCFFPrivateDict(data2, start, size, strings) {
  var dict = parseCFFDict(data2, start, size);
  return interpretDict(dict, PRIVATE_DICT_META, strings);
}
function gatherCFFTopDicts(data2, start, cffIndex, strings) {
  var topDictArray = [];
  for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
    var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
    var topDict = parseCFFTopDict(topDictData, strings);
    topDict._subrs = [];
    topDict._subrsBias = 0;
    topDict._defaultWidthX = 0;
    topDict._nominalWidthX = 0;
    var privateSize = topDict.private[0];
    var privateOffset = topDict.private[1];
    if (privateSize !== 0 && privateOffset !== 0) {
      var privateDict = parseCFFPrivateDict(data2, privateOffset + start, privateSize, strings);
      topDict._defaultWidthX = privateDict.defaultWidthX;
      topDict._nominalWidthX = privateDict.nominalWidthX;
      if (privateDict.subrs !== 0) {
        var subrOffset = privateOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data2, subrOffset + start);
        topDict._subrs = subrIndex.objects;
        topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
      }
      topDict._privateDict = privateDict;
    }
    topDictArray.push(topDict);
  }
  return topDictArray;
}
function parseCFFCharset(data2, start, nGlyphs, strings) {
  var sid;
  var count;
  var parser = new parse.Parser(data2, start);
  nGlyphs -= 1;
  var charset2 = [".notdef"];
  var format = parser.parseCard8();
  if (format === 0) {
    for (var i = 0; i < nGlyphs; i += 1) {
      sid = parser.parseSID();
      charset2.push(getCFFString(strings, sid));
    }
  } else if (format === 1) {
    while (charset2.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard8();
      for (var i$1 = 0; i$1 <= count; i$1 += 1) {
        charset2.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else if (format === 2) {
    while (charset2.length <= nGlyphs) {
      sid = parser.parseSID();
      count = parser.parseCard16();
      for (var i$2 = 0; i$2 <= count; i$2 += 1) {
        charset2.push(getCFFString(strings, sid));
        sid += 1;
      }
    }
  } else {
    throw new Error("Unknown charset format " + format);
  }
  return charset2;
}
function parseCFFEncoding(data2, start, charset2) {
  var code;
  var enc = {};
  var parser = new parse.Parser(data2, start);
  var format = parser.parseCard8();
  if (format === 0) {
    var nCodes = parser.parseCard8();
    for (var i = 0; i < nCodes; i += 1) {
      code = parser.parseCard8();
      enc[code] = i;
    }
  } else if (format === 1) {
    var nRanges = parser.parseCard8();
    code = 1;
    for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
      var first2 = parser.parseCard8();
      var nLeft = parser.parseCard8();
      for (var j = first2; j <= first2 + nLeft; j += 1) {
        enc[j] = code;
        code += 1;
      }
    }
  } else {
    throw new Error("Unknown encoding format " + format);
  }
  return new CffEncoding(enc, charset2);
}
function parseCFFCharstring(font, glyph, code) {
  var c1x;
  var c1y;
  var c2x;
  var c2y;
  var p = new Path();
  var stack = [];
  var nStems = 0;
  var haveWidth = false;
  var open = false;
  var x = 0;
  var y = 0;
  var subrs;
  var subrsBias;
  var defaultWidthX;
  var nominalWidthX;
  if (font.isCIDFont) {
    var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
    var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
    subrs = fdDict._subrs;
    subrsBias = fdDict._subrsBias;
    defaultWidthX = fdDict._defaultWidthX;
    nominalWidthX = fdDict._nominalWidthX;
  } else {
    subrs = font.tables.cff.topDict._subrs;
    subrsBias = font.tables.cff.topDict._subrsBias;
    defaultWidthX = font.tables.cff.topDict._defaultWidthX;
    nominalWidthX = font.tables.cff.topDict._nominalWidthX;
  }
  var width = defaultWidthX;
  function newContour(x2, y2) {
    if (open) {
      p.closePath();
    }
    p.moveTo(x2, y2);
    open = true;
  }
  function parseStems() {
    var hasWidthArg;
    hasWidthArg = stack.length % 2 !== 0;
    if (hasWidthArg && !haveWidth) {
      width = stack.shift() + nominalWidthX;
    }
    nStems += stack.length >> 1;
    stack.length = 0;
    haveWidth = true;
  }
  function parse2(code2) {
    var b1;
    var b2;
    var b3;
    var b4;
    var codeIndex;
    var subrCode;
    var jpx;
    var jpy;
    var c3x;
    var c3y;
    var c4x;
    var c4y;
    var i = 0;
    while (i < code2.length) {
      var v = code2[i];
      i += 1;
      switch (v) {
        case 1:
          parseStems();
          break;
        case 3:
          parseStems();
          break;
        case 4:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          newContour(x, y);
          break;
        case 5:
          while (stack.length > 0) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 6:
          while (stack.length > 0) {
            x += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            y += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 7:
          while (stack.length > 0) {
            y += stack.shift();
            p.lineTo(x, y);
            if (stack.length === 0) {
              break;
            }
            x += stack.shift();
            p.lineTo(x, y);
          }
          break;
        case 8:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 10:
          codeIndex = stack.pop() + subrsBias;
          subrCode = subrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 11:
          return;
        case 12:
          v = code2[i];
          i += 1;
          switch (v) {
            case 35:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              y = c4y + stack.shift();
              stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 34:
              c1x = x + stack.shift();
              c1y = y;
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = y;
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 36:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y;
              c3x = jpx + stack.shift();
              c3y = c2y;
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              x = c4x + stack.shift();
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            case 37:
              c1x = x + stack.shift();
              c1y = y + stack.shift();
              c2x = c1x + stack.shift();
              c2y = c1y + stack.shift();
              jpx = c2x + stack.shift();
              jpy = c2y + stack.shift();
              c3x = jpx + stack.shift();
              c3y = jpy + stack.shift();
              c4x = c3x + stack.shift();
              c4y = c3y + stack.shift();
              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                x = c4x + stack.shift();
              } else {
                y = c4y + stack.shift();
              }
              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
              p.curveTo(c3x, c3y, c4x, c4y, x, y);
              break;
            default:
              console.log("Glyph " + glyph.index + ": unknown operator 1200" + v);
              stack.length = 0;
          }
          break;
        case 14:
          if (stack.length > 0 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          if (open) {
            p.closePath();
            open = false;
          }
          break;
        case 18:
          parseStems();
          break;
        case 19:
        // hintmask
        case 20:
          parseStems();
          i += nStems + 7 >> 3;
          break;
        case 21:
          if (stack.length > 2 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          y += stack.pop();
          x += stack.pop();
          newContour(x, y);
          break;
        case 22:
          if (stack.length > 1 && !haveWidth) {
            width = stack.shift() + nominalWidthX;
            haveWidth = true;
          }
          x += stack.pop();
          newContour(x, y);
          break;
        case 23:
          parseStems();
          break;
        case 24:
          while (stack.length > 2) {
            c1x = x + stack.shift();
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          x += stack.shift();
          y += stack.shift();
          p.lineTo(x, y);
          break;
        case 25:
          while (stack.length > 6) {
            x += stack.shift();
            y += stack.shift();
            p.lineTo(x, y);
          }
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y + stack.shift();
          p.curveTo(c1x, c1y, c2x, c2y, x, y);
          break;
        case 26:
          if (stack.length % 2) {
            x += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x;
            y = c2y + stack.shift();
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 27:
          if (stack.length % 2) {
            y += stack.shift();
          }
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y;
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 28:
          b1 = code2[i];
          b2 = code2[i + 1];
          stack.push((b1 << 24 | b2 << 16) >> 16);
          i += 2;
          break;
        case 29:
          codeIndex = stack.pop() + font.gsubrsBias;
          subrCode = font.gsubrs[codeIndex];
          if (subrCode) {
            parse2(subrCode);
          }
          break;
        case 30:
          while (stack.length > 0) {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        case 31:
          while (stack.length > 0) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            x = c2x + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
            if (stack.length === 0) {
              break;
            }
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            y = c2y + (stack.length === 1 ? stack.shift() : 0);
            p.curveTo(c1x, c1y, c2x, c2y, x, y);
          }
          break;
        default:
          if (v < 32) {
            console.log("Glyph " + glyph.index + ": unknown operator " + v);
          } else if (v < 247) {
            stack.push(v - 139);
          } else if (v < 251) {
            b1 = code2[i];
            i += 1;
            stack.push((v - 247) * 256 + b1 + 108);
          } else if (v < 255) {
            b1 = code2[i];
            i += 1;
            stack.push(-(v - 251) * 256 - b1 - 108);
          } else {
            b1 = code2[i];
            b2 = code2[i + 1];
            b3 = code2[i + 2];
            b4 = code2[i + 3];
            i += 4;
            stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);
          }
      }
    }
  }
  parse2(code);
  glyph.advanceWidth = width;
  return p;
}
function parseCFFFDSelect(data2, start, nGlyphs, fdArrayCount) {
  var fdSelect = [];
  var fdIndex;
  var parser = new parse.Parser(data2, start);
  var format = parser.parseCard8();
  if (format === 0) {
    for (var iGid = 0; iGid < nGlyphs; iGid++) {
      fdIndex = parser.parseCard8();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      fdSelect.push(fdIndex);
    }
  } else if (format === 3) {
    var nRanges = parser.parseCard16();
    var first2 = parser.parseCard16();
    if (first2 !== 0) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad initial GID " + first2);
    }
    var next;
    for (var iRange = 0; iRange < nRanges; iRange++) {
      fdIndex = parser.parseCard8();
      next = parser.parseCard16();
      if (fdIndex >= fdArrayCount) {
        throw new Error("CFF table CID Font FDSelect has bad FD index value " + fdIndex + " (FD count " + fdArrayCount + ")");
      }
      if (next > nGlyphs) {
        throw new Error("CFF Table CID Font FDSelect format 3 range has bad GID " + next);
      }
      for (; first2 < next; first2++) {
        fdSelect.push(fdIndex);
      }
      first2 = next;
    }
    if (next !== nGlyphs) {
      throw new Error("CFF Table CID Font FDSelect format 3 range has bad final GID " + next);
    }
  } else {
    throw new Error("CFF Table CID Font FDSelect table has unsupported format " + format);
  }
  return fdSelect;
}
function parseCFFTable(data2, start, font, opt) {
  font.tables.cff = {};
  var header = parseCFFHeader(data2, start);
  var nameIndex = parseCFFIndex(data2, header.endOffset, parse.bytesToString);
  var topDictIndex = parseCFFIndex(data2, nameIndex.endOffset);
  var stringIndex = parseCFFIndex(data2, topDictIndex.endOffset, parse.bytesToString);
  var globalSubrIndex = parseCFFIndex(data2, stringIndex.endOffset);
  font.gsubrs = globalSubrIndex.objects;
  font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);
  var topDictArray = gatherCFFTopDicts(data2, start, topDictIndex.objects, stringIndex.objects);
  if (topDictArray.length !== 1) {
    throw new Error("CFF table has too many fonts in 'FontSet' - count of fonts NameIndex.length = " + topDictArray.length);
  }
  var topDict = topDictArray[0];
  font.tables.cff.topDict = topDict;
  if (topDict._privateDict) {
    font.defaultWidthX = topDict._privateDict.defaultWidthX;
    font.nominalWidthX = topDict._privateDict.nominalWidthX;
  }
  if (topDict.ros[0] !== void 0 && topDict.ros[1] !== void 0) {
    font.isCIDFont = true;
  }
  if (font.isCIDFont) {
    var fdArrayOffset = topDict.fdArray;
    var fdSelectOffset = topDict.fdSelect;
    if (fdArrayOffset === 0 || fdSelectOffset === 0) {
      throw new Error("Font is marked as a CID font, but FDArray and/or FDSelect information is missing");
    }
    fdArrayOffset += start;
    var fdArrayIndex = parseCFFIndex(data2, fdArrayOffset);
    var fdArray = gatherCFFTopDicts(data2, start, fdArrayIndex.objects, stringIndex.objects);
    topDict._fdArray = fdArray;
    fdSelectOffset += start;
    topDict._fdSelect = parseCFFFDSelect(data2, fdSelectOffset, font.numGlyphs, fdArray.length);
  }
  var privateDictOffset = start + topDict.private[1];
  var privateDict = parseCFFPrivateDict(data2, privateDictOffset, topDict.private[0], stringIndex.objects);
  font.defaultWidthX = privateDict.defaultWidthX;
  font.nominalWidthX = privateDict.nominalWidthX;
  if (privateDict.subrs !== 0) {
    var subrOffset = privateDictOffset + privateDict.subrs;
    var subrIndex = parseCFFIndex(data2, subrOffset);
    font.subrs = subrIndex.objects;
    font.subrsBias = calcCFFSubroutineBias(font.subrs);
  } else {
    font.subrs = [];
    font.subrsBias = 0;
  }
  var charStringsIndex;
  if (opt.lowMemory) {
    charStringsIndex = parseCFFIndexLowMemory(data2, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.offsets.length;
  } else {
    charStringsIndex = parseCFFIndex(data2, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;
  }
  var charset2 = parseCFFCharset(data2, start + topDict.charset, font.nGlyphs, stringIndex.objects);
  if (topDict.encoding === 0) {
    font.cffEncoding = new CffEncoding(cffStandardEncoding, charset2);
  } else if (topDict.encoding === 1) {
    font.cffEncoding = new CffEncoding(cffExpertEncoding, charset2);
  } else {
    font.cffEncoding = parseCFFEncoding(data2, start + topDict.encoding, charset2);
  }
  font.encoding = font.encoding || font.cffEncoding;
  font.glyphs = new glyphset.GlyphSet(font);
  if (opt.lowMemory) {
    font._push = function(i2) {
      var charString2 = getCffIndexObject(i2, charStringsIndex.offsets, data2, start + topDict.charStrings);
      font.glyphs.push(i2, glyphset.cffGlyphLoader(font, i2, parseCFFCharstring, charString2));
    };
  } else {
    for (var i = 0; i < font.nGlyphs; i += 1) {
      var charString = charStringsIndex.objects[i];
      font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
  }
}
function encodeString(s, strings) {
  var sid;
  var i = cffStandardStrings.indexOf(s);
  if (i >= 0) {
    sid = i;
  }
  i = strings.indexOf(s);
  if (i >= 0) {
    sid = i + cffStandardStrings.length;
  } else {
    sid = cffStandardStrings.length + strings.length;
    strings.push(s);
  }
  return sid;
}
function makeHeader() {
  return new table.Record("Header", [
    { name: "major", type: "Card8", value: 1 },
    { name: "minor", type: "Card8", value: 0 },
    { name: "hdrSize", type: "Card8", value: 4 },
    { name: "major", type: "Card8", value: 1 }
  ]);
}
function makeNameIndex(fontNames) {
  var t2 = new table.Record("Name INDEX", [
    { name: "names", type: "INDEX", value: [] }
  ]);
  t2.names = [];
  for (var i = 0; i < fontNames.length; i += 1) {
    t2.names.push({ name: "name_" + i, type: "NAME", value: fontNames[i] });
  }
  return t2;
}
function makeDict(meta2, attrs, strings) {
  var m = {};
  for (var i = 0; i < meta2.length; i += 1) {
    var entry = meta2[i];
    var value = attrs[entry.name];
    if (value !== void 0 && !equals(value, entry.value)) {
      if (entry.type === "SID") {
        value = encodeString(value, strings);
      }
      m[entry.op] = { name: entry.name, type: entry.type, value };
    }
  }
  return m;
}
function makeTopDict(attrs, strings) {
  var t2 = new table.Record("Top DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t2.dict = makeDict(TOP_DICT_META, attrs, strings);
  return t2;
}
function makeTopDictIndex(topDict) {
  var t2 = new table.Record("Top DICT INDEX", [
    { name: "topDicts", type: "INDEX", value: [] }
  ]);
  t2.topDicts = [{ name: "topDict_0", type: "TABLE", value: topDict }];
  return t2;
}
function makeStringIndex(strings) {
  var t2 = new table.Record("String INDEX", [
    { name: "strings", type: "INDEX", value: [] }
  ]);
  t2.strings = [];
  for (var i = 0; i < strings.length; i += 1) {
    t2.strings.push({ name: "string_" + i, type: "STRING", value: strings[i] });
  }
  return t2;
}
function makeGlobalSubrIndex() {
  return new table.Record("Global Subr INDEX", [
    { name: "subrs", type: "INDEX", value: [] }
  ]);
}
function makeCharsets(glyphNames, strings) {
  var t2 = new table.Record("Charsets", [
    { name: "format", type: "Card8", value: 0 }
  ]);
  for (var i = 0; i < glyphNames.length; i += 1) {
    var glyphName = glyphNames[i];
    var glyphSID = encodeString(glyphName, strings);
    t2.fields.push({ name: "glyph_" + i, type: "SID", value: glyphSID });
  }
  return t2;
}
function glyphToOps(glyph) {
  var ops = [];
  var path = glyph.path;
  ops.push({ name: "width", type: "NUMBER", value: glyph.advanceWidth });
  var x = 0;
  var y = 0;
  for (var i = 0; i < path.commands.length; i += 1) {
    var dx = void 0;
    var dy = void 0;
    var cmd = path.commands[i];
    if (cmd.type === "Q") {
      var _1310 = 1 / 3;
      var _2310 = 2 / 3;
      cmd = {
        type: "C",
        x: cmd.x,
        y: cmd.y,
        x1: Math.round(_1310 * x + _2310 * cmd.x1),
        y1: Math.round(_1310 * y + _2310 * cmd.y1),
        x2: Math.round(_1310 * cmd.x + _2310 * cmd.x1),
        y2: Math.round(_1310 * cmd.y + _2310 * cmd.y1)
      };
    }
    if (cmd.type === "M") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rmoveto", type: "OP", value: 21 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "L") {
      dx = Math.round(cmd.x - x);
      dy = Math.round(cmd.y - y);
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rlineto", type: "OP", value: 5 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    } else if (cmd.type === "C") {
      var dx1 = Math.round(cmd.x1 - x);
      var dy1 = Math.round(cmd.y1 - y);
      var dx2 = Math.round(cmd.x2 - cmd.x1);
      var dy2 = Math.round(cmd.y2 - cmd.y1);
      dx = Math.round(cmd.x - cmd.x2);
      dy = Math.round(cmd.y - cmd.y2);
      ops.push({ name: "dx1", type: "NUMBER", value: dx1 });
      ops.push({ name: "dy1", type: "NUMBER", value: dy1 });
      ops.push({ name: "dx2", type: "NUMBER", value: dx2 });
      ops.push({ name: "dy2", type: "NUMBER", value: dy2 });
      ops.push({ name: "dx", type: "NUMBER", value: dx });
      ops.push({ name: "dy", type: "NUMBER", value: dy });
      ops.push({ name: "rrcurveto", type: "OP", value: 8 });
      x = Math.round(cmd.x);
      y = Math.round(cmd.y);
    }
  }
  ops.push({ name: "endchar", type: "OP", value: 14 });
  return ops;
}
function makeCharStringsIndex(glyphs) {
  var t2 = new table.Record("CharStrings INDEX", [
    { name: "charStrings", type: "INDEX", value: [] }
  ]);
  for (var i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs.get(i);
    var ops = glyphToOps(glyph);
    t2.charStrings.push({ name: glyph.name, type: "CHARSTRING", value: ops });
  }
  return t2;
}
function makePrivateDict(attrs, strings) {
  var t2 = new table.Record("Private DICT", [
    { name: "dict", type: "DICT", value: {} }
  ]);
  t2.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
  return t2;
}
function makeCFFTable(glyphs, options) {
  var t2 = new table.Table("CFF ", [
    { name: "header", type: "RECORD" },
    { name: "nameIndex", type: "RECORD" },
    { name: "topDictIndex", type: "RECORD" },
    { name: "stringIndex", type: "RECORD" },
    { name: "globalSubrIndex", type: "RECORD" },
    { name: "charsets", type: "RECORD" },
    { name: "charStringsIndex", type: "RECORD" },
    { name: "privateDict", type: "RECORD" }
  ]);
  var fontScale = 1 / options.unitsPerEm;
  var attrs = {
    version: options.version,
    fullName: options.fullName,
    familyName: options.familyName,
    weight: options.weightName,
    fontBBox: options.fontBBox || [0, 0, 0, 0],
    fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
    charset: 999,
    encoding: 0,
    charStrings: 999,
    private: [0, 999]
  };
  var privateAttrs = {};
  var glyphNames = [];
  var glyph;
  for (var i = 1; i < glyphs.length; i += 1) {
    glyph = glyphs.get(i);
    glyphNames.push(glyph.name);
  }
  var strings = [];
  t2.header = makeHeader();
  t2.nameIndex = makeNameIndex([options.postScriptName]);
  var topDict = makeTopDict(attrs, strings);
  t2.topDictIndex = makeTopDictIndex(topDict);
  t2.globalSubrIndex = makeGlobalSubrIndex();
  t2.charsets = makeCharsets(glyphNames, strings);
  t2.charStringsIndex = makeCharStringsIndex(glyphs);
  t2.privateDict = makePrivateDict(privateAttrs, strings);
  t2.stringIndex = makeStringIndex(strings);
  var startOffset = t2.header.sizeOf() + t2.nameIndex.sizeOf() + t2.topDictIndex.sizeOf() + t2.stringIndex.sizeOf() + t2.globalSubrIndex.sizeOf();
  attrs.charset = startOffset;
  attrs.encoding = 0;
  attrs.charStrings = attrs.charset + t2.charsets.sizeOf();
  attrs.private[1] = attrs.charStrings + t2.charStringsIndex.sizeOf();
  topDict = makeTopDict(attrs, strings);
  t2.topDictIndex = makeTopDictIndex(topDict);
  return t2;
}
var cff = { parse: parseCFFTable, make: makeCFFTable };
function parseHeadTable(data2, start) {
  var head2 = {};
  var p = new parse.Parser(data2, start);
  head2.version = p.parseVersion();
  head2.fontRevision = Math.round(p.parseFixed() * 1e3) / 1e3;
  head2.checkSumAdjustment = p.parseULong();
  head2.magicNumber = p.parseULong();
  check.argument(head2.magicNumber === 1594834165, "Font header has wrong magic number.");
  head2.flags = p.parseUShort();
  head2.unitsPerEm = p.parseUShort();
  head2.created = p.parseLongDateTime();
  head2.modified = p.parseLongDateTime();
  head2.xMin = p.parseShort();
  head2.yMin = p.parseShort();
  head2.xMax = p.parseShort();
  head2.yMax = p.parseShort();
  head2.macStyle = p.parseUShort();
  head2.lowestRecPPEM = p.parseUShort();
  head2.fontDirectionHint = p.parseShort();
  head2.indexToLocFormat = p.parseShort();
  head2.glyphDataFormat = p.parseShort();
  return head2;
}
function makeHeadTable(options) {
  var timestamp = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) + 2082844800;
  var createdTimestamp = timestamp;
  if (options.createdTimestamp) {
    createdTimestamp = options.createdTimestamp + 2082844800;
  }
  return new table.Table("head", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "fontRevision", type: "FIXED", value: 65536 },
    { name: "checkSumAdjustment", type: "ULONG", value: 0 },
    { name: "magicNumber", type: "ULONG", value: 1594834165 },
    { name: "flags", type: "USHORT", value: 0 },
    { name: "unitsPerEm", type: "USHORT", value: 1e3 },
    { name: "created", type: "LONGDATETIME", value: createdTimestamp },
    { name: "modified", type: "LONGDATETIME", value: timestamp },
    { name: "xMin", type: "SHORT", value: 0 },
    { name: "yMin", type: "SHORT", value: 0 },
    { name: "xMax", type: "SHORT", value: 0 },
    { name: "yMax", type: "SHORT", value: 0 },
    { name: "macStyle", type: "USHORT", value: 0 },
    { name: "lowestRecPPEM", type: "USHORT", value: 0 },
    { name: "fontDirectionHint", type: "SHORT", value: 2 },
    { name: "indexToLocFormat", type: "SHORT", value: 0 },
    { name: "glyphDataFormat", type: "SHORT", value: 0 }
  ], options);
}
var head = { parse: parseHeadTable, make: makeHeadTable };
function parseHheaTable(data2, start) {
  var hhea2 = {};
  var p = new parse.Parser(data2, start);
  hhea2.version = p.parseVersion();
  hhea2.ascender = p.parseShort();
  hhea2.descender = p.parseShort();
  hhea2.lineGap = p.parseShort();
  hhea2.advanceWidthMax = p.parseUShort();
  hhea2.minLeftSideBearing = p.parseShort();
  hhea2.minRightSideBearing = p.parseShort();
  hhea2.xMaxExtent = p.parseShort();
  hhea2.caretSlopeRise = p.parseShort();
  hhea2.caretSlopeRun = p.parseShort();
  hhea2.caretOffset = p.parseShort();
  p.relativeOffset += 8;
  hhea2.metricDataFormat = p.parseShort();
  hhea2.numberOfHMetrics = p.parseUShort();
  return hhea2;
}
function makeHheaTable(options) {
  return new table.Table("hhea", [
    { name: "version", type: "FIXED", value: 65536 },
    { name: "ascender", type: "FWORD", value: 0 },
    { name: "descender", type: "FWORD", value: 0 },
    { name: "lineGap", type: "FWORD", value: 0 },
    { name: "advanceWidthMax", type: "UFWORD", value: 0 },
    { name: "minLeftSideBearing", type: "FWORD", value: 0 },
    { name: "minRightSideBearing", type: "FWORD", value: 0 },
    { name: "xMaxExtent", type: "FWORD", value: 0 },
    { name: "caretSlopeRise", type: "SHORT", value: 1 },
    { name: "caretSlopeRun", type: "SHORT", value: 0 },
    { name: "caretOffset", type: "SHORT", value: 0 },
    { name: "reserved1", type: "SHORT", value: 0 },
    { name: "reserved2", type: "SHORT", value: 0 },
    { name: "reserved3", type: "SHORT", value: 0 },
    { name: "reserved4", type: "SHORT", value: 0 },
    { name: "metricDataFormat", type: "SHORT", value: 0 },
    { name: "numberOfHMetrics", type: "USHORT", value: 0 }
  ], options);
}
var hhea = { parse: parseHheaTable, make: makeHheaTable };
function parseHmtxTableAll(data2, start, numMetrics, numGlyphs, glyphs) {
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data2, start);
  for (var i = 0; i < numGlyphs; i += 1) {
    if (i < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    var glyph = glyphs.get(i);
    glyph.advanceWidth = advanceWidth;
    glyph.leftSideBearing = leftSideBearing;
  }
}
function parseHmtxTableOnLowMemory(font, data2, start, numMetrics, numGlyphs) {
  font._hmtxTableData = {};
  var advanceWidth;
  var leftSideBearing;
  var p = new parse.Parser(data2, start);
  for (var i = 0; i < numGlyphs; i += 1) {
    if (i < numMetrics) {
      advanceWidth = p.parseUShort();
      leftSideBearing = p.parseShort();
    }
    font._hmtxTableData[i] = {
      advanceWidth,
      leftSideBearing
    };
  }
}
function parseHmtxTable(font, data2, start, numMetrics, numGlyphs, glyphs, opt) {
  if (opt.lowMemory) {
    parseHmtxTableOnLowMemory(font, data2, start, numMetrics, numGlyphs);
  } else {
    parseHmtxTableAll(data2, start, numMetrics, numGlyphs, glyphs);
  }
}
function makeHmtxTable(glyphs) {
  var t2 = new table.Table("hmtx", []);
  for (var i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs.get(i);
    var advanceWidth = glyph.advanceWidth || 0;
    var leftSideBearing = glyph.leftSideBearing || 0;
    t2.fields.push({ name: "advanceWidth_" + i, type: "USHORT", value: advanceWidth });
    t2.fields.push({ name: "leftSideBearing_" + i, type: "SHORT", value: leftSideBearing });
  }
  return t2;
}
var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };
function makeLtagTable(tags) {
  var result = new table.Table("ltag", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "numTags", type: "ULONG", value: tags.length }
  ]);
  var stringPool = "";
  var stringPoolOffset = 12 + tags.length * 4;
  for (var i = 0; i < tags.length; ++i) {
    var pos = stringPool.indexOf(tags[i]);
    if (pos < 0) {
      pos = stringPool.length;
      stringPool += tags[i];
    }
    result.fields.push({ name: "offset " + i, type: "USHORT", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + i, type: "USHORT", value: tags[i].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
function parseLtagTable(data2, start) {
  var p = new parse.Parser(data2, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported ltag table version.");
  p.skip("uLong", 1);
  var numTags = p.parseULong();
  var tags = [];
  for (var i = 0; i < numTags; i++) {
    var tag = "";
    var offset = start + p.parseUShort();
    var length = p.parseUShort();
    for (var j = offset; j < offset + length; ++j) {
      tag += String.fromCharCode(data2.getInt8(j));
    }
    tags.push(tag);
  }
  return tags;
}
var ltag = { make: makeLtagTable, parse: parseLtagTable };
function parseMaxpTable(data2, start) {
  var maxp2 = {};
  var p = new parse.Parser(data2, start);
  maxp2.version = p.parseVersion();
  maxp2.numGlyphs = p.parseUShort();
  if (maxp2.version === 1) {
    maxp2.maxPoints = p.parseUShort();
    maxp2.maxContours = p.parseUShort();
    maxp2.maxCompositePoints = p.parseUShort();
    maxp2.maxCompositeContours = p.parseUShort();
    maxp2.maxZones = p.parseUShort();
    maxp2.maxTwilightPoints = p.parseUShort();
    maxp2.maxStorage = p.parseUShort();
    maxp2.maxFunctionDefs = p.parseUShort();
    maxp2.maxInstructionDefs = p.parseUShort();
    maxp2.maxStackElements = p.parseUShort();
    maxp2.maxSizeOfInstructions = p.parseUShort();
    maxp2.maxComponentElements = p.parseUShort();
    maxp2.maxComponentDepth = p.parseUShort();
  }
  return maxp2;
}
function makeMaxpTable(numGlyphs) {
  return new table.Table("maxp", [
    { name: "version", type: "FIXED", value: 20480 },
    { name: "numGlyphs", type: "USHORT", value: numGlyphs }
  ]);
}
var maxp = { parse: parseMaxpTable, make: makeMaxpTable };
var nameTableNames = [
  "copyright",
  // 0
  "fontFamily",
  // 1
  "fontSubfamily",
  // 2
  "uniqueID",
  // 3
  "fullName",
  // 4
  "version",
  // 5
  "postScriptName",
  // 6
  "trademark",
  // 7
  "manufacturer",
  // 8
  "designer",
  // 9
  "description",
  // 10
  "manufacturerURL",
  // 11
  "designerURL",
  // 12
  "license",
  // 13
  "licenseURL",
  // 14
  "reserved",
  // 15
  "preferredFamily",
  // 16
  "preferredSubfamily",
  // 17
  "compatibleFullName",
  // 18
  "sampleText",
  // 19
  "postScriptFindFontName",
  // 20
  "wwsFamily",
  // 21
  "wwsSubfamily"
  // 22
];
var macLanguages = {
  0: "en",
  1: "fr",
  2: "de",
  3: "it",
  4: "nl",
  5: "sv",
  6: "es",
  7: "da",
  8: "pt",
  9: "no",
  10: "he",
  11: "ja",
  12: "ar",
  13: "fi",
  14: "el",
  15: "is",
  16: "mt",
  17: "tr",
  18: "hr",
  19: "zh-Hant",
  20: "ur",
  21: "hi",
  22: "th",
  23: "ko",
  24: "lt",
  25: "pl",
  26: "hu",
  27: "es",
  28: "lv",
  29: "se",
  30: "fo",
  31: "fa",
  32: "ru",
  33: "zh",
  34: "nl-BE",
  35: "ga",
  36: "sq",
  37: "ro",
  38: "cz",
  39: "sk",
  40: "si",
  41: "yi",
  42: "sr",
  43: "mk",
  44: "bg",
  45: "uk",
  46: "be",
  47: "uz",
  48: "kk",
  49: "az-Cyrl",
  50: "az-Arab",
  51: "hy",
  52: "ka",
  53: "mo",
  54: "ky",
  55: "tg",
  56: "tk",
  57: "mn-CN",
  58: "mn",
  59: "ps",
  60: "ks",
  61: "ku",
  62: "sd",
  63: "bo",
  64: "ne",
  65: "sa",
  66: "mr",
  67: "bn",
  68: "as",
  69: "gu",
  70: "pa",
  71: "or",
  72: "ml",
  73: "kn",
  74: "ta",
  75: "te",
  76: "si",
  77: "my",
  78: "km",
  79: "lo",
  80: "vi",
  81: "id",
  82: "tl",
  83: "ms",
  84: "ms-Arab",
  85: "am",
  86: "ti",
  87: "om",
  88: "so",
  89: "sw",
  90: "rw",
  91: "rn",
  92: "ny",
  93: "mg",
  94: "eo",
  128: "cy",
  129: "eu",
  130: "ca",
  131: "la",
  132: "qu",
  133: "gn",
  134: "ay",
  135: "tt",
  136: "ug",
  137: "dz",
  138: "jv",
  139: "su",
  140: "gl",
  141: "af",
  142: "br",
  143: "iu",
  144: "gd",
  145: "gv",
  146: "ga",
  147: "to",
  148: "el-polyton",
  149: "kl",
  150: "az",
  151: "nn"
};
var macLanguageToScript = {
  0: 0,
  // langEnglish → smRoman
  1: 0,
  // langFrench → smRoman
  2: 0,
  // langGerman → smRoman
  3: 0,
  // langItalian → smRoman
  4: 0,
  // langDutch → smRoman
  5: 0,
  // langSwedish → smRoman
  6: 0,
  // langSpanish → smRoman
  7: 0,
  // langDanish → smRoman
  8: 0,
  // langPortuguese → smRoman
  9: 0,
  // langNorwegian → smRoman
  10: 5,
  // langHebrew → smHebrew
  11: 1,
  // langJapanese → smJapanese
  12: 4,
  // langArabic → smArabic
  13: 0,
  // langFinnish → smRoman
  14: 6,
  // langGreek → smGreek
  15: 0,
  // langIcelandic → smRoman (modified)
  16: 0,
  // langMaltese → smRoman
  17: 0,
  // langTurkish → smRoman (modified)
  18: 0,
  // langCroatian → smRoman (modified)
  19: 2,
  // langTradChinese → smTradChinese
  20: 4,
  // langUrdu → smArabic
  21: 9,
  // langHindi → smDevanagari
  22: 21,
  // langThai → smThai
  23: 3,
  // langKorean → smKorean
  24: 29,
  // langLithuanian → smCentralEuroRoman
  25: 29,
  // langPolish → smCentralEuroRoman
  26: 29,
  // langHungarian → smCentralEuroRoman
  27: 29,
  // langEstonian → smCentralEuroRoman
  28: 29,
  // langLatvian → smCentralEuroRoman
  29: 0,
  // langSami → smRoman
  30: 0,
  // langFaroese → smRoman (modified)
  31: 4,
  // langFarsi → smArabic (modified)
  32: 7,
  // langRussian → smCyrillic
  33: 25,
  // langSimpChinese → smSimpChinese
  34: 0,
  // langFlemish → smRoman
  35: 0,
  // langIrishGaelic → smRoman (modified)
  36: 0,
  // langAlbanian → smRoman
  37: 0,
  // langRomanian → smRoman (modified)
  38: 29,
  // langCzech → smCentralEuroRoman
  39: 29,
  // langSlovak → smCentralEuroRoman
  40: 0,
  // langSlovenian → smRoman (modified)
  41: 5,
  // langYiddish → smHebrew
  42: 7,
  // langSerbian → smCyrillic
  43: 7,
  // langMacedonian → smCyrillic
  44: 7,
  // langBulgarian → smCyrillic
  45: 7,
  // langUkrainian → smCyrillic (modified)
  46: 7,
  // langByelorussian → smCyrillic
  47: 7,
  // langUzbek → smCyrillic
  48: 7,
  // langKazakh → smCyrillic
  49: 7,
  // langAzerbaijani → smCyrillic
  50: 4,
  // langAzerbaijanAr → smArabic
  51: 24,
  // langArmenian → smArmenian
  52: 23,
  // langGeorgian → smGeorgian
  53: 7,
  // langMoldavian → smCyrillic
  54: 7,
  // langKirghiz → smCyrillic
  55: 7,
  // langTajiki → smCyrillic
  56: 7,
  // langTurkmen → smCyrillic
  57: 27,
  // langMongolian → smMongolian
  58: 7,
  // langMongolianCyr → smCyrillic
  59: 4,
  // langPashto → smArabic
  60: 4,
  // langKurdish → smArabic
  61: 4,
  // langKashmiri → smArabic
  62: 4,
  // langSindhi → smArabic
  63: 26,
  // langTibetan → smTibetan
  64: 9,
  // langNepali → smDevanagari
  65: 9,
  // langSanskrit → smDevanagari
  66: 9,
  // langMarathi → smDevanagari
  67: 13,
  // langBengali → smBengali
  68: 13,
  // langAssamese → smBengali
  69: 11,
  // langGujarati → smGujarati
  70: 10,
  // langPunjabi → smGurmukhi
  71: 12,
  // langOriya → smOriya
  72: 17,
  // langMalayalam → smMalayalam
  73: 16,
  // langKannada → smKannada
  74: 14,
  // langTamil → smTamil
  75: 15,
  // langTelugu → smTelugu
  76: 18,
  // langSinhalese → smSinhalese
  77: 19,
  // langBurmese → smBurmese
  78: 20,
  // langKhmer → smKhmer
  79: 22,
  // langLao → smLao
  80: 30,
  // langVietnamese → smVietnamese
  81: 0,
  // langIndonesian → smRoman
  82: 0,
  // langTagalog → smRoman
  83: 0,
  // langMalayRoman → smRoman
  84: 4,
  // langMalayArabic → smArabic
  85: 28,
  // langAmharic → smEthiopic
  86: 28,
  // langTigrinya → smEthiopic
  87: 28,
  // langOromo → smEthiopic
  88: 0,
  // langSomali → smRoman
  89: 0,
  // langSwahili → smRoman
  90: 0,
  // langKinyarwanda → smRoman
  91: 0,
  // langRundi → smRoman
  92: 0,
  // langNyanja → smRoman
  93: 0,
  // langMalagasy → smRoman
  94: 0,
  // langEsperanto → smRoman
  128: 0,
  // langWelsh → smRoman (modified)
  129: 0,
  // langBasque → smRoman
  130: 0,
  // langCatalan → smRoman
  131: 0,
  // langLatin → smRoman
  132: 0,
  // langQuechua → smRoman
  133: 0,
  // langGuarani → smRoman
  134: 0,
  // langAymara → smRoman
  135: 7,
  // langTatar → smCyrillic
  136: 4,
  // langUighur → smArabic
  137: 26,
  // langDzongkha → smTibetan
  138: 0,
  // langJavaneseRom → smRoman
  139: 0,
  // langSundaneseRom → smRoman
  140: 0,
  // langGalician → smRoman
  141: 0,
  // langAfrikaans → smRoman
  142: 0,
  // langBreton → smRoman (modified)
  143: 28,
  // langInuktitut → smEthiopic (modified)
  144: 0,
  // langScottishGaelic → smRoman (modified)
  145: 0,
  // langManxGaelic → smRoman (modified)
  146: 0,
  // langIrishGaelicScript → smRoman (modified)
  147: 0,
  // langTongan → smRoman
  148: 6,
  // langGreekAncient → smRoman
  149: 0,
  // langGreenlandic → smRoman
  150: 0,
  // langAzerbaijanRoman → smRoman
  151: 0
  // langNynorsk → smRoman
};
var windowsLanguages = {
  1078: "af",
  1052: "sq",
  1156: "gsw",
  1118: "am",
  5121: "ar-DZ",
  15361: "ar-BH",
  3073: "ar",
  2049: "ar-IQ",
  11265: "ar-JO",
  13313: "ar-KW",
  12289: "ar-LB",
  4097: "ar-LY",
  6145: "ary",
  8193: "ar-OM",
  16385: "ar-QA",
  1025: "ar-SA",
  10241: "ar-SY",
  7169: "aeb",
  14337: "ar-AE",
  9217: "ar-YE",
  1067: "hy",
  1101: "as",
  2092: "az-Cyrl",
  1068: "az",
  1133: "ba",
  1069: "eu",
  1059: "be",
  2117: "bn",
  1093: "bn-IN",
  8218: "bs-Cyrl",
  5146: "bs",
  1150: "br",
  1026: "bg",
  1027: "ca",
  3076: "zh-HK",
  5124: "zh-MO",
  2052: "zh",
  4100: "zh-SG",
  1028: "zh-TW",
  1155: "co",
  1050: "hr",
  4122: "hr-BA",
  1029: "cs",
  1030: "da",
  1164: "prs",
  1125: "dv",
  2067: "nl-BE",
  1043: "nl",
  3081: "en-AU",
  10249: "en-BZ",
  4105: "en-CA",
  9225: "en-029",
  16393: "en-IN",
  6153: "en-IE",
  8201: "en-JM",
  17417: "en-MY",
  5129: "en-NZ",
  13321: "en-PH",
  18441: "en-SG",
  7177: "en-ZA",
  11273: "en-TT",
  2057: "en-GB",
  1033: "en",
  12297: "en-ZW",
  1061: "et",
  1080: "fo",
  1124: "fil",
  1035: "fi",
  2060: "fr-BE",
  3084: "fr-CA",
  1036: "fr",
  5132: "fr-LU",
  6156: "fr-MC",
  4108: "fr-CH",
  1122: "fy",
  1110: "gl",
  1079: "ka",
  3079: "de-AT",
  1031: "de",
  5127: "de-LI",
  4103: "de-LU",
  2055: "de-CH",
  1032: "el",
  1135: "kl",
  1095: "gu",
  1128: "ha",
  1037: "he",
  1081: "hi",
  1038: "hu",
  1039: "is",
  1136: "ig",
  1057: "id",
  1117: "iu",
  2141: "iu-Latn",
  2108: "ga",
  1076: "xh",
  1077: "zu",
  1040: "it",
  2064: "it-CH",
  1041: "ja",
  1099: "kn",
  1087: "kk",
  1107: "km",
  1158: "quc",
  1159: "rw",
  1089: "sw",
  1111: "kok",
  1042: "ko",
  1088: "ky",
  1108: "lo",
  1062: "lv",
  1063: "lt",
  2094: "dsb",
  1134: "lb",
  1071: "mk",
  2110: "ms-BN",
  1086: "ms",
  1100: "ml",
  1082: "mt",
  1153: "mi",
  1146: "arn",
  1102: "mr",
  1148: "moh",
  1104: "mn",
  2128: "mn-CN",
  1121: "ne",
  1044: "nb",
  2068: "nn",
  1154: "oc",
  1096: "or",
  1123: "ps",
  1045: "pl",
  1046: "pt",
  2070: "pt-PT",
  1094: "pa",
  1131: "qu-BO",
  2155: "qu-EC",
  3179: "qu",
  1048: "ro",
  1047: "rm",
  1049: "ru",
  9275: "smn",
  4155: "smj-NO",
  5179: "smj",
  3131: "se-FI",
  1083: "se",
  2107: "se-SE",
  8251: "sms",
  6203: "sma-NO",
  7227: "sms",
  1103: "sa",
  7194: "sr-Cyrl-BA",
  3098: "sr",
  6170: "sr-Latn-BA",
  2074: "sr-Latn",
  1132: "nso",
  1074: "tn",
  1115: "si",
  1051: "sk",
  1060: "sl",
  11274: "es-AR",
  16394: "es-BO",
  13322: "es-CL",
  9226: "es-CO",
  5130: "es-CR",
  7178: "es-DO",
  12298: "es-EC",
  17418: "es-SV",
  4106: "es-GT",
  18442: "es-HN",
  2058: "es-MX",
  19466: "es-NI",
  6154: "es-PA",
  15370: "es-PY",
  10250: "es-PE",
  20490: "es-PR",
  // Microsoft has defined two different language codes for
  // “Spanish with modern sorting” and “Spanish with traditional
  // sorting”. This makes sense for collation APIs, and it would be
  // possible to express this in BCP 47 language tags via Unicode
  // extensions (eg., es-u-co-trad is Spanish with traditional
  // sorting). However, for storing names in fonts, the distinction
  // does not make sense, so we give “es” in both cases.
  3082: "es",
  1034: "es",
  21514: "es-US",
  14346: "es-UY",
  8202: "es-VE",
  2077: "sv-FI",
  1053: "sv",
  1114: "syr",
  1064: "tg",
  2143: "tzm",
  1097: "ta",
  1092: "tt",
  1098: "te",
  1054: "th",
  1105: "bo",
  1055: "tr",
  1090: "tk",
  1152: "ug",
  1058: "uk",
  1070: "hsb",
  1056: "ur",
  2115: "uz-Cyrl",
  1091: "uz",
  1066: "vi",
  1106: "cy",
  1160: "wo",
  1157: "sah",
  1144: "ii",
  1130: "yo"
};
function getLanguageCode(platformID, languageID, ltag2) {
  switch (platformID) {
    case 0:
      if (languageID === 65535) {
        return "und";
      } else if (ltag2) {
        return ltag2[languageID];
      }
      break;
    case 1:
      return macLanguages[languageID];
    case 3:
      return windowsLanguages[languageID];
  }
  return void 0;
}
var utf16 = "utf-16";
var macScriptEncodings = {
  0: "macintosh",
  // smRoman
  1: "x-mac-japanese",
  // smJapanese
  2: "x-mac-chinesetrad",
  // smTradChinese
  3: "x-mac-korean",
  // smKorean
  6: "x-mac-greek",
  // smGreek
  7: "x-mac-cyrillic",
  // smCyrillic
  9: "x-mac-devanagai",
  // smDevanagari
  10: "x-mac-gurmukhi",
  // smGurmukhi
  11: "x-mac-gujarati",
  // smGujarati
  12: "x-mac-oriya",
  // smOriya
  13: "x-mac-bengali",
  // smBengali
  14: "x-mac-tamil",
  // smTamil
  15: "x-mac-telugu",
  // smTelugu
  16: "x-mac-kannada",
  // smKannada
  17: "x-mac-malayalam",
  // smMalayalam
  18: "x-mac-sinhalese",
  // smSinhalese
  19: "x-mac-burmese",
  // smBurmese
  20: "x-mac-khmer",
  // smKhmer
  21: "x-mac-thai",
  // smThai
  22: "x-mac-lao",
  // smLao
  23: "x-mac-georgian",
  // smGeorgian
  24: "x-mac-armenian",
  // smArmenian
  25: "x-mac-chinesesimp",
  // smSimpChinese
  26: "x-mac-tibetan",
  // smTibetan
  27: "x-mac-mongolian",
  // smMongolian
  28: "x-mac-ethiopic",
  // smEthiopic
  29: "x-mac-ce",
  // smCentralEuroRoman
  30: "x-mac-vietnamese",
  // smVietnamese
  31: "x-mac-extarabic"
  // smExtArabic
};
var macLanguageEncodings = {
  15: "x-mac-icelandic",
  // langIcelandic
  17: "x-mac-turkish",
  // langTurkish
  18: "x-mac-croatian",
  // langCroatian
  24: "x-mac-ce",
  // langLithuanian
  25: "x-mac-ce",
  // langPolish
  26: "x-mac-ce",
  // langHungarian
  27: "x-mac-ce",
  // langEstonian
  28: "x-mac-ce",
  // langLatvian
  30: "x-mac-icelandic",
  // langFaroese
  37: "x-mac-romanian",
  // langRomanian
  38: "x-mac-ce",
  // langCzech
  39: "x-mac-ce",
  // langSlovak
  40: "x-mac-ce",
  // langSlovenian
  143: "x-mac-inuit",
  // langInuktitut
  146: "x-mac-gaelic"
  // langIrishGaelicScript
};
function getEncoding(platformID, encodingID, languageID) {
  switch (platformID) {
    case 0:
      return utf16;
    case 1:
      return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];
    case 3:
      if (encodingID === 1 || encodingID === 10) {
        return utf16;
      }
      break;
  }
  return void 0;
}
function parseNameTable(data2, start, ltag2) {
  var name = {};
  var p = new parse.Parser(data2, start);
  var format = p.parseUShort();
  var count = p.parseUShort();
  var stringOffset = p.offset + p.parseUShort();
  for (var i = 0; i < count; i++) {
    var platformID = p.parseUShort();
    var encodingID = p.parseUShort();
    var languageID = p.parseUShort();
    var nameID = p.parseUShort();
    var property = nameTableNames[nameID] || nameID;
    var byteLength = p.parseUShort();
    var offset = p.parseUShort();
    var language = getLanguageCode(platformID, languageID, ltag2);
    var encoding = getEncoding(platformID, encodingID, languageID);
    if (encoding !== void 0 && language !== void 0) {
      var text = void 0;
      if (encoding === utf16) {
        text = decode.UTF16(data2, stringOffset + offset, byteLength);
      } else {
        text = decode.MACSTRING(data2, stringOffset + offset, byteLength, encoding);
      }
      if (text) {
        var translations = name[property];
        if (translations === void 0) {
          translations = name[property] = {};
        }
        translations[language] = text;
      }
    }
  }
  var langTagCount = 0;
  if (format === 1) {
    langTagCount = p.parseUShort();
  }
  return name;
}
function reverseDict(dict) {
  var result = {};
  for (var key in dict) {
    result[dict[key]] = parseInt(key);
  }
  return result;
}
function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
  return new table.Record("NameRecord", [
    { name: "platformID", type: "USHORT", value: platformID },
    { name: "encodingID", type: "USHORT", value: encodingID },
    { name: "languageID", type: "USHORT", value: languageID },
    { name: "nameID", type: "USHORT", value: nameID },
    { name: "length", type: "USHORT", value: length },
    { name: "offset", type: "USHORT", value: offset }
  ]);
}
function findSubArray(needle, haystack) {
  var needleLength = needle.length;
  var limit = haystack.length - needleLength + 1;
  loop:
    for (var pos = 0; pos < limit; pos++) {
      for (; pos < limit; pos++) {
        for (var k = 0; k < needleLength; k++) {
          if (haystack[pos + k] !== needle[k]) {
            continue loop;
          }
        }
        return pos;
      }
    }
  return -1;
}
function addStringToPool(s, pool) {
  var offset = findSubArray(s, pool);
  if (offset < 0) {
    offset = pool.length;
    var i = 0;
    var len = s.length;
    for (; i < len; ++i) {
      pool.push(s[i]);
    }
  }
  return offset;
}
function makeNameTable(names, ltag2) {
  var nameID;
  var nameIDs = [];
  var namesWithNumericKeys = {};
  var nameTableIds = reverseDict(nameTableNames);
  for (var key in names) {
    var id = nameTableIds[key];
    if (id === void 0) {
      id = key;
    }
    nameID = parseInt(id);
    if (isNaN(nameID)) {
      throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
    }
    namesWithNumericKeys[nameID] = names[key];
    nameIDs.push(nameID);
  }
  var macLanguageIds = reverseDict(macLanguages);
  var windowsLanguageIds = reverseDict(windowsLanguages);
  var nameRecords = [];
  var stringPool = [];
  for (var i = 0; i < nameIDs.length; i++) {
    nameID = nameIDs[i];
    var translations = namesWithNumericKeys[nameID];
    for (var lang in translations) {
      var text = translations[lang];
      var macPlatform = 1;
      var macLanguage = macLanguageIds[lang];
      var macScript = macLanguageToScript[macLanguage];
      var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
      var macName = encode.MACSTRING(text, macEncoding);
      if (macName === void 0) {
        macPlatform = 0;
        macLanguage = ltag2.indexOf(lang);
        if (macLanguage < 0) {
          macLanguage = ltag2.length;
          ltag2.push(lang);
        }
        macScript = 4;
        macName = encode.UTF16(text);
      }
      var macNameOffset = addStringToPool(macName, stringPool);
      nameRecords.push(makeNameRecord(
        macPlatform,
        macScript,
        macLanguage,
        nameID,
        macName.length,
        macNameOffset
      ));
      var winLanguage = windowsLanguageIds[lang];
      if (winLanguage !== void 0) {
        var winName = encode.UTF16(text);
        var winNameOffset = addStringToPool(winName, stringPool);
        nameRecords.push(makeNameRecord(
          3,
          1,
          winLanguage,
          nameID,
          winName.length,
          winNameOffset
        ));
      }
    }
  }
  nameRecords.sort(function(a, b) {
    return a.platformID - b.platformID || a.encodingID - b.encodingID || a.languageID - b.languageID || a.nameID - b.nameID;
  });
  var t2 = new table.Table("name", [
    { name: "format", type: "USHORT", value: 0 },
    { name: "count", type: "USHORT", value: nameRecords.length },
    { name: "stringOffset", type: "USHORT", value: 6 + nameRecords.length * 12 }
  ]);
  for (var r = 0; r < nameRecords.length; r++) {
    t2.fields.push({ name: "record_" + r, type: "RECORD", value: nameRecords[r] });
  }
  t2.fields.push({ name: "strings", type: "LITERAL", value: stringPool });
  return t2;
}
var _name = { parse: parseNameTable, make: makeNameTable };
var unicodeRanges = [
  { begin: 0, end: 127 },
  // Basic Latin
  { begin: 128, end: 255 },
  // Latin-1 Supplement
  { begin: 256, end: 383 },
  // Latin Extended-A
  { begin: 384, end: 591 },
  // Latin Extended-B
  { begin: 592, end: 687 },
  // IPA Extensions
  { begin: 688, end: 767 },
  // Spacing Modifier Letters
  { begin: 768, end: 879 },
  // Combining Diacritical Marks
  { begin: 880, end: 1023 },
  // Greek and Coptic
  { begin: 11392, end: 11519 },
  // Coptic
  { begin: 1024, end: 1279 },
  // Cyrillic
  { begin: 1328, end: 1423 },
  // Armenian
  { begin: 1424, end: 1535 },
  // Hebrew
  { begin: 42240, end: 42559 },
  // Vai
  { begin: 1536, end: 1791 },
  // Arabic
  { begin: 1984, end: 2047 },
  // NKo
  { begin: 2304, end: 2431 },
  // Devanagari
  { begin: 2432, end: 2559 },
  // Bengali
  { begin: 2560, end: 2687 },
  // Gurmukhi
  { begin: 2688, end: 2815 },
  // Gujarati
  { begin: 2816, end: 2943 },
  // Oriya
  { begin: 2944, end: 3071 },
  // Tamil
  { begin: 3072, end: 3199 },
  // Telugu
  { begin: 3200, end: 3327 },
  // Kannada
  { begin: 3328, end: 3455 },
  // Malayalam
  { begin: 3584, end: 3711 },
  // Thai
  { begin: 3712, end: 3839 },
  // Lao
  { begin: 4256, end: 4351 },
  // Georgian
  { begin: 6912, end: 7039 },
  // Balinese
  { begin: 4352, end: 4607 },
  // Hangul Jamo
  { begin: 7680, end: 7935 },
  // Latin Extended Additional
  { begin: 7936, end: 8191 },
  // Greek Extended
  { begin: 8192, end: 8303 },
  // General Punctuation
  { begin: 8304, end: 8351 },
  // Superscripts And Subscripts
  { begin: 8352, end: 8399 },
  // Currency Symbol
  { begin: 8400, end: 8447 },
  // Combining Diacritical Marks For Symbols
  { begin: 8448, end: 8527 },
  // Letterlike Symbols
  { begin: 8528, end: 8591 },
  // Number Forms
  { begin: 8592, end: 8703 },
  // Arrows
  { begin: 8704, end: 8959 },
  // Mathematical Operators
  { begin: 8960, end: 9215 },
  // Miscellaneous Technical
  { begin: 9216, end: 9279 },
  // Control Pictures
  { begin: 9280, end: 9311 },
  // Optical Character Recognition
  { begin: 9312, end: 9471 },
  // Enclosed Alphanumerics
  { begin: 9472, end: 9599 },
  // Box Drawing
  { begin: 9600, end: 9631 },
  // Block Elements
  { begin: 9632, end: 9727 },
  // Geometric Shapes
  { begin: 9728, end: 9983 },
  // Miscellaneous Symbols
  { begin: 9984, end: 10175 },
  // Dingbats
  { begin: 12288, end: 12351 },
  // CJK Symbols And Punctuation
  { begin: 12352, end: 12447 },
  // Hiragana
  { begin: 12448, end: 12543 },
  // Katakana
  { begin: 12544, end: 12591 },
  // Bopomofo
  { begin: 12592, end: 12687 },
  // Hangul Compatibility Jamo
  { begin: 43072, end: 43135 },
  // Phags-pa
  { begin: 12800, end: 13055 },
  // Enclosed CJK Letters And Months
  { begin: 13056, end: 13311 },
  // CJK Compatibility
  { begin: 44032, end: 55215 },
  // Hangul Syllables
  { begin: 55296, end: 57343 },
  // Non-Plane 0 *
  { begin: 67840, end: 67871 },
  // Phoenicia
  { begin: 19968, end: 40959 },
  // CJK Unified Ideographs
  { begin: 57344, end: 63743 },
  // Private Use Area (plane 0)
  { begin: 12736, end: 12783 },
  // CJK Strokes
  { begin: 64256, end: 64335 },
  // Alphabetic Presentation Forms
  { begin: 64336, end: 65023 },
  // Arabic Presentation Forms-A
  { begin: 65056, end: 65071 },
  // Combining Half Marks
  { begin: 65040, end: 65055 },
  // Vertical Forms
  { begin: 65104, end: 65135 },
  // Small Form Variants
  { begin: 65136, end: 65279 },
  // Arabic Presentation Forms-B
  { begin: 65280, end: 65519 },
  // Halfwidth And Fullwidth Forms
  { begin: 65520, end: 65535 },
  // Specials
  { begin: 3840, end: 4095 },
  // Tibetan
  { begin: 1792, end: 1871 },
  // Syriac
  { begin: 1920, end: 1983 },
  // Thaana
  { begin: 3456, end: 3583 },
  // Sinhala
  { begin: 4096, end: 4255 },
  // Myanmar
  { begin: 4608, end: 4991 },
  // Ethiopic
  { begin: 5024, end: 5119 },
  // Cherokee
  { begin: 5120, end: 5759 },
  // Unified Canadian Aboriginal Syllabics
  { begin: 5760, end: 5791 },
  // Ogham
  { begin: 5792, end: 5887 },
  // Runic
  { begin: 6016, end: 6143 },
  // Khmer
  { begin: 6144, end: 6319 },
  // Mongolian
  { begin: 10240, end: 10495 },
  // Braille Patterns
  { begin: 40960, end: 42127 },
  // Yi Syllables
  { begin: 5888, end: 5919 },
  // Tagalog
  { begin: 66304, end: 66351 },
  // Old Italic
  { begin: 66352, end: 66383 },
  // Gothic
  { begin: 66560, end: 66639 },
  // Deseret
  { begin: 118784, end: 119039 },
  // Byzantine Musical Symbols
  { begin: 119808, end: 120831 },
  // Mathematical Alphanumeric Symbols
  { begin: 1044480, end: 1048573 },
  // Private Use (plane 15)
  { begin: 65024, end: 65039 },
  // Variation Selectors
  { begin: 917504, end: 917631 },
  // Tags
  { begin: 6400, end: 6479 },
  // Limbu
  { begin: 6480, end: 6527 },
  // Tai Le
  { begin: 6528, end: 6623 },
  // New Tai Lue
  { begin: 6656, end: 6687 },
  // Buginese
  { begin: 11264, end: 11359 },
  // Glagolitic
  { begin: 11568, end: 11647 },
  // Tifinagh
  { begin: 19904, end: 19967 },
  // Yijing Hexagram Symbols
  { begin: 43008, end: 43055 },
  // Syloti Nagri
  { begin: 65536, end: 65663 },
  // Linear B Syllabary
  { begin: 65856, end: 65935 },
  // Ancient Greek Numbers
  { begin: 66432, end: 66463 },
  // Ugaritic
  { begin: 66464, end: 66527 },
  // Old Persian
  { begin: 66640, end: 66687 },
  // Shavian
  { begin: 66688, end: 66735 },
  // Osmanya
  { begin: 67584, end: 67647 },
  // Cypriot Syllabary
  { begin: 68096, end: 68191 },
  // Kharoshthi
  { begin: 119552, end: 119647 },
  // Tai Xuan Jing Symbols
  { begin: 73728, end: 74751 },
  // Cuneiform
  { begin: 119648, end: 119679 },
  // Counting Rod Numerals
  { begin: 7040, end: 7103 },
  // Sundanese
  { begin: 7168, end: 7247 },
  // Lepcha
  { begin: 7248, end: 7295 },
  // Ol Chiki
  { begin: 43136, end: 43231 },
  // Saurashtra
  { begin: 43264, end: 43311 },
  // Kayah Li
  { begin: 43312, end: 43359 },
  // Rejang
  { begin: 43520, end: 43615 },
  // Cham
  { begin: 65936, end: 65999 },
  // Ancient Symbols
  { begin: 66e3, end: 66047 },
  // Phaistos Disc
  { begin: 66208, end: 66271 },
  // Carian
  { begin: 127024, end: 127135 }
  // Domino Tiles
];
function getUnicodeRange(unicode3) {
  for (var i = 0; i < unicodeRanges.length; i += 1) {
    var range = unicodeRanges[i];
    if (unicode3 >= range.begin && unicode3 < range.end) {
      return i;
    }
  }
  return -1;
}
function parseOS2Table(data2, start) {
  var os22 = {};
  var p = new parse.Parser(data2, start);
  os22.version = p.parseUShort();
  os22.xAvgCharWidth = p.parseShort();
  os22.usWeightClass = p.parseUShort();
  os22.usWidthClass = p.parseUShort();
  os22.fsType = p.parseUShort();
  os22.ySubscriptXSize = p.parseShort();
  os22.ySubscriptYSize = p.parseShort();
  os22.ySubscriptXOffset = p.parseShort();
  os22.ySubscriptYOffset = p.parseShort();
  os22.ySuperscriptXSize = p.parseShort();
  os22.ySuperscriptYSize = p.parseShort();
  os22.ySuperscriptXOffset = p.parseShort();
  os22.ySuperscriptYOffset = p.parseShort();
  os22.yStrikeoutSize = p.parseShort();
  os22.yStrikeoutPosition = p.parseShort();
  os22.sFamilyClass = p.parseShort();
  os22.panose = [];
  for (var i = 0; i < 10; i++) {
    os22.panose[i] = p.parseByte();
  }
  os22.ulUnicodeRange1 = p.parseULong();
  os22.ulUnicodeRange2 = p.parseULong();
  os22.ulUnicodeRange3 = p.parseULong();
  os22.ulUnicodeRange4 = p.parseULong();
  os22.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
  os22.fsSelection = p.parseUShort();
  os22.usFirstCharIndex = p.parseUShort();
  os22.usLastCharIndex = p.parseUShort();
  os22.sTypoAscender = p.parseShort();
  os22.sTypoDescender = p.parseShort();
  os22.sTypoLineGap = p.parseShort();
  os22.usWinAscent = p.parseUShort();
  os22.usWinDescent = p.parseUShort();
  if (os22.version >= 1) {
    os22.ulCodePageRange1 = p.parseULong();
    os22.ulCodePageRange2 = p.parseULong();
  }
  if (os22.version >= 2) {
    os22.sxHeight = p.parseShort();
    os22.sCapHeight = p.parseShort();
    os22.usDefaultChar = p.parseUShort();
    os22.usBreakChar = p.parseUShort();
    os22.usMaxContent = p.parseUShort();
  }
  return os22;
}
function makeOS2Table(options) {
  return new table.Table("OS/2", [
    { name: "version", type: "USHORT", value: 3 },
    { name: "xAvgCharWidth", type: "SHORT", value: 0 },
    { name: "usWeightClass", type: "USHORT", value: 0 },
    { name: "usWidthClass", type: "USHORT", value: 0 },
    { name: "fsType", type: "USHORT", value: 0 },
    { name: "ySubscriptXSize", type: "SHORT", value: 650 },
    { name: "ySubscriptYSize", type: "SHORT", value: 699 },
    { name: "ySubscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySubscriptYOffset", type: "SHORT", value: 140 },
    { name: "ySuperscriptXSize", type: "SHORT", value: 650 },
    { name: "ySuperscriptYSize", type: "SHORT", value: 699 },
    { name: "ySuperscriptXOffset", type: "SHORT", value: 0 },
    { name: "ySuperscriptYOffset", type: "SHORT", value: 479 },
    { name: "yStrikeoutSize", type: "SHORT", value: 49 },
    { name: "yStrikeoutPosition", type: "SHORT", value: 258 },
    { name: "sFamilyClass", type: "SHORT", value: 0 },
    { name: "bFamilyType", type: "BYTE", value: 0 },
    { name: "bSerifStyle", type: "BYTE", value: 0 },
    { name: "bWeight", type: "BYTE", value: 0 },
    { name: "bProportion", type: "BYTE", value: 0 },
    { name: "bContrast", type: "BYTE", value: 0 },
    { name: "bStrokeVariation", type: "BYTE", value: 0 },
    { name: "bArmStyle", type: "BYTE", value: 0 },
    { name: "bLetterform", type: "BYTE", value: 0 },
    { name: "bMidline", type: "BYTE", value: 0 },
    { name: "bXHeight", type: "BYTE", value: 0 },
    { name: "ulUnicodeRange1", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange2", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange3", type: "ULONG", value: 0 },
    { name: "ulUnicodeRange4", type: "ULONG", value: 0 },
    { name: "achVendID", type: "CHARARRAY", value: "XXXX" },
    { name: "fsSelection", type: "USHORT", value: 0 },
    { name: "usFirstCharIndex", type: "USHORT", value: 0 },
    { name: "usLastCharIndex", type: "USHORT", value: 0 },
    { name: "sTypoAscender", type: "SHORT", value: 0 },
    { name: "sTypoDescender", type: "SHORT", value: 0 },
    { name: "sTypoLineGap", type: "SHORT", value: 0 },
    { name: "usWinAscent", type: "USHORT", value: 0 },
    { name: "usWinDescent", type: "USHORT", value: 0 },
    { name: "ulCodePageRange1", type: "ULONG", value: 0 },
    { name: "ulCodePageRange2", type: "ULONG", value: 0 },
    { name: "sxHeight", type: "SHORT", value: 0 },
    { name: "sCapHeight", type: "SHORT", value: 0 },
    { name: "usDefaultChar", type: "USHORT", value: 0 },
    { name: "usBreakChar", type: "USHORT", value: 0 },
    { name: "usMaxContext", type: "USHORT", value: 0 }
  ], options);
}
var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges, getUnicodeRange };
function parsePostTable(data2, start) {
  var post2 = {};
  var p = new parse.Parser(data2, start);
  post2.version = p.parseVersion();
  post2.italicAngle = p.parseFixed();
  post2.underlinePosition = p.parseShort();
  post2.underlineThickness = p.parseShort();
  post2.isFixedPitch = p.parseULong();
  post2.minMemType42 = p.parseULong();
  post2.maxMemType42 = p.parseULong();
  post2.minMemType1 = p.parseULong();
  post2.maxMemType1 = p.parseULong();
  switch (post2.version) {
    case 1:
      post2.names = standardNames.slice();
      break;
    case 2:
      post2.numberOfGlyphs = p.parseUShort();
      post2.glyphNameIndex = new Array(post2.numberOfGlyphs);
      for (var i = 0; i < post2.numberOfGlyphs; i++) {
        post2.glyphNameIndex[i] = p.parseUShort();
      }
      post2.names = [];
      for (var i$1 = 0; i$1 < post2.numberOfGlyphs; i$1++) {
        if (post2.glyphNameIndex[i$1] >= standardNames.length) {
          var nameLength = p.parseChar();
          post2.names.push(p.parseString(nameLength));
        }
      }
      break;
    case 2.5:
      post2.numberOfGlyphs = p.parseUShort();
      post2.offset = new Array(post2.numberOfGlyphs);
      for (var i$2 = 0; i$2 < post2.numberOfGlyphs; i$2++) {
        post2.offset[i$2] = p.parseChar();
      }
      break;
  }
  return post2;
}
function makePostTable() {
  return new table.Table("post", [
    { name: "version", type: "FIXED", value: 196608 },
    { name: "italicAngle", type: "FIXED", value: 0 },
    { name: "underlinePosition", type: "FWORD", value: 0 },
    { name: "underlineThickness", type: "FWORD", value: 0 },
    { name: "isFixedPitch", type: "ULONG", value: 0 },
    { name: "minMemType42", type: "ULONG", value: 0 },
    { name: "maxMemType42", type: "ULONG", value: 0 },
    { name: "minMemType1", type: "ULONG", value: 0 },
    { name: "maxMemType1", type: "ULONG", value: 0 }
  ]);
}
var post = { parse: parsePostTable, make: makePostTable };
var subtableParsers = new Array(9);
subtableParsers[1] = function parseLookup1() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser.coverage),
      deltaGlyphId: this.parseUShort()
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser.coverage),
      substitute: this.parseOffset16List()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 1 format must be 1 or 2.");
};
subtableParsers[2] = function parseLookup2() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Multiple Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    sequences: this.parseListOfLists()
  };
};
subtableParsers[3] = function parseLookup3() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Alternate Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    alternateSets: this.parseListOfLists()
  };
};
subtableParsers[4] = function parseLookup4() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB ligature table identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    ligatureSets: this.parseListOfLists(function() {
      return {
        ligGlyph: this.parseUShort(),
        components: this.parseUShortList(this.parseUShort() - 1)
      };
    })
  };
};
var lookupRecordDesc = {
  sequenceIndex: Parser.uShort,
  lookupListIndex: Parser.uShort
};
subtableParsers[5] = function parseLookup5() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser.coverage),
      ruleSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          input: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat,
      coverage: this.parsePointer(Parser.coverage),
      classDef: this.parsePointer(Parser.classDef),
      classSets: this.parseListOfLists(function() {
        var glyphCount2 = this.parseUShort();
        var substCount2 = this.parseUShort();
        return {
          classes: this.parseUShortList(glyphCount2 - 1),
          lookupRecords: this.parseRecordList(substCount2, lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    var glyphCount = this.parseUShort();
    var substCount = this.parseUShort();
    return {
      substFormat,
      coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
      lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 5 format must be 1, 2 or 3.");
};
subtableParsers[6] = function parseLookup6() {
  var start = this.offset + this.relativeOffset;
  var substFormat = this.parseUShort();
  if (substFormat === 1) {
    return {
      substFormat: 1,
      coverage: this.parsePointer(Parser.coverage),
      chainRuleSets: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 2) {
    return {
      substFormat: 2,
      coverage: this.parsePointer(Parser.coverage),
      backtrackClassDef: this.parsePointer(Parser.classDef),
      inputClassDef: this.parsePointer(Parser.classDef),
      lookaheadClassDef: this.parsePointer(Parser.classDef),
      chainClassSet: this.parseListOfLists(function() {
        return {
          backtrack: this.parseUShortList(),
          input: this.parseUShortList(this.parseShort() - 1),
          lookahead: this.parseUShortList(),
          lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
      })
    };
  } else if (substFormat === 3) {
    return {
      substFormat: 3,
      backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
      inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
      lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
      lookupRecords: this.parseRecordList(lookupRecordDesc)
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": lookup type 6 format must be 1, 2 or 3.");
};
subtableParsers[7] = function parseLookup7() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Extension Substitution subtable identifier-format must be 1");
  var extensionLookupType = this.parseUShort();
  var extensionParser = new Parser(this.data, this.offset + this.parseULong());
  return {
    substFormat: 1,
    lookupType: extensionLookupType,
    extension: subtableParsers[extensionLookupType].call(extensionParser)
  };
};
subtableParsers[8] = function parseLookup8() {
  var substFormat = this.parseUShort();
  check.argument(substFormat === 1, "GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1");
  return {
    substFormat,
    coverage: this.parsePointer(Parser.coverage),
    backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
    lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
    substitutes: this.parseUShortList()
  };
};
function parseGsubTable(data2, start) {
  start = start || 0;
  var p = new Parser(data2, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GSUB table version.");
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers = new Array(9);
subtableMakers[1] = function makeLookup1(subtable) {
  if (subtable.substFormat === 1) {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 1 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) },
      { name: "deltaGlyphID", type: "USHORT", value: subtable.deltaGlyphId }
    ]);
  } else {
    return new table.Table("substitutionTable", [
      { name: "substFormat", type: "USHORT", value: 2 },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.ushortList("substitute", subtable.substitute)));
  }
};
subtableMakers[2] = function makeLookup2(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 2 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("seqSet", subtable.sequences, function(sequenceSet) {
    return new table.Table("sequenceSetTable", table.ushortList("sequence", sequenceSet));
  })));
};
subtableMakers[3] = function makeLookup3(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 3 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("altSet", subtable.alternateSets, function(alternateSet) {
    return new table.Table("alternateSetTable", table.ushortList("alternate", alternateSet));
  })));
};
subtableMakers[4] = function makeLookup4(subtable) {
  check.assert(subtable.substFormat === 1, "Lookup type 4 substFormat must be 1.");
  return new table.Table("substitutionTable", [
    { name: "substFormat", type: "USHORT", value: 1 },
    { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
  ].concat(table.tableList("ligSet", subtable.ligatureSets, function(ligatureSet) {
    return new table.Table("ligatureSetTable", table.tableList("ligature", ligatureSet, function(ligature) {
      return new table.Table(
        "ligatureTable",
        [{ name: "ligGlyph", type: "USHORT", value: ligature.ligGlyph }].concat(table.ushortList("component", ligature.components, ligature.components.length + 1))
      );
    }));
  })));
};
subtableMakers[6] = function makeLookup6(subtable) {
  if (subtable.substFormat === 1) {
    var returnTable = new table.Table("chainContextTable", [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat },
      { name: "coverage", type: "TABLE", value: new table.Coverage(subtable.coverage) }
    ].concat(table.tableList("chainRuleSet", subtable.chainRuleSets, function(chainRuleSet) {
      return new table.Table("chainRuleSetTable", table.tableList("chainRule", chainRuleSet, function(chainRule) {
        var tableData2 = table.ushortList("backtrackGlyph", chainRule.backtrack, chainRule.backtrack.length).concat(table.ushortList("inputGlyph", chainRule.input, chainRule.input.length + 1)).concat(table.ushortList("lookaheadGlyph", chainRule.lookahead, chainRule.lookahead.length)).concat(table.ushortList("substitution", [], chainRule.lookupRecords.length));
        chainRule.lookupRecords.forEach(function(record, i) {
          tableData2 = tableData2.concat({ name: "sequenceIndex" + i, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i, type: "USHORT", value: record.lookupListIndex });
        });
        return new table.Table("chainRuleTable", tableData2);
      }));
    })));
    return returnTable;
  } else if (subtable.substFormat === 2) {
    check.assert(false, "lookup type 6 format 2 is not yet supported.");
  } else if (subtable.substFormat === 3) {
    var tableData = [
      { name: "substFormat", type: "USHORT", value: subtable.substFormat }
    ];
    tableData.push({ name: "backtrackGlyphCount", type: "USHORT", value: subtable.backtrackCoverage.length });
    subtable.backtrackCoverage.forEach(function(coverage, i) {
      tableData.push({ name: "backtrackCoverage" + i, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "inputGlyphCount", type: "USHORT", value: subtable.inputCoverage.length });
    subtable.inputCoverage.forEach(function(coverage, i) {
      tableData.push({ name: "inputCoverage" + i, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "lookaheadGlyphCount", type: "USHORT", value: subtable.lookaheadCoverage.length });
    subtable.lookaheadCoverage.forEach(function(coverage, i) {
      tableData.push({ name: "lookaheadCoverage" + i, type: "TABLE", value: new table.Coverage(coverage) });
    });
    tableData.push({ name: "substitutionCount", type: "USHORT", value: subtable.lookupRecords.length });
    subtable.lookupRecords.forEach(function(record, i) {
      tableData = tableData.concat({ name: "sequenceIndex" + i, type: "USHORT", value: record.sequenceIndex }).concat({ name: "lookupListIndex" + i, type: "USHORT", value: record.lookupListIndex });
    });
    var returnTable$1 = new table.Table("chainContextTable", tableData);
    return returnTable$1;
  }
  check.assert(false, "lookup type 6 format must be 1, 2 or 3.");
};
function makeGsubTable(gsub2) {
  return new table.Table("GSUB", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gsub2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gsub2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gsub2.lookups, subtableMakers) }
  ]);
}
var gsub = { parse: parseGsubTable, make: makeGsubTable };
function parseMetaTable(data2, start) {
  var p = new parse.Parser(data2, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 1, "Unsupported META table version.");
  p.parseULong();
  p.parseULong();
  var numDataMaps = p.parseULong();
  var tags = {};
  for (var i = 0; i < numDataMaps; i++) {
    var tag = p.parseTag();
    var dataOffset = p.parseULong();
    var dataLength = p.parseULong();
    var text = decode.UTF8(data2, start + dataOffset, dataLength);
    tags[tag] = text;
  }
  return tags;
}
function makeMetaTable(tags) {
  var numTags = Object.keys(tags).length;
  var stringPool = "";
  var stringPoolOffset = 16 + numTags * 12;
  var result = new table.Table("meta", [
    { name: "version", type: "ULONG", value: 1 },
    { name: "flags", type: "ULONG", value: 0 },
    { name: "offset", type: "ULONG", value: stringPoolOffset },
    { name: "numTags", type: "ULONG", value: numTags }
  ]);
  for (var tag in tags) {
    var pos = stringPool.length;
    stringPool += tags[tag];
    result.fields.push({ name: "tag " + tag, type: "TAG", value: tag });
    result.fields.push({ name: "offset " + tag, type: "ULONG", value: stringPoolOffset + pos });
    result.fields.push({ name: "length " + tag, type: "ULONG", value: tags[tag].length });
  }
  result.fields.push({ name: "stringPool", type: "CHARARRAY", value: stringPool });
  return result;
}
var meta = { parse: parseMetaTable, make: makeMetaTable };
function log2(v) {
  return Math.log(v) / Math.log(2) | 0;
}
function computeCheckSum(bytes) {
  while (bytes.length % 4 !== 0) {
    bytes.push(0);
  }
  var sum = 0;
  for (var i = 0; i < bytes.length; i += 4) {
    sum += (bytes[i] << 24) + (bytes[i + 1] << 16) + (bytes[i + 2] << 8) + bytes[i + 3];
  }
  sum %= Math.pow(2, 32);
  return sum;
}
function makeTableRecord(tag, checkSum, offset, length) {
  return new table.Record("Table Record", [
    { name: "tag", type: "TAG", value: tag !== void 0 ? tag : "" },
    { name: "checkSum", type: "ULONG", value: checkSum !== void 0 ? checkSum : 0 },
    { name: "offset", type: "ULONG", value: offset !== void 0 ? offset : 0 },
    { name: "length", type: "ULONG", value: length !== void 0 ? length : 0 }
  ]);
}
function makeSfntTable(tables) {
  var sfnt2 = new table.Table("sfnt", [
    { name: "version", type: "TAG", value: "OTTO" },
    { name: "numTables", type: "USHORT", value: 0 },
    { name: "searchRange", type: "USHORT", value: 0 },
    { name: "entrySelector", type: "USHORT", value: 0 },
    { name: "rangeShift", type: "USHORT", value: 0 }
  ]);
  sfnt2.tables = tables;
  sfnt2.numTables = tables.length;
  var highestPowerOf2 = Math.pow(2, log2(sfnt2.numTables));
  sfnt2.searchRange = 16 * highestPowerOf2;
  sfnt2.entrySelector = log2(highestPowerOf2);
  sfnt2.rangeShift = sfnt2.numTables * 16 - sfnt2.searchRange;
  var recordFields = [];
  var tableFields = [];
  var offset = sfnt2.sizeOf() + makeTableRecord().sizeOf() * sfnt2.numTables;
  while (offset % 4 !== 0) {
    offset += 1;
    tableFields.push({ name: "padding", type: "BYTE", value: 0 });
  }
  for (var i = 0; i < tables.length; i += 1) {
    var t2 = tables[i];
    check.argument(t2.tableName.length === 4, "Table name" + t2.tableName + " is invalid.");
    var tableLength = t2.sizeOf();
    var tableRecord = makeTableRecord(t2.tableName, computeCheckSum(t2.encode()), offset, tableLength);
    recordFields.push({ name: tableRecord.tag + " Table Record", type: "RECORD", value: tableRecord });
    tableFields.push({ name: t2.tableName + " table", type: "RECORD", value: t2 });
    offset += tableLength;
    check.argument(!isNaN(offset), "Something went wrong calculating the offset.");
    while (offset % 4 !== 0) {
      offset += 1;
      tableFields.push({ name: "padding", type: "BYTE", value: 0 });
    }
  }
  recordFields.sort(function(r1, r2) {
    if (r1.value.tag > r2.value.tag) {
      return 1;
    } else {
      return -1;
    }
  });
  sfnt2.fields = sfnt2.fields.concat(recordFields);
  sfnt2.fields = sfnt2.fields.concat(tableFields);
  return sfnt2;
}
function metricsForChar(font, chars, notFoundMetrics) {
  for (var i = 0; i < chars.length; i += 1) {
    var glyphIndex = font.charToGlyphIndex(chars[i]);
    if (glyphIndex > 0) {
      var glyph = font.glyphs.get(glyphIndex);
      return glyph.getMetrics();
    }
  }
  return notFoundMetrics;
}
function average(vs) {
  var sum = 0;
  for (var i = 0; i < vs.length; i += 1) {
    sum += vs[i];
  }
  return sum / vs.length;
}
function fontToSfntTable(font) {
  var xMins = [];
  var yMins = [];
  var xMaxs = [];
  var yMaxs = [];
  var advanceWidths = [];
  var leftSideBearings = [];
  var rightSideBearings = [];
  var firstCharIndex;
  var lastCharIndex = 0;
  var ulUnicodeRange1 = 0;
  var ulUnicodeRange2 = 0;
  var ulUnicodeRange3 = 0;
  var ulUnicodeRange4 = 0;
  for (var i = 0; i < font.glyphs.length; i += 1) {
    var glyph = font.glyphs.get(i);
    var unicode3 = glyph.unicode | 0;
    if (isNaN(glyph.advanceWidth)) {
      throw new Error("Glyph " + glyph.name + " (" + i + "): advanceWidth is not a number.");
    }
    if (firstCharIndex > unicode3 || firstCharIndex === void 0) {
      if (unicode3 > 0) {
        firstCharIndex = unicode3;
      }
    }
    if (lastCharIndex < unicode3) {
      lastCharIndex = unicode3;
    }
    var position = os2.getUnicodeRange(unicode3);
    if (position < 32) {
      ulUnicodeRange1 |= 1 << position;
    } else if (position < 64) {
      ulUnicodeRange2 |= 1 << position - 32;
    } else if (position < 96) {
      ulUnicodeRange3 |= 1 << position - 64;
    } else if (position < 123) {
      ulUnicodeRange4 |= 1 << position - 96;
    } else {
      throw new Error("Unicode ranges bits > 123 are reserved for internal usage");
    }
    if (glyph.name === ".notdef") {
      continue;
    }
    var metrics = glyph.getMetrics();
    xMins.push(metrics.xMin);
    yMins.push(metrics.yMin);
    xMaxs.push(metrics.xMax);
    yMaxs.push(metrics.yMax);
    leftSideBearings.push(metrics.leftSideBearing);
    rightSideBearings.push(metrics.rightSideBearing);
    advanceWidths.push(glyph.advanceWidth);
  }
  var globals = {
    xMin: Math.min.apply(null, xMins),
    yMin: Math.min.apply(null, yMins),
    xMax: Math.max.apply(null, xMaxs),
    yMax: Math.max.apply(null, yMaxs),
    advanceWidthMax: Math.max.apply(null, advanceWidths),
    advanceWidthAvg: average(advanceWidths),
    minLeftSideBearing: Math.min.apply(null, leftSideBearings),
    maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
    minRightSideBearing: Math.min.apply(null, rightSideBearings)
  };
  globals.ascender = font.ascender;
  globals.descender = font.descender;
  var headTable = head.make({
    flags: 3,
    // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
    unitsPerEm: font.unitsPerEm,
    xMin: globals.xMin,
    yMin: globals.yMin,
    xMax: globals.xMax,
    yMax: globals.yMax,
    lowestRecPPEM: 3,
    createdTimestamp: font.createdTimestamp
  });
  var hheaTable = hhea.make({
    ascender: globals.ascender,
    descender: globals.descender,
    advanceWidthMax: globals.advanceWidthMax,
    minLeftSideBearing: globals.minLeftSideBearing,
    minRightSideBearing: globals.minRightSideBearing,
    xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
    numberOfHMetrics: font.glyphs.length
  });
  var maxpTable = maxp.make(font.glyphs.length);
  var os2Table = os2.make(Object.assign({
    xAvgCharWidth: Math.round(globals.advanceWidthAvg),
    usFirstCharIndex: firstCharIndex,
    usLastCharIndex: lastCharIndex,
    ulUnicodeRange1,
    ulUnicodeRange2,
    ulUnicodeRange3,
    ulUnicodeRange4,
    // See http://typophile.com/node/13081 for more info on vertical metrics.
    // We get metrics for typical characters (such as "x" for xHeight).
    // We provide some fallback characters if characters are unavailable: their
    // ordering was chosen experimentally.
    sTypoAscender: globals.ascender,
    sTypoDescender: globals.descender,
    sTypoLineGap: 0,
    usWinAscent: globals.yMax,
    usWinDescent: Math.abs(globals.yMin),
    ulCodePageRange1: 1,
    // FIXME: hard-code Latin 1 support for now
    sxHeight: metricsForChar(font, "xyvw", { yMax: Math.round(globals.ascender / 2) }).yMax,
    sCapHeight: metricsForChar(font, "HIKLEFJMNTZBDPRAGOQSUVWXY", globals).yMax,
    usDefaultChar: font.hasChar(" ") ? 32 : 0,
    // Use space as the default character, if available.
    usBreakChar: font.hasChar(" ") ? 32 : 0
    // Use space as the break character, if available.
  }, font.tables.os2));
  var hmtxTable = hmtx.make(font.glyphs);
  var cmapTable = cmap.make(font.glyphs);
  var englishFamilyName = font.getEnglishName("fontFamily");
  var englishStyleName = font.getEnglishName("fontSubfamily");
  var englishFullName = englishFamilyName + " " + englishStyleName;
  var postScriptName = font.getEnglishName("postScriptName");
  if (!postScriptName) {
    postScriptName = englishFamilyName.replace(/\s/g, "") + "-" + englishStyleName;
  }
  var names = {};
  for (var n in font.names) {
    names[n] = font.names[n];
  }
  if (!names.uniqueID) {
    names.uniqueID = { en: font.getEnglishName("manufacturer") + ":" + englishFullName };
  }
  if (!names.postScriptName) {
    names.postScriptName = { en: postScriptName };
  }
  if (!names.preferredFamily) {
    names.preferredFamily = font.names.fontFamily;
  }
  if (!names.preferredSubfamily) {
    names.preferredSubfamily = font.names.fontSubfamily;
  }
  var languageTags = [];
  var nameTable = _name.make(names, languageTags);
  var ltagTable = languageTags.length > 0 ? ltag.make(languageTags) : void 0;
  var postTable = post.make();
  var cffTable = cff.make(font.glyphs, {
    version: font.getEnglishName("version"),
    fullName: englishFullName,
    familyName: englishFamilyName,
    weightName: englishStyleName,
    postScriptName,
    unitsPerEm: font.unitsPerEm,
    fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
  });
  var metaTable = font.metas && Object.keys(font.metas).length > 0 ? meta.make(font.metas) : void 0;
  var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
  if (ltagTable) {
    tables.push(ltagTable);
  }
  if (font.tables.gsub) {
    tables.push(gsub.make(font.tables.gsub));
  }
  if (metaTable) {
    tables.push(metaTable);
  }
  var sfntTable = makeSfntTable(tables);
  var bytes = sfntTable.encode();
  var checkSum = computeCheckSum(bytes);
  var tableFields = sfntTable.fields;
  var checkSumAdjusted = false;
  for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
    if (tableFields[i$1].name === "head table") {
      tableFields[i$1].value.checkSumAdjustment = 2981146554 - checkSum;
      checkSumAdjusted = true;
      break;
    }
  }
  if (!checkSumAdjusted) {
    throw new Error("Could not find head table with checkSum to adjust.");
  }
  return sfntTable;
}
var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum };
function searchTag(arr, tag) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid].tag;
    if (val === tag) {
      return imid;
    } else if (val < tag) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function binSearch(arr, value) {
  var imin = 0;
  var imax = arr.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    var val = arr[imid];
    if (val === value) {
      return imid;
    } else if (val < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  return -imin - 1;
}
function searchRange(ranges, value) {
  var range;
  var imin = 0;
  var imax = ranges.length - 1;
  while (imin <= imax) {
    var imid = imin + imax >>> 1;
    range = ranges[imid];
    var start = range.start;
    if (start === value) {
      return range;
    } else if (start < value) {
      imin = imid + 1;
    } else {
      imax = imid - 1;
    }
  }
  if (imin > 0) {
    range = ranges[imin - 1];
    if (value > range.end) {
      return 0;
    }
    return range;
  }
}
function Layout(font, tableName) {
  this.font = font;
  this.tableName = tableName;
}
Layout.prototype = {
  /**
   * Binary search an object by "tag" property
   * @instance
   * @function searchTag
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {string} tag
   * @return {number}
   */
  searchTag,
  /**
   * Binary search in a list of numbers
   * @instance
   * @function binSearch
   * @memberof opentype.Layout
   * @param  {Array} arr
   * @param  {number} value
   * @return {number}
   */
  binSearch,
  /**
   * Get or create the Layout table (GSUB, GPOS etc).
   * @param  {boolean} create - Whether to create a new one.
   * @return {Object} The GSUB or GPOS table.
   */
  getTable: function(create) {
    var layout = this.font.tables[this.tableName];
    if (!layout && create) {
      layout = this.font.tables[this.tableName] = this.createDefaultTable();
    }
    return layout;
  },
  /**
   * Returns all scripts in the substitution table.
   * @instance
   * @return {Array}
   */
  getScriptNames: function() {
    var layout = this.getTable();
    if (!layout) {
      return [];
    }
    return layout.scripts.map(function(script2) {
      return script2.tag;
    });
  },
  /**
   * Returns the best bet for a script name.
   * Returns 'DFLT' if it exists.
   * If not, returns 'latn' if it exists.
   * If neither exist, returns undefined.
   */
  getDefaultScriptName: function() {
    var layout = this.getTable();
    if (!layout) {
      return;
    }
    var hasLatn = false;
    for (var i = 0; i < layout.scripts.length; i++) {
      var name = layout.scripts[i].tag;
      if (name === "DFLT") {
        return name;
      }
      if (name === "latn") {
        hasLatn = true;
      }
    }
    if (hasLatn) {
      return "latn";
    }
  },
  /**
   * Returns all LangSysRecords in the given script.
   * @instance
   * @param {string} [script='DFLT']
   * @param {boolean} create - forces the creation of this script table if it doesn't exist.
   * @return {Object} An object with tag and script properties.
   */
  getScriptTable: function(script2, create) {
    var layout = this.getTable(create);
    if (layout) {
      script2 = script2 || "DFLT";
      var scripts = layout.scripts;
      var pos = searchTag(layout.scripts, script2);
      if (pos >= 0) {
        return scripts[pos].script;
      } else if (create) {
        var scr = {
          tag: script2,
          script: {
            defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
            langSysRecords: []
          }
        };
        scripts.splice(-1 - pos, 0, scr);
        return scr.script;
      }
    }
  },
  /**
   * Returns a language system table
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
   * @return {Object}
   */
  getLangSysTable: function(script2, language, create) {
    var scriptTable = this.getScriptTable(script2, create);
    if (scriptTable) {
      if (!language || language === "dflt" || language === "DFLT") {
        return scriptTable.defaultLangSys;
      }
      var pos = searchTag(scriptTable.langSysRecords, language);
      if (pos >= 0) {
        return scriptTable.langSysRecords[pos].langSys;
      } else if (create) {
        var langSysRecord = {
          tag: language,
          langSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] }
        };
        scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
        return langSysRecord.langSys;
      }
    }
  },
  /**
   * Get a specific feature table.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
   * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
   * @return {Object}
   */
  getFeatureTable: function(script2, language, feature, create) {
    var langSysTable2 = this.getLangSysTable(script2, language, create);
    if (langSysTable2) {
      var featureRecord;
      var featIndexes = langSysTable2.featureIndexes;
      var allFeatures = this.font.tables[this.tableName].features;
      for (var i = 0; i < featIndexes.length; i++) {
        featureRecord = allFeatures[featIndexes[i]];
        if (featureRecord.tag === feature) {
          return featureRecord.feature;
        }
      }
      if (create) {
        var index = allFeatures.length;
        check.assert(index === 0 || feature >= allFeatures[index - 1].tag, "Features must be added in alphabetical order.");
        featureRecord = {
          tag: feature,
          feature: { params: 0, lookupListIndexes: [] }
        };
        allFeatures.push(featureRecord);
        featIndexes.push(index);
        return featureRecord.feature;
      }
    }
  },
  /**
   * Get the lookup tables of a given type for a script/language/feature.
   * @instance
   * @param {string} [script='DFLT']
   * @param {string} [language='dlft']
   * @param {string} feature - 4-letter feature code
   * @param {number} lookupType - 1 to 9
   * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
   * @return {Object[]}
   */
  getLookupTables: function(script2, language, feature, lookupType, create) {
    var featureTable = this.getFeatureTable(script2, language, feature, create);
    var tables = [];
    if (featureTable) {
      var lookupTable;
      var lookupListIndexes = featureTable.lookupListIndexes;
      var allLookups = this.font.tables[this.tableName].lookups;
      for (var i = 0; i < lookupListIndexes.length; i++) {
        lookupTable = allLookups[lookupListIndexes[i]];
        if (lookupTable.lookupType === lookupType) {
          tables.push(lookupTable);
        }
      }
      if (tables.length === 0 && create) {
        lookupTable = {
          lookupType,
          lookupFlag: 0,
          subtables: [],
          markFilteringSet: void 0
        };
        var index = allLookups.length;
        allLookups.push(lookupTable);
        lookupListIndexes.push(index);
        return [lookupTable];
      }
    }
    return tables;
  },
  /**
   * Find a glyph in a class definition table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
   * @param {object} classDefTable - an OpenType Layout class definition table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getGlyphClass: function(classDefTable, glyphIndex) {
    switch (classDefTable.format) {
      case 1:
        if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
          return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
        }
        return 0;
      case 2:
        var range = searchRange(classDefTable.ranges, glyphIndex);
        return range ? range.classId : 0;
    }
  },
  /**
   * Find a glyph in a coverage table
   * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
   * @param {object} coverageTable - an OpenType Layout coverage table
   * @param {number} glyphIndex - the index of the glyph to find
   * @returns {number} -1 if not found
   */
  getCoverageIndex: function(coverageTable, glyphIndex) {
    switch (coverageTable.format) {
      case 1:
        var index = binSearch(coverageTable.glyphs, glyphIndex);
        return index >= 0 ? index : -1;
      case 2:
        var range = searchRange(coverageTable.ranges, glyphIndex);
        return range ? range.index + glyphIndex - range.start : -1;
    }
  },
  /**
   * Returns the list of glyph indexes of a coverage table.
   * Format 1: the list is stored raw
   * Format 2: compact list as range records.
   * @instance
   * @param  {Object} coverageTable
   * @return {Array}
   */
  expandCoverage: function(coverageTable) {
    if (coverageTable.format === 1) {
      return coverageTable.glyphs;
    } else {
      var glyphs = [];
      var ranges = coverageTable.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        var start = range.start;
        var end = range.end;
        for (var j = start; j <= end; j++) {
          glyphs.push(j);
        }
      }
      return glyphs;
    }
  }
};
function Position(font) {
  Layout.call(this, font, "gpos");
}
Position.prototype = Layout.prototype;
Position.prototype.init = function() {
  var script2 = this.getDefaultScriptName();
  this.defaultKerningTables = this.getKerningTables(script2);
};
Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
  for (var i = 0; i < kerningLookups.length; i++) {
    var subtables = kerningLookups[i].subtables;
    for (var j = 0; j < subtables.length; j++) {
      var subtable = subtables[j];
      var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
      if (covIndex < 0) {
        continue;
      }
      switch (subtable.posFormat) {
        case 1:
          var pairSet = subtable.pairSets[covIndex];
          for (var k = 0; k < pairSet.length; k++) {
            var pair = pairSet[k];
            if (pair.secondGlyph === rightIndex) {
              return pair.value1 && pair.value1.xAdvance || 0;
            }
          }
          break;
        // left glyph found, not right glyph - try next subtable
        case 2:
          var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
          var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
          var pair$1 = subtable.classRecords[class1][class2];
          return pair$1.value1 && pair$1.value1.xAdvance || 0;
      }
    }
  }
  return 0;
};
Position.prototype.getKerningTables = function(script2, language) {
  if (this.font.tables.gpos) {
    return this.getLookupTables(script2, language, "kern", 2);
  }
};
function Substitution(font) {
  Layout.call(this, font, "gsub");
}
function arraysEqual(ar1, ar2) {
  var n = ar1.length;
  if (n !== ar2.length) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    if (ar1[i] !== ar2[i]) {
      return false;
    }
  }
  return true;
}
function getSubstFormat(lookupTable, format, defaultSubtable) {
  var subtables = lookupTable.subtables;
  for (var i = 0; i < subtables.length; i++) {
    var subtable = subtables[i];
    if (subtable.substFormat === format) {
      return subtable;
    }
  }
  if (defaultSubtable) {
    subtables.push(defaultSubtable);
    return defaultSubtable;
  }
  return void 0;
}
Substitution.prototype = Layout.prototype;
Substitution.prototype.createDefaultTable = function() {
  return {
    version: 1,
    scripts: [{
      tag: "DFLT",
      script: {
        defaultLangSys: { reserved: 0, reqFeatureIndex: 65535, featureIndexes: [] },
        langSysRecords: []
      }
    }],
    features: [],
    lookups: []
  };
};
Substitution.prototype.getSingle = function(feature, script2, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script2, language, feature, 1);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j = void 0;
      if (subtable.substFormat === 1) {
        var delta = subtable.deltaGlyphId;
        for (j = 0; j < glyphs.length; j++) {
          var glyph = glyphs[j];
          substitutions.push({ sub: glyph, by: glyph + delta });
        }
      } else {
        var substitute = subtable.substitute;
        for (j = 0; j < glyphs.length; j++) {
          substitutions.push({ sub: glyphs[j], by: substitute[j] });
        }
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getMultiple = function(feature, script2, language) {
  var substitutions = [];
  var lookupTables = this.getLookupTables(script2, language, feature, 2);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var j = void 0;
      for (j = 0; j < glyphs.length; j++) {
        var glyph = glyphs[j];
        var replacements = subtable.sequences[j];
        substitutions.push({ sub: glyph, by: replacements });
      }
    }
  }
  return substitutions;
};
Substitution.prototype.getAlternates = function(feature, script2, language) {
  var alternates = [];
  var lookupTables = this.getLookupTables(script2, language, feature, 3);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var alternateSets = subtable.alternateSets;
      for (var j = 0; j < glyphs.length; j++) {
        alternates.push({ sub: glyphs[j], by: alternateSets[j] });
      }
    }
  }
  return alternates;
};
Substitution.prototype.getLigatures = function(feature, script2, language) {
  var ligatures = [];
  var lookupTables = this.getLookupTables(script2, language, feature, 4);
  for (var idx = 0; idx < lookupTables.length; idx++) {
    var subtables = lookupTables[idx].subtables;
    for (var i = 0; i < subtables.length; i++) {
      var subtable = subtables[i];
      var glyphs = this.expandCoverage(subtable.coverage);
      var ligatureSets = subtable.ligatureSets;
      for (var j = 0; j < glyphs.length; j++) {
        var startGlyph = glyphs[j];
        var ligSet = ligatureSets[j];
        for (var k = 0; k < ligSet.length; k++) {
          var lig = ligSet[k];
          ligatures.push({
            sub: [startGlyph].concat(lig.components),
            by: lig.ligGlyph
          });
        }
      }
    }
  }
  return ligatures;
};
Substitution.prototype.addSingle = function(feature, substitution, script2, language) {
  var lookupTable = this.getLookupTables(script2, language, feature, 1, true)[0];
  var subtable = getSubstFormat(lookupTable, 2, {
    // lookup type 1 subtable, format 2, coverage format 1
    substFormat: 2,
    coverage: { format: 1, glyphs: [] },
    substitute: []
  });
  check.assert(subtable.coverage.format === 1, "Single: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.substitute.splice(pos, 0, 0);
  }
  subtable.substitute[pos] = substitution.by;
};
Substitution.prototype.addMultiple = function(feature, substitution, script2, language) {
  check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
  var lookupTable = this.getLookupTables(script2, language, feature, 2, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    // lookup type 2 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    sequences: []
  });
  check.assert(subtable.coverage.format === 1, "Multiple: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.sequences.splice(pos, 0, 0);
  }
  subtable.sequences[pos] = substitution.by;
};
Substitution.prototype.addAlternate = function(feature, substitution, script2, language) {
  var lookupTable = this.getLookupTables(script2, language, feature, 3, true)[0];
  var subtable = getSubstFormat(lookupTable, 1, {
    // lookup type 3 subtable, format 1, coverage format 1
    substFormat: 1,
    coverage: { format: 1, glyphs: [] },
    alternateSets: []
  });
  check.assert(subtable.coverage.format === 1, "Alternate: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = substitution.sub;
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos < 0) {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.alternateSets.splice(pos, 0, 0);
  }
  subtable.alternateSets[pos] = substitution.by;
};
Substitution.prototype.addLigature = function(feature, ligature, script2, language) {
  var lookupTable = this.getLookupTables(script2, language, feature, 4, true)[0];
  var subtable = lookupTable.subtables[0];
  if (!subtable) {
    subtable = {
      // lookup type 4 subtable, format 1, coverage format 1
      substFormat: 1,
      coverage: { format: 1, glyphs: [] },
      ligatureSets: []
    };
    lookupTable.subtables[0] = subtable;
  }
  check.assert(subtable.coverage.format === 1, "Ligature: unable to modify coverage table format " + subtable.coverage.format);
  var coverageGlyph = ligature.sub[0];
  var ligComponents = ligature.sub.slice(1);
  var ligatureTable = {
    ligGlyph: ligature.by,
    components: ligComponents
  };
  var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
  if (pos >= 0) {
    var ligatureSet = subtable.ligatureSets[pos];
    for (var i = 0; i < ligatureSet.length; i++) {
      if (arraysEqual(ligatureSet[i].components, ligComponents)) {
        return;
      }
    }
    ligatureSet.push(ligatureTable);
  } else {
    pos = -1 - pos;
    subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
    subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
  }
};
Substitution.prototype.getFeature = function(feature, script2, language) {
  if (/ss\d\d/.test(feature)) {
    return this.getSingle(feature, script2, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      return this.getSingle(feature, script2, language).concat(this.getAlternates(feature, script2, language));
    case "dlig":
    case "liga":
    case "rlig":
      return this.getLigatures(feature, script2, language);
    case "ccmp":
      return this.getMultiple(feature, script2, language).concat(this.getLigatures(feature, script2, language));
    case "stch":
      return this.getMultiple(feature, script2, language);
  }
  return void 0;
};
Substitution.prototype.add = function(feature, sub, script2, language) {
  if (/ss\d\d/.test(feature)) {
    return this.addSingle(feature, sub, script2, language);
  }
  switch (feature) {
    case "aalt":
    case "salt":
      if (typeof sub.by === "number") {
        return this.addSingle(feature, sub, script2, language);
      }
      return this.addAlternate(feature, sub, script2, language);
    case "dlig":
    case "liga":
    case "rlig":
      return this.addLigature(feature, sub, script2, language);
    case "ccmp":
      if (sub.by instanceof Array) {
        return this.addMultiple(feature, sub, script2, language);
      }
      return this.addLigature(feature, sub, script2, language);
  }
  return void 0;
};
function isBrowser2() {
  return typeof window !== "undefined";
}
function arrayBufferToNodeBuffer(ab) {
  var buffer = new Buffer(ab.byteLength);
  var view = new Uint8Array(ab);
  for (var i = 0; i < buffer.length; ++i) {
    buffer[i] = view[i];
  }
  return buffer;
}
function checkArgument(expression, message2) {
  if (!expression) {
    throw message2;
  }
}
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
  var v;
  if ((flag & shortVectorBitMask) > 0) {
    v = p.parseByte();
    if ((flag & sameBitMask) === 0) {
      v = -v;
    }
    v = previousValue + v;
  } else {
    if ((flag & sameBitMask) > 0) {
      v = previousValue;
    } else {
      v = previousValue + p.parseShort();
    }
  }
  return v;
}
function parseGlyph(glyph, data2, start) {
  var p = new parse.Parser(data2, start);
  glyph.numberOfContours = p.parseShort();
  glyph._xMin = p.parseShort();
  glyph._yMin = p.parseShort();
  glyph._xMax = p.parseShort();
  glyph._yMax = p.parseShort();
  var flags;
  var flag;
  if (glyph.numberOfContours > 0) {
    var endPointIndices = glyph.endPointIndices = [];
    for (var i = 0; i < glyph.numberOfContours; i += 1) {
      endPointIndices.push(p.parseUShort());
    }
    glyph.instructionLength = p.parseUShort();
    glyph.instructions = [];
    for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
      glyph.instructions.push(p.parseByte());
    }
    var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
    flags = [];
    for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
      flag = p.parseByte();
      flags.push(flag);
      if ((flag & 8) > 0) {
        var repeatCount = p.parseByte();
        for (var j = 0; j < repeatCount; j += 1) {
          flags.push(flag);
          i$2 += 1;
        }
      }
    }
    check.argument(flags.length === numberOfCoordinates, "Bad flags.");
    if (endPointIndices.length > 0) {
      var points = [];
      var point;
      if (numberOfCoordinates > 0) {
        for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
          flag = flags[i$3];
          point = {};
          point.onCurve = !!(flag & 1);
          point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
          points.push(point);
        }
        var px = 0;
        for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
          flag = flags[i$4];
          point = points[i$4];
          point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
          px = point.x;
        }
        var py = 0;
        for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
          flag = flags[i$5];
          point = points[i$5];
          point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
          py = point.y;
        }
      }
      glyph.points = points;
    } else {
      glyph.points = [];
    }
  } else if (glyph.numberOfContours === 0) {
    glyph.points = [];
  } else {
    glyph.isComposite = true;
    glyph.points = [];
    glyph.components = [];
    var moreComponents = true;
    while (moreComponents) {
      flags = p.parseUShort();
      var component = {
        glyphIndex: p.parseUShort(),
        xScale: 1,
        scale01: 0,
        scale10: 0,
        yScale: 1,
        dx: 0,
        dy: 0
      };
      if ((flags & 1) > 0) {
        if ((flags & 2) > 0) {
          component.dx = p.parseShort();
          component.dy = p.parseShort();
        } else {
          component.matchedPoints = [p.parseUShort(), p.parseUShort()];
        }
      } else {
        if ((flags & 2) > 0) {
          component.dx = p.parseChar();
          component.dy = p.parseChar();
        } else {
          component.matchedPoints = [p.parseByte(), p.parseByte()];
        }
      }
      if ((flags & 8) > 0) {
        component.xScale = component.yScale = p.parseF2Dot14();
      } else if ((flags & 64) > 0) {
        component.xScale = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      } else if ((flags & 128) > 0) {
        component.xScale = p.parseF2Dot14();
        component.scale01 = p.parseF2Dot14();
        component.scale10 = p.parseF2Dot14();
        component.yScale = p.parseF2Dot14();
      }
      glyph.components.push(component);
      moreComponents = !!(flags & 32);
    }
    if (flags & 256) {
      glyph.instructionLength = p.parseUShort();
      glyph.instructions = [];
      for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
        glyph.instructions.push(p.parseByte());
      }
    }
  }
}
function transformPoints(points, transform) {
  var newPoints = [];
  for (var i = 0; i < points.length; i += 1) {
    var pt = points[i];
    var newPt = {
      x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
      y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
      onCurve: pt.onCurve,
      lastPointOfContour: pt.lastPointOfContour
    };
    newPoints.push(newPt);
  }
  return newPoints;
}
function getContours(points) {
  var contours = [];
  var currentContour = [];
  for (var i = 0; i < points.length; i += 1) {
    var pt = points[i];
    currentContour.push(pt);
    if (pt.lastPointOfContour) {
      contours.push(currentContour);
      currentContour = [];
    }
  }
  check.argument(currentContour.length === 0, "There are still points left in the current contour.");
  return contours;
}
function getPath(points) {
  var p = new Path();
  if (!points) {
    return p;
  }
  var contours = getContours(points);
  for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
    var contour = contours[contourIndex];
    var prev = null;
    var curr = contour[contour.length - 1];
    var next = contour[0];
    if (curr.onCurve) {
      p.moveTo(curr.x, curr.y);
    } else {
      if (next.onCurve) {
        p.moveTo(next.x, next.y);
      } else {
        var start = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        p.moveTo(start.x, start.y);
      }
    }
    for (var i = 0; i < contour.length; ++i) {
      prev = curr;
      curr = next;
      next = contour[(i + 1) % contour.length];
      if (curr.onCurve) {
        p.lineTo(curr.x, curr.y);
      } else {
        var prev2 = prev;
        var next2 = next;
        if (!prev.onCurve) {
          prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
        }
        if (!next.onCurve) {
          next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
        }
        p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
      }
    }
    p.closePath();
  }
  return p;
}
function buildPath(glyphs, glyph) {
  if (glyph.isComposite) {
    for (var j = 0; j < glyph.components.length; j += 1) {
      var component = glyph.components[j];
      var componentGlyph = glyphs.get(component.glyphIndex);
      componentGlyph.getPath();
      if (componentGlyph.points) {
        var transformedPoints = void 0;
        if (component.matchedPoints === void 0) {
          transformedPoints = transformPoints(componentGlyph.points, component);
        } else {
          if (component.matchedPoints[0] > glyph.points.length - 1 || component.matchedPoints[1] > componentGlyph.points.length - 1) {
            throw Error("Matched points out of range in " + glyph.name);
          }
          var firstPt = glyph.points[component.matchedPoints[0]];
          var secondPt = componentGlyph.points[component.matchedPoints[1]];
          var transform = {
            xScale: component.xScale,
            scale01: component.scale01,
            scale10: component.scale10,
            yScale: component.yScale,
            dx: 0,
            dy: 0
          };
          secondPt = transformPoints([secondPt], transform)[0];
          transform.dx = firstPt.x - secondPt.x;
          transform.dy = firstPt.y - secondPt.y;
          transformedPoints = transformPoints(componentGlyph.points, transform);
        }
        glyph.points = glyph.points.concat(transformedPoints);
      }
    }
  }
  return getPath(glyph.points);
}
function parseGlyfTableAll(data2, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  for (var i = 0; i < loca2.length - 1; i += 1) {
    var offset = loca2[i];
    var nextOffset = loca2[i + 1];
    if (offset !== nextOffset) {
      glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data2, start + offset, buildPath));
    } else {
      glyphs.push(i, glyphset.glyphLoader(font, i));
    }
  }
  return glyphs;
}
function parseGlyfTableOnLowMemory(data2, start, loca2, font) {
  var glyphs = new glyphset.GlyphSet(font);
  font._push = function(i) {
    var offset = loca2[i];
    var nextOffset = loca2[i + 1];
    if (offset !== nextOffset) {
      glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data2, start + offset, buildPath));
    } else {
      glyphs.push(i, glyphset.glyphLoader(font, i));
    }
  };
  return glyphs;
}
function parseGlyfTable(data2, start, loca2, font, opt) {
  if (opt.lowMemory) {
    return parseGlyfTableOnLowMemory(data2, start, loca2, font);
  } else {
    return parseGlyfTableAll(data2, start, loca2, font);
  }
}
var glyf = { getPath, parse: parseGlyfTable };
var instructionTable;
var exec;
var execGlyph;
var execComponent;
function Hinting(font) {
  this.font = font;
  this.getCommands = function(hPoints) {
    return glyf.getPath(hPoints).commands;
  };
  this._fpgmState = this._prepState = void 0;
  this._errorState = 0;
}
function roundOff(v) {
  return v;
}
function roundToGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v));
}
function roundToDoubleGrid(v) {
  return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}
function roundToHalfGrid(v) {
  return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}
function roundUpToGrid(v) {
  return Math.sign(v) * Math.ceil(Math.abs(v));
}
function roundDownToGrid(v) {
  return Math.sign(v) * Math.floor(Math.abs(v));
}
var roundSuper = function(v) {
  var period = this.srPeriod;
  var phase = this.srPhase;
  var threshold = this.srThreshold;
  var sign = 1;
  if (v < 0) {
    v = -v;
    sign = -1;
  }
  v += threshold - phase;
  v = Math.trunc(v / period) * period;
  v += phase;
  if (v < 0) {
    return phase * sign;
  }
  return v * sign;
};
var xUnitVector = {
  x: 1,
  y: 0,
  axis: "x",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.xo - rp1.xo;
      do2 = p.xo - rp2.xo;
      dm1 = rp1.x - rp1.xo;
      dm2 = rp2.x - rp2.xo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.x = p.xo + (dm1 + dm2) / 2;
        return;
      }
      p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  // Slope of line normal to this
  normalSlope: Number.NEGATIVE_INFINITY,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'.
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.x = (org ? rp.xo : rp.x) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
  },
  // Slope of vector line.
  slope: 0,
  // Touches the point p.
  touch: function(p) {
    p.xTouched = true;
  },
  // Tests if a point p is touched.
  touched: function(p) {
    return p.xTouched;
  },
  // Untouches the point p.
  untouch: function(p) {
    p.xTouched = false;
  }
};
var yUnitVector = {
  x: 0,
  y: 1,
  axis: "y",
  // Gets the projected distance between two points.
  // o1/o2 ... if true, respective original position is used.
  distance: function(p1, p2, o1, o2) {
    return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
  },
  // Moves point p so the moved position has the same relative
  // position to the moved positions of rp1 and rp2 than the
  // original positions had.
  //
  // See APPENDIX on INTERPOLATE at the bottom of this file.
  interpolate: function(p, rp1, rp2, pv) {
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dm1;
    var dm2;
    var dt;
    if (!pv || pv === this) {
      do1 = p.yo - rp1.yo;
      do2 = p.yo - rp2.yo;
      dm1 = rp1.y - rp1.yo;
      dm2 = rp2.y - rp2.yo;
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;
      if (dt === 0) {
        p.y = p.yo + (dm1 + dm2) / 2;
        return;
      }
      p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
      return;
    }
    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;
    if (dt === 0) {
      yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
      return;
    }
    yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  },
  // Slope of line normal to this.
  normalSlope: 0,
  // Sets the point 'p' relative to point 'rp'
  // by the distance 'd'
  //
  // See APPENDIX on SETRELATIVE at the bottom of this file.
  //
  // p   ... point to set
  // rp  ... reference point
  // d   ... distance on projection vector
  // pv  ... projection vector (undefined = this)
  // org ... if true, uses the original position of rp as reference.
  setRelative: function(p, rp, d, pv, org) {
    if (!pv || pv === this) {
      p.y = (org ? rp.yo : rp.y) + d;
      return;
    }
    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;
    p.y = rpdy + pv.normalSlope * (p.x - rpdx);
  },
  // Slope of vector line.
  slope: Number.POSITIVE_INFINITY,
  // Touches the point p.
  touch: function(p) {
    p.yTouched = true;
  },
  // Tests if a point p is touched.
  touched: function(p) {
    return p.yTouched;
  },
  // Untouches the point p.
  untouch: function(p) {
    p.yTouched = false;
  }
};
Object.freeze(xUnitVector);
Object.freeze(yUnitVector);
function UnitVector(x, y) {
  this.x = x;
  this.y = y;
  this.axis = void 0;
  this.slope = y / x;
  this.normalSlope = -x / y;
  Object.freeze(this);
}
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
  return this.x * xUnitVector.distance(p1, p2, o1, o2) + this.y * yUnitVector.distance(p1, p2, o1, o2);
};
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
  var dm1;
  var dm2;
  var do1;
  var do2;
  var doa1;
  var doa2;
  var dt;
  do1 = pv.distance(p, rp1, true, true);
  do2 = pv.distance(p, rp2, true, true);
  dm1 = pv.distance(rp1, rp1, false, true);
  dm2 = pv.distance(rp2, rp2, false, true);
  doa1 = Math.abs(do1);
  doa2 = Math.abs(do2);
  dt = doa1 + doa2;
  if (dt === 0) {
    this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
    return;
  }
  this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
  pv = pv || this;
  var rpx = org ? rp.xo : rp.x;
  var rpy = org ? rp.yo : rp.y;
  var rpdx = rpx + d * pv.x;
  var rpdy = rpy + d * pv.y;
  var pvns = pv.normalSlope;
  var fvs = this.slope;
  var px = p.x;
  var py = p.y;
  p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
  p.y = fvs * (p.x - px) + py;
};
UnitVector.prototype.touch = function(p) {
  p.xTouched = true;
  p.yTouched = true;
};
function getUnitVector(x, y) {
  var d = Math.sqrt(x * x + y * y);
  x /= d;
  y /= d;
  if (x === 1 && y === 0) {
    return xUnitVector;
  } else if (x === 0 && y === 1) {
    return yUnitVector;
  } else {
    return new UnitVector(x, y);
  }
}
function HPoint(x, y, lastPointOfContour, onCurve) {
  this.x = this.xo = Math.round(x * 64) / 64;
  this.y = this.yo = Math.round(y * 64) / 64;
  this.lastPointOfContour = lastPointOfContour;
  this.onCurve = onCurve;
  this.prevPointOnContour = void 0;
  this.nextPointOnContour = void 0;
  this.xTouched = false;
  this.yTouched = false;
  Object.preventExtensions(this);
}
HPoint.prototype.nextTouched = function(v) {
  var p = this.nextPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.nextPointOnContour;
  }
  return p;
};
HPoint.prototype.prevTouched = function(v) {
  var p = this.prevPointOnContour;
  while (!v.touched(p) && p !== this) {
    p = p.prevPointOnContour;
  }
  return p;
};
var HPZero = Object.freeze(new HPoint(0, 0));
var defaultState = {
  cvCutIn: 17 / 16,
  // control value cut in
  deltaBase: 9,
  deltaShift: 0.125,
  loop: 1,
  // loops some instructions
  minDis: 1,
  // minimum distance
  autoFlip: true
};
function State(env, prog) {
  this.env = env;
  this.stack = [];
  this.prog = prog;
  switch (env) {
    case "glyf":
      this.zp0 = this.zp1 = this.zp2 = 1;
      this.rp0 = this.rp1 = this.rp2 = 0;
    /* fall through */
    case "prep":
      this.fv = this.pv = this.dpv = xUnitVector;
      this.round = roundToGrid;
  }
}
Hinting.prototype.exec = function(glyph, ppem) {
  if (typeof ppem !== "number") {
    throw new Error("Point size is not a number!");
  }
  if (this._errorState > 2) {
    return;
  }
  var font = this.font;
  var prepState = this._prepState;
  if (!prepState || prepState.ppem !== ppem) {
    var fpgmState = this._fpgmState;
    if (!fpgmState) {
      State.prototype = defaultState;
      fpgmState = this._fpgmState = new State("fpgm", font.tables.fpgm);
      fpgmState.funcs = [];
      fpgmState.font = font;
      if (exports.DEBUG) {
        console.log("---EXEC FPGM---");
        fpgmState.step = -1;
      }
      try {
        exec(fpgmState);
      } catch (e) {
        console.log("Hinting error in FPGM:" + e);
        this._errorState = 3;
        return;
      }
    }
    State.prototype = fpgmState;
    prepState = this._prepState = new State("prep", font.tables.prep);
    prepState.ppem = ppem;
    var oCvt = font.tables.cvt;
    if (oCvt) {
      var cvt = prepState.cvt = new Array(oCvt.length);
      var scale = ppem / font.unitsPerEm;
      for (var c = 0; c < oCvt.length; c++) {
        cvt[c] = oCvt[c] * scale;
      }
    } else {
      prepState.cvt = [];
    }
    if (exports.DEBUG) {
      console.log("---EXEC PREP---");
      prepState.step = -1;
    }
    try {
      exec(prepState);
    } catch (e) {
      if (this._errorState < 2) {
        console.log("Hinting error in PREP:" + e);
      }
      this._errorState = 2;
    }
  }
  if (this._errorState > 1) {
    return;
  }
  try {
    return execGlyph(glyph, prepState);
  } catch (e) {
    if (this._errorState < 1) {
      console.log("Hinting error:" + e);
      console.log("Note: further hinting errors are silenced");
    }
    this._errorState = 1;
    return void 0;
  }
};
execGlyph = function(glyph, prepState) {
  var xScale = prepState.ppem / prepState.font.unitsPerEm;
  var yScale = xScale;
  var components = glyph.components;
  var contours;
  var gZone;
  var state;
  State.prototype = prepState;
  if (!components) {
    state = new State("glyf", glyph.instructions);
    if (exports.DEBUG) {
      console.log("---EXEC GLYPH---");
      state.step = -1;
    }
    execComponent(glyph, state, xScale, yScale);
    gZone = state.gZone;
  } else {
    var font = prepState.font;
    gZone = [];
    contours = [];
    for (var i = 0; i < components.length; i++) {
      var c = components[i];
      var cg = font.glyphs.get(c.glyphIndex);
      state = new State("glyf", cg.instructions);
      if (exports.DEBUG) {
        console.log("---EXEC COMP " + i + "---");
        state.step = -1;
      }
      execComponent(cg, state, xScale, yScale);
      var dx = Math.round(c.dx * xScale);
      var dy = Math.round(c.dy * yScale);
      var gz = state.gZone;
      var cc = state.contours;
      for (var pi = 0; pi < gz.length; pi++) {
        var p = gz[pi];
        p.xTouched = p.yTouched = false;
        p.xo = p.x = p.x + dx;
        p.yo = p.y = p.y + dy;
      }
      var gLen = gZone.length;
      gZone.push.apply(gZone, gz);
      for (var j = 0; j < cc.length; j++) {
        contours.push(cc[j] + gLen);
      }
    }
    if (glyph.instructions && !state.inhibitGridFit) {
      state = new State("glyf", glyph.instructions);
      state.gZone = state.z0 = state.z1 = state.z2 = gZone;
      state.contours = contours;
      gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
      );
      if (exports.DEBUG) {
        console.log("---EXEC COMPOSITE---");
        state.step = -1;
      }
      exec(state);
      gZone.length -= 2;
    }
  }
  return gZone;
};
execComponent = function(glyph, state, xScale, yScale) {
  var points = glyph.points || [];
  var pLen = points.length;
  var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
  var contours = state.contours = [];
  var cp;
  for (var i = 0; i < pLen; i++) {
    cp = points[i];
    gZone[i] = new HPoint(
      cp.x * xScale,
      cp.y * yScale,
      cp.lastPointOfContour,
      cp.onCurve
    );
  }
  var sp;
  var np;
  for (var i$1 = 0; i$1 < pLen; i$1++) {
    cp = gZone[i$1];
    if (!sp) {
      sp = cp;
      contours.push(i$1);
    }
    if (cp.lastPointOfContour) {
      cp.nextPointOnContour = sp;
      sp.prevPointOnContour = cp;
      sp = void 0;
    } else {
      np = gZone[i$1 + 1];
      cp.nextPointOnContour = np;
      np.prevPointOnContour = cp;
    }
  }
  if (state.inhibitGridFit) {
    return;
  }
  if (exports.DEBUG) {
    console.log("PROCESSING GLYPH", state.stack);
    for (var i$2 = 0; i$2 < pLen; i$2++) {
      console.log(i$2, gZone[i$2].x, gZone[i$2].y);
    }
  }
  gZone.push(
    new HPoint(0, 0),
    new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
  );
  exec(state);
  gZone.length -= 2;
  if (exports.DEBUG) {
    console.log("FINISHED GLYPH", state.stack);
    for (var i$3 = 0; i$3 < pLen; i$3++) {
      console.log(i$3, gZone[i$3].x, gZone[i$3].y);
    }
  }
};
exec = function(state) {
  var prog = state.prog;
  if (!prog) {
    return;
  }
  var pLen = prog.length;
  var ins;
  for (state.ip = 0; state.ip < pLen; state.ip++) {
    if (exports.DEBUG) {
      state.step++;
    }
    ins = instructionTable[prog[state.ip]];
    if (!ins) {
      throw new Error(
        "unknown instruction: 0x" + Number(prog[state.ip]).toString(16)
      );
    }
    ins(state);
  }
};
function initTZone(state) {
  var tZone = state.tZone = new Array(state.gZone.length);
  for (var i = 0; i < tZone.length; i++) {
    tZone[i] = new HPoint(0, 0);
  }
}
function skip(state, handleElse) {
  var prog = state.prog;
  var ip = state.ip;
  var nesting = 1;
  var ins;
  do {
    ins = prog[++ip];
    if (ins === 88) {
      nesting++;
    } else if (ins === 89) {
      nesting--;
    } else if (ins === 64) {
      ip += prog[ip + 1] + 1;
    } else if (ins === 65) {
      ip += 2 * prog[ip + 1] + 1;
    } else if (ins >= 176 && ins <= 183) {
      ip += ins - 176 + 1;
    } else if (ins >= 184 && ins <= 191) {
      ip += (ins - 184 + 1) * 2;
    } else if (handleElse && nesting === 1 && ins === 27) {
      break;
    }
  } while (nesting > 0);
  state.ip = ip;
}
function SVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SVTCA[" + v.axis + "]");
  }
  state.fv = state.pv = state.dpv = v;
}
function SPVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SPVTCA[" + v.axis + "]");
  }
  state.pv = state.dpv = v;
}
function SFVTCA(v, state) {
  if (exports.DEBUG) {
    console.log(state.step, "SFVTCA[" + v.axis + "]");
  }
  state.fv = v;
}
function SPVTL(a, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SPVTL[" + a + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.pv = state.dpv = getUnitVector(dx, dy);
}
function SFVTL(a, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log("SFVTL[" + a + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.fv = getUnitVector(dx, dy);
}
function SPVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.pv = state.dpv = getUnitVector(x, y);
}
function SFVFS(state) {
  var stack = state.stack;
  var y = stack.pop();
  var x = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SPVFS[]", y, x);
  }
  state.fv = getUnitVector(x, y);
}
function GPV(state) {
  var stack = state.stack;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "GPV[]");
  }
  stack.push(pv.x * 16384);
  stack.push(pv.y * 16384);
}
function GFV(state) {
  var stack = state.stack;
  var fv = state.fv;
  if (exports.DEBUG) {
    console.log(state.step, "GFV[]");
  }
  stack.push(fv.x * 16384);
  stack.push(fv.y * 16384);
}
function SFVTPV(state) {
  state.fv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "SFVTPV[]");
  }
}
function ISECT(state) {
  var stack = state.stack;
  var pa0i = stack.pop();
  var pa1i = stack.pop();
  var pb0i = stack.pop();
  var pb1i = stack.pop();
  var pi = stack.pop();
  var z0 = state.z0;
  var z1 = state.z1;
  var pa0 = z0[pa0i];
  var pa1 = z0[pa1i];
  var pb0 = z1[pb0i];
  var pb1 = z1[pb1i];
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log("ISECT[], ", pa0i, pa1i, pb0i, pb1i, pi);
  }
  var x1 = pa0.x;
  var y1 = pa0.y;
  var x2 = pa1.x;
  var y2 = pa1.y;
  var x3 = pb0.x;
  var y3 = pb0.y;
  var x4 = pb1.x;
  var y4 = pb1.y;
  var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  var f1 = x1 * y2 - y1 * x2;
  var f2 = x3 * y4 - y3 * x4;
  p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
  p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}
function SRP0(state) {
  state.rp0 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP0[]", state.rp0);
  }
}
function SRP1(state) {
  state.rp1 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP1[]", state.rp1);
  }
}
function SRP2(state) {
  state.rp2 = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SRP2[]", state.rp2);
  }
}
function SZP0(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP0[]", n);
  }
  state.zp0 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.tZone;
      break;
    case 1:
      state.z0 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP1(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP1[]", n);
  }
  state.zp1 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z1 = state.tZone;
      break;
    case 1:
      state.z1 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZP2(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZP2[]", n);
  }
  state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z2 = state.tZone;
      break;
    case 1:
      state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SZPS(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SZPS[]", n);
  }
  state.zp0 = state.zp1 = state.zp2 = n;
  switch (n) {
    case 0:
      if (!state.tZone) {
        initTZone(state);
      }
      state.z0 = state.z1 = state.z2 = state.tZone;
      break;
    case 1:
      state.z0 = state.z1 = state.z2 = state.gZone;
      break;
    default:
      throw new Error("Invalid zone pointer");
  }
}
function SLOOP(state) {
  state.loop = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SLOOP[]", state.loop);
  }
}
function RTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTG[]");
  }
  state.round = roundToGrid;
}
function RTHG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTHG[]");
  }
  state.round = roundToHalfGrid;
}
function SMD(state) {
  var d = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SMD[]", d);
  }
  state.minDis = d / 64;
}
function ELSE(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ELSE[]");
  }
  skip(state, false);
}
function JMPR(state) {
  var o = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "JMPR[]", o);
  }
  state.ip += o - 1;
}
function SCVTCI(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCVTCI[]", n);
  }
  state.cvCutIn = n / 64;
}
function DUP(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DUP[]");
  }
  stack.push(stack[stack.length - 1]);
}
function POP(state) {
  if (exports.DEBUG) {
    console.log(state.step, "POP[]");
  }
  state.stack.pop();
}
function CLEAR(state) {
  if (exports.DEBUG) {
    console.log(state.step, "CLEAR[]");
  }
  state.stack.length = 0;
}
function SWAP(state) {
  var stack = state.stack;
  var a = stack.pop();
  var b = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SWAP[]");
  }
  stack.push(a);
  stack.push(b);
}
function DEPTH(state) {
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.step, "DEPTH[]");
  }
  stack.push(stack.length);
}
function LOOPCALL(state) {
  var stack = state.stack;
  var fn = stack.pop();
  var c = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LOOPCALL[]", fn, c);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  for (var i = 0; i < c; i++) {
    exec(state);
    if (exports.DEBUG) {
      console.log(
        ++state.step,
        i + 1 < c ? "next loopcall" : "done loopcall",
        i
      );
    }
  }
  state.ip = cip;
  state.prog = cprog;
}
function CALL(state) {
  var fn = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CALL[]", fn);
  }
  var cip = state.ip;
  var cprog = state.prog;
  state.prog = state.funcs[fn];
  exec(state);
  state.ip = cip;
  state.prog = cprog;
  if (exports.DEBUG) {
    console.log(++state.step, "returning from", fn);
  }
}
function CINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CINDEX[]", k);
  }
  stack.push(stack[stack.length - k]);
}
function MINDEX(state) {
  var stack = state.stack;
  var k = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MINDEX[]", k);
  }
  stack.push(stack.splice(stack.length - k, 1)[0]);
}
function FDEF(state) {
  if (state.env !== "fpgm") {
    throw new Error("FDEF not allowed here");
  }
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  var fn = stack.pop();
  var ipBegin = ip;
  if (exports.DEBUG) {
    console.log(state.step, "FDEF[]", fn);
  }
  while (prog[++ip] !== 45) {
  }
  state.ip = ip;
  state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}
function MDAP(round, state) {
  var pi = state.stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  if (exports.DEBUG) {
    console.log(state.step, "MDAP[" + round + "]", pi);
  }
  var d = pv.distance(p, HPZero);
  if (round) {
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function IUP(v, state) {
  var z2 = state.z2;
  var pLen = z2.length - 2;
  var cp;
  var pp;
  var np;
  if (exports.DEBUG) {
    console.log(state.step, "IUP[" + v.axis + "]");
  }
  for (var i = 0; i < pLen; i++) {
    cp = z2[i];
    if (v.touched(cp)) {
      continue;
    }
    pp = cp.prevTouched(v);
    if (pp === cp) {
      continue;
    }
    np = cp.nextTouched(v);
    if (pp === np) {
      v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
    }
    v.interpolate(cp, pp, np, v);
  }
}
function SHP(a, state) {
  var stack = state.stack;
  var rpi = a ? state.rp1 : state.rp2;
  var rp = (a ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var loop = state.loop;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    var d = pv.distance(rp, rp, false, true);
    fv.setRelative(p, p, d, pv);
    fv.touch(p);
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHP[" + (a ? "rp1" : "rp2") + "]",
        pi
      );
    }
  }
  state.loop = 1;
}
function SHC(a, state) {
  var stack = state.stack;
  var rpi = a ? state.rp1 : state.rp2;
  var rp = (a ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var ci = stack.pop();
  var sp = state.z2[state.contours[ci]];
  var p = sp;
  if (exports.DEBUG) {
    console.log(state.step, "SHC[" + a + "]", ci);
  }
  var d = pv.distance(rp, rp, false, true);
  do {
    if (p !== rp) {
      fv.setRelative(p, p, d, pv);
    }
    p = p.nextPointOnContour;
  } while (p !== sp);
}
function SHZ(a, state) {
  var stack = state.stack;
  var rpi = a ? state.rp1 : state.rp2;
  var rp = (a ? state.z0 : state.z1)[rpi];
  var fv = state.fv;
  var pv = state.pv;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SHZ[" + a + "]", e);
  }
  var z;
  switch (e) {
    case 0:
      z = state.tZone;
      break;
    case 1:
      z = state.gZone;
      break;
    default:
      throw new Error("Invalid zone");
  }
  var p;
  var d = pv.distance(rp, rp, false, true);
  var pLen = z.length - 2;
  for (var i = 0; i < pLen; i++) {
    p = z[i];
    fv.setRelative(p, p, d, pv);
  }
}
function SHPIX(state) {
  var stack = state.stack;
  var loop = state.loop;
  var fv = state.fv;
  var d = stack.pop() / 64;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "SHPIX[]",
        pi,
        d
      );
    }
    fv.setRelative(p, p, d);
    fv.touch(p);
  }
  state.loop = 1;
}
function IP(state) {
  var stack = state.stack;
  var rp1i = state.rp1;
  var rp2i = state.rp2;
  var loop = state.loop;
  var rp1 = state.z0[rp1i];
  var rp2 = state.z1[rp2i];
  var fv = state.fv;
  var pv = state.dpv;
  var z2 = state.z2;
  while (loop--) {
    var pi = stack.pop();
    var p = z2[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "IP[]",
        pi,
        rp1i,
        "<->",
        rp2i
      );
    }
    fv.interpolate(p, rp1, rp2, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function MSIRP(a, state) {
  var stack = state.stack;
  var d = stack.pop() / 64;
  var pi = stack.pop();
  var p = state.z1[pi];
  var rp0 = state.z0[state.rp0];
  var fv = state.fv;
  var pv = state.pv;
  fv.setRelative(p, rp0, d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(state.step, "MSIRP[" + a + "]", d, pi);
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (a) {
    state.rp0 = pi;
  }
}
function ALIGNRP(state) {
  var stack = state.stack;
  var rp0i = state.rp0;
  var rp0 = state.z0[rp0i];
  var loop = state.loop;
  var fv = state.fv;
  var pv = state.pv;
  var z1 = state.z1;
  while (loop--) {
    var pi = stack.pop();
    var p = z1[pi];
    if (exports.DEBUG) {
      console.log(
        state.step,
        (state.loop > 1 ? "loop " + (state.loop - loop) + ": " : "") + "ALIGNRP[]",
        pi
      );
    }
    fv.setRelative(p, rp0, 0, pv);
    fv.touch(p);
  }
  state.loop = 1;
}
function RTDG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RTDG[]");
  }
  state.round = roundToDoubleGrid;
}
function MIAP(round, state) {
  var stack = state.stack;
  var n = stack.pop();
  var pi = stack.pop();
  var p = state.z0[pi];
  var fv = state.fv;
  var pv = state.pv;
  var cv = state.cvt[n];
  if (exports.DEBUG) {
    console.log(
      state.step,
      "MIAP[" + round + "]",
      n,
      "(",
      cv,
      ")",
      pi
    );
  }
  var d = pv.distance(p, HPZero);
  if (round) {
    if (Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
    d = state.round(d);
  }
  fv.setRelative(p, HPZero, d, pv);
  if (state.zp0 === 0) {
    p.xo = p.x;
    p.yo = p.y;
  }
  fv.touch(p);
  state.rp0 = state.rp1 = pi;
}
function NPUSHB(state) {
  var prog = state.prog;
  var ip = state.ip;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHB[]", n);
  }
  for (var i = 0; i < n; i++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function NPUSHW(state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  var n = prog[++ip];
  if (exports.DEBUG) {
    console.log(state.step, "NPUSHW[]", n);
  }
  for (var i = 0; i < n; i++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function WS(state) {
  var stack = state.stack;
  var store = state.store;
  if (!store) {
    store = state.store = [];
  }
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WS", v, l);
  }
  store[l] = v;
}
function RS(state) {
  var stack = state.stack;
  var store = state.store;
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RS", l);
  }
  var v = store && store[l] || 0;
  stack.push(v);
}
function WCVTP(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTP", v, l);
  }
  state.cvt[l] = v / 64;
}
function RCVT(state) {
  var stack = state.stack;
  var cvte = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "RCVT", cvte);
  }
  stack.push(state.cvt[cvte] * 64);
}
function GC(a, state) {
  var stack = state.stack;
  var pi = stack.pop();
  var p = state.z2[pi];
  if (exports.DEBUG) {
    console.log(state.step, "GC[" + a + "]", pi);
  }
  stack.push(state.dpv.distance(p, HPZero, a, false) * 64);
}
function MD(a, state) {
  var stack = state.stack;
  var pi2 = stack.pop();
  var pi1 = stack.pop();
  var p2 = state.z1[pi2];
  var p1 = state.z0[pi1];
  var d = state.dpv.distance(p1, p2, a, a);
  if (exports.DEBUG) {
    console.log(state.step, "MD[" + a + "]", pi2, pi1, "->", d);
  }
  state.stack.push(Math.round(d * 64));
}
function MPPEM(state) {
  if (exports.DEBUG) {
    console.log(state.step, "MPPEM[]");
  }
  state.stack.push(state.ppem);
}
function FLIPON(state) {
  if (exports.DEBUG) {
    console.log(state.step, "FLIPON[]");
  }
  state.autoFlip = true;
}
function LT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LT[]", e2, e1);
  }
  stack.push(e1 < e2 ? 1 : 0);
}
function LTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "LTEQ[]", e2, e1);
  }
  stack.push(e1 <= e2 ? 1 : 0);
}
function GT(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GT[]", e2, e1);
  }
  stack.push(e1 > e2 ? 1 : 0);
}
function GTEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "GTEQ[]", e2, e1);
  }
  stack.push(e1 >= e2 ? 1 : 0);
}
function EQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EQ[]", e2, e1);
  }
  stack.push(e2 === e1 ? 1 : 0);
}
function NEQ(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEQ[]", e2, e1);
  }
  stack.push(e2 !== e1 ? 1 : 0);
}
function ODD(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ODD[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 1 : 0);
}
function EVEN(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "EVEN[]", n);
  }
  stack.push(Math.trunc(n) % 2 ? 0 : 1);
}
function IF(state) {
  var test = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "IF[]", test);
  }
  if (!test) {
    skip(state, true);
    if (exports.DEBUG) {
      console.log(state.step, "EIF[]");
    }
  }
}
function EIF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "EIF[]");
  }
}
function AND(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "AND[]", e2, e1);
  }
  stack.push(e2 && e1 ? 1 : 0);
}
function OR(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "OR[]", e2, e1);
  }
  stack.push(e2 || e1 ? 1 : 0);
}
function NOT(state) {
  var stack = state.stack;
  var e = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NOT[]", e);
  }
  stack.push(e ? 0 : 1);
}
function DELTAP123(b, state) {
  var stack = state.stack;
  var n = stack.pop();
  var fv = state.fv;
  var pv = state.pv;
  var ppem = state.ppem;
  var base = state.deltaBase + (b - 1) * 16;
  var ds = state.deltaShift;
  var z0 = state.z0;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAP[" + b + "]", n, stack);
  }
  for (var i = 0; i < n; i++) {
    var pi = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    if (exports.DEBUG) {
      console.log(state.step, "DELTAPFIX", pi, "by", mag * ds);
    }
    var p = z0[pi];
    fv.setRelative(p, p, mag * ds, pv);
  }
}
function SDB(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDB[]", n);
  }
  state.deltaBase = n;
}
function SDS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SDS[]", n);
  }
  state.deltaShift = Math.pow(0.5, n);
}
function ADD(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ADD[]", n2, n1);
  }
  stack.push(n1 + n2);
}
function SUB(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SUB[]", n2, n1);
  }
  stack.push(n1 - n2);
}
function DIV(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "DIV[]", n2, n1);
  }
  stack.push(n1 * 64 / n2);
}
function MUL(state) {
  var stack = state.stack;
  var n2 = stack.pop();
  var n1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MUL[]", n2, n1);
  }
  stack.push(n1 * n2 / 64);
}
function ABS(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ABS[]", n);
  }
  stack.push(Math.abs(n));
}
function NEG(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "NEG[]", n);
  }
  stack.push(-n);
}
function FLOOR(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "FLOOR[]", n);
  }
  stack.push(Math.floor(n / 64) * 64);
}
function CEILING(state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "CEILING[]", n);
  }
  stack.push(Math.ceil(n / 64) * 64);
}
function ROUND(dt, state) {
  var stack = state.stack;
  var n = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROUND[]");
  }
  stack.push(state.round(n / 64) * 64);
}
function WCVTF(state) {
  var stack = state.stack;
  var v = stack.pop();
  var l = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "WCVTF[]", v, l);
  }
  state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}
function DELTAC123(b, state) {
  var stack = state.stack;
  var n = stack.pop();
  var ppem = state.ppem;
  var base = state.deltaBase + (b - 1) * 16;
  var ds = state.deltaShift;
  if (exports.DEBUG) {
    console.log(state.step, "DELTAC[" + b + "]", n, stack);
  }
  for (var i = 0; i < n; i++) {
    var c = stack.pop();
    var arg = stack.pop();
    var appem = base + ((arg & 240) >> 4);
    if (appem !== ppem) {
      continue;
    }
    var mag = (arg & 15) - 8;
    if (mag >= 0) {
      mag++;
    }
    var delta = mag * ds;
    if (exports.DEBUG) {
      console.log(state.step, "DELTACFIX", c, "by", delta);
    }
    state.cvt[c] += delta;
  }
}
function SROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = 0.5;
      break;
    case 64:
      period = 1;
      break;
    case 128:
      period = 2;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid SROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function S45ROUND(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "S45ROUND[]", n);
  }
  state.round = roundSuper;
  var period;
  switch (n & 192) {
    case 0:
      period = Math.sqrt(2) / 2;
      break;
    case 64:
      period = Math.sqrt(2);
      break;
    case 128:
      period = 2 * Math.sqrt(2);
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  state.srPeriod = period;
  switch (n & 48) {
    case 0:
      state.srPhase = 0;
      break;
    case 16:
      state.srPhase = 0.25 * period;
      break;
    case 32:
      state.srPhase = 0.5 * period;
      break;
    case 48:
      state.srPhase = 0.75 * period;
      break;
    default:
      throw new Error("invalid S45ROUND value");
  }
  n &= 15;
  if (n === 0) {
    state.srThreshold = 0;
  } else {
    state.srThreshold = (n / 8 - 0.5) * period;
  }
}
function ROFF(state) {
  if (exports.DEBUG) {
    console.log(state.step, "ROFF[]");
  }
  state.round = roundOff;
}
function RUTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RUTG[]");
  }
  state.round = roundUpToGrid;
}
function RDTG(state) {
  if (exports.DEBUG) {
    console.log(state.step, "RDTG[]");
  }
  state.round = roundDownToGrid;
}
function SCANCTRL(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANCTRL[]", n);
  }
}
function SDPVTL(a, state) {
  var stack = state.stack;
  var p2i = stack.pop();
  var p1i = stack.pop();
  var p2 = state.z2[p2i];
  var p1 = state.z1[p1i];
  if (exports.DEBUG) {
    console.log(state.step, "SDPVTL[" + a + "]", p2i, p1i);
  }
  var dx;
  var dy;
  if (!a) {
    dx = p1.x - p2.x;
    dy = p1.y - p2.y;
  } else {
    dx = p2.y - p1.y;
    dy = p1.x - p2.x;
  }
  state.dpv = getUnitVector(dx, dy);
}
function GETINFO(state) {
  var stack = state.stack;
  var sel = stack.pop();
  var r = 0;
  if (exports.DEBUG) {
    console.log(state.step, "GETINFO[]", sel);
  }
  if (sel & 1) {
    r = 35;
  }
  if (sel & 32) {
    r |= 4096;
  }
  stack.push(r);
}
function ROLL(state) {
  var stack = state.stack;
  var a = stack.pop();
  var b = stack.pop();
  var c = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "ROLL[]");
  }
  stack.push(b);
  stack.push(a);
  stack.push(c);
}
function MAX(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MAX[]", e2, e1);
  }
  stack.push(Math.max(e1, e2));
}
function MIN(state) {
  var stack = state.stack;
  var e2 = stack.pop();
  var e1 = stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "MIN[]", e2, e1);
  }
  stack.push(Math.min(e1, e2));
}
function SCANTYPE(state) {
  var n = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "SCANTYPE[]", n);
  }
}
function INSTCTRL(state) {
  var s = state.stack.pop();
  var v = state.stack.pop();
  if (exports.DEBUG) {
    console.log(state.step, "INSTCTRL[]", s, v);
  }
  switch (s) {
    case 1:
      state.inhibitGridFit = !!v;
      return;
    case 2:
      state.ignoreCvt = !!v;
      return;
    default:
      throw new Error("invalid INSTCTRL[] selector");
  }
}
function PUSHB(n, state) {
  var stack = state.stack;
  var prog = state.prog;
  var ip = state.ip;
  if (exports.DEBUG) {
    console.log(state.step, "PUSHB[" + n + "]");
  }
  for (var i = 0; i < n; i++) {
    stack.push(prog[++ip]);
  }
  state.ip = ip;
}
function PUSHW(n, state) {
  var ip = state.ip;
  var prog = state.prog;
  var stack = state.stack;
  if (exports.DEBUG) {
    console.log(state.ip, "PUSHW[" + n + "]");
  }
  for (var i = 0; i < n; i++) {
    var w = prog[++ip] << 8 | prog[++ip];
    if (w & 32768) {
      w = -((w ^ 65535) + 1);
    }
    stack.push(w);
  }
  state.ip = ip;
}
function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
  var stack = state.stack;
  var cvte = indirect && stack.pop();
  var pi = stack.pop();
  var rp0i = state.rp0;
  var rp = state.z0[rp0i];
  var p = state.z1[pi];
  var md = state.minDis;
  var fv = state.fv;
  var pv = state.dpv;
  var od;
  var d;
  var sign;
  var cv;
  d = od = pv.distance(p, rp, true, true);
  sign = d >= 0 ? 1 : -1;
  d = Math.abs(d);
  if (indirect) {
    cv = state.cvt[cvte];
    if (ro && Math.abs(d - cv) < state.cvCutIn) {
      d = cv;
    }
  }
  if (keepD && d < md) {
    d = md;
  }
  if (ro) {
    d = state.round(d);
  }
  fv.setRelative(p, rp, sign * d, pv);
  fv.touch(p);
  if (exports.DEBUG) {
    console.log(
      state.step,
      (indirect ? "MIRP[" : "MDRP[") + (setRp0 ? "M" : "m") + (keepD ? ">" : "_") + (ro ? "R" : "_") + (dt === 0 ? "Gr" : dt === 1 ? "Bl" : dt === 2 ? "Wh" : "") + "]",
      indirect ? cvte + "(" + state.cvt[cvte] + "," + cv + ")" : "",
      pi,
      "(d =",
      od,
      "->",
      sign * d,
      ")"
    );
  }
  state.rp1 = state.rp0;
  state.rp2 = pi;
  if (setRp0) {
    state.rp0 = pi;
  }
}
instructionTable = [
  /* 0x00 */
  SVTCA.bind(void 0, yUnitVector),
  /* 0x01 */
  SVTCA.bind(void 0, xUnitVector),
  /* 0x02 */
  SPVTCA.bind(void 0, yUnitVector),
  /* 0x03 */
  SPVTCA.bind(void 0, xUnitVector),
  /* 0x04 */
  SFVTCA.bind(void 0, yUnitVector),
  /* 0x05 */
  SFVTCA.bind(void 0, xUnitVector),
  /* 0x06 */
  SPVTL.bind(void 0, 0),
  /* 0x07 */
  SPVTL.bind(void 0, 1),
  /* 0x08 */
  SFVTL.bind(void 0, 0),
  /* 0x09 */
  SFVTL.bind(void 0, 1),
  /* 0x0A */
  SPVFS,
  /* 0x0B */
  SFVFS,
  /* 0x0C */
  GPV,
  /* 0x0D */
  GFV,
  /* 0x0E */
  SFVTPV,
  /* 0x0F */
  ISECT,
  /* 0x10 */
  SRP0,
  /* 0x11 */
  SRP1,
  /* 0x12 */
  SRP2,
  /* 0x13 */
  SZP0,
  /* 0x14 */
  SZP1,
  /* 0x15 */
  SZP2,
  /* 0x16 */
  SZPS,
  /* 0x17 */
  SLOOP,
  /* 0x18 */
  RTG,
  /* 0x19 */
  RTHG,
  /* 0x1A */
  SMD,
  /* 0x1B */
  ELSE,
  /* 0x1C */
  JMPR,
  /* 0x1D */
  SCVTCI,
  /* 0x1E */
  void 0,
  // TODO SSWCI
  /* 0x1F */
  void 0,
  // TODO SSW
  /* 0x20 */
  DUP,
  /* 0x21 */
  POP,
  /* 0x22 */
  CLEAR,
  /* 0x23 */
  SWAP,
  /* 0x24 */
  DEPTH,
  /* 0x25 */
  CINDEX,
  /* 0x26 */
  MINDEX,
  /* 0x27 */
  void 0,
  // TODO ALIGNPTS
  /* 0x28 */
  void 0,
  /* 0x29 */
  void 0,
  // TODO UTP
  /* 0x2A */
  LOOPCALL,
  /* 0x2B */
  CALL,
  /* 0x2C */
  FDEF,
  /* 0x2D */
  void 0,
  // ENDF (eaten by FDEF)
  /* 0x2E */
  MDAP.bind(void 0, 0),
  /* 0x2F */
  MDAP.bind(void 0, 1),
  /* 0x30 */
  IUP.bind(void 0, yUnitVector),
  /* 0x31 */
  IUP.bind(void 0, xUnitVector),
  /* 0x32 */
  SHP.bind(void 0, 0),
  /* 0x33 */
  SHP.bind(void 0, 1),
  /* 0x34 */
  SHC.bind(void 0, 0),
  /* 0x35 */
  SHC.bind(void 0, 1),
  /* 0x36 */
  SHZ.bind(void 0, 0),
  /* 0x37 */
  SHZ.bind(void 0, 1),
  /* 0x38 */
  SHPIX,
  /* 0x39 */
  IP,
  /* 0x3A */
  MSIRP.bind(void 0, 0),
  /* 0x3B */
  MSIRP.bind(void 0, 1),
  /* 0x3C */
  ALIGNRP,
  /* 0x3D */
  RTDG,
  /* 0x3E */
  MIAP.bind(void 0, 0),
  /* 0x3F */
  MIAP.bind(void 0, 1),
  /* 0x40 */
  NPUSHB,
  /* 0x41 */
  NPUSHW,
  /* 0x42 */
  WS,
  /* 0x43 */
  RS,
  /* 0x44 */
  WCVTP,
  /* 0x45 */
  RCVT,
  /* 0x46 */
  GC.bind(void 0, 0),
  /* 0x47 */
  GC.bind(void 0, 1),
  /* 0x48 */
  void 0,
  // TODO SCFS
  /* 0x49 */
  MD.bind(void 0, 0),
  /* 0x4A */
  MD.bind(void 0, 1),
  /* 0x4B */
  MPPEM,
  /* 0x4C */
  void 0,
  // TODO MPS
  /* 0x4D */
  FLIPON,
  /* 0x4E */
  void 0,
  // TODO FLIPOFF
  /* 0x4F */
  void 0,
  // TODO DEBUG
  /* 0x50 */
  LT,
  /* 0x51 */
  LTEQ,
  /* 0x52 */
  GT,
  /* 0x53 */
  GTEQ,
  /* 0x54 */
  EQ,
  /* 0x55 */
  NEQ,
  /* 0x56 */
  ODD,
  /* 0x57 */
  EVEN,
  /* 0x58 */
  IF,
  /* 0x59 */
  EIF,
  /* 0x5A */
  AND,
  /* 0x5B */
  OR,
  /* 0x5C */
  NOT,
  /* 0x5D */
  DELTAP123.bind(void 0, 1),
  /* 0x5E */
  SDB,
  /* 0x5F */
  SDS,
  /* 0x60 */
  ADD,
  /* 0x61 */
  SUB,
  /* 0x62 */
  DIV,
  /* 0x63 */
  MUL,
  /* 0x64 */
  ABS,
  /* 0x65 */
  NEG,
  /* 0x66 */
  FLOOR,
  /* 0x67 */
  CEILING,
  /* 0x68 */
  ROUND.bind(void 0, 0),
  /* 0x69 */
  ROUND.bind(void 0, 1),
  /* 0x6A */
  ROUND.bind(void 0, 2),
  /* 0x6B */
  ROUND.bind(void 0, 3),
  /* 0x6C */
  void 0,
  // TODO NROUND[ab]
  /* 0x6D */
  void 0,
  // TODO NROUND[ab]
  /* 0x6E */
  void 0,
  // TODO NROUND[ab]
  /* 0x6F */
  void 0,
  // TODO NROUND[ab]
  /* 0x70 */
  WCVTF,
  /* 0x71 */
  DELTAP123.bind(void 0, 2),
  /* 0x72 */
  DELTAP123.bind(void 0, 3),
  /* 0x73 */
  DELTAC123.bind(void 0, 1),
  /* 0x74 */
  DELTAC123.bind(void 0, 2),
  /* 0x75 */
  DELTAC123.bind(void 0, 3),
  /* 0x76 */
  SROUND,
  /* 0x77 */
  S45ROUND,
  /* 0x78 */
  void 0,
  // TODO JROT[]
  /* 0x79 */
  void 0,
  // TODO JROF[]
  /* 0x7A */
  ROFF,
  /* 0x7B */
  void 0,
  /* 0x7C */
  RUTG,
  /* 0x7D */
  RDTG,
  /* 0x7E */
  POP,
  // actually SANGW, supposed to do only a pop though
  /* 0x7F */
  POP,
  // actually AA, supposed to do only a pop though
  /* 0x80 */
  void 0,
  // TODO FLIPPT
  /* 0x81 */
  void 0,
  // TODO FLIPRGON
  /* 0x82 */
  void 0,
  // TODO FLIPRGOFF
  /* 0x83 */
  void 0,
  /* 0x84 */
  void 0,
  /* 0x85 */
  SCANCTRL,
  /* 0x86 */
  SDPVTL.bind(void 0, 0),
  /* 0x87 */
  SDPVTL.bind(void 0, 1),
  /* 0x88 */
  GETINFO,
  /* 0x89 */
  void 0,
  // TODO IDEF
  /* 0x8A */
  ROLL,
  /* 0x8B */
  MAX,
  /* 0x8C */
  MIN,
  /* 0x8D */
  SCANTYPE,
  /* 0x8E */
  INSTCTRL,
  /* 0x8F */
  void 0,
  /* 0x90 */
  void 0,
  /* 0x91 */
  void 0,
  /* 0x92 */
  void 0,
  /* 0x93 */
  void 0,
  /* 0x94 */
  void 0,
  /* 0x95 */
  void 0,
  /* 0x96 */
  void 0,
  /* 0x97 */
  void 0,
  /* 0x98 */
  void 0,
  /* 0x99 */
  void 0,
  /* 0x9A */
  void 0,
  /* 0x9B */
  void 0,
  /* 0x9C */
  void 0,
  /* 0x9D */
  void 0,
  /* 0x9E */
  void 0,
  /* 0x9F */
  void 0,
  /* 0xA0 */
  void 0,
  /* 0xA1 */
  void 0,
  /* 0xA2 */
  void 0,
  /* 0xA3 */
  void 0,
  /* 0xA4 */
  void 0,
  /* 0xA5 */
  void 0,
  /* 0xA6 */
  void 0,
  /* 0xA7 */
  void 0,
  /* 0xA8 */
  void 0,
  /* 0xA9 */
  void 0,
  /* 0xAA */
  void 0,
  /* 0xAB */
  void 0,
  /* 0xAC */
  void 0,
  /* 0xAD */
  void 0,
  /* 0xAE */
  void 0,
  /* 0xAF */
  void 0,
  /* 0xB0 */
  PUSHB.bind(void 0, 1),
  /* 0xB1 */
  PUSHB.bind(void 0, 2),
  /* 0xB2 */
  PUSHB.bind(void 0, 3),
  /* 0xB3 */
  PUSHB.bind(void 0, 4),
  /* 0xB4 */
  PUSHB.bind(void 0, 5),
  /* 0xB5 */
  PUSHB.bind(void 0, 6),
  /* 0xB6 */
  PUSHB.bind(void 0, 7),
  /* 0xB7 */
  PUSHB.bind(void 0, 8),
  /* 0xB8 */
  PUSHW.bind(void 0, 1),
  /* 0xB9 */
  PUSHW.bind(void 0, 2),
  /* 0xBA */
  PUSHW.bind(void 0, 3),
  /* 0xBB */
  PUSHW.bind(void 0, 4),
  /* 0xBC */
  PUSHW.bind(void 0, 5),
  /* 0xBD */
  PUSHW.bind(void 0, 6),
  /* 0xBE */
  PUSHW.bind(void 0, 7),
  /* 0xBF */
  PUSHW.bind(void 0, 8),
  /* 0xC0 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 0),
  /* 0xC1 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 1),
  /* 0xC2 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 2),
  /* 0xC3 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 0, 3),
  /* 0xC4 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 0),
  /* 0xC5 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 1),
  /* 0xC6 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 2),
  /* 0xC7 */
  MDRP_MIRP.bind(void 0, 0, 0, 0, 1, 3),
  /* 0xC8 */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 0),
  /* 0xC9 */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 1),
  /* 0xCA */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 2),
  /* 0xCB */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 0, 3),
  /* 0xCC */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 0),
  /* 0xCD */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 1),
  /* 0xCE */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 2),
  /* 0xCF */
  MDRP_MIRP.bind(void 0, 0, 0, 1, 1, 3),
  /* 0xD0 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 0),
  /* 0xD1 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 1),
  /* 0xD2 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 2),
  /* 0xD3 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 0, 3),
  /* 0xD4 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 0),
  /* 0xD5 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 1),
  /* 0xD6 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 2),
  /* 0xD7 */
  MDRP_MIRP.bind(void 0, 0, 1, 0, 1, 3),
  /* 0xD8 */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 0),
  /* 0xD9 */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 1),
  /* 0xDA */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 2),
  /* 0xDB */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 0, 3),
  /* 0xDC */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 0),
  /* 0xDD */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 1),
  /* 0xDE */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 2),
  /* 0xDF */
  MDRP_MIRP.bind(void 0, 0, 1, 1, 1, 3),
  /* 0xE0 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 0),
  /* 0xE1 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 1),
  /* 0xE2 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 2),
  /* 0xE3 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 0, 3),
  /* 0xE4 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 0),
  /* 0xE5 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 1),
  /* 0xE6 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 2),
  /* 0xE7 */
  MDRP_MIRP.bind(void 0, 1, 0, 0, 1, 3),
  /* 0xE8 */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 0),
  /* 0xE9 */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 1),
  /* 0xEA */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 2),
  /* 0xEB */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 0, 3),
  /* 0xEC */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 0),
  /* 0xED */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 1),
  /* 0xEE */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 2),
  /* 0xEF */
  MDRP_MIRP.bind(void 0, 1, 0, 1, 1, 3),
  /* 0xF0 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 0),
  /* 0xF1 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 1),
  /* 0xF2 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 2),
  /* 0xF3 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 0, 3),
  /* 0xF4 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 0),
  /* 0xF5 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 1),
  /* 0xF6 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 2),
  /* 0xF7 */
  MDRP_MIRP.bind(void 0, 1, 1, 0, 1, 3),
  /* 0xF8 */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 0),
  /* 0xF9 */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 1),
  /* 0xFA */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 2),
  /* 0xFB */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 0, 3),
  /* 0xFC */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 0),
  /* 0xFD */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 1),
  /* 0xFE */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 2),
  /* 0xFF */
  MDRP_MIRP.bind(void 0, 1, 1, 1, 1, 3)
];
function Token(char) {
  this.char = char;
  this.state = {};
  this.activeState = null;
}
function ContextRange(startIndex, endOffset, contextName) {
  this.contextName = contextName;
  this.startIndex = startIndex;
  this.endOffset = endOffset;
}
function ContextChecker(contextName, checkStart, checkEnd) {
  this.contextName = contextName;
  this.openRange = null;
  this.ranges = [];
  this.checkStart = checkStart;
  this.checkEnd = checkEnd;
}
function ContextParams(context, currentIndex) {
  this.context = context;
  this.index = currentIndex;
  this.length = context.length;
  this.current = context[currentIndex];
  this.backtrack = context.slice(0, currentIndex);
  this.lookahead = context.slice(currentIndex + 1);
}
function Event(eventId) {
  this.eventId = eventId;
  this.subscribers = [];
}
function initializeCoreEvents(events) {
  var this$1 = this;
  var coreEvents = [
    "start",
    "end",
    "next",
    "newToken",
    "contextStart",
    "contextEnd",
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD",
    "updateContextsRanges"
  ];
  coreEvents.forEach(function(eventId) {
    Object.defineProperty(this$1.events, eventId, {
      value: new Event(eventId)
    });
  });
  if (!!events) {
    coreEvents.forEach(function(eventId) {
      var event = events[eventId];
      if (typeof event === "function") {
        this$1.events[eventId].subscribe(event);
      }
    });
  }
  var requiresContextUpdate = [
    "insertToken",
    "removeToken",
    "removeRange",
    "replaceToken",
    "replaceRange",
    "composeRUD"
  ];
  requiresContextUpdate.forEach(function(eventId) {
    this$1.events[eventId].subscribe(
      this$1.updateContextsRanges
    );
  });
}
function Tokenizer(events) {
  this.tokens = [];
  this.registeredContexts = {};
  this.contextCheckers = [];
  this.events = {};
  this.registeredModifiers = [];
  initializeCoreEvents.call(this, events);
}
Token.prototype.setState = function(key, value) {
  this.state[key] = value;
  this.activeState = { key, value: this.state[key] };
  return this.activeState;
};
Token.prototype.getState = function(stateId) {
  return this.state[stateId] || null;
};
Tokenizer.prototype.inboundIndex = function(index) {
  return index >= 0 && index < this.tokens.length;
};
Tokenizer.prototype.composeRUD = function(RUDs) {
  var this$1 = this;
  var silent = true;
  var state = RUDs.map(function(RUD) {
    return this$1[RUD[0]].apply(this$1, RUD.slice(1).concat(silent));
  });
  var hasFAILObject = function(obj) {
    return typeof obj === "object" && obj.hasOwnProperty("FAIL");
  };
  if (state.every(hasFAILObject)) {
    return {
      FAIL: "composeRUD: one or more operations hasn't completed successfully",
      report: state.filter(hasFAILObject)
    };
  }
  this.dispatch("composeRUD", [state.filter(function(op) {
    return !hasFAILObject(op);
  })]);
};
Tokenizer.prototype.replaceRange = function(startIndex, offset, tokens, silent) {
  offset = offset !== null ? offset : this.tokens.length;
  var isTokenType = tokens.every(function(token) {
    return token instanceof Token;
  });
  if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
    var replaced = this.tokens.splice.apply(
      this.tokens,
      [startIndex, offset].concat(tokens)
    );
    if (!silent) {
      this.dispatch("replaceToken", [startIndex, offset, tokens]);
    }
    return [replaced, tokens];
  } else {
    return { FAIL: "replaceRange: invalid tokens or startIndex." };
  }
};
Tokenizer.prototype.replaceToken = function(index, token, silent) {
  if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
    var replaced = this.tokens.splice(index, 1, token);
    if (!silent) {
      this.dispatch("replaceToken", [index, token]);
    }
    return [replaced[0], token];
  } else {
    return { FAIL: "replaceToken: invalid token or index." };
  }
};
Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
  offset = !isNaN(offset) ? offset : this.tokens.length;
  var tokens = this.tokens.splice(startIndex, offset);
  if (!silent) {
    this.dispatch("removeRange", [tokens, startIndex, offset]);
  }
  return tokens;
};
Tokenizer.prototype.removeToken = function(index, silent) {
  if (!isNaN(index) && this.inboundIndex(index)) {
    var token = this.tokens.splice(index, 1);
    if (!silent) {
      this.dispatch("removeToken", [token, index]);
    }
    return token;
  } else {
    return { FAIL: "removeToken: invalid token index." };
  }
};
Tokenizer.prototype.insertToken = function(tokens, index, silent) {
  var tokenType = tokens.every(
    function(token) {
      return token instanceof Token;
    }
  );
  if (tokenType) {
    this.tokens.splice.apply(
      this.tokens,
      [index, 0].concat(tokens)
    );
    if (!silent) {
      this.dispatch("insertToken", [tokens, index]);
    }
    return tokens;
  } else {
    return { FAIL: "insertToken: invalid token(s)." };
  }
};
Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.events.newToken.subscribe(function(token, contextParams) {
    var conditionParams = [token, contextParams];
    var canApplyModifier = condition === null || condition.apply(this, conditionParams) === true;
    var modifierParams = [token, contextParams];
    if (canApplyModifier) {
      var newStateValue = modifier.apply(this, modifierParams);
      token.setState(modifierId, newStateValue);
    }
  });
  this.registeredModifiers.push(modifierId);
};
Event.prototype.subscribe = function(eventHandler) {
  if (typeof eventHandler === "function") {
    return this.subscribers.push(eventHandler) - 1;
  } else {
    return { FAIL: "invalid '" + this.eventId + "' event handler" };
  }
};
Event.prototype.unsubscribe = function(subsId) {
  this.subscribers.splice(subsId, 1);
};
ContextParams.prototype.setCurrentIndex = function(index) {
  this.index = index;
  this.current = this.context[index];
  this.backtrack = this.context.slice(0, index);
  this.lookahead = this.context.slice(index + 1);
};
ContextParams.prototype.get = function(offset) {
  switch (true) {
    case offset === 0:
      return this.current;
    case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
      return this.backtrack.slice(offset)[0];
    case (offset > 0 && offset <= this.lookahead.length):
      return this.lookahead[offset - 1];
    default:
      return null;
  }
};
Tokenizer.prototype.rangeToText = function(range) {
  if (range instanceof ContextRange) {
    return this.getRangeTokens(range).map(function(token) {
      return token.char;
    }).join("");
  }
};
Tokenizer.prototype.getText = function() {
  return this.tokens.map(function(token) {
    return token.char;
  }).join("");
};
Tokenizer.prototype.getContext = function(contextName) {
  var context = this.registeredContexts[contextName];
  return !!context ? context : null;
};
Tokenizer.prototype.on = function(eventName, eventHandler) {
  var event = this.events[eventName];
  if (!!event) {
    return event.subscribe(eventHandler);
  } else {
    return null;
  }
};
Tokenizer.prototype.dispatch = function(eventName, args) {
  var this$1 = this;
  var event = this.events[eventName];
  if (event instanceof Event) {
    event.subscribers.forEach(function(subscriber) {
      subscriber.apply(this$1, args || []);
    });
  }
};
Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
  if (!!this.getContext(contextName)) {
    return {
      FAIL: "context name '" + contextName + "' is already registered."
    };
  }
  if (typeof contextStartCheck !== "function") {
    return {
      FAIL: "missing context start check."
    };
  }
  if (typeof contextEndCheck !== "function") {
    return {
      FAIL: "missing context end check."
    };
  }
  var contextCheckers = new ContextChecker(
    contextName,
    contextStartCheck,
    contextEndCheck
  );
  this.registeredContexts[contextName] = contextCheckers;
  this.contextCheckers.push(contextCheckers);
  return contextCheckers;
};
Tokenizer.prototype.getRangeTokens = function(range) {
  var endIndex = range.startIndex + range.endOffset;
  return [].concat(
    this.tokens.slice(range.startIndex, endIndex)
  );
};
Tokenizer.prototype.getContextRanges = function(contextName) {
  var context = this.getContext(contextName);
  if (!!context) {
    return context.ranges;
  } else {
    return { FAIL: "context checker '" + contextName + "' is not registered." };
  }
};
Tokenizer.prototype.resetContextsRanges = function() {
  var registeredContexts = this.registeredContexts;
  for (var contextName in registeredContexts) {
    if (registeredContexts.hasOwnProperty(contextName)) {
      var context = registeredContexts[contextName];
      context.ranges = [];
    }
  }
};
Tokenizer.prototype.updateContextsRanges = function() {
  this.resetContextsRanges();
  var chars = this.tokens.map(function(token) {
    return token.char;
  });
  for (var i = 0; i < chars.length; i++) {
    var contextParams = new ContextParams(chars, i);
    this.runContextCheck(contextParams);
  }
  this.dispatch("updateContextsRanges", [this.registeredContexts]);
};
Tokenizer.prototype.setEndOffset = function(offset, contextName) {
  var startIndex = this.getContext(contextName).openRange.startIndex;
  var range = new ContextRange(startIndex, offset, contextName);
  var ranges = this.getContext(contextName).ranges;
  range.rangeId = contextName + "." + ranges.length;
  ranges.push(range);
  this.getContext(contextName).openRange = null;
  return range;
};
Tokenizer.prototype.runContextCheck = function(contextParams) {
  var this$1 = this;
  var index = contextParams.index;
  this.contextCheckers.forEach(function(contextChecker) {
    var contextName = contextChecker.contextName;
    var openRange = this$1.getContext(contextName).openRange;
    if (!openRange && contextChecker.checkStart(contextParams)) {
      openRange = new ContextRange(index, null, contextName);
      this$1.getContext(contextName).openRange = openRange;
      this$1.dispatch("contextStart", [contextName, index]);
    }
    if (!!openRange && contextChecker.checkEnd(contextParams)) {
      var offset = index - openRange.startIndex + 1;
      var range = this$1.setEndOffset(offset, contextName);
      this$1.dispatch("contextEnd", [contextName, range]);
    }
  });
};
Tokenizer.prototype.tokenize = function(text) {
  this.tokens = [];
  this.resetContextsRanges();
  var chars = Array.from(text);
  this.dispatch("start");
  for (var i = 0; i < chars.length; i++) {
    var char = chars[i];
    var contextParams = new ContextParams(chars, i);
    this.dispatch("next", [contextParams]);
    this.runContextCheck(contextParams);
    var token = new Token(char);
    this.tokens.push(token);
    this.dispatch("newToken", [token, contextParams]);
  }
  this.dispatch("end", [this.tokens]);
  return this.tokens;
};
function isArabicChar(c) {
  return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
}
function isIsolatedArabicChar(char) {
  return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
}
function isTashkeelArabicChar(char) {
  return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
}
function isLatinChar(c) {
  return /[A-z]/.test(c);
}
function isWhiteSpace(c) {
  return /\s/.test(c);
}
function FeatureQuery(font) {
  this.font = font;
  this.features = {};
}
function SubstitutionAction(action) {
  this.id = action.id;
  this.tag = action.tag;
  this.substitution = action.substitution;
}
function lookupCoverage(glyphIndex, coverage) {
  if (!glyphIndex) {
    return -1;
  }
  switch (coverage.format) {
    case 1:
      return coverage.glyphs.indexOf(glyphIndex);
    case 2:
      var ranges = coverage.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (glyphIndex >= range.start && glyphIndex <= range.end) {
          var offset = glyphIndex - range.start;
          return range.index + offset;
        }
      }
      break;
    default:
      return -1;
  }
  return -1;
}
function singleSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return glyphIndex + subtable.deltaGlyphId;
}
function singleSubstitutionFormat2(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.substitute[substituteIndex];
}
function lookupCoverageList(coverageList, contextParams) {
  var lookupList = [];
  for (var i = 0; i < coverageList.length; i++) {
    var coverage = coverageList[i];
    var glyphIndex = contextParams.current;
    glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
    var lookupIndex = lookupCoverage(glyphIndex, coverage);
    if (lookupIndex !== -1) {
      lookupList.push(lookupIndex);
    }
  }
  if (lookupList.length !== coverageList.length) {
    return -1;
  }
  return lookupList;
}
function chainingSubstitutionFormat3(contextParams, subtable) {
  var lookupsCount = subtable.inputCoverage.length + subtable.lookaheadCoverage.length + subtable.backtrackCoverage.length;
  if (contextParams.context.length < lookupsCount) {
    return [];
  }
  var inputLookups = lookupCoverageList(
    subtable.inputCoverage,
    contextParams
  );
  if (inputLookups === -1) {
    return [];
  }
  var lookaheadOffset = subtable.inputCoverage.length - 1;
  if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) {
    return [];
  }
  var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
  while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
    lookaheadContext.shift();
  }
  var lookaheadParams = new ContextParams(lookaheadContext, 0);
  var lookaheadLookups = lookupCoverageList(
    subtable.lookaheadCoverage,
    lookaheadParams
  );
  var backtrackContext = [].concat(contextParams.backtrack);
  backtrackContext.reverse();
  while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
    backtrackContext.shift();
  }
  if (backtrackContext.length < subtable.backtrackCoverage.length) {
    return [];
  }
  var backtrackParams = new ContextParams(backtrackContext, 0);
  var backtrackLookups = lookupCoverageList(
    subtable.backtrackCoverage,
    backtrackParams
  );
  var contextRulesMatch = inputLookups.length === subtable.inputCoverage.length && lookaheadLookups.length === subtable.lookaheadCoverage.length && backtrackLookups.length === subtable.backtrackCoverage.length;
  var substitutions = [];
  if (contextRulesMatch) {
    for (var i = 0; i < subtable.lookupRecords.length; i++) {
      var lookupRecord = subtable.lookupRecords[i];
      var lookupListIndex = lookupRecord.lookupListIndex;
      var lookupTable = this.getLookupByIndex(lookupListIndex);
      for (var s = 0; s < lookupTable.subtables.length; s++) {
        var subtable$1 = lookupTable.subtables[s];
        var lookup = this.getLookupMethod(lookupTable, subtable$1);
        var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
        if (substitutionType === "12") {
          for (var n = 0; n < inputLookups.length; n++) {
            var glyphIndex = contextParams.get(n);
            var substitution = lookup(glyphIndex);
            if (substitution) {
              substitutions.push(substitution);
            }
          }
        }
      }
    }
  }
  return substitutions;
}
function ligatureSubstitutionFormat1(contextParams, subtable) {
  var glyphIndex = contextParams.current;
  var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (ligSetIndex === -1) {
    return null;
  }
  var ligature;
  var ligatureSet = subtable.ligatureSets[ligSetIndex];
  for (var s = 0; s < ligatureSet.length; s++) {
    ligature = ligatureSet[s];
    for (var l = 0; l < ligature.components.length; l++) {
      var lookaheadItem = contextParams.lookahead[l];
      var component = ligature.components[l];
      if (lookaheadItem !== component) {
        break;
      }
      if (l === ligature.components.length - 1) {
        return ligature;
      }
    }
  }
  return null;
}
function decompositionSubstitutionFormat1(glyphIndex, subtable) {
  var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
  if (substituteIndex === -1) {
    return null;
  }
  return subtable.sequences[substituteIndex];
}
FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function() {
  var scripts = this.font.tables.gsub.scripts;
  for (var s = 0; s < scripts.length; s++) {
    var script2 = scripts[s];
    if (script2.tag === "DFLT") {
      return script2.script.defaultLangSys.featureIndexes;
    }
  }
  return [];
};
FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
  var tables = this.font.tables;
  if (!tables.gsub) {
    return [];
  }
  if (!scriptTag) {
    return this.getDefaultScriptFeaturesIndexes();
  }
  var scripts = this.font.tables.gsub.scripts;
  for (var i = 0; i < scripts.length; i++) {
    var script2 = scripts[i];
    if (script2.tag === scriptTag && script2.script.defaultLangSys) {
      return script2.script.defaultLangSys.featureIndexes;
    } else {
      var langSysRecords = script2.langSysRecords;
      if (!!langSysRecords) {
        for (var j = 0; j < langSysRecords.length; j++) {
          var langSysRecord = langSysRecords[j];
          if (langSysRecord.tag === scriptTag) {
            var langSys = langSysRecord.langSys;
            return langSys.featureIndexes;
          }
        }
      }
    }
  }
  return this.getDefaultScriptFeaturesIndexes();
};
FeatureQuery.prototype.mapTagsToFeatures = function(features, scriptTag) {
  var tags = {};
  for (var i = 0; i < features.length; i++) {
    var tag = features[i].tag;
    var feature = features[i].feature;
    tags[tag] = feature;
  }
  this.features[scriptTag].tags = tags;
};
FeatureQuery.prototype.getScriptFeatures = function(scriptTag) {
  var features = this.features[scriptTag];
  if (this.features.hasOwnProperty(scriptTag)) {
    return features;
  }
  var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
  if (!featuresIndexes) {
    return null;
  }
  var gsub2 = this.font.tables.gsub;
  features = featuresIndexes.map(function(index) {
    return gsub2.features[index];
  });
  this.features[scriptTag] = features;
  this.mapTagsToFeatures(features, scriptTag);
  return features;
};
FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
  var lookupType = lookupTable.lookupType.toString();
  var substFormat = subtable.substFormat.toString();
  return lookupType + substFormat;
};
FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
  var this$1 = this;
  var substitutionType = this.getSubstitutionType(lookupTable, subtable);
  switch (substitutionType) {
    case "11":
      return function(glyphIndex) {
        return singleSubstitutionFormat1.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    case "12":
      return function(glyphIndex) {
        return singleSubstitutionFormat2.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    case "63":
      return function(contextParams) {
        return chainingSubstitutionFormat3.apply(
          this$1,
          [contextParams, subtable]
        );
      };
    case "41":
      return function(contextParams) {
        return ligatureSubstitutionFormat1.apply(
          this$1,
          [contextParams, subtable]
        );
      };
    case "21":
      return function(glyphIndex) {
        return decompositionSubstitutionFormat1.apply(
          this$1,
          [glyphIndex, subtable]
        );
      };
    default:
      throw new Error(
        "lookupType: " + lookupTable.lookupType + " - substFormat: " + subtable.substFormat + " is not yet supported"
      );
  }
};
FeatureQuery.prototype.lookupFeature = function(query) {
  var contextParams = query.contextParams;
  var currentIndex = contextParams.index;
  var feature = this.getFeature({
    tag: query.tag,
    script: query.script
  });
  if (!feature) {
    return new Error(
      "font '" + this.font.names.fullName.en + "' doesn't support feature '" + query.tag + "' for script '" + query.script + "'."
    );
  }
  var lookups = this.getFeatureLookups(feature);
  var substitutions = [].concat(contextParams.context);
  for (var l = 0; l < lookups.length; l++) {
    var lookupTable = lookups[l];
    var subtables = this.getLookupSubtables(lookupTable);
    for (var s = 0; s < subtables.length; s++) {
      var subtable = subtables[s];
      var substType = this.getSubstitutionType(lookupTable, subtable);
      var lookup = this.getLookupMethod(lookupTable, subtable);
      var substitution = void 0;
      switch (substType) {
        case "11":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 11,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "12":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 12,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "63":
          substitution = lookup(contextParams);
          if (Array.isArray(substitution) && substitution.length) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 63,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "41":
          substitution = lookup(contextParams);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 41,
              tag: query.tag,
              substitution
            }));
          }
          break;
        case "21":
          substitution = lookup(contextParams.current);
          if (substitution) {
            substitutions.splice(currentIndex, 1, new SubstitutionAction({
              id: 21,
              tag: query.tag,
              substitution
            }));
          }
          break;
      }
      contextParams = new ContextParams(substitutions, currentIndex);
      if (Array.isArray(substitution) && !substitution.length) {
        continue;
      }
      substitution = null;
    }
  }
  return substitutions.length ? substitutions : null;
};
FeatureQuery.prototype.supports = function(query) {
  if (!query.script) {
    return false;
  }
  this.getScriptFeatures(query.script);
  var supportedScript = this.features.hasOwnProperty(query.script);
  if (!query.tag) {
    return supportedScript;
  }
  var supportedFeature = this.features[query.script].some(function(feature) {
    return feature.tag === query.tag;
  });
  return supportedScript && supportedFeature;
};
FeatureQuery.prototype.getLookupSubtables = function(lookupTable) {
  return lookupTable.subtables || null;
};
FeatureQuery.prototype.getLookupByIndex = function(index) {
  var lookups = this.font.tables.gsub.lookups;
  return lookups[index] || null;
};
FeatureQuery.prototype.getFeatureLookups = function(feature) {
  return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
};
FeatureQuery.prototype.getFeature = function getFeature(query) {
  if (!this.font) {
    return { FAIL: "No font was found" };
  }
  if (!this.features.hasOwnProperty(query.script)) {
    this.getScriptFeatures(query.script);
  }
  var scriptFeatures = this.features[query.script];
  if (!scriptFeatures) {
    return { FAIL: "No feature for script " + query.script };
  }
  if (!scriptFeatures.tags[query.tag]) {
    return null;
  }
  return this.features[query.script].tags[query.tag];
};
function arabicWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? arabic first char
    prevChar === null && isArabicChar(char) || // ? arabic char preceded with a non arabic char
    !isArabicChar(prevChar) && isArabicChar(char)
  );
}
function arabicWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return (
    // ? last arabic char
    nextChar === null || // ? next char is not arabic
    !isArabicChar(nextChar)
  );
}
var arabicWordCheck = {
  startCheck: arabicWordStartCheck,
  endCheck: arabicWordEndCheck
};
function arabicSentenceStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? an arabic char preceded with a non arabic char
    (isArabicChar(char) || isTashkeelArabicChar(char)) && !isArabicChar(prevChar)
  );
}
function arabicSentenceEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  switch (true) {
    case nextChar === null:
      return true;
    case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
      var nextIsWhitespace = isWhiteSpace(nextChar);
      if (!nextIsWhitespace) {
        return true;
      }
      if (nextIsWhitespace) {
        var arabicCharAhead = false;
        arabicCharAhead = contextParams.lookahead.some(
          function(c) {
            return isArabicChar(c) || isTashkeelArabicChar(c);
          }
        );
        if (!arabicCharAhead) {
          return true;
        }
      }
      break;
    default:
      return false;
  }
}
var arabicSentenceCheck = {
  startCheck: arabicSentenceStartCheck,
  endCheck: arabicSentenceEndCheck
};
function singleSubstitutionFormat1$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function singleSubstitutionFormat2$1(action, tokens, index) {
  tokens[index].setState(action.tag, action.substitution);
}
function chainingSubstitutionFormat3$1(action, tokens, index) {
  action.substitution.forEach(function(subst, offset) {
    var token = tokens[index + offset];
    token.setState(action.tag, subst);
  });
}
function ligatureSubstitutionFormat1$1(action, tokens, index) {
  var token = tokens[index];
  token.setState(action.tag, action.substitution.ligGlyph);
  var compsCount = action.substitution.components.length;
  for (var i = 0; i < compsCount; i++) {
    token = tokens[index + i + 1];
    token.setState("deleted", true);
  }
}
var SUBSTITUTIONS = {
  11: singleSubstitutionFormat1$1,
  12: singleSubstitutionFormat2$1,
  63: chainingSubstitutionFormat3$1,
  41: ligatureSubstitutionFormat1$1
};
function applySubstitution(action, tokens, index) {
  if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
    SUBSTITUTIONS[action.id](action, tokens, index);
  }
}
function willConnectPrev(charContextParams) {
  var backtrack = [].concat(charContextParams.backtrack);
  for (var i = backtrack.length - 1; i >= 0; i--) {
    var prevChar = backtrack[i];
    var isolated = isIsolatedArabicChar(prevChar);
    var tashkeel = isTashkeelArabicChar(prevChar);
    if (!isolated && !tashkeel) {
      return true;
    }
    if (isolated) {
      return false;
    }
  }
  return false;
}
function willConnectNext(charContextParams) {
  if (isIsolatedArabicChar(charContextParams.current)) {
    return false;
  }
  for (var i = 0; i < charContextParams.lookahead.length; i++) {
    var nextChar = charContextParams.lookahead[i];
    var tashkeel = isTashkeelArabicChar(nextChar);
    if (!tashkeel) {
      return true;
    }
  }
  return false;
}
function arabicPresentationForms(range) {
  var this$1 = this;
  var script2 = "arab";
  var tags = this.featuresTags[script2];
  var tokens = this.tokenizer.getRangeTokens(range);
  if (tokens.length === 1) {
    return;
  }
  var contextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.getState("glyphIndex");
      }
    ),
    0
  );
  var charContextParams = new ContextParams(
    tokens.map(
      function(token) {
        return token.char;
      }
    ),
    0
  );
  tokens.forEach(function(token, index) {
    if (isTashkeelArabicChar(token.char)) {
      return;
    }
    contextParams.setCurrentIndex(index);
    charContextParams.setCurrentIndex(index);
    var CONNECT = 0;
    if (willConnectPrev(charContextParams)) {
      CONNECT |= 1;
    }
    if (willConnectNext(charContextParams)) {
      CONNECT |= 2;
    }
    var tag;
    switch (CONNECT) {
      case 1:
        tag = "fina";
        break;
      case 2:
        tag = "init";
        break;
      case 3:
        tag = "medi";
        break;
    }
    if (tags.indexOf(tag) === -1) {
      return;
    }
    var substitutions = this$1.query.lookupFeature({
      tag,
      script: script2,
      contextParams
    });
    if (substitutions instanceof Error) {
      return console.info(substitutions.message);
    }
    substitutions.forEach(function(action, index2) {
      if (action instanceof SubstitutionAction) {
        applySubstitution(action, tokens, index2);
        contextParams.context[index2] = action.substitution;
      }
    });
  });
}
function getContextParams(tokens, index) {
  var context = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context, index || 0);
}
function arabicRequiredLigatures(range) {
  var this$1 = this;
  var script2 = "arab";
  var tokens = this.tokenizer.getRangeTokens(range);
  var contextParams = getContextParams(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1.query.lookupFeature({
      tag: "rlig",
      script: script2,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams(tokens);
    }
  });
}
function latinWordStartCheck(contextParams) {
  var char = contextParams.current;
  var prevChar = contextParams.get(-1);
  return (
    // ? latin first char
    prevChar === null && isLatinChar(char) || // ? latin char preceded with a non latin char
    !isLatinChar(prevChar) && isLatinChar(char)
  );
}
function latinWordEndCheck(contextParams) {
  var nextChar = contextParams.get(1);
  return (
    // ? last latin char
    nextChar === null || // ? next char is not latin
    !isLatinChar(nextChar)
  );
}
var latinWordCheck = {
  startCheck: latinWordStartCheck,
  endCheck: latinWordEndCheck
};
function getContextParams$1(tokens, index) {
  var context = tokens.map(function(token) {
    return token.activeState.value;
  });
  return new ContextParams(context, index || 0);
}
function latinLigature(range) {
  var this$1 = this;
  var script2 = "latn";
  var tokens = this.tokenizer.getRangeTokens(range);
  var contextParams = getContextParams$1(tokens);
  contextParams.context.forEach(function(glyphIndex, index) {
    contextParams.setCurrentIndex(index);
    var substitutions = this$1.query.lookupFeature({
      tag: "liga",
      script: script2,
      contextParams
    });
    if (substitutions.length) {
      substitutions.forEach(
        function(action) {
          return applySubstitution(action, tokens, index);
        }
      );
      contextParams = getContextParams$1(tokens);
    }
  });
}
function Bidi(baseDir) {
  this.baseDir = baseDir || "ltr";
  this.tokenizer = new Tokenizer();
  this.featuresTags = {};
}
Bidi.prototype.setText = function(text) {
  this.text = text;
};
Bidi.prototype.contextChecks = {
  latinWordCheck,
  arabicWordCheck,
  arabicSentenceCheck
};
function registerContextChecker(checkId) {
  var check2 = this.contextChecks[checkId + "Check"];
  return this.tokenizer.registerContextChecker(
    checkId,
    check2.startCheck,
    check2.endCheck
  );
}
function tokenizeText() {
  registerContextChecker.call(this, "latinWord");
  registerContextChecker.call(this, "arabicWord");
  registerContextChecker.call(this, "arabicSentence");
  return this.tokenizer.tokenize(this.text);
}
function reverseArabicSentences() {
  var this$1 = this;
  var ranges = this.tokenizer.getContextRanges("arabicSentence");
  ranges.forEach(function(range) {
    var rangeTokens = this$1.tokenizer.getRangeTokens(range);
    this$1.tokenizer.replaceRange(
      range.startIndex,
      range.endOffset,
      rangeTokens.reverse()
    );
  });
}
Bidi.prototype.registerFeatures = function(script2, tags) {
  var this$1 = this;
  var supportedTags = tags.filter(
    function(tag) {
      return this$1.query.supports({ script: script2, tag });
    }
  );
  if (!this.featuresTags.hasOwnProperty(script2)) {
    this.featuresTags[script2] = supportedTags;
  } else {
    this.featuresTags[script2] = this.featuresTags[script2].concat(supportedTags);
  }
};
Bidi.prototype.applyFeatures = function(font, features) {
  if (!font) {
    throw new Error(
      "No valid font was provided to apply features"
    );
  }
  if (!this.query) {
    this.query = new FeatureQuery(font);
  }
  for (var f = 0; f < features.length; f++) {
    var feature = features[f];
    if (!this.query.supports({ script: feature.script })) {
      continue;
    }
    this.registerFeatures(feature.script, feature.tags);
  }
};
Bidi.prototype.registerModifier = function(modifierId, condition, modifier) {
  this.tokenizer.registerModifier(modifierId, condition, modifier);
};
function checkGlyphIndexStatus() {
  if (this.tokenizer.registeredModifiers.indexOf("glyphIndex") === -1) {
    throw new Error(
      "glyphIndex modifier is required to apply arabic presentation features."
    );
  }
}
function applyArabicPresentationForms() {
  var this$1 = this;
  var script2 = "arab";
  if (!this.featuresTags.hasOwnProperty(script2)) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range) {
    arabicPresentationForms.call(this$1, range);
  });
}
function applyArabicRequireLigatures() {
  var this$1 = this;
  var script2 = "arab";
  if (!this.featuresTags.hasOwnProperty(script2)) {
    return;
  }
  var tags = this.featuresTags[script2];
  if (tags.indexOf("rlig") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("arabicWord");
  ranges.forEach(function(range) {
    arabicRequiredLigatures.call(this$1, range);
  });
}
function applyLatinLigatures() {
  var this$1 = this;
  var script2 = "latn";
  if (!this.featuresTags.hasOwnProperty(script2)) {
    return;
  }
  var tags = this.featuresTags[script2];
  if (tags.indexOf("liga") === -1) {
    return;
  }
  checkGlyphIndexStatus.call(this);
  var ranges = this.tokenizer.getContextRanges("latinWord");
  ranges.forEach(function(range) {
    latinLigature.call(this$1, range);
  });
}
Bidi.prototype.checkContextReady = function(contextId) {
  return !!this.tokenizer.getContext(contextId);
};
Bidi.prototype.applyFeaturesToContexts = function() {
  if (this.checkContextReady("arabicWord")) {
    applyArabicPresentationForms.call(this);
    applyArabicRequireLigatures.call(this);
  }
  if (this.checkContextReady("latinWord")) {
    applyLatinLigatures.call(this);
  }
  if (this.checkContextReady("arabicSentence")) {
    reverseArabicSentences.call(this);
  }
};
Bidi.prototype.processText = function(text) {
  if (!this.text || this.text !== text) {
    this.setText(text);
    tokenizeText.call(this);
    this.applyFeaturesToContexts();
  }
};
Bidi.prototype.getBidiText = function(text) {
  this.processText(text);
  return this.tokenizer.getText();
};
Bidi.prototype.getTextGlyphs = function(text) {
  this.processText(text);
  var indexes = [];
  for (var i = 0; i < this.tokenizer.tokens.length; i++) {
    var token = this.tokenizer.tokens[i];
    if (token.state.deleted) {
      continue;
    }
    var index = token.activeState.value;
    indexes.push(Array.isArray(index) ? index[0] : index);
  }
  return indexes;
};
function Font(options) {
  options = options || {};
  options.tables = options.tables || {};
  if (!options.empty) {
    checkArgument(options.familyName, "When creating a new Font object, familyName is required.");
    checkArgument(options.styleName, "When creating a new Font object, styleName is required.");
    checkArgument(options.unitsPerEm, "When creating a new Font object, unitsPerEm is required.");
    checkArgument(options.ascender, "When creating a new Font object, ascender is required.");
    checkArgument(options.descender <= 0, "When creating a new Font object, negative descender value is required.");
    this.names = {
      fontFamily: { en: options.familyName || " " },
      fontSubfamily: { en: options.styleName || " " },
      fullName: { en: options.fullName || options.familyName + " " + options.styleName },
      // postScriptName may not contain any whitespace
      postScriptName: { en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, "") },
      designer: { en: options.designer || " " },
      designerURL: { en: options.designerURL || " " },
      manufacturer: { en: options.manufacturer || " " },
      manufacturerURL: { en: options.manufacturerURL || " " },
      license: { en: options.license || " " },
      licenseURL: { en: options.licenseURL || " " },
      version: { en: options.version || "Version 0.1" },
      description: { en: options.description || " " },
      copyright: { en: options.copyright || " " },
      trademark: { en: options.trademark || " " }
    };
    this.unitsPerEm = options.unitsPerEm || 1e3;
    this.ascender = options.ascender;
    this.descender = options.descender;
    this.createdTimestamp = options.createdTimestamp;
    this.tables = Object.assign(options.tables, {
      os2: Object.assign({
        usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
        usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
        fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
      }, options.tables.os2)
    });
  }
  this.supported = true;
  this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
  this.encoding = new DefaultEncoding(this);
  this.position = new Position(this);
  this.substitution = new Substitution(this);
  this.tables = this.tables || {};
  this._push = null;
  this._hmtxTableData = {};
  Object.defineProperty(this, "hinting", {
    get: function() {
      if (this._hinting) {
        return this._hinting;
      }
      if (this.outlinesFormat === "truetype") {
        return this._hinting = new Hinting(this);
      }
    }
  });
}
Font.prototype.hasChar = function(c) {
  return this.encoding.charToGlyphIndex(c) !== null;
};
Font.prototype.charToGlyphIndex = function(s) {
  return this.encoding.charToGlyphIndex(s);
};
Font.prototype.charToGlyph = function(c) {
  var glyphIndex = this.charToGlyphIndex(c);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font.prototype.updateFeatures = function(options) {
  return this.defaultRenderOptions.features.map(function(feature) {
    if (feature.script === "latn") {
      return {
        script: "latn",
        tags: feature.tags.filter(function(tag) {
          return options[tag];
        })
      };
    } else {
      return feature;
    }
  });
};
Font.prototype.stringToGlyphs = function(s, options) {
  var this$1 = this;
  var bidi = new Bidi();
  var charToGlyphIndexMod = function(token) {
    return this$1.charToGlyphIndex(token.char);
  };
  bidi.registerModifier("glyphIndex", null, charToGlyphIndexMod);
  var features = options ? this.updateFeatures(options.features) : this.defaultRenderOptions.features;
  bidi.applyFeatures(this, features);
  var indexes = bidi.getTextGlyphs(s);
  var length = indexes.length;
  var glyphs = new Array(length);
  var notdef = this.glyphs.get(0);
  for (var i = 0; i < length; i += 1) {
    glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
  }
  return glyphs;
};
Font.prototype.nameToGlyphIndex = function(name) {
  return this.glyphNames.nameToGlyphIndex(name);
};
Font.prototype.nameToGlyph = function(name) {
  var glyphIndex = this.nameToGlyphIndex(name);
  var glyph = this.glyphs.get(glyphIndex);
  if (!glyph) {
    glyph = this.glyphs.get(0);
  }
  return glyph;
};
Font.prototype.glyphIndexToName = function(gid) {
  if (!this.glyphNames.glyphIndexToName) {
    return "";
  }
  return this.glyphNames.glyphIndexToName(gid);
};
Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
  leftGlyph = leftGlyph.index || leftGlyph;
  rightGlyph = rightGlyph.index || rightGlyph;
  var gposKerning = this.position.defaultKerningTables;
  if (gposKerning) {
    return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
  }
  return this.kerningPairs[leftGlyph + "," + rightGlyph] || 0;
};
Font.prototype.defaultRenderOptions = {
  kerning: true,
  features: [
    /**
     * these 4 features are required to render Arabic text properly
     * and shouldn't be turned off when rendering arabic text.
     */
    { script: "arab", tags: ["init", "medi", "fina", "rlig"] },
    { script: "latn", tags: ["liga", "rlig"] }
  ]
};
Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
  x = x !== void 0 ? x : 0;
  y = y !== void 0 ? y : 0;
  fontSize = fontSize !== void 0 ? fontSize : 72;
  options = Object.assign({}, this.defaultRenderOptions, options);
  var fontScale = 1 / this.unitsPerEm * fontSize;
  var glyphs = this.stringToGlyphs(text, options);
  var kerningLookups;
  if (options.kerning) {
    var script2 = options.script || this.position.getDefaultScriptName();
    kerningLookups = this.position.getKerningTables(script2, options.language);
  }
  for (var i = 0; i < glyphs.length; i += 1) {
    var glyph = glyphs[i];
    callback.call(this, glyph, x, y, fontSize, options);
    if (glyph.advanceWidth) {
      x += glyph.advanceWidth * fontScale;
    }
    if (options.kerning && i < glyphs.length - 1) {
      var kerningValue = kerningLookups ? this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) : this.getKerningValue(glyph, glyphs[i + 1]);
      x += kerningValue * fontScale;
    }
    if (options.letterSpacing) {
      x += options.letterSpacing * fontSize;
    } else if (options.tracking) {
      x += options.tracking / 1e3 * fontSize;
    }
  }
  return x;
};
Font.prototype.getPath = function(text, x, y, fontSize, options) {
  var fullPath = new Path();
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    fullPath.extend(glyphPath);
  });
  return fullPath;
};
Font.prototype.getPaths = function(text, x, y, fontSize, options) {
  var glyphPaths = [];
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
    glyphPaths.push(glyphPath);
  });
  return glyphPaths;
};
Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
  return this.forEachGlyph(text, 0, 0, fontSize, options, function() {
  });
};
Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
  this.getPath(text, x, y, fontSize, options).draw(ctx);
};
Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawPoints(ctx, gX, gY, gFontSize);
  });
};
Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
  this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
    glyph.drawMetrics(ctx, gX, gY, gFontSize);
  });
};
Font.prototype.getEnglishName = function(name) {
  var translations = this.names[name];
  if (translations) {
    return translations.en;
  }
};
Font.prototype.validate = function() {
  var _this = this;
  function assert(predicate, message2) {
  }
  function assertNamePresent(name) {
    var englishName = _this.getEnglishName(name);
    assert(englishName && englishName.trim().length > 0);
  }
  assertNamePresent("fontFamily");
  assertNamePresent("weightName");
  assertNamePresent("manufacturer");
  assertNamePresent("copyright");
  assertNamePresent("version");
  assert(this.unitsPerEm > 0);
};
Font.prototype.toTables = function() {
  return sfnt.fontToTable(this);
};
Font.prototype.toBuffer = function() {
  console.warn("Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.");
  return this.toArrayBuffer();
};
Font.prototype.toArrayBuffer = function() {
  var sfntTable = this.toTables();
  var bytes = sfntTable.encode();
  var buffer = new ArrayBuffer(bytes.length);
  var intArray = new Uint8Array(buffer);
  for (var i = 0; i < bytes.length; i++) {
    intArray[i] = bytes[i];
  }
  return buffer;
};
Font.prototype.download = function(fileName) {
  var familyName = this.getEnglishName("fontFamily");
  var styleName = this.getEnglishName("fontSubfamily");
  fileName = fileName || familyName.replace(/\s/g, "") + "-" + styleName + ".otf";
  var arrayBuffer = this.toArrayBuffer();
  if (isBrowser2()) {
    window.URL = window.URL || window.webkitURL;
    if (window.URL) {
      var dataView = new DataView(arrayBuffer);
      var blob = new Blob([dataView], { type: "font/opentype" });
      var link = document.createElement("a");
      link.href = window.URL.createObjectURL(blob);
      link.download = fileName;
      var event = document.createEvent("MouseEvents");
      event.initEvent("click", true, false);
      link.dispatchEvent(event);
    } else {
      console.warn("Font file could not be downloaded. Try using a different browser.");
    }
  } else {
    var fs = require_fs();
    var buffer = arrayBufferToNodeBuffer(arrayBuffer);
    fs.writeFileSync(fileName, buffer);
  }
};
Font.prototype.fsSelectionValues = {
  ITALIC: 1,
  //1
  UNDERSCORE: 2,
  //2
  NEGATIVE: 4,
  //4
  OUTLINED: 8,
  //8
  STRIKEOUT: 16,
  //16
  BOLD: 32,
  //32
  REGULAR: 64,
  //64
  USER_TYPO_METRICS: 128,
  //128
  WWS: 256,
  //256
  OBLIQUE: 512
  //512
};
Font.prototype.usWidthClasses = {
  ULTRA_CONDENSED: 1,
  EXTRA_CONDENSED: 2,
  CONDENSED: 3,
  SEMI_CONDENSED: 4,
  MEDIUM: 5,
  SEMI_EXPANDED: 6,
  EXPANDED: 7,
  EXTRA_EXPANDED: 8,
  ULTRA_EXPANDED: 9
};
Font.prototype.usWeightClasses = {
  THIN: 100,
  EXTRA_LIGHT: 200,
  LIGHT: 300,
  NORMAL: 400,
  MEDIUM: 500,
  SEMI_BOLD: 600,
  BOLD: 700,
  EXTRA_BOLD: 800,
  BLACK: 900
};
function addName(name, names) {
  var nameString = JSON.stringify(name);
  var nameID = 256;
  for (var nameKey in names) {
    var n = parseInt(nameKey);
    if (!n || n < 256) {
      continue;
    }
    if (JSON.stringify(names[nameKey]) === nameString) {
      return n;
    }
    if (nameID <= n) {
      nameID = n + 1;
    }
  }
  names[nameID] = name;
  return nameID;
}
function makeFvarAxis(n, axis, names) {
  var nameID = addName(axis.name, names);
  return [
    { name: "tag_" + n, type: "TAG", value: axis.tag },
    { name: "minValue_" + n, type: "FIXED", value: axis.minValue << 16 },
    { name: "defaultValue_" + n, type: "FIXED", value: axis.defaultValue << 16 },
    { name: "maxValue_" + n, type: "FIXED", value: axis.maxValue << 16 },
    { name: "flags_" + n, type: "USHORT", value: 0 },
    { name: "nameID_" + n, type: "USHORT", value: nameID }
  ];
}
function parseFvarAxis(data2, start, names) {
  var axis = {};
  var p = new parse.Parser(data2, start);
  axis.tag = p.parseTag();
  axis.minValue = p.parseFixed();
  axis.defaultValue = p.parseFixed();
  axis.maxValue = p.parseFixed();
  p.skip("uShort", 1);
  axis.name = names[p.parseUShort()] || {};
  return axis;
}
function makeFvarInstance(n, inst, axes, names) {
  var nameID = addName(inst.name, names);
  var fields = [
    { name: "nameID_" + n, type: "USHORT", value: nameID },
    { name: "flags_" + n, type: "USHORT", value: 0 }
  ];
  for (var i = 0; i < axes.length; ++i) {
    var axisTag = axes[i].tag;
    fields.push({
      name: "axis_" + n + " " + axisTag,
      type: "FIXED",
      value: inst.coordinates[axisTag] << 16
    });
  }
  return fields;
}
function parseFvarInstance(data2, start, axes, names) {
  var inst = {};
  var p = new parse.Parser(data2, start);
  inst.name = names[p.parseUShort()] || {};
  p.skip("uShort", 1);
  inst.coordinates = {};
  for (var i = 0; i < axes.length; ++i) {
    inst.coordinates[axes[i].tag] = p.parseFixed();
  }
  return inst;
}
function makeFvarTable(fvar2, names) {
  var result = new table.Table("fvar", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "offsetToData", type: "USHORT", value: 0 },
    { name: "countSizePairs", type: "USHORT", value: 2 },
    { name: "axisCount", type: "USHORT", value: fvar2.axes.length },
    { name: "axisSize", type: "USHORT", value: 20 },
    { name: "instanceCount", type: "USHORT", value: fvar2.instances.length },
    { name: "instanceSize", type: "USHORT", value: 4 + fvar2.axes.length * 4 }
  ]);
  result.offsetToData = result.sizeOf();
  for (var i = 0; i < fvar2.axes.length; i++) {
    result.fields = result.fields.concat(makeFvarAxis(i, fvar2.axes[i], names));
  }
  for (var j = 0; j < fvar2.instances.length; j++) {
    result.fields = result.fields.concat(makeFvarInstance(j, fvar2.instances[j], fvar2.axes, names));
  }
  return result;
}
function parseFvarTable(data2, start, names) {
  var p = new parse.Parser(data2, start);
  var tableVersion = p.parseULong();
  check.argument(tableVersion === 65536, "Unsupported fvar table version.");
  var offsetToData = p.parseOffset16();
  p.skip("uShort", 1);
  var axisCount = p.parseUShort();
  var axisSize = p.parseUShort();
  var instanceCount = p.parseUShort();
  var instanceSize = p.parseUShort();
  var axes = [];
  for (var i = 0; i < axisCount; i++) {
    axes.push(parseFvarAxis(data2, start + offsetToData + i * axisSize, names));
  }
  var instances = [];
  var instanceStart = start + offsetToData + axisCount * axisSize;
  for (var j = 0; j < instanceCount; j++) {
    instances.push(parseFvarInstance(data2, instanceStart + j * instanceSize, axes, names));
  }
  return { axes, instances };
}
var fvar = { make: makeFvarTable, parse: parseFvarTable };
var attachList = function() {
  return {
    coverage: this.parsePointer(Parser.coverage),
    attachPoints: this.parseList(Parser.pointer(Parser.uShortList))
  };
};
var caretValue = function() {
  var format = this.parseUShort();
  check.argument(
    format === 1 || format === 2 || format === 3,
    "Unsupported CaretValue table version."
  );
  if (format === 1) {
    return { coordinate: this.parseShort() };
  } else if (format === 2) {
    return { pointindex: this.parseShort() };
  } else if (format === 3) {
    return { coordinate: this.parseShort() };
  }
};
var ligGlyph = function() {
  return this.parseList(Parser.pointer(caretValue));
};
var ligCaretList = function() {
  return {
    coverage: this.parsePointer(Parser.coverage),
    ligGlyphs: this.parseList(Parser.pointer(ligGlyph))
  };
};
var markGlyphSets = function() {
  this.parseUShort();
  return this.parseList(Parser.pointer(Parser.coverage));
};
function parseGDEFTable(data2, start) {
  start = start || 0;
  var p = new Parser(data2, start);
  var tableVersion = p.parseVersion(1);
  check.argument(
    tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
    "Unsupported GDEF table version."
  );
  var gdef2 = {
    version: tableVersion,
    classDef: p.parsePointer(Parser.classDef),
    attachList: p.parsePointer(attachList),
    ligCaretList: p.parsePointer(ligCaretList),
    markAttachClassDef: p.parsePointer(Parser.classDef)
  };
  if (tableVersion >= 1.2) {
    gdef2.markGlyphSets = p.parsePointer(markGlyphSets);
  }
  return gdef2;
}
var gdef = { parse: parseGDEFTable };
var subtableParsers$1 = new Array(10);
subtableParsers$1[1] = function parseLookup12() {
  var start = this.offset + this.relativeOffset;
  var posformat = this.parseUShort();
  if (posformat === 1) {
    return {
      posFormat: 1,
      coverage: this.parsePointer(Parser.coverage),
      value: this.parseValueRecord()
    };
  } else if (posformat === 2) {
    return {
      posFormat: 2,
      coverage: this.parsePointer(Parser.coverage),
      values: this.parseValueRecordList()
    };
  }
  check.assert(false, "0x" + start.toString(16) + ": GPOS lookup type 1 format must be 1 or 2.");
};
subtableParsers$1[2] = function parseLookup22() {
  var start = this.offset + this.relativeOffset;
  var posFormat = this.parseUShort();
  check.assert(posFormat === 1 || posFormat === 2, "0x" + start.toString(16) + ": GPOS lookup type 2 format must be 1 or 2.");
  var coverage = this.parsePointer(Parser.coverage);
  var valueFormat1 = this.parseUShort();
  var valueFormat2 = this.parseUShort();
  if (posFormat === 1) {
    return {
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      pairSets: this.parseList(Parser.pointer(Parser.list(function() {
        return {
          // pairValueRecord
          secondGlyph: this.parseUShort(),
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      })))
    };
  } else if (posFormat === 2) {
    var classDef1 = this.parsePointer(Parser.classDef);
    var classDef2 = this.parsePointer(Parser.classDef);
    var class1Count = this.parseUShort();
    var class2Count = this.parseUShort();
    return {
      // Class Pair Adjustment
      posFormat,
      coverage,
      valueFormat1,
      valueFormat2,
      classDef1,
      classDef2,
      class1Count,
      class2Count,
      classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
        return {
          value1: this.parseValueRecord(valueFormat1),
          value2: this.parseValueRecord(valueFormat2)
        };
      }))
    };
  }
};
subtableParsers$1[3] = function parseLookup32() {
  return { error: "GPOS Lookup 3 not supported" };
};
subtableParsers$1[4] = function parseLookup42() {
  return { error: "GPOS Lookup 4 not supported" };
};
subtableParsers$1[5] = function parseLookup52() {
  return { error: "GPOS Lookup 5 not supported" };
};
subtableParsers$1[6] = function parseLookup62() {
  return { error: "GPOS Lookup 6 not supported" };
};
subtableParsers$1[7] = function parseLookup72() {
  return { error: "GPOS Lookup 7 not supported" };
};
subtableParsers$1[8] = function parseLookup82() {
  return { error: "GPOS Lookup 8 not supported" };
};
subtableParsers$1[9] = function parseLookup9() {
  return { error: "GPOS Lookup 9 not supported" };
};
function parseGposTable(data2, start) {
  start = start || 0;
  var p = new Parser(data2, start);
  var tableVersion = p.parseVersion(1);
  check.argument(tableVersion === 1 || tableVersion === 1.1, "Unsupported GPOS table version " + tableVersion);
  if (tableVersion === 1) {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1)
    };
  } else {
    return {
      version: tableVersion,
      scripts: p.parseScriptList(),
      features: p.parseFeatureList(),
      lookups: p.parseLookupList(subtableParsers$1),
      variations: p.parseFeatureVariationsList()
    };
  }
}
var subtableMakers$1 = new Array(10);
function makeGposTable(gpos2) {
  return new table.Table("GPOS", [
    { name: "version", type: "ULONG", value: 65536 },
    { name: "scripts", type: "TABLE", value: new table.ScriptList(gpos2.scripts) },
    { name: "features", type: "TABLE", value: new table.FeatureList(gpos2.features) },
    { name: "lookups", type: "TABLE", value: new table.LookupList(gpos2.lookups, subtableMakers$1) }
  ]);
}
var gpos = { parse: parseGposTable, make: makeGposTable };
function parseWindowsKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var subtableVersion = p.parseUShort();
  check.argument(subtableVersion === 0, "Unsupported kern sub-table version.");
  p.skip("uShort", 2);
  var nPairs = p.parseUShort();
  p.skip("uShort", 3);
  for (var i = 0; i < nPairs; i += 1) {
    var leftIndex = p.parseUShort();
    var rightIndex = p.parseUShort();
    var value = p.parseShort();
    pairs[leftIndex + "," + rightIndex] = value;
  }
  return pairs;
}
function parseMacKernTable(p) {
  var pairs = {};
  p.skip("uShort");
  var nTables = p.parseULong();
  if (nTables > 1) {
    console.warn("Only the first kern subtable is supported.");
  }
  p.skip("uLong");
  var coverage = p.parseUShort();
  var subtableVersion = coverage & 255;
  p.skip("uShort");
  if (subtableVersion === 0) {
    var nPairs = p.parseUShort();
    p.skip("uShort", 3);
    for (var i = 0; i < nPairs; i += 1) {
      var leftIndex = p.parseUShort();
      var rightIndex = p.parseUShort();
      var value = p.parseShort();
      pairs[leftIndex + "," + rightIndex] = value;
    }
  }
  return pairs;
}
function parseKernTable(data2, start) {
  var p = new parse.Parser(data2, start);
  var tableVersion = p.parseUShort();
  if (tableVersion === 0) {
    return parseWindowsKernTable(p);
  } else if (tableVersion === 1) {
    return parseMacKernTable(p);
  } else {
    throw new Error("Unsupported kern table version (" + tableVersion + ").");
  }
}
var kern = { parse: parseKernTable };
function parseLocaTable(data2, start, numGlyphs, shortVersion) {
  var p = new parse.Parser(data2, start);
  var parseFn = shortVersion ? p.parseUShort : p.parseULong;
  var glyphOffsets = [];
  for (var i = 0; i < numGlyphs + 1; i += 1) {
    var glyphOffset = parseFn.call(p);
    if (shortVersion) {
      glyphOffset *= 2;
    }
    glyphOffsets.push(glyphOffset);
  }
  return glyphOffsets;
}
var loca = { parse: parseLocaTable };
function parseOpenTypeTableEntries(data2, numTables) {
  var tableEntries = [];
  var p = 12;
  for (var i = 0; i < numTables; i += 1) {
    var tag = parse.getTag(data2, p);
    var checksum = parse.getULong(data2, p + 4);
    var offset = parse.getULong(data2, p + 8);
    var length = parse.getULong(data2, p + 12);
    tableEntries.push({ tag, checksum, offset, length, compression: false });
    p += 16;
  }
  return tableEntries;
}
function parseWOFFTableEntries(data2, numTables) {
  var tableEntries = [];
  var p = 44;
  for (var i = 0; i < numTables; i += 1) {
    var tag = parse.getTag(data2, p);
    var offset = parse.getULong(data2, p + 4);
    var compLength = parse.getULong(data2, p + 8);
    var origLength = parse.getULong(data2, p + 12);
    var compression = void 0;
    if (compLength < origLength) {
      compression = "WOFF";
    } else {
      compression = false;
    }
    tableEntries.push({
      tag,
      offset,
      compression,
      compressedLength: compLength,
      length: origLength
    });
    p += 20;
  }
  return tableEntries;
}
function uncompressTable(data2, tableEntry) {
  if (tableEntry.compression === "WOFF") {
    var inBuffer = new Uint8Array(data2.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
    var outBuffer = new Uint8Array(tableEntry.length);
    tinyInflate(inBuffer, outBuffer);
    if (outBuffer.byteLength !== tableEntry.length) {
      throw new Error("Decompression error: " + tableEntry.tag + " decompressed length doesn't match recorded length");
    }
    var view = new DataView(outBuffer.buffer, 0);
    return { data: view, offset: 0 };
  } else {
    return { data: data2, offset: tableEntry.offset };
  }
}
function parseBuffer(buffer, opt) {
  opt = opt === void 0 || opt === null ? {} : opt;
  var indexToLocFormat;
  var ltagTable;
  var font = new Font({ empty: true });
  var data2 = new DataView(buffer, 0);
  var numTables;
  var tableEntries = [];
  var signature = parse.getTag(data2, 0);
  if (signature === String.fromCharCode(0, 1, 0, 0) || signature === "true" || signature === "typ1") {
    font.outlinesFormat = "truetype";
    numTables = parse.getUShort(data2, 4);
    tableEntries = parseOpenTypeTableEntries(data2, numTables);
  } else if (signature === "OTTO") {
    font.outlinesFormat = "cff";
    numTables = parse.getUShort(data2, 4);
    tableEntries = parseOpenTypeTableEntries(data2, numTables);
  } else if (signature === "wOFF") {
    var flavor = parse.getTag(data2, 4);
    if (flavor === String.fromCharCode(0, 1, 0, 0)) {
      font.outlinesFormat = "truetype";
    } else if (flavor === "OTTO") {
      font.outlinesFormat = "cff";
    } else {
      throw new Error("Unsupported OpenType flavor " + signature);
    }
    numTables = parse.getUShort(data2, 12);
    tableEntries = parseWOFFTableEntries(data2, numTables);
  } else {
    throw new Error("Unsupported OpenType signature " + signature);
  }
  var cffTableEntry;
  var fvarTableEntry;
  var glyfTableEntry;
  var gdefTableEntry;
  var gposTableEntry;
  var gsubTableEntry;
  var hmtxTableEntry;
  var kernTableEntry;
  var locaTableEntry;
  var nameTableEntry;
  var metaTableEntry;
  var p;
  for (var i = 0; i < numTables; i += 1) {
    var tableEntry = tableEntries[i];
    var table2 = void 0;
    switch (tableEntry.tag) {
      case "cmap":
        table2 = uncompressTable(data2, tableEntry);
        font.tables.cmap = cmap.parse(table2.data, table2.offset);
        font.encoding = new CmapEncoding(font.tables.cmap);
        break;
      case "cvt ":
        table2 = uncompressTable(data2, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.cvt = p.parseShortList(tableEntry.length / 2);
        break;
      case "fvar":
        fvarTableEntry = tableEntry;
        break;
      case "fpgm":
        table2 = uncompressTable(data2, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.fpgm = p.parseByteList(tableEntry.length);
        break;
      case "head":
        table2 = uncompressTable(data2, tableEntry);
        font.tables.head = head.parse(table2.data, table2.offset);
        font.unitsPerEm = font.tables.head.unitsPerEm;
        indexToLocFormat = font.tables.head.indexToLocFormat;
        break;
      case "hhea":
        table2 = uncompressTable(data2, tableEntry);
        font.tables.hhea = hhea.parse(table2.data, table2.offset);
        font.ascender = font.tables.hhea.ascender;
        font.descender = font.tables.hhea.descender;
        font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
        break;
      case "hmtx":
        hmtxTableEntry = tableEntry;
        break;
      case "ltag":
        table2 = uncompressTable(data2, tableEntry);
        ltagTable = ltag.parse(table2.data, table2.offset);
        break;
      case "maxp":
        table2 = uncompressTable(data2, tableEntry);
        font.tables.maxp = maxp.parse(table2.data, table2.offset);
        font.numGlyphs = font.tables.maxp.numGlyphs;
        break;
      case "name":
        nameTableEntry = tableEntry;
        break;
      case "OS/2":
        table2 = uncompressTable(data2, tableEntry);
        font.tables.os2 = os2.parse(table2.data, table2.offset);
        break;
      case "post":
        table2 = uncompressTable(data2, tableEntry);
        font.tables.post = post.parse(table2.data, table2.offset);
        font.glyphNames = new GlyphNames(font.tables.post);
        break;
      case "prep":
        table2 = uncompressTable(data2, tableEntry);
        p = new parse.Parser(table2.data, table2.offset);
        font.tables.prep = p.parseByteList(tableEntry.length);
        break;
      case "glyf":
        glyfTableEntry = tableEntry;
        break;
      case "loca":
        locaTableEntry = tableEntry;
        break;
      case "CFF ":
        cffTableEntry = tableEntry;
        break;
      case "kern":
        kernTableEntry = tableEntry;
        break;
      case "GDEF":
        gdefTableEntry = tableEntry;
        break;
      case "GPOS":
        gposTableEntry = tableEntry;
        break;
      case "GSUB":
        gsubTableEntry = tableEntry;
        break;
      case "meta":
        metaTableEntry = tableEntry;
        break;
    }
  }
  var nameTable = uncompressTable(data2, nameTableEntry);
  font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
  font.names = font.tables.name;
  if (glyfTableEntry && locaTableEntry) {
    var shortVersion = indexToLocFormat === 0;
    var locaTable = uncompressTable(data2, locaTableEntry);
    var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
    var glyfTable = uncompressTable(data2, glyfTableEntry);
    font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
  } else if (cffTableEntry) {
    var cffTable = uncompressTable(data2, cffTableEntry);
    cff.parse(cffTable.data, cffTable.offset, font, opt);
  } else {
    throw new Error("Font doesn't contain TrueType or CFF outlines.");
  }
  var hmtxTable = uncompressTable(data2, hmtxTableEntry);
  hmtx.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
  addGlyphNames(font, opt);
  if (kernTableEntry) {
    var kernTable = uncompressTable(data2, kernTableEntry);
    font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
  } else {
    font.kerningPairs = {};
  }
  if (gdefTableEntry) {
    var gdefTable = uncompressTable(data2, gdefTableEntry);
    font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
  }
  if (gposTableEntry) {
    var gposTable = uncompressTable(data2, gposTableEntry);
    font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
    font.position.init();
  }
  if (gsubTableEntry) {
    var gsubTable = uncompressTable(data2, gsubTableEntry);
    font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
  }
  if (fvarTableEntry) {
    var fvarTable = uncompressTable(data2, fvarTableEntry);
    font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
  }
  if (metaTableEntry) {
    var metaTable = uncompressTable(data2, metaTableEntry);
    font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
    font.metas = font.tables.meta;
  }
  return font;
}

// ../packages/engine-render/src/components/docs/layout/shaping-engine/utils.ts
function prepareParagraphBody(body, paragraphIndex) {
  const { dataStream, paragraphs = [], textRuns = [] } = body;
  let last = 0;
  for (let i = 0; i < paragraphs.length; i++) {
    const paragraph = paragraphs[i];
    const { startIndex } = paragraph;
    if (startIndex === paragraphIndex) {
      break;
    }
    last = startIndex + 1;
  }
  const textRunChunks = [];
  for (const textRun of textRuns) {
    const { st, ed } = textRun;
    if (st >= last && st <= paragraphIndex) {
      textRunChunks.push({
        ...textRun,
        st: st - last,
        ed: Math.min(ed, paragraphIndex) - last
      });
    } else if (ed >= last && ed <= paragraphIndex) {
      textRunChunks.push({
        ...textRun,
        st: Math.max(st, last) - last,
        ed: ed - last
      });
    }
  }
  return {
    dataStream: dataStream.substring(last, paragraphIndex + 1),
    textRuns: textRunChunks
  };
}
function prepareTextChunks(body) {
  const { dataStream, textRuns = [] } = body;
  let offset = 0;
  const chunks = [];
  for (const textRun of textRuns) {
    const { st, ed, ts = {} } = textRun;
    if (st !== offset) {
      chunks.push({
        content: dataStream.substring(offset, st)
      });
    }
    chunks.push({
      content: dataStream.substring(st, ed),
      style: ts
    });
    offset = ed;
  }
  if (offset !== dataStream.length) {
    chunks.push({
      content: dataStream.substring(offset)
    });
  }
  return chunks;
}

// ../packages/engine-render/src/components/docs/layout/shaping-engine/text-shaping.ts
var fontCache = /* @__PURE__ */ new Map();
var glyphCache = /* @__PURE__ */ new Map();
function shapeChunk(content, charPosition, used, families, style) {
  var _a, _b, _c, _d;
  let fi = 0;
  let fontFamily = families[fi];
  while (used.has(fontFamily)) {
    fi++;
    fontFamily = families[fi];
  }
  if (!fontFamily) {
    return [{
      char: content,
      start: charPosition,
      end: charPosition + content.length,
      glyph: null,
      font: null,
      kerning: 0,
      boundingBox: null
    }];
  }
  used.add(fontFamily);
  const { font: fontInfo, buffer: fontBuffer } = fontLibrary.findBestMatchFontByStyle({
    ff: fontFamily,
    bl: (_a = style.bl) != null ? _a : 0 /* FALSE */,
    it: (_b = style.it) != null ? _b : 0 /* FALSE */
  });
  let font = fontCache.get(fontInfo.fullName);
  if (!font) {
    font = parseBuffer(fontBuffer);
    fontCache.set(fontInfo.fullName, font);
  }
  const results = [];
  const glyphs = font.stringToGlyphs(content);
  const chars = (_c = content.match(/[\s\S]/gu)) != null ? _c : [];
  let gi = 0;
  let startIndex = 0;
  while (gi < glyphs.length) {
    const glyph = glyphs[gi];
    if (glyph.index !== 0) {
      results.push({
        char: chars[gi],
        start: startIndex + charPosition,
        end: startIndex + charPosition + chars[gi].length,
        glyph,
        font,
        kerning: 0,
        boundingBox: glyph.getBoundingBox()
      });
    } else {
      const start = startIndex;
      const subStr = content.substring(start);
      const emojiMatch = subStr.match(EMOJI_REG);
      if (emojiMatch) {
        let acc = 0;
        do {
          acc += chars[gi].length;
          startIndex += chars[gi].length;
          gi++;
        } while (acc < emojiMatch[0].length);
        results.push(...shapeChunk(content.slice(start, start + emojiMatch[0].length), charPosition + start, used, families, style));
        continue;
      } else {
        let nextGlyph = glyphs[gi + 1];
        let nextChar = chars[gi + 1];
        while ((nextGlyph == null ? void 0 : nextGlyph.index) === 0 && !EMOJI_REG.test(nextChar)) {
          startIndex += chars[gi].length;
          gi++;
          nextGlyph = glyphs[gi + 1];
          nextChar = chars[gi + 1];
        }
        results.push(...shapeChunk(content.slice(start, startIndex + chars[gi].length), charPosition + start, used, families, style));
      }
    }
    startIndex += (_d = chars[gi]) == null ? void 0 : _d.length;
    gi++;
  }
  used.delete(fontFamily);
  return results;
}
function kerningAdjustment(glyphs) {
  if (glyphs.length < 2) {
    return;
  }
  let lastFont = glyphs[0].font;
  let lastGlyph = glyphs[0].glyph;
  for (let i = 1; i < glyphs.length; i++) {
    const { font, glyph } = glyphs[i];
    if (lastFont !== font || font == null || lastGlyph == null || glyph == null) {
      lastFont = font;
      lastGlyph = glyph;
      continue;
    }
    const kerning = font.getKerningValue(lastGlyph, glyph);
    if (kerning !== 0) {
      glyphs[i].kerning = kerning;
    }
    lastFont = font;
    lastGlyph = glyph;
  }
}
function textShape(body) {
  var _a;
  if (!fontLibrary.isReady) {
    return [];
  }
  const key = JSON.stringify(body);
  if (glyphCache.has(key)) {
    return glyphCache.get(key);
  }
  const chunks = prepareTextChunks(body);
  const glyphs = [];
  let charPosition = 0;
  for (const chunk of chunks) {
    const { content, style = {} } = chunk;
    let fontFamilies = DEFAULT_FONTFACE_PLANE.split(",").map((family) => family.trim().replace(/["']/g, ""));
    fontFamilies.unshift((_a = style.ff) != null ? _a : "Arial");
    fontFamilies = fontLibrary.getValidFontFamilies(fontFamilies);
    glyphs.push(...shapeChunk(content, charPosition, /* @__PURE__ */ new Set(), fontFamilies, style));
    charPosition += content.length;
  }
  kerningAdjustment(glyphs);
  glyphCache.set(key, glyphs);
  return glyphs;
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/language-ruler.ts
function otherHandler(index, charArray, viewModel, paragraphNode, sectionBreakConfig, paragraph) {
  var _a;
  const glyphGroup = [];
  let step = 0;
  let src = charArray;
  while (src.length) {
    const char = (_a = src.match(/^[\s\S]/gu)) == null ? void 0 : _a[0];
    if (char == null) {
      break;
    }
    if (hasSpace(char) || startWithEmoji(charArray.substring(step))) {
      break;
    }
    const config = getFontCreateConfig(index + step, viewModel, paragraphNode, sectionBreakConfig, paragraph);
    const glyph = createSkeletonLetterGlyph(char, config);
    glyphGroup.push(glyph);
    src = src.substring(char.length);
    step += char.length;
  }
  return {
    step,
    glyphGroup
  };
}
function ArabicHandler(index, charArray, viewModel, paragraphNode, sectionBreakConfig, paragraph) {
  const config = getFontCreateConfig(index, viewModel, paragraphNode, sectionBreakConfig, paragraph);
  const glyph = [];
  let step = 0;
  for (let i = 0; i < charArray.length; i++) {
    const newChar = charArray[i];
    if (hasArabic(newChar)) {
      glyph.unshift(newChar);
      step++;
    } else {
      break;
    }
  }
  return {
    step,
    glyphGroup: [createSkeletonLetterGlyph(glyph.join(""), config)]
  };
}
function emojiHandler(index, charArray, viewModel, paragraphNode, sectionBreakConfig, paragraph) {
  const config = getFontCreateConfig(index, viewModel, paragraphNode, sectionBreakConfig, paragraph);
  const match = charArray.match(EMOJI_REG);
  return {
    step: match[0].length,
    glyphGroup: [createSkeletonLetterGlyph(match[0], config)]
  };
}
function TibetanHandler(index, charArray, viewModel, paragraphNode, sectionBreakConfig, paragraph) {
  const config = getFontCreateConfig(index, viewModel, paragraphNode, sectionBreakConfig, paragraph);
  const glyph = [];
  let step = 0;
  for (let i = 0; i < charArray.length; i++) {
    const newChar = charArray[i];
    if (hasTibetan(newChar)) {
      glyph.push(newChar);
      step++;
    } else {
      break;
    }
  }
  return {
    step,
    glyphGroup: [createSkeletonWordGlyph(glyph.join(""), config)]
  };
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/shaping.ts
function punctuationSpaceAdjustment(shapedGlyphs) {
  const len = shapedGlyphs.length;
  for (let i = 0; i < len - 1; i++) {
    const curGlyph = shapedGlyphs[i];
    const nextGlyph = shapedGlyphs[i + 1];
    const { width, content } = curGlyph;
    const delta = width / 2;
    if (hasCJKPunctuation(content) && hasCJKPunctuation(nextGlyph.content) && curGlyph.adjustability.shrinkability[1] + nextGlyph.adjustability.shrinkability[0] >= delta) {
      const leftDelta = Math.min(curGlyph.adjustability.shrinkability[1], delta);
      glyphShrinkRight(curGlyph, leftDelta);
      glyphShrinkLeft(nextGlyph, delta - leftDelta);
    }
  }
}
function addCJKLatinSpacing(shapedTextList) {
  const shapedGlyphs = shapedTextList.flatMap((shapedText) => shapedText.glyphs);
  let prevGlyph = null;
  const len = shapedGlyphs.length;
  const LATIN_REG = /[a-z\d]/i;
  for (let i = 0; i < len; i++) {
    const curGlyph = shapedGlyphs[i];
    const nextGlyph = i < len - 1 ? shapedGlyphs[i + 1] : null;
    const { width } = curGlyph;
    if (hasCJKText(curGlyph.content) && nextGlyph && LATIN_REG.test(nextGlyph.content)) {
      curGlyph.width += width / 4;
      curGlyph.adjustability.shrinkability[1] += width / 8;
    }
    if (hasCJKText(curGlyph.content) && prevGlyph && LATIN_REG.test(prevGlyph.content)) {
      curGlyph.width += width / 4;
      curGlyph.xOffset += width / 4;
      curGlyph.adjustability.shrinkability[0] += width / 8;
    }
    prevGlyph = curGlyph;
  }
}
function hyphenConfig(paragraphStyle, sectionBreakConfig) {
  const { suppressHyphenation = 0 /* FALSE */ } = paragraphStyle;
  const { autoHyphenation = 0 /* FALSE */ } = sectionBreakConfig;
  return suppressHyphenation === 0 /* FALSE */ && autoHyphenation === 1 /* TRUE */;
}
function shaping(ctx, content, viewModel, paragraphNode, sectionBreakConfig, useOpenType = false) {
  var _a, _b;
  const {
    gridType = 1 /* LINES */,
    charSpace = 0,
    defaultTabStop = 10.5,
    drawings = {}
  } = sectionBreakConfig;
  const shapedTextList = [];
  let breaker = new LineBreaker(content);
  const { endIndex } = paragraphNode;
  const paragraph = viewModel.getParagraph(endIndex) || { startIndex: 0 };
  const { paragraphStyle = {} } = paragraph;
  const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
  let last = 0;
  let bk;
  let lastGlyphIndex = 0;
  const { hyphen, languageDetector } = ctx;
  const paragraphBody = prepareParagraphBody(viewModel.getBody(), endIndex);
  let glyphInfos = [];
  if (useOpenType) {
    glyphInfos = textShape(paragraphBody);
  }
  tabLineBreakExtension(breaker);
  customBlockLineBreakExtension(breaker);
  breaker = new LineBreakerLinkEnhancer(breaker);
  const lang = languageDetector.detect(content);
  const needHyphen = hyphenConfig(paragraphStyle, sectionBreakConfig);
  const doNotHyphenateCaps = sectionBreakConfig.doNotHyphenateCaps === 1 /* TRUE */;
  if (lang !== "unknown" /* UNKNOWN */ && needHyphen) {
    if (hyphen.hasPattern(lang)) {
      breaker = new LineBreakerHyphenEnhancer(breaker, hyphen, lang, doNotHyphenateCaps);
    } else {
      hyphen.loadPattern(lang);
    }
  }
  while (bk = breaker.nextBreakPoint()) {
    const word = content.slice(last, bk.position);
    const shapedGlyphs = [];
    if (fontLibrary.isReady && useOpenType) {
      const glyphInfosInWord = [];
      let i = 0;
      for (i = lastGlyphIndex; i < glyphInfos.length; i++) {
        const glyphInfo = glyphInfos[i];
        const { end } = glyphInfo;
        if (end > bk.position) {
          break;
        }
        glyphInfosInWord.push(glyphInfo);
      }
      lastGlyphIndex = i;
      for (const glyphInfo of glyphInfosInWord) {
        const { start, char } = glyphInfo;
        const config = getFontCreateConfig(start, viewModel, paragraphNode, sectionBreakConfig, paragraph);
        if (char === "	" /* TAB */) {
          const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
          const newSpan = createSkeletonTabGlyph(config, charSpaceApply);
          shapedGlyphs.push(newSpan);
        } else if (startWithEmoji(char)) {
          const newSpan = createSkeletonLetterGlyph(char, config);
          shapedGlyphs.push(newSpan);
        } else {
          const newSpan = createSkeletonLetterGlyph(char, config, void 0, glyphInfo);
          shapedGlyphs.push(newSpan);
        }
      }
    } else {
      let src = word;
      let i = last;
      while (src.length > 0) {
        const char = (_a = src.match(/^[\s\S]/gu)) == null ? void 0 : _a[0];
        if (char == null) {
          break;
        }
        if (char === "\b" /* CUSTOM_BLOCK */) {
          const config = getFontCreateConfig(i, viewModel, paragraphNode, sectionBreakConfig, paragraph);
          let newGlyph = null;
          const customBlock = viewModel.getCustomBlockWithoutSetCurrentIndex(paragraphNode.startIndex + i);
          if (customBlock != null) {
            const { blockId } = customBlock;
            const drawingOrigin = drawings[blockId];
            if (drawingOrigin.layoutType === 0 /* INLINE */) {
              const { angle } = drawingOrigin.docTransform;
              const { width = 0, height = 0 } = drawingOrigin.docTransform.size;
              const top = 0;
              const left = 0;
              const boundingBox = getBoundingBox(angle, left, width, top, height);
              newGlyph = createSkeletonCustomBlockGlyph(config, boundingBox.width, boundingBox.height, drawingOrigin.drawingId);
            } else {
              newGlyph = createSkeletonCustomBlockGlyph(config, 0, 0, drawingOrigin.drawingId);
            }
          }
          if (newGlyph == null) {
            newGlyph = createSkeletonLetterGlyph(char, config);
          }
          shapedGlyphs.push(newGlyph);
          i += char.length;
          src = src.substring(char.length);
        } else if (/\s/.test(char) || hasCJK(char)) {
          const config = getFontCreateConfig(i, viewModel, paragraphNode, sectionBreakConfig, paragraph);
          let newGlyph = null;
          if (char === "	" /* TAB */) {
            const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
            newGlyph = createSkeletonTabGlyph(config, charSpaceApply);
          } else if (char === "\r" /* PARAGRAPH */) {
            const zeroWidthParagraphBreak = (_b = sectionBreakConfig.renderConfig) == null ? void 0 : _b.zeroWidthParagraphBreak;
            if (zeroWidthParagraphBreak === 1 /* TRUE */) {
              newGlyph = createSkeletonLetterGlyph(char, config, 0);
            } else {
              newGlyph = createSkeletonLetterGlyph(char, config);
            }
          } else {
            newGlyph = createSkeletonLetterGlyph(char, config);
          }
          shapedGlyphs.push(newGlyph);
          i += char.length;
          src = src.substring(char.length);
        } else if (startWithEmoji(src)) {
          const { step, glyphGroup } = emojiHandler(
            i,
            src,
            viewModel,
            paragraphNode,
            sectionBreakConfig,
            paragraph
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        } else if (hasArabic(char)) {
          const { step, glyphGroup } = ArabicHandler(
            i,
            src,
            viewModel,
            paragraphNode,
            sectionBreakConfig,
            paragraph
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        } else if (hasTibetan(char)) {
          const { step, glyphGroup } = TibetanHandler(
            i,
            src,
            viewModel,
            paragraphNode,
            sectionBreakConfig,
            paragraph
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        } else {
          const { step, glyphGroup } = otherHandler(
            i,
            src,
            viewModel,
            paragraphNode,
            sectionBreakConfig,
            paragraph
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        }
      }
    }
    punctuationSpaceAdjustment(shapedGlyphs);
    const shapedGlyphsList = [[]];
    for (let i = 0; i < shapedGlyphs.length; i++) {
      const lastList = shapedGlyphsList[shapedGlyphsList.length - 1];
      const glyph = shapedGlyphs[i];
      if (glyph.streamType === "\b" /* CUSTOM_BLOCK */ && glyph.width !== 0) {
        if (lastList.length === 0) {
          shapedGlyphsList.pop();
        }
        shapedGlyphsList.push([glyph]);
      } else {
        lastList.push(glyph);
      }
    }
    const lastShapedGlyphs = shapedGlyphsList[shapedGlyphsList.length - 1];
    for (const shapedGlyphs2 of shapedGlyphsList) {
      const word2 = shapedGlyphs2.map((g) => g.content).join("");
      shapedTextList.push({
        text: word2,
        glyphs: shapedGlyphs2,
        breakPointType: shapedGlyphs2 === lastShapedGlyphs ? bk.type : "Normal" /* Normal */
      });
    }
    last = bk.position;
  }
  addCJKLatinSpacing(shapedTextList);
  return shapedTextList;
}

// ../packages/engine-render/src/components/docs/layout/block/paragraph/paragraph-layout.ts
function dealWidthParagraph(ctx, viewModel, paragraphNode, curPage, sectionBreakConfig) {
  clearFontCreateConfigCache();
  const { content = "", children } = paragraphNode;
  let tableSkeleton = null;
  if (children.length === 1 && children[0].nodeType === "TABLE" /* TABLE */) {
    tableSkeleton = createTableSkeleton(
      ctx,
      curPage,
      viewModel,
      children[0],
      sectionBreakConfig
    );
  }
  const shapedTextList = shaping(
    ctx,
    content,
    viewModel,
    paragraphNode,
    sectionBreakConfig
  );
  const allPages = lineBreaking(
    ctx,
    viewModel,
    shapedTextList,
    curPage,
    paragraphNode,
    sectionBreakConfig,
    tableSkeleton
  );
  lineAdjustment(
    allPages,
    viewModel,
    paragraphNode,
    sectionBreakConfig
  );
  return allPages;
}

// ../packages/engine-render/src/components/docs/layout/block/section.ts
function dealWithSection(ctx, viewModel, sectionNode, curPage, sectionBreakConfig, layoutAnchor) {
  const allCurrentSkeletonPages = [];
  const renderedBlockIdMap = /* @__PURE__ */ new Map();
  let paragraphStartIndex = 0;
  if (layoutAnchor != null) {
    const { startIndex, endIndex } = sectionNode;
    if (layoutAnchor >= startIndex && layoutAnchor <= endIndex) {
      for (let pi = 0; pi < sectionNode.children.length; pi++) {
        const paragraph = sectionNode.children[pi];
        if (paragraph.endIndex === layoutAnchor) {
          paragraphStartIndex = pi;
          break;
        }
      }
    }
  }
  for (let i = paragraphStartIndex; i < sectionNode.children.length; i++) {
    const paragraphNode = sectionNode.children[i];
    let skeletonPages = [];
    let currentPageCache = curPage;
    if (allCurrentSkeletonPages.length > 0) {
      currentPageCache = allCurrentSkeletonPages[allCurrentSkeletonPages.length - 1];
    }
    if (paragraphNode.nodeType === "PARAGRAPH" /* PARAGRAPH */) {
      if (ctx.paragraphsOpenNewPage.has(paragraphNode.endIndex)) {
        currentPageCache = createSkeletonPage(
          ctx,
          sectionBreakConfig,
          ctx.skeletonResourceReference,
          currentPageCache.pageNumber + 1
        );
      }
      skeletonPages = dealWidthParagraph(
        ctx,
        viewModel,
        paragraphNode,
        currentPageCache,
        sectionBreakConfig
      );
    }
    if (skeletonPages.length === 0) {
      skeletonPages = dealWithBlockError();
    }
    _pushPage(allCurrentSkeletonPages, skeletonPages);
    if (ctx.isDirty) {
      break;
    }
  }
  const { segmentId } = curPage;
  if (ctx.isDirty && ctx.layoutStartPointer[segmentId] != null) {
    _rollbackPages(ctx.layoutStartPointer[segmentId], allCurrentSkeletonPages);
  }
  return {
    pages: allCurrentSkeletonPages,
    renderedBlockIdMap
  };
}
function _rollbackPages(paragraphIndex, allCurrentSkeletonPages) {
  let findFirstDirtyLine = false;
  for (let pageIndex = 0; pageIndex < allCurrentSkeletonPages.length; pageIndex++) {
    const page = allCurrentSkeletonPages[pageIndex];
    for (let sectionIndex = 0; sectionIndex < page.sections.length; sectionIndex++) {
      const section = page.sections[sectionIndex];
      for (let columnIndex = 0; columnIndex < section.columns.length; columnIndex++) {
        const column = section.columns[columnIndex];
        for (let lineIndex = 0; lineIndex < column.lines.length; lineIndex++) {
          const line2 = column.lines[lineIndex];
          if (line2.paragraphIndex === paragraphIndex) {
            findFirstDirtyLine = true;
            column.lines.splice(lineIndex);
            break;
          }
        }
        if (findFirstDirtyLine) {
          let columnSplitIndex = column.lines.length ? columnIndex + 1 : columnIndex;
          columnSplitIndex = Math.max(columnSplitIndex, 1);
          const preColumnIndex = columnSplitIndex - 1;
          if (preColumnIndex >= 0) {
            section.columns[preColumnIndex].isFull = false;
          }
          section.columns.splice(columnSplitIndex);
          break;
        }
      }
      if (findFirstDirtyLine) {
        const sectionSplitIndex = sectionIndex + 1;
        page.sections.splice(sectionSplitIndex);
        break;
      }
    }
    if (findFirstDirtyLine) {
      const pageSplitIndex = pageIndex + 1;
      allCurrentSkeletonPages.splice(Math.max(pageSplitIndex, 1));
      break;
    }
  }
}
function _pushPage(allCurrentSkeletonPages, blockSkeletonPages) {
  const lastIndex = allCurrentSkeletonPages.length - 1;
  const lastOldPage = allCurrentSkeletonPages[lastIndex];
  const firstNewPage = blockSkeletonPages[0];
  if (lastOldPage === firstNewPage) {
    blockSkeletonPages.splice(0, 1);
  }
  allCurrentSkeletonPages.push(...blockSkeletonPages);
}

// ../packages/engine-render/src/components/docs/layout/hyphenation/tools.ts
function parsePattern(pattern) {
  const [levelsTableStr, patternStr] = pattern;
  return {
    levelsTable: levelsTableStr.split(","),
    pattern: JSON.parse(patternStr)
  };
}
function snackToPascal(snack) {
  return snack.replace(/^[a-z]/, (g) => g.toUpperCase()).replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}
function createStringSlicer(str) {
  let i = 0;
  let slice = str;
  function next() {
    slice = str.slice(i++);
    if (slice.length < 3) {
      return [];
    }
    return slice;
  }
  function isFirstCharacter() {
    return i === 2;
  }
  return [next, isFirstCharacter];
}
function createCharIterator(str) {
  let i = 0;
  function nextChar() {
    return str[i++];
  }
  function isLastLetter() {
    return str.length === i + 1;
  }
  return [nextChar, isLastLetter];
}

// import("./patterns/**/*.ts") in ../packages/engine-render/src/components/docs/layout/hyphenation/hyphen.ts
var globImport_patterns_ts = __glob({
  "./patterns/af.ts": () => import("./af-UIBZU5Y2.js"),
  "./patterns/as.ts": () => import("./as-ZHK6R4BS.js"),
  "./patterns/be.ts": () => import("./be-L7OG5CVI.js"),
  "./patterns/bg.ts": () => import("./bg-TSXVRW56.js"),
  "./patterns/bn.ts": () => import("./bn-FFYVTAGE.js"),
  "./patterns/ca.ts": () => import("./ca-J5BFE3PD.js"),
  "./patterns/cop.ts": () => import("./cop-VVXZM2GD.js"),
  "./patterns/cs.ts": () => import("./cs-BLDYYZ44.js"),
  "./patterns/cu.ts": () => import("./cu-Y4XXD3ZE.js"),
  "./patterns/cy.ts": () => import("./cy-ULYPC4BJ.js"),
  "./patterns/da.ts": () => import("./da-BSLNJSWG.js"),
  "./patterns/de-1901.ts": () => import("./de-1901-5NUYKFPX.js"),
  "./patterns/de-1996.ts": () => import("./de-1996-PJKZ4B2X.js"),
  "./patterns/de-ch-1901.ts": () => import("./de-ch-1901-6VPX7G67.js"),
  "./patterns/el-monoton.ts": () => import("./el-monoton-VDFVGJZA.js"),
  "./patterns/el-polyton.ts": () => import("./el-polyton-2OHVICSF.js"),
  "./patterns/en-gb.ts": () => import("./en-gb-BKCEUQYX.js"),
  "./patterns/en-us.ts": () => import("./en-us-F3JE3G2N.js"),
  "./patterns/es.ts": () => import("./es-C4THRHYU.js"),
  "./patterns/et.ts": () => import("./et-XPG3QGQN.js"),
  "./patterns/eu.ts": () => import("./eu-LPRF43GY.js"),
  "./patterns/fi.ts": () => import("./fi-FJ6XPA2T.js"),
  "./patterns/fr.ts": () => import("./fr-BJIZ6KC3.js"),
  "./patterns/fur.ts": () => import("./fur-7KFEDJC3.js"),
  "./patterns/ga.ts": () => import("./ga-JXUSOHUO.js"),
  "./patterns/gl.ts": () => import("./gl-3FKPNSB6.js"),
  "./patterns/grc.ts": () => import("./grc-UY3WNANQ.js"),
  "./patterns/gu.ts": () => import("./gu-EHOZBYHG.js"),
  "./patterns/hi.ts": () => import("./hi-DPJNJ2B5.js"),
  "./patterns/hr.ts": () => import("./hr-F7SECAC7.js"),
  "./patterns/hsb.ts": () => import("./hsb-55XOCLA5.js"),
  "./patterns/hu.ts": () => import("./hu-63YGCPN3.js"),
  "./patterns/hy.ts": () => import("./hy-DVEUXGVL.js"),
  "./patterns/ia.ts": () => import("./ia-COAND44L.js"),
  "./patterns/id.ts": () => import("./id-RTSLJHSK.js"),
  "./patterns/is.ts": () => import("./is-SER4Z7UB.js"),
  "./patterns/it.ts": () => import("./it-T4ACCFR3.js"),
  "./patterns/ka.ts": () => import("./ka-UUBU5VAI.js"),
  "./patterns/kmr.ts": () => import("./kmr-5K3BSPJO.js"),
  "./patterns/kn.ts": () => import("./kn-GULYRTR7.js"),
  "./patterns/la-x-classic.ts": () => import("./la-x-classic-VL7SAANH.js"),
  "./patterns/la-x-liturgic.ts": () => import("./la-x-liturgic-BQTDM4XH.js"),
  "./patterns/la.ts": () => import("./la-NMB7MSDY.js"),
  "./patterns/lt.ts": () => import("./lt-X3MRUF3V.js"),
  "./patterns/lv.ts": () => import("./lv-4ZI6FE2T.js"),
  "./patterns/ml.ts": () => import("./ml-ZKDINWWT.js"),
  "./patterns/mn-cyrl-x-lmc.ts": () => import("./mn-cyrl-x-lmc-X6DHX2I5.js"),
  "./patterns/mn-cyrl.ts": () => import("./mn-cyrl-XYBFSUOJ.js"),
  "./patterns/mr.ts": () => import("./mr-JBZCW2EP.js"),
  "./patterns/mul-ethi.ts": () => import("./mul-ethi-ZPQBKCKG.js"),
  "./patterns/nb.ts": () => import("./nb-CI7OG3JH.js"),
  "./patterns/nl.ts": () => import("./nl-O3MSQ5F7.js"),
  "./patterns/nn.ts": () => import("./nn-6P3IRM7P.js"),
  "./patterns/no.ts": () => import("./no-B5IVAHZW.js"),
  "./patterns/oc.ts": () => import("./oc-YNRLHUML.js"),
  "./patterns/or.ts": () => import("./or-253GDATY.js"),
  "./patterns/pa.ts": () => import("./pa-T2AM47WP.js"),
  "./patterns/pi.ts": () => import("./pi-RRKAHFJO.js"),
  "./patterns/pl.ts": () => import("./pl-5CJVQRTT.js"),
  "./patterns/pms.ts": () => import("./pms-5UHVSA4Z.js"),
  "./patterns/pt.ts": () => import("./pt-Y3ZQSOG2.js"),
  "./patterns/rm.ts": () => import("./rm-LCG7W4HL.js"),
  "./patterns/ro.ts": () => import("./ro-RIXWVBI4.js"),
  "./patterns/ru.ts": () => import("./ru-WMH26LZA.js"),
  "./patterns/sa.ts": () => import("./sa-4UUYLSUP.js"),
  "./patterns/sh-cyrl.ts": () => import("./sh-cyrl-JRO7SQFA.js"),
  "./patterns/sh-latn.ts": () => import("./sh-latn-PMP6IZXH.js"),
  "./patterns/sk.ts": () => import("./sk-JBB2YWNE.js"),
  "./patterns/sl.ts": () => import("./sl-Y2K4HFQQ.js"),
  "./patterns/sr-cyrl.ts": () => import("./sr-cyrl-O2TFFPCB.js"),
  "./patterns/sv.ts": () => import("./sv-M3XUIFD2.js"),
  "./patterns/ta.ts": () => import("./ta-AZE2UI2O.js"),
  "./patterns/te.ts": () => import("./te-4L3P4RFR.js"),
  "./patterns/th.ts": () => import("./th-UKLN3MAK.js"),
  "./patterns/tk.ts": () => import("./tk-NOETCKID.js"),
  "./patterns/tr.ts": () => import("./tr-7PQIKJKN.js"),
  "./patterns/uk.ts": () => import("./uk-6K27HQ55.js"),
  "./patterns/zh-latn-pinyin.ts": () => import("./zh-latn-pinyin-L7NSCAZY.js")
});

// ../packages/engine-render/src/components/docs/layout/hyphenation/hyphen.ts
var _Hyphen = class _Hyphen {
  constructor() {
    __publicField(this, "_patterns", /* @__PURE__ */ new Map());
    __publicField(this, "_hyphenCache", /* @__PURE__ */ new Map());
    this._preloadPatterns();
    this.loadPattern("en-gb" /* EnGb */);
  }
  static getInstance() {
    if (this._instance == null) {
      this._instance = new _Hyphen();
    }
    return this._instance;
  }
  _preloadPatterns() {
    this._patterns.set("en-us" /* EnUs */, parsePattern(EnUs));
    this._loadExceptionsToCache("en-us" /* EnUs */, EnUs);
  }
  _loadExceptionsToCache(lang, pattern) {
    if (pattern.length < 3) {
      return;
    }
    const exceptions = pattern[2];
    for (const exception of exceptions) {
      const cacheKey = exception.replace(/-/g, "");
      const hyphens = exception.split("-");
      let cache = this._hyphenCache.get(lang);
      if (cache == null) {
        cache = /* @__PURE__ */ new Map();
        this._hyphenCache.set(lang, cache);
      }
      cache.set(cacheKey, hyphens);
    }
  }
  async loadPattern(lang) {
    let pattern = await globImport_patterns_ts(`./patterns/${lang}.ts`);
    pattern = pattern == null ? void 0 : pattern[snackToPascal(lang)];
    if (pattern == null) {
      return;
    }
    this._patterns.set(lang, parsePattern(pattern));
    this._loadExceptionsToCache(lang, pattern);
  }
  // Only used for text.
  fetchHyphenCache(lang) {
    return this._hyphenCache.get(lang);
  }
  hasPattern(lang) {
    return this._patterns.has(lang);
  }
  hyphenate(word, lang) {
    let cache = this._hyphenCache.get(lang);
    if (cache == null ? void 0 : cache.has(word)) {
      return cache.get(word);
    }
    if (!this._patterns.has(lang)) {
      throw new Error(`Language pattern not found for ${lang}, please load pattern before hyphenating`);
    }
    const { levelsTable, pattern } = this._patterns.get(lang);
    const levels = new Array(word.length + 1).fill(0);
    const loweredText = `.${word.toLocaleLowerCase()}.`.split("");
    const [nextSlice, isFirstCharacter] = createStringSlicer(loweredText);
    let wordSlice;
    let letter;
    let treePtr;
    let nextPtr;
    let patternLevelsIndex;
    let patternLevels;
    let patternEntityIndex = -1;
    let charIterator;
    let nextLetter;
    let isLastLetter;
    while ((wordSlice = nextSlice()).length > 0) {
      patternEntityIndex++;
      if (isFirstCharacter()) {
        patternEntityIndex--;
      }
      treePtr = pattern;
      charIterator = createCharIterator(wordSlice);
      nextLetter = charIterator[0];
      isLastLetter = charIterator[1];
      while (letter = nextLetter()) {
        if (treePtr[letter] === void 0) {
          break;
        }
        nextPtr = treePtr[letter];
        treePtr = nextPtr[0];
        patternLevelsIndex = nextPtr[1];
        if (treePtr === void 0) {
          treePtr = {};
          patternLevelsIndex = nextPtr;
        }
        if (isLastLetter()) {
          continue;
        }
        if (patternLevelsIndex === void 0) {
          continue;
        }
        patternLevels = levelsTable[patternLevelsIndex];
        for (let k = 0; k < patternLevels.length; k++) {
          levels[patternEntityIndex + k] = Math.max(
            +patternLevels[k],
            levels[patternEntityIndex + k]
          );
        }
      }
    }
    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;
    let hyphenatedText = "";
    for (let i = 0; i < levels.length; i++) {
      hyphenatedText += (levels[i] % 2 === 1 ? "-" : "") + word.charAt(i);
    }
    if (cache == null) {
      cache = /* @__PURE__ */ new Map();
      this._hyphenCache.set(lang, cache);
    }
    const hyphenatedSlices = hyphenatedText.split("-");
    cache.set(word, hyphenatedSlices);
    return hyphenatedSlices;
  }
  dispose() {
    this._patterns.clear();
    this._hyphenCache.clear();
  }
};
__publicField(_Hyphen, "_instance", null);
var Hyphen = _Hyphen;

// ../node_modules/.pnpm/n-gram@2.0.2/node_modules/n-gram/index.js
var bigram = nGram(2);
var trigram = nGram(3);
function nGram(n) {
  if (typeof n !== "number" || Number.isNaN(n) || n < 1 || n === Number.POSITIVE_INFINITY) {
    throw new Error("`" + n + "` is not a valid argument for `n-gram`");
  }
  return grams;
  function grams(value) {
    const nGrams = [];
    if (value === null || value === void 0) {
      return nGrams;
    }
    const source = typeof value.slice === "function" ? value : String(value);
    let index = source.length - n + 1;
    if (index < 1) {
      return nGrams;
    }
    while (index--) {
      nGrams[index] = source.slice(index, index + n);
    }
    return nGrams;
  }
}

// ../node_modules/.pnpm/collapse-white-space@2.1.0/node_modules/collapse-white-space/index.js
var js = /\s+/g;
var html = /[\t\n\v\f\r ]+/g;
function collapseWhiteSpace(value, options) {
  if (!options) {
    options = {};
  } else if (typeof options === "string") {
    options = { style: options };
  }
  const replace = options.preserveLineEndings ? replaceLineEnding : replaceSpace;
  return String(value).replace(
    options.style === "html" ? html : js,
    options.trim ? trimFactory(replace) : replace
  );
}
function replaceLineEnding(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceSpace() {
  return " ";
}
function trimFactory(replace) {
  return dropOrReplace;
  function dropOrReplace(value, index, all2) {
    return index === 0 || index + value.length === all2.length ? "" : replace(value);
  }
}

// ../node_modules/.pnpm/trigram-utils@2.0.1/node_modules/trigram-utils/index.js
var own = {}.hasOwnProperty;
function clean(value) {
  if (value === null || value === void 0) {
    return "";
  }
  return collapseWhiteSpace(String(value).replace(/[\u0021-\u0040]+/g, " ")).trim().toLowerCase();
}
function trigrams(value) {
  return trigram(" " + clean(value) + " ");
}
function asDictionary(value) {
  const values = trigrams(value);
  const dictionary = {};
  let index = -1;
  while (++index < values.length) {
    if (own.call(dictionary, values[index])) {
      dictionary[values[index]]++;
    } else {
      dictionary[values[index]] = 1;
    }
  }
  return dictionary;
}
function asTuples(value) {
  const dictionary = asDictionary(value);
  const tuples = [];
  let trigram2;
  for (trigram2 in dictionary) {
    if (own.call(dictionary, trigram2)) {
      tuples.push([trigram2, dictionary[trigram2]]);
    }
  }
  tuples.sort(sort);
  return tuples;
}
function sort(a, b) {
  return a[1] - b[1];
}

// ../node_modules/.pnpm/franc-min@6.2.0/node_modules/franc-min/expressions.js
var expressions = {
  cmn: /[\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFA6D\uFA70-\uFAD9]|\uD81B[\uDFE2\uDFE3\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]/g,
  Latin: /[A-Za-z\u00AA\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u02E0-\u02E4\u1D00-\u1D25\u1D2C-\u1D5C\u1D62-\u1D65\u1D6B-\u1D77\u1D79-\u1DBE\u1E00-\u1EFF\u2071\u207F\u2090-\u209C\u212A\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB64\uAB66-\uAB69\uFB00-\uFB06\uFF21-\uFF3A\uFF41-\uFF5A]|\uD801[\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]/g,
  Cyrillic: /[\u0400-\u0484\u0487-\u052F\u1C80-\u1C88\u1D2B\u1D78\u2DE0-\u2DFF\uA640-\uA69F\uFE2E\uFE2F]|\uD838[\uDC30-\uDC6D\uDC8F]/g,
  Arabic: /[\u0600-\u0604\u0606-\u060B\u060D-\u061A\u061C-\u061E\u0620-\u063F\u0641-\u064A\u0656-\u066F\u0671-\u06DC\u06DE-\u06FF\u0750-\u077F\u0870-\u088E\u0890\u0891\u0898-\u08E1\u08E3-\u08FF\uFB50-\uFBC2\uFBD3-\uFD3D\uFD40-\uFD8F\uFD92-\uFDC7\uFDCF\uFDF0-\uFDFF\uFE70-\uFE74\uFE76-\uFEFC]|\uD803[\uDE60-\uDE7E\uDEFD-\uDEFF]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB\uDEF0\uDEF1]/g,
  ben: /[\u0980-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FE]/g,
  Devanagari: /[\u0900-\u0950\u0955-\u0963\u0966-\u097F\uA8E0-\uA8FF]|\uD806[\uDF00-\uDF09]/g,
  jpn: /[\u3041-\u3096\u309D-\u309F]|\uD82C[\uDC01-\uDD1F\uDD32\uDD50-\uDD52]|\uD83C\uDE00|[\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00\uDD20-\uDD22\uDD55\uDD64-\uDD67]|[\u3400-\u4DB5\u4E00-\u9FAF]/g,
  jav: /[\uA980-\uA9CD\uA9D0-\uA9D9\uA9DE\uA9DF]/g,
  kor: /[\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/g,
  tel: /[\u0C00-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3C-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C5D\u0C60-\u0C63\u0C66-\u0C6F\u0C77-\u0C7F]/g,
  tam: /[\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA]|\uD807[\uDFC0-\uDFF1\uDFFF]/g,
  guj: /[\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF]/g,
  kan: /[\u0C80-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDD\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1-\u0CF3]/g,
  mal: /[\u0D00-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F]/g,
  mya: /[\u1000-\u109F\uA9E0-\uA9FE\uAA60-\uAA7F]/g,
  pan: /[\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A76]/g,
  amh: /[\u1200-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]/g,
  tha: /[\u0E01-\u0E3A\u0E40-\u0E5B]/g,
  sin: /[\u0D81-\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4]|\uD804[\uDDE1-\uDDF4]/g,
  ell: /[\u0370-\u0373\u0375-\u0377\u037A-\u037D\u037F\u0384\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\uAB65]|\uD800[\uDD40-\uDD8E\uDDA0]|\uD834[\uDE00-\uDE45]/g
};

// ../node_modules/.pnpm/franc-min@6.2.0/node_modules/franc-min/data.js
var data = {
  Latin: {
    spa: " de|de |os | la| a |la | y |\xF3n |i\xF3n|es |ere|rec|ien|o a|der|ci\xF3|cho|ech|en |a p|ent|a l|aci|el |na |ona|e d| co|as |da | to|al |ene| en|tod| pe|e l| el|ho |nte| su|per|a t|ad | ti|ers|tie| se|rso|son|e s| pr|o d|oda|te |cia|n d| es|dad|ida| in|ne |est|ion|cio|s d|con|a e| po|men| li|n e|nci|res|su |to |tra| re| lo|tad| na|los|a s| o |ia |que| pa|r\xE1 |pro| un|s y|ual|s e|lib|nac|do |ra |er |a d|ue | qu|e e|sta|nal|ar |nes|ica|a c|ser|or |ter|se |por|cci|io |del|l d|des|ado|les|one|a a|ndi| so| cu|s p|ale|s n|ame|par|ici|oci|una|ber|s t|rta|com| di|dos|e a|imi|o s|e c|ert|las|o p|ant|dic|nto| al|ara|ibe|enc|o e|s l|cas| as|e p|ten|ali|o t|soc|y l|n c|nta|so |tos|y a|ria|n t|die|a u| fu|no |l p|ial|qui|dis|s o|hos|gua|igu| ig| ca|sar|l t| ma|l e|pre| ac|tiv|s a|re |nad|vid|era| tr|ier|cua|n p|ta |cla|ade|bre|s s|esa|ntr|ecc|a i| le|lid|das|d d|ido|ari|ind|ada|nda|fun|mie|ca |tic|eli|y d|nid|e i|odo|ios|o y|esp|iva|y e|mat|bli|r a|dr\xE1|tri|cti|tal|rim|ont|er\xE1|us |sus|end|pen|tor|ito|ond|ori|uie|lig|n a|ist|rac|lar|rse|tar|mo |omo|ibr|n l|edi|med| me|nio|a y|eda|isf|lo |aso|l m|ias|ico|lic|ple|ste|act|tec|ote|rot|ele|ura| ni|ie |adi|u p|seg|s i|un |und|a n|lqu|alq|o i|inc|sti| si|n s|ern",
    eng: "the| th| an|he |nd |ion|and| to|to |tio| of|on |of | in|al |ati|or |ght|igh|rig| ri|ne |ent|one|ll |is |as |ver|ed | be|e r|in |t t|all|eve|ht | or|ery|s t|ty | ev|e h|yon| ha|ryo|e a|be |his| fr|ng |d t|has| sh|ing| hi|sha| pr| co| re|hal|nal|y a|s a|n t|ce |men|ree|fre|e s|l b|nat|for|ts |nt |n a|ity|ry |her|nce|ect|d i| pe|pro|n o|cti| fo|e e|ly |es | no|ona|ny |any|er |re |f t|e o| de|s o| wi|ter|nte|e i|ons| en| ar|res|ers|y t|per|d f| a | on|ith|l a|e t|oci|soc|lit| as| se|dom|edo|eed|nti|s e|t o|oth|wit| di|equ|t a|ted|st |y o|int|e p| ma| so| na|l o|e c|ch |d a|enc|th |are|ns |ic | un| fu|tat|ial|cia| ac|hts|nit|qua| eq| al|om |e w|d o|f h|ali|ote|n e| wh|r t|sta|ge |thi|o a|tit|ual|an |te |ess| ch|le |ary|e f|by | by|y i|tec|uni|o t|o o| li|no | la|s r| su|inc|led|rot|con| pu| he|ere|imi|r a|ntr| st| ot|eli|age|dis|s d|tle|itl|hou|son|duc|edu| wo|ate|ble|ces|at | at| fa|com|ive|o s|eme|o e|aw |law|tra|und|pen|nde|unt|oun|n s|s f|f a|tho|ms | is|act|cie|cat|uca| ed|anc|wor|ral|t i| me|o f|ily|pri|ren|ose|s c|en |d n|l c|ful|rar|nta|nst| ag|l p|min|din|sec|y e| tr|rso|ich|hic|whi|cou|ern|uri|r o|tic|iti|igi|lig|rat|rth|t f|oms|rit|d r|ee |e b|era|rou|se |ay |rs | ho|abl|e u",
    por: "de | de| se|\xE3o |os |to |em | e |do |o d| di|er |ito|eit|ser|ent|\xE7\xE3o| a |dir|ire|rei|o s|ade|dad|uma|as |no |e d| to|nte| co|o t|tod| ou|men|que|s e|man| pr| in| qu|es | te|hum|odo|e a|da | hu|ano|te |al |tem|o e|s d|ida|m d| pe| re|o a|ou |r h|e s|cia|a e| li|o p| es|res| do| da| \xE0 |ual| em| su|a\xE7\xE3|dos|a p|tra|est|ia |con|pro|ar |e p|is | na|r\xE1 |qua|a d| pa|com|ais|o c|ame|er\xE1| po|uer|sta|ber|ter| o |ess|ra |e e|das|o \xE0|nto|nal|o o|a c|ido|rda|erd| as|nci|sua|ona|des|ibe|lib|e t|ado|s n|ua |s t|ue | so|ica|ma |lqu|alq|tos|m s|a l|per|ada|oci|soc|cio|a n|par|aci|s a|pre|ont|m o|ura|a s| um|ion|e o|or |e r|pel|nta|ntr|a i|io |nac|\xEAnc|str|ali|ria|nst| tr|a q|int|o n|a o|ca |ela|u\xE7\xE3|lid|e l| at|sen|ese|r d|s p|egu|seg|vid|pri|sso|\xE9m |ime|tic|dis|ra\xE7|eci|ara| ca|nid|tru|\xF5es|ass|seu|por|a a|m p| ex|so |r i|e\xE7\xE3|te\xE7|ote|rot| le| ma|ing|a t|ran|era|rio|l d|eli|\xE7a |sti| ne|cid|ern|utr|out|r e|e c|tad|gua|igu| ig| os|s o|ru\xE7|ins|\xE7\xF5e|ios| fa|e n|sse| no|re |art|r p|rar|u p|inc|lei|cas|ico|u\xE9m|gu\xE9|ngu|nin| ni|gur|la |pen|n\xE7a|na |i\xE7\xE3|i\xE3o|cie|ist|sem|ta |ele|e f|om |tro| ao|rel|m a|s s|tar|eda|ied|uni|e m|s i|a f|ias| cu| ac|r a|\xE1 a|rem|ei |omo|rec|for|s f|esc|ant|\xE0 s| vi|o q|ver|a u|nda|und|fun",
    ind: "an |ang|ng | da|ak | pe|ata| se| ke| me|dan| di| be|ber|kan|ran|hak|per|yan| ya|nga|nya|gan| at|ara| ha|eng|asa|ora|men|n p|n k|erh|rha|n d|ya |ap |at |as |tan|n b|ala|a d| or|a s|san|tas|eti|uk |pen|g b|set|ntu|n y|tia|iap|k m|eba|aan| un|n s|tuk|k a|p o|am |lam| ma|unt| de|ter|bas|beb|dak|end|i d|pun|mem|tau|dal|ama|keb|aka|ika|n m| ba|di |ma | sa|den|au |nda|n h|eri| ti|ela|k d|un |n a|ebe|ana|ah |ra |ida|uka| te|al |ada|ri |ole|tid|ngg|lak|leh|dap|a p|dil|g d|ena|eh |gar|na |ert|apa|um |tu |atu|a m|sam|ila|har|n t|asi|ban|erl|t d|bat|uat|ta |lan|adi|h d|neg| ne|kum|mas|nan|pat|aha| in|l d|emp|sem|rus|sua|ser|uan|era|ari|erb|kat|man|a b|g s|rta|ai |nny|n u|ung|ndi|han|uku|huk| hu|sa |ers|in | la|ka | su|ann|car|kes|aku|dip|i s|a a|erk|n i|lai|rga|aru|k h|i m|rka|a u|us |nak|emb|gga|nta|iba| pu|ind|s p|ent|mel|ina|min|ian|dar|ni |rma|lua|rik|ndu|lin|sia|rbu|g p|k s|da |aya|ese|u d|ega|nas|ar |ipe|yar|sya|ik |aga| ta|ain|ua |arg|uar|iny|pem|ut |si |dun|eor|seo|rak|ngs|ami|kel|ini|g t|dik|mer|emu|aks|rat|uru|ewa|il |enu|any|kep|pel|asu|rli|ia |dir|jam|mba|mat|pan|g m|ses|sar|das|kuk|bol|ili|u k|gsa|u p|a k|ern|ant|raa|t p|ema|mua|idi|did|t s|i k|rin|erm|esu|ger|elu|nja|enj|ga |dit",
    fra: " de|es |de |ion|nt |tio|et |ne |on | et|ent|le |oit|e d| la|e p|la |it | \xE0 |t d|roi|dro| dr| le|t\xE9 |e s|ati|te |re | to|s d|men|tou|e l|ns | pe| co|son|que| au| so|e a|onn|out| un| qu| sa| pr|ute|eme| l\u2019|t \xE0| a |e e|con|des| pa|ue |ers|e c| li|a d|per|ont|s e|t l|les|ts |tre|s l|ant| ou|cti|rso|ou |ce |ux |\xE0 l|nne|ons|it\xE9|en |un | en|er |une|n d|sa |lle| in|nte|e t| se|lib|res|a l|ire| d\u2019| re|\xE9 d|nat|iqu|ur |r l|t a|s s|aux|par|nal|a p|ans|dan|qui|t p| d\xE9|pro|s p|air| ne| fo|ert|s a|nce|au |ui |ect|du |ond|ale|lit| po|san| ch|\xE9s | na|us |com|our|ali|tra| ce|al |e o|e n|rt\xE9|ber|ibe|tes|r d|e r|its| di|\xEAtr|pou|\xE9t\xE9|s c|\xE0 u|ell|int|fon|oci|soc|ut |ter| da|aut|ien|rai| do|iss|s n| ma|bli|ge |est|s o| du|ona|n p|pri|rs |\xE9ga| \xEAt|ous|ens|ar |age|s t| su|cia|u d|cun|rat| es|ir |n c|e m| \xE9t|t \xEA|a c| ac|ote|n t|ein| tr|a s|ndi|e q|sur|\xE9e |ser|l n| pl|anc|lig|t s|n e|s i|t e| \xE9g|ain|omm|act|ntr|tec|gal|ul | nu| vi|me |nda|ind|soi|st | te|pay|tat|era|il |rel|n a|dis|n s|pr\xE9|peu|rit|\xE9 e|t \xE9|bre|sen|ill|l\u2019a|d\u2019a| mo|ass|lic|art| pu|abl|nta|t c|rot| on| lo|ure|l\u2019e|ava|ten|nul|ivi|t i|ess|ys |ays| fa|ine|eur|r\xE9s|cla|t\xE9s|oir|eut|e f|utr|doi|ibr|ais|ins|\xE9ra|\u2019en|i\xE9t|l e|s \xE9|nt\xE9| r\xE9|ssi| as|nse|ces|\xE9 a",
    deu: "en |er |der|ein| un|nd |und|ung|cht|ich| de|sch|ng | ge|ine|ech|gen|rec|che|ie | re|eit| au|ht |die| di| ha|ch | da|ver| zu|lic|t d|in |auf| ei| in| be|hen|nde|n d|uf |ede| ve|it |ten|n s|sei|at |jed| je| se|and|rei|s r|den|ter|ne |hat|t a|r h|zu |das|ode| od|as |es | an|fre|nge| we|n u|run| fr|ere|e u|lle|ner|nte|hei|ese| so|rde|wer|ige| al|ers|n g|hte|d d| st|n j|lei|all|n a|nen|ege|ent|bei|g d|erd|t u|ren|nsc|chu| gr|kei|ens|le |ben|aft|haf|cha|tli|ges|e s| si|men| vo|lun|em |r s|ion|te |len|gru|gun|tig|unt|uch|spr|n e|ft |ei |e f| wi| sc|r d|n n|geh|r g|dar|sta|erk| er|r e|sen|eic|gle| gl|lie|e e|tz |fen|n i|nie|f g|t w|des|chl|ite|ihe|eih|ies|ruc|st |ist|n w|h a|n z|e a| ni|ang|rf |arf|gem|ale|ati|on |he |t s|ach| na|end|n o|pru|ans|sse|ern|aat|taa|ehe|e d|hli|hre|int|tio|her|nsp|de |mei| ar|r a|ffe|e b|wie|erf|abe|hab|ndl|n v|sic|t i|han|ema|nat|ber|ied|geg|d s|nun|d f|ind| me|gke|igk|ie\xDF| fa|igu|hul|r v|dig|rch|urc|dur| du|utz|hut|tra|aus|alt|bes|str|ell|ste|ger|r o|esc|e g|rbe|arb|ohn|r b|mit|d g|r w|ntl|sow|n h|nne|etz|raf|dlu| ih|lte|man|iem|erh|eru| is|dem|lan|rt |son|isc|eli|rel|n r|e i|rli|r i| mi|e m|ild|bil| bi|eme| en|ins|f\xFCr| f\xFC|gel|\xF6ff| \xF6f|owi|ill|wil|e v|ric|f e",
    jav: "ng |an | ka|ang|ing|kan| sa|ak |lan| la|hak| pa| ha|ara|ne |abe| in|n k|ngg|ong|ane|nga|ant|won|uwo| an| uw|nin|ata|n u|en |ra |tan| da|ran|ana| ma|nth|ake|ben|beb|hi |ke |sab|nda| ng|adi|thi|nan|a k| ba|san|asa|ni |e h|e k|g k| ut|pan|awa| be|eba|gan|g p|dan| wa|bas|aka|dha|yan|sa |arb|man| di|wa |g d| na|g n|ban| tu|n s|ung|wen|g s|rbe|dar|dak|di |g u|ora|aya|be |ah |a s|eni| or|han|as | pr|a n|na |iya|a a|kar|at |a l|mar|uwe|duw|uta|und|n p|asi|pa | si|ala|n n| un|kab|oni|ya |i h|gar|g b|yat|tum|ta |n m|i k|apa|taw| li|ani| ke|al |ka |kal|ngk|ega| ne|nal|n i|g a|ggo|ina|we |ena|dad|iba|awi|aga|a p| ta|sar|adh|awe|and|uju|ind|min|sin|ndu|uwa|gge|n l|ggu|ngs|n b|a b|pra|iji|n a|ha | bi|kat|go | ku|e p|ron|kak|ngu|a u|gsa|war|nya|g t|pad|bis|k b|i w|ae |wae| nd|ali|a m|er |sak|e s|ku |liy|ama|i l|eh |isa|arg|n t|a d|kap|i s|ayo|gay| pe|ndh|bad|pri|neg|tow|uto|eda|bed|il |ih | ik|ur |k k|rta|art|i p|rga|lak|ami|ro |aro|yom|r k|e d|a w|kon|rib|eng|ger|g l|ras|dil| ti|k l|rap|mra|uma| pi|k h|n d|gaw|wat|ga |k n|ar |per| we|oma|k p|jro|ajr|saj|ase|ini|ken|saw|ona|nas|kas|h k|i t| um|tin|wo | me|aba|rak|pag|yar|sya|t k| te| mu|ngl| ni|i b|men|ate|a i|aku|ebu|a t| du|g m|owo|mat| lu|amp",
    vie: "ng |\u0323c |\u0301c | qu|a\u0300 | th|nh | ng|\u0323i |\u0300n |va\u0300| va| nh|uy\xEA| ph|quy| ca|\xEA\u0300n|y\xEA\u0300|\u0300nh|\u0300i |\u0323t | ch|o\u0301 | tr|ng\u01B0|i n| gi|g\u01B0\u01A1|\u01A1\u0300i|\u01B0\u01A1\u0300|\u0301t | co|\u01B0\u01A1\u0323| cu|a\u0301c|\u01B0\u0323 |\u01A1\u0323c| kh| \u0111\u01B0|\u0111\u01B0\u01A1| t\u01B0|co\u0301| ha|\xF4ng|c t| \u0111\xEA|n t|i \u0111|i\u0300n|\u0300u |ca\u0301|gia|\u0301i |o\u0323i|mo\u0323| mo|\xEA\u0300u|i\xEA\u0323|\u0111\xEA\u0300|u c|nh\u01B0|pha| ba| bi|\xE2\u0301t|\u0309a |u\u0309a|cu\u0309|h\xF4n| \u0111\xF4|g t|\u0301 q|\u0303ng| ti|t\u01B0\u0323|t c|\u0323n | la|n \u0111|n c|n n|hi\xEA|ch |ay |hay| vi|\xE2n | \u0111i| na|ba\u0309| ho|do | do| t\xF4| hi|\xF4\u0323i|ha\u0301|i\u0323 |na\u0300|\u0300 t|\u01A1\u0301i|h\xE2n| m\xF4|\u0301p |a\u0300n|\u0323 d|\u0301ch|\u0323p |\u0300o |a\u0300o|kh\xF4|\u0301n |\xF4\u0323t|m\xF4\u0323| h\xF4|ia |\xF4\u0301c|c h|h\u01B0\u0303|i v|g n|\u0301ng|u\xF4\u0301|qu\xF4|h t|\xF4n |\xEAn |n v|nh\xE2|\u0323 t| b\xE2|i c|g v|\u0309ng|i\xEA\u0301|c c|\xE2\u0323t|th\u01B0|h\u01B0 |\u01B0\u01A1\u0301|\u0309n | v\u01A1| c\xF4|c \u0111| \u0111o| s\u01B0|t t|\xF4\u0323c|\u01B0\u0303n|v\u01A1\u0301| v\xEA|a\u0309 |\u0323ng|g \u0111|\u0309o |a\u0309o|u\xE2\u0323| \u0111a|bi\u0323|la\u0300|s\u01B0\u0323|b\xE2\u0301|ha\u0300|h\xF4\u0323|i t|a\u0309n|h\u01B0\u01A1|\u0300ng|tro|\u0309m |o v| mi|\xEA\u0309 |u\u0323c|i h|\u01B0\u0301c|a\u0301p|g c|\u0303 h|ia\u0301|n b|\u0309i |a m|h c|c\xF4n|\xEA\u0323n|\u01A1\u0301c|ha\u0323|\u0111\xF4\u0323| du| c\u01B0|a c|n h|tha|a\u0303 | xa|\u0301o |a\u0301o|i\u0301n|\u0300y |g b| h\u01B0|g h|ong|ron|\u0300 c|cho|\u0300 n|mi\u0300|\u01B0\u0323c|h v|c b| lu|i b|\xEA\u0323 |ai |\xEA\u0301 |\u0323 c|xa\u0303|kha|c q|i\xEA\u0309|t\xF4\u0323|\xF4\u0301i|\u0111\xF4\u0301|a\u0301 |hoa|o h|h \u0111|ca\u0309|n l|ho\u0323|ti\xEA|y t|\u0309 c|a\u0323i|a\u0301n|\u0300 \u0111|oa\u0300|y \u0111|chi|\u0309 n|ph\xE2|\xEA\u0300 |thu|i\xEAn|du\u0323|o c|i m|lu\xE2|c p|\xF4\u0301n|c l|\u0301 c|u\u0303n|cu\u0303|c g|c n|qua|n g|c m|o n|a\u0309i|ha\u0309|\u0301 t|ho |v\xEA\u0300| t\xE2| h\u01A1|o t|\u01A1\u0309 |h\u01B0\u0301|hi\u0300|vi\xEA|\u0300m |\u0309 t|\u0111o\u0301|th\xF4|\u01B0\u0301 |c\u01B0\u0301|hi\u0301|\u0301nh|a\u0300y|\u01A1\u0309n|\u01B0\u01A1\u0309| b\u0103|tri| ta|m v|c v|\u01A1\u0323p|h\u01A1\u0323|h m| n\u01B0|\xEA\u0301t|thi|\u0103\u0323c|ngh|uy ",
    ita: " di|to | in|ion|la | de|di |re |e d|ne | e |zio|rit|a d|one|o d|ni |le |lla|itt|ess| al|iri|dir|tto|ent|ell|i i|del|ndi|ere|ind|o a| co|te |t\xE0 |ti |a s|uo |e e|gni|azi| pr|idu|ivi|duo|vid|div|ogn| og| es|i e| ha|all|ale|nte|e a|men|ser| su| ne|e l|za |i d|per|a p|ha | pe| un|con|no |sse|li |e i| o | so| li| la|pro|ia |o i|e p|o s|i s|in |ato|o h|na |e s|a l|e o|nza|ali|tti|o p|ta |so |ber|ibe|lib|o e|un | a | ri|ua |il | il|nto|pri|el | po|una|are|ame| qu|a c|ro |oni|nel|e n| ad|ual|gli|sua|ond| re|a a|i c|ri |o o|sta|ita|i o| le|ad |i a|ers|enz|ssi|\xE0 e|it\xE0|gua|i p|e c|io | pa|ter|soc|nal|ona|naz|ist|cia|rso|ver|a e|i r|tat|lle|sia| si|rio|tra|che| se|rt\xE0|ert|anz|eri|tut|\xE0 d|he | da|al |ant|qua|on |ari|o c| st|oci|er |dis|tri|si |ed | ed|ono| tu|ei |dei|uzi|com|att|a n|opr|rop|par|nes|i l|zza|ese|res|ien|son| eg|n c|ont|nti|pos|int|ico|r\xE0 |sun|ial|lit|sen|pre|tta|dev|nit|era|eve|ll |l i| l |nda|ina|non| no|o n|ria|str|d a|art|se |ssu|ica|raz|ett|sci|gio|ati|egu| na|i u|utt|ve | ma|do |e r|ssa|sa |a f|n p|fon| ch|d u|rim| fo|a t| sc|tr\xE0|otr|pot|n i| cu|l p|ra |ezz|a o|ini|sso|dic|ltr|uni|cie| ra|i n|ruz|tru|ste| is|der|l m|a r|pie|lia|est|dal|nta| at|tal|ntr| pu|nno|ann|ten|vit|a v",
    tur: " ve| ha|ve |ir |ler|hak| he|her|in |lar|r h|bir|ya |er |ak |kk\u0131|akk|eti| ka| bi|eya|an |eri|iye|yet|ara|ek | ol|de |vey|\u0131n |\u0131r |nda|ar\u0131|esi|\u0131n\u0131|d\u0131r| ta|tle|e h|as\u0131|etl|e k| va|\u0131 v|s\u0131n|ile|ne |rke|erk|ard|ine| sa|\u0131nd|ini|k h|k\u0131n|ama|le |tin|rd\u0131|var|a v| me|e m|na |sin|ere|k v| \u015Fa| bu|lan|kes|dir|rin|dan| ma|k\u0131 |mak|\u015Fah|da | te|mek| ge|n\u0131 | hi|nin|en |n h| se|lik|rle|ana|lma|e a|\u0131 h|r \u015F|ill|si | de|aya|zdi|izd|aiz|hai|ret|hi\xE7|\u0131na| i\u015F|e b| ba|kla|et | h\xFC|r\u0131n|n k|ola|nma|e t| ya|eme|riy|n v|e i|a h|li |mil|eli|ket|ik |kar|irl|h\xFCr|im |evl|mes|e d|ahs|ma |rak|ala|let|lle|un | ed|rri|\xFCrr|bu | mi|i v|dil| il| e\u015F|n i|la |el |mal| m\xFC| ko|e g|se | ki|mas|lek|mle|mem|n b|ili|e e|ser| i\xE7|n s|din| di|es |mel|eke|tir|\u015Fit|e\u015Fi|r b|akl|yla|n m|len| ke|edi|oru|nde|re |ele|ni |t\xFCr|a k|eye|\u0131k |ken|u\u011Fu| uy|eml|erd|ede|ame| g\xF6|e s|i m|tim|i b|rde|r\u015F\u0131|ar\u015F|a s|it |t v|siy|ar |rme|est|bes|rbe|erb|te |al\u0131| an|ndi|end|hs\u0131|unm|r\u0131 |kor|n\u0131n| ce|maz|mse|ims|kim|i\xE7 | ay|a m|lam|ri |s\u0131z|a b|ade|n t|nam|lme|ilm|k g|il |tme|etm|r v|e v|n e|\u011Fre|\xF6\u011Fr| \xF6\u011F|al |\u0131yl|olm|vle|\u015Fma|i s|ger|me | da|ind|lem|i o|may|cak|\xE7in|i\xE7i|nun|kan|ye |e y|r t|az |\xE7 k|ece|s\u0131 |eni| mu|ulu|und|den|lun| fa|\u015F\u0131 |ahi|l v|r a|san|kat| so|enm| ev|i\u015F ",
    pol: " pr|nie|pra| i |nia|ie |go |ani|raw|ia | po|ego| do|wie|iek|awo| ni|owi|ch |ek |do | ma|wo |a p|\u015Bci|ci |ej | cz| za| w |ych|o\u015Bc|rze|prz| ka|wa |eni| na| je|a\u017Cd|ka\u017C|ma |z\u0142o|cz\u0142|no\u015B|o d|\u0142ow|y c|dy |\u017Cdy|i p|wol| lu|ny |oln| wy|stw| wo|ub |lub|lno|rod|k m|twa|dzi|na | sw|rzy|aj\u0105|ecz|czn|sta| sp|owa|o p|spo|i w|kie|a w|zys|obo|est|neg|a\u0107 |mi |cze|e w|nyc|nic|jak| ja|wsz| z |jeg|wan|\u0144st|o s|a i|awa|e p|yst|pos|pow| r\xF3|o o|j\u0105c|ony|nej|owo|dow|\xF3w | ko|kol|aki|bez|rac|sze|iej| in|zen|pod|i i|ni | ro|cy |o w|zan|e\u0144s|no |zne|a s|lwi|olw|ez |odn|r\xF3w|odz|o u|ne |i n|i k|czy| be|acj|wob|inn| ob|\xF3wn|zie| ws|aln|orz|nik|o n|icz|zyn|\u0142ec|o\u0142e|po\u0142|aro|nar|a j|i z|t\u0119p|st\u0119|ien|cza|o z|ym |zec|ron|i l|ami| os|kra| kr|owe| od|ji |cji|mie|a z|bod|swo|dni|zes|e\u0142n|pe\u0142|iu |edn|iko|a n|raj| st|odo|zna|wyc|em |lni|szy|wia|nym|\u0105 p|j\u0105 |ze\u0144|iec|pie|st |jes| to|sob|kt\xF3|ale|y w|ieg|och|du |ini|war|zaw|nny|roz|i o|wej|i\u0119 |si\u0119| si|nau| or|o r|kor|e s|pop|zas|niu|z p|owy|w k|ywa| ta|ymi|hro|chr| oc|jed|ki |o t|ogo|oby|ran|any|oso|a o|t\xF3r| kt|w z|dne|to |tan|h i|nan|ejs|ada|a k|iem|aw |h p|wni|ucz|ora|a d| w\u0142|ian| dz| mo|e m|awi|\u0107 s|gan|zez|mu |taw|dst|wi\u0105|w c|y p|kow|o j|i m|y s|bow|kog|by |j o|ier|mow|sza|b o|ju |yna",
    swh: "a k| ya|na |wa |ya | ku|a m| na| ha|i y| wa|a h|a n|ana|aki|ki |la |hak| ka|kwa|tu | kw| ma|li |a a|ila|i k| ki|ni |a w|ali|a u| an| mt|ke |mtu|a y|ake|ati|kil|ka |ika|kat|ili|te |ote|we |a s|e k|ia |zi |u a|za |azi|ifa|ma |yak|yo |i n|ama| yo|au | au|e a|kut|amb|o y|ha |asi|fa |u w|hal|ara|sha|ish|ata|ayo| as|tik|u k| za|i z|ina|u n|mba|uhu|hi |hur|cha|yot|ru |uru|wat| ch|eri|ngi|e y|u y|i a|aif|tai| sh|nay|chi|ra |ani| bi| uh|sa | hi|i h|awa|iwa|a j|ti |mu |o k|ja |kan|uli|iwe|any|i w| am|e n|end|atu|kaz|o h|ria|her|she|shi|nch| nc|uta|ye |wak|ii |ele|ami|adh|eza| wo|iki|oja|moj|jam| ja|aka|bu |kam|kul|mat|fan|a l|agu|ind|ne |iri|lim|wen|da |kup|uto|i m|a b|ini|wan|bil| ta|sta|dha| sa| ni|ao | hu|e w|wot| zi|rik|kuf|aji|ta |wez|nya|har| ye|e m|si |lin| ut|ine|gin|ing| la|a t|zim|imu|ima|tak|e b|uni|ibu|azo|kos|yan|nye|uba|ari|ahi|nde|asa|ri |ham|dhi|eli|hir|ush|pat| nd|kus|maa|di |nda|oa |bar|bo |mbo|oka|tok|ndw|ala|wal| si|uzi|hii|tah|i s|o n|liw| el|upa|zin|hag|a c|ndi|ais|mai|eny|mwe|aa |ewe| al|ndo|e h|lo |umi|kuh|jib|osa|mam|a z|ufu|dwa|u i| in|iyo|nyi| ny|u m|sil|ang|o w|guz|zwa|uwa|kuw|hil|saw|uch|ufa|laz|und|aha|ua | mw|bal| lo|o l|a i|del|nun|anu|nji| ba|lik|le |uku|i i",
    sun: "an |na |eun|ng | ka|ana| sa| di|ang|ung|un |nga|ak | ha|keu| ba|a b| an|nu |hak| bo|anu|ata|nan|a h|ina| je|aha|ga |ah |awa|jeu| na|ara|ing|oga|bog|gan| ng|asa|kan|a s|ha |ae |bae|n k|a k| pa|a p|sah|g s|sar| si|sin|a n|din|n s|ma | at|aga|a a|tan| ku| ma|n a|san|man|wa |lah|pan|taw|u d|ra |ari|eu | pi|gar| pe|kat| te|n p|sa |per|a d|a m|e b|aan|ban|ran|ala|ike|n n|kum| ti|ama|a j|pik|ima|n d|al |at | ja|ila|ta |nda|bas|rim|teu|n b|eba|beb|udu|aya|ika|ngg|nag|kab|rta|art| me|ola|k n|uma|atu|aba|g k|adi|aca| po|ngt|nar|una|ate|oh |boh|awe|di |tin|asi|uku|n h|dan|aka|iba|car|sac|gaw|are|ent|um |jen|abe|u s|dil|pol|ar |ku |kud|u m|upa|han| hu|ake|bar|ur |hna|aru|h s|a t|sak|wat|kaw| so|n t|pa |mpa|du |ngk|g d|ena|huk| mi|mas|ngs|ti |n j|ka |aku|ren|n m| ta|law|isa| tu|und|a u|h a|tay|ula|aja|ali|nte|gsa|en |gam| wa|ieu|ere|k h|jal|h b|il |dit|ngu|lan|asu|yun|ayu|gta|k d|a r|g n|mah|uda|dip|kas|rup|geu| be|ter|sej|min|ri |ern|u p|k k|amp|ura|kal|e a|k a|ut |g b|nak|bis| bi|k p|tes|end|we |h k|tun|uan| un| de|u n|h t|ksa|u k|ian|wil|u b|ona|nas|uka|rak|eje| se|ami| ke|war| ra| ie|k j|eh |ya |lma|alm|pen|tur|wan|lak|h j|g a|ean|up |rga|arg|r k|u t| ne|deu|gal|gke|e t|h p| ge|g t| da|i n",
    ron: " de|re | \xEEn|\u0219i |are|de | \u0219i|te |ul | sa|rep|e d|ea |ept|dre|tul|e a| dr|ie |\xEEn |ptu|le |ate|la |e p| la| pe|ori| pr|ce |e s| or|au |tat| ar|ice|ii |or |a s| fi| a |ric|ale|per| co|n\u0103 |\u0103 a|rea|ers|i s| li|sau| ca|rso|ent|lor|a\u021Bi|al |a d|e o|men|l l|ei |e c|pri|an\u0103| ac| re|uri|ber|ibe|lib|a p|oan|soa| in|i l|ter| al| s\u0103|tea|l\u0103 |car|t\u0103\u021B|s\u0103 |tur|i a|i d|nal| ni|ri |ita|e \xEE|e \u0219|se |ilo|in |ia |\u021Bie|pre|fie|\u021Bii|\u0103\u021Bi|con|ere|e f|a o|eni|nte| nu| se|ace|ire|ici| cu|i \xEE|a c|i n|a l|pen|ui |nu |\u0103ri|al\u0103|ona|l d|r\u0103 |ert|ril| su|ntr|n c|rin| as|ni |i o|eri|t\u0103 |c\u0103 |ile|\u0103 d|i c|e n|ele|sa | mo|i p|fi |sal|tor|va |oci|soc|nic|pro| un| tr|est|in\u021B|a \xEE|uni|n m|a a| di|ecu|lui|sta|lit| po|tre|gal|ega|oat|ra |act|\u0103 \xEE|leg|u d|e l|nde|int|a f|n a| so|na\u021B|ara|i f|uie|iun| to|tar|ste|ces|rar|at | ce|eme|i \u0219|rec|dep| c\u0103| o | \xEEm|bui|ebu|reb| eg| na|m\xE2n|ntu|ili|v\u0103\u021B|\xE2nd|iei|r \u0219|bil|pli|od |mod|res|din|e e|c\u021Bi| au|ali|\u0103 p|\u0103 f|\xEEmp|ial|cia|ion|\u0103 c|dec|nta| om|it\u0103| fa|\u021B\u0103 |cu |tra|\u0103\u021B\u0103|nv\u0103|\xEEnv|\xE2t |ite|i i|lic| pu| ex|riv|tri|rot|\u021Ba |\u021Bi |l c|rta|imi|ulu|\u021Bio|ic\u0103|lig|rel|ta |cla|t \xEE|nt |nit|e m|\xE2nt|\u0103m\xE2|\u021B\u0103m|ger|n\u021Ba|ru |tru|gur|u c|bli|abi|at\u0103|art|par|ar |rim|iva|l \u0219| sc|ime|nim|era|sup|ind|u a|dic|ic | st| va|ini|igi|e r",
    hau: "da | da|in |a k|ya |a d| ya|an |a a| ko| wa|na | a |sa | ha|kin|wan|ta | ba|a s| ta|a y|a h|wa |ko | na|n d|a t|ba |ma |n a| ma|iya|hak|asa| sa|ar |ata|yan| za|akk|a w|ama| ka|i d|iki|a m|owa|a b| ci| mu| sh|anc|nci|kow|a z|ai |nsa|a c|shi| \u0199a|cik|ne |ana|i k|ci |kki|e d|a \u0199| ku|su |n y|uma|ka |uwa|kum|hi |a n|utu| yi|ani| ga| ra|aka|ali|mut|\u2018ya|tar| do|\u0257an|ars| \u2018y|sam|\u0199as|nda|ane|man|tum|i a|yi |ni | du|ada| su|and|a g|cin| ad|a i|ke | \u0257a|n k|yin|um |e m| ab|ins|nan|ki |mi |ami|yar|min|oka|re |i b|kam|mas|i y|mat|za |ann|en |a\u0257a| ja|m n|li |duk|dai|e s|n s|ra |n w|n h|aik| ai|ida|ga |san|rsa|aba|sar|ce |nin| la|o n|ban|nna|kan|abi|una|dam|me |ara|i m|hal|a r|add|are|n j|abu| ne|zai|a \u0257|wat|ari| \u0199u|on |ans|wa\u0257|ame|ake|kar|din|zam| fa|a l|\u0199un|buw|r d| hu|oki|kok|a \u2018|u d|n t|abb|aur| id|rin|yak|dok|kiy|ray|jam|n b|ubu|bub|n m|i s| an|am |ili|bba|omi|dan|gam|ayu|ash|nce|tsa|ayi|har|yya|ika|bin|han|kko|rsu|aif|imi|fa | am|i i|dom| ki|yuw|dun|o a|fan|n \u0199|aya|fi |n r|she|uni|bay|riy|n \u2018|sab| iy|bat|tab|aga| ir|mar|o w|i w|sha|awa| ak|uns|unc|tun|u k| il|\u0257in|mfa|amf|aci|ewa|kas|lin|n n|don|n i|ure|ifi|lai|dda| ts|iri|aye|un |tan|wad|gwa|afi| ay|ace|mba|amb|aid|nta|ant|war|lim|kya| al|a\u0257i",
    fuv: "de | e |e n| ha|nde|la | wa|ina| ka|akk| nd|\u0257o |na | in|e e|hak|al |di |i h|kke|ii |um |ko |ala|ndi| mu| ne|lla| jo|wal|e\u0257\u0257|ne\u0257|all|mum| fo|kal|jog|ke |aaw|taa| ko|eed|\u0257\u0257o|aa | le|ji |ade|aad|laa|o k| ng|e h| ta|re |ogi|a j|e w|e m|nnd|gii|e l|ley|awa|aag|ede|waa|e k|gu |e d| go|gal|\u0253e |ti |fot|aan|eyd|ydi|\u0257e |ee | re|ol |oto|i e|oti|m e|taw|nga|a i|kee|to |ann|eji|am |ni | wo|een|goo|eej|e f| he|enn|gol|agu|pot| po|dee|ay | fa|ka |a k|ond|oot| de|a f|o f|a n|wa |maa|ota|le |hay|i k|o n|ngo|e j|o t| ja|\xF1aa|hee|nka|i w|awi|a w|ngu|der| to|e t|dim|i n|fof|i f|e g|tee|naa|aak| do|too|a e|ndo|ren|dii|oor|er |o e|i m|of | sa| so|gaa|ani|kam| ma| \xF1a|o w|i l|u m|kaa|ima|dir| ba|igg|lig| li|aar| \u0253e|o i|e s| o |e r|so |ooj| nj| la|won|awo|dow|woo|faw|and|e i|ore|nge|nan|are|a t|tin|aam| mo|\u0257ee|ita|ira|aa\u0257|e p|nng|ma |ank|yan|nda|oo |e \u0253|njo|ude|nee|e y|e a|je | ya|en |ine|iin| di|ral| na|\u0257i |und| hu|inn|\u014Bde|a\u014Bd|ja\u014B|a d|den| fe| te|go | su|a h|haa|tal|e\u0257e|e b|y g|baa|tde| yi|\u0257\u0257a|o h|ii\u0257|ow | da|do |l n|alt| ho|l e|aga|mii| aa|a a|ama|nna|m t| ke|edd|oga|m w|l m|o j|a\u0257e|ree|oje|yee| no|ele|ne |ago| pa| al|guu|wi |ge |aa\u0253|daa|ind|dew|i j|jey| je|ent|tan|o \u0257|ge\u0257| ge|\xF1ee|a l| \u0257u|kko|mak|a s| ga",
    bos: " pr| i |je |rav|na |ma |pra| na|ima| sv|a s|da |a p|vo |nje|ko |ako|anj|o i| po|avo|ja |e s|a i|ti | im| da| u |sva|no |ju | za|o n|va |i p|ili|vak|li | ko|ne | il|koj| ne|nja| dr|ost| sl|van|im |i s|u s|i i|a n|ava|ije|a u| bi|stv|se |a d|om |jed|bod|obo|lob|slo| se| ra|ih |sti| ob| je|pri|enj|dru|u i|o d|iti|voj|raz|ova|dje| os|e i|lo |e p| nj|uje|i d|bra|tre| tr| su|jeg|i n|u z|a k|og |u p|oje|cij|reb|a o|a b|lju|i u|ran|mij|ni |nos|jen|ba |edn|svo| iz|jel|pro|e d|\u017Eav|bit| ni|i o|sta|a z|avn|vje| ka|bil|ovo|a j|aju|ist|nih|tu |red|gov| od|e o|oji| sm|lje|o k|ilo|ji |aci|e u|e n|pre|o p|eba|u o|su |vim|i\u010Dn| sa|u n| dj|a t|ija|\u010Dno|jem|r\u017Ea|dr\u017E|elj|stu|dna|odn|eni|za |iva|olj|\u0161ti|nom|em |du |vno|smi|jer|e b|de |pos|m i| do|u d|nak|a r|obr| mo|lja|nim|ego| kr|tit|kri|ve |nju|an |iko|nik|nu |i m|nog|eno|sno| st|e k|tup|rug|ka |oda|riv|vol|aln|m s|itu|a\u0161t|za\u0161|ani|sam|akv|ovi|osn|rod|aro| mi|tva|dno|nst|jan|ak |ite|vi\u010D|rad|u m| ta|dst|tiv|nac|rim|kon|ku |odu|\u017Eiv|amo|tvo|tel|pod|g p|nov|ina|nar| vj|o s|i b|oj | ov|ave|vu |ans|oja|zov|azo|ude|bud| bu|e t|i v|din|edi|nic|tan|nap|mje| is|jal|slu|pun|eds|o o|zak|jav|i k|m p|tno|ivo|ere|ni\u010D|m n|jim|kak|ada|vni|ugi| ro|mov|ven|pol|to |te | vr",
    hrv: " pr| i |ma |rav|ima|pra|je |na | sv|ti | na|a p|vo |vat|ko |a s|nje| po|anj|avo|o i|tko| im|a i|sva|no |i p|e s|ja |o n| za|ju |ili| u |va |li | bi|ne |i s|atk| il|iti|da | ne| ko| dr| sl|van|nja|koj|ije| ra|ova| os|u s|i i|ost|bod|obo|lob|slo|pri|a n|om |jed|ati|ih |im |voj|ava| ob|stv|se | mo|i u|bit|dru| je| se|dje|i o|enj| ka|i n|sti|lo |u i|svo|mij|ni |e i|raz|a o|e n|bra|o p| su|a b|u p|ran|a k|og |i d|bil|ako|e p|a d|edn|aju|mor|eni| nj|iva|jel|\u017Eav| ni|a z|avn|ovi|eno|ra |oje|a j| da|a u|ora|jeg| iz|nih|r\u017Ea|dr\u017E|oji|sno|nit|jen|vje|ilo|cij|oda|nim| dj|pro|tit|u z|e d|red|nom|jem| od|nos|sta|nov|osn| sm|lje|o s|ji |ovo|stu|pos|vim| do|odn|rad|ist| sa|e o|tu |nju|em |gov|o d|rod|i m|jer|aci|oj |pre|m i|nak|dna|a r|lju|uje|e m|obr|za |olj|ve |o o|m s|an |nu |du |aro|vno|smi|aln|e k|o k|i b|e u|tva|u u|tup|rug|dno|u o|su |u d|ka |vol| ta|ija|itu|\u0161ti|a\u0161t|za\u0161|itk|\u017Eiv|ani|sam|elj| st|sob|oso|nar|akv|ada| mi|te |ona|nst|jan|lja|i v|ite|ego|elo|rim|ku |odu|amo|tvo|tel|jim|pod|nog|vi |ina| vj|to |e b|ans|zov|azo|ak | sk|edi|tan|oju|pun|pot|oti|kon|zak|i k|m p|tno|ivo|ere|ni\u010D|kak|vni|ugi| ro|mov|ven|\u0161tv| be|ara|kla|ave|u b|avi|oja|jal|u m|dni|mje|rak|din|\u0107i |ju\u010D|klj|nic|u k|nap|obi|atn",
    nld: "en |an |de | de| he|ing|cht| en|der|van| va|ng |een|et |ech| ge| ee|n e|rec| re|n v|n d|nde|ver| be|er |ede|den| op|het|n i| te|lij|gen|zij| zi|ht |ijk|eli| in|t o| ve|op |and|ten|ke |ijn|e v|jn |ied| on|eft| ie|sch|n z|n o|aan|ft |eid|te |oor| we|ond|eef|ere|hee|id |in |rde|n w|t r|aar|rij|ord|wor|ens|of | of|hei|n g| vr| vo| aa|r h|hte| wo|n h|al |nd |vri|e o|ren|le |or |n a|jke|lle|eni|n b|ij |e e|g v| st|ige|die|e g|men|nge|t h|e b| za|e s|om |t e|ati|wel|erk|sta|ers| al| om|n t|zal|dig| me|ste|voo|ter|gin|re |ege|ge |g e|bes|nat| na|eke|che|ig |gel|nie|nst|e a|nig|est|e w|erw|r d|end|ona|d v|jhe|ijh|d e|ele| di|ie | do|del|n n|at |it | da|tie|e r|elk|ich|jk |vol|ijd|tel|min|len|str|lin|n s|per|t d|han| zo|hap|cha|wet| to|ven| ni|aat|ion|tio|taa|lke|eze|met|ard|waa|uit|sti|e n|doo|pen|eve|el |toe|ale|ien|ach|st |ns | wa|eme|nin|e d|bij| gr|n m|p v|esc|t w|ont|ite|man|ema| ma|nal|g o|rin|hed|t a|t v|beg|all|ijs|wij|rwi|e h| bi|gro|p d|rmi|erm|her|oon| pe|eit|kin|t z|iet|iem|e i|gem|igi| an|d o|r e|ete|e m|js | hu|oep|g z|edi|arb|zen|tin|ron|daa|teg|g t|raf|tra|eri|soo|nsc|t b| er|lan| la|ern|ar |lit|zon|d z|ze |dez|eho|d m|tig|loo|mee|ger|ali|gev|ije|ezi|gez|nli|l v|tij|eer| ar",
    srp: " pr| i |rav|na |pra| na|ma | sv|ima|da |ja |a p|vo |je |ko |ti |avo| po|a i|ako|a s| za| u |ju |o i| im|nje|i p|va |sva|anj|vak| da|o n|nja|e s|ost| ko|a n|li |ili|ne |om | ne|i s| sl| il| dr|no |koj|u s|ava| ra|og |slo|im |enj|sti|bod|obo|lob|iti|a o|stv|i u|a d|ni |jed|u p|pri|edn| bi|i i|a k|o d|sta|ih |dru|a u| je| os| ni|nos|pro|aju|i o|ran| de| su|u i|se |van|ova|i d|cij| ob|uje|red|\u017Eav|e i|i n|voj|e p|a j|dna| se| od|ve | ka|eni|r\u017Ea|dr\u017E|a z|avn|aci|ovo|u u|m i|oja| iz|lja| nj|ija|u z|e o|rod|jen|lje|e b|raz|jan|lju|svo|za |gov|i\u010Dn| st|nov|sno|osn|du |ji |pre| tr|su |vu |odn|a b|jeg|nim|nih|tu |tit|\u0161ti|ku |nom|bit|e d|me |iko|\u010Dno|oji|lo |vno|nik|e n|\u0111en|ika|bez|ara|de |u o|vim|nak| sa|u n|riv|ave|an |olj|vol| kr|o p|sme|e k|nog| ov|e u|tva|bra|rug|reb|tre|u d|oda| mo| vr|vlj|avl|ego|jav|del|m s|kri|o k|a\u0161t|za\u0161|nju| sm|ani| li|dno|e\u0111u|aln|la |akv|oj |\u0161en|kom|stu|ugi|avi|a r|ka |rad|oju|tan|odi|vi\u010D|tav|itu|ude|bud| bu|pot|odu|\u017Eiv|ere|m n|tvo|ilo|bil|aro|ovi|por|eno|\u0161tv|nac|ove|m p|tup|pos|rem|dni|ba |nst|a t|ast|iva|e m|vre|nu |be\u0111|ist|pun|en |te |dst|rot|zak|ao |kao|i k|ju\u0107|o s|st |sam|ter|nar| me|i m|kol|e r|u\u0161t|ru\u0161|ver|kak| be|i b|kla|ada|eba|ena|ona| on|tvu|ans| do|rak|slu",
    ckb: " he| \xFB |\xEAn | bi| ma|na |in |maf| di|an |xwe| xw|ku | ku|kes| de| ji|her|kir|iya|ya |rin|iri|ji |bi |es | ne|ye |y\xEAn|e b|er |af\xEA|tin|ke | an|iy\xEA|eye|rke|erk|we | be|e h|de | we|hey|f\xEA |i b|y\xEA |ina| b\xEA| li|diy|ber|li |re |\xEE \xFB|n\xEA |\xEA d| se| ci|eke|di |w\xEE | na|\xEE y|af |ete|hem| w\xEE|sti| ki|r\xEE |k\xEE |\xEE a|yek|n d|kar| te|ne |y\xEE |i h|e k|t\xEE |t\xEA |a w|e d|\xEE b|s m|ast|n b|be |yan|ser|tew|net| tu| ew|hev|aza|ara|\xFB b|n k|adi|ev |zad| az|ras|est|an\xEA| ya|n h|n \xFB|wed| t\xEA|wek|bat|bo | bo| y\xEA|st |n n|\xEA k|dan|\xEA h|ema|\xEA b|iye|\xEE h|din|b\xFBn|r k|ek\xEE| me|par|\xFBna|ta |wle|ewl|\xEE m| ke|nav|ewe|man|\xEA t|d\xEE |\xFB m|m\xFB |em\xFB|a m|ika|e \xFB|n w|a x|\xEA m|e n| ta|ela|n j|ey\xEA|n x|civ|wey|ana| re|khe|ekh|bik|k\xEA |j\xEE |f h|er\xEE| pa|\xEEna|bin|erb|vak|iva|a s| ni|cih|v\xEA |e j|ari| p\xEA|\xEE d|n\xEAn|ike|e t|a k|\xEA x| ye|n a|ey\xEE|n e|ama|b\xEA |ar |ewa|at\xEA|bes|rbe|av |ibe|ist|m\xEE |tem|awa|are|h\xEE |geh|nge|ing|nek|n\xFBn|an\xFB|qan| qa|v\xEE |rti|uke|tuk| \u015Fe|eza| da|u d|\xFB a|f \xFB|edi| ra|tu |tiy|t\xEAn| mi|xeb| ge|h\xEEn| h\xEE|et\xEA|\xEE j|st\xEE|mal|bib|ra |i d|e m|mam|i a|nik|i m|\xEE k| wi|\xFBn | ko|a \u015F|\xEA j|riy|lat|wel|e e|ine|ane|\xFB h|\xEEn |a d|siy|end|aye| za|ija|a n|\xEE n|ek |tek|yet|mbe|emb|\xFB d|rov|iro|mir|eba| xe|m\xEAn| \xEAn| hu|n\xEEn|an\xEE|t \xFB|ten|n m|dem|\xEA \xFB|en\xEA|te |art|i r| j\xEE|u j|ek\xEA|dew",
    yor: " n\xED|ti |\u1ECD\u0301 |n\xED | l\xE1| \u1EB9\u0300|\xE0n |\u1EB9\u0301 |kan|t\xED | t\xED|an |\u1EB9\u0300 |t\u1ECD\u0301|\u1ECD\u0300 | \u1EB9n|\u1ECDn |w\u1ECDn|\xED \u1EB9|b\xED |\xE1ti|l\xE1t|\u0300t\u1ECD|\u1EB9\u0300t| gb| \xE0t| \xE0w|n l|\xE0ti| a |l\u1EB9\u0300|\u1EB9n\xEC| \xF3 |k\u1ECD\u0300| l\xF3|\xEC k|s\xED |\u1ECD\u0300k| k\u1ECD|ra |ni |\xE0b\xED|t\xE0b| t\xE0|n\xEC | s\xED|\u0300ka|\u1ECD\u0300\u1ECD|n \u1EB9|\xE0w\u1ECD|n t|\xF3 n|\u0300\u1ECD\u0300|\xEDl\u1EB9|or\xED|l\xF3 | w\u1ECD|t\xF3 |d\xE8 |\xECy\xE0|\xFAn | t\xF3| or|\xED \xEC|\xE8d\xE8|k\xF2 |\u2010\xE8d|\u0300\u2010\xE8|\u1EB9\u0300\u2010|r\xEDl|\xED \xF3|r\u1EB9\u0300|\xED \xE0| s\xEC|y\xE0n|gbo|\u1E63e | k\xF2|\xED a| r\u1EB9| j\u1EB9|s\xEC | b\xE1|r\xE0n| \u1E63e|w\u1ECD\u0301|n\xECy|f\xFAn| f\xFA|n \xE0|ba |n n|gb\xE0|gb\u1ECD|j\u1EB9\u0301|un |\xEC\xED | k\xED|gba|\xE8n\xEC| \xE8n|b\xE1 |\u0301 l|a k| ka|d\u1ECD\u0300|k\xED | \xF2m|in | fi|b\xF2 |fi |b\u1EB9\u0301|\u1ECDd\u1ECD|b\u1ECDd|\u0301 s|hun|n\xFA |n\xEDn|w\xE0 |ira|nir|\xF2m\xEC|\xECgb| \xECg|\u0301 t|\u1EB9ni|\xEDn\xFA|i l|\xECni|m\xECn|b\xE0 |\xE1\xE0 |i \xEC|ohu| oh|\xED i|ara| ti|bo |\xF2 l| p\xE9|r\xFA |\xEDr\xE0| \u1ECD\u0300|\xED \xF2|ogb|k\u1ECD\u0301|p\u1ECD\u0300|\xF3 b|\xE0 t|i n|l\u1ECD\u0301|\u1EB9\u0301n| \xECb|y\xEC\xED|gb\xE9|g\u1EB9\u0301|bog|\xF3\xF2 |y\xF3\xF2| y\xF3|n k|p\xE9 |d\xE1 |\u0301w\u1ECD|\u1ECD\u0301w|\xE0 l|\xED k| w\xE0|n o|j\u1ECD | ir|\u1ECD\u0300r|\xFA \xEC|\u0301 \xE0|\xF3 s|i t|\u1E63\u1EB9\u0301|\u0300k\u1ECD|\xED t|y\xE9 |l\xE8 | l\xE8|fin|\xE0b\xF2| l\u1ECD|\xE0 n|\xF9j\u1ECD|w\xF9j|ir\xFA|\xF3 j| ar|\xED w|a w| \xECm|\xFA \xE0|\u0300 t|\xF2fi| \xF2f| \xE0\xE0|f\u1EB9\u0301|\xE0w\xF9|\u0301ni|w\xF9 |\xEC\xEDr|m\xEC\xED| m\xEC|l\xE1\xEC| y\xEC|\xED g|\u1ECD\u0301n|n s|i \u1EB9|\u1EB9\u0300k|\xE0gb|\xEDgb|n\xEDg|a n| k\xFA|l\xE1\xE0|\xED o|n\xE1\xE0| n\xE1|k\u1EB9\u0301|\xEDpa|n\xEDp|\xECn | \xECk|b\xE9 |i g|\u1ECDm\u1ECD| \u1ECDm|i \xE0|i\u1E63\u1EB9|\u0300 \xE0|\xECm\u1ECD|n a|n f|j\u1EB9 |y\xED |\u0301 \u1ECD|\xF3 d|\u0301 \xF2| d\xE1| m\xFA|\xE0\xE0b|\xE1b\u1EB9|l\xE1b|\xECb\xE1|\xF2 g|j\xFA |i o|l\xFA | \xE8t|\u0300 \u1EB9|t\u1ECD\u0300|de |\u0300 n|i \xF2| \xECy|k\xE0n|\u0301n | b\xED| i\u1E63|m\u1ECD\u0300|e \u1EB9|\u0300 l| f\xE0|\xE8y\xED| \xE8y| \xECd|m\u1ECD\u0301|d\xE9 |\u0300 k|\u0301 p|\xF2 t|m\xFA | f\u1EB9| \xECj|r\xED |\xECk\u1EB9|n\xECk|\xECn\xED|n \xEC|n \xE8|s\xECn|\xE8 \u1EB9| i |r\u1ECD\u0300| \xE0n|\u0301 b|\xF9n |\u0301gb|\u1ECD\u0301g|d\u1ECD\u0301| d\u1ECD|\xED n|rin|\u0300 j",
    uzn: "ish|an |lar|ga |ir | bi|ar | va|da |iga| hu|va |bir|sh |uqu|quq|huq| ha|shi| bo|r b|gan|a e|ida| ta|ini|lis|adi|ng |dir|lik|iy |ili|o\u02BBl|har|ari| o\u02BB|uqi|ins|lan|hi |ing|dan|nin|kin| yo|son|nso| in| mu|on |qig| ma|ega|r i|bo\u02BB| eg|o\u02BBz|ni |gad|ash|i b|ki |oki|ila|yok|a b|n b|osh|ala|at |in |r h|erk| er|lga| qa|rki|h h| sh|i h|ara|n m| ba|nis|ik |igi|lig|bos|ri |qil|a t|bil|las|eti| et|n o|ani|nli|kla|i v|a q|a h|a o|yat| qo|im |a s|i m|iya|atl|oli|osi|siy|qla|cha|til| ol|ati|a y|mas|qar|inl|lat| qi|ta\u02BC|ham|gi |ib |\u02BBli|mla|h v|\u02BBz |hun|n e|mum| da| bu| to|un |mki|umk|sha|tla|ris|iro|ha |rch|bar|iri|oya|ali| be|i o|asi|aro| ke|i t|rla| te|arc|hda|shu|tis|n h|tga| sa| xa|rak|lin|ada|ola|imo|hqa|shq|li | tu|aml|lla|sid| as|nid|a i| ki|ch |n t|nda|k b|era|siz|or |hla|a m|r v|eng|ten|mat|mda|amd|lim|miy|y t|ayo|i a|ino|ilg|tni| is|ana|as |ema| em|ech|a a|tar|kat|aka|ak |rat| de|aza|ill| si| so|g\u02BBi|uql|n q|oda|\u02BCli|a\u02BCl|nik| ni|tda|uch|gin|a u|him|uni|sit|ay |qon| ja|atn|kim|h k|hec| he|\u02BBzi|lak|ker|ikl| ch|liy|lli|chi|ur |zar|shl|rig|irl|dam|koh|iko|a d|am |n v|rti|tib|yot|tal|chu| uc|sla|rin|sos|aso| un|na | ka|muh|dig|asl|lma|ra |bu |ush|xal|\u02BBlg|i k|ekl|r d|qat|aga|i q|oiy|mil| mi|qa |i s|jin",
    zlm: "an |ang| ke|ng | se| da|ada|ara|dan| pe|ran| be|ak |ber|hak|ata|ala|a s|ah |nya| me|da |per|n s|ya | di|kan|lah|n k|aan|gan|dal|pad|kep|a p|n d|erh|eba|nga|yan|rha| ya|nda|ora|tia|asa| ha|ama|epa| or|iap|ap |a b| at| ma|eti|ra |tau|n a|set|au | ba|pa | ad|n p|tan|p o|eng|a d|men|apa|h b|h d|dak|man|a a|ter| te|k k| sa|n b|ana|g a|end|leh|ole|a k|am |n y|aka|eh |lam|bas|beb|n m| un|pen|sa |keb|sam|n t| ti|ela|san|car|uan|ma |di |han|ega|ban|eri|at |sia|a m|ika|kes|ian|gar|seb|ta |mas|und|neg|nan|ngs|i d|erl|na |epe|emb|bar| la|atu|kla|pem|mem|emu|eca|sec|ngg|nny|any|bol|al |aha|gsa|ebe|ind|akl|n h|erk|ung|ena| bo|a t| ap|ers| de|in |tu |pun|as |agi|ann|g b|bag| ne|ain|hen| he|era|rat|sem| su|adi|lan|g s|dia|mat|ses|iad| ta|iha|g t|tin|k m|k h|i k|gi |i s|ing|uka|enu|den|lai|k d|ert|ti |rka|aja|rga|lua|ker|mel|dun|ndu|lin|rli|nak|ntu|esi|aya|un |uat|jua| in|rma|erm|ai |emp|kem|ri |dil|ua |uk |h m|l d|g m|mba|kat|ese|tik|ni |ini| an|mpu|ka |dar|mar|rja|erj|arg|u k|sua| ol|esa|dap|ar |g u|si |ent|g d| pu|awa|iri|dir|sal|gam|mbe|n i|har|a h|raa|ema|tar|i a|saa|ira|ari|pel|jar|laj|uju|tuj|rak|ura|uar|elu|t d|unt|il |wen|asi|gga|ipa|ksa|tuk|ula|sek|sas|ibu|rta|sep|rsa|nta|ati|ila|mua|yar",
    ibo: "a n|e n|ke | na| \u1ECD |na | b\u1EE5|\u1ECD b|nwe|nye|ere|re | n |ya |la | nk|ye | nw| ma|e \u1ECD| ya| ik|a o|a \u1ECD|ma |\u1EE5la|b\u1EE5l|ike| on|nke|e i|a m|ony|\u1EE5 n|kik|iki|b\u1EE5 | a |ka |wer|ta |i n|do |di | nd| ga|a a|e a|a i|he |kwa| ok| ob|e o|hi |any|ga\u2010|ha |d\u1EE5 | mm|ndi|\u1ECD n|wa |r\u1EE5 |e m|che|a e|oke|wu |aka|ite|o n|a g|odo|bod|obo| d\u1ECB| ez|ara|we | ih|a\u2010e|h\u1ECB |ri |n o|zi |mma|chi|d\u1ECB |ghi|\u1EE5ta|iri|ihe| an| oh|a y|gba|\u1EE5 \u1ECD| \u1ECDz| ak| iw|nya|te |iwu| nt|ro |oro|e \u1ECB|z\u1ECD |ezi|me |e e|u n|her|ohe| si|a\u2010a|i m|ala|\u1EE5 i| ka|akw| in|gh\u1ECB|kpe|n e|p\u1EE5t| e |i i|i o|ide|inw|\u1EE5 o|h\u1EE5 |ah\u1EE5|weg|ra |o i|kpa|ad\u1EE5|mad|si |sit|a s| me|sor|i \u1ECD|gid|edo|u o|e y|n a| en|tar|ozu|toz|bi |be |\u1EE5 m|\u1EE5r\u1EE5|\u1ECDr\u1EE5| \u1ECDr|mak|uso|ama|de |\u1ECB o| \u1ECDn|\u1ECDz\u1ECD|ch\u1ECB|egh|enw|ap\u1EE5|ru | to|i a|a \u1EE5|osi|r\u1ECB |wet|hed|nch| nc| eb| al|n\u1ECDd|\u1ECDn\u1ECD|uru|sir| kw|yer|ji |eny| mk|\u1ECBr\u1ECB|eta| us|tu |\u1ECD d|u \u1ECD| o |ba | mb|\u1ECDd\u1EE5|\u1ECBch| ch|a d|pa | ag|kwe| ha|a u|e s|mkp|n u|nta|ebe|n \u1ECD|o m|kwu|nkw|nwa|obi| \u1ECBk|esi|i e|nha| nh|le |ile|nil| ni|eme| og|e k|n i|ch\u1ECD|o y|as\u1ECB|otu| ot|ram|u m|\u1ECBgh|d\u1ECBg|zu |n\u1ECD |mba| gb|e g|\u1ECB m|\u1ECDch|ich|pe |agb|i \u1ECB|uch|z\u1EE5z|uny|wun|\u1ECDr\u1ECD| nn|na\u2010| di|ge |oge|iji| ij|\u1ECDha| \u1ECDh|ikp|egi|meg|o o|\u1EE5h\u1EE5|h\u1EE5h|mah|n \u1EE5|\u1ECD g|\u1ECDta|ek\u1ECD|\u1ECB n|kw\u1EE5|agh|\u1EE5m\u1EE5|ban|kpu|okp| ah|\u1ECBkp|a k|ime| im|z\u1EE5 |\u1EE5z\u1EE5|\u1ECDz\u1EE5| \u1EE5z|lit|ali|nat",
    ceb: "sa | sa|ng |ang| ka| pa|an |ga |nga| ma|pag| ng|on |a p|od |kat|ay | an|g m|a k|ug |ana| ug|ung|ata|ngo|atu|n s|ala|san|d s|tun|ag |a m|god|g s|a a|a s|g k|g p|yon|n u|ong|tag|usa|pan|ing|una|mat|g u|mga| mg|y k| us|ali|syo| o |aga|tan|iya|kin|dun|nay|man|nan|a i| na|ina|nsa|isa|bis|a b|adu| ad|n n| bi|asy|asa|lay|awa|lan|non|a n|nas|o s|al |agp|lin|nal|wal| wa|ili|was|gaw|han| iy| ki|nah|ban|nag|yan|ahi|n k|gan| gi|him| di|a u| ba| un|ini|ama|ya |kas|asu|n a|g a|gka|agk|kan|ags|agt|l n|a g|kag| ta|imo|uns|sam| su|g n|n o|gal|kal|og |taw|aho|uka|gpa|ipo|ika|o p|a t| og| si|gsa|g t|aba|ano|gla|y s|o a|aki|hat|kau|sud|gpi|a w|g i|aha|ot |ran|i s|n m|bal|lip|gon|ud | ga|li |uba|ig |ara|g d|na |kab|aka|gba|ngl|ayo| la| hu|a h|ati|d a|d n| pu| in|uga|ok |ihi|d u|ma |may|awo|agb|ami|say|apa|pod|uha|t n|agh|buh|ins|ad | ub| bu|at |iin|a d|ip |uta|sal|hon|wo |ho |tra|lak|iko|as |aod|bah|mo |aug|ona|dil|gik|sos|lih|pin| pi|k s|nin|oon|abu|la |rab|hun| ti|mah|tar|t s|ngb|uma|hin|bat|lao|mak|it | at|s s|sno|asn|ni |aan|ahu| hi|agi|n p|inu|ulo|y p| ni|iha|mag|o n|duk|edu| ed|a e|til|ura|tin|kip|agl|gay|g h|g b|ato|ghi|nab|kon|in |ter|o u|o o|yal|sya|osy| so|tik| re| tr|hig|a o|ha |but|pak|aya",
    tgl: "ng |ang| pa|an |sa | ka| sa|at | ma| ng|apa|ala|ata|g p|pan|pag|ay | an| na|ara| at|tan|a p|pat|n a| ba|ga |awa|rap|kar|g k|aya|lan|g m|n n|g b|nga|mga| mg|a k|na |ama|n s|a a|gan|yan|gka| ta|may|tao|agk|asa|man|aka|ao |y m|ana|g a|nan|aha|kan|y k|baw|kal|a m|g n|ing|wat| y |t t|pam|a n|o y|ban| la|ali|san|wal|mag| o |g i|aga|lay|any|g s|in |nya|yon|kas|a s|isa|una|ong|aan|kat|t p| wa|ina|tay|ya |on |o m|ila|ag |nta|t n|aba|ili| ay|o a| ga|no |a i|gal|ant|han|t s|kap|kak|lah|ari|agt|agp|ran|g l|lin|as |lal|gaw|ans|to |ito| it|hay|wa |t m| is|pap|mam|nsa|ahi|nag|bat|lip|gta| di|gay|gpa|pin| si|ngk|ung|aki|y n|iti|tat|ano|yaa|y s|mal|hat|kai|sal|hin|uma|mak|di |agi|pun|ihi|a l|i a|ira|gga|nah|s n|ap | ha|usa|nin|o p|gin|ipu|ika|ngi|i n|lag|la |y p|ini|g t|uka|nap| tu|a g|tas|aru|ipa| ip|li |al |n o|a o|t k|alo| pi|sin|syo|asy|ita|aho|nar|par|o s|pak|t a|uha|sas|gsa|ags|kin|a h|iba|lit|ula|o n|nak|a t| bu|duk|kab|sam|g e|ain|ami|mas|lab|ani|kil|it | al|agb|buh|a b|g g|ba | ib|iyo|ri |yag|ad | da|edu| ed|anl|ma |ais|iga|mba|tun|ipi| ki|od |ayu| li|lih|sar|gi |g w|pah|wir|oob|loo|agg|nli|bay|map|git|mil|ok |hon|ngg|sah|iya|pas|g h|agl|tar|ngu|amb|uku|ayo|s a|p n|n m|rus|i m|l a|abu| aa",
    hun: "en | sz| va| a |\xE9s |min|ek | \xE9s| mi|jog| jo|an |ind|nek|sze|s\xE1g|nde|a v|den|oga|sza|val|ga |m\xE9l|ala|em\xE9|gy |n a|van|zem|ele| me|egy|\xE9ly| eg|zab|t\xE1s| az|n s|bad|aba|ni |az |gye| el|ak | se|meg|sen|\xE9ny|s\xE9g|k j|yne|lyn| ne|ben|lam|tt |t a|et |agy|oz |hoz|vag|zet| te|n m|ez |nak|int|re |et\xE9|tet|mel|tel|s a|em |ely|let|hez| al|s s| ki|ete|at\xE1|z a| le|yen|es |ra |t\xE9s|ell|nt |sem|t s|len|nem|a s|ese|nki|enk|a m|\xE1s\xE1|i m|ban|kin|k m|szt| \xE1l|ame|k\xF6z|k a|ds\xE1|ads|l\xF3 | k\xF6|\xE1s |ly |on |\xE9be|tat|a t|n v|\xE1ll|m\xE9n| v\xE9|nye|k\xFCl|l\u0151 |a n| cs|i \xE9|ok |\xE9sz|\xE9rt|lla|lap|\xE1go|gok|nyi|tek| ke|nd |\xE9te|ami|z\xE9s|yes|szo|t m|a a|het|fel|lat|lem|lle|el |z e|s e|k \xE9|mbe|emb|el\xE9|ot |lis|vet|kor|\xE1g |olg| am|sz\xE1|ehe|leh|ogo|ott|\xFCl |nte|\xE9le|i v|ogy|hog| ho|kel|n k|tes|nl\u0151|enl|ss\xE1|\xE1za|h\xE1z|\xE9g |vel|\xE1ba|lek|\xE9ge| ha|a h|r\xE9s| fe|\xE1ny|del|el\u0151|\xE1t |al\xE1|art|tar|zto|z\xE1s|t\u0151 |yil|koz|tko|al\xF3|s k|i e|\xE1rs|t\xE1r|mze|emz| ny|m\xE1s|ett|ny |fej|ass|zas| h\xE1|d a|t \xE9|is |\xE9s\xE9|ez\xE9|t\xE9b| mu|\xE1so|s\xEDt|lye|elm|\xE9de|v\xE9d|ine|t k|os |it |izt|biz| bi|y a|m l|tot|a j|atk|n\xE9l|t n|ti | m\xE1|ai |l\xE1s|eve|nev|zte| b\xE1|sel|ll |al |ere|n e|unk|mun|t e| ak|ife|kif|ako|s \xE9| \xE9r|\xE1na| es|s t|got|s\xFCl| be|v\xE1l|csa|se |\xE9se|ad |ges|tos|ja | gy|asz|ten|lm\xE9| t\xE1|eze|\xE1rm|b\xE1r|ess|l s|\xFCle",
    azj: " v\u0259|v\u0259 |\u0259r |ir | h\u0259| bi| h\xFC| ol|\xFCqu|h\xFCq|quq|na |in |lar|h\u0259r|d\u0259 | \u015F\u0259|bir|l\u0259r|lik|mal|r b|lma|r h| t\u0259|\u0259xs|\u015F\u0259x|\u0259n |dir|uqu|una|an |ali|a m| ma|ikd|ini|r \u015F|d\u0259n|ar |il\u0259|qun|aq |as\u0131| ya|m\u0259k|y\u0259t| m\u0259| m\xFC|kdi|\u0259si|\u0259k |ilm|nin|nd\u0259|olm|\u0259ti|\u0259 y|sin|xs |nda|lm\u0259|yy\u0259|i v| qa| az|olu|iyy|ya |ind|zad|qla|\xFCn |ni |l\u0259 |tin|n m|aza|ar\u0131|\u0259t |n t|maq|lun|l\u0131q|\u0259 b|un |nun|q v|n h|dan|\u0131n | et|tm\u0259|\u0259r\u0259| \xF6z|da |\u0259 v| on|\u0259 a|\u0131na|\u0131n\u0131|bil|a b|s\u0131 |il |\u0259mi|ara|si | di|\u0259 m|\u0259ri|rl\u0259| va|\u0259 h|etm|\u0131\u011F\u0131|ama|dl\u0131|adl|rin|b\u0259r|r\u0131n|n i|m\xFCd|n\u0131n| he|mas|ik |n a|dil|al\u0131|irl|\u0259l\u0259|\xFCda|s\u0131n|\u0131nd|xsi|li |\u0259 d|n\u0259 | b\u0259|\u0259ya| in|\u0259 i|l\u0259t| s\u0259|n\u0131 | i\u015F|an\u0131|e\xE7 |he\xE7|q h|eyn|\u0259 e|d\u0131r| da|asi|r\u0131 |i\u015F |ifa|l\u0131\u011F|i s|fi\u0259|afi|daf| ed|m\u0259z|u v|kil| ha|ola|n v|\u0259ni|\u0131r |uq |unm| bu| as|sia|osi|sos|ili|\u0131d\u0131|l\u0131d|nma|\u0131q |in\u0259|\u0259ra|sil|xil|axi|dax|ad\u0259|man|a h|\u0259 o|onu|a q|\u0259z | ki|se\xE7| se|\u0131 h|min|lan|\u0259d\u0259|bu |raq|l\u0131 |\u0131l\u0131|al |\u0259 q|r v|nla|hsi|\u0259hs|t\u0259h|\xF6z |ist| is|m\u0259s| \u0259s|ina|\u0259 t|\u0259tl|a v|i\u0259 |n b|t\u0259r| ta| c\u0259|edi|ala|kim|qu |i t|ulm|m\u0259h|n o|aya|\u0131 o|ial| so|ill|siy| d\u0259|var|ins|mi |\u011F\u0131 |nik|r i|aql|k h|t\u0259m|tam|\xE7\xFCn|\xFC\xE7\xFC| \xFC\xE7|\u011F\u0131n|sas|\u0259sa|z h|\u0259m\u0259|zam| za|sti|r\u0259f|n e|r a|ild|h\u0259m|\u0131ql|yan|may|n \u0259|m\u0259n|mil| mi|\u0259qi|din|n d|t\xFCn| d\xF6|miy|kah|ika| ni|fad|tif|l o|s\u0259r|yni| ey|ana|l\u0259n|am |ril|ay\u0259|a\u015F\u0131",
    ces: " pr|n\xED | a | ne|pr\xE1|r\xE1v|na |ost| po|ho | sv|o n| na|vo |neb|\xE1vo|bo |ebo|nos|m\xE1 | m\xE1|a\u017Ed|ka\u017E| ka| ro|ch |d\xFD |\u017Ed\xFD|ti |ou |a s| p\u0159| za|\xE1n\xED|\xE1 p| je| v |svo|\xE9ho| st|\xFD m|sti|n\u011B | by|obo|vob|ter|pro|en\xED|bod| z\xE1| sp|\xED a|rod|kte|by |mu |u p|o p| n\xE1|v\xE1n|jak| ja|a p|o v|\xED n|ov\xE1|oli|v\xED |spo|roz| kt|mi |\xED p|ny | ma|\xEDm |i a|do | so|odn|\xE1ro|n\xE1r|li |n\xE9 |tv\xED|at |\xFDch|a z| vy|byl|vol|en |\xFDt |b\xFDt| b\xFD|t s|tn\xED|stn|o s|\xED b|to | do|sv\xE9|v\xE9 |ran|ejn|z\xE1k|eho|jeh|nes|p\u0159\xED|m\xED |\u010Din|kol|aj\xED|sou| v\u0161|\xEDch|it |n\xFDm|\xFDm |nu |hra|nou|u s|\xE9mu| k |du |\u017Een|pod| ze|kla|a v|stv|pol|dn\xED|er\xE9|m p|st\xE1|je |ci |e\u010Dn| ni|n\xE9h|a n|ak\xE9|\xE1va|maj|em |rov|\xED m|k\xE9 |ole|n\xFDc|ova| ve|ako| ta|i k|chr|och| oc|kon|i p|\xED v|sm\xED|esm|kdo|st |i n|o z|ave|odu|bez| to|sta|ech|j\xED |o d|sob|se | se|\xED s|\xFDmi|i s| i |i v| vz|n\xEDm|pra|ln\u011B|p\u0159i|t\xE1t|ste|a j|aby| ab| s |oln|a o|m n|\u010Den|slu|\u0159\xEDs| os|zem|mez| \u010Di|ln\xED|\xE1ln|oci|jin| ji|y b|\xED z|y s|va |v\u0161e|t v|ovn|chn|d\u011Bl|n\xEDc|le\u010D| pl|vat| vo|vin|rav|vou|lad|inn|\xE9 v|anu|tej|u k|stu|est| tr|ky |ikd|nik|ivo|nit|zen|u o|n\xE9m|nez|i\xE1l|\xEDho|len|ens|o\u017Ee|oko|k\xE9h|rac|ven|\xED k|e s|l\xE1n|\u011Bl\xE1|zd\u011B|vzd|t k|din|odi|t\xED | od|r\xE9 |tup|pov|pln|\u0161t\u011B|\xE1kl|nno|tak|er\xE1|\u0159ed|o a|a t|res|j\xEDc| mu|u z|rok| ob|\u010Dno|u a|y k|i j|\xE9 n|lu\u0161|\xEDsl|oso|ci\xE1|soc|n\xEDh|o j|ck\xE9",
    run: "ra |we |wa |e a| mu|a k|se | n | um| ku|ira|ash|tu |ntu|a i|mu |umu|mun|unt|ere|zwa|ege|ye |ora|teg|a n|a a|ing|ko | bi|sho|iri| ar| we|shi|aba|e n|ese|go |a m|o a|gu |uba|ngo|nga|hir| ca|ugu|obo|hob|za |ndi|ish|gih| at|ara|wes| kw|ger|ate|a b| ba| gu|e k|can|ama|ung|bor|u w|mwe|di | ab|nke|ke |kwi|ka |ank|yo |ezw|n u|na |iwe|e m|rez|ri |a g|gir| am|igi|e i|ro |a u|ngi|e b|ban| ak| in|ari|n i|hug|ihu|e u|riz|ang|nta| vy|ata| ub|and|aka|rwa| nt|kur|ta |iki|kan|iza|u b|ran|sha|o n|i n| ig|ivy| iv|ahi|bah|u n|ana| bu| as|aku|ga |uko|o u|ho | ka|ose|ubu|ako|guk|ite|o y|ba |i b|any|kir|o k|aho|iye|kub|amw|nye|aha| ng|o m|nya| it|re | im|o b|izw|kun|hin|e c|vyo|o i|vyi|ngu|uri|imi|imw|gin|ene|u m|zi |ha |kug|bur|uru|jwe| zi|u g|era|aga|ron|abi| y |e y| uk|gek|ani| gi|eye|ind|wo |u a|i a| ib|i i|ras|bat|gan|amb|n a|onk|rik|ne |ihe|agi|kor| ic|ze |tun|ibi|wub|nge|o z|tse|nka|he |rek|twa|gen|eko|mat|ber| ah|ni |ush|umw| bw|mak|bik|ury|yiw|bwo| nk|ma |no |kiz|uro|gis|aro|ika| ya|gus|y i|wir|ugi|uki| ki|a c|ryo|bir| ma| yi|iro|bwa|mur|eng|ukw|hat|tan|utu|wit|w i| mw|y a|mbe| ha|uza|ham|rah| is|irw|o v|umv|ura|eny|him|eka|bak|bun| ny|bo |yig|kuv|wab|key|eke|yer|vye|i y|ita|ya |a r| ko|kwa|o c",
    plt: "ny |na |ana| ny|a n|sy |y f|a a|aha|ra | ma|nan|n n|any|y n|a m|y m|y a| fi|an |tra|han|ara| fa| am|ka | ts| na|in |ami| mi|a t|olo|min|man|iza|lon| iz|fan| ol| ha| sy|aka|a i|reh|ay |ian|tsy|ina| ar|on |o a|etr|het|ona|y o|o h|zan|y t|a h|ala| hi|a f|y h|ehe|ira|a s|zo |y i|ndr|jo | jo|n j| an| az|ran|dia| dr|y s|fah|ena|ire|tan|dre| zo|mba| ka|m p|afa| di|n d|and|azo|zy |amp|ia |ren|iny|rah|y z|ry |ika|oan|ao |amb|lal|ho | ho|isy|ony|tsa|asa|a d|ha |fia|mis|ava|ray| pi|am |dra| to|rin| ta|ant|eo |zay|rai|tsi|itr|sa | fo| ra|van|ova|nen|azy| vo|mpi|ari|o f|tok|a k| ir|kan|oto|mah|ly |sia| la|n i|voa|haf|a r|ito|y k|oka|y r|y l|ano|ita|ene|its|ial|zon|aza|ain| re| as|fot|aro|fit|nat|nin|aly|har| ko|ham| no|fa |ary|atr|ila|ata|iha|nam|kon|oko| sa|elo|nja|anj|ive|isa|oa |dy |y d|o m|nto|ank|o n|otr|pan|fir|air|sir|ty |a v|sam|o s|tov|mit|rak|reo|o t|pia|tao| ao|no |y v|iar|a e|a z|hit|hoa| it|to |za |ton|eha|end|vy |idi|tin|ati|adi|lna|aln|rov|ban| za|nga|hah|oni|osi|sos|vah|ino|ity| at|hia|pir|ifa|omb|ame|era|vel|kar|va |tso|jak|fid|ifi|ais|o i|idy|la |ama|ba | pa|tot|ani|rar|mpa|haz|kam| eo| il|iva|aho|nao|n k|ato|lah|ovy| te|dro|lan|ela| mo| si|fin|miv|san|koa| he|aso| mb|sak|kav",
    qug: "ta | ka|ka |na |una|cha|ash|ari|a k|ana|pak|ish|ach|hka|shk|mi |kta|hay|man| ch|apa|ak |rin|ata|kun|har|akt|ita| ha|ami|lla| pa|ama|pas|shp| ma|tak|ay\xF1|y\xF1i|in |sh |ina|uku|nka|chi|aka|a c|yta|kuy|all|tap|a h|kan| tu|\xF1it|tuk| ru|run|chu|an |pay|ayt|ris| ki|aku|hpa|ank|a p|kam| sh|nam|a s|uy |i k|ayp|nak|pi |nta|a m| li|ay |lia|hin|kaw|nap|ant|tam|a t|iri|nat| wa|y r|kay|aws| ya|n t|ypa|wsa|pa |lak|shi|a a|lli|iku|hu |n k|iak|yay|kis| al|shu|a w|ipa| sa| il|api|kas|yku|yac|kat|a r|huk|i c|wan|hik|a i|ill|ush| ti|ayk|hpi| ku|kac|say|hun|uya|ila|ika|yuy|pir|ich|mac|ima|a y|yll|ayl|i p|kin|a l| wi|kus| yu|lan|tan|llu|kpi| ta| pi|aya|la |yan|awa| ni|kak|lat|rik|war|ull|kll|li |ink|nch|un |akp|n s|may| ay|uch|i s|nac|sha|iki|kik|h m|ukt|pip|tin|n p|iya|nal|aki| ri|ura|tik|mak|ypi|i m|i w|n m|his|k i|riy|iwa|y h| hu|han|akl|k t|mas|pik|kap| \xF1a|u t|nmi|nis|k a|i y|k l|kar| im|i i|wil|yma|aym|ksi|iks|uma| su|h k|has| ak|unk|huc|kir|anc|k m|pal|k k|ik |i\xF1i| i\xF1|ma |n y|mun| mu|mam|tac|a n|i t|k r|sam|ian|asi|k h|was|ywa|iyt|llp|san|sum|ray|si |pan|nki|tar| ii|u k|\xF1ik|uk |i\xF1a|kuk|wpa|awp|akk|a u|wat|uri| mi|yar|uyk|ayw|h c|ha |tay|rmi|arm|uta|las|yka|llk|kul|wi\xF1|ati|ska| ll|kit|n h|uti|kic|mat",
    mad: "an |eng|ng |ban| sa| ka|dha|ren| se| ba|ak | ha|adh|hak| dh|ang|se | pa|aba|a s|na |aga|ha | or|n s|ore|ara| ag|gad|are|ana|n o|ngg|ale|gan|a k|ala|dhu|tab|sar|ota|asa|eba| ot| ke|sab|ba |wi |uwi|abb|i h|huw|aan|n k|a b|bba| ta| ma|pan|hal|bas|ako|dhi|ra |kab|em |beb|ka |lak|gi |lem|g a|eka|n b|ama|nga|san|at |ong|ran|nge|a o|ggu|sa |a d|ane|n p|ken|par|aja|man|gar|ata|nek|apa| na|agi|abe| ga|e e|sal|a a|tan|g s|al |kal|gen|ta |i s|aka|e a|a p|a e| la| pe|nan| an|era|e d| e | be|n a| al|ena|uy |guy|n n|ate| bi|mas|e k|kat|uan|oan|kon|k k|a m|i d|g e|n t|g k|ada|koa|lan|ela| da|bad|ma |ne |as |lab|ega| mo|ar |car|one|i p|bi |kaa|bat|ri |on |pon| so|e b|le |ah |abi|ase|adi|epa| ep|k h|and|pam|te |ok |ste|aon|om |oko|aha|ari|ona|asi|ter| di|di |pad|e s|sad|yar|neg|ton|set|rga|ost|mos|gap|nda|a l|har|i k|ina| a | ng|kom|isa|si |a t|a h| kl|jan|daj|iga|hig|idh|hid|ndh|n m|ngs|tto|ett|arg|la |k b|ler|k d|nna| to|nao|n d|mat| ca|tad|bis|aya|epo|aen| po|bin|nya|kas|k s|n h|sya|nta|gsa|en |ant|n g|kar|i e|das|e t|e p|iba| pr|g p| ho| el|i a|hi |os |sao|uwa|tes| ja|nag|nas|lae|sia|t s|k o|nto|int|yat|arn|m p|duw|adu|eta| ko|i b|ni |g n|kla|rak|ame|mpo|jua|sok|aso|ggi|eja|pel|jam|ele| et|dil",
    nya: "ali|ndi|a m|a k| nd|wa |na | al|yen| ku|nth|ra |di |se |nse| mu|a n|thu|hu |nga| wa|la |mun|u a|unt|iye| ka|ce |ace| lo|a l|ang|e a| la| pa|liy|a u|ens| ma|idw|ons|dwa|e m|i n|ala|kha|lo |li |ira|era|ene|ga |ana|za |o m| mo|yo |o w| ci|we |dzi|ko |o l|and|dan|hal|zik|chi|oyo|pa |ner|ulu|ena|moy| um|a p| da|ape|kap|ka |iko| an|pen|a c|to |ito|hit|nch| nc|iri|lir|wac|umo|e k|lu |a a|aye| dz|kuk|a z|dwe|tha|mal| za|ing|ufu|mu |ro |ful| uf|o c|i d|lin|e l|zo |edw| zo|o a|mwa|u w|iro|o n|lan|amu|ere| mw|nzi|dza|alo|ri | li|fun|lid|gan|so | ca|kul|ofu|nso|o z|ulo|unz|o k|mul|lam|i c|san|a b|kwa| na|a d| a |una|u k|i l|nkh|ant|aku|ca |cit|oli|ipo|dip|ama|lac|wir|han|yan|osa|uli|tsa|i m|pon|kup|u d|ti |gwi|ukh|ung|hun|lon|ank|nda|iki|ina| ko|ao |diz|phu|ati|oma|i a|tsi|pat|iya|siy|kut| ya|zid|eze|ma |i k|mer|ome|mol|u n|u o|aph|ogw|izo|mba|sid|ku |sam|awi|adz| ad|izi|ula|say|e n|khu| kh|rez|vom|bvo|okh|lok|win|akh|o o| am| on|zir|map| zi|eza|ja |go |ngo|ika|its|ats|osi|gwe| co|isa|ya |haw|ani|o p|zi |ndu|kho|ezo|kir|uni|i u| ay|lal|gal|sa |bom| bo|ola|amb|wak|ha |ba |nja|anj|ban| ba|iza| bu|udz|ngw|bun|oye|o d|nal|kus|i p|i o|i y|wi | nt|e p| si|aka|ne |men|jir|nji|sed|ets|end|eka|uma|du ",
    zyb: "bou|iz |aeu|enz|eng|uz | bo|ih |oux|nz | di|ing|z g|ux |uq |dih|ngh| ca|ng |gen|ung|z c| mi|miz|ij |cae|z d| gi| de| ge|euq|you| ci|ngz|ouj|aen|uj | yi|ien|gya| gu|ngj|mbo| mb|zli|dae|gij|cin|ang|j d|nae| se| ba|z y|euz| cu|de |x m|oz |j g|ouz|x b|li |z b|h g| da| yo|nj |xna|oxn|rox| ro|h c|nzl|vei|yau|wz |z m|ix | si|i c|iq |gh |j b| cw|nda|yin| hi| nd|dan|vun|inh| ga|can|ei |cun|yie|q g|hoz|bau| li| gy|wyo|cwy|z h|gue|gz |gun|faz|unz|yen|uh |den|ciz| go|q c|gj | bi|ej |aej| fa|hin|zci| wn|j n|goz|gai|au |z s|q d| vu|h m|gva|hu |auj|ouq|az |h d|ya |uek|ci |nh |u d|ou |sou|jso|gjs|din|awz|enj| do|h s|eve|sev|z r|nq |sin|nhy|g g|g b|liz|kgy|ekg|sen|eix|wng|lij|ngq|bin|i d|ghc| ha|bae|hix|h y|j c|ghg|i b|ouh|en |n d|h f|j s|z v|j y|law|hci|anh|inz|q y|nei|anj|ozc|ez |enh|q s|aiq|uen|zsi|zda|hye|ujc|e c|siz|eiz|anz|g y|i g|q n|bie| ne| ae|giz|u c|hgy|g d|gda|ngd|cou| la|z l|auy|ai |in |iuz|zdi|jhu|ujh|yuz| du|j m| fu|cuz|eiq|g c|gzd| co|uyu|coz|zbi|biu| dw|i s|i n|aw |dun|yun|izy|daw| he|nho| ho|enq|x l|cie|q b|cij|uzl|x d|iuj|awj| ya|eij|dei|nde|sae|izc|wnq|wnh|sei|h b|aih|gzs|bwn|a d|u g|ngg|jca|e b|ran| ra|hcu| me|iet|van| bu|guh|hen|si |wnj| ve|u b|azl|inj|gak|gan|ozg|siu|yaw|i m",
    kin: "ra | ku|se | mu|a k|ntu|tu |nga|umu|ye | um|unt|mun|e n| gu|we |ira|a n| n |wa |ere|mu |ko |gom|a b|e a| ab|li |e k|mba|a a|e b|aba|ga |e u|ba |omb|o k| ba|a u|ose|u b|o a| cy|ash|eng| ag|kwi| bu|za |gih|ren|ndi| ub|ang|yo |aka|gu |igi| ib|a g|a m| nt|uli|o b|ama|ihu|e i|nta| ak|ago|ro |ora| ka|ugu|hug|di |iye|ban| am|cya|ku |ta | bw|and|sha|re | ig|gan|ubu|na | kw|obo| by| bi|a i|yan|ka |sho|kub|era|ese| we|kan|aga|hob|bor|ana|byo|ura|uru|ibi|rwa|wes|u w|no |uko|i m|mo |u a|ure|ili|uba|o n|uha|uga|n a| im|ish|bwa|bwo|wiy|ali|ber|ze |ne |ush|are|o i|u m|ger|bur|ran| ki| no|ane|bye| y |ege|teg|guh| uk|n i|rag|i a|ya |u g|e m|anz|bo |abo|gar|wo |y i|ho |age|ind|o m|eke|a s|ara|zir|ite|kug|kim|aci| as|u n|ani|kir|mbe| gi|yos|kur|ugo|gir|e c|iza|aho|i b|tur|ata|o u| se|u u|zo |i i|aha|nge|mwe|iro|akw|any|eza|uki|imi|o y|ate|u k|iki|atu|bat| in|go |tan|n u|bos| bo| na|hak|iby| at|ihe|ung|ha |bul|kar|eye|eko|gek|nya|o g|shy|e y|awe|ngo|bit|mul|nzi|rer|bag|ge |imw|bah|cir|gac|bak|je |gez|imu|eze|tse|ets|mat| ru|irw|he | ni| ur| yi|ako|ngi| ng|i n|rez|ubi|gus|fit|afi|ugi|uka|amb|o c|utu|ufa|ruk|mug|bas|bis|uku|hin|e g|ige|amo|ing| af|yem|ni | ry|a r|gaz|te |erw|bwe|ubw|hwa|iko| al|ant|zi ",
    zul: "nge|oku| ng|a n|lo |ung|nga|la |le | no|elo|lun| um|e n|wa |we |gel|e u|ele|nel|thi|ke |nom|ezi|ma |ntu|oma|hi |o n|ngo|tu |nke|onk|o l|uth|ni |a u|lek|unt| wo|o e| lo|mun|umu|pha| ku|ang|ho |kwe|ulu| ne|won|une|lul|elu| un|a i|gok|kul|ath|hla|lok|khe|eni|tho|ela|zwe|akh|kel|a k|enz|ana|ban|aka|u u|ing|ule|elw|kho|uku|ala|lwa|gen| uk|wen|ama|na |e k|ko |gan|a e|he |zin|enk|o y| ez|kat| kw|lan|eth|het|o o| ok|okw|i n|nzi|aba|e a|hak|lel|lwe|eko|ane|ka |so |yo |ayo|o a|uhl|nku|nye| na|thu|mph|do |ben|ise|kut|ike|kun| is| im|hol|obu|fan|i k|e w|nhl|nok|ini|and|kuh|ukh|kuk| ak|e i|isi|aph|zi |ile|eki|ekh| ba|eka|the|a a| le| ye|kwa|e e|fut| fu|za |mal| ab|ebe|isa| em|o w|kub|mth|i w|ndl|emp|any|olo|ga | ko|nen|nis|alu|ith|eli|ndo|seb|nda| ya|i i|eke|vik|ake|uba|abe|ezw|yok|ba |ale|zo |olu|ume|ye |esi|kil|khu|yen|emi|nez|hlo|a l|ase|ula|kek|a o|iph|o u|no |azw|kan|mel|uny|ne |ufa|ahl|lin|hul|ant|und|sa |enh|kus|kuv|lak| in|o i|din|kom|amb|zis|ind|ola|uph|wez|eng|yez|phe|phi|mba|nya|han|kuf|nem|isw|ani|iyo| iy|fun| yo|uvi|i a|ene|izi| el|cal|i e|eze|ano|nay|hwe|kup|lal|uyo|ubu|kol|oko|ulo| la|e l|tha|nan|mfu|hon|nza|hin| ey|omp|da |bo |ilu|wak|lon|iso|kug|nka|ink|i l|sek|eku| ek|thw|gez",
    swe: "ar |er |tt |ch |och| oc|ing|\xE4tt|ill|r\xE4t|en | ti|til|f\xF6r|ll | r\xE4|nde| f\xF6|var|et |and| en|ell| ha|om |het|lle|lig|de |nin| de|ng | in| fr|as |ler| el|gen|nva|und|att|env|r h| i |r r|ska|fri| so|har|der| at|\xF6r |ter|all|t t| ut|den|ka |lla|som|av |sam|ghe|ga | sk| vi| av|ete|la |ens|t a| si|r s|iga|igh|tig| va|ig |a s| st|ion|ra |tti|a o| \xE4r|ten|ns |t e|na | be|han| un| an| sa|a f| la| gr| m\xE5|nge|n s|vis|lan|m\xE5 |ati|nat| \xE5t|an |nna| li| al|t f|ans|nsk|sni|gru|\xE4ll|tio|ad | me|isk|kli|s f|t i|st\xE4|t s|ri |med|sta|h r|lik|da |dig|ta |r o|run|on | re|lag|tta|\xE4r |kap|a i|a r|\xE4nd|erv|n e|kte|n f|rvi|nom|itt|id | mo|sky|r e|ver|\xE4ns|vil|gt |igt| na|tan|uta|dra|t o|ro |isn| fa|kal|ihe|rih|erk|r u|e s|per|l v|vid|one|rel|ber|ran|ot |mot|ndl|d f|ed |ika|m\xE4n|l s|bet|t b|dd |ydd|kyd|n o|s s|str|n m|tet|sin|r f| om|rna|int|r i|end|nad|l a|ap |ers|nda|t v|ent|rbe|arb| h\xE4|ets|h\xE4l|amh|ckl|gar|nga|r m|je |rje|arj|n i|s e|lin|r t|i s|r\xE4n| pe|ilk|t l|ern|p\xE5 | p\xE5|t\xE4l|d e|dom|ege|g e|tni|r a|lit|ras| s\xE5|lln|kil|ski|enn|i o|a d|er\xE4|n a|ara| ge|\xE4ro|a m| ar|t d|ilj|els|yck| ve|g o|fr\xE5|nas|tra|ess|del|m s|liv|l l|in |v s|g a|ast|e e|val|son|rso|e t|age|nd | eg|ial|cia|oci|soc|upp|igi|eli|g s|rkl|gad|ndr|nte|\xF6ra",
    lin: "na | na| ya|ya |a m| mo|to | ko|li |a b| li|o n| bo|i n|a y|a n|ki |a l|kok|la | ma|zal|i y|oki| pe|ngo|ali|pe |so |nso|oto|ons| ba|ala|mot|a k|eng|nyo|eko|o e|nge|yon| ny|kol|lik|iko|a e|o y|ang|ye | ye|oko|ma |o a|go | ek|ko |e m|aza|te |olo|sal|ama|si | az|mak|e b|lo | te|ta |isa|ako|amb|sen|ong|e n|ela|oyo|i k|ani| es|o m|ni |osa| to|ban|bat|a t|mba|ing|yo | oy|eli|a p|mbo|o p|mi | mi| nd|ba |i m|bok|i p|isi|mok|lis|nga|ge |nde|koz|bo |gel|ato|o t|mos|aka|oba|ese|lam|kop| ez|lon|den|omb|o b|ota|sa |ga |e a|e y|eza|kos|lin|esa|e e|kob|e k|sam|kot|kan|bot|ika|ngi|kam|ka | po|gom|oli|ope|yan|elo| lo|ata| el|bon|oka|po |bik|ate| bi|a s|i t|i b|omi|pes|wa | se|oza|lok|bom|oke|som|zwa|mis|i e|bek|iki| at|ola|ti |ozw|lib|o l|osu|oso|e t|nda|ase|ele|kel|omo|bos|su |usu|sus|bal|i l|ami|o o|bak| nz|pon|tel|mob|mu | ep|nza|asi|mbi|ati|kat|le |gi |ana|oti|ndi|tan|a o|wan|obe|kum|nya|mab|bis|nis|opo|tal|mat| ka|bol|and|aye|baz|u y|eta| ta|ne |ene|emb|sem|e l|gis|ben| ak| en|mal|obo|gob|ike|se |ibo|\u2019te| \u2019t|umb| so|mik|oku|be |mbe|bi |i a|eni|i o| mb|tey|san| et|abo|ebe|geb|eba|yeb|bu | as|ote|sik|ema|eya|ibe|mib|ai |pai|mwa|kes|da |may|boz|amu|a a|kom|mel|ona|ebi|ia |ina|tin| ti|bwa|sol|son",
    som: " ka|ka |ay |uu |an |yo |oo |aan|aha| wa|da | qo| in| u |sha| xa|a i|ada|iyo| iy|ma |ama| ah| la|qof|aa |hay|ga |a a|a w|ah | dh|a s| da|in |xaq| oo|a d|aad|yah|eey| le|isa|lee|u l|q u|aq | si|taa|eya|ast|la |of |iya|sa |y i|u x|sta|kas|xuu|uxu|wux| wu|iis|nuu|inu|ro | am| ma|a q|wax|dha|ala|kal|nay|f k|a k|le |ku | ku| sh|o i|a l|ta |maa|a u|dii|loo| lo|o a|ale|ara|ana|iga|o d| uu|ha |lo |o m|o x|doo|aro|kar|yaa|gu |si |ima|na | xo| fa|adk|do |a x|ad |aas| qa| so|a o| ba|lag| aa| he|dka|adi|soo|o k|aqa| is|ash|u d|had| ga|eed|san|u k|a m|iin|i k| ca|u s|n l|yad|rka|axa|elo|hel|aga|hii|o h|o q| ha|id |n k| mi|baa| xu|har|xor|aar|ax |mad|add|nta|mid|aal|waa|haa|ina|qaa|daa|agu|ark|o w|nka|u h|dad|ihi| bu| ho|naa|n a|ays|haq|a h|o l| gu|o s|aya|saa|lka| ee| sa|dda|ab |nim|quu|gga|ank|kii|rci|arc|n s|a g| ji|gel| ge|eli|ysa|a f|siy|int|laa|uuq|uqu|xuq| mu|i a|uur|mar|ra |iri|o u| ci|riy|ya |ado|alk|dal|ee |al |rri|ayn|asa| di|ooc|aam|ofk|oon|to |ayo|dar| xi|dhi|jee|a c| ay|yih|a j|ban|caa|lad|sho|d k|ida|uqd|agg|sag|ras|bar|ar | ko| ra|o f|gaa|gal|fal|u a| de| ya|o c|ii |xay|eel|aab|sig|aba|orr|hoo|u q|y d|ed |ho |sad|qda|h q|fka|n i|xag|n x|qay|lsh|uls|bul|u w|jin| do|raa| ug|ido|ood",
    hms: "ang|gd |ngd|ib | na|nan|ex | ji|eb |id |d n|b n|ud | li|nl |ad | le|jid|leb|l l| ga|ot | me|x n|anl|aot|mex|d g|b l|d d|ob |gs |ngs|jan| ne|ul | ni|nja| nj|lib|ong|nd | zh|jex| je|b j| sh|ngb| gh|gb | gu|gao|l n|han| ad|gan| da|t n| wu|il |x g|nb |b m| nh|she|is |l j|d l|nha|l g|d j|b g|el |end|wud|nex|gho|d s|d z|oul|hob|ub |nis| ch| ya|it |b y|eib| gi|s g|lie| yo| zi|oud|s j|d b|nx | de|es |d y| hu|uel|gue|ies|aob|you| ba|d m|chu|gia|dao|b d|s n|zib| go|zha|eit|hei|al |hud| do|nt |ol | fa|t g|hen|ut |gx |ngx|ab |fal|x j|b z|ian|d h|don|b w|t j|iad|nen| xi|gou|d c|b h|hao|x z|nib|anx|ant|gua| mi|s z|dan|ox |inl|hib|lil|uan|and| xa|b x| se|x m|uib|hui|d x|anb|enl| we|od |enb| du|at |ix |s m|bao| ho|hub| ng|zhi|jil|l s|yad|t m|t l|yan| ze| ju|heb|had|os |aos|t h|l d|nga| he|b a|xan|b s|sen|xin|dud|jul|d a|lou| lo|dei|d w| bi|b c| di|zhe|gt |ngt|x l|bad|x b| ja|hon|zho|blo| bl|d k| ma|deb|l z|wei| yi| qi|b b|x d|d p|eud| ge|x a|can| ca|t w|lol| si|hol|s w|aod|pao| pa|ren| re|x s|eut|pud| pu|aox|mis|gl |ngl|x w|zei|gon|enx|gha|s a|b f|l y|oub|eab|hea| to|did| ko|unb|ghu|t p|x c|geu|t s|x x|jao|ed |t c|l m|l h|jib|ax |l c|d f|nia| pi|eul|d r| no|min|l t|heu|ux |tou|ns |s y|iel|s l|hun",
    hnj: "it | zh| ni|ab |at |ang| sh|nit| do|uat|os |ax |ox |ol |nx |ob | nd|t d|zhi|nf |x n|if |uax| mu|d n|tab| ta| cu|mua|cua|as |ad |ef |uf |id |dos|gd |ngd|hit|ib |us |enx|f n|she|s d|t l|nb |ux |x z|ed |inf|b n|l n|t n|aob|b z| lo|ong|ix |dol| go|zhe|f g| ho| yi|t z|d z|b d| le|euf|d s|ut |yao| yo| zi|gb |ngb|ndo|enb|len| dr|zha|uab|dro|hox| ge|nen| ne|han| ja|das|x d|x c|x j|f z|shi|f h|il | da|oux|nda|s n|nd |s z|b g| ny|heu| de|gf |ngf| du|od |gox| na|uad| gu|inx|b c| ya|uef| xa| ji|ous| ua| hu|xan|hen|zhu|nil|jai|rou|t g|f d| la|enf|ged|ik | bu|nya|you|f y|lob|af |bua|uk |is |yin|out|of |l m|ud |hua| qi|ot |t s| ba|ait| kh|s s|nad| di|aib|x l|lol| id|dou|ex |aod|bao| re| ga|d d|b y|las|hed|b h|b s|f b|t y|jua| ju| dl|x s|hue|b l| xi|zif|dus|b b|x g|hif|x y|hai| nz|sha| li|x t| be|d j|und|hun|ren|d y|hef|xin| ib|b t|l d|aos|s l| ha|gai|nzh|gx |ngx| ao|s b|s x|el |gt |ngt|hik|aid|s t|x m|f l|f t| pi|aof|t r|eb | gh|s y|d l|gua| bi| za| fu|t h| zu|hou|deu|lb | lb|d g| mo|b k| bo|iao|ros|gon|eut|x h|al |uaf|hab|t t|k n|f x|hix|pin|yua| no|t b|ak | zo|s m| nb| we|d b|gha|f s|mol|euk|dax|l b|nof| ko|lou|guk|end|uas|t k|dis|dan|yol|uan|d t|x b|lan|t m| ch|jix|x x| hl|aox|zis|x i|et | ro",
    ilo: "ti |iti|an |nga|ga | ng| it| pa|en | ma| ka| a | ke| ti|ana|pan|ken|ang|a n|agi|a k|n a|gan|a m|a a|lin|ali|aya|man|int|teg|n t|i p|nte| na|awa|a p|na |kal|ng |dag|git|ega|sa |da |add|way|n i|n n|no |ysa|al |dda|n k|ada|aba|nag|nna|ngg|eys| me|a i|i a|mey|ann|pag|wen|i k|gal|gga| tu|enn| da| sa|nno| we|ung| ad|tun|mai| ba|l m| ag|ya |i s|i n|yan|nan|ata|nak| si|aka|kad|aan|kas|asa|wan|ami|aki|ay |li |i m|apa|yaw|a t|mak| an|i t|g k|a s|ina|eng|ala|ika|ama|ong|ara|ili|dad| aw|gpa|nai|et |yon|ani|aik|on |at |oma|sin|bal|ipa|n d|uma|g i|ket|ag |in |aen|n p|ram|sab|aga|nom|ino|lya|ily|syo|i b| ki|nia|agp|gim|kab|asi|kin|iam|ags|bab|oy |toy|n m|agt| ta|bag|sia|g a|gil|mil| um|o p|ngi|n w|i i|pad|pap|daa|iwa|naa|eg |ias|ed |nat|bae|o k|saa|san|pam|gsa|ta |kit|ma |dum|yto|tan|i e|t n|uka|t k|apu|lan|sta|sal| li|a b|ari|g n|den|mid|ad |o i|y a|ida|ar |aar|y n|dey| de| wa|a d|ak |bia|ao |tao|min|asy|mon|imo| gi|maa|sap|abi|i u|aib|kni|i l|gin|ged|o a| ar|kap|pul|eyt|abs|ibi| am|akn|i g|kip|isu|g t|bas|nay|ing|i d|kar|ban|iba|nib|t i|as |d n|y i|ura|a w|nal|aad|i w|lak|adu|kai|bsa|duk|edu| ed|may|agb|agk|tra|gge|sol|aso|agr|ngs|ian|ila|dde|edd|tal|aip|kua|umi|pay|sas|ita|pak|g d|ulo|inn|aw "
  },
  Cyrillic: {
    rus: " \u043F\u0440| \u0438 |\u0440\u0430\u0432| \u043D\u0430|\u043F\u0440\u0430|\u0441\u0442\u0432|\u0433\u043E |\u0435\u043D\u0438|\u0432\u043E |\u043E\u0432\u0435| \u043A\u0430|\u043D\u0430 |\u0442\u044C | \u043F\u043E|\u0438\u044F |\u043E \u043D| \u043E\u0431|\u0435\u0442 | \u0432 |\u0441\u0432\u043E| \u0441\u0432|\u0430\u0432\u043E|\u0430\u043D\u0438|\u043E\u0441\u0442|\u043E\u0433\u043E|\u044B\u0439 |\u0430\u0436\u0434|\u043B\u043E\u0432|\u0442 \u043F| \u0438\u043C|\u043D\u0438\u044F| \u0447\u0435| \u0441\u043E|\u0435\u043B\u043E|\u0438\u043C\u0435| \u043D\u0435|\u043B\u044C\u043D|\u043B\u0438 |\u0447\u0435\u043B|\u043A\u0430\u0436|\u0435\u0441\u0442|\u0432\u0435\u043A|\u0430\u0442\u044C|\u043E\u0432\u0430|\u0438\u043B\u0438| \u0440\u0430|\u0435\u043A |\u0439 \u0447|\u0434\u044B\u0439|\u0436\u0434\u044B| \u0434\u043E|\u0438\u0435 |\u0435\u0435\u0442|\u043C\u0435\u0435|\u043D\u043E | \u0438\u043B|\u0438\u0438 |\u0441\u044F |\u0435\u0433\u043E|\u043E\u0431\u043E|\u0438 \u043F|\u043D\u0438\u0435|\u043A \u0438| \u0431\u044B|\u0438 \u0441|\u0438 \u0438|\u043C\u0438 |\u0431\u043E\u0434|\u0432\u043E\u0431|\u0432\u0430\u043D| \u0437\u0430|\u043E\u0439 |\u044B\u0445 |\u043E\u043C |\u043B\u0435\u043D|\u0430\u0446\u0438|\u0435\u043D\u043D|\u043E \u0441|\u043E \u043F|\u044C\u043D\u043E|\u0442\u0432\u0430|\u0442\u0432\u043E|\u043F\u0440\u0438|\u043D\u043E\u0433|\u0430\u043B\u044C|\u0430\u043A\u043E|\u0432\u0430 |\u0438 \u043D|\u0441\u0442\u0438|\u043D\u044B\u0445|\u0442\u043E |\u0431\u0440\u0430|\u043E\u043B\u0436|\u0434\u043E\u043B|\u0441\u0442\u043E|\u0438 \u0432|\u043D\u044B\u043C|\u043E\u0435 | \u0435\u0433|\u043D\u043E\u0432|\u0438\u0445 |\u0435\u043B\u044C|\u0442\u0435\u043B|\u0442\u0438 |\u043D\u043E\u0441|\u043D\u0435 |\u043F\u043E\u043B|\u0440\u0430\u0437| \u0432\u0441|\u0438 \u043E| \u043B\u0438|\u0438 \u0440|\u044B\u0442\u044C|\u0431\u044B\u0442|\u0432\u043B\u0435|\u0440\u0435\u0434|\u0438\u044E |\u0442\u043E\u0440| \u043E\u0441|\u044C\u0441\u044F|\u0442\u044C\u0441|\u043E\u0434\u0438|\u0449\u0435\u0441|\u044F \u0438|\u043A\u0430\u043A|\u043F\u0440\u043E|\u0436\u0435\u043D|\u044B\u043C |\u043F\u0440\u0435|\u0430 \u0441|\u0441\u043D\u043E|\u0435 \u0434|\u043D\u043D\u043E|\u043E \u0438|\u0438\u0439 | \u043A\u043E|\u043E \u0432| \u043D\u0438| \u0434\u0435|\u0441\u0442\u0443|\u043B\u0436\u043D|\u0441\u043E\u0432|\u0435 \u0432|\u043D\u043E\u043C|\u043E\u043B\u044C|\u0440\u0430\u043D|\u043E\u0436\u0435|\u0438\u0447\u0435|\u0435\u0439 |\u0430\u0441\u0442|\u043D\u043D\u044B| \u043E\u0442|\u0442\u0443\u043F|\u043C \u0438|\u043E\u0434\u043D|\u0437\u043E\u0432|\u0440\u0435\u0441| \u043C\u043E|\u043E\u0441\u0443|\u043B\u044F |\u043E\u0441\u043D|\u0430 \u043E|\u0432\u0435\u043D| \u0442\u043E|\u043E \u0431|\u0448\u0435\u043D|\u0442\u0432\u0435|\u043E\u0431\u0449|\u0430 \u0438|\u0435 \u043C|\u044C\u043D\u044B|\u043E\u0431\u0440|\u0432\u0435\u0440|\u0447\u0435\u043D|\u044F \u043D|\u0436\u043D\u043E|\u0447\u0435\u0441|\u0430\u043A |\u043B\u0438\u0447|\u043D\u0438\u0438|\u0435 \u0438|\u0432\u0441\u0435|\u0431\u0449\u0435|\u0432\u0430\u0442|\u0435\u0441\u043F|\u043C\u043E\u0436|\u0439 \u0438|\u043D\u043E\u0435|\u043E \u0434|\u0431\u0435\u0441| \u0432\u043E|\u044F \u0432|\u0434\u0443 | \u0441\u0442|\u0434\u043D\u043E|\u043E\u043D\u0430|\u043D\u0430\u0446|\u0434\u0435\u043D|\u0435\u0436\u0434|\u0445 \u0438| \u0431\u0435|\u0438 \u0434|\u043D\u044B |\u0434\u043E\u0441|\u0434\u043B\u044F| \u0434\u043B| \u0442\u0430|\u043B\u044C\u0441|\u0430\u0442\u0435|\u0446\u0438\u0438|\u044F \u043F|\u0443\u044E |\u0438\u0442\u0435|\u0435 \u043E|\u043D\u043E\u0439|\u043F\u043E\u0434|\u043E\u0442\u043E|\u0441\u0442\u0440|\u0441\u0442\u0430| \u043C\u0435|\u0435\u043B\u0438| \u0440\u0435|\u044F \u043A|\u0442\u043E\u044F|\u0430\u043C\u0438|\u0435\u043D |\u044C \u0432|\u044E \u0438|\u0430\u0437\u043E|\u0433\u043E\u0441|\u043C \u043F|\u044C \u043F|\u0442 \u0431|\u0436\u0435\u0442|\u0443\u0447\u0430|\u0441\u0443\u0434|\u044C\u0441\u0442|\u0434\u0441\u0442|\u0449\u0438\u0442|\u0430\u0449\u0438|\u0437\u0430\u0449|\u043A\u043E\u043D|\u043D\u0438\u044E|\u0430\u043C |\u043E\u0434\u0443|\u0435\u0440\u0435|\u0433\u0440\u0430|\u043F\u0435\u0447|\u043E \u043E|\u043E\u0440\u043E|\u043A\u043E\u0442|\u0438 \u043A|\u0442\u0440\u0430|\u043D\u0438\u043A|\u0443\u0449\u0435|\u0446\u0438\u0430|\u043E\u0446\u0438|\u0441\u043E\u0446|\u043D\u0430\u043B|\u0435\u0441\u043A|\u043E \u0440|\u043A\u043E\u0433|\u0434\u0440\u0443| \u0434\u0440|\u043D\u0438 |\u0430\u0432\u0430|\u043D\u0441\u0442|\u0435\u043C |\u0430\u0432\u043D|\u044B\u043C\u0438|\u0435\u0434\u0441|\u0434\u0438\u043D|\u0434\u043E\u0432| \u0433\u043E| \u0432\u044B|\u0432 \u043A|\u044B\u0435 |\u043E\u0431\u0435|\u043C\u0443 |\u044F \u0435|\u0441\u043B\u0443|\u0443\u0434\u0430|\u0442\u0430\u043A|\u043A\u043E\u0439|\u0442\u0443 |\u0438\u0442\u0443|\u0437\u0430\u043A|\u0445\u043E\u0434|\u0432\u043E\u043B|\u0440\u0430\u0431|\u043A\u0442\u043E|\u0438\u043A\u0442|\u0438\u0447\u043D|\u043D\u0438\u0447|\u043E\u0442 |\u0438\u043D\u0430| \u043A |\u0442\u0435\u0440|\u0440\u043E\u0434|\u043D\u0430\u0440",
    ukr: "\u043D\u0430 | \u043F\u0440|\u043F\u0440\u0430| \u0456 |\u0440\u0430\u0432| \u043D\u0430| \u043F\u043E|\u043D\u044F |\u043D\u043D\u044F| \u0437\u0430|\u043E\u0433\u043E|\u0442\u0438 |\u0432\u043E |\u0433\u043E | \u043A\u043E|\u0430\u0432\u043E| \u043C\u0430|\u043B\u044E\u0434|\u043E \u043D| \u043D\u0435| \u043B\u044E|\u044E\u0434\u0438|\u043E\u0436\u043D|\u043A\u043E\u0436|\u043B\u044C\u043D|\u0436\u043D\u0430|\u0434\u0438\u043D|\u0430\u0442\u0438|\u0430\u0454 |\u0438\u0445 |\u0438\u043D\u0430|\u043F\u043E\u0432|\u0441\u0432\u043E| \u0441\u0432|\u0430\u043D\u043D|\u0454 \u043F|\u043C\u0430\u0454|\u0430\u0431\u043E|\u0430 \u043B| \u0431\u0443|\u043D\u0435 |\u0435\u043D\u043D|\u0431\u043E | \u0430\u0431|\u0430 \u043C|\u043E\u0432\u0438|\u043D\u0456 | \u0432\u0438| \u043E\u0441|\u0430\u0446\u0456|\u0432\u0438\u043D| \u0442\u0430|\u0431\u0435\u0437|\u043E\u0431\u043E| \u0432\u0456| \u044F\u043A|\u0435\u0440\u0435| \u0434\u043E|\u0456 \u043F|\u0443\u0432\u0430|\u043E \u043F|\u0430\u043B\u044C|\u043D\u0438\u0445|\u043E\u043C |\u043C\u0438 |\u0456\u043B\u044C|\u043D\u043E\u0433|\u0442\u0430 |\u0438\u0439 |\u043F\u0440\u0438|\u043E\u044E |\u0442\u044C |\u0441\u0442\u0430| \u043E\u0431|\u0432\u0430\u043D|\u0438\u043D\u043D|\u0442\u0456 |\u043E\u0441\u0442| \u0443 |\u0441\u044F |\u0432\u0430\u0442|\u0431\u0443\u0442|\u0438\u0441\u0442| \u043C\u043E|\u0435\u0437\u043F|\u0443\u0442\u0438|\u043D\u043E\u0432|\u043F\u0435\u0440|\u0456\u0457 |\u0438 \u043F|\u0431\u043E\u0434|\u0432\u043E\u0431|\u0441\u0442\u0432| \u0432 |\u043E \u0432|\u0432\u0456\u0434| \u0431\u0435|\u0430\u043A\u043E|\u043F\u0456\u0434|\u0442\u0438\u0441|\u043A\u043E\u043D|\u043D\u043E |\u0432\u0430 |\u043D\u043D\u0456|\u0456 \u0441|\u0430 \u043F|\u0441\u0442\u0456| \u0441\u043F|\u043D\u0438\u0439|\u0434\u0443 |\u044C\u043D\u043E|\u043E\u043D\u0430| \u0456\u043D|\u0434\u043D\u043E|\u043D\u0438\u043C|\u0456\u0439 |\u0430 \u0437|\u043D\u0443 |\u043C\u043E\u0436|\u0457\u0457 | \u0457\u0457|\u043B\u044F |\u0441\u043E\u0431|\u043C\u0443 |\u043E\u0457 |\u044F\u043A\u043E| \u043F\u0435| \u0440\u0430|\u0456\u0434 | \u0434\u0435|\u0456 \u0432|\u0438 \u0456|\u0447\u0438\u043D|\u0432\u043D\u043E|\u043E\u043C\u0443|\u043D\u043E\u043C|\u0443 \u043F|\u0456 \u043D|\u0430 \u0441| \u0441\u0443|\u0430 \u043E|\u043D\u0435\u043D|\u0438\u0441\u044F|\u043E\u0432\u043E|\u043D\u0430\u043D|\u043E\u0434\u043D|\u0443 \u0432|\u0456 \u0434|\u0430\u0432\u0430|\u0456\u0434\u043D|\u0440\u0456\u0432| \u0440\u0456|\u0456 \u0440|\u0438\u043C\u0438|\u0432\u0456\u043B|\u0438\u043C |\u0446\u0456\u0457|\u043E \u0434|\u0430 \u0432|\u0441\u0442\u0443|\u043E\u0434\u0443|\u0431\u0443\u0434|\u043E\u0432\u0430| \u043F\u0456| \u043D\u0456|\u044F \u043D|\u0435 \u043F|\u043D\u0430\u0446|\u0438 \u0441|\u043D\u043D\u0430| \u043E\u0434| \u0440\u043E|\u043D\u043E\u0441|\u044C\u043D\u0438|\u044E\u0442\u044C|\u0438 \u0437|\u043A\u0438 |\u0456 \u0437|\u0430 \u0431|\u0441\u043F\u0440|\u0447\u0435\u043D|\u0436\u0435 |\u043E\u0436\u0435|\u0435 \u043C|\u043E\u0432\u043D|\u0440\u0438\u043C|\u0435 \u0431|\u0442\u043E |\u043D\u0456\u0445|\u043E\u0441\u043E|\u0443\u0434\u044C|\u0432\u0456 | \u0440\u0435| \u0441\u0442|\u0440\u0430\u0446|\u0434\u043E | \u0441\u043E|\u0440\u043E\u0437|\u043B\u0435\u043D|\u0432\u043D\u0438|\u0456\u0432\u043D|\u0440\u043E\u0434| \u0432\u0441|\u0441\u043F\u0456|\u043A\u043E\u0432|\u0437\u043F\u0435|\u0456\u0432 |\u0434\u043B\u044F| \u0434\u043B|\u0457 \u043E|\u0445\u0438\u0441|\u0430\u0445\u0438|\u0437\u0430\u0445|\u2010\u044F\u043A|\u044C\u2010\u044F|\u0434\u044C\u2010|\u044F \u0456|\u0442\u0430\u043A|\u0437\u043D\u0430|\u0437\u0430\u0431|\u0441\u0442\u044C|\u0442\u0443 |\u043D\u043E\u044E|\u0430 \u043D|\u0442\u043E\u0440|\u0441\u043D\u043E|\u043E \u0441|\u0436\u0435\u043D|\u0446\u0456\u0430|\u043E\u0446\u0456|\u0441\u043E\u0446|\u0456\u043D\u0448|\u0456 \u043C|\u043A\u043B\u0430|\u0438 \u0432|\u0442\u0435\u0440| \u0434\u0456|\u0456\u0441\u0442|\u043E\u0432\u0456|\u0443 \u0441|\u044F \u0432|\u0430\u0440\u043E|\u0441\u0456 |\u0432\u0456\u0442|\u0441\u0432\u0456|\u043E\u0441\u0432|\u0440\u043E\u0431|\u043F\u0456\u043B|\u0440\u0435\u0441|\u0437\u0430 |\u043F\u0435\u0447|\u0430\u0431\u0435|\u043A\u0443 |\u043B\u0438\u0432|\u0435\u0440\u0436|\u0434\u0435\u0440|\u0432 \u0456|\u0430\u0432\u043D|\u0442\u0430\u0432|\u0430\u0432 |\u0430\u043C\u0438|\u043A\u043E\u043C|\u0432\u043B\u0435|\u043E \u0431|\u044C \u043F| \u0449\u043E|\u0457\u0445 |\u0442\u0432\u043E|\u0445\u0442\u043E|\u0456\u0445\u0442|\u043A\u043E\u0433| \u043A\u0440|\u0430\u043D\u043E|\u0442\u0430\u043D|\u0456\u0430\u043B|\u043D\u0430\u043B|\u043D\u044C |\u0445 \u043F|\u0436\u043D\u043E|\u043B\u0435\u0436|\u0430\u043B\u0435|\u043F\u0440\u043E|\u0442\u0432\u0430|\u0440\u0430\u0442|\u043E \u043E|\u0445 \u0432|\u043D\u0430\u0440|\u043B\u044C\u0441|\u0446\u0456\u0439|\u043A\u043E\u0440|\u0447\u0430\u0441|\u0440\u0436\u0430|\u0457 \u0441|\u0438\u043D\u0443|\u0434\u0441\u0442|\u043E \u0437|\u0440\u0430\u0437|\u043C\u0456\u043D|\u0430 \u0440|\u0437\u0430\u043A",
    bos: " \u043F\u0440| \u0438 |\u0440\u0430\u0432|\u043D\u0430 |\u043C\u0430 |\u043F\u0440\u0430| \u043D\u0430|\u0438\u043C\u0430| \u0441\u0432|\u0430 \u0441|\u0434\u0430 |\u0430 \u043F|\u0432\u043E |\u0458\u0435 |\u043A\u043E |\u0430\u043A\u043E|\u043E \u0438| \u043F\u043E|\u0430\u0432\u043E|\u0435 \u0441|\u0430 \u0438|\u0442\u0438 | \u0438\u043C| \u0434\u0430| \u0443 |\u0441\u0432\u0430|\u043D\u043E | \u0437\u0430|\u043E \u043D|\u0432\u0430 |\u0438 \u043F|\u0438\u043B\u0438|\u0432\u0430\u043A|\u043B\u0438 | \u043A\u043E|\u043D\u0435 | \u0438\u043B|\u043A\u043E\u0458| \u043D\u0435| \u0434\u0440|\u043E\u0441\u0442| \u0441\u043B|\u045A\u0430 |\u0438\u043C |\u0438 \u0441|\u0443 \u0441|\u0438 \u0438|\u0430\u0432\u0430|\u0438\u0458\u0435|\u0430 \u0443| \u0431\u0438|\u0441\u0442\u0432|\u0441\u0435 |\u0432\u0430\u045A|\u0430 \u0434|\u043E\u043C |\u0458\u0435\u0434|\u0431\u043E\u0434|\u043E\u0431\u043E|\u043B\u043E\u0431|\u0441\u043B\u043E| \u0441\u0435| \u0440\u0430|\u0438\u0445 |\u0441\u0442\u0438|\u0430 \u043D|\u045A\u0435 | \u043E\u0431| \u0458\u0435|\u043F\u0440\u0438|\u0434\u0440\u0443|\u0443 \u0438|\u0458\u0443 |\u043E \u0434|\u0438\u0442\u0438|\u0432\u043E\u0458|\u0440\u0430\u0437|\u0430\u045A\u0435|\u043E\u0432\u0430|\u0434\u0458\u0435| \u043E\u0441|\u0435 \u0438|\u043B\u043E |\u0435 \u043F|\u0430\u045A\u0430|\u0443\u0458\u0435|\u0438 \u0434|\u0431\u0440\u0430|\u0442\u0440\u0435| \u0442\u0440| \u0441\u0443|\u0443 \u0437|\u0430 \u043A|\u043E\u0433 |\u0443 \u043F|\u043E\u0458\u0435|\u0446\u0438\u0458|\u0440\u0435\u0431|\u0430 \u043E|\u0430 \u0431| \u045A\u0435|\u0438 \u0443|\u043C\u0438\u0458|\u043D\u0438 |\u043D\u043E\u0441|\u0431\u0430 |\u0435\u0434\u043D|\u0441\u0432\u043E|\u045A\u0435\u0433| \u0438\u0437|\u043F\u0440\u043E|\u0435 \u0434|\u0436\u0430\u0432|\u0431\u0438\u0442| \u043D\u0438|\u0438 \u043E|\u0441\u0442\u0430|\u0430 \u0437|\u0430\u0432\u043D|\u0432\u0458\u0435| \u043A\u0430|\u0431\u0438\u043B|\u043E\u0432\u043E|\u0430 \u0458|\u0430\u0458\u0443|\u0438\u0441\u0442|\u0438 \u043D|\u043D\u0438\u0445|\u0458\u0435\u043B|\u0442\u0443 |\u0440\u0435\u0434|\u0433\u043E\u0432| \u043E\u0434|\u0435 \u043E|\u043E\u0458\u0438| \u0441\u043C|\u0458\u0430 |\u043E \u043A|\u0438\u043B\u043E|\u0430\u0446\u0438|\u0435 \u0443|\u043F\u0440\u0435|\u043E \u043F|\u0435\u0431\u0430|\u0443 \u043E|\u0441\u0443 |\u0432\u0438\u043C|\u0438\u0447\u043D| \u0441\u0430| \u0434\u0458|\u0430 \u0442|\u0438\u0458\u0430|\u0448\u0442\u0438|\u0447\u043D\u043E|\u0440\u0436\u0430|\u0434\u0440\u0436|\u0441\u0442\u0443|\u0434\u043D\u0430|\u043E\u0434\u043D|\u0435\u043D\u0438|\u0437\u0430 |\u0438\u0432\u0430|\u043D\u043E\u043C|\u0435\u043C |\u0434\u0443 |\u0440\u0430\u043D|\u0432\u043D\u043E|\u0441\u043C\u0438|\u0458\u0435\u0440|\u0435 \u0431|\u0435 \u043D|\u0434\u0435 |\u043F\u043E\u0441|\u043C \u0438| \u0434\u043E|\u0443 \u0434|\u043D\u0430\u043A|\u0430 \u0440|\u043E\u0431\u0440| \u043C\u043E|\u043D\u0438\u043C|\u0435\u0433\u043E| \u043A\u0440|\u0442\u0438\u0442|\u043A\u0440\u0438|\u0432\u0435 |\u0430\u043D |\u0438\u043A\u043E|\u043D\u0438\u043A|\u043D\u0443 |\u0438 \u043C|\u043D\u043E\u0433|\u0435\u043D\u043E|\u0441\u043D\u043E|\u0435 \u043A|\u0442\u0443\u043F|\u0440\u0443\u0433|\u043A\u0430 |\u043E\u0434\u0430|\u0440\u0438\u0432|\u0432\u043E\u0459|\u0430\u043B\u043D|\u043C \u0441|\u0438\u0442\u0443|\u0430\u0448\u0442|\u0437\u0430\u0448|\u0430\u043D\u0438|\u0441\u0430\u043C| \u0441\u0442|\u0430\u043A\u0432|\u043E\u0432\u0438|\u043E\u0441\u043D|\u0440\u043E\u0434|\u0430\u0440\u043E| \u043C\u0438|\u0458\u0438 |\u0442\u0432\u0430|\u0434\u043D\u043E|\u043D\u0441\u0442|\u0430\u043A |\u0438\u0442\u0435|\u0459\u0443 |\u0432\u0438\u0447|\u0440\u0430\u0434|\u0443 \u043D|\u0443 \u043C| \u0442\u0430|\u0434\u0441\u0442|\u0442\u0438\u0432|\u043D\u0430\u0446|\u0440\u0438\u043C|\u043A\u043E\u043D|\u043A\u0443 |\u045A\u0443 |\u043E\u0434\u0443|\u0436\u0438\u0432|\u0430\u043C\u043E|\u0442\u0432\u043E|\u0442\u0435\u0459|\u043F\u043E\u0434|\u0435\u045B\u0443|\u0433 \u043F|\u043D\u043E\u0432|\u0438\u043D\u0430|\u043D\u0430\u0440| \u0432\u0458|\u0438 \u0431|\u043E\u0458 | \u043E\u0432|\u0430\u0432\u0435|\u0432\u0443 |\u0430\u043D\u0441|\u043E\u0458\u0430|\u0437\u043E\u0432|\u0430\u0437\u043E|\u0443\u0434\u0435|\u0431\u0443\u0434| \u0431\u0443|\u0435 \u0442|\u0438 \u0432|\u0435\u045A\u0430|\u0435\u0434\u0438|\u043D\u0438\u0446|\u043D\u0430\u043F|\u043C\u0458\u0435| \u0438\u0441|\u0441\u043B\u0443|\u0435\u0434\u0441|\u043E \u043E|\u0437\u0430\u043A|\u0438 \u043A|\u043C \u043F|\u0442\u043D\u043E|\u0438\u0432\u043E|\u0435\u0440\u0435|\u043D\u0438\u0447|\u043A\u0430\u043A|\u0430\u0434\u0430|\u0432\u043D\u0438|\u0443\u0433\u0438| \u0440\u043E|\u043C\u043E\u0432|\u0432\u0435\u043D|\u043E \u0441|\u0442\u043E |\u0442\u0435 | \u0432\u0440| \u0431\u0435|\u0430\u0440\u0430|\u043A\u043B\u0430| \u0431\u0440|\u0443 \u0431|\u0443 \u0443|\u0438 \u0442|\u043E\u043D\u0430| \u043E\u043D|\u0430\u0432\u0438|\u0458\u0430\u043B|\u0434\u043D\u0438| \u0441\u043A",
    srp: " \u043F\u0440| \u0438 |\u0440\u0430\u0432|\u043D\u0430 |\u043F\u0440\u0430| \u043D\u0430|\u043C\u0430 | \u0441\u0432|\u0438\u043C\u0430|\u0434\u0430 |\u0430 \u043F|\u0432\u043E |\u043A\u043E |\u0442\u0438 |\u0430\u0432\u043E| \u043F\u043E|\u0430 \u0438|\u0430\u043A\u043E|\u0430 \u0441| \u0437\u0430| \u0443 |\u043E \u0438| \u0438\u043C|\u0438 \u043F|\u0432\u0430 |\u0441\u0432\u0430|\u0432\u0430\u043A| \u0434\u0430|\u043E \u043D|\u0435 \u0441|\u043E\u0441\u0442| \u043A\u043E|\u045A\u0430 |\u043B\u0438 |\u0438\u043B\u0438|\u043D\u0435 |\u043E\u043C | \u043D\u0435|\u0430 \u043D| \u0441\u043B| \u0438\u043B|\u0458\u0435 | \u0434\u0440|\u0438 \u0441|\u043D\u043E |\u043A\u043E\u0458|\u0443 \u0441|\u0430\u0432\u0430| \u0440\u0430|\u043E\u0433 |\u0441\u043B\u043E|\u0458\u0443 |\u0438\u043C |\u0441\u0442\u0438|\u0431\u043E\u0434|\u043E\u0431\u043E|\u043B\u043E\u0431|\u0438\u0442\u0438|\u0430 \u043E|\u0441\u0442\u0432|\u0438 \u0443|\u0430 \u0434|\u043D\u0438 |\u0458\u0435\u0434|\u0443 \u043F|\u043F\u0440\u0438|\u0435\u0434\u043D| \u0431\u0438|\u0438 \u0438|\u0430 \u043A|\u043E \u0434|\u0441\u0442\u0430|\u0438\u0445 |\u0434\u0440\u0443|\u0430 \u0443| \u0458\u0435|\u0430\u045A\u0430| \u043E\u0441| \u043D\u0438|\u043D\u043E\u0441|\u043F\u0440\u043E|\u0430\u0458\u0443|\u0438 \u043E| \u0434\u0435| \u0441\u0443|\u0443 \u0438|\u0441\u0435 |\u045A\u0435 |\u0458\u0430 |\u043E\u0432\u0430|\u0438 \u0434|\u0446\u0438\u0458| \u043E\u0431|\u0443\u0458\u0435|\u0440\u0435\u0434|\u0436\u0430\u0432|\u0435 \u0438|\u0435 \u043F|\u0430 \u0458|\u0434\u043D\u0430| \u0441\u0435| \u043E\u0434|\u0432\u0435 | \u043A\u0430|\u0435\u043D\u0438|\u0440\u0436\u0430|\u0434\u0440\u0436|\u0430 \u0437|\u0430\u0432\u043D|\u0435\u045A\u0430|\u0430\u0446\u0438|\u0432\u043E\u0458|\u043E\u0432\u043E|\u0443 \u0443|\u043C \u0438|\u043E\u0458\u0430|\u0432\u0430\u045A| \u0438\u0437|\u0438\u0458\u0430|\u0443 \u0437|\u0430\u045A\u0435|\u0440\u0430\u043D|\u0435 \u043E|\u0440\u043E\u0434|\u0438 \u043D|\u0435 \u0431|\u0440\u0430\u0437|\u0437\u0430 | \u045A\u0435|\u0433\u043E\u0432|\u0438\u0447\u043D| \u0441\u0442|\u043D\u043E\u0432|\u0441\u043D\u043E|\u043E\u0441\u043D|\u0434\u0443 |\u043F\u0440\u0435| \u0442\u0440|\u0441\u0443 |\u0432\u0443 |\u043E\u0434\u043D|\u0430 \u0431|\u0441\u0432\u043E|\u045A\u0435\u0433|\u043D\u0438\u043C|\u043D\u0438\u0445|\u0442\u0443 |\u0442\u0438\u0442|\u0448\u0442\u0438|\u043A\u0443 |\u043D\u043E\u043C|\u0431\u0438\u0442|\u0435 \u0434|\u043C\u0435 |\u0438\u043A\u043E|\u0447\u043D\u043E|\u043E\u0458\u0438|\u043B\u043E |\u0432\u043D\u043E|\u043D\u0438\u043A|\u0438\u043A\u0430|\u0431\u0435\u0437|\u0430\u0440\u0430|\u0434\u0435 |\u0443 \u043E|\u0432\u0438\u043C|\u043D\u0430\u043A| \u0441\u0430|\u0440\u0438\u0432|\u0430\u0432\u0435|\u0430\u043D |\u0432\u043E\u0459| \u043A\u0440|\u043E \u043F|\u0441\u043C\u0435|\u0435 \u043A|\u043D\u043E\u0433|\u0458\u0438 | \u043E\u0432|\u0435 \u0443|\u0442\u0432\u0430|\u0431\u0440\u0430|\u0440\u0443\u0433|\u0440\u0435\u0431|\u0442\u0440\u0435|\u0443 \u0434|\u043E\u0434\u0430| \u043C\u043E| \u0432\u0440|\u0430\u0432\u0459|\u0443 \u043D|\u0435\u0433\u043E|\u0434\u0435\u043B|\u043C \u0441|\u043A\u0440\u0438|\u043E \u043A|\u0430\u0448\u0442|\u0437\u0430\u0448|\u045A\u0443 | \u0441\u043C|\u0430\u043D\u0438| \u043B\u0438|\u0434\u043D\u043E|\u0435\u0452\u0443|\u0430\u043B\u043D|\u043B\u0430 |\u0430\u043A\u0432|\u043E\u0458 |\u043A\u043E\u043C|\u0441\u0442\u0443|\u0443\u0433\u0438|\u0430\u0432\u0438|\u0430 \u0440|\u043A\u0430 |\u0440\u0430\u0434|\u043E\u0434\u0438|\u0432\u0438\u0447|\u0442\u0430\u0432|\u0438\u0442\u0443|\u0443\u0434\u0435|\u0431\u0443\u0434| \u0431\u0443|\u043F\u043E\u0442|\u043E\u0434\u0443|\u0436\u0438\u0432|\u0435\u0440\u0435|\u0442\u0432\u043E|\u0438\u043B\u043E|\u0431\u0438\u043B|\u0430\u0440\u043E|\u0435 \u043D|\u043E\u0432\u0438|\u043F\u043E\u0440|\u0435\u043D\u043E|\u0448\u0442\u0432|\u043D\u0430\u0446|\u043E\u0432\u0435|\u043C \u043F|\u0442\u0443\u043F|\u043F\u043E\u0441|\u0440\u0435\u043C|\u0434\u043D\u0438|\u0431\u0430 |\u043D\u0441\u0442|\u0430 \u0442|\u043E\u0458\u0443|\u0430\u0441\u0442|\u0438\u0432\u0430|\u0435 \u043C|\u0432\u0440\u0435|\u0432\u0459\u0430|\u043D\u0443 |\u0431\u0435\u0452|\u0438\u0441\u0442|\u0435\u043D |\u0442\u0435 |\u0434\u0441\u0442|\u0440\u043E\u0442|\u0437\u0430\u043A|\u0430\u043E |\u043A\u0430\u043E|\u0438 \u043A|\u0458\u0443\u045B|\u043E \u0441|\u0441\u0442 |\u0441\u0430\u043C|\u043C \u043D|\u0442\u0435\u0440|\u043D\u0430\u0440| \u043C\u0435|\u0438 \u043C|\u043A\u043E\u043B|\u0435 \u0440|\u0443\u0448\u0442|\u0440\u0443\u0448|\u0432\u0435\u0440|\u043A\u0430\u043A| \u0431\u0435|\u0438 \u0431|\u043A\u043B\u0430|\u0430\u0434\u0430|\u0435\u0431\u0430|\u0435\u043D\u0430|\u043E\u043D\u0430| \u043E\u043D|\u0442\u0432\u0443|\u0430\u043D\u0441| \u0434\u043E|\u0440\u0430\u043A|\u0441\u043B\u0443|\u0438 \u0432|\u043D\u0438\u0446|\u0443 \u043A|\u043C\u0435\u043D|\u0432\u0440\u0448|\u0435\u043C\u0435|\u0435\u0434\u0441|\u0438\u0432\u0438|\u043E \u043E|\u0458\u0430\u0432",
    uzn: "\u0430\u043D |\u043B\u0430\u0440|\u0433\u0430 |\u0438\u0440 | \u0431\u0438|\u0430\u0440 | \u0432\u0430|\u0434\u0430 |\u0438\u0433\u0430| \u04B3\u0443|\u0432\u0430 |\u0431\u0438\u0440|\u0443\u049B\u0443|\u049B\u0443\u049B|\u04B3\u0443\u049B| \u04B3\u0430|\u0440 \u0431|\u0433\u0430\u043D|\u0438\u0448 |\u0438\u0434\u0430| \u0442\u0430|\u0430 \u044D|\u0438\u043D\u0438|\u0430\u0434\u0438|\u043D\u0433 |\u0434\u0438\u0440|\u0438\u0448\u0438|\u043B\u0438\u043A|\u043B\u0438\u0448|\u0438\u0439 |\u0438\u043B\u0438|\u0430\u0440\u0438|\u0443\u049B\u0438|\u04B3\u0430\u0440|\u043B\u0430\u043D|\u0438\u043D\u0433|\u0448\u0438 |\u0434\u0430\u043D|\u043D\u0438\u043D|\u0438\u043D\u0441|\u043A\u0438\u043D|\u0441\u043E\u043D|\u043D\u0441\u043E| \u0438\u043D| \u043C\u0443|\u049B\u0438\u0433| \u043C\u0430|\u043E\u043D |\u0440 \u0438| \u0431\u045E|\u044D\u0433\u0430| \u044D\u0433| \u045E\u0437|\u043D\u0438 |\u0431\u045E\u043B|\u0433\u0430\u0434|\u0438 \u0431|\u043A\u0438 |\u0438\u043B\u0430|\u0451\u043A\u0438| \u0451\u043A|\u0430 \u0431|\u043D \u0431|\u0438\u043D |\u0440 \u04B3|\u0430\u043B\u0430|\u044D\u0440\u043A| \u044D\u0440|\u043B\u0433\u0430| \u049B\u0430|\u0440\u043A\u0438|\u0448 \u04B3|\u0438 \u04B3|\u043D \u043C| \u0431\u043E| \u0431\u0430|\u0438\u043A |\u0430\u0440\u0430|\u0438\u0433\u0438|\u043B\u0438\u0433|\u0440\u0438 |\u049B\u0438\u043B|\u0430 \u0442|\u0431\u0438\u043B| \u044D\u0442|\u043D\u0438\u0448|\u043D\u043B\u0438|\u043A\u043B\u0430|\u0438 \u0432|\u0431\u043E\u0448|\u044D\u0442\u0438|\u0430\u043D\u0438|\u0438\u043C |\u0438 \u043C|\u043E\u043B\u0438|\u049B\u043B\u0430|\u0430 \u04B3|\u043B\u0430\u0448|\u0430\u0442\u043B|\u0442\u0438\u043B|\u0430 \u049B| \u043E\u043B|\u043E\u0441\u0438|\u043C\u0430\u0441|\u049B\u0430\u0440|\u0438\u043D\u043B|\u043B\u0430\u0442| \u049B\u0438|\u0442\u0430\u044A|\u04B3\u0430\u043C|\u0433\u0438 |\u0438\u0431 |\u043C\u043B\u0430|\u045E\u0437 |\u043D \u044D|\u043C\u0443\u043C| \u0434\u0430| \u0431\u0443|\u0430\u0442 |\u0448 \u0432|\u0443\u043D |\u0430\u0442\u0438|\u043C\u043A\u0438|\u0443\u043C\u043A|\u0442\u043B\u0430|\u0438\u0440\u043E|\u045E\u043B\u0438|\u0431\u0430\u0440|\u0438\u0440\u0438|\u0440\u0438\u0448|\u0438\u044F\u0442|\u0430\u043B\u0438| \u0431\u0435| \u049B\u043E|\u0430 \u0448|\u0430\u0440\u043E| \u043A\u0435|\u0438 \u0442|\u0440\u043B\u0430| \u0442\u0435|\u0447\u0430 |\u0440\u0447\u0430|\u0430\u0440\u0447|\u0430 \u045E| \u0448\u0443|\u0442\u0438\u0448|\u043D \u04B3|\u0442\u0433\u0430| \u0441\u0430|\u0430\u0441\u0438| \u0445\u0430|\u0440\u0430\u043A|\u043B\u0438\u043D|\u043E\u043B\u0430|\u0438\u043C\u043E|\u0448\u049B\u0430|\u043B\u0438 | \u0442\u0443|\u0430\u043C\u043B|\u043B\u043B\u0430|\u0441\u0438\u0434|\u043D \u045E| \u0430\u0441|\u043D\u0438\u0434|\u0430 \u0438| \u043A\u0438|\u043D \u0442|\u043D\u0434\u0430|\u043A \u0431|\u0435\u0440\u0430|\u043E\u0448\u049B|\u0441\u0438\u0437|\u043E\u0440 |\u0430 \u043C|\u0440 \u0432|\u0435\u043D\u0433|\u0442\u0435\u043D|\u043C\u0430\u0442|\u043C\u0434\u0430|\u0430\u043C\u0434|\u043B\u0438\u043C|\u0439 \u0442|\u044F\u0442 |\u0438 \u0430|\u0438\u043D\u043E|\u0438\u043B\u0433| \u0442\u043E|\u0442\u043D\u0438|\u0430\u043D\u0430|\u0430\u0441 |\u044D\u043C\u0430| \u044D\u043C|\u0430 \u0451| \u0448\u0430|\u0430\u0448 |\u0430 \u0430|\u0442\u0430\u0440|\u043A\u0430\u0442|\u0430\u043A\u0430|\u0430\u043A | \u0434\u0435|\u0430\u0437\u0430|\u0438\u043B\u043B|\u0441\u0438\u0439| \u0441\u0438| \u0441\u043E|\u0443\u049B\u043B|\u043D \u049B|\u043E\u0434\u0430|\u044A\u043B\u0438|\u0430\u044A\u043B|\u043D\u0438\u043A|\u0430\u0434\u0430| \u043D\u0438|\u0442\u0434\u0430|\u0433\u0438\u043D|\u0443\u043D\u0438|\u0441\u0438\u0442|\u0430\u0439 |\u049B\u043E\u043D|\u043D \u043E| \u0436\u0430|\u043A\u0438\u043C|\u0435\u0447 |\u04B3\u0435\u0447| \u04B3\u0435|\u045E\u0437\u0438|\u043B\u0430\u043A|\u043A\u0435\u0440|\u0438\u043A\u043B|\u043B\u043B\u0438|\u0443\u0440 |\u0437\u0430\u0440|\u0448\u043B\u0430|\u0440\u0438\u0433|\u0438\u0440\u043B|\u0434\u0430\u043C|\u043A\u043E\u04B3|\u0438\u043A\u043E|\u0430 \u0434|\u0430\u043C |\u043D \u0432|\u0440\u0442\u0438|\u0442\u0438\u0431|\u0442\u0430\u043B| \u0438\u0448|\u0447\u0443\u043D|\u0443\u0447\u0443| \u0443\u0447|\u0441\u043B\u0430|\u0430 \u0443|\u0440\u0438\u043D|\u0441\u043E\u0441|\u0430\u0441\u043E| \u0443\u043D|\u043D\u0430 | \u043A\u0430|\u043C\u0443\u04B3|\u0434\u0438\u0433|\u0447 \u043A|\u0430\u0441\u043B|\u043B\u043C\u0430|\u0440\u0430 |\u0431\u0443 |\u0445\u0430\u043B|\u045E\u043B\u0433|\u0438 \u043A|\u0435\u043A\u043B|\u0440 \u0434|\u049B\u0430\u0442|\u0430\u0433\u0430|\u0438 \u049B|\u043E\u0438\u0439|\u043C\u0438\u043B| \u043C\u0438|\u049B\u0430 |\u0438 \u0441|\u0436\u0438\u043D| \u0436\u0438|\u0441\u0438\u043D|\u0440\u043E\u0440|\u0430 \u0432|\u043B\u0430\u0434|\u0430 \u043E|\u0442\u043B\u0438|\u043C\u0438\u044F|\u043D \u0438|\u0430\u0431 |\u0442\u0438\u0440|\u0437 \u043C|\u0434\u0430\u0432|\u0440\u0433\u0430|\u0430\u0433\u0438|\u0430 \u043A|\u043D\u043B\u0430|\u0430\u049B\u0442|\u0432\u0430\u049B|\u0430\u0440\u0442|\u0430\u0451\u0442|\u043B\u0430\u0431",
    azj: " \u0432\u04D9|\u0432\u04D9 |\u04D9\u0440 |\u0438\u0440 | \u04BB\u04D9| \u0431\u0438| \u04BB\u04AF| \u043E\u043B|\u04AF\u0433\u0443|\u04BB\u04AF\u0433|\u0433\u0443\u0433|\u043D\u0430 |\u0438\u043D |\u043B\u0430\u0440|\u04BB\u04D9\u0440|\u0434\u04D9 | \u0448\u04D9|\u0431\u0438\u0440|\u043B\u04D9\u0440|\u043B\u0438\u043A|\u043C\u0430\u043B|\u0440 \u0431|\u043B\u043C\u0430|\u0440 \u04BB| \u0442\u04D9|\u04D9\u0445\u0441|\u0448\u04D9\u0445|\u04D9\u043D |\u0434\u0438\u0440|\u0443\u0433\u0443|\u0443\u043D\u0430|\u0430\u043D |\u0430\u043B\u0438|\u0430 \u043C| \u043C\u0430|\u0438\u043A\u0434|\u0438\u043D\u0438|\u0440 \u0448|\u0434\u04D9\u043D|\u0430\u0440 |\u0438\u043B\u04D9|\u0433\u0443\u043D|\u0430\u0433 |\u0430\u0441\u044B| \u0458\u0430|\u043C\u04D9\u043A|\u0458\u04D9\u0442| \u043C\u04D9| \u043C\u04AF|\u043A\u0434\u0438|\u04D9\u0441\u0438|\u04D9\u043A |\u0438\u043B\u043C|\u043D\u0438\u043D|\u043D\u0434\u04D9|\u043E\u043B\u043C|\u04D9\u0442\u0438|\u04D9 \u0458|\u0441\u0438\u043D|\u0445\u0441 |\u043D\u0434\u0430|\u043B\u043C\u04D9|\u0458\u0458\u04D9|\u0438 \u0432| \u0433\u0430| \u0430\u0437|\u043E\u043B\u0443|\u0438\u0458\u0458|\u0458\u0430 |\u0438\u043D\u0434|\u0437\u0430\u0434|\u0433\u043B\u0430|\u04AF\u043D |\u043D\u0438 |\u043B\u04D9 |\u0442\u0438\u043D|\u043D \u043C|\u0430\u0437\u0430|\u0430\u0440\u044B|\u04D9\u0442 |\u043D \u0442|\u043C\u0430\u0433|\u043B\u0443\u043D|\u043B\u044B\u0433|\u04D9 \u0431|\u0443\u043D |\u043D\u0443\u043D|\u0433 \u0432|\u043D \u04BB|\u0434\u0430\u043D|\u044B\u043D | \u0435\u0442|\u0442\u043C\u04D9|\u04D9\u0440\u04D9| \u04E9\u0437|\u0434\u0430 |\u04D9 \u0432| \u043E\u043D|\u04D9 \u0430|\u044B\u043D\u0430|\u044B\u043D\u044B|\u0431\u0438\u043B|\u0430 \u0431|\u0441\u044B |\u0438\u043B |\u04D9\u043C\u0438|\u0430\u0440\u0430|\u0441\u0438 | \u0434\u0438|\u04D9 \u043C|\u04D9\u0440\u0438|\u0440\u043B\u04D9| \u0432\u0430|\u04D9 \u04BB|\u0435\u0442\u043C|\u044B\u0493\u044B|\u0430\u043C\u0430|\u0434\u043B\u044B|\u0430\u0434\u043B|\u0440\u0438\u043D|\u0431\u04D9\u0440|\u0440\u044B\u043D|\u043D \u0438|\u043C\u04AF\u0434|\u043D\u044B\u043D| \u04BB\u0435|\u043C\u0430\u0441|\u0438\u043A |\u043D \u0430|\u0434\u0438\u043B|\u0430\u043B\u044B|\u0438\u0440\u043B|\u04D9\u043B\u04D9|\u04AF\u0434\u0430|\u0441\u044B\u043D|\u044B\u043D\u0434|\u0445\u0441\u0438|\u043B\u0438 |\u04D9 \u0434|\u043D\u04D9 | \u0431\u04D9|\u04D9\u0458\u0430| \u0438\u043D|\u04D9 \u0438|\u043B\u04D9\u0442| \u0441\u04D9|\u043D\u044B | \u0438\u0448|\u0430\u043D\u044B|\u0435\u0447 |\u04BB\u0435\u0447|\u0433 \u04BB|\u0435\u0458\u043D|\u04D9 \u0435|\u0434\u044B\u0440| \u0434\u0430|\u0430\u0441\u0438|\u0440\u044B |\u0438\u0448 |\u0438\u0444\u0430|\u043B\u044B\u0493|\u0438 \u0441|\u0444\u0438\u04D9|\u0430\u0444\u0438|\u0434\u0430\u0444| \u0435\u0434|\u043C\u04D9\u0437|\u0443 \u0432|\u043A\u0438\u043B| \u04BB\u0430|\u043E\u043B\u0430|\u043D \u0432|\u04D9\u043D\u0438|\u044B\u0440 |\u0443\u0433 |\u0443\u043D\u043C| \u0431\u0443| \u0430\u0441|\u0441\u0438\u0430|\u043E\u0441\u0438|\u0441\u043E\u0441|\u0438\u043B\u0438|\u044B\u0434\u044B|\u043B\u044B\u0434|\u043D\u043C\u0430|\u044B\u0433 |\u0438\u043D\u04D9|\u04D9\u0440\u0430|\u0441\u0438\u043B|\u0445\u0438\u043B|\u0430\u0445\u0438|\u0434\u0430\u0445|\u0430\u0434\u04D9|\u043C\u0430\u043D|\u0430 \u04BB|\u04D9 \u043E|\u043E\u043D\u0443|\u0430 \u0433|\u04D9\u0437 | \u043A\u0438|\u0441\u0435\u0447| \u0441\u0435|\u044B \u04BB|\u043C\u0438\u043D|\u043B\u0430\u043D|\u04D9\u0434\u04D9|\u0431\u0443 |\u0440\u0430\u0433|\u043B\u044B |\u044B\u043B\u044B|\u0430\u043B |\u04D9 \u0433|\u0440 \u0432|\u043D\u043B\u0430|\u04BB\u0441\u0438|\u04D9\u04BB\u0441|\u0442\u04D9\u04BB|\u04E9\u0437 |\u0438\u0441\u0442| \u0438\u0441|\u043C\u04D9\u0441| \u04D9\u0441|\u0438\u043D\u0430|\u04D9 \u0442|\u04D9\u0442\u043B|\u0430 \u0432|\u0438\u04D9 |\u043D \u0431|\u0442\u04D9\u0440| \u0442\u0430| \u04B9\u04D9|\u0435\u0434\u0438|\u0430\u043B\u0430|\u043A\u0438\u043C|\u0433\u0443 |\u0438 \u0442|\u0443\u043B\u043C|\u043C\u04D9\u04BB|\u043D \u043E|\u0430\u0458\u0430|\u044B \u043E|\u0438\u0430\u043B| \u0441\u043E|\u0438\u043B\u043B|\u0441\u0438\u0458| \u0434\u04D9|\u0432\u0430\u0440|\u0438\u043D\u0441|\u043C\u0438 |\u0493\u044B |\u043D\u0438\u043A|\u0440 \u0438|\u0430\u0433\u043B|\u043A \u04BB|\u0442\u04D9\u043C|\u0442\u0430\u043C|\u0447\u04AF\u043D|\u04AF\u0447\u04AF| \u04AF\u0447|\u0493\u044B\u043D|\u0441\u0430\u0441|\u04D9\u0441\u0430|\u0437 \u04BB|\u04D9\u043C\u04D9|\u0437\u0430\u043C| \u0437\u0430|\u0441\u0442\u0438|\u0440\u04D9\u0444|\u043D \u0435|\u0440 \u0430|\u0438\u043B\u0434|\u04BB\u04D9\u043C|\u044B\u0433\u043B|\u0458\u0430\u043D|\u043C\u0430\u0458|\u043D \u04D9|\u043C\u04D9\u043D|\u043C\u0438\u043B| \u043C\u0438|\u04D9\u0433\u0438|\u0434\u0438\u043D|\u043D \u0434|\u0442\u04AF\u043D| \u0434\u04E9|\u043C\u0438\u0458|\u043A\u0430\u04BB|\u0438\u043A\u0430| \u043D\u0438|\u0444\u0430\u0434|\u0442\u0438\u0444|\u043B \u043E|\u0441\u04D9\u0440|\u0458\u043D\u0438| \u0435\u0458|\u0430\u043D\u0430|\u043B\u04D9\u043D|\u0430\u043C |\u0440\u0438\u043B|\u0430\u0458\u04D9|\u0430\u0448\u044B",
    koi: "\u043D\u044B |\u04E7\u043D | \u0431\u044B|\u0434\u0430 | \u043F\u0440|\u043B\u04E7\u043D|\u0440\u0430\u0432| \u043C\u043E|\u043F\u0440\u0430| \u0434\u0430|\u0431\u044B\u0434| \u0432\u0435|\u043E\u0440\u0442|\u043B\u04E7 |\u04E7\u0439 |\u043C\u043E\u0440|\u04E7\u043C |\u0430\u0432\u043E| \u043D\u0435|\u0432\u043E |\u044B\u0434 |\u044B\u0441 |\u043D\u04E7\u0439|\u044B\u043D |\u043C \u043F|\u0434 \u043C|\u044B\u043D\u044B|\u0442\u043D\u044B| \u0430\u0441|\u0442\u04E7\u043C|\u043B\u044C\u043D| \u044D\u043C|\u0432\u0435\u0440|\u0441\u044C |\u044C\u043D\u04E7|\u044D\u043C |\u043D \u044D|\u0442\u043B\u04E7| \u043A\u044B|\u0441\u04E7 | \u043F\u043E|\u0435\u0440\u043C|\u0441\u044C\u04E7|\u0440\u0442\u043B|\u0430\u043B\u044C| \u043A\u04E7|\u044D\u0437 | \u04E7\u0442|\u04E7 \u0432|\u0442\u043E |\u0435\u0442\u043E|\u043D\u0435\u0442|\u044B\u043B\u04E7| \u043A\u043E|\u0442\u0448\u04E7| \u043E\u0442| \u0438 |\u044B \u0441|\u0431\u044B |\u04E7 \u0431|\u0441\u0442\u0432|\u043A\u04E7\u0440| \u0432\u04E7|\u0448\u04E7\u043C|\u043A\u044B\u0442|\u0442\u0430 |\u043D\u0430 |\u0437 \u0432| \u0441\u0435| \u0434\u043E|\u0432\u043E\u043B|\u04E7\u0441 | \u0441\u044B|\u044B \u0430|\u043E\u043B\u0430|\u0440\u043C\u04E7|\u0430\u0441 |\u043E\u0437 | \u043E\u0437| \u0441\u0456|\u0430 \u0441|\u0442\u0432\u043E|\u0441 \u043E| \u0432\u044B|\u043B\u0456\u0441|\u04E7 \u043A|\u044B\u0442\u0448|\u04E7 \u0434|\u0438\u0441 |\u0456\u0441\u044C|\u04E7\u0442\u043D|\u0430\u0441\u044C| \u043E\u043B| \u043D\u0430|\u0430\u0446\u0438| \u044D\u0442|\u0430 \u0432|\u0437\u043B\u04E7|\u0441\u0435\u0442| \u0432\u043E| \u0447\u0443|\u043B\u0430\u0441|\u043B\u0430\u043D|\u043C\u04E7 |\u0442\u044B\u0441|\u0440\u0442\u044B|\u04E7\u0440\u0442|\u044B \u043F|\u04E7\u0442\u043B|\u043E \u0441|\u044D\u0442\u0430|\u0434\u0437 |\u043A\u04E7\u0442|\u04E7\u0434\u043D|\u0432\u043D\u044B| \u043C\u044B|\u043D \u043D|\u0443\u0434\u0436| \u0443\u0434|\u0432\u044B\u043B|\u04E7 \u043C|\u0440\u0442\u0456|\u043E\u0440\u0439|\u0438\u0441\u044C| \u0441\u043E|\u0432\u043E\u044D|\u044B\u0434\u04E7|\u0439 \u043E|\u043A\u043E\u043B| \u0433\u043E|\u0441 \u0441|\u0441\u0441\u0438|\u0441\u044B\u043B|\u044B\u0441\u043B|\u0439\u044B\u043D|\u043A\u0438\u043D|\u043E\u043B\u04E7|\u0442\u04E7\u043D| \u0441\u044C|\u0430\u043D\u0430|\u04E7\u0440 |\u0446\u0438\u044F|\u0430 \u0434|\u04E7\u043C\u04E7| \u0432\u0438|\u0437 \u043A| \u044D\u0437|\u044B \u0431|\u0442\u04E7\u0433|\u04E7\u0442 |\u043C\u04E7\u0434|\u0435\u0441\u0442|\u043E\u0441\u0442|\u04E7\u043D\u044B|\u0442\u0438\u0440|\u043E\u0442\u0438|\u0443\u043A\u04E7|\u0447\u0443\u043A|\u043D \u043F|\u043E\u043D\u0434|\u043F\u043E\u043D|\u0441\u043B\u04E7|\u043A\u0435\u0440| \u043A\u0435| \u043E\u0431|\u0441\u0438\u0441|\u0441\u0443\u0434|\u0430 \u043D|\u0434\u043E\u0440|\u043A\u043E\u043D|\u043D\u0435\u043A|\u043D \u0431|\u043B\u04E7\u0442|\u0441 \u0432|\u0442\u0456 |\u044C\u04E7\u0440|\u0442\u0440\u0430| \u0441\u0442|\u043D\u0430\u043B|\u043E\u043D\u0430|\u043D\u0430\u0446|\u043D \u043A|\u043A\u04E7\u0434|\u04E7\u0433 |\u0441\u043A\u04E7|\u0442\u044C |\u0435\u0442\u04E7|\u0434\u04E7\u0441|\u0431\u044B\u0442|\u0440\u043D\u044B|\u04E7 \u043D|\u0442\u0441\u04E7|\u0440\u0440\u0435|\u0430 \u0431|\u043D\u0434\u0430|\u0441 \u0434|\u0430\u0441\u0441|\u044B \u043A|\u0430\u0441\u043B| \u043B\u043E|\u044C\u043D\u044B|\u0441\u044C\u043D|\u044B \u043C|\u0435\u043A\u0438|\u044B \u0434| \u043C\u04E7|\u044C \u043C|\u044B \u043D|\u044B\u0442\u04E7| \u043C\u0435|\u0440\u0439\u04E7|\u0438\u0430\u043B|\u0439 \u0434|\u0438\u0442\u04E7|\u0430 \u043A|\u04E7\u0441\u044C|\u043C\u04E7\u0441|\u043E\u0432\u043D|\u0437\u044B\u043D|\u0430 \u043F|\u043E\u0442\u0441| \u043B\u0438|\u043E\u043B\u044F|\u04E7 \u0430|\u043E\u0441\u0443|\u04E7\u044F |\u043D\u04E7\u044F|\u0435\u0437\u043B|\u0440\u0435\u0437|\u043C\u0435\u0434|\u0441 \u043C| \u0441\u044D|\u044C \u043A|\u0440\u0439\u044B|\u0430\u043A\u043E|\u0437\u0430\u043A| \u0437\u0430|\u044C\u044B\u043D|\u043D\u043D\u0451|\u043C\u04E7\u043B|\u0443\u043C\u04E7| \u0443\u043C|\u044B \u0443|\u043D \u0432|\u043C \u0434|\u043D \u0441| \u0434\u0437|\u043D \u043E|\u0440\u0430\u043D|\u0441\u0442\u0440|\u043E\u0437\u044C|\u043F\u043E\u0437|\u0437 \u043F|\u043E \u0434|\u0446\u0438\u0430|\u043E\u0446\u0438|\u0441\u043E\u0446|\u0438\u043E\u043D|\u0430 \u043C|\u0435\u0441\u043A|\u0447\u0435\u0441|\u043D\u04E7 |\u0437 \u0434|\u0442\u0441\u044C|\u0431\u04E7\u0440| \u0431\u04E7| \u043E\u0432|\u0432\u0435\u0441|\u043A\u044B\u0434|\u04E7 \u0441|\u0432\u043E\u044B|\u043A\u043E\u0434|\u0442\u043A\u043E|\u04E7\u0442\u043A|\u043E\u043B\u044C|\u0434\u0431\u044B|\u0435\u0434\u0431|\u0441\u044C\u044B|\u0447\u044B\u043D|\u0442\u0447\u044B|\u04E7\u0442\u0447|\u0442\u043B\u0430|\u043C\u04E7\u043D|\u0441\u043B\u0430|\u0439\u04E7\u0437| \u0439\u04E7|\u0442 \u0432|\u044B \u0438|\u0435\u0437 |\u043E \u0432|\u043E\u043D\u044B|\u0439\u04E7 |\u0430\u043D\u043D|\u04E7\u043B\u044C| \u043F\u044B|\u0430\u043D |\u043D\u04E7\u0441|\u043D\u0438\u0442| \u0441\u0443|\u043C \u0441",
    bel: " \u043F\u0440|\u043F\u0440\u0430| \u0456 |\u0430\u0432\u0430|\u043D\u0430 |\u0440\u0430\u0432| \u043D\u0430| \u043F\u0430|\u043D\u044B |\u0432\u0430 |\u0430\u0431\u043E|\u0446\u044C | \u0430\u0431|\u0430\u0435 | \u043C\u0430|\u0430\u0432\u0435|\u0430\u043D\u043D|\u0430\u0446\u044B|\u0441\u0432\u0430| \u0441\u0432|\u0435 \u043F|\u043B\u044C\u043D| \u0447\u0430|\u043D\u0435 |\u043D\u043D\u044F|\u0430\u043B\u0430|\u0430 \u043D|\u0430\u0439 |\u043B\u0430\u0432|\u0447\u0430\u043B| \u043A\u043E| \u0430\u0434| \u043D\u0435|\u0433\u0430 |\u043E\u0436\u043D|\u043A\u043E\u0436|\u0432\u0435\u043A|\u043D\u044F | \u044F\u043A|\u0436\u043D\u044B|\u044B \u0447|\u043C\u0430\u0435|\u0430 \u043F|\u0430\u0433\u0430|\u0431\u043E |\u0435\u043A |\u0430 \u0430|\u0446\u0430 |\u0446\u0446\u0430| \u045E | \u0437\u0430|\u044B\u0445 |\u043F\u0430\u0432|\u0430 \u0441|\u0433\u043E |\u0432\u0456\u043D|\u0434\u043D\u0430|\u0431\u043E\u0434|\u043C\u0456 |\u0432\u0430\u0431|\u0432\u0430\u043D|\u0430\u043C | \u0432\u044B| \u0441\u0430| \u0434\u0430|\u0441\u0442\u0430|\u0430\u0432\u0456|\u043D\u043D\u0435|\u0430\u0441\u0446|\u043D\u0430\u0439|\u0446\u044B\u044F|\u043D\u0430\u0433|\u0430\u0440\u0430|\u0456 \u043D|\u043A \u043C|\u044F\u0433\u043E| \u044F\u0433|\u044C\u043D\u0430|\u043F\u0440\u044B|\u0430\u0446\u044C|\u0456 \u043F|\u043E\u0434\u043D|\u0441\u0442\u0432|\u0430\u043C\u0430|\u043D\u044B\u0445| \u0431\u044B|\u0442\u0432\u0430|\u0434\u0437\u0435|\u0430\u043B\u044C| \u0440\u0430|\u043D\u0456 |\u0456 \u0441|\u0456 \u0430|\u044B\u0446\u044C|\u0430 \u0431|\u0435\u043D\u043D|\u043B\u0435\u043D|\u0446\u0456 |\u043E\u045E\u043D|\u044B\u043C |\u0440\u0430\u0446|\u0456\u043D\u043D|\u0456\u0445 | \u0430\u0441| \u0442\u0430|\u0442\u043E |\u043D\u0430\u0441|\u044F\u043A\u0456| \u0434\u0437|\u0447\u044B\u043D|\u043E\u043B\u044C|\u0456 \u0434|\u0430\u0432\u043E|\u0430\u0434 | \u043D\u0456|\u0441\u0446\u0456|\u044B\u043C\u0456|\u043D\u044B\u043C|\u0431\u044B\u0446|\u044F \u043F|\u044C\u043D\u044B|\u044B\u044F |\u0430\u0440\u043E|\u0430\u043D\u0430|\u0456\u043D\u0430|\u0456 \u0456|\u0440\u0430\u0434| \u0433\u0440|\u043B\u044F |\u045E\u043B\u0435|\u043E \u043F|\u0430 \u045E|\u0440\u044B\u043C|\u043F\u0430\u0434|\u044B\u0456 | \u0456\u043D|\u0430\u043C\u0456|\u0434\u0437\u044F|\u0440\u0430\u043C|\u0446\u044B\u0456|\u0430\u0431\u0430|\u0430 \u0456|\u0434\u0443 |\u0436\u043D\u0430|\u045E\u043D\u0430|\u043D\u0430\u043B|\u043D\u0430\u0446|\u0440\u044B |\u044D\u0442\u0430|\u0433\u044D\u0442| \u0433\u044D|\u043D\u0435\u043D|\u0434\u0430 |\u0430\u0445 |\u0433\u0440\u0430|\u043A\u0430\u0446|\u0443\u043A\u0430|\u0430 \u0437|\u043A\u0456 |\u0430\u0434\u0441|\u045E \u0456|\u043D\u0441\u0442|\u044D\u043D\u043D|\u044F \u0430|\u043D\u043D\u0456|\u043E\u0434\u0443|\u0430 \u0440|\u043D\u043D\u0430|\u0445\u043E\u0434|\u043D\u0430\u043D|\u043F\u0435\u0440|\u0445 \u043F| \u0443 |\u0430\u0434\u0437|\u0456 \u0440|\u043C\u0430\u0434|\u043C \u043F|\u0435 \u043C|\u0430\u0434\u0443|\u0434\u0441\u0442|\u0434\u043B\u044F| \u0434\u043B|\u043E\u045E |\u043D\u0430\u0435|\u0456 \u043C|\u0430\u043A\u043E| \u043A\u0430|\u044B \u045E|\u0431\u0430\u0440|\u0435 \u0430|\u0430\u0446\u0446|\u0443\u044E |\u044B\u0446\u0446|\u0441\u0430\u043C|\u044F\u045E\u043B|\u0430\u043B\u0435|\u0440\u043E\u0434|\u0440\u0430\u0431| \u043F\u0435|\u0448\u0442\u043E| \u045E\u0441|\u0430\u0434\u043D| \u0441\u0443|\u0440\u043E\u045E| \u0440\u043E|\u0434\u0443\u043A|\u043B\u044E\u0431|\u044C \u0441| \u0448\u043B|\u0440\u0430\u0437|\u043D\u0430\u0432|\u0437\u043D\u0430|\u0432\u043E\u043B|\u0443\u0434\u0437|\u0430\u0434\u0430|\u0436\u044B\u0446|\u0447\u043D\u0430|\u0432\u0435 |\u0430 \u0442|\u0430\u0441\u043D|\u0441\u0430\u0446|\u0435\u0440\u0430| \u0440\u044D|\u044F\u043A\u043E|\u043A\u043B\u0430|\u0430\u043D\u044B| \u0448\u0442|\u044C \u0443|\u0430\u044E\u0446|\u043D\u0430\u0440| \u0443\u0441|\u0441\u043E\u0431|\u0430\u0441\u043E|\u043F\u0430\u043C|\u044F \u045E|\u0430\u0432\u044F|\u0447\u044D\u043D|\u0432\u043E\u045E|\u0442\u0430\u043A|\u043D\u0443 |\u044E \u0430|\u044C \u043F|\u0437\u0430\u043A|\u043A\u0430\u0440|\u0435 \u0456|\u044C \u0430|\u0431\u0435\u0441|\u0456\u044F |\u043A\u0456\u044F|\u0445 \u0456|\u0437\u0430\u0431|\u0430\u0441\u0430|\u0456\u043C |\u0436\u0430\u0432|\u0456 \u0437|\u043B\u0435\u0436|\u0442\u0430\u043D|\u0430\u0445\u043E|\u044F\u043B\u044C|\u044B\u044F\u043B|\u043E \u0441|\u044F\u043D\u0430|\u043A\u0430\u043D|\u0430\u043A\u0430|\u0456\u043D\u0448|\u0430\u043B\u0456|\u0432\u044B | \u043C\u043E|\u043D\u0430\u0445|\u044F \u044F|\u043C \u043D|\u043E\u0433\u0430| \u0431\u0435|\u0439 \u0434|\u043E \u0430| \u0441\u0442|\u0435\u043D\u044B|\u0456 \u045E|\u0430 \u0434|\u0435\u0441\u043F|\u0448\u043B\u044E|\u0446\u0446\u044F|\u044B \u0456|\u044B\u0441\u0442|\u0440\u044B\u0441|\u043B\u044E\u0447|\u043A\u043B\u044E|\u0442\u0430\u0446|\u0443\u043B\u044C|\u044B\u043D\u0441|\u0430\u0447\u044B|\u0441\u043F\u0440| \u0441\u043F|\u0430\u045E |\u044B\u043C\u0430|\u0430\u0440\u044B|\u043A\u0430\u043C|\u0435 \u045E|\u0456 \u043A|\u043A\u043E\u043D",
    bul: " \u043D\u0430|\u043D\u0430 | \u043F\u0440|\u0442\u043E | \u0438 |\u0440\u0430\u0432|\u0434\u0430 | \u0434\u0430|\u043F\u0440\u0430|\u0441\u0442\u0432|\u0432\u0430 |\u0430 \u0441|\u0430 \u043F|\u0432\u043E |\u043D\u043E |\u0438\u0442\u0435|\u0442\u0430 |\u043E \u0438|\u0435\u043D\u0438| \u0437\u0430|\u043D\u0435 | \u043D\u0435|\u0430 \u043D| \u0432\u0441|\u0432\u0430\u043D|\u0430\u0432\u043E|\u043E\u0442\u043E|\u0435 \u043D|\u043E \u043D|\u0430 \u0438|\u043A\u0438 |\u0438\u0435 |\u0442\u0435 |\u043D\u0438 |\u0438\u043C\u0430| \u0438\u043C|\u043B\u0438 |\u0438\u043B\u0438|\u0438\u044F | \u043F\u043E|\u043E\u0432\u0435|\u0430\u043D\u0435|\u0447\u043E\u0432|\u043C\u0430 | \u0447\u043E|\u0438 \u0447|\u0430 \u0434|\u043D\u0438\u0435|\u0438 \u0434|\u0435\u0441\u0442| \u0438\u043B|\u0430\u043D\u0438|\u0432\u0435\u043A|\u0432\u0441\u0435| \u043E\u0431|\u0435\u043A |\u0435\u043A\u0438|\u0441\u0435\u043A|\u0430\u0432\u0430|\u0442\u0432\u043E|\u0441\u0432\u043E| \u0441\u0432|\u0432\u043E\u0442|\u0430 \u0432|\u0438 \u0441|\u043E\u0441\u0442| \u0440\u0430|\u043E\u0432\u0430|\u0430 \u043E|\u0435 \u0438|\u0432\u0430\u0442|\u0438 \u043D|\u0435 \u043F|\u043A \u0438|\u0430 \u0431| \u0432 |\u0438 \u043F|\u043B\u043D\u043E|\u043E \u0434| \u0441\u0435|\u0440\u0430\u0437|\u0435\u0442\u043E|\u044A\u0434\u0435|\u0431\u044A\u0434| \u0431\u044A|\u043F\u0440\u0438|\u0430\u0442\u0430| \u043A\u043E| \u0442\u0440| \u043E\u0441| \u0441\u044A|\u0431\u043E\u0434|\u043E\u0431\u043E|\u0432\u043E\u0431|\u0430\u0442 |\u0437\u0430 |\u0442\u0435\u043B| \u0435 |\u0430\u0446\u0438|\u043E \u0441|\u0434\u0435 |\u043E \u043F|\u0435\u043D |\u0431\u0440\u0430|\u0438 \u0432| \u043E\u0442|\u0441\u0435 |\u043D\u0438\u044F|\u0430\u043B\u043D| \u0434\u0435|\u0435\u0433\u043E|\u043D\u0435\u0433| \u0438\u0437|\u043E\u0442 |\u0440\u0430\u043D|\u044F\u0442\u0430|\u043A\u0430\u043A|\u043E\u0434\u0438|\u0435 \u0441|\u0438 \u0438|\u0434\u0435\u043D|\u043F\u0440\u0435|\u0431\u0432\u0430|\u044F\u0431\u0432|\u0440\u044F\u0431|\u0442\u0440\u044F|\u043D\u0438\u0442| \u043A\u0430|\u044F\u0432\u0430|\u043F\u0440\u043E|\u0441\u0442 |\u0430 \u0437|\u0433\u043E\u0432|\u0432\u0435\u043D|\u0442\u0432\u0435|\u043E \u043E|\u0430 \u0440|\u0430\u043A\u0432|\u043E \u0432|\u0438 \u0437|\u0440\u0435\u0434|\u043D\u043E\u0441|\u0438\u044F\u0442|\u0435 \u0434|\u0449\u0435\u0441|\u043D\u043E\u0432| \u043D\u0438|\u0446\u0438\u044F| \u0434\u043E|\u0439\u0441\u0442|\u043E \u0442|\u0435 \u0442|\u0440\u0436\u0430|\u044A\u0440\u0436|\u0434\u044A\u0440|\u0435\u043D\u043E|\u043F\u043E\u043B| \u0441 |\u043E\u0431\u0440|\u0442\u0432\u0430|\u043D\u043E\u0442|\u0440\u0435\u0441|\u0435\u0439\u0441|\u0438 \u043E|\u0435 \u0432|\u043A\u043E\u0439|\u043E\u0431\u0449|\u043B\u0435\u043D|\u043E\u043D\u0430|\u043D\u0430\u0446|\u0438\u0447\u0435|\u0435\u0437 |\u0431\u0435\u0437| \u0431\u0435|\u0435\u0436\u0434|\u0443\u0432\u0430|\u0432\u0438\u0442|\u0440\u0438 |\u0437\u0430\u043A|\u0438 \u043A| \u043B\u0438|\u0430 \u0435|\u043F\u043E\u0434|\u0435\u043B\u0438|\u043D\u0438\u043A|\u0441\u0438 |\u0435 \u043E|\u0430 \u0442|\u0430\u0432\u043D|\u0438 \u0440|\u0442 \u0441|\u043A\u0430 |\u043E\u0435\u0442|\u0435\u043B\u043D|\u043D\u0435\u043D|\u043E\u0439 |\u0433\u0440\u0430|\u0436\u0435\u043D|\u0434\u0440\u0443| \u0440\u0435|\u0430 \u043A|\u0441\u043D\u043E|\u043E\u0441\u043D|\u043B\u0438\u0447|\u0437\u0438 | \u0442\u0430|\u0441\u0430 |\u043D\u0441\u0442|\u0432\u043D\u0438|\u0447\u043A\u0438|\u0438\u0447\u043A|\u0441\u0438\u0447|\u0432\u0441\u0438|\u043B\u044E\u0447|\u043A\u043B\u044E|\u0434\u043D\u043E| \u043C\u043E|\u0435\u043C\u0435|\u0430 \u0443|\u0438\u0437\u0432|\u0442\u0432\u0438|\u0434\u0435\u0439|\u044F \u043D|\u043A\u0440\u0438|\u0430\u0442\u043E|\u043E \u0440|\u0439 \u043D|\u0438\u043A\u043E|\u0438\u0447\u043D|\u0436\u0430\u0432| \u0434\u044A| \u0442\u043E|\u0431\u0449\u0435|\u0438\u0430\u043B| \u0441\u043E|\u043B\u0438\u0442|\u0442 \u043D| \u0441\u0438|\u0442 \u0438|\u043E\u0434\u043D|\u0436\u0434\u0430|\u0437\u043E\u0432|\u0430\u0437\u043E|\u0443\u0447\u0430| \u0433\u0440|\u043A\u043E\u0435|\u0442\u044A\u043F|\u0441\u0442\u044A|\u0432\u043E\u043B|\u043B\u043D\u0438|\u0441\u0440\u0435| \u0441\u0440|\u043A\u0432\u0430|\u043A\u043E\u043D|\u0442\u043D\u043E|\u0430\u043A\u0430|\u0438 \u0443|\u043A\u043E |\u0433\u0430\u043D|\u043E\u0434\u0430|\u0447\u0435\u043D|\u043B\u0441\u0442|\u0435\u043B\u0441|\u0441\u0442\u0440| \u043A\u044A|\u0441\u0442\u0430|\u0440\u043E\u0434|\u043D\u0430\u0440|\u0438 \u043C|\u043D\u0430\u043B|\u0440\u0443\u0433| \u0434\u0440|\u0447\u0435\u0441|\u0432\u044A\u0437|\u0434\u0438 | \u0441\u0430| \u0442\u0435|\u0441\u0442\u043E|\u0434\u043E\u0441|\u0440\u0430\u0436|\u0440\u0435\u0437|\u0447\u0440\u0435|\u0433\u0430\u0442|\u0435\u043E\u0431|\u0430 \u043C|\u043E \u0435|\u0438\u043D\u0435|\u0430\u0441\u0442|\u043E\u0432\u043E|\u0447\u043D\u043E|\u0430\u0432\u0435|\u043C\u0443 | \u043C\u0443|\u0430\u043D\u043E|\u0438\u0442\u0430|\u0438\u043C\u0438|\u0430\u043A\u043E|\u043D\u0430\u043A|\u043B\u0430\u0433|\u043E\u0432\u0438",
    kaz: "\u043D\u0435 | \u049B\u04B1|\u0435\u043D |\u04B1\u049B\u044B| \u0431\u0430| \u049B\u0430|\u049B\u04B1\u049B|\u044B\u049B |\u0493\u0430 | \u0436\u04D9|\u04D9\u043D\u0435|\u0436\u04D9\u043D| \u043D\u0435| \u0431\u043E|\u0434\u0435 |\u0434\u0430\u043C|\u0430\u0434\u0430|\u0430 \u049B|\u0442\u0430\u0440|\u044B\u043D\u0430| \u0430\u0434|\u044B\u043B\u044B| \u04D9\u0440|\u044B\u04A3 |\u0430\u043D |\u0456\u043D |\u049B\u044B\u043B|\u0430\u0440 |\u0435\u043C\u0435|\u043D\u0430 |\u0440 \u0430|\u043B\u044B\u049B|\u0443\u0493\u0430|\u0430\u043B\u0430|\u044B\u049B\u0442| \u04E9\u0437|\u043C\u0435\u0441|\u04D9\u0440 | \u0436\u0430|\u043C\u0435\u043D|\u044B\u0493\u044B|\u043B\u044B | \u0434\u0435|\u049B\u0442\u0430|\u043D\u044B\u04A3|\u043D \u049B|\u0493\u0430\u043D|\u0456\u043D\u0435|\u0431\u0430\u0441|\u0430\u0440\u044B| \u043C\u0435| \u049B\u043E|\u0435\u043A\u0435|\u044B\u043D |\u0434\u0430 |\u0435 \u049B|\u0434\u044B |\u0430\u0441\u044B|\u0441\u0435 |\u0435\u0441\u0435|\u0430\u043C |\u0431\u043E\u043B|\u0430\u043D\u0434|\u043D\u0435\u043C| \u0431\u0456|\u0430\u0440\u0430|\u044B \u0431|\u0441\u0442\u0430|\u0442\u0430\u043D|\u043D\u0434\u044B|\u043D \u0431|\u0456\u04A3 |\u0435 \u0431|\u0456\u043B\u0456|\u0442\u0438\u0456| \u0442\u0438|\u0431\u0430\u0440|\u0493\u044B |\u043D\u0434\u0435|\u0435\u0442\u0442|\u0438\u0456\u0441|\u049B\u044B\u0493|\u0456\u0441 |\u043B\u0430\u0440|\u0433\u0435 |\u044B \u0442|\u0456\u043D\u0434|\u0456\u043A |\u0431\u0456\u0440| \u0431\u0435| \u043A\u0435|\u0430\u043B\u0443|\u0435 \u0430|\u0430\u043B\u044B|\u043B\u0443\u044B|\u0430 \u0436|\u0435\u0440\u0456|\u043E\u043B\u044B| \u0442\u0435|\u049B\u044B\u049B|\u043D \u043A| \u0442\u0430|\u043D \u0436|\u0493\u044B\u043D|\u0442\u0442\u0456|\u0456\u043D\u0456|\u0442\u044B\u043D| \u0435\u0440|\u043D\u0434\u0430|\u0456\u043C | \u0441\u0430|\u0435 \u0436|\u0430\u0442\u044B| \u0430\u0440|\u0440\u0493\u0430|\u0435\u0442\u0456|\u0430\u043D\u0430|\u044B \u04D9|\u0443\u044B\u043D|\u043B\u0493\u0430|\u04E9\u0437\u0456|\u043E\u0441\u0442|\u0435\u0433\u0456|\u0442\u0456\u043A|\u049B\u0430 |\u0441\u049B\u0430|\u0440\u044B\u043D|\u043A\u0456\u043D|\u043B\u0443\u0493|\u04A3 \u049B|\u043D\u0456\u04A3|\u0443\u044B |\u0431\u043E\u0441|\u0430\u0441\u049B|\u049B\u0430\u0440|\u0434\u044B\u049B|\u043D\u0430\u043D|\u043C\u044B\u0441|\u043C\u043D\u044B|\u0430\u043C\u043D|\u044B \u043C|\u0430\u0439\u0434|\u043A\u0435 | \u0436\u0435|\u0437\u0456\u043D|\u0440\u0434\u0435|\u0440\u0456\u043D|\u0435 \u0442|\u0433\u0435\u043D|\u044B\u043F |\u0440\u044B |\u0442\u0456 |\u0441\u044B\u043D|\u049B\u0430\u043C|\u0434\u0435\u043D|\u0456 \u0431|\u0433\u0456\u0437|\u0440\u0430\u043B|\u0435 \u04E9|\u043B\u0430\u043D|\u0441\u044B |\u0430\u043C\u0430|\u0442\u0442\u0430|\u0442\u044B\u049B|\u0431\u0435\u0440|\u0434\u0456 |\u0431\u0456\u043B|\u0440\u043A\u0456|\u04E9\u0437 |\u0437\u0434\u0435|\u043A\u0435\u0442|\u049B\u043E\u0440|\u0434\u0430\u0439|\u0443\u0433\u0435|\u044B \u0435|\u044B\u043D\u0434|\u043D\u0435\u0433|\u043E\u043D\u044B|\u0435\u0439 |\u043C\u0435\u0442|\u0430\u043D\u044B|\u0430 \u0442|\u0436\u0430\u0441|\u0430\u0443\u044B|\u043B\u0433\u0435|\u0430\u0441\u0430|\u0435\u0433\u0435|\u0434\u0430\u0440|\u0440\u0443 |\u0430\u0443 |\u0435\u0440\u043A|\u044B \u0436|\u0440\u044B\u043B| \u0442\u043E|\u043D \u043D|\u0435 \u043D|\u0442\u0456\u043D|\u0456\u0440 |\u0441\u0456\u0437|\u0442\u0435\u0440|\u043B\u043C\u0430|\u0456 \u0442|\u043A\u0456\u043C| \u0430\u043B|\u0440 \u043C|\u043B\u0456\u043A| \u043C\u04AF|\u0435 \u043C|\u0442\u04AF\u0440| \u0442\u04AF|\u043A\u0435\u043B|\u043B\u044B\u043F|\u0435\u04A3 |\u0442\u0435\u04A3|\u0440\u043B\u044B|\u043B\u0456\u043C|\u0440\u0434\u044B|\u0430\u0440\u0434|\u0430\u0442\u0442|\u0441 \u0431|\u044B\u0440\u044B|\u0441\u044B\u0437|\u044B\u0441 |\u0435\u043B\u0433|\u0434\u0430\u043B|\u0439\u0434\u0430|\u043E\u0440\u0493|\u0440\u049B\u044B|\u0430\u0440\u049B| \u0436\u04AF|\u0442\u0430\u043B|\u044B\u043B\u043C|\u0430 \u0431|\u0456\u0433\u0456|\u043B\u0434\u0435|\u0456\u0437 |\u049B\u0442\u044B| \u0435\u0448|\u0434\u0435\u0439|\u0430\u0439 |\u0436\u0430\u0493|\u043A\u0442\u0456|\u0456\u043A\u0442|\u0433\u0456\u043D| \u04D9\u043B|\u0442\u0442\u044B|\u04B1\u043B\u0442| \u04B1\u043B|\u0435 \u0434|\u044B\u043D\u044B|\u043B\u0456\u043D|\u0440 \u0431|\u0435\u043B\u0435|\u043A\u04B1\u049B| \u043A\u04B1|\u0430\u043C\u0434|\u043C \u0431| \u0435\u0442|\u043E\u0493\u0430|\u049B\u04B1\u0440| \u043A\u04E9|\u0430\u0493\u0430|\u0442\u043E\u043B|\u0448\u0456\u043D|\u0430\u0439\u044B| \u049B\u044B|\u049B\u0430\u043B|\u0436\u0435\u043A|\u0456 \u043D|\u0435\u0441 |\u0430\u0493\u044B|\u0435 \u043E|\u0435\u043B\u0456| \u0435\u043B|\u043D \u0435|\u0437\u0456 |\u0448\u043A\u0456|\u0435\u0448\u043A|\u043E\u043B\u0443|\u0446\u0438\u044F|\u043C\u0430\u0441|\u0493\u0434\u0430|\u0430\u0493\u0434|\u043B\u0442\u0442|\u0456\u043C\u0434|\u043D\u044B\u043C| \u0434\u0430|\u0430 \u0434|\u04D9\u0441\u0456|\u0441 \u04D9|\u049B\u0430\u0442|\u0456\u0440\u0456| \u0441\u043E|\u04A3 \u0431|\u0430\u0437\u0430|\u043C\u0434\u0430|\u0430\u0439\u043B| \u0430\u0441|\u0493\u0430\u043C|\u049B\u043E\u0493"
  },
  Arabic: {
    arb: " \u0627\u0644|\u064A\u0629 |\u0641\u064A | \u0641\u064A|\u0627\u0644\u062D| \u0623\u0648|\u0623\u0648 | \u0648\u0627|\u0648\u0627\u0644|\u062D\u0642 |\u0629 \u0627|\u0644\u062D\u0642|\u0627\u0644\u062A|\u0643\u0644 |\u0627\u0644\u0645|\u0644\u0643\u0644| \u0644\u0643|\u0644\u0649 |\u0642 \u0641|\u062A\u0647 |\u0648 \u0627|\u0629 \u0648|\u0634\u062E\u0635|\u0629 \u0644|\u0627\u062A |\u0627\u0644\u0623|\u064A \u0623|\u0648\u0646 | \u0634\u062E|\u0645 \u0627|\u0623\u064A | \u0623\u064A|\u0627\u0646 |\u0623\u0646 |\u0645\u0629 |\u064A \u0627|\u0627\u0644\u0627|\u0644\u0627 |\u0647\u0627 |\u0627\u0621 | \u0623\u0646| \u0639\u0644|\u062E\u0635 |\u0646 \u0627| \u0644\u0644|\u062F \u0627|\u0645\u0646 |\u0641\u0631\u062F|\u0645\u0627 |\u0627\u0644\u0639|\u062A \u0627|\u062D\u0631\u064A|\u0639\u0644\u0649|\u0644 \u0641|\u0631\u062F |\u0644 \u0634| \u0644\u0627|\u0631\u064A\u0629| \u0625\u0644|\u0629 \u0623|\u0627 \u0627|\u0646 \u064A| \u0648\u0644|\u0627 \u0644|\u0627 \u064A| \u0641\u0631| \u0645\u0646|\u0629 \u0645|\u0627\u0644\u0642|\u062C\u062A\u0645|\u0646 \u0623|\u0642 \u0627|\u0627\u0644\u0625| \u062D\u0631|\u0644\u0647 |\u0647 \u0644|\u0627\u064A\u0629|\u0644\u0643 |\u0647 \u0627| \u062F\u0648|\u062F\u0629 |\u0627\u064B |\u064A\u0646 |\u0647 \u0648|\u0644\u0629 |\u064A \u062D| \u0639\u0646|\u0645\u0627\u0639|\u064A \u062A|\u0630\u0627 | \u062D\u0642|\u0642\u0648\u0642|\u062D\u0642\u0648|\u060C \u0648|\u0646 \u062A|\u0645\u0639 |\u0635 \u0627|\u0627\u0645 |\u062F \u0623| \u0643\u0627|\u0647\u0630\u0627|\u0627\u0644\u0648| \u0625\u0646|\u0645\u0644 |\u0627\u0645\u0629|\u0639 \u0627|\u0625\u0644\u0649|\u0629 \u0639|\u0645\u0627\u064A|\u062D\u0645\u0627|\u0646 \u0648|\u0644\u062A\u0639| \u0648\u064A|\u064A\u0631 |\u0646\u0648\u0646|\u064A \u0648|\u0627\u0633\u064A|\u0627\u0644\u062C| \u0647\u0630|\u0646\u0633\u0627|\u0648\u0642 |\u062A\u0631\u0627|\u0639\u064A\u0629|\u0647 \u0623| \u0644\u0647|\u0633\u064A\u0629| \u064A\u062C| \u0628\u0627|\u062F\u0648\u0644|\u0627\u0646\u0648|\u0642\u0627\u0646|\u0644\u0642\u0627|\u0629 \u0628|\u0629 \u062A|\u062A\u0645\u0627|\u0627\u0644\u062F|\u064A\u0627\u062A|\u0639 \u0628|\u0633\u0627\u0646|\u0625\u0646\u0633|\u0647\u0645 |\u0639\u0644\u064A| \u0645\u062A|\u0644\u0645\u062C|\u0630\u0644\u0643|\u0639\u0645\u0644|\u0644\u0623\u0633|\u0648\u0632 |\u062C\u0648\u0632|\u064A\u062C\u0648|\u0628\u0627\u0644|\u063A\u064A\u0631|\u0643 \u0627|\u0643\u0627\u0646|\u0633\u0627\u0633|\u0623\u0633\u0627|\u062F\u0645 |\u0644\u0627\u062F|\u0627\u0639\u064A|\u0627\u0644\u0631|\u062A\u0645\u064A|\u062F\u0648\u0646|\u062A\u0645\u062A|\u0644\u062A\u0645| \u064A\u0639|\u0644\u064A\u0647|\u0633\u0627\u0648|\u0627\u062C\u062A|\u064A \u0645|\u0644\u0639\u0627|\u0644\u062C\u0645|\u062A\u0639\u0644|\u0631 \u0648|\u062A\u0645\u0639|\u0645\u062C\u062A| \u0645\u0639|\u064A\u0647 |\u0649 \u0623|\u0641\u064A\u0647|\u0649 \u0627| \u0643\u0644|\u0644\u0627\u062A|\u0645\u0644\u0627|\u0648\u062F |\u0627\u0646\u062A|\u0627\u0644\u0641|\u064A\u0647\u0627|\u064A \u0625|\u062A\u064A |\u0627\u0644\u0628|\u0644\u064A |\u0642\u062F\u0645|\u0627\u0644 |\u0627\u062F |\u0644 \u0627|\u064A\u0632 |\u064A\u064A\u0632|\u0645\u064A\u064A| \u062A\u0645|\u0644\u062D\u0631|\u062A\u0639 |\u0645\u062A\u0639|\u0627 \u0628|\u0639\u0627\u0645|\u0627 \u0648|\u0642 \u0648|\u0631\u0627\u0645|\u0644 \u0644|\u0644\u0627\u062C|\u0631\u0627 |\u0627\u0644\u0634| \u0648\u0625|\u064A\u0645 |\u0644\u064A\u0645|\u0634\u062A\u0631|\u0627 \u062D|\u0648\u0627\u062C|\u0644\u0632\u0648|\u0648\u0644 |\u0627 \u0641|\u0648\u0644\u0629|\u0644\u062D\u0645|\u0623\u0633\u0631| \u0630\u0644|\u0647 \u0641|\u0627\u062A\u0647|\u0645\u0633\u0627|\u0644\u0645\u0633| \u062A\u0639|\u0639\u0646 |\u0647 \u0639|\u0648\u0644\u0647|\u064A\u062A\u0647|\u0646 \u0644|\u0631\u0629 | \u0648\u0633|\u0627\u0629 |\u064A\u062F | \u062A\u062D| \u0645\u0633|\u064A \u064A|\u0644\u062A\u064A|\u0639\u0629 |\u0648\u0644\u064A|\u0644\u062F\u0648| \u0623\u0633| \u0648\u0641|\u0644 \u0648|\u0623\u064A\u0629|\u0646\u064A |\u0627\u0644\u0633|\u0644\u0627\u0646|\u0644\u0625\u0639|\u0629 \u0641|\u0631\u064A\u0627|\u0644 \u0625|\u0645 \u0628|\u0627\u0645\u0644|\u0643\u0631\u0627|\u062A\u0633\u0627|\u0645\u064A\u0639|\u062C\u0645\u064A| \u062C\u0645|\u0623\u0648\u0644|\u0628\u064A\u0629|\u0639\u064A\u0634|\u062A\u062D\u0642|\u0627\u062F\u0629|\u0633 \u0627| \u0645\u0645|\u0645\u0639\u064A|\u062C\u0645\u0627|\u0639\u0627\u062A|\u0627\u0639\u0627|\u0627\u0631\u0633|\u0645\u0627\u0631|\u0645\u0645\u0627|\u0645 \u0648|\u0631\u0627\u0643|\u0627\u0634\u062A|\u0627\u0644\u0637|\u0627\u062C |\u0632\u0648\u0627|\u0627\u0644\u0632| \u0648\u0645|\u062D\u062F\u0629|\u062A\u062D\u062F|\u0644\u0645\u062A|\u0645\u0645 |\u0644\u0623\u0645|\u062F\u0647 |\u0628\u0644\u0627| \u0628\u0644|\u0627\u0631 |\u064A\u0627\u0631|\u062A\u064A\u0627|\u062E\u062A\u064A|\u0627\u062E\u062A|\u0646 \u0645| \u0645\u0631",
    urd: "\u0648\u0631 | \u0627\u0648|\u0627\u0648\u0631|\u06A9\u06D2 | \u06A9\u06D2| \u06A9\u06CC| \u06A9\u0627|\u06CC\u06BA | \u062D\u0642|\u06A9\u06CC |\u06A9\u0627 | \u06A9\u0648|\u0626\u06D2 |\u06D2 \u06A9|\u06CC\u0627 |\u0633\u06D2 |\u06A9\u0648 |\u0634\u062E\u0635| \u0634\u062E|\u0646\u06D2 | \u0627\u0633| \u06C1\u06D2|\u0645\u06CC\u06BA|\u062D\u0642 | \u06C1\u0648| \u0645\u06CC|\u062E\u0635 |\u06D2 \u0627| \u062C\u0627|\u0627\u0633 | \u0633\u06D2| \u06CC\u0627|\u06C1\u0631 |\u06CC \u0627| \u06A9\u0631| \u06C1\u0631|\u06D2\u06D4 |\u0633\u06CC |\u06C1\u06CC\u06BA|\u0627 \u062D|\u0635 \u06A9|\u0648\u06BA |\u06D2 \u0645| \u0627\u0646|\u0631 \u0634|\u06D4 \u06C1|\u0627\u0626\u06D2|\u0632\u0627\u062F|\u0622\u0632\u0627| \u0622\u0632|\u0627\u0645 |\u0631 \u0627|\u0642 \u06C1|\u0627\u062F\u06CC|\u062C\u0627\u0626|\u06BA \u06A9|\u06C1\u06D2\u06D4|\u0645 \u06A9| \u06A9\u0633|\u0627 \u062C|\u06CC \u06A9|\u0633 \u06A9|\u06A9\u0633\u06CC| \u067E\u0631|\u06D2 \u06AF|\u06C1\u06D2 |\u0627\u0631 |\u062A \u06A9|\u062F\u06CC |\u067E\u0631 |\u0648 \u0627| \u062D\u0627| \u062C\u0648| \u06C1\u06CC|\u0627\u0646 |\u06CC \u062C|\u0631\u06CC | \u0646\u06C1| \u0645\u0639|\u062C\u0648 |\u0644 \u06A9|\u06CC \u062A|\u0646 \u06A9|\u06A9\u0631\u0646|\u0626\u06CC |\u0644 \u06C1|\u062A\u06CC |\u06C1\u0648 |\u06C1 \u0627| \u0627\u06CC|\u0635\u0644 |\u0627\u0635\u0644|\u062D\u0627\u0635|\u0631\u0646\u06D2|\u06CC \u0634|\u0646\u06C1 |\u06D4 \u0627|\u06BA\u06D4 |\u06CC\u06BA\u06D4|\u0631 \u06A9|\u0631 \u0645| \u0645\u0644|\u0648\u06C1 |\u0645\u0639\u0627|\u0631\u06D2 |\u06BA \u0627|\u0646\u06C1\u06CC|\u06D2 \u06C1|\u06D2 \u0628|\u0627\u06CC\u0633|\u06D2 \u0644| \u062A\u0639| \u06AF\u0627|\u06CC\u062A |\u06CC \u062D|\u0627 \u0627|\u06CC \u0645|\u0627\u067E\u0646| \u0627\u067E|\u06A9\u06CC\u0627|\u0645\u06CC |\u06CC \u0633| \u062C\u0633|\u06C1 \u06A9|\u0646\u06CC |\u0627\u0634\u0631|\u0639\u0627\u0634| \u062F\u0648|\u0644\u0626\u06D2| \u0644\u0626|\u0627\u0646\u06C1|\u0648\u0642 |\u0642\u0648\u0642|\u062D\u0642\u0648|\u0645\u0644 | \u0642\u0627|\u06A9\u06C1 | \u06AF\u06CC|\u0631 \u0628|\u06C1 \u0645| \u0648\u06C1| \u0628\u0646|\u06CC \u0628|\u0645\u0644\u06A9|\u062C\u0633 |\u0627\u06D4 |\u0631\u06CC\u0642|\u0631 \u0646|\u06D2 \u062C|\u0627\u062F |\u0627\u062A |\u06AF\u06CC |\u062F \u06A9|\u06D2 \u062D|\u062F\u0627\u0631|\u0631 \u06C1|\u06AF\u0627\u06D4|\u0642\u0648\u0645| \u0642\u0648|\u06D2\u060C |\u0627 \u0633|\u062F\u0648\u0633|\u0631 \u067E| \u0648 | \u0634\u0627|\u06CC \u0622|\u06BA \u0645|\u0642 \u062D| \u067E\u0648| \u0628\u0627|\u062E\u0644\u0627|\u0627\u0646\u06D2|\u06CC\u0645 |\u0644\u06CC\u0645|\u0648 \u062A|\u0648\u0646 | \u06A9\u06C1|\u06CC\u060C |\u06D4 \u06A9|\u0627 \u067E|\u0646 \u0627|\u0644\u06A9 |\u0639\u0644\u0627|\u0627 \u0645|\u0642 \u06A9|\u0627\u0626\u06CC|\u0648\u0633\u0631|\u06CC \u06C1|\u0648\u0626\u06CC|\u06CC\u0631 |\u0627 \u06C1|\u0639\u0644\u06CC|\u0648 \u06AF|\u0648\u0631\u06CC|\u062F\u06AF\u06CC|\u0646\u062F\u06AF|\u0648 \u06A9|\u06CC\u0633\u06D2| \u0645\u0646|\u0627\u0626\u062F|\u0631\u0627\u0626| \u0645\u0631|\u067E\u0648\u0631| \u0637\u0631|\u0648\u0645\u06CC|\u06D2 \u062E|\u0633\u0628 |\u0646\u0648\u0646|\u0627\u0646\u0648|\u0642\u0627\u0646| \u0633\u06A9|\u0648\u0627\u0645|\u06CC\u0646 | \u0631\u06A9|\u062A\u0639\u0644|\u0644\u0627\u0642|\u063A\u06CC\u0631|\u062F\u0627\u0646|\u060C \u0627| \u0628\u06CC| \u0645\u0633|\u06CC\u0648\u06BA|\u0646\u0627 | \u0628\u06BE| \u0628\u0631|\u0631\u062A\u06CC|\u0627\u062F\u0627|\u0627\u0645\u0644|\u06CC\u06C1 | \u06CC\u06C1|\u06C1 \u0648| \u0639\u0627|\u06CC \u067E| \u0628\u0686|\u0627\u0641 |\u0644\u0627\u0641| \u062E\u0644|\u06CC\u06D4 |\u06AF\u06CC\u06D4| \u062F\u06CC|\u06BE\u06CC |\u0628\u06BE\u06CC|\u062F\u06C1 |\u062C\u0627 |\u067E\u0646\u06CC|\u0642\u0648\u0627|\u0627\u0642\u0648|\u0631\u06A9\u06BE|\u06D2 \u06CC| \u0639\u0644|\u06A9\u0648\u0626|\u060C \u0645| \u0686\u0627|\u06D2 \u0633|\u0631 \u0639| \u067E\u06CC|\u0628\u0631\u0627|\u0631 \u0633|\u0631 \u062D|\u0633\u0627\u0646|\u0645 \u0627|\u06A9\u0627\u0645|\u0634\u0631\u062A| \u0631\u0627|\u0634\u0627\u0645|\u0645\u0646 |\u0632\u0646\u062F| \u0632\u0646|\u0628 \u06A9|\u062A \u0645|\u0627\u06C1 |\u0627\u0631\u06CC|\u0633 \u0645|\u0631 \u062C| \u0645\u062D|\u0648\u0631\u0627|\u06D2 \u067E|\u0637\u0631\u06CC|\u06C1\u0648\u06BA|\u0627\u0644 |\u06BA \u0633|\u06CC \u0646|\u06A9\u0631\u06D2| \u0645\u0642|\u062A \u0633|\u062A\u062D\u0641| \u062A\u062D|\u0648\u06D4 |\u06C1\u0648\u06D4|\u0628\u0646\u062F| \u0627\u0642|\u062F \u06C1| \u0627\u0645|\u0627\u0645\u06CC|\u0627\u0644\u0627|\u0644\u062A |\u0634\u0631\u06D2|\u06D2 \u0639|\u0627 \u06A9|\u0641\u0631\u06CC",
    pes: " \u0648 | \u062D\u0642| \u0628\u0627|\u0646\u062F |\u0631\u062F |\u062F\u0627\u0631| \u062F\u0627|\u06A9\u0647 |\u0647\u0631 | \u062F\u0631| \u06A9\u0647|\u062F\u0631 | \u0647\u0631|\u0631 \u06A9|\u062D\u0642 |\u062F \u0647|\u0627\u0632 |\u06CC\u062A | \u0627\u0632|\u06CC\u0627 |\u06A9\u0633 |\u0648\u062F |\u0627\u0631\u062F| \u06CC\u0627| \u06A9\u0633|\u0627\u06CC |\u062F \u0648| \u0628\u0631| \u062E\u0648|\u0642 \u062F|\u0628\u0627\u0634|\u0634\u062F |\u062F \u06A9|\u0627\u0631 |\u062F \u0628| \u0631\u0627|\u0647 \u0628|\u0627\u0646 |\u0622\u0632\u0627| \u0622\u0632|\u0631\u0627 |\u0627\u0634\u062F|\u06CC \u0648|\u0647 \u0627|\u06CC\u0646 |\u06CC\u062F |\u0632\u0627\u062F|\u0633 \u062D|\u062E\u0648\u062F|\u06CC \u0628| \u0627\u0633|\u062F\u0647 |\u062F\u06CC |\u0648\u0631 |\u0627\u06CC\u062F|\u0647 \u062F|\u0631\u06CC |\u0648 \u0627|\u062A\u0645\u0627|\u0627\u062A | \u0646\u0645|\u06CC \u06A9|\u0627\u062F\u06CC|\u0646\u0647 |\u0631\u0627\u06CC|\u062F \u0627| \u0622\u0646|\u0627\u0633\u062A|\u0631 \u0627|\u0631 \u0645| \u0627\u062C|\u0645\u0627\u06CC|\u0648\u0646 |\u0642\u0648\u0642|\u062D\u0642\u0648|\u0648 \u0645| \u0627\u0646|\u0627\u0646\u0647| \u0647\u0645|\u0648\u0642 |\u0627\u06CC\u062A| \u0634\u0648|\u06CC \u0627| \u0645\u0648| \u0628\u06CC|\u0628\u0627 | \u062A\u0627|\u0648\u0631\u062F|\u0627\u0646\u0648|\u0633\u062A |\u0648\u0627\u0646|\u0628\u0631\u0627|\u0627\u0645 |\u0634\u0648\u062F|\u0622\u0646 |\u062C\u062A\u0645|\u06CC \u06CC| \u06A9\u0646|\u0631 \u0628|\u06A9\u0646\u062F| \u0645\u0631|\u062A \u0645|\u0647\u0627\u06CC|\u062A \u0627| \u0645\u0633|\u06CC\u060C |\u0645\u0627\u0639|\u0627\u062C\u062A|\u062A\u0648\u0627|\u06CC\u06AF\u0631|\u0648 \u0628|\u062F\u0627\u0646|\u062A \u0648|\u0627 \u0645| \u0628\u062F|\u0639\u06CC |\u06A9\u0627\u0631| \u0645\u0646|\u0645\u0648\u0631| \u0645\u0642|\u06CC \u062F| \u0632\u0646|\u06CC \u0645|\u0646 \u0628|\u0631 \u062E|\u0627\u0647 |\u0627 \u0628|\u0627\u0631\u06CC|\u062F \u0622|\u0645\u0644 | \u0628\u0647|\u0627\u0639\u06CC|\u062F\u060C |\u062F\u06CC\u06AF|\u062A \u0628|\u0628\u0627\u06CC|\u0627\u06CC\u0646| \u0645\u06CC|\u0646 \u0648|\u0642 \u0645| \u0639\u0645| \u06A9\u0627|\u0646 \u0627|\u0648 \u0622| \u062D\u0645|\u0646\u0648\u0646|\u0647 \u0648|\u0648 \u062F|\u062F \u0634| \u0627\u06CC|\u0634\u0648\u0631|\u06A9\u0634\u0648| \u06A9\u0634|\u0644\u06CC |\u0646\u06CC |\u0647 \u0645|\u0628\u0639\u06CC|\u0631 \u0634|\u06CC\u0647 | \u0645\u0644|\u0645\u06CC\u062A|\u06CC \u0631|\u0631\u0646\u062F| \u0634\u0631|\u0645\u06CC |\u0648\u06CC |\u0633\u0627\u0648|\u0642\u0627\u0646| \u0642\u0627|\u0645\u0642\u0627|\u0627\u0648 | \u0627\u0648|\u062F \u0645|\u06AF\u06CC |\u0646\u0645\u06CC| \u0627\u062D| \u0645\u062D|\u0645\u06CC\u0646|\u0626\u06CC |\u0627\u062F\u0627| \u0622\u0645|\u062E\u0648\u0627|\u06AF\u0631\u062F| \u06AF\u0631|\u0645\u0646\u062F| \u0634\u062F|\u0627\u0626\u06CC| \u062F\u06CC|\u0632 \u062D|\u0647\u06CC\u0686| \u0647\u06CC|\u0627\u062F\u0647| \u0645\u062A|\u0646\u0645\u0627|\u062A \u06A9|\u0631\u0627\u0646| \u0628\u0645|\u0646 \u062D|\u0631 \u062A|\u062D\u0645\u0627|\u0627\u0631\u0646|\u0645\u0633\u0627|\u062F\u06AF\u06CC|\u0648\u0645\u06CC|\u0646 \u062A|\u0645\u0644\u0644|\u0628\u0631 |\u0647\u062F |\u0648\u0627\u0647|\u0628\u0647\u0631| \u0627\u0639|\u200C\u0647\u0627|\u0642 \u0648|\u060C \u0627|\u0639\u06CC\u062A|\u06CC\u062A\u0648|\u0627 \u0631|\u0646 \u0645| \u0639\u0642|\u0647\u0645\u0647|\u0627 \u0647|\u0632\u0634 |\u0648\u0632\u0634|\u0645\u0648\u0632|\u0622\u0645\u0648|\u0627\u0646\u062A|\u062A\u06CC |\u062C\u0627\u0645|\u0645\u0648\u0645|\u0639\u0645\u0648|\u062A\u062E\u0627| \u0641\u0631|\u0637\u0648\u0631|\u062F \u062F|\u0647 \u062D|\u0631\u062F\u0627|\u0627\u0648\u06CC|\u0646\u0648\u0627|\u0627\u0646\u06CC|\u0631\u0627\u0631| \u0645\u062C|\u06CC \u0646|\u062D\u062F\u06CC|\u0627\u062D\u062F|\u0646\u062F\u06AF|\u0632\u0646\u062F|\u0634\u062E\u0635| \u0634\u062E|\u200C\u0645\u0646|\u0647\u200C\u0645|\u0631\u0647\u200C|\u0647\u0631\u0647|\u0634\u062F\u0647|\u0639 \u0627|\u0648 \u0647|\u0627\u0633\u06CC|\u0647\u0654 |\u06CC\u062F\u0647|\u0639\u0642\u06CC|\u0627 \u0627|\u0645\u0647 | \u0628\u0634|\u0627\u062F |\u062F\u06CC\u0647|\u0627 \u062F|\u062F\u0648\u0627|\u06CC \u062D|\u0627\u0628\u0639|\u06CC \u062A|\u062E\u0627\u0628|\u0646\u062A\u062E|\u0631\u0648\u0631|\u0648 \u0631|\u0634\u0631\u0627| \u062E\u0627|\u0654\u0645\u06CC|\u0627\u0654\u0645|\u062A\u0627\u0654|\u0627\u064B |\u0627\u0645\u0644|\u0644\u0647 |\u062F \u0631|\u0627\u0633\u0627|\u062E\u0648\u0631|\u0628\u0644 |\u0627\u0628\u0644|\u0642\u0627\u0628|\u06CC\u06A9 |\u0633\u0627\u0646|\u0642\u0631\u0627|\u0627 \u0646|\u062E\u0635\u06CC| \u0627\u0645| \u0628\u0648|\u06CC\u0631 |\u0627\u0644\u0645|\u0628\u06CC\u0646|\u0627\u0647\u062F|\u062A\u0628\u0639| \u062A\u0628",
    zlm: " \u062F\u0627|\u0627\u0646 |\u062F\u0627\u0646| \u0628\u0631| \u0627\u0648|\u0646 \u0633|\u0631\u06A0 |\u062F\u0627\u0644| \u06A4\u0631|\u0644\u0647 |\u0643\u0646 | \u0643\u06A4|\u0646 \u0627|\u0646 \u0643|\u0646 \u062F|\u064A\u06A0 | \u064A\u06A0|\u06A4\u062F |\u062D\u0642 |\u0648\u0631\u06A0|\u062A\u064A\u0627|\u064A\u0627\u06A4|\u0627\u0631\u0627|\u0643\u06A4\u062F|\u0627\u0648\u0631|\u0631\u062D\u0642|\u0628\u0631\u062D|\u0627\u0644\u0647|\u0623\u0646 |\u0648\u0644\u064A| \u0627\u062A|\u0627\u062A\u0627|\u06A0\u0646 |\u062A\u0627\u0648|\u0627\u06A4 |\u0633\u062A\u064A|\u0644\u064A\u0647|\u0627\u0648 | \u0633\u062A|\u06A4 \u0627|\u064A\u0647 |\u0631\u0627 |\u0647 \u0628|\u0647 \u062F|\u0639\u062F\u0627| \u0639\u062F|\u0646 \u06A4|\u0646 \u0628|\u064A\u0646 | \u062A\u0631|\u0642 \u0643|\u0646 \u064A|\u064A\u0628\u0633|\u0628\u064A\u0628| \u062A\u064A| \u0633\u0648| \u0643\u0628| \u0633\u0627|\u0646 \u0645|\u0646 \u062A|\u0644\u0645 |\u0627\u0644\u0645|\u062F \u0633|\u06A0 \u0639| \u0645\u0646|\u0686\u0627\u0631|\u062F \u06A4|\u0631\u0646 |\u0633\u0627\u0645| \u0645\u0627|\u06BD \u0633|\u0646\u060C | \u0628\u0648| \u0627\u064A|\u0646\u062F\u0642| \u062D\u0642|\u06AC\u0627\u0631|\u0646\u06AC\u0627|\u0628\u0648\u0644|\u0633\u0628\u0627| \u0633\u0628|\u0627\u062A\u0648|\u0627 \u0633|\u0642\u0644\u0647| \u06A4\u0645| \u0645\u0645|\u0648\u0627\u0646|\u0633\u0686\u0627| \u0633\u0686| \u0643\u0633|\u0627 \u0628|\u0633\u0646 | \u0633\u0645|\u06A4\u0631\u0644|\u0627\u0648\u0646|\u0646\u06BD |\u062A\u0646 | \u0628\u0627|\u0647\u0646 |\u0633\u064A\u0627|\u0627 \u06A4|\u0627\u0631\u06A0|\u0628\u0627\u0631|\u06A4\u0627 |\u0628\u0633\u0646|\u0643\u0628\u064A|\u0627\u0645 |\u064A\u0646\u062F|\u064A \u062F|\u0627\u06AC\u064A|\u06A0 \u0628|\u0628\u0627\u06AC|\u064A \u0627|\u0645\u0627\u0646| \u0644\u0627| \u062F |\u062F\u0642\u0644|\u0647\u0646\u062F| \u0647\u0646|\u062A \u062F|\u0627\u062F\u064A|\u0648\u064A\u0646|\u064A\u0643\u0646| \u0646\u06AC|\u060C \u0643|\u0646\u0662 | \u06A4\u0648|\u0628\u06A0\u0633|\u0642\u0662 |\u0627\u062A |\u0627\u0648\u0644|\u0627\u0643\u0646|\u0627\u06BD | \u0633\u0633|\u0648\u0646 |\u0627\u062F | \u0643\u0648|\u0627\u064A\u0646|\u062F\u06A0\u0646| \u062F\u06A0|\u0627\u0626\u0646|\u062A\u0648 |\u062A\u064A |\u0646 \u0647|\u06AC\u064A |\u0633\u064A |\u0642 \u0645|\u0648\u06A0\u0646|\u062F\u0648\u06A0|\u0646\u062F\u0648|\u0644\u064A\u0646|\u0631\u0644\u064A|\u0646\u062A\u0648|\u06A4\u0648\u0646|\u0648\u0627\u062A|\u064A\u0627\u062F|\u062A\u064A\u0643|\u06A0\u0633\u0627|\u06A4\u0645\u0628|\u062A\u0631\u0645|\u0662 \u062F|\u062D\u0642\u0662|\u0648\u0627 |\u0644\u0648\u0627|\u0645\u0627\u0633|\u0648\u0642 |\u0647 \u0645|\u0644 \u062F| \u0645\u0644|\u0648\u0646\u062F| \u06A4\u06A0|\u0627\u060C |\u060C \u062A|\u0644\u0627\u0626|\u0627\u064A |\u0645\u06A4\u0648|\u064A\u0643 |\u064A \u0643|\u0631\u0627\u062A|\u0645\u0631\u0627| \u0628\u064A|\u0633\u0645\u0648|\u0648 \u0643|\u060C \u062F|\u0633\u0648\u0627|\u06A0 \u0645|\u06A0 \u0633|\u06A0\u0662 |\u06A4\u0631\u064A|\u064A\u0631\u064A|\u062F\u064A\u0631|\u0627 \u0627|\u0627\u0633\u0627|\u06A4\u0662 |\u062A\u0627 |\u0633\u0648\u0633|\u060C \u0633|\u062C\u0648\u0627|\u06A0 \u062A|\u0631\u0623\u0646| \u0627\u0646|\u0633\u0623\u0646|\u0631\u064A\u0643|\u064A\u0623\u0646|\u0631\u064A | \u062F\u0631|\u0627\u0645\u0631|\u0643\u0631\u062C| \u06A4\u0644|\u0627 \u062F|\u062C\u0631\u0646|\u0627\u062C\u0631|\u0627\u0631\u0643|\u0644\u0627\u062C|\u062F \u0643|\u0648\u0627\u0631|\u0628\u0631\u0633|\u0648\u0646\u062A|\u0645\u0646\u0648|\u0633\u0627\u0644|\u064A\u0646\u06A0|\u062F\u06A0\u0662|\u0646\u062F\u06A0| \u0645\u06A0|\u0627\u06A4\u0627|\u0633\u0633\u064A|\u0633\u0627\u0633|\u0646\u0646 |\u06A4\u0648\u0644|\u0627\u06AC\u0627| \u0628\u06A0| \u0633\u06A4|\u0645\u0628\u064A| \u0627\u06A4|\u06A0 \u0627|\u0627\u0631\u0623|\u06A4\u0631\u0627|\u064A \u0633|\u0628\u0633 | \u062F\u0644|\u0627 \u0645|\u0645\u0648\u0627|\u06A4\u0644\u0627|\u0645\u0644\u0627|\u06A4\u0631\u0643|\u0643\u0648\u0631|\u0648\u0628\u0648| \u0643\u0623|\u0648\u0643\u0646|\u0623\u0646\u06BD|\u0643\u0633\u0627|\u06A0\u06AC\u0648|\u0627\u062F\u06A4|\u0647\u0627\u062F|\u0631\u0647\u0627|\u062A\u0631\u0647|\u0643\u0648\u0645|\u062A\u0648\u0642|\u0645 \u0633|\u06A0 \u062F|\u062F\u064A | \u062F\u064A|\u0662 \u0633|\u0646\u062F\u064A|\u0627\u0633 |\u0627\u062F\u0627|\u0628\u0648\u0627| \u062F\u0628|\u06A0 \u06A4|\u06BD\u060C |\u0627\u06A4\u0662|\u0631\u062A\u0627|\u0627\u0644 |\u064A\u0627\u0644|\u0648\u0633\u064A| \u0643\u062A|\u0623\u0646\u060C|\u0646\u06A4\u0627|\u062A\u0646\u06A4| \u062A\u0646|\u0645 \u06A4|\u0631\u0633\u0627|\u0645\u0645\u06A4| \u0645\u0631|\u0646 \u062D| \u0643\u0645|\u0646\u0633\u064A|\u062C\u0623\u0646|\u0624\u064A |\u0644\u0624\u064A|\u0627\u0644\u0624|\u0644\u0627\u0644|\u0643\u06A4\u0631|\u0643\u062A |\u0631\u0643\u062A|\u0634\u0627\u0631|\u0645\u0634\u0627| \u0645\u0634|\u062C\u0627\u062F|\u0631\u06AC\u0627",
    skr: "\u062A\u06D2 |\u0627\u06BA |\u062F\u06CC |\u062F\u06D2 | \u06D4 |\u0648\u06BA | \u062A\u06D2| \u062F\u0627| \u06A9\u0648|\u06A9\u0648\u06BA| \u062D\u0642|\u062F\u0627 | \u062F\u06CC|\u06CC\u0627\u06BA| \u062F\u06D2|\u06CC\u06BA |\u06D2 \u0627|\u0634\u062E\u0635| \u0634\u062E|\u06C1\u0631 |\u06D2 \u06D4|\u0627\u0635\u0644| \u062D\u0627|\u062D\u0642 |\u062E\u0635 | \u06C1\u0631|\u0635\u0644 |\u062D\u0627\u0635|\u06C1\u06D2 | \u06C1\u06D2|\u0627\u0644 |\u0642 \u062D|\u0644 \u06C1| \u0646\u0627| \u06A9\u06CC| \u0648\u0686|\u06D4 \u06C1|\u06CC\u0627 |\u0633\u06CC |\u06D2 \u0645| \u0627\u0648|\u0648\u0686 |\u0627\u062A\u06D2|\u06A9\u06CC\u062A|\u0627 \u062D|\u0627\u062F\u06CC|\u0646\u0627\u0644|\u0635 \u06A9| \u0627\u062A|\u0631 \u0634|\u06C1\u06CC\u06BA| \u06CC\u0627|\u06BA \u062F| \u0627\u06CC|\u06CC\u0633\u06CC| \u0645\u0644|\u0648\u0646\u062F|\u06A9\u06C1\u06CC| \u06A9\u06C1|\u06CC \u062A|\u0632\u0627\u062F|\u0627\u0632\u0627| \u0627\u0632|\u0646\u062F\u06D2|\u06BA \u06A9|\u0627\u0631 | \u0648\u06CC|\u06D2 \u06A9|\u0626\u06D2 | \u0627\u0646|\u06BB \u062F|\u0646\u06C1 | \u06A9\u0631|\u0627\u0648\u0646|\u06D2 \u0648|\u062F\u06CC\u0627|\u06CC \u062F|\u06BA \u0627|\u06D2 \u0628|\u0648\u06CC\u0633|\u0648\u06BB |\u06CC \u0646| \u06C1\u0648|\u062A\u06CC |\u06CC \u06D4| \u0646\u06C1|\u06CC \u0627|\u06CC\u0646\u062F|\u0648 \u0684|\u0622\u067E\u06BB| \u0622\u067E|\u0627 \u0648|\u06D2 \u062C| \u06A9\u0646|\u06D2 \u0646|\u0646\u062F\u06CC|\u062A \u062F|\u06D2 \u062D|\u06CC \u06A9|\u0626\u06CC |\u0645\u0644\u06A9|\u06CC\u062A\u06D2|\u0646 \u06D4|\u062A\u06BE\u06CC| \u062A\u06BE|\u0648\u0646 |\u06BA \u0645| \u0628\u0686|\u06D4 \u0627|\u0646\u0648\u06BA|\u06A9\u0646\u0648|\u06BB\u06D2 |\u0627\u0631\u06CC|\u0627 \u0627|\u06D2 \u06C1|\u0644 \u062A| \u0684\u0626|\u0648\u0642 |\u0642\u0648\u0642|\u062D\u0642\u0648|\u0644 \u06A9|\u062E\u0644\u0627| \u062C\u06CC|\u0644\u06A9 |\u062F\u0627\u0631|\u06CC\u062A |\u06A9\u0631\u06BB|\u0627\u0646\u06C1|\u06A9\u0648 |\u06C1\u06A9\u0648| \u06C1\u06A9|\u0646 \u0627|\u0645\u0644 | \u0648\u0633|\u06BA \u0648|\u067E\u06BB\u06D2| \u062A\u0639|\u06CC \u0645|\u0627\u0641 |\u06D2 \u062E|\u0646\u0648\u0646|\u0642\u0646\u0648| \u0642\u0646| \u0644\u0648|\u06D4 \u06A9|\u0631\u06CC |\u0644\u06D2 |\u062A\u0627 |\u06CC\u062A\u0627| \u0642\u0648| \u0686\u0627|\u06C1\u0627\u06BA|\u0684\u0626\u06D2|\u0642 \u062A|\u0627\u06CC\u06C1|\u0631\u06BB |\u06D2 \u062F|\u0631 \u06A9| \u0648 |\u0644\u0627\u0641| \u062E\u0644| \u062C\u0648|\u06CC \u0648|\u0627\u0648 |\u06C1\u0648 |\u0626\u0648 |\u0686\u0626\u0648|\u0628\u0686\u0626|\u06CC\u0631 |\u06C1\u0648\u0648|\u0627 \u0645|\u06CC \u062C|\u0627\u0644\u0627|\u06CC\u0646 | \u062C\u0627|\u0645\u06CC |\u0646\u06C1\u0627|\u0627\u0646 |\u0627\u062A |\u0633\u06B1\u062F| \u0633\u06B1|\u06CC\u0628 |\u0633\u06CC\u0628|\u0648\u0633\u06CC| \u0634\u0627|\u0628 \u062F|\u06CC\u0648\u06BB|\u0627\u0645 |\u0627\u0648\u06BB|\u06D2 \u062A|\u06BB \u06A9| \u0645\u0637|\u06BA \u062A| \u0648\u0646| \u06A9\u0645|\u0646 \u062F|\u0631\u06A9\u06BE| \u0631\u06A9|\u06BB\u06CC |\u06BA \u0622|\u0631\u06CC\u0627|\u06CC \u06C1|\u0627\u062F |\u06CC\u0627\u062F|\u0639\u0644\u0627|\u0631 \u06C1|\u06BA \u0633|\u06CC \u062D|\u062C\u06BE\u06CC|\u0627\u0626\u062F|\u06C1\u06CC |\u0644\u0648\u06A9| \u068B\u0648| \u0633\u0645| \u0633\u0627| \u0645\u0646| \u0645\u0639|\u0628\u0642 |\u0627\u0628\u0642|\u0637\u0627\u0628|\u0645\u0637\u0627|\u06BE\u06CC\u0648|\u06BA \u0641|\u06C1\u0646 | \u06C1\u0646|\u062C\u0648 |\u0648 \u06A9|\u06BA \u0634|\u0631 \u062A|\u06A9\u0627\u0631|\u0645 \u062F|\u06BE\u06CC\u0627| \u067B\u0627|\u063A\u06CC\u0631|\u0648 \u0644|\u0648\u0626\u06CC|\u062C\u06CC\u0627|\u0648\u0627\u0645|\u0642\u0648\u0627|\u06CC \u0633| \u062C\u06BE|\u0644 \u0627|\u0642\u0648\u0645| \u0633\u06CC|\u0630\u06C1\u0628|\u0645\u0630\u06C1| \u0645\u0630|\u0627\u06D2 | \u0627\u06D2|\u062F\u0646 |\u0627 \u062A|\u0633\u0627\u0646|\u0646\u0633\u0627|\u0627\u0646\u0633|\u0631\u06D2 |\u0644\u06CC\u0645|\u0639\u0644\u06CC|\u062A\u0639\u0644|\u0627\u0645\u0644|\u06C1 \u062F|\u06D2 \u0631|\u062F \u0627|\u06A9\u0645 |\u06CC\u06C1\u0648|\u0641\u0627\u0626|\u0686 \u0627| \u06A9\u06BE|\u0645 \u062A|\u0631\u0627 |\u0648\u0631\u0627|\u067E\u0648\u0631|\u06BA \u0628|\u0642 \u062F|\u06D2 \u0642|\u0648\u06A9\u0648|\u06A9\u06BE\u06CC|\u0627 \u06A9|\u0648 \u062F|\u06D2 \u0630|\u067E\u06BB\u06CC|\u0628\u0646\u062F| \u0641\u0631|\u06A9\u0648\u0626|\u0627\u0645\u06CC|\u06CC \u06CC|\u0627\u0626\u06CC|\u0644\u0627\u0642|\u0627\u06CC\u06BA|\u06C1 \u0627| \u0646\u0638|\u0633\u0645\u0627|\u0648\u0645\u06CC|\u06CC\u060C |\u06D2 \u0633|\u062A \u0648|\u06BE\u06CC\u0646|\u06D2 \u0639|\u06CC\u0645 |\u0633\u06C1\u0648| \u0633\u06C1",
    pbu: " \u062F | \u0627\u0648|\u0627\u0648 |\u067E\u0647 | \u067E\u0647|\u064A\u06D4 | \u062D\u0642|\u0686\u06D0 | \u0686\u06D0|\u0631\u0647 |\u064A \u0627|\u06D0 \u062F| \u0647\u0631|\u0646\u0647 |\u0647\u0631 |\u062D\u0642 | \u0685\u0648|\u0648\u06A9 |\u0685\u0648\u06A9|\u0648 \u0627|\u0647 \u062F|\u0647 \u0627|\u06D4 \u0647|\u0647 \u0648| \u0634\u064A| \u0644\u0631|\u064A \u0686|\u0648 \u062F|\u0631\u064A |\u0644\u0631\u064A|\u0642 \u0644| \u06A9\u069A|\u0648\u064A |\u069A\u06D0 |\u06A9\u069A\u06D0|\u0647 \u06A9|\u063A\u0647 |\u0644\u0648 |\u0631 \u0685|\u0633\u0631\u0647| \u0633\u0631|\u0647 \u067E| \u067C\u0648|\u0648 \u067E|\u0644\u0647 |\u064A\u062A |\u067C\u0648\u0644|\u064A\u0627 |\u06A9\u0693\u064A| \u06A9\u0648|\u062E\u0647 |\u064A\u060C |\u062F\u064A | \u0644\u0647| \u0627\u0632|\u062F \u0645| \u0647\u064A| \u0648\u0627| \u064A\u0627| \u0685\u062E|\u0627\u0632\u0627|\u062F \u0627|\u0648\u0644\u0648|\u0647 \u062A|\u0685\u062E\u0647| \u06A9\u0693|\u0648\u0644 |\u0647\u063A\u0647|\u0647 \u0634|\u064A \u062F| \u0647\u063A|\u06A9\u0648\u0644|\u0632\u0627\u062F|\u0646\u0648 | \u0648\u064A|\u0648 \u064A|\u0647 \u0628|\u0634\u064A\u06D4|\u062F\u06D0 |\u064A\u0648 | \u062F\u064A|\u062A\u0647 |\u062E\u067E\u0644| \u067E\u0631|\u0627\u062F |\u062F \u062F|\u06A9 \u062D| \u062A\u0648|\u0647 \u0645|\u06AB\u0647 |\u0647 \u0647|\u0642\u0648\u0642|\u062D\u0642\u0648|\u0648 \u0645|\u0647 \u062D|\u062F \u0647| \u062A\u0631| \u0645\u0633|\u0634\u064A | \u0646\u0647|\u0693\u064A\u06D4|\u0646\u064A |\u062F \u067E|\u0648\u0627\u062F|\u06D0 \u067E|\u0627\u062F\u064A|\u0648\u0644\u0646| \u064A\u0648|\u062F \u062A|\u0648\u0646\u0648|\u0648\u06AB\u0647|\u064A \u0648|\u0644\u064A | \u062F\u0627|\u064A\u062F | \u0628\u0627|\u062A\u0648\u0646| \u062E\u067E|\u064A \u067E|\u062A\u0648\u06AB|\u0627\u0631 |\u0627\u0646\u062F|\u064A\u0648\u0627|\u06D0 \u0648|\u062F\u0627\u0646| \u0628\u0631|\u0693\u064A | \u0639\u0645|\u0627\u0646\u0647| \u062F\u0647|\u064A\u0685 |\u0647\u064A\u0685|\u0627\u0645\u064A|\u0644\u0646\u064A|\u0628\u0639\u064A|\u0689\u0648\u0644| \u0689\u0648|\u0647 \u0644|\u0627\u064A\u062F|\u0628\u0627\u064A|\u0627\u062A\u0648|\u0647 \u06AB| \u062A\u0627|\u067E\u0644 | \u0645\u0644|\u0627\u064A\u062A|\u0648\u0645 |\u0648\u0646 | \u0644\u0627|\u0647\u064A\u0648| \u0634\u0648| \u062F\u063A|\u0645 \u062F|\u062F\u0647 |\u06D0 \u0627|\u0627\u0646 | \u062A\u0647|\u06A9\u0627\u0631|\u062A\u0648 |\u0645\u064A |\u0627\u0631\u0647|\u0627\u0648\u064A|\u0633\u0627\u0648|\u0645\u0633\u0627|\u0646\u0648\u0646|\u062F\u0647\u063A|\u0648 \u062A|\u064A \u0634|\u0627\u0646\u0648| \u0645\u062D|\u064A\u0646 |\u0627\u062E\u0644| \u06AB\u067C|\u0634\u0648\u064A|\u062F\u063A\u0647|\u0648 \u062D|\u0648\u064A\u060C|\u0646\u064A\u0632|\u0633\u064A |\u0627\u0633\u064A|\u0648\u0646\u062F|\u0642\u0648 |\u0648\u0642\u0648|\u0648 \u06A9|\u0648\u0646\u0647|\u0648\u0645\u064A| \u0648\u06A9|\u064A \u062A| \u0627\u0646|\u0642\u0627\u0646|\u0646\u062F\u06D0|\u0648 \u0631|\u06A9 \u062F|\u0647 \u064A|\u0645\u064A\u0646|\u067E\u0631 |\u067C\u0647 |\u0644\u0627\u0645|\u063A\u0648 |\u0647\u063A\u0648|\u062F \u067C|\u0648 \u0647|\u0644 \u062A|\u0644\u06D2 |\u0648\u0644\u06D2|\u0648\u0648\u0646|\u06A9\u064A |\u0631\u0648 |\u0646 \u06A9|\u0645\u0648\u0645|\u0648\u06A9\u0693|\u067E\u0627\u0631|\u0646 \u0634|\u0645\u0646 | \u0646\u0648| \u0648\u0693| \u0642\u0627|\u06D0 \u0686| \u0648\u0633|\u0685 \u0685|\u0634\u062E\u0635| \u0634\u062E|\u0698\u0648\u0646| \u0698\u0648|\u062A\u0631 |\u06AB\u067C\u0647|\u0648 \u0685|\u0647\u0645 |\u0639\u0642\u064A|\u0631\u062A\u0647| \u0648\u0631|\u0628\u0644 | \u0628\u0644|\u0648 \u0628|\u0647 \u0633|\u069A\u0648\u0648| \u069A\u0648| \u06A9\u0627|\u06D0 \u06A9|\u0648 \u0633|\u0627\u062F\u0647|\u0648\u0646\u06A9| \u063A\u0648|\u062F\u0648 |\u0648 \u0646|\u062A \u06A9|\u0645\u0644 |\u0639\u0645\u0648|\u0644 \u0647| \u067E\u064A|\u0648\u0633\u064A|\u0693\u0627\u0646|\u0648\u0693\u0627|\u064A\u0632 |\u062E\u0635\u064A|\u064A \u0645|\u0627 \u0628|\u0627\u062F\u0627|\u0647 \u0646|\u062E\u0644\u064A|\u0648\u0627\u062E|\u062F\u064A\u0648|\u060C \u062F|\u062F \u0642| \u0647\u0645|\u0627 \u062F| \u0628\u064A|\u062A\u0628\u0639| \u062A\u0628|\u0647 \u0686| \u0639\u0642|\u067E\u0644\u0648|\u0648 \u0644| \u0631\u0627|\u062F \u0628|\u0631\u0627\u064A| \u062F\u062E|\u0646\u06D0 |\u0646\u06A9\u064A|\u062A \u062F|\u0627\u0628\u0639| \u0645\u0642|\u062F \u062E|\u0648\u0631\u0647|\u0634\u0631\u0627| \u0634\u0631|\u0631 \u0645|\u0631\u0633\u0631|\u062A\u0627\u0645|\u0647 \u067C| \u0645\u0646|\u0637\u0647 |\u0633\u0637\u0647|\u0627\u0633\u0637|\u0648\u0627\u0633|\u0644\u06D0 | \u0627\u0633|\u06D4 \u062F|\u0628\u0631\u062E|\u06D0 \u0646"
  },
  Devanagari: {
    hin: "\u0915\u0947 |\u092A\u094D\u0930| \u092A\u094D| \u0915\u093E| \u0915\u0947| \u0964 |\u0914\u0930 | \u0914\u0930|\u0915\u093E | \u0915\u094B|\u0915\u093E\u0930|\u093E\u0930 |\u0924\u093F |\u092F\u093E |\u0915\u094B |\u0928\u0947 |\u094B\u0902 |\u093F\u0915\u093E|\u094D\u0930\u0924| \u0939\u0948| \u0915\u093F|\u0902 \u0915|\u0939\u0948 |\u0927\u093F\u0915|\u0935\u094D\u092F|\u0905\u0927\u093F| \u0905\u0927|\u094D\u0924\u093F| \u0938\u092E|\u094D\u092F\u0915|\u093F \u0915|\u0915\u094D\u0924|\u093E \u0905|\u0915\u0940 |\u093E \u0915| \u0935\u094D|\u0947\u0902 | \u0939\u094B|\u092F\u0915\u094D|\u0938\u0940 |\u0938\u0947 |\u0947 \u0915| \u092F\u093E| \u0915\u0940|\u092E\u0947\u0902|\u0928\u094D\u0924| \u092E\u0947|\u0924\u094D\u092F|\u0948 \u0964|\u0924\u093E |\u0930\u0924\u094D|\u0915\u094D\u0937|\u0947\u0915 |\u092F\u0947\u0915|\u094D\u092F\u0947|\u093F\u0915 |\u0930 \u0939|\u092D\u0940 |\u0915\u093F\u0938| \u091C\u093E| \u0938\u094D|\u0915 \u0935|\u093E \u091C|\u093F\u0938\u0940|\u092E\u093E\u0928| \u0935\u093F|\u0930 \u0938|\u0924\u094D\u0930|\u0940 \u0938|\u0964 \u092A| \u0915\u0930|\u094D\u0930\u093E|\u0917\u093E |\u093F\u0924 | \u0905\u092A| \u092A\u0930|\u0938\u094D\u0935|\u0940 \u0915| \u0938\u0947|\u093E \u0938|\u094D\u092F | \u0905\u0928|\u094D\u0924\u094D|\u093F\u092F\u093E|\u093E \u0939| \u0938\u093E|\u0928\u093E |\u094D\u0924 |\u092A\u094D\u0924|\u0938\u092E\u093E|\u093E\u0928 |\u0930 \u0915|\u093E\u092A\u094D|\u0924\u0928\u094D| \u092D\u0940| \u0909\u0938|\u0930\u093E\u092A|\u0935\u0924\u0928|\u094D\u0935\u0924|\u0930\u094B\u0902|\u0935\u093E\u0930|\u0947 \u0938|\u0925\u093E |\u0939\u094B |\u0947 \u0905|\u093E \u0964|\u0928 \u0915| \u0928 |\u0926\u0947\u0936| \u0930\u093E|\u0937\u093E |\u0905\u0928\u094D|\u0924 \u0939|\u094D\u0937\u093E|\u094D\u0935\u093E|\u091C\u093E\u090F|\u0940 \u092A|\u0915\u0930\u0928|\u093E \u092A|\u0905\u092A\u0928|\u0937\u094D\u091F| \u0938\u0902|\u0947 \u0935|\u0939\u094B\u0917|\u093F\u0935\u093E|\u091F\u094D\u0930|\u094D\u091F\u094D|\u093E\u0937\u094D|\u0930\u093E\u0937|\u0938\u0915\u0947| \u092E\u093E|\u0913\u0902 |\u093E\u0913\u0902|\u0930\u0940 |\u0915 \u0938|\u0947 \u092A| \u0928\u093F|\u0940\u092F |\u0930\u0915\u094D|\u094B \u0938|\u093E\u090F\u0917|\u0930\u0928\u0947| \u0907\u0938|\u0935 \u0915|\u092A\u0930 |\u0930\u0924\u093E|\u0930 \u0905| \u0938\u092D|\u0924\u0925\u093E| \u0924\u0925| \u0910\u0938|\u0930\u093E |\u092A\u0928\u0947|\u094D\u0930\u0940|\u093F\u0915\u094D|\u0915\u093F\u092F|\u093E \u0935|\u092E\u093E\u091C|\u0902 \u0914|\u0930 \u0909|\u0926\u094D\u0927|\u0938\u092D\u0940|\u0936\u094D\u092F| \u091C\u093F|\u093E\u0928\u0947|\u093E\u0930\u094D|\u093E\u0930\u093E|\u0926\u094D\u0935| \u0926\u094D|\u090F\u0917\u093E|\u0938\u092E\u094D|\u0947\u0936 |\u093F\u090F |\u093E\u0935 |\u0930 \u092A| \u0926\u0947|\u094D\u0924\u0930|\u093E \u0914|\u093E\u0930\u094B|\u092F\u094B\u0902|\u092A\u0930\u093E|\u092A\u0942\u0930|\u091A\u093F\u0924|\u094D\u0927 |\u0930\u0942\u092A| \u0930\u0942| \u0938\u0941| \u0932\u093F|\u0924 \u0915|\u094B \u092A|\u0902 \u0938|\u0947 \u0932|\u0936\u093F\u0915| \u0936\u093F|\u0935\u093E\u0939|\u0947 \u0914|\u091C\u094B |\u0930\u093E\u0927|\u091C\u093F\u0938|\u0942\u0930\u094D|\u0940 \u092D|\u0942\u092A |\u094B\u0917\u093E|\u0938\u094D\u0925|\u0930\u0940\u092F|\u0924\u093F\u0915|\u094D\u0930 |\u0964 \u0907|\u0907\u0938 | \u0909\u0928|\u0932\u0947 |\u0947 \u092E|\u0932\u093F\u090F|\u092E \u0915|\u0915\u0924\u093E|\u0947 \u092F| \u091C\u094B|\u0928 \u092E|\u0905\u092A\u0930| \u092A\u0942|\u094B \u0915|\u093E \u0909|\u093E\u0939 |\u0928\u0942\u0928|\u093E\u0928\u0942|\u0917\u0940 |\u0926\u0940 |\u093E\u0930\u0940|\u0902 \u092E|\u0964 \u0915|\u0924\u0930\u094D|\u0940 \u0930|\u0936 \u0915|\u092A\u0930\u093F|\u0938\u094D\u0924|\u094B\u0908 |\u0915\u094B\u0908|\u0930\u094D\u092F|\u0940 \u0905|\u0939\u093F\u0924|\u092D\u093E\u0935| \u092D\u093E|\u0924\u093E\u0913|\u093E\u0938 |\u0938\u093E\u092E|\u0935\u093F\u0915|\u0935\u093F\u0935|\u092E\u094D\u092E| \u0938\u0915|\u0915\u0930 |\u093E\u0928\u093E|\u0927 \u0915|\u0928\u093F\u0915|\u092F \u0915|\u0909\u0938\u0915|\u0915\u0943\u0924| \u0958\u093E|\u0928 \u0938|\u091C\u0940\u0935|\u094D\u092F\u093E|\u0930\u0915\u093E|\u094D\u0930\u0915|\u093E\u091C |\u0928\u094D\u092F|\u094D\u092E |\u0930\u094D\u0923|\u0958 \u0939|\u0939\u0958 | \u0939\u0958|\u0940 \u092E|\u091C\u093F\u0915|\u093E\u091C\u093F|\u093E\u092E\u093E|\u0915 \u0914|\u092E\u093F\u0932|\u0947\u0928\u0947|\u0932\u0947\u0928| \u0932\u0947|\u092F\u0947 |\u094B \u0905|\u0947 \u091C|\u0930\u093F\u0935|\u092E\u092F |\u0938\u092E\u092F|\u0935\u0936\u094D|\u0906\u0935\u0936| \u0906\u0935|\u0910\u0938\u0940|\u093E\u0927 |\u0930 \u0926|\u0930\u094D\u0935|\u0938\u093E\u0930|\u092A \u0938|\u092C\u0928\u094D| \u0938\u0939|\u093F\u0927\u093E|\u0935\u093F\u0927|\u0940 \u0928|\u0942\u0928 |\u0958\u093E\u0928",
    mar: "\u094D\u092F\u093E|\u092F\u093E |\u0924\u094D\u092F|\u092F\u093E\u091A|\u091A\u093E |\u0923\u094D\u092F|\u093E\u091A\u093E| \u0935 |\u0915\u093E\u0930|\u092A\u094D\u0930| \u092A\u094D|\u093F\u0915\u093E|\u0927\u093F\u0915|\u093E\u0930 | \u0905\u0927|\u0905\u0927\u093F|\u091A\u094D\u092F|\u0906\u0939\u0947| \u0906\u0939|\u093E \u0905|\u0939\u0947 |\u093E \u0915|\u093E\u0938 |\u0935\u093E |\u094D\u092F\u0947|\u094D\u0930\u0924| \u0938\u094D|\u0924\u093E |\u093E \u0938| \u0905\u0938| \u0915\u0930|\u0938\u094D\u0935| \u0915\u093E|\u0932\u094D\u092F|\u0930\u0924\u094D|\u093E\u0939\u093F|\u0915\u094B\u0923| \u0915\u094B|\u093F\u0915 |\u092F\u0947\u0915|\u094D\u0935\u093E|\u093E \u0935| \u0924\u094D|\u0930 \u0906|\u094D\u092F |\u0924\u094D\u0930|\u0947\u0915\u093E|\u0915\u094D\u0937|\u093E \u0928| \u0938\u0902|\u093E\u092E\u093E|\u093E\u091A\u094D|\u0902\u0935\u093E|\u093F\u0902\u0935|\u0915\u093F\u0902| \u0915\u093F|\u093E\u0924 |\u0937\u094D\u091F|\u0915\u093E\u0938| \u092F\u093E|\u092F\u093E\u0902|\u093E\u0902\u091A|\u0930\u094D\u092F|\u092E\u093F\u0933| \u092E\u093F| \u0938\u093E|\u0935\u094D\u092F|\u094B\u0923\u0924|\u0928\u0947 |\u0947 \u092A|\u0915\u093E\u092E| \u0938\u092E|\u0902\u0924\u094D|\u092F\u0947 | \u0930\u093E|\u0938\u092E\u093E|\u0924\u0902\u0924|\u0915\u0930\u0923|\u093E \u0906|\u0947 \u0915|\u0939\u093F |\u0947 \u0938|\u0928\u093E |\u093F\u0933\u0923|\u0942\u0928 |\u093E \u092A|\u091F\u094D\u0930|\u094D\u091F\u094D|\u093E\u0937\u094D|\u0930\u093E\u0937|\u0940\u092F |\u0935 \u0938|\u0915\u094D\u0924|\u092E\u093E\u0928|\u0930\u094D\u0935| \u0906\u092A|\u0933\u0923\u094D|\u094D\u0930\u094D|\u093E\u0924\u0902|\u0935\u093E\u0924|\u091A\u0947 | \u0935\u093F|\u094D\u0937\u0923|\u0930\u0923\u094D| \u0926\u0947| \u0935\u094D|\u0906\u092A\u0932|\u0939\u0940 |\u093E\u0930\u094D|\u0928\u092F\u0947| \u0928\u092F|\u092E\u093E |\u092F\u093E\u0938| \u091C\u093E|\u0932\u0947\u0932| \u0928\u093F|\u0947 \u0905| \u092A\u093E|\u093E \u092E|\u0932\u0947 |\u093E\u0939\u0940|\u092C\u0902\u0927|\u0947 \u0935|\u094D\u092F\u0915| \u092E\u093E|\u0936\u093F\u0915| \u0936\u093F|\u0926\u0947\u0936|\u093E \u0926|\u092E\u093E\u091C|\u094D\u0930\u0940|\u0932\u0940 |\u093E\u0928 |\u093E\u0902\u0928|\u092A\u0932\u094D| \u0939\u094B|\u093E \u0939|\u0937\u0923 |\u091C\u0947 |\u093F\u091C\u0947|\u0939\u093F\u091C|\u092A\u093E\u0939|\u093E\u0930\u093E|\u092F\u093E\u0924|\u0938\u0930\u094D| \u0938\u0930|\u0930\u093E\u0902|\u0905\u0938\u0932|\u0902\u092C\u0902|\u0938\u0902\u092C|\u093F\u0915\u094D|\u0940 \u092A|\u0902\u091A\u094D|\u0930\u0915\u094D|\u0923\u0924\u094D| \u0906\u0923|\u0932\u093E |\u0938\u094D\u0925|\u0930\u0940\u092F|\u0940\u0924 |\u0902\u0928\u093E|\u0924 \u0935|\u094D\u0935 |\u0915 \u0935|\u0923\u0947 |\u093E\u091A\u0947|\u0928 \u0915|\u0924 \u0915|\u0930\u0924\u093E|\u094D\u0930\u093E|\u092F\u093E\u0939|\u094D\u0924 |\u091A\u0940 |\u092F \u0915|\u0926\u094D\u0927|\u094D\u0935\u0924|\u092F\u0915\u094D|\u0923\u093F |\u0906\u0923\u093F|\u0938 \u0938|\u0902\u0927\u093E|\u0915 \u0938|\u091A\u094D\u091B|\u092F \u0905|\u0924 \u0938|\u0940\u0928\u0947|\u094B\u0923\u093E|\u0915\u0930\u0924|\u0924\u094D\u0935|\u0940\u0932 |\u0940 \u0905|\u0938\u093E\u0930|\u0930 \u0935|\u092D\u093E\u0935|\u0935 \u0924|\u0925\u0935\u093E|\u0905\u0925\u0935| \u0905\u0925|\u0947 \u0924|\u0947 \u091C|\u092F\u093E\u092F|\u0902\u091A\u093E|\u0947\u0932\u094D|\u093E\u0928\u0947|\u0947\u0923\u094D|\u0915 \u0906|\u0915\u094D\u0915|\u0939\u0915\u094D| \u0939\u0915|\u0923 \u092E|\u0902\u0930\u0915|\u0938\u0902\u0930|\u0928\u094D\u092F|\u093E\u092F\u0926|\u093E \u0924|\u0924 \u0906| \u0909\u092A|\u0935\u0938\u094D|\u093F\u0935\u093E|\u0947\u0936\u093E|\u0938\u093E\u092E|\u0947 \u092F|\u0947 \u0906|\u0940 \u0935|\u0935 \u092E|\u0924\u0940\u0928|\u0935 \u0906|\u0927\u094D\u092F| \u0905\u0936|\u0927\u093E\u0924|\u0915\u0943\u0924|\u094D\u0915 |\u0926\u094D\u092F|\u093F\u0924 |\u0938\u0932\u0947|\u0947\u0936 |\u0924\u094B |\u0947\u0932 |\u0924\u0940 |\u094D\u0924\u0940|\u0905\u0938\u0947|\u0907\u0924\u0930| \u0907\u0924|\u0938\u094D\u0924|\u0930\u094D\u0923|\u093E \u092C|\u0947\u0932\u0947| \u0915\u0947|\u0939\u0940\u0930|\u091C\u093E\u0939|\u093E \u091C|\u0947\u0924 |\u0942\u0930\u094D|\u092A\u0942\u0930|\u0947\u091A | \u0935\u093E|\u093E\u091C\u093E|\u0940 \u0938|\u0936\u093E |\u092F \u0935| \u0928\u094D|\u092F\u093E\u0935|\u0926\u094D\u0926|\u094D\u0927 |\u0930\u0942\u0928|\u092F\u0926\u094D|\u0915\u093E\u092F|\u093E \u0936|\u0917\u0923\u094D|\u0915 \u0915|\u0930\u093E\u0927| \u0936\u093E|\u092F\u0924\u094D|\u0932 \u0905|\u094D\u092F\u0935|\u0940 \u0915|\u093E\u0935 |\u093E \u092F|\u0924\u094D\u0924|\u091C\u093F\u0915|\u093E\u091C\u093F|\u0930\u0923\u093E| \u0927\u0930|\u093E \u0927|\u092D\u0947\u0926| \u092C\u093E|\u0930\u0915\u093E|\u094D\u0930\u0915|\u0915\u0947\u0932|\u093F \u0935|\u093F\u0937\u094D|\u0924\u0940\u0932|\u092F\u094B\u0917|\u0938\u093E\u0927|\u093E\u0902\u0924|\u0935\u093F\u0935|\u0936\u094D\u0930| \u0927\u0947| \u092E\u0941|\u0935\u0924\u0903",
    mai: "\u093E\u0915 |\u092A\u094D\u0930|\u0915\u093E\u0930| \u092A\u094D|\u093E\u0930 |\u093F\u0915\u093E|\u094D\u092F\u0915|\u0927\u093F\u0915|\u0915 \u0905|\u094D\u0930\u0924|\u094D\u0924\u093F|\u0935\u094D\u092F| \u0905\u0927|\u0947\u0901 |\u0905\u0927\u093F|\u093F\u0915 | \u0935\u094D|\u0906\u02BC | \u0906\u02BC|\u0915\u094D\u0924|\u092F\u0915\u094D|\u0924\u093F\u0915|\u0915\u0947\u0901|\u0915 \u0935|\u092C\u093E\u0915|\u0915 \u0938|\u091B\u0948\u0915| \u091B\u0948|\u0924\u094D\u092F|\u092E\u0947 |\u0947\u0915 | \u0938\u092E|\u0915\u094D\u0937|\u0939\u093F |\u0930\u0924\u094D|\u0930 \u091B|\u092F\u0947\u0915|\u094D\u092F\u0947|\u0928\u094D\u0924|\u0935\u093E |\u093F\u0915\u0947|\u0915\u0964 |\u0948\u0915\u0964|\u0964 \u092A| \u0905\u092A| \u0938\u094D| \u0935\u093F| \u091C\u093E|\u093F\u0924 |\u0938\u0901 | \u0939\u094B|\u0915\u094B\u0928| \u0915\u094B|\u0924\u094D\u0930|\u0938\u094D\u0935| \u0935\u093E|\u0915 \u0906|\u0937\u094D\u091F| \u0915\u0930|\u0905\u092A\u0928|\u092E\u093E\u0928| \u0915\u093E| \u0905\u0928|\u0924\u093F |\u094D\u0924\u094D|\u0928\u094B |\u0928\u0939\u093F| \u092A\u0930|\u091F\u094D\u0930|\u094D\u092F | \u090F\u0939|\u093F \u0915|\u094D\u091F\u094D|\u093E\u0937\u094D|\u0930\u093E\u0937| \u0930\u093E|\u0938\u092E\u093E|\u094B\u0928\u094B|\u0932 \u091C| \u0928\u0939|\u0924\u093E\u0915|\u093E\u0930\u094D|\u092A\u0928 |\u0924\u0928\u094D|\u0935\u0924\u0928|\u094D\u0935\u0924|\u094D\u0937\u093E| \u0915\u090F| \u0938\u093E|\u094D\u0930\u0940| \u0928\u093F|\u093E \u0906|\u093F\u0935\u093E| \u0938\u0902| \u0926\u0947|\u091C\u093E\u090F|\u0940\u092F |\u0915\u0930\u092C|\u0925\u093E |\u090F\u092C\u093E|\u093E \u092A|\u0928\u093E |\u094D\u0935\u093E|\u0926\u0947\u0936|\u0924\u0964 |\u0930\u0915 |\u0915 \u0939|\u0901 \u0905| \u0938\u092D| \u0906 |\u0924 \u0915|\u091A\u093F\u0924|\u094D\u0924 |\u0935\u093E\u0930|\u0924\u093E |\u093E\u0930\u0915|\u092E\u093E\u091C|\u093E \u0938|\u0930\u0940\u092F|\u0928\u094D\u092F|\u0930\u0924\u093E|\u093E\u0928 |\u094D\u0930\u093E|\u094D\u092F\u093E|\u0930\u0915\u094D|\u093E\u0930\u0923|\u092A\u0930\u093F|\u090F\u0932 |\u0915\u090F\u0932|\u0905\u0928\u094D|\u0930\u092C\u093E|\u0915 \u092A|\u0913\u0930 |\u0906\u0913\u0930| \u0906\u0913|\u0905\u091B\u093F| \u0905\u091B|\u093F\u0930\u094D|\u093E\u0928\u094D|\u0928\u0915 |\u0939\u094B\u090F|\u0915\u0930 |\u0927\u093E\u0930|\u0938\u094D\u0925|\u093E \u0905|\u093F\u092E\u0947|\u0930 \u0906|\u090F\u0939\u093F| \u090F\u0915|\u0947 \u0938|\u0924\u0925\u093E| \u0924\u0925| \u092E\u093E|\u093F\u0915\u094D|\u0936\u093F\u0915| \u0936\u093F|\u092A\u094D\u0924|\u0930\u094D\u0935|\u0928\u093F\u0930|\u091A\u094D\u091B|\u0930\u094D\u092F|\u0901 \u0938|\u0915 \u0915|\u0939\u094B |\u093E\u0939\u093F|\u090F\u0924\u0964|\u0930 \u092A|\u093E\u092E\u093E|\u0938\u093E\u092E|\u0937\u093E |\u02BC \u0938|\u0901 \u090F|\u0948\u0915 |\u0926\u094D\u0927|\u0930 \u0905|\u0915 \u091C|\u0938\u094D\u0924|\u093E\u092A\u094D|\u0901 \u0915| \u0938\u0915|\u092F\u0915 |\u0915\u093E\u0928|\u0939\u0928 |\u090F\u0939\u0928|\u0947\u0932 |\u094B\u090F\u0924|\u0924 \u0906|\u093E \u0935|\u0964 \u0915|\u094D\u0924\u0930|\u093E\u090F\u0924|\u094D\u0930\u0915|\u0939\u0941 |\u0915 \u0909|\u092A\u0942\u0930|\u0935\u093F\u0935|\u02BC \u0905|\u091B\u093F | \u0932\u0947|\u0928 \u092A|\u093E\u0938 |\u0930\u093E\u092A|\u0927\u0915 |\u092A\u090F\u092C| \u092A\u090F|\u0930\u093E |\u092F\u0924\u093E|\u0930\u0942\u092A|\u0928 \u0935| \u0915\u0947|\u0937\u093E\u0915|\u092F \u092A|\u0924 \u0939|\u091C\u093E\u0939| \u0913 |\u092D\u093E\u0935|\u092A\u0930 |\u0925\u0935\u093E|\u0905\u0925\u0935| \u0905\u0925|\u0938\u092E\u094D|\u091C\u093F\u0915|\u093E\u091C\u093F|\u0942\u0930\u094D|\u0930\u0924\u093F| \u0926\u094B|\u0938\u092D\u0915|\u0964 \u0938| \u091C\u0928|\u0938\u092D |\u092C\u093E\u0927|\u0905\u0928\u0941|\u093F\u0938\u0901| \u0938\u0939|\u0901 \u0935|\u090F \u0938|\u0930\u093F\u0935|\u0924\u0941 |\u0947\u0924\u0941|\u0939\u0947\u0924| \u0939\u0947|\u093E\u0927 |\u0947\u092C\u093E|\u0928 \u0938|\u093F\u0937\u094D|\u0930\u093E\u0927| \u0905\u0935|\u093F\u0924\u094D|\u0935\u093E\u0938|\u091A\u093E\u0930| \u0909\u091A|\u093E\u0930\u093E|\u0928 \u0915|\u0935\u0915 |\u093E \u0915|\u0928\u0942\u0928|\u093E\u0928\u0942|\u090F\u0924 |\u0930\u0940 |\u0947\u0913 |\u0915\u0947\u0913|\u0930\u0923 |\u094D\u0930\u0938|\u093F \u0926|\u0913 \u0935| \u092D\u0947|\u0928\u0939\u0941|\u094B\u0928\u0939|\u094D\u0925\u093F|\u092A\u0924\u094D|\u092E\u094D\u092A|\u0930\u093E\u091C| \u092D\u093E|\u0939\u093F\u092E| \u0939\u0915|\u093E\u092E\u0947|\u094D\u0923 |\u0930\u094D\u0923|\u0939\u093E\u0930|\u093F \u0938|\u0915 \u0926|\u0928 \u0905|\u0924 \u0905|\u0932\u0947\u092C| \u0905\u092D|\u093F\u0936\u094D|\u091C\u0915 |\u093E\u091C\u0915|\u0928 \u0906|\u0935\u093E\u0939|\u0915\u093E\u091C|\u0936\u094D\u092F|\u0935\u0938\u094D|\u0913\u0939\u093F| \u0913\u0939|\u092F\u094B\u0917|\u0964 \u090F|\u0915\u090F |\u0947 \u0913|\u0905\u092A\u0930",
    bho: " \u0915\u0947|\u0915\u0947 |\u0947 \u0915|\u093E\u0930 |\u0915\u093E\u0930|\u093F\u0915\u093E|\u0927\u093F\u0915|\u0905\u0927\u093F| \u0905\u0927|\u0913\u0930 |\u0906\u0913\u0930| \u0906\u0913|\u0947 \u0905|\u0947 \u0938|\u093E \u0915| \u0938\u0902|\u093F\u0915 |\u0930 \u0939|\u093E \u0938| \u0939\u094B|\u0930 \u0938|\u0947\u0902 |\u092E\u0947\u0902| \u092E\u0947| \u0915\u0930| \u0938\u0947|\u0928\u094B |\u0915\u094D\u0937|\u0938\u0947 | \u0915\u093E|\u0964 \u0938|\u0916\u0947 |\u093E\u0964 |\u0930\u093E | \u0938\u092E| \u0938\u092C|\u094D\u0930\u093E| \u0938\u0915|\u0930 \u0915|\u0928 \u0915|\u0935\u0947 |\u094C\u0928\u094B|\u0915\u094C\u0928| \u0915\u094C|\u091A\u093E\u0939| \u091A\u093E| \u092C\u093E|\u092A\u094D\u0930| \u092A\u094D|\u0925\u093E |\u093F \u0915|\u0924\u093F | \u091C\u093E| \u0938\u093E|\u0947 \u0906|\u092A\u0928 |\u0915\u0930\u0947|\u0924\u093E |\u0939\u094B\u0916|\u0924 \u0915|\u0947\u0964 |\u0947 \u092C|\u0924\u0925\u093E| \u0924\u0925| \u0906\u092A|\u0915\u0947\u0932|\u0938\u0915\u0947| \u0938\u094D|\u0930\u0947 |\u0938\u092C\u0939|\u0915\u0930 |\u0906\u092A\u0928|\u0947 \u0913|\u091C\u093E | \u092A\u0930|\u0937\u094D\u091F| \u0930\u093E|\u0928\u093E |\u0939\u0935\u0947| \u0939\u0935|\u0932\u093E |\u0947\u0932\u093E|\u092C\u0939\u093F| \u0913\u0915|\u094B\u0916\u0947|\u0930 \u092C|\u0939\u0964 | \u0939\u0964|\u0928 \u0938|\u093E\u0937\u094D|\u0930\u093E\u0937|\u094D\u0924 | \u0914\u0930|\u0947 \u091A|\u0964 \u0915|\u0938\u0902\u0917|\u0930 \u0906|\u091F\u094D\u0930|\u094D\u091F\u094D|\u0937\u093E |\u092E\u093E\u0928|\u093E \u0906|\u0902 \u0915|\u093E \u092A|\u094D\u0937\u093E|\u0930\u0915\u094D|\u0939\u0947 |\u093E\u0939\u0947|\u093E\u0924\u093F|\u093E\u0935\u0947| \u091C\u0947|\u0939\u0940 |\u0913\u0915\u0930|\u092E\u093F\u0932|\u093F\u0924 |\u094B \u0938|\u0932 \u091C|\u0907\u0916\u0947|\u0928\u0907\u0916| \u0928\u0907|\u0924\u094D\u0930|\u092E\u093E\u091C| \u092C\u093F|\u0935\u0947\u0964|\u0947 \u091C|\u0915 \u0938|\u093F\u0902 |\u0939\u093F\u0902|\u0915\u0930\u093E|\u0914\u0930 |\u0947 \u092E|\u0938\u092E\u093E|\u0939\u0941 | \u0913 |\u092A\u0930 |\u0947 \u0928|\u0938\u094D\u0925|\u0930\u0940\u092F|\u094D\u0930\u0940|\u0932\u093E\u0964|\u093E\u091C |\u093E\u0928 |\u0915\u093E\u0928|\u0947 \u0924|\u093F\u0930 |\u0924\u093F\u0930|\u0916\u093E\u0924| \u0916\u093E|\u0947 \u0909|\u0928\u0942\u0928|\u093E\u0928\u0942|\u093E\u092E | \u0938\u0941| \u0926\u0947|\u0940 \u0915| \u092E\u093E|\u0930 \u092E|\u092A\u094D\u0924|\u093F\u092F\u093E|\u093E\u0939\u0940|\u092C\u093E\u0964|\u092F\u094B\u0917|\u0940 \u0938|\u0932 \u0939|\u0942\u0928 |\u0935\u094D\u092F|\u0941 \u0915|\u090F \u0915|\u0947 \u0935|\u0902\u0924\u094D|\u0938\u094D\u0935|\u0915\u0947\u0939|\u0940\u092F |\u0916\u0932 |\u0938\u093E\u092E|\u092F\u0924\u093E|\u0924\u093F\u0915|\u0947 \u0939|\u093E\u092A\u094D|\u0930\u093E\u092A|\u0930 \u092A|\u0930 \u0905| \u0932\u094B| \u0938\u0939|\u091C\u0947 |\u094B\u0917 |\u092E \u0915|\u0932\u0947 | \u0928\u093F|\u0947\u0915\u0930|\u093E \u0939|\u092A\u0942\u0930|\u0930 \u0928|\u0947\u0939\u0941|\u094D\u092F |\u092F\u093E | \u092F\u093E|\u0926\u0947\u0936|\u0926\u0940 |\u093E \u092E|\u093E\u0935 | \u0926\u094B|\u0947 \u0926| \u092A\u093E|\u0939\u093F |\u093F\u0915\u094D|\u0936\u093F\u0915| \u0936\u093F|\u092C\u093E |\u093F\u0932 | \u0909\u092A|\u094D\u0930\u0924| \u0935\u093F| \u0939\u0940| \u0932\u0947|\u0930\u094B |\u0947 \u0916|\u0920\u0928 |\u0917\u0920\u0928|\u0902\u0917\u0920| \u092E\u093F|\u0937\u0923 |\u094D\u0937\u0923|\u0902\u0930\u0915|\u0938\u0902\u0930| \u0906\u0926| \u090F\u0915|\u0928\u0947 | \u0905\u092A|\u0924\u0902\u0924|\u0935\u0924\u0902|\u094D\u0935\u0924|\u094D\u0924\u0930|\u094D\u092F\u093E|\u0947\u0936 |\u093E\u0926\u0940|\u094D\u0924\u093F|\u091C\u093F\u0915|\u093E\u091C\u093F|\u0915 \u0906|\u094D\u092E |\u091A\u093E\u0930| \u0909\u091A| \u0936\u093E|\u0930\u0940 |\u093E\u0939 |\u092F\u093E\u0939|\u092C\u093F\u092F|\u091A\u093F\u0924|\u0915\u094D\u0924|\u092A\u092F\u094B|\u0909\u092A\u092F|\u0930\u0924\u093E|\u0930 \u0935|\u0928 \u092E|\u0932\u094B\u0917|\u0939 \u0915|\u0928 \u092A|\u0915\u093E\u092E| \u092A\u0942| \u0907 |\u0906\u0926\u093F|\u0908\u0932 | \u0915\u0908| \u0935\u094D|\u092E\u0940 |\u0941\u0930\u0915|\u0938\u0941\u0930| \u091C\u0940|\u0927\u093E\u0930|\u092F \u0938|\u0924\u0930\u094D|\u092D\u0947 |\u0938\u092D\u0947| \u0938\u092D|\u092D\u093E\u0935|\u094D\u0925\u093F|\u093E\u092E\u093E|\u0938\u0930 |\u0930\u094D\u092E| \u0915\u094B| \u092C\u0947|\u094B\u0938\u0930|\u0926\u094B\u0938|\u0923 \u0915|\u093E\u0938 |\u0947 \u092A|\u091C\u093E\u0926|\u0906\u091C\u093E| \u0906\u091C|\u0909\u091A\u093F|\u0917 \u0915|\u093E\u0930\u0940| \u091C\u0930|\u0917\u0947 |\u091C \u0915|\u0940 \u092C|\u0938\u0928 |\u0939\u094B |\u093E \u0924",
    npi: "\u0915\u094B |\u0928\u0947 | \u0930 |\u093E\u0930 |\u0915\u094D\u0924|\u0915\u093E\u0930|\u092A\u094D\u0930| \u092A\u094D|\u094D\u092F\u0915|\u0935\u094D\u092F| \u0917\u0930|\u093F\u0915\u093E| \u0935\u094D|\u094D\u0930\u0924|\u0927\u093F\u0915|\u094D\u0924\u093F|\u092F\u0915\u094D|\u0905\u0927\u093F| \u0905\u0927|\u093E\u0908 |\u092E\u093E |\u0932\u093E\u0908|\u0924\u094D\u092F|\u093F\u0915 | \u0964 | \u0938\u092E|\u0935\u093E | \u0935\u093E|\u0915 \u0935|\u094D\u0928\u0947|\u0930\u094D\u0928|\u0917\u0930\u094D|\u0928\u094D\u0924|\u091B \u0964|\u0924\u093F\u0932|\u0930\u0924\u094D|\u0924\u094D\u0930|\u0947\u0915 |\u092F\u0947\u0915|\u094D\u092F\u0947|\u093F\u0932\u093E|\u0930 \u0938|\u094B \u0938| \u0938\u094D|\u092E\u093E\u0928|\u0915\u094D\u0937| \u0935\u093F|\u0939\u0941\u0928|\u093E \u0938| \u0939\u0941| \u091B |\u0930 \u091B|\u094D\u0924\u094D|\u0938\u092E\u093E|\u0938\u094D\u0935|\u0964 \u092A| \u0938\u0902|\u0928\u0947\u091B|\u0941\u0928\u0947|\u0939\u0930\u0941|\u0924\u0928\u094D|\u0935\u0924\u0928|\u0947 \u0905|\u093F\u0928\u0947|\u094B \u0905|\u094D\u0935\u0924| \u0915\u093E|\u0947 \u091B|\u0917\u0930\u093F| \u0930\u093E|\u094D\u0930 |\u0924\u093F |\u093E\u0915\u094B| \u0915\u0941|\u0937\u094D\u091F|\u0928\u093E |\u0938\u094D\u0924|\u0915 \u0938|\u0941\u0928\u0948|\u0915\u0941\u0928|\u091F\u094D\u0930|\u0932\u0947 | \u0928\u093F|\u093E\u0928 |\u091B\u0948\u0928| \u091B\u0948|\u094D\u091F\u094D|\u093E\u0937\u094D|\u0930\u093E\u0937|\u0924\u093F\u0915|\u091B\u0964 |\u093E\u0930\u094D|\u0924\u093E |\u093F\u0924 |\u0928\u0948 |\u093E \u0905| \u0938\u093E|\u093E \u0935|\u0930\u0941 | \u092E\u093E| \u0905\u0928|\u093E \u0930|\u0930\u0924\u093E|\u0930 \u0930|\u0939\u0930\u0942|\u0947\u091B |\u093E \u092A|\u0930\u0915\u094D|\u094D\u0924 | \u092A\u0930|\u0925\u093E | \u0932\u093E|\u092A\u0930\u093F|\u0926\u0947\u0936|\u0938\u0915\u094B| \u092F\u0938|\u092E\u093E\u091C|\u093E\u092E\u093E|\u094D\u0930\u093E|\u093F\u0935\u093E|\u093E\u0939\u0930|\u094B \u092A|\u094D\u092F |\u0935\u093E\u0930|\u0928 \u0938|\u0964 \u0915|\u0928\u093F |\u094D\u0937\u093E| \u0924\u094D|\u0926\u094D\u0927|\u0930 \u0939|\u0924\u0925\u093E| \u0924\u0925|\u092F\u0938\u094D|\u094D\u092F\u0938|\u0930\u0940 |\u0930 \u0935|\u092A\u0928\u093F|\u0930\u093F\u0928|\u0902\u0930\u0915|\u0938\u0902\u0930|\u092D\u093E\u0935|\u0948 \u0935|\u0938\u092C\u0948| \u0938\u092C| \u0936\u093F| \u0938\u0939|\u0924\u093E\u0915|\u0947 \u0930|\u0924 \u0930|\u0932\u093E\u0917| \u0938\u0941|\u094D\u0937\u0923|\u0926\u094D\u0926| \u0905\u092A|\u0948\u0928 |\u094B \u0935|\u093F\u0915\u094D|\u093E\u0935 |\u0927\u093E\u0930|\u094D\u092F\u093E|\u094D\u0930\u093F|\u093E \u092D|\u090F\u0915\u094B|\u0930 \u092E|\u0928 \u0905|\u094B \u0932| \u0909\u0938|\u0936\u093F\u0915|\u093E\u0924\u094D|\u0938\u094D\u0925|\u0935\u093E\u0939|\u0942\u0930\u094D|\u0936\u094D\u092F|\u093F\u0924\u094D|\u0930\u0915\u094B|\u093E\u0930\u0915|\u0941\u0926\u094D|\u0924\u094B |\u094D\u0924\u094B|\u093E\u0909\u0928|\u0915\u093E\u0928|\u093F\u090F\u0915|\u093E \u0928| \u092A\u0928|\u0928\u0964 |\u0948\u0928\u0964|\u0915\u093E |\u0947\u091B\u0964| \u092D\u0947|\u0930\u094D\u092F|\u0938\u092E\u094D|\u0924\u094D\u092A|\u0938\u093E\u092E|\u0930\u093F\u092F|\u091A\u093E\u0930|\u0928\u093F\u091C|\u0941\u0928 |\u0917\u093F |\u093E\u0917\u093F|\u0909\u0938\u0915| \u092E\u0924| \u0905\u092D|\u092A\u0942\u0930|\u0930 \u0924| \u0938\u0915|\u0938\u093E\u0930|\u0930\u093E\u0927|\u092A\u0930\u093E|\u0905\u092A\u0930|\u0941\u0915\u094D|\u091C\u0915\u094B| \u0909\u092A|\u0930\u093E |\u093E\u0930\u093E|\u094D\u0935\u093E|\u0935\u093F\u0927|\u094D\u0928 |\u093E \u0924|\u0928 \u0917|\u0923\u0915\u094B| \u092A\u093E| \u0926\u093F|\u0915 \u0930|\u0930 \u092A|\u0905\u0928\u094D|\u092D\u0947\u0926|\u093E\u0930\u092E|\u094B \u0906| \u0905\u0930|\u091C\u093F\u0915|\u093E\u091C\u093F|\u093F\u092F |\u0937\u093E |\u093E\u091F |\u092C\u093E\u091F| \u092C\u093E|\u093F \u0930| \u091B\u0964|\u0924\u094D\u0935|\u0924 \u0938|\u0930\u0942 |\u091B \u0930|\u0930\u0915\u093E|\u0935\u093F\u0915|\u0930 \u0909|\u094B\u0917 |\u094D\u0926\u0947|\u0930\u093F\u0935|\u0938\u0915\u093F|\u0948 \u092A|\u0930\u0924\u093F|\u0905\u0928\u0941| \u0906\u0935|\u092F\u0941\u0915|\u093E \u0917|\u0928\u092E\u093E|\u092F\u094B\u0917|\u0917 \u0917|\u0915 \u0905|\u0926\u094D\u0935|\u094D\u0927 |\u0930\u0941\u0926| \u092C\u093F|\u0964 \u0938|\u0909\u0928\u0947|\u093E\u0928\u094D|\u093E \u092E|\u093F\u0915\u094B|\u0930\u094D\u0926|\u093E\u0930\u0940|\u094D\u0924\u0930|\u094B \u0939|\u0939\u093F\u0924| \u0926\u0947|\u0930\u093F\u0915|\u093E \u0915| \u0906\u0927|\u0930\u093E\u091C|\u0930\u094D\u092E|\u094D\u0923 |\u0930\u094D\u0923|\u093F \u0935|\u094D\u092F\u0935|\u0935\u093F\u091A|\u092C\u0948 |\u0938\u0939\u093F|\u0930\u094B\u091C|\u0930\u094D\u0938|\u0908 \u0909|\u094D\u092A |\u0930\u093E\u0924|\u0928\u093F\u0915|\u092E\u093F\u0915|\u091A\u094D\u091B|\u094D\u0925\u093E|\u0935\u093F\u0935|\u0915\u0924\u093E|\u0905\u092D\u093F|\u094D\u0927\u093E",
    mag: " \u0915\u0947|\u0915\u0947 |\u093E\u0930 | \u0939\u0908|\u0915\u093E\u0930|\u0908\u0964 |\u0939\u0908\u0964|\u093F\u0915\u093E|\u0947 \u0905|\u0927\u093F\u0915|\u0905\u0927\u093F| \u0905\u0927|\u0930 \u0939|\u0947 \u0915|\u0914\u0930 | \u0914\u0930|\u093E \u0915|\u0947 \u0938|\u0938\u092C | \u0938\u092C| \u0915\u0930|\u0947\u0902 |\u0925\u093E |\u092E\u0947\u0902| \u092E\u0947|\u0924\u0925\u093E| \u0924\u0925|\u093F\u0915 | \u0939\u094B| \u0938\u092E|\u0915\u094D\u0937|\u0928\u093E |\u092C \u0915|\u0930 \u0938| \u0938\u0902|\u093E \u0938|\u0915\u0930 | \u092D\u0940|\u0964 \u0938| \u0938\u093E| \u0938\u0947| \u0915\u093E| \u0905\u092A|\u094D\u0930\u093E|\u092A\u094D\u0930| \u092A\u094D|\u0938\u0947 |\u092D\u0940 | \u0915\u094B|\u0924 \u0915| \u092A\u0930|\u0930\u093E |\u0915 \u0939|\u092A\u0928 |\u0905\u092A\u0928| \u0938\u0915|\u092F\u093E |\u0924\u093F |\u0930 \u0915|\u0940 \u0915| \u092F\u093E|\u0915\u0930\u0947| \u091C\u093E|\u0930\u0947 | \u0913\u0915|\u094D\u0924 |\u0938\u0915 |\u0928\u094B |\u093E\u0928 |\u092E\u093E\u0928|\u0913\u0915\u0930|\u093E \u092A|\u0928 \u0915|\u0947\u0932 | \u0928\u093E|\u0964 \u0915|\u0930\u0915\u094D| \u0938\u094D|\u0939\u0940 |\u0939\u094B\u090F| \u090F\u0915|\u092A\u0930 |\u0926\u0940 |\u091F\u094D\u0930|\u0924\u093E |\u0935\u094D\u092F|\u0939\u0908 | \u0936\u093E|\u0947 \u0909| \u0926\u0947|\u0924\u094D\u0930|\u093E\u0926\u0940| \u0930\u093E| \u0939\u0940|\u0915\u093E\u0928|\u093F\u0924 |\u092E \u0915|\u0932 \u091C|\u093E\u092E |\u0940 \u0938|\u0947 \u092D|\u0928 \u0938|\u092E\u093E\u091C|\u0937\u094D\u091F|\u0937\u093E | \u0932\u0947|\u0915 \u0938|\u092C\u0947 |\u0935\u0947 |\u093E\u0935\u0947|\u092E\u093F\u0932|\u0930 \u092E|\u094D\u092F |\u093E \u0939|\u0932\u093E |\u092A\u094D\u0924|\u0928\u0942\u0928|\u093E\u0928\u0942|\u091C\u093E |\u0947\u0915\u0930|\u094D\u0937\u093E|\u094D\u0930\u0924|\u0902\u0924\u094D|\u0930 \u0914|\u094B\u0908 |\u0915\u094B\u0908|\u094D\u091F\u094D|\u093E\u0937\u094D|\u0930\u093E\u0937| \u092E\u093E|\u0930\u094B | \u091C\u0947|\u0915\u0930\u093E|\u094B\u090F |\u093E\u092A\u094D|\u0930\u093E\u092A|\u0938\u092E\u093E|\u0942\u0928 |\u094B \u0938|\u0938\u094D\u0935|\u094D\u0924\u093F|\u0938\u093E\u092E|\u094B\u0928\u094B|\u0915\u094B\u0928| \u0935\u094D|\u0930 \u0905|\u094D\u092E | \u0935\u093F| \u0938\u0939|\u0947 \u092E|\u0915\u094D\u0924|\u092F\u094B\u0917|\u0930 \u0935|\u0915\u093E\u092E|\u0932 \u0939| \u0928\u093F|\u0926\u0947\u0936|\u092A\u0942\u0930|\u0935\u093E\u0930| \u0907 |\u0902\u0930\u0915|\u0938\u0902\u0930|\u090F \u0915|\u0930 \u092A| \u0938\u0941|\u0924\u0902\u0924|\u0935\u0924\u0902|\u094D\u0935\u0924|\u093E \u092E|\u0935 \u0915|\u0947 \u0935|\u093E\u0925 |\u0938\u093E\u0925| \u0926\u094B|\u0939\u094B\u092C| \u092A\u093E|\u094B \u0915|\u0947 \u092C|\u094B\u0917 | \u0909\u092A|\u0938\u094D\u0924|\u092A\u0930\u093F|\u0928 \u092A|\u0947 \u0924|\u094D\u0924\u0930|\u0932\u0947\u0932|\u0947 \u0913|\u091A\u093E\u0939| \u091A\u093E|\u092F \u0915|\u0935\u093E |\u0947\u0936 |\u092F \u0938|\u0928 \u0939|\u0937\u0923 |\u093E \u092C|\u0964 \u0924|\u090F\u0915 |\u090F\u0932 |\u0940\u092F |\u0915\u0947\u0915|\u0947 \u0939|\u0930 \u0906|\u093F \u0915|\u0938\u094D\u0925|\u091C\u093F\u0915|\u093E\u091C\u093F|\u093E\u092E\u093E|\u0930\u0940\u092F|\u094D\u0930\u0940|\u0924\u093F\u0915|\u093E\u0924\u093F| \u092C\u093F|\u091A\u093E\u0930|\u0947 \u0906|\u093E\u0938 | \u0909\u091A|\u093E \u0924|\u092F\u0915\u094D|\u094D\u092F\u0915|\u093F\u0932 |\u092E\u092F |\u0938\u092E\u092F|\u0936\u093E\u0926|\u092A\u092F\u094B|\u0909\u092A\u092F|\u0947 \u0916|\u0930\u093F\u0935| \u092A\u0942|\u0947 \u0932|\u0947 \u091A|\u094C\u0928\u094B|\u0915\u094C\u0928| \u0915\u094C|\u0902 \u0915|\u0938\u0902\u0917|\u0928 \u0926|\u0902 \u0938|\u0923 \u092A|\u094D\u0937\u0923|\u0930 \u0928|\u0947 \u0928|\u094B \u092D|\u0915\u0930\u094B|\u093E \u0914|\u0930\u0924\u093E|\u093E\u0935 |\u092D\u093E\u0935|\u0915 \u0914|\u0930\u094D\u092E|\u094B\u0938\u0930|\u0926\u094B\u0938|\u0923 \u0915|\u0947 \u092A|\u0928 \u0914|\u092C \u0939|\u093F\u0915\u094D|\u0936\u093F\u0915| \u0936\u093F|\u093E\u092C\u0947|\u0928\u093F\u092F|\u091A\u093F\u0924|\u0909\u091A\u093F|\u093F\u0924\u094D|\u0917 \u0915|\u0947\u0964 |\u0924 \u0938|\u0940 \u0936|\u0902 \u0936|\u090F\u0915\u0930|\u0964 \u090F|\u0924\u0928 | \u0913 |\u0930\u0940 |\u094D\u0930 |\u091C\u0947 |\u0915 \u0915| \u0938\u0940|\u0938\u0928 |\u093F\u0935\u093E| \u0905\u0928|\u0942\u0930\u093E| \u092C\u091A|\u090F\u0964 | \u092C\u0947|\u0924 \u0939| \u0924\u0915| \u092E\u093F|\u0927\u093E\u0930|\u0925\u0935\u093E|\u0905\u0925\u0935| \u0905\u0925|\u093F\u0932\u093E|\u094D\u0935\u093E|\u093F \u092E| \u0906\u0926|\u0928\u0947 |\u0915\u090F\u0932| \u0915\u090F|\u094D\u092F\u093E"
  }
};

// ../node_modules/.pnpm/franc-min@6.2.0/node_modules/franc-min/index.js
var MAX_LENGTH = 2048;
var MIN_LENGTH = 10;
var MAX_DIFFERENCE = 300;
var own2 = {}.hasOwnProperty;
var script;
var numericData = {};
for (script in data) {
  if (own2.call(data, script)) {
    const languages = data[script];
    let name;
    numericData[script] = {};
    for (name in languages) {
      if (own2.call(languages, name)) {
        const model = languages[name].split("|");
        const trigrams2 = {};
        let weight = model.length;
        while (weight--) {
          trigrams2[model[weight]] = weight;
        }
        numericData[script][name] = trigrams2;
      }
    }
  }
}
function franc(value, options) {
  return francAll(value, options)[0][0];
}
function francAll(value, options = {}) {
  const only = [...options.whitelist || [], ...options.only || []];
  const ignore = [...options.blacklist || [], ...options.ignore || []];
  const minLength = options.minLength !== null && options.minLength !== void 0 ? options.minLength : MIN_LENGTH;
  if (!value || value.length < minLength) {
    return und();
  }
  value = value.slice(0, MAX_LENGTH);
  const script2 = getTopScript(value, expressions);
  if (!script2[0] || !(script2[0] in numericData)) {
    if (!script2[0] || script2[1] === 0 || !allow(script2[0], only, ignore)) {
      return und();
    }
    return singleLanguageTuples(script2[0]);
  }
  return normalize2(
    value,
    getDistances(asTuples(value), numericData[script2[0]], only, ignore)
  );
}
function normalize2(value, distances) {
  const min2 = distances[0][1];
  const max2 = value.length * MAX_DIFFERENCE - min2;
  let index = -1;
  while (++index < distances.length) {
    distances[index][1] = 1 - (distances[index][1] - min2) / max2 || 0;
  }
  return distances;
}
function getTopScript(value, scripts) {
  let topCount = -1;
  let topScript;
  let script2;
  for (script2 in scripts) {
    if (own2.call(scripts, script2)) {
      const count = getOccurrence(value, scripts[script2]);
      if (count > topCount) {
        topCount = count;
        topScript = script2;
      }
    }
  }
  return [topScript, topCount];
}
function getOccurrence(value, expression) {
  const count = value.match(expression);
  return (count ? count.length : 0) / value.length || 0;
}
function getDistances(trigrams2, languages, only, ignore) {
  languages = filterLanguages(languages, only, ignore);
  const distances = [];
  let language;
  if (languages) {
    for (language in languages) {
      if (own2.call(languages, language)) {
        distances.push([language, getDistance(trigrams2, languages[language])]);
      }
    }
  }
  return distances.length === 0 ? und() : distances.sort(sort2);
}
function getDistance(trigrams2, model) {
  let distance = 0;
  let index = -1;
  while (++index < trigrams2.length) {
    const trigram2 = trigrams2[index];
    let difference = MAX_DIFFERENCE;
    if (trigram2[0] in model) {
      difference = trigram2[1] - model[trigram2[0]] - 1;
      if (difference < 0) {
        difference = -difference;
      }
    }
    distance += difference;
  }
  return distance;
}
function filterLanguages(languages, only, ignore) {
  if (only.length === 0 && ignore.length === 0) {
    return languages;
  }
  const filteredLanguages = {};
  let language;
  for (language in languages) {
    if (allow(language, only, ignore)) {
      filteredLanguages[language] = languages[language];
    }
  }
  return filteredLanguages;
}
function allow(language, only, ignore) {
  if (only.length === 0 && ignore.length === 0) {
    return true;
  }
  return (only.length === 0 || only.includes(language)) && !ignore.includes(language);
}
function und() {
  return singleLanguageTuples("und");
}
function singleLanguageTuples(language) {
  return [[language, 1]];
}
function sort2(a, b) {
  return a[1] - b[1];
}

// ../packages/engine-render/src/components/docs/layout/hyphenation/language-detector.ts
var LANG_MAP_TO_HYPHEN_LANG = {
  // cmn Mandarin Chinese 885M
  spa: "es" /* Es */,
  // Spanish 332M
  eng: "en-us" /* EnUs */,
  // English 322M
  rus: "ru" /* Ru */,
  // Russian 288M
  // arb: Standard Arabic 280M
  ben: "bn" /* Bn */,
  // Bengali 196M
  hin: "hi" /* Hi */,
  // Hindi 182M
  por: "pt" /* Pt */,
  // Portuguese 182M
  ind: "id" /* Id */,
  // Indonesian 140M
  // jpn: Japanese 125M
  fra: "fr" /* Fr */,
  // French 124M
  deu: "de-1901" /* De1901 */,
  // German 121M TODO: use which langs: German?
  // jav: Javanese(Javanese) 76M
  // jav: Javanese(Latin) 76M
  // kor: Korean 75M
  tel: "te" /* Te */,
  // Telugu 73M
  // vie: Vietnamese 67M
  mar: "mr" /* Mr */,
  // Marathi 65M
  ita: "it" /* It */,
  // Italian 63M
  tam: "ta" /* Ta */,
  // Tamil 62M
  tur: "tr" /* Tr */,
  // Turkish 59M
  // urd: Urdu 54M
  guj: "gu" /* Gu */,
  // Gujarati 44M
  pol: "pl" /* Pl */,
  // Polish 44M
  ukr: "uk" /* Uk */,
  // Ukrainian 41M
  kan: "kn" /* Kn */,
  // Kannada 38M
  // mai: Maithili 35M
  mal: "ml" /* Ml */,
  // Malayalam 34M
  // pes: Iranian Persian 33M
  // mya: Burmese 31M
  // swh: Swahili(individual language)
  // sun: Sundanese 27M
  ron: "ro" /* Ro */,
  // Romanian 26M
  pan: "pa" /* Pa */,
  // Panjabi 26M
  // bho: Bhojpuri 25M
  // amh: Amharic 23M
  // hau: Hausa 22M
  // fuv: Nigerian Fulfulde 22M
  // bos: Bosnian(Cyrillic) 21M
  // bos: Bosnian(Latin) 21M
  hrv: "hr" /* Hr */,
  // Croatian 21M
  nld: "nl" /* Nl */,
  // Dutch 21M
  srp: "sr-cyrl" /* SrCyrl */,
  // Serbian(Cyrillic) 21M
  // srp: Serbian(Latin) 21M
  tha: "th" /* Th */,
  // Thai 21M
  // ckb: Central Kurdish 20M
  // yor: Yoruba 20M
  uzn: "kmr" /* Kmr */,
  // Northern Uzbek(Cyrillic) 18M
  // uzn: Northern Uzbek(Latin) 18M
  zlm: "ml" /* Ml */,
  // Malay(individual language)(Arabic) 18M
  // zlm: Malay(individual language)(Latin) 18M
  // ibo: Igbo 17M
  // npi: Nepali(individual language) 16M
  // ceb: Cebuano 15M
  // skr: Saraiki 15M
  // tgl: Tagalog 15M
  hun: "hu" /* Hu */,
  // Hungarian 15M
  // azj: North Azerbaijani(Cyrillic) 14M
  // azj: North Azerbaijani(Latin) 14M
  // sin: Sinhala 13M
  // koi: Komi - Permyak 13M
  ell: "el-monoton" /* ElMonoton */,
  // Modern Greek(1453-) 12M
  ces: "cs" /* Cs */,
  // Czech 12M
  // mag: Magahi 11M
  // run: Rundi 11M
  bel: "be" /* Be */,
  // Belarusian 10M
  // plt: Plateau Malagasy 10M
  // qug: Chimborazo Highland Quichua 10M
  // mad: Madurese 10M
  // nya: Nyanja 10M
  // zyb: Yongbei Zhuang 10M
  // pbu: Northern Pashto 10M
  // kin: Kinyarwanda 9M
  // zul: Zulu 9M
  bul: "bg" /* Bg */,
  // Bulgarian 9M
  swe: "sv" /* Sv */,
  // Swedish 9M
  // lin: Lingala 8M
  // som: Somali 8M
  // hms: Southern Qiandong Miao 8M
  // hnj: Hmong Njua 8M
  // ilo: Iloko 8M
  // kaz: Kazakh
  und: "unknown" /* UNKNOWN */
  // Undetermined
};
var _LanguageDetector = class _LanguageDetector {
  constructor() {
    // language cache for special text.
    __publicField(this, "_detectCache", /* @__PURE__ */ new Map());
  }
  static getInstance() {
    if (this._instance == null) {
      this._instance = new _LanguageDetector();
    }
    return this._instance;
  }
  detect(text) {
    var _a;
    let lang = this._detectCache.get(text);
    if (lang) {
      return lang;
    }
    const francLang = franc(text);
    lang = (_a = LANG_MAP_TO_HYPHEN_LANG[francLang]) != null ? _a : "unknown" /* UNKNOWN */;
    this._detectCache.set(text, lang);
    return lang;
  }
  dispose() {
    this._detectCache.clear();
  }
};
__publicField(_LanguageDetector, "_instance", null);
var LanguageDetector = _LanguageDetector;

// ../packages/engine-render/src/components/docs/layout/doc-skeleton.ts
function removeDupPages(ctx) {
  const hash = /* @__PURE__ */ new Set();
  ctx.skeleton.pages = ctx.skeleton.pages.filter((page) => {
    const hasPage = hash.has(page);
    hash.add(page);
    return !hasPage;
  });
}
function getPagePath(page) {
  const path = [];
  let skeNode = page;
  let parent = skeNode.parent;
  while (parent) {
    if (parent.pages) {
      const index = parent.pages.indexOf(skeNode);
      if (index !== -1) {
        path.unshift("pages", index);
      }
    } else if (parent.cells) {
      const index = parent.cells.indexOf(skeNode);
      if (index !== -1) {
        path.unshift("cells", index);
      }
    } else if (parent.rows) {
      const index = parent.rows.indexOf(skeNode);
      if (index !== -1) {
        path.unshift("rows", index);
      }
    } else if (parent.skeTables && parent.skeTables.has(skeNode.tableId)) {
      path.unshift("skeTables", skeNode.tableId);
    }
    skeNode = parent;
    parent = parent == null ? void 0 : parent.parent;
  }
  return path;
}
var DocumentSkeleton = class _DocumentSkeleton extends Skeleton {
  constructor(_docViewModel, localeService) {
    super(localeService);
    this._docViewModel = _docViewModel;
    __publicField(this, "_dirty$", new Subject());
    __publicField(this, "dirty$", this._dirty$.asObservable());
    __publicField(this, "_skeletonData");
    __publicField(this, "_findLiquid", new Liquid());
    // Use for hyphenation.
    __publicField(this, "_hyphen", Hyphen.getInstance());
    __publicField(this, "_languageDetector", LanguageDetector.getInstance());
    __publicField(this, "_iteratorCount", 0);
  }
  static create(docViewModel, localeService) {
    return new _DocumentSkeleton(docViewModel, localeService);
  }
  dispose() {
    super.dispose();
    this._skeletonData = null;
    this._findLiquid = null;
    this._docViewModel.dispose();
  }
  getViewModel() {
    return this._docViewModel;
  }
  /**
   * Layout the document.
   * PS: This method has significant impact on performance.
   */
  calculate(bounds) {
    if (!this.dirty) {
      return;
    }
    const ctx = this._prepareLayoutContext();
    this._skeletonData = this._createSkeleton(ctx, bounds);
    this._dirty$.next(true);
  }
  getSkeletonData() {
    return this._skeletonData;
  }
  getActualSize() {
    const skeletonData = this.getSkeletonData();
    let actualWidth = Number.NEGATIVE_INFINITY;
    let actualHeight = 0;
    skeletonData == null ? void 0 : skeletonData.pages.forEach((page) => {
      const { width, height } = page;
      actualWidth = Math.max(actualWidth, width);
      actualHeight += height;
    });
    return {
      actualWidth,
      actualHeight
    };
  }
  _getPageActualWidth(page) {
    let maxWidth = Number.NEGATIVE_INFINITY;
    for (const section of page.sections) {
      for (const column of section.columns) {
        for (const line2 of column.lines) {
          let lineWidth = 0;
          for (const divide of line2.divides) {
            for (const glyph of divide.glyphGroup) {
              lineWidth += glyph.width;
            }
          }
          maxWidth = Math.max(maxWidth, lineWidth);
        }
      }
    }
    return maxWidth;
  }
  getPageSize() {
    return this.getViewModel().getDataModel().documentStyle.pageSize;
  }
  findPositionByGlyph(glyph, segmentPage) {
    const divide = glyph.parent;
    const line2 = divide == null ? void 0 : divide.parent;
    const column = line2 == null ? void 0 : line2.parent;
    const section = column == null ? void 0 : column.parent;
    const page = section == null ? void 0 : section.parent;
    const skeletonData = this.getSkeletonData();
    if (!divide || !column || !section || !page || !skeletonData) {
      return;
    }
    const pageType = page.type;
    const glyphIndex = divide.glyphGroup.indexOf(glyph);
    const divideIndex = line2.divides.indexOf(divide);
    const lineIndex = column.lines.indexOf(line2);
    const columnIndex = section.columns.indexOf(column);
    const sectionIndex = page.sections.indexOf(section);
    let pageIndex = -1;
    const path = getPagePath(page);
    switch (pageType) {
      case 1 /* HEADER */:
      case 2 /* FOOTER */: {
        pageIndex = 0;
        break;
      }
      case 0 /* BODY */: {
        pageIndex = skeletonData.pages.indexOf(page);
        break;
      }
      case 3 /* CELL */: {
        pageIndex = path[1];
        break;
      }
      default: {
        throw new Error("Invalid page type");
      }
    }
    return {
      glyph: glyphIndex,
      divide: divideIndex,
      line: lineIndex,
      column: columnIndex,
      section: sectionIndex,
      page: pageIndex,
      segmentPage,
      pageType,
      path
    };
  }
  findCharIndexByPosition(position) {
    const glyph = this.findGlyphByPosition(position);
    const divide = glyph == null ? void 0 : glyph.parent;
    if (divide == null) {
      return;
    }
    const { st, glyphGroup } = divide;
    let index = st;
    for (const g of glyphGroup) {
      if (g === glyph) {
        break;
      }
      index += g.count;
    }
    return position.isBack ? index : index + glyph.count;
  }
  findNodePositionByCharIndex(charIndex, isBack = true, segmentId = "", segmentPIndex = -1) {
    const nodes = this._findNodeByIndex(charIndex, segmentId, segmentPIndex);
    if (nodes == null) {
      return;
    }
    const skeletonData = this.getSkeletonData();
    if (!skeletonData) {
      return;
    }
    const pages = skeletonData.pages;
    const { glyph, divide, line: line2, column, section, page, segmentPageIndex, pageType } = nodes;
    const path = getPagePath(page);
    let pageIndex = -1;
    switch (pageType) {
      case 1 /* HEADER */:
      case 2 /* FOOTER */: {
        pageIndex = 0;
        break;
      }
      case 0 /* BODY */: {
        pageIndex = pages.indexOf(page);
        break;
      }
      case 3 /* CELL */: {
        pageIndex = path[1];
        break;
      }
      default: {
        throw new Error("Invalid page type");
      }
    }
    return {
      glyph: divide.glyphGroup.indexOf(glyph),
      divide: line2.divides.indexOf(divide),
      line: column.lines.indexOf(line2),
      column: section.columns.indexOf(column),
      section: page.sections.indexOf(section),
      page: pageIndex,
      pageType,
      segmentPage: segmentPageIndex,
      isBack,
      path
    };
  }
  findNodeByCharIndex(charIndex, segmentId = "", segmentPageIndex = -1) {
    const nodes = this._findNodeByIndex(charIndex, segmentId, segmentPageIndex);
    return nodes == null ? void 0 : nodes.glyph;
  }
  findGlyphByPosition(position) {
    var _a, _b;
    if (position == null) {
      return;
    }
    const skeletonData = this.getSkeletonData();
    if (skeletonData == null) {
      return;
    }
    const { pages, skeFooters, skeHeaders } = skeletonData;
    const { divide, line: line2, column, section, segmentPage, pageType, path, isBack } = position;
    let { glyph } = position;
    let skePage = null;
    if (pageType === 1 /* HEADER */ || pageType === 2 /* FOOTER */) {
      skePage = pages[segmentPage];
      const { headerId, footerId, pageWidth } = skePage;
      if (pageType === 1 /* HEADER */) {
        const skeHeader = (_a = skeHeaders.get(headerId)) == null ? void 0 : _a.get(pageWidth);
        if (skeHeader == null) {
          return;
        } else {
          skePage = skeHeader;
        }
      } else if (pageType === 2 /* FOOTER */) {
        const skeFooter = (_b = skeFooters.get(footerId)) == null ? void 0 : _b.get(pageWidth);
        if (skeFooter == null) {
          return;
        } else {
          skePage = skeFooter;
        }
      }
    } else {
      skePage = getPageFromPath(skeletonData, path);
    }
    if (skePage == null) {
      return;
    }
    const glyphGroup = skePage.sections[section].columns[column].lines[line2].divides[divide].glyphGroup;
    glyph = Math.min(glyph, glyphGroup.length - 1);
    if (glyphGroup[glyph].glyphType === 2 /* LIST */) {
      glyph += 1;
    }
    return glyphGroup[glyph];
  }
  findEditAreaByCoord(coord, pageLayoutType, pageMarginLeft, pageMarginTop) {
    const { x, y } = coord;
    let editArea = "BODY" /* BODY */;
    let pageNumber = -1;
    let pageSkeleton = null;
    const skeletonData = this.getSkeletonData();
    if (skeletonData == null) {
      return {
        editArea,
        page: pageSkeleton,
        pageNumber
      };
    }
    this._findLiquid.reset();
    const { pages } = skeletonData;
    for (let i = 0, len = pages.length; i < len; i++) {
      const page = pages[i];
      const { marginTop, marginBottom, pageWidth, pageHeight } = page;
      if (x > this._findLiquid.x && x < this._findLiquid.x + pageWidth && y > this._findLiquid.y && y < this._findLiquid.y + marginTop) {
        editArea = "HEADER" /* HEADER */;
        pageSkeleton = page;
        pageNumber = i;
        break;
      }
      if (x > this._findLiquid.x && x < this._findLiquid.x + pageWidth && y > this._findLiquid.y + marginTop && y < this._findLiquid.y + pageHeight - marginBottom) {
        editArea = "BODY" /* BODY */;
        pageSkeleton = page;
        pageNumber = i;
        break;
      }
      if (x > this._findLiquid.x && x < this._findLiquid.x + pageWidth && y > this._findLiquid.y + pageHeight - marginBottom && y < this._findLiquid.y + pageHeight) {
        editArea = "FOOTER" /* FOOTER */;
        pageSkeleton = page;
        pageNumber = i;
        break;
      }
      this._translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
    }
    return {
      editArea,
      page: pageSkeleton,
      pageNumber
    };
  }
  findNodeByCoord(coord, pageLayoutType, pageMarginLeft, pageMarginTop, restrictions) {
    var _a, _b, _c, _d, _e, _f;
    const { x, y } = coord;
    const skeletonData = this.getSkeletonData();
    if (skeletonData == null) {
      return;
    }
    const cache = {
      nearestNodeList: [],
      nearestNodeDistanceList: []
    };
    const { pages, skeHeaders, skeFooters } = skeletonData;
    const editArea = this.findEditAreaByCoord(coord, pageLayoutType, pageMarginLeft, pageMarginTop).editArea;
    const pageLength = pages.length;
    this._findLiquid.reset();
    if (restrictions == null) {
      for (let pi = 0; pi < pageLength; pi++) {
        const page = pages[pi];
        const { headerId, footerId, pageWidth } = page;
        let exactMatch = null;
        if (editArea === "HEADER" /* HEADER */ || editArea === "FOOTER" /* FOOTER */) {
          const headerSke = (_a = skeHeaders.get(headerId)) == null ? void 0 : _a.get(pageWidth);
          if (headerSke) {
            exactMatch = this._collectNearestNode(
              headerSke,
              1 /* HEADER */,
              page,
              headerId,
              pi,
              cache,
              x,
              y,
              pageLength
            );
          }
          const footerSke = (_b = skeFooters.get(footerId)) == null ? void 0 : _b.get(pageWidth);
          if (footerSke) {
            exactMatch = exactMatch != null ? exactMatch : this._collectNearestNode(
              footerSke,
              2 /* FOOTER */,
              page,
              footerId,
              pi,
              cache,
              x,
              y,
              pageLength
            );
          }
        } else {
          const BODY_SEGMENT_ID = "";
          exactMatch = this._collectNearestNode(
            page,
            0 /* BODY */,
            page,
            BODY_SEGMENT_ID,
            pi,
            cache,
            x,
            y,
            pageLength
          );
        }
        if (exactMatch) {
          return exactMatch;
        }
        this._translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
      }
    } else {
      const { segmentId, segmentPage, strict } = restrictions;
      let exactMatch = null;
      if (strict === false) {
        for (let pi = 0; pi < pageLength; pi++) {
          const page = pages[pi];
          const { headerId, footerId, pageWidth } = page;
          if (segmentId !== "") {
            const headerSke = (_c = skeHeaders.get(headerId)) == null ? void 0 : _c.get(pageWidth);
            if (headerSke) {
              exactMatch = this._collectNearestNode(
                headerSke,
                1 /* HEADER */,
                page,
                headerId,
                pi,
                cache,
                x,
                y,
                pageLength
              );
            }
            const footerSke = (_d = skeFooters.get(footerId)) == null ? void 0 : _d.get(pageWidth);
            if (footerSke) {
              exactMatch = exactMatch != null ? exactMatch : this._collectNearestNode(
                footerSke,
                2 /* FOOTER */,
                page,
                footerId,
                pi,
                cache,
                x,
                y,
                pageLength
              );
            }
          } else {
            const BODY_SEGMENT_ID = "";
            exactMatch = this._collectNearestNode(
              page,
              0 /* BODY */,
              page,
              BODY_SEGMENT_ID,
              pi,
              cache,
              x,
              y,
              pageLength
            );
          }
          if (exactMatch) {
            return exactMatch;
          }
          this._translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
        }
      } else {
        for (let pi = 0; pi < pageLength; pi++) {
          const page = pages[pi];
          if (segmentId) {
            if (segmentPage !== pi) {
              this._translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
              continue;
            }
            const { headerId, pageWidth } = page;
            const segmentSke = segmentId === headerId ? (_e = skeHeaders.get(segmentId)) == null ? void 0 : _e.get(pageWidth) : (_f = skeFooters.get(segmentId)) == null ? void 0 : _f.get(pageWidth);
            if (segmentSke) {
              exactMatch = this._collectNearestNode(
                segmentSke,
                segmentId === headerId ? 1 /* HEADER */ : 2 /* FOOTER */,
                page,
                segmentId,
                segmentPage,
                cache,
                x,
                y,
                pageLength
              );
            }
          } else {
            const BODY_SEGMENT_ID = "";
            exactMatch = this._collectNearestNode(
              page,
              0 /* BODY */,
              page,
              BODY_SEGMENT_ID,
              pi,
              cache,
              x,
              y,
              pageLength
            );
          }
          if (exactMatch) {
            return exactMatch;
          }
          this._translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
        }
      }
    }
    return this._getNearestNode(cache.nearestNodeList, cache.nearestNodeDistanceList);
  }
  _collectNearestNode(segmentPage, pageType, page, segmentId, pi, cache, x, y, pageLength, nestLevel = 0) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const { sections, skeTables } = segmentPage;
    this._findLiquid.translateSave();
    const pageLeft = this._findLiquid.x;
    const pageRight = pageLeft + page.pageWidth;
    const pageTop = this._findLiquid.y + (pageType === 2 /* FOOTER */ ? page.pageHeight - segmentPage.pageHeight : 0);
    const pageBottom = pageTop + segmentPage.pageHeight;
    let pointInPage = x >= pageLeft && x <= pageRight && y >= pageTop && y <= pageBottom;
    if (nestLevel === 0 && pageType === 0 /* BODY */) {
      const isFirstPage = pi === 0;
      const isLastPage = pi === pageLength - 1;
      const halfMarginTop = page.originMarginTop / 2;
      if (isFirstPage && isLastPage) {
        pointInPage = true;
      } else if (isFirstPage) {
        pointInPage = y <= pageBottom + halfMarginTop;
      } else if (isLastPage) {
        pointInPage = y >= pageTop - halfMarginTop;
      } else {
        pointInPage = y >= pageTop - halfMarginTop && y <= pageBottom + halfMarginTop;
      }
    }
    switch (pageType) {
      case 1 /* HEADER */: {
        this._findLiquid.translatePagePadding({
          ...segmentPage,
          marginLeft: page.marginLeft
          // Because header or footer margin Left is 0.
        });
        break;
      }
      case 2 /* FOOTER */: {
        const footerTop = page.pageHeight - segmentPage.height - segmentPage.marginBottom;
        this._findLiquid.translate(page.marginLeft, footerTop);
        break;
      }
      default: {
        this._findLiquid.translatePagePadding(page);
        break;
      }
    }
    if (pointInPage) {
      let nearestNodeDistanceY = Number.POSITIVE_INFINITY;
      for (const section of sections) {
        const { columns } = section;
        this._findLiquid.translateSave();
        this._findLiquid.translateSection(section);
        for (const column of columns) {
          const { lines } = column;
          this._findLiquid.translateSave();
          this._findLiquid.translateColumn(column);
          for (let i = 0; i < lines.length; i++) {
            const line2 = lines[i];
            const { divides, type: type2, lineHeight = 0 } = line2;
            if (type2 === 1 /* BLOCK */) {
              continue;
            } else {
              this._findLiquid.translateSave();
              this._findLiquid.translateLine(line2);
              const { y: startY } = this._findLiquid;
              const startY_fin = startY;
              const endY_fin = startY + lineHeight;
              const distanceY = Math.abs(y - endY_fin);
              const divideLength = divides.length;
              for (let i2 = 0; i2 < divideLength; i2++) {
                const divide = divides[i2];
                const { glyphGroup } = divide;
                this._findLiquid.translateSave();
                this._findLiquid.translateDivide(divide);
                const { x: startX } = this._findLiquid;
                for (const glyph of glyphGroup) {
                  if (!glyph.content || glyph.content.length === 0) {
                    continue;
                  }
                  const { width: glyphWidth, left: glyphLeft } = glyph;
                  const startX_fin = startX + glyphLeft;
                  const endX_fin = startX + glyphLeft + glyphWidth;
                  const distanceX = Math.abs(x - endX_fin);
                  if (y >= startY_fin && y <= endY_fin) {
                    if (x >= startX_fin && x <= endX_fin) {
                      return {
                        node: glyph,
                        segmentPage: pageType === 0 /* BODY */ ? -1 : pi,
                        segmentId,
                        ratioX: x / (startX_fin + endX_fin),
                        ratioY: y / (startY_fin + endY_fin)
                      };
                    }
                    if (nearestNodeDistanceY !== Number.NEGATIVE_INFINITY) {
                      cache.nearestNodeList = [];
                      cache.nearestNodeDistanceList = [];
                    }
                    cache.nearestNodeList.push({
                      node: glyph,
                      segmentPage: pageType === 0 /* BODY */ ? -1 : pi,
                      segmentId,
                      ratioX: x / (startX_fin + endX_fin),
                      ratioY: y / (startY_fin + endY_fin)
                    });
                    cache.nearestNodeDistanceList.push({
                      coordInPage: pointInPage,
                      distance: distanceX,
                      nestLevel
                    });
                    nearestNodeDistanceY = Number.NEGATIVE_INFINITY;
                    continue;
                  }
                  if (distanceY < nearestNodeDistanceY) {
                    nearestNodeDistanceY = distanceY;
                    cache.nearestNodeList = [];
                    cache.nearestNodeDistanceList = [];
                  }
                  if (distanceY === nearestNodeDistanceY) {
                    cache.nearestNodeList.push({
                      node: glyph,
                      segmentPage: pageType === 0 /* BODY */ ? -1 : pi,
                      segmentId,
                      ratioX: x / (startX_fin + endX_fin),
                      ratioY: y / (startY_fin + endY_fin)
                    });
                    cache.nearestNodeDistanceList.push({
                      coordInPage: pointInPage,
                      distance: distanceX,
                      nestLevel
                    });
                  }
                }
                this._findLiquid.translateRestore();
              }
              this._findLiquid.translateRestore();
            }
          }
          this._findLiquid.translateRestore();
        }
        this._findLiquid.translateRestore();
      }
    }
    let exactMatch = null;
    if (skeTables.size > 0) {
      for (const table2 of skeTables.values()) {
        const { top: tableTop, left: tableLeft, rows } = table2;
        (_a = this._findLiquid) == null ? void 0 : _a.translateSave();
        (_b = this._findLiquid) == null ? void 0 : _b.translate(tableLeft, tableTop);
        for (const row of rows) {
          const { top: rowTop, cells, isRepeatRow } = row;
          if (isRepeatRow) {
            continue;
          }
          (_c = this._findLiquid) == null ? void 0 : _c.translateSave();
          (_d = this._findLiquid) == null ? void 0 : _d.translate(0, rowTop);
          for (const cell of cells) {
            const { left: cellLeft } = cell;
            (_e = this._findLiquid) == null ? void 0 : _e.translateSave();
            (_f = this._findLiquid) == null ? void 0 : _f.translate(cellLeft, 0);
            exactMatch = exactMatch != null ? exactMatch : this._collectNearestNode(
              cell,
              3 /* CELL */,
              cell,
              segmentId,
              pi,
              cache,
              x,
              y,
              pageLength,
              nestLevel + 1
            );
            (_g = this._findLiquid) == null ? void 0 : _g.translateRestore();
          }
          (_h = this._findLiquid) == null ? void 0 : _h.translateRestore();
        }
        (_i = this._findLiquid) == null ? void 0 : _i.translateRestore();
      }
    }
    if (exactMatch) {
      this._findLiquid.translateRestore();
      return exactMatch;
    }
    this._findLiquid.translateRestore();
  }
  _getNearestNode(nearestNodeList, nearestNodeDistanceList) {
    if (nearestNodeDistanceList.length === 0) {
      return;
    }
    if (nearestNodeDistanceList.length === 1) {
      return nearestNodeList[0];
    }
    let miniValue = nearestNodeDistanceList[0];
    for (let i = 1; i < nearestNodeDistanceList.length; i++) {
      const { distance, nestLevel, coordInPage } = nearestNodeDistanceList[i];
      if (nestLevel > miniValue.nestLevel) {
        miniValue = nearestNodeDistanceList[i];
        continue;
      }
      if (nestLevel === miniValue.nestLevel) {
        if (coordInPage === miniValue.coordInPage) {
          if (distance < miniValue.distance) {
            miniValue = nearestNodeDistanceList[i];
            continue;
          }
        } else {
          if (coordInPage) {
            miniValue = nearestNodeDistanceList[i];
            continue;
          }
        }
      }
    }
    const miniValueIndex = nearestNodeDistanceList.indexOf(miniValue);
    return nearestNodeList[miniValueIndex];
  }
  _getPageBoundingBox(page, pageLayoutType) {
    const { pageWidth, pageHeight } = page;
    const { x: startX, y: startY } = this._findLiquid;
    let endX = -1;
    let endY = -1;
    if (pageLayoutType === 0 /* VERTICAL */) {
      endX = pageWidth;
      endY = startY + pageHeight;
    } else if (pageLayoutType === 1 /* HORIZONTAL */) {
      endX = startX + pageWidth;
      endY = pageHeight;
    }
    return {
      startX,
      startY,
      endX,
      endY
    };
  }
  _translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop) {
    this._findLiquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
  }
  _prepareLayoutContext() {
    const viewModel = this.getViewModel();
    const dataModel = viewModel.getDataModel();
    const { headerTreeMap, footerTreeMap } = viewModel.getHeaderFooterTreeMap();
    const { documentStyle, drawings, lists: customLists = {} } = dataModel;
    const lists = {
      ...PRESET_LIST_TYPE,
      ...customLists
    };
    const {
      paragraphLineGapDefault = 0,
      defaultTabStop = 10.5,
      textStyle = {}
    } = documentStyle;
    const docsConfig = {
      headerTreeMap,
      footerTreeMap,
      lists,
      drawings,
      localeService: this._localeService,
      paragraphLineGapDefault,
      defaultTabStop,
      documentTextStyle: textStyle
    };
    const skeleton = getNullSkeleton();
    const { skeHeaders, skeFooters, skeListLevel, drawingAnchor } = skeleton;
    const skeletonResourceReference = {
      skeHeaders,
      skeFooters,
      skeListLevel,
      drawingAnchor
    };
    return {
      viewModel,
      dataModel,
      skeleton,
      skeletonResourceReference,
      docsConfig,
      layoutStartPointer: {
        "": null
        // '' is the main document.
      },
      isDirty: false,
      floatObjectsCache: /* @__PURE__ */ new Map(),
      paragraphConfigCache: /* @__PURE__ */ new Map(),
      sectionBreakConfigCache: /* @__PURE__ */ new Map(),
      paragraphsOpenNewPage: /* @__PURE__ */ new Set(),
      hyphen: this._hyphen,
      languageDetector: this._languageDetector
    };
  }
  /**
   * \v COLUMN_BREAK
   * \f PAGE_BREAK
   * \0 DOCS_END
   * \t TAB
   *
   * Needs to be changed：
   * \r PARAGRAPH
   * \n SECTION_BREAK
   *
   * \b customBlock: Scenarios where customBlock, images, mentions, etc. do not participate in the document flow.
   *
   * Table
   * \x1A table start
   * \x1B table row start
   * \x1C table cell start
   * \x1D table cell end
   * \x1E table row end
   * \x1F table end
   *
   * Special ranges within the document flow:：hyperlinks，field，structured document tags， bookmark，comment
   * \x1F customRange start
   * \x1E customRange end
   *
   * Split the document according to SectionBreak and perform layout calculations.
   * @returns view model: skeleton
   */
  _createSkeleton(ctx, _bounds) {
    var _a;
    const { viewModel, skeleton, skeletonResourceReference } = ctx;
    const allSkeletonPages = skeleton.pages;
    let startSectionIndex = 0;
    const layoutAnchor = ctx.layoutStartPointer[""];
    ctx.layoutStartPointer[""] = null;
    if (layoutAnchor != null) {
      for (let sectionIndex = 0; sectionIndex < viewModel.getChildren().length; sectionIndex++) {
        const sectionNode = viewModel.getChildren()[sectionIndex];
        const { endIndex, startIndex } = sectionNode;
        if (layoutAnchor >= startIndex && layoutAnchor <= endIndex) {
          startSectionIndex = sectionIndex;
          break;
        }
      }
    }
    for (let i = startSectionIndex, len = viewModel.getChildren().length; i < len; i++) {
      const sectionNode = viewModel.getChildren()[i];
      const sectionBreakConfig = prepareSectionBreakConfig(ctx, i);
      const { sectionType, columnProperties, columnSeparatorType, sectionTypeNext, pageNumberStart = 1 } = sectionBreakConfig;
      let curSkeletonPage = getLastPage(allSkeletonPages);
      let isContinuous = false;
      ctx.sectionBreakConfigCache.set(sectionNode.endIndex, sectionBreakConfig);
      if (sectionType === 1 /* CONTINUOUS */) {
        updateBlockIndex(allSkeletonPages);
        this._addNewSectionByContinuous(curSkeletonPage, columnProperties, columnSeparatorType);
        isContinuous = true;
      } else if (layoutAnchor == null || curSkeletonPage == null) {
        curSkeletonPage = createSkeletonPage(
          ctx,
          sectionBreakConfig,
          skeletonResourceReference,
          (_a = curSkeletonPage == null ? void 0 : curSkeletonPage.pageNumber) != null ? _a : pageNumberStart
        );
      }
      const { pages } = dealWithSection(
        ctx,
        viewModel,
        sectionNode,
        curSkeletonPage,
        sectionBreakConfig,
        layoutAnchor
      );
      if (sectionTypeNext === 1 /* CONTINUOUS */ && columnProperties.length > 0) {
      }
      if (isContinuous) {
        pages.splice(0, 1);
      }
      allSkeletonPages.push(...pages);
      if (ctx.isDirty) {
        break;
      }
    }
    if (ctx.isDirty && this._iteratorCount < 10) {
      this._iteratorCount++;
      resetContext(ctx);
      return this._createSkeleton(ctx, _bounds);
    } else {
      this._iteratorCount = 0;
      removeDupPages(ctx);
      updateBlockIndex(skeleton.pages);
      updateInlineDrawingCoordsAndBorder(ctx, skeleton.pages);
      for (const hSkeMap of skeleton.skeHeaders.values()) {
        for (const page of hSkeMap.values()) {
          updateInlineDrawingCoordsAndBorder(ctx, [page]);
        }
      }
      for (const fSkeMap of skeleton.skeFooters.values()) {
        for (const page of fSkeMap.values()) {
          updateInlineDrawingCoordsAndBorder(ctx, [page]);
        }
      }
      setPageParent(skeleton.pages, skeleton);
      return skeleton;
    }
  }
  // 一页存在多个 section 的情况，仅在 SectionType.CONTINUOUS 的情况下出现
  _addNewSectionByContinuous(curSkeletonPage, columnProperties, columnSeparatorType) {
    const sections = curSkeletonPage.sections;
    const lastSection = sections[sections.length - 1];
    const {
      pageWidth,
      pageHeight,
      marginTop: curPageMT,
      marginBottom: curPageMB,
      marginLeft: curPageML,
      marginRight: curPageMR
    } = curSkeletonPage;
    const pageContentWidth = pageWidth - curPageML - curPageMR;
    const pageContentHeight = pageHeight - curPageMT - curPageMB;
    const lastSectionBottom = ((lastSection == null ? void 0 : lastSection.top) || 0) + ((lastSection == null ? void 0 : lastSection.height) || 0);
    const newSection = createSkeletonSection(
      columnProperties,
      columnSeparatorType,
      lastSectionBottom,
      0,
      pageContentWidth,
      pageContentHeight - lastSectionBottom
    );
    newSection.parent = curSkeletonPage;
    sections.push(newSection);
  }
  _findNodeByIndex(charIndex, segmentId = "", segmentPageIndex = -1) {
    var _a, _b;
    const skeletonData = this.getSkeletonData();
    if (skeletonData == null) {
      return;
    }
    const { pages, skeFooters, skeHeaders } = skeletonData;
    for (const page of pages) {
      const curPageIndex = pages.indexOf(page);
      if (segmentId && curPageIndex !== segmentPageIndex) {
        continue;
      }
      const { pageWidth, skeTables } = page;
      let segmentPage = page;
      if (segmentId) {
        const maybeHeaderSke = (_a = skeHeaders.get(segmentId)) == null ? void 0 : _a.get(pageWidth);
        const maybeFooterSke = (_b = skeFooters.get(segmentId)) == null ? void 0 : _b.get(pageWidth);
        if (maybeHeaderSke) {
          segmentPage = maybeHeaderSke;
        } else if (maybeFooterSke) {
          segmentPage = maybeFooterSke;
        } else {
          continue;
        }
      }
      if (segmentId === "") {
        let foundCell = false;
        for (const table2 of skeTables.values()) {
          const { rows } = table2;
          for (const row of rows) {
            const { cells } = row;
            for (const cell of cells) {
              const { st: st2, ed: ed2 } = cell;
              if (charIndex >= st2 && charIndex <= ed2) {
                segmentPage = cell;
                foundCell = true;
                break;
              }
            }
            if (foundCell) {
              break;
            }
          }
          if (foundCell) {
            break;
          }
        }
      }
      const { sections, st, ed } = segmentPage;
      if (charIndex < st || charIndex > ed) {
        continue;
      }
      for (const section of sections) {
        const { columns, st: st2, ed: ed2 } = section;
        if (charIndex < st2 || charIndex > ed2) {
          continue;
        }
        for (const column of columns) {
          const { lines, st: st3, ed: ed3 } = column;
          if (charIndex < st3 || charIndex > ed3) {
            continue;
          }
          for (const line2 of lines) {
            const { divides, st: st4, ed: ed4 } = line2;
            const divideLength = divides.length;
            if (charIndex < st4 || charIndex > ed4) {
              continue;
            }
            for (let i = 0; i < divideLength; i++) {
              const divide = divides[i];
              const { glyphGroup, st: st5, ed: ed5 } = divide;
              if (charIndex < st5 || charIndex > ed5) {
                continue;
              }
              let delta = charIndex - st5;
              for (const glyph of glyphGroup) {
                delta -= glyph.count;
                if (delta < 0) {
                  return {
                    page: segmentPage,
                    pageType: segmentPage.type,
                    section,
                    column,
                    line: line2,
                    divide,
                    glyph,
                    segmentPageIndex
                  };
                }
              }
            }
          }
        }
      }
    }
  }
};

// ../packages/engine-render/src/components/sheets/util.ts
function createDocumentModelWithStyle(content, textStyle, config = {}) {
  const contentLength = content.length;
  const {
    textRotation,
    paddingData,
    horizontalAlign = 0 /* UNSPECIFIED */,
    verticalAlign = 0 /* UNSPECIFIED */,
    wrapStrategy = 0 /* UNSPECIFIED */,
    cellValueType
  } = config;
  const { t: marginTop, r: marginRight, b: marginBottom, l: marginLeft } = paddingData || DEFAULT_PADDING_DATA;
  const { vertexAngle, centerAngle } = convertTextRotation(textRotation);
  const documentData = {
    id: "d",
    body: {
      dataStream: `${content}${DEFAULT_EMPTY_DOCUMENT_VALUE}`,
      textRuns: [
        {
          ts: textStyle,
          st: 0,
          ed: contentLength
        }
      ],
      paragraphs: [
        {
          startIndex: contentLength,
          paragraphStyle: {
            horizontalAlign
          }
        }
      ],
      sectionBreaks: [{
        startIndex: contentLength + 1
      }]
    },
    documentStyle: {
      pageSize: {
        width: Number.POSITIVE_INFINITY,
        height: Number.POSITIVE_INFINITY
      },
      marginTop,
      marginBottom,
      marginRight,
      marginLeft,
      renderConfig: {
        horizontalAlign,
        verticalAlign,
        centerAngle,
        vertexAngle,
        wrapStrategy,
        cellValueType
      }
    },
    drawings: {},
    drawingsOrder: []
  };
  return new DocumentDataModel(documentData);
}
function extractOtherStyle(style) {
  if (!style) return {};
  const {
    tr: textRotation,
    td: textDirection,
    ht: horizontalAlign,
    vt: verticalAlign,
    tb: wrapStrategy,
    pd: paddingData
  } = style;
  return {
    textRotation,
    textDirection,
    horizontalAlign,
    verticalAlign,
    wrapStrategy,
    paddingData
  };
}
function getFontFormat(format) {
  if (!format) {
    return {};
  }
  const { ff, fs, it, bl, ul, st, ol, cl } = format;
  const style = {};
  ff && (style.ff = ff);
  fs && (style.fs = fs);
  it && (style.it = it);
  bl && (style.bl = bl);
  ul && (style.ul = ul);
  st && (style.st = st);
  ol && (style.ol = ol);
  cl && (style.cl = cl);
  return style;
}

// ../packages/engine-render/src/components/sheets/sheet.render-skeleton.ts
var DEFAULT_CELL_DOCUMENT_MODEL_OPTION = {
  isDeepClone: false,
  displayRawFormula: false,
  ignoreTextRotation: false
};
var DEFAULT_PADDING_DATA = {
  t: 0,
  b: 2,
  // must over 1, see https://github.com/dream-num/univer/issues/2727
  l: 2,
  r: 2
};
var RENDER_RAW_FORMULA_KEY = "RENDER_RAW_FORMULA";
var SpreadsheetSkeleton = class extends SheetSkeleton {
  constructor(worksheet, _styles, _localeService, _contextService, _configService, _injector) {
    super(worksheet, _styles, _localeService, _contextService, _configService, _injector);
    /**
     * Range viewBounds. only update by viewBounds.
     * It would change multiple times in one frame if there is multiple viewport (after freeze row&col)
     */
    __publicField(this, "_drawingRange", {
      startRow: -1,
      endRow: -1,
      startColumn: -1,
      endColumn: -1
    });
    __publicField(this, "_cacheRangeMap", /* @__PURE__ */ new Map());
    __publicField(this, "_visibleRangeMap", /* @__PURE__ */ new Map());
    // private _dataMergeCache: IRange[] = [];
    __publicField(this, "_overflowCache", new ObjectMatrix());
    __publicField(this, "_stylesCache", {
      background: {},
      backgroundPositions: new ObjectMatrix(),
      font: {},
      fontMatrix: new ObjectMatrix(),
      border: new ObjectMatrix()
    });
    /** A matrix to store if a (row, column) position has render cache. */
    __publicField(this, "_handleBgMatrix", new ObjectMatrix());
    __publicField(this, "_handleBorderMatrix", new ObjectMatrix());
    __publicField(this, "_handleFontMatrix", new ObjectMatrix());
    __publicField(this, "_showGridlines", 1 /* TRUE */);
    __publicField(this, "_gridlinesColor");
    __publicField(this, "_scene", null);
    this._updateLayout();
    this.disposeWithMe(
      this._contextService.subscribeContextValue$(RENDER_RAW_FORMULA_KEY).pipe(
        startWith(false),
        distinctUntilChanged()
      ).subscribe((renderRaw) => {
        this._renderRawFormula = renderRaw;
        this._resetCache();
        this.makeDirty(true);
      })
    );
  }
  setScene(scene) {
    this._scene = scene;
    this.disposeWithMe(
      this._scene.onTransformChange$.subscribeEvent((param) => {
        this.setScale(param.value.scaleX || 1, param.value.scaleY);
      })
    );
  }
  _updateLayout() {
    const {
      showGridlines,
      gridlinesColor
    } = this._worksheetData;
    this._showGridlines = showGridlines;
    this._gridlinesColor = gridlinesColor;
    super._updateLayout();
  }
  /**
   * Range of visible area(range in viewBounds)
   */
  get rowColumnSegment() {
    return this._drawingRange;
  }
  /**
   * Get range needs to render.
   * @param viewportKey
   * @returns
   */
  visibleRangeByViewportKey(viewportKey) {
    return this._cacheRangeMap.get(viewportKey);
  }
  get stylesCache() {
    return this._stylesCache;
  }
  get overflowCache() {
    return this._overflowCache;
  }
  get showGridlines() {
    return this._showGridlines;
  }
  get gridlinesColor() {
    return this._gridlinesColor;
  }
  dispose() {
    super.dispose();
    this._drawingRange = {
      startRow: -1,
      endRow: -1,
      startColumn: -1,
      endColumn: -1
    };
    this._stylesCache = {
      background: {},
      backgroundPositions: new ObjectMatrix(),
      font: {},
      fontMatrix: new ObjectMatrix(),
      border: new ObjectMatrix()
    };
    this._handleBgMatrix.reset();
    this._handleBorderMatrix.reset();
    this._overflowCache.reset();
  }
  /**
   * @deprecated should never expose a property that is provided by another module!
   */
  getStyles() {
    return this._styles;
  }
  setOverflowCache(value) {
    this._overflowCache = value;
  }
  getFont(rowIndex, columnIndex) {
    const fontCache2 = this.stylesCache.fontMatrix;
    if (!fontCache2) {
      return null;
    }
    const fontItem = fontCache2.getValue(rowIndex, columnIndex);
    if (fontItem) {
      return fontItem;
    }
    return null;
  }
  /**
   * Get range in visible area (range in view bounds) and set into this._rowColumnSegment.
   * @param vpInfo
   * @returns boolean
   */
  updateVisibleRange(vpInfo) {
    if (!this._worksheetData || !this.rowHeightAccumulation || !this.columnWidthAccumulation) {
      return false;
    }
    if (vpInfo) {
      const range = this.getRangeByViewport(vpInfo);
      this._visibleRangeMap.set(vpInfo.viewportKey, range);
      const cacheRange = this.getCacheRangeByViewport(vpInfo);
      this._drawingRange = cacheRange;
      this._cacheRangeMap.set(vpInfo.viewportKey, cacheRange);
    }
    return true;
  }
  getVisibleRangeByViewport(viewportKey) {
    return this._visibleRangeMap.get(viewportKey);
  }
  getVisibleRanges() {
    return this._visibleRangeMap;
  }
  /**
   * Set border background and font to this._stylesCache by visible range, which derives from bounds)
   * @param vpInfo viewBounds
   */
  setStylesCache(vpInfo) {
    if (!this._worksheetData) return;
    if (!this.rowHeightAccumulation || !this.columnWidthAccumulation) return;
    this.updateVisibleRange(vpInfo);
    const rowColumnSegment = this._drawingRange;
    const columnWidthAccumulation = this.columnWidthAccumulation;
    const { startRow: visibleStartRow, endRow: visibleEndRow, startColumn: visibleStartColumn, endColumn: visibleEndColumn } = rowColumnSegment;
    if (visibleEndColumn === -1 || visibleEndRow === -1) return;
    const mergeRanges = this.getCurrentRowColumnSegmentMergeData(this._drawingRange);
    for (const mergeRange of mergeRanges) {
      this._setStylesCacheForOneCell(mergeRange.startRow, mergeRange.startColumn, {
        mergeRange
      });
    }
    const expandStartCol = Math.max(0, visibleStartColumn - EXPAND_SIZE_FOR_RENDER_OVERFLOW);
    const expandEndCol = Math.min(columnWidthAccumulation.length - 1, visibleEndColumn + EXPAND_SIZE_FOR_RENDER_OVERFLOW);
    for (let r = visibleStartRow; r <= visibleEndRow; r++) {
      if (this.worksheet.getRowVisible(r) === false) continue;
      for (let c = visibleStartColumn; c <= visibleEndColumn; c++) {
        this._setStylesCacheForOneCell(r, c, { cacheItem: { bg: true, border: true } });
      }
      for (let c = expandStartCol; c < visibleEndColumn; c++) {
        this._setStylesCacheForOneCell(r, c, { cacheItem: { bg: false, border: false } });
      }
      if (visibleEndColumn === 0) continue;
      for (let c = visibleEndColumn + 1; c < expandEndCol; c++) {
        this._setStylesCacheForOneCell(r, c, { cacheItem: { bg: false, border: false } });
      }
    }
    return this;
  }
  //#region auto height
  /**
   * Calc all auto height by getDocsSkeletonPageSize in ranges
   * @param ranges
   * @returns {IRowAutoHeightInfo[]} result
   */
  calculateAutoHeightInRange(ranges) {
    var _a;
    if (!Tools.isArray(ranges)) {
      return [];
    }
    const results = [];
    const { rowData } = this._worksheetData;
    const rowObjectArray = rowData;
    const calculatedRows = /* @__PURE__ */ new Set();
    for (const range of ranges) {
      const { startRow, endRow, startColumn, endColumn } = range;
      for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
        if (calculatedRows.has(rowIndex)) {
          continue;
        }
        if (((_a = rowObjectArray[rowIndex]) == null ? void 0 : _a.ia) === 0 /* FALSE */) {
          continue;
        }
        const hasUnMergedCell = this._hasUnMergedCellInRow(rowIndex, startColumn, endColumn);
        if (hasUnMergedCell) {
          const autoHeight = this._calculateRowAutoHeight(rowIndex);
          calculatedRows.add(rowIndex);
          results.push({
            row: rowIndex,
            autoHeight
          });
        }
      }
    }
    return results;
  }
  // eslint-disable-next-line max-lines-per-function
  _calculateRowAutoHeight(rowNum) {
    var _a, _b, _c;
    const worksheet = this.worksheet;
    const { columnCount, columnData, defaultRowHeight, defaultColumnWidth } = this._worksheetData;
    let height = defaultRowHeight;
    for (let i = 0; i < columnCount; i++) {
      const cellMergeInfo = this.worksheet.getCellInfoInMergeData(rowNum, i);
      if (this._skipAutoHeightForMergedCells) {
        if (cellMergeInfo.isMerged || cellMergeInfo.isMergedMainCell) {
          continue;
        }
      }
      const cell = worksheet.getCell(rowNum, i);
      if (cell == null ? void 0 : cell.interceptorAutoHeight) {
        const cellHeight = cell.interceptorAutoHeight();
        if (cellHeight) {
          height = Math.max(height, cellHeight);
          continue;
        }
      }
      const modelObject = cell && this._getCellDocumentModel(cell);
      if (modelObject == null) {
        continue;
      }
      const { documentModel, textRotation, wrapStrategy } = modelObject;
      if (documentModel == null) {
        continue;
      }
      const documentViewModel = new DocumentViewModel(documentModel);
      const { vertexAngle: angle } = convertTextRotation(textRotation);
      let colWidth = (_b = (_a = columnData[i]) == null ? void 0 : _a.w) != null ? _b : defaultColumnWidth;
      if (cellMergeInfo.isMergedMainCell) {
        const mergeCellStartCol = cellMergeInfo.startColumn;
        const mergeCellEndCol = cellMergeInfo.endColumn;
        const mergeCellWidth = mergeCellEndCol - mergeCellStartCol + 1;
        colWidth = Array.from(
          { length: mergeCellEndCol - mergeCellStartCol + 1 },
          (_819, index) => mergeCellStartCol + index
        ).reduce((sum, colIndex) => {
          var _a2, _b2;
          return sum + ((_b2 = (_a2 = columnData[colIndex]) == null ? void 0 : _a2.w) != null ? _b2 : defaultColumnWidth);
        }, 0);
      }
      if (typeof colWidth === "number" && wrapStrategy === 3 /* WRAP */) {
        documentModel.updateDocumentDataPageSize(colWidth);
      }
      const documentSkeleton = DocumentSkeleton.create(documentViewModel, this._localeService);
      documentSkeleton.calculate();
      let { height: h = 0 } = (_c = getDocsSkeletonPageSize(documentSkeleton, angle)) != null ? _c : {};
      if (documentSkeleton) {
        const skeletonData = documentSkeleton.getSkeletonData();
        const {
          marginTop: t2,
          marginBottom: b,
          marginLeft: l,
          marginRight: r
        } = skeletonData.pages[skeletonData.pages.length - 1];
        const absAngleInRad = Math.abs(degToRad(angle));
        h += t2 * Math.cos(absAngleInRad) + r * Math.sin(absAngleInRad) + b * Math.cos(absAngleInRad) + l * Math.sin(absAngleInRad);
      }
      height = Math.max(height, h);
    }
    return Math.min(height, MAXIMUM_ROW_HEIGHT);
  }
  //#endregion
  //#region calculate auto width
  calculateAutoWidthInRange(ranges) {
    if (!Tools.isArray(ranges)) {
      return [];
    }
    const results = [];
    const calculatedCols = /* @__PURE__ */ new Set();
    for (const range of ranges) {
      const { startColumn, endColumn } = range;
      for (let colIndex = startColumn; colIndex <= endColumn; colIndex++) {
        if (!this.worksheet.getColVisible(colIndex)) continue;
        if (calculatedCols.has(colIndex)) continue;
        const autoWidth = this._calculateColWidth(colIndex);
        calculatedCols.add(colIndex);
        results.push({
          col: colIndex,
          width: autoWidth
        });
      }
    }
    return results;
  }
  /**
   * Iterate rows in visible area(and rows around it) and return column width of the specified column(by column index)
   *
   * @param colIndex
   * @returns {number} width
   */
  _calculateColWidth(colIndex) {
    var _a, _b;
    const worksheet = this.worksheet;
    let colWidth = 0;
    const visibleRangeViewMain = this.visibleRangeByViewportKey("viewMain" /* VIEW_MAIN */);
    if (!visibleRangeViewMain) return colWidth;
    const { startRow: startRowOfViewMain, endRow: endRowOfViewMain } = visibleRangeViewMain;
    const rowCount = this.worksheet.getRowCount();
    const otherRowIndex = /* @__PURE__ */ new Set();
    otherRowIndex.add(0);
    otherRowIndex.add(rowCount - 1);
    const visibleRangeViewMainTop = this.visibleRangeByViewportKey("viewMainTop" /* VIEW_MAIN_TOP */);
    if (visibleRangeViewMainTop) {
      const { startRow: startRowOfViewMainTop, endRow: endRowOfViewMainTop } = visibleRangeViewMainTop;
      for (let i = startRowOfViewMainTop; i <= endRowOfViewMainTop; i++) {
        otherRowIndex.add(i);
      }
    }
    const createRowSequence = (start, end, additionalArr) => {
      const range = Array.from(
        { length: end - start + 1 },
        (_819, i) => i + start
      );
      return [...range, ...additionalArr];
    };
    const checkStartRow = Math.max(0, startRowOfViewMain - MEASURE_EXTENT);
    const checkEndRow = Math.min(rowCount, endRowOfViewMain + MEASURE_EXTENT);
    const rowIdxArr = createRowSequence(checkStartRow, checkEndRow, otherRowIndex);
    const preColIndex = Math.max(0, colIndex - 1);
    let currColWidth = this.columnWidthAccumulation[colIndex] - this.columnWidthAccumulation[preColIndex];
    if (colIndex === 0) {
      currColWidth = this.columnWidthAccumulation[colIndex];
    }
    for (let i = 0; i < rowIdxArr.length; i++) {
      const row = rowIdxArr[i];
      const { isMerged, isMergedMainCell } = this.worksheet.getCellInfoInMergeData(colIndex, row);
      if (isMerged && !isMergedMainCell) continue;
      if (!this.worksheet.getRowVisible(row)) continue;
      const cell = worksheet.getCell(row, colIndex);
      if (!cell) continue;
      if (cell.p) {
        if (row + MEASURE_EXTENT_FOR_PARAGRAPH <= startRowOfViewMain || row - MEASURE_EXTENT_FOR_PARAGRAPH >= endRowOfViewMain) continue;
      }
      let measuredWidth = this._getMeasuredWidthByCell(cell, currColWidth);
      if (cell.fontRenderExtension) {
        measuredWidth += (((_a = cell.fontRenderExtension) == null ? void 0 : _a.leftOffset) || 0) + (((_b = cell.fontRenderExtension) == null ? void 0 : _b.rightOffset) || 0);
      }
      colWidth = Math.max(colWidth, measuredWidth);
      if (colWidth >= MAXIMUM_COL_WIDTH) return MAXIMUM_COL_WIDTH;
    }
    if (colWidth === 0) return currColWidth;
    return Math.max(MIN_COL_WIDTH, colWidth);
  }
  getColWidth(colIndex) {
    const preColIndex = Math.max(0, colIndex - 1);
    const currColWidth = this.columnWidthAccumulation[colIndex] - this.columnWidthAccumulation[preColIndex];
    return currColWidth;
  }
  getRowHeight(rowIndex) {
    const preRowIndex = Math.max(0, rowIndex - 1);
    const currRowHeight = this.rowHeightAccumulation[rowIndex] - this.rowHeightAccumulation[preRowIndex];
    return currRowHeight;
  }
  /**
   * For _calculateColMaxWidth
   * @param cell
   * @returns {number} currColWidth
   */
  _getMeasuredWidthByCell(cell, currColWidth) {
    var _a, _b, _c;
    let measuredWidth = 0;
    if (((_a = cell.fontRenderExtension) == null ? void 0 : _a.isSkip) && (cell == null ? void 0 : cell.interceptorAutoWidth)) {
      const cellWidth = (_b = cell.interceptorAutoWidth) == null ? void 0 : _b.call(cell);
      if (cellWidth) {
        return cellWidth;
      }
    }
    const modelObject = this._getCellDocumentModel(cell);
    if (modelObject == null) {
      return measuredWidth;
    }
    const { documentModel, textRotation } = modelObject;
    if (documentModel == null) {
      return measuredWidth;
    }
    const documentViewModel = new DocumentViewModel(documentModel);
    const { vertexAngle: angle } = convertTextRotation(textRotation);
    const cellStyle = this._styles.getStyleByCell(cell);
    if ((cellStyle == null ? void 0 : cellStyle.tb) === 3 /* WRAP */) {
      documentModel.updateDocumentDataPageSize(currColWidth, Infinity);
    } else {
      documentModel.updateDocumentDataPageSize(Infinity, Infinity);
    }
    const documentSkeleton = DocumentSkeleton.create(documentViewModel, this._localeService);
    documentSkeleton.calculate();
    measuredWidth = ((_c = getDocsSkeletonPageSize(documentSkeleton, angle)) != null ? _c : { width: 0 }).width;
    if (documentSkeleton) {
      const skeletonData = documentSkeleton.getSkeletonData();
      const {
        marginTop: t2,
        marginBottom: b,
        marginLeft: l,
        marginRight: r
      } = skeletonData.pages[skeletonData.pages.length - 1];
      const absAngleInRad = Math.abs(degToRad(angle));
      measuredWidth += t2 * Math.sin(absAngleInRad) + r * Math.cos(absAngleInRad) + b * Math.sin(absAngleInRad) + l * Math.cos(absAngleInRad);
    }
    return measuredWidth;
  }
  //#endregion
  /**
   * @deprecated use `getRangeByViewport` instead.
   * @param bounds
   */
  getRangeByBounding(bounds) {
    return this._getRangeByViewBounding(this.rowHeightAccumulation, this.columnWidthAccumulation, bounds == null ? void 0 : bounds.cacheBound);
  }
  getRangeByViewport(vpInfo) {
    return this._getRangeByViewBounding(this.rowHeightAccumulation, this.columnWidthAccumulation, vpInfo == null ? void 0 : vpInfo.viewBound);
  }
  getCacheRangeByViewport(vpInfo) {
    return this._getRangeByViewBounding(this.rowHeightAccumulation, this.columnWidthAccumulation, vpInfo == null ? void 0 : vpInfo.cacheBound);
  }
  getRangeByViewBound(bound) {
    return this._getRangeByViewBounding(this.rowHeightAccumulation, this.columnWidthAccumulation, bound);
  }
  appendToOverflowCache(row, column, startColumn, endColumn) {
    this._overflowCache.setValue(row, column, {
      startRow: row,
      endRow: row,
      startColumn,
      endColumn
    });
  }
  getOverflowPosition(contentSize, horizontalAlign, row, column, columnCount) {
    var _a;
    const contentWidth = (_a = contentSize == null ? void 0 : contentSize.width) != null ? _a : 0;
    let startColumn = column;
    let endColumn = column;
    if (horizontalAlign === 2 /* CENTER */) {
      startColumn = this._getOverflowBound(row, column, 0, contentWidth / 2, horizontalAlign);
      endColumn = this._getOverflowBound(row, column, columnCount - 1, contentWidth / 2, horizontalAlign);
    } else if (horizontalAlign === 3 /* RIGHT */) {
      startColumn = this._getOverflowBound(row, column, 0, contentWidth);
    } else {
      endColumn = this._getOverflowBound(row, column, columnCount - 1, contentWidth);
    }
    return {
      startColumn,
      endColumn
    };
  }
  /**
   * Get cell by pos(offsetX, offsetY).
   * @deprecated Please use `getCellWithCoordByOffset` instead.
   */
  calculateCellIndexByPosition(offsetX, offsetY, scaleX, scaleY, scrollXY) {
    return this.getCellWithCoordByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
  }
  /**
   * This method has the same implementation as `getCellIndexByOffset`,
   * but uses a different name to maintain backward compatibility with previous calls.
   *
   * @deprecated Please use `getCellIndexByOffset` method instead.
   */
  getCellPositionByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY, options) {
    return this.getCellIndexByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY, options);
  }
  getCellWithMergeInfoByIndex(row, column) {
    const selectionCell = this.worksheet.getCellInfoInMergeData(row, column);
    return selectionCell;
  }
  /**
   * Same as getColumnIndexByOffsetX
   * @deprecated Please use `getColumnIndexByOffsetX` method instead.
   */
  getColumnPositionByOffsetX(offsetX, scaleX, scrollXY, options) {
    return this.getColumnIndexByOffsetX(offsetX, scaleX, scrollXY, options);
  }
  /**
   * Same as getRowIndexByOffsetY
   * @deprecated Please use `getRowIndexByOffsetY` method instead.
   */
  getRowPositionByOffsetY(offsetY, scaleY, scrollXY, options) {
    return this.getRowIndexByOffsetY(offsetY, scaleY, scrollXY, options);
  }
  /**
   * Same as getCellWithCoordByIndex, but uses a different name to maintain backward compatibility with previous calls.
   * @deprecated Please use `getCellWithCoordByIndex` instead.
   */
  getCellByIndex(row, column) {
    return this.getCellWithCoordByIndex(row, column);
  }
  /**
   * @deprecated Please use `getCellWithCoordByIndex(row, col, false)` instead.
   * @param row
   * @param column
   */
  getCellByIndexWithNoHeader(row, column) {
    return this.getCellWithCoordByIndex(row, column, false);
  }
  /**
   * Only used for cell edit, and no need to rotate text when edit cell content!
   * @deprecated use same method in worksheet.
   * @param cell
   */
  getBlankCellDocumentModel(cell) {
    const documentModelObject = this._getCellDocumentModel(cell, { ignoreTextRotation: true });
    const style = this._styles.getStyleByCell(cell);
    const textStyle = getFontFormat(style);
    if (documentModelObject != null) {
      if (documentModelObject.documentModel == null) {
        documentModelObject.documentModel = createDocumentModelWithStyle("", textStyle);
      }
      return documentModelObject;
    }
    const content = "";
    let fontString = "document";
    const textRotation = DEFAULT_STYLES.tr;
    const horizontalAlign = DEFAULT_STYLES.ht;
    const verticalAlign = DEFAULT_STYLES.vt;
    const wrapStrategy = DEFAULT_STYLES.tb;
    const paddingData = DEFAULT_PADDING_DATA;
    fontString = getFontStyleString({}).fontCache;
    const documentModel = createDocumentModelWithStyle(content, textStyle);
    return {
      documentModel,
      fontString,
      textRotation,
      wrapStrategy,
      verticalAlign,
      horizontalAlign,
      paddingData
    };
  }
  /**
   * Only used for cell edit, and no need to rotate text when edit cell content!
   * @deprecated use same method in worksheet.
   * @param cell
   */
  getCellDocumentModelWithFormula(cell) {
    return this._getCellDocumentModel(cell, {
      isDeepClone: true,
      displayRawFormula: true,
      ignoreTextRotation: true
    });
  }
  /**
   * This method generates a document model based on the cell's properties and handles the associated styles and configurations.
   * If the cell does not exist, it will return null.
   *
   * @deprecated use same method in worksheet.
   * PS: This method has significant impact on performance.
   * @param cell
   * @param options
   */
  // eslint-disable-next-line complexity, max-lines-per-function
  _getCellDocumentModel(cell, options = DEFAULT_CELL_DOCUMENT_MODEL_OPTION) {
    var _a;
    const { isDeepClone, displayRawFormula, ignoreTextRotation } = {
      ...DEFAULT_CELL_DOCUMENT_MODEL_OPTION,
      ...options
    };
    const style = this._styles.getStyleByCell(cell);
    if (!cell) return;
    let documentModel;
    let fontString = "document";
    const cellOtherConfig = extractOtherStyle(style);
    const textRotation = ignoreTextRotation ? DEFAULT_STYLES.tr : cellOtherConfig.textRotation || DEFAULT_STYLES.tr;
    let horizontalAlign = cellOtherConfig.horizontalAlign || DEFAULT_STYLES.ht;
    const verticalAlign = cellOtherConfig.verticalAlign || DEFAULT_STYLES.vt;
    const wrapStrategy = cellOtherConfig.wrapStrategy || DEFAULT_STYLES.tb;
    const paddingData = cellOtherConfig.paddingData || DEFAULT_PADDING_DATA;
    if (cell.f && displayRawFormula) {
      documentModel = createDocumentModelWithStyle(cell.f.toString(), {}, { verticalAlign });
      horizontalAlign = DEFAULT_STYLES.ht;
    } else if (cell.p) {
      const { centerAngle, vertexAngle } = convertTextRotation(textRotation);
      documentModel = this._updateConfigAndGetDocumentModel(
        isDeepClone ? Tools.deepClone(cell.p) : cell.p,
        horizontalAlign,
        paddingData,
        {
          horizontalAlign,
          verticalAlign,
          centerAngle,
          vertexAngle,
          wrapStrategy,
          zeroWidthParagraphBreak: 1
        }
      );
    } else if (cell.v != null) {
      const textStyle = getFontFormat(style);
      fontString = getFontStyleString(textStyle).fontCache;
      let cellText = extractPureTextFromCell(cell);
      if (cell.t === 4 /* FORCE_STRING */ && displayRawFormula) {
        cellText = `'${cellText}`;
      }
      documentModel = createDocumentModelWithStyle(cellText, textStyle, {
        ...cellOtherConfig,
        textRotation,
        cellValueType: cell.t
      });
    }
    if (documentModel && cell.linkUrl && cell.linkId) {
      addLinkToDocumentModel(documentModel, cell.linkUrl, cell.linkId);
    }
    return {
      documentModel,
      fontString,
      textRotation,
      wrapStrategy,
      verticalAlign,
      horizontalAlign,
      paddingData,
      fill: (_a = style == null ? void 0 : style.bg) == null ? void 0 : _a.rgb
    };
  }
  /**
   * Calculate the overflow of cell text. If there is no value on either side of the cell,
   * the text content of this cell can be drawn to both sides, not limited by the cell's width.
   * Overflow on the left or right is aligned according to the text's horizontal alignment.
   */
  // eslint-disable-next-line complexity, max-lines-per-function
  _calculateOverflowCell(row, column, docsConfig) {
    const { documentSkeleton, vertexAngle = 0, centerAngle = 0, horizontalAlign, wrapStrategy } = docsConfig;
    const cell = this._cellData.getValue(row, column);
    const { t: cellValueType = 1 /* STRING */ } = cell || {};
    let horizontalAlignPos = horizontalAlign;
    if (horizontalAlign === 0 /* UNSPECIFIED */) {
      if (centerAngle === VERTICAL_ROTATE_ANGLE && vertexAngle === VERTICAL_ROTATE_ANGLE) {
        horizontalAlignPos = 2 /* CENTER */;
      } else if (vertexAngle > 0 && vertexAngle !== VERTICAL_ROTATE_ANGLE || vertexAngle === -VERTICAL_ROTATE_ANGLE) {
        horizontalAlignPos = 3 /* RIGHT */;
      }
    }
    if ((wrapStrategy === 1 /* OVERFLOW */ || wrapStrategy === 0 /* UNSPECIFIED */) && cellValueType !== 2 /* NUMBER */ && cellValueType !== 3 /* BOOLEAN */ && horizontalAlign !== 4 /* JUSTIFIED */) {
      if (this.intersectMergeRange(row, column)) {
        return true;
      }
      let contentSize = getDocsSkeletonPageSize(documentSkeleton, vertexAngle);
      if (!contentSize) {
        return true;
      }
      if (vertexAngle !== 0) {
        const { startY, endY, startX, endX } = this.getCellWithCoordByIndex(
          row,
          column
        );
        const cellWidth = endX - startX;
        const cellHeight = endY - startY;
        if (contentSize.height > cellHeight) {
          contentSize = {
            width: cellHeight / Math.tan(Math.abs(vertexAngle)) + cellWidth,
            height: cellHeight
          };
        }
      }
      const position = this.getOverflowPosition(contentSize, horizontalAlignPos, row, column, this.getColumnCount());
      const { startColumn, endColumn } = position;
      if (startColumn === endColumn) {
        return true;
      }
      this.appendToOverflowCache(row, column, startColumn, endColumn);
    } else if (wrapStrategy === 3 /* WRAP */ && vertexAngle !== 0) {
      if (this.intersectMergeRange(row, column)) {
        return true;
      }
      const { startY, endY } = this.getCellWithCoordByIndex(
        row,
        column
      );
      const cellHeight = endY - startY;
      documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(cellHeight);
      documentSkeleton.calculate();
      const contentSize = getDocsSkeletonPageSize(documentSkeleton, vertexAngle);
      if (!contentSize) {
        return true;
      }
      const { startColumn, endColumn } = this.getOverflowPosition(
        contentSize,
        horizontalAlignPos,
        row,
        column,
        this.getColumnCount()
      );
      if (startColumn === endColumn) {
        return true;
      }
      this.appendToOverflowCache(row, column, startColumn, endColumn);
    }
    return false;
  }
  /**
   * Get the range of the bounding area of the canvas.
   * @param rowHeightAccumulation Row layout information
   * @param columnWidthAccumulation Column layout information
   * @param viewBound The range of the visible area of the canvas
   * @returns The range cell index of the canvas visible area
   */
  _getRangeByViewBounding(rowHeightAccumulation, columnWidthAccumulation, viewBound) {
    const lenOfRowData = rowHeightAccumulation.length;
    const lenOfColData = columnWidthAccumulation.length;
    if (!viewBound) {
      return {
        startRow: 0,
        endRow: lenOfRowData - 1,
        startColumn: 0,
        endColumn: lenOfColData - 1
      };
    }
    const startRow = searchArray(rowHeightAccumulation, Math.round(viewBound.top) - this.columnHeaderHeightAndMarginTop);
    const endRow = searchArray(rowHeightAccumulation, Math.round(viewBound.bottom) - this.columnHeaderHeightAndMarginTop);
    const startColumn = searchArray(columnWidthAccumulation, Math.round(viewBound.left) - this.rowHeaderWidthAndMarginLeft);
    const endColumn = searchArray(columnWidthAccumulation, Math.round(viewBound.right) - this.rowHeaderWidthAndMarginLeft);
    return {
      startRow,
      endRow,
      startColumn,
      endColumn
    };
  }
  /**
   * Get the current row and column segment visible merge data.
   * @returns {IRange} The visible merge data
   */
  getCurrentRowColumnSegmentMergeData(range) {
    const endColumnLast = this.columnWidthAccumulation.length - 1;
    if (!range) {
      const endRow = this.rowHeightAccumulation.length - 1;
      range = { startRow: 0, startColumn: 0, endRow, endColumn: endColumnLast };
    } else {
      range = {
        startRow: range.startRow,
        startColumn: 0,
        endRow: range.endRow,
        endColumn: endColumnLast
      };
    }
    return this.worksheet.getSpanModel().getMergedCellRangeForSkeleton(range.startRow, range.startColumn, range.endRow, range.endColumn);
  }
  resetCache() {
    this._resetCache();
  }
  /**
   * Any changes to sheet model would reset cache.
   */
  _resetCache() {
    var _a, _b, _c;
    this._stylesCache = {
      background: {},
      backgroundPositions: new ObjectMatrix(),
      font: {},
      fontMatrix: new ObjectMatrix(),
      border: new ObjectMatrix()
    };
    (_a = this._handleBgMatrix) == null ? void 0 : _a.reset();
    (_b = this._handleBorderMatrix) == null ? void 0 : _b.reset();
    (_c = this._overflowCache) == null ? void 0 : _c.reset();
  }
  resetRangeCache(ranges) {
    for (let i = 0; i < ranges.length; i++) {
      const range = ranges[i];
      Range.foreach(range, (row, col) => {
        this._stylesCache.fontMatrix.realDeleteValue(row, col);
      });
    }
    this.makeDirty(true);
  }
  _setBorderStylesCache(row, col, style, options) {
    const handledThisCell = Tools.isDefine(this._handleBorderMatrix.getValue(row, col));
    if (handledThisCell) return;
    const cacheItem = (options == null ? void 0 : options.cacheItem) || { bg: true, border: true };
    if (!cacheItem.border) return;
    this._handleBorderMatrix.setValue(row, col, true);
    if (style && style.bd) {
      const mergeRange = options == null ? void 0 : options.mergeRange;
      if (mergeRange) {
        this._setMergeBorderProps("t" /* TOP */, this._stylesCache, mergeRange);
        this._setMergeBorderProps("b" /* BOTTOM */, this._stylesCache, mergeRange);
        this._setMergeBorderProps("l" /* LEFT */, this._stylesCache, mergeRange);
        this._setMergeBorderProps("r" /* RIGHT */, this._stylesCache, mergeRange);
      } else if (!this.intersectMergeRange(row, col)) {
        this._setBorderProps(row, col, "t" /* TOP */, style, this._stylesCache);
        this._setBorderProps(row, col, "b" /* BOTTOM */, style, this._stylesCache);
        this._setBorderProps(row, col, "l" /* LEFT */, style, this._stylesCache);
        this._setBorderProps(row, col, "r" /* RIGHT */, style, this._stylesCache);
      }
      this._setBorderProps(row, col, "tl_br" /* TL_BR */, style, this._stylesCache);
      this._setBorderProps(row, col, "tl_bc" /* TL_BC */, style, this._stylesCache);
      this._setBorderProps(row, col, "tl_mr" /* TL_MR */, style, this._stylesCache);
      this._setBorderProps(row, col, "bl_tr" /* BL_TR */, style, this._stylesCache);
      this._setBorderProps(row, col, "ml_tr" /* ML_TR */, style, this._stylesCache);
      this._setBorderProps(row, col, "bc_tr" /* BC_TR */, style, this._stylesCache);
    }
  }
  _setBgStylesCache(row, col, style, options) {
    var _a;
    const handledThisCell = Tools.isDefine(this._handleBgMatrix.getValue(row, col));
    if (handledThisCell) return;
    const cacheItem = (options == null ? void 0 : options.cacheItem) || { bg: true, border: true };
    if (!cacheItem.bg) return;
    this._handleBgMatrix.setValue(row, col, true);
    if (style && style.bg && style.bg.rgb) {
      const rgb = style.bg.rgb;
      if (!this._stylesCache.background[rgb]) {
        this._stylesCache.background[rgb] = new ObjectMatrix();
      }
      const bgCache = this._stylesCache.background[rgb];
      bgCache.setValue(row, col, rgb);
      const cellInfo = this.getCellWithCoordByIndex(row, col, false);
      (_a = this._stylesCache.backgroundPositions) == null ? void 0 : _a.setValue(row, col, cellInfo);
    }
  }
  _setFontStylesCache(row, col, cellData) {
    if (isNullCell(cellData)) return;
    let config = {
      cellData,
      imageCacheMap: this._imageCacheMap
    };
    const cacheValue = this._stylesCache.fontMatrix.getValue(row, col);
    if (!cacheValue) {
      this._stylesCache.fontMatrix.setValue(row, col, config);
    } else {
      const cacheItem = cacheValue;
      cacheItem.cellData = cellData;
      this._stylesCache.fontMatrix.setValue(row, col, cacheValue);
      return;
    }
    const modelObject = this._getCellDocumentModel(cellData, {
      displayRawFormula: this._renderRawFormula
    });
    if (modelObject) {
      const { documentModel } = modelObject;
      if (documentModel) {
        const { fontString: _fontString, textRotation, wrapStrategy, verticalAlign, horizontalAlign } = modelObject;
        const documentViewModel = new DocumentViewModel(documentModel);
        if (documentViewModel) {
          const { vertexAngle, centerAngle } = convertTextRotation(textRotation);
          const documentSkeleton = DocumentSkeleton.create(documentViewModel, this._localeService);
          documentSkeleton.calculate();
          config = {
            documentSkeleton,
            vertexAngle,
            centerAngle,
            verticalAlign,
            horizontalAlign,
            wrapStrategy,
            imageCacheMap: this._imageCacheMap,
            cellData
          };
          this._calculateOverflowCell(row, col, config);
          this._handleFontMatrix.setValue(row, col, true);
        }
      }
    }
    this._stylesCache.fontMatrix.setValue(row, col, config);
    this._handleFontMatrix.setValue(row, col, true);
  }
  /**
   * Set border background and font to this._stylesCache cell by cell.
   * @param row {number}
   * @param col {number}
   * @param options {{ mergeRange: IRange; cacheItem: ICacheItem } | undefined}
   */
  _setStylesCacheForOneCell(row, col, options) {
    if (row === -1 || col === -1) {
      return;
    }
    if (!options) {
      options = { cacheItem: { bg: true, border: true } };
    }
    const { isMerged, isMergedMainCell, startRow, startColumn, endRow, endColumn } = this.worksheet.getCellInfoInMergeData(row, col);
    options.mergeRange = { startRow, startColumn, endRow, endColumn };
    const hidden = this.worksheet.getColVisible(col) === false || this.worksheet.getRowVisible(row) === false;
    if (hidden) {
      if (isMerged && !isMergedMainCell) {
        return;
      } else if (!isMergedMainCell) {
        return;
      }
    }
    const cell = this.worksheet.getCell(row, col) || this.worksheet.getCellRaw(row, col);
    const cellStyle = this._styles.getStyleByCell(cell);
    const columnStyle = this.worksheet.getColumnStyle(col);
    const rowStyle = this.worksheet.getRowStyle(row);
    const defaultStyle = this.worksheet.getDefaultCellStyleInternal();
    const style = this._isRowStylePrecedeColumnStyle ? composeStyles(defaultStyle, columnStyle, rowStyle, cell == null ? void 0 : cell.themeStyle, cellStyle) : composeStyles(defaultStyle, rowStyle, columnStyle, cell == null ? void 0 : cell.themeStyle, cellStyle);
    this._setBgStylesCache(row, col, style, options);
    this._setBorderStylesCache(row, col, style, options);
    this._setFontStylesCache(row, col, { ...cell, ...{ s: style } });
  }
  /**
   * pro/issues/344
   * In Excel, for the border rendering of merged cells to take effect, the outermost cells need to have the same border style.
   */
  _setMergeBorderProps(type2, cache, mergeRange) {
    var _a;
    if (!this.worksheet || !cache.border) return;
    const borders = [];
    let isAddBorders = true;
    let forStart = mergeRange.startRow;
    let forEnd = mergeRange.endRow;
    let row = mergeRange.startRow;
    let column = mergeRange.startColumn;
    if (type2 === "t" /* TOP */) {
      row = mergeRange.startRow;
      forStart = mergeRange.startColumn;
      forEnd = mergeRange.endColumn;
    } else if (type2 === "b" /* BOTTOM */) {
      row = mergeRange.endRow;
      forStart = mergeRange.startColumn;
      forEnd = mergeRange.endColumn;
    } else if (type2 === "l" /* LEFT */) {
      column = mergeRange.startColumn;
      forStart = mergeRange.startRow;
      forEnd = mergeRange.endRow;
    } else if (type2 === "r" /* RIGHT */) {
      column = mergeRange.endColumn;
      forStart = mergeRange.startRow;
      forEnd = mergeRange.endRow;
    }
    for (let i = forStart; i <= forEnd; i++) {
      if (type2 === "t" /* TOP */) {
        column = i;
      } else if (type2 === "b" /* BOTTOM */) {
        column = i;
      } else if (type2 === "l" /* LEFT */) {
        row = i;
      } else if (type2 === "r" /* RIGHT */) {
        row = i;
      }
      const cell = this.worksheet.getCell(row, column);
      if (!cell) {
        isAddBorders = false;
        break;
      }
      const style = this._styles.getStyleByCell(cell);
      if (!style) {
        isAddBorders = false;
        break;
      }
      const props = (_a = style.bd) == null ? void 0 : _a[type2];
      if (props) {
        const rgb = getColorStyle(props.cl) || COLOR_BLACK_RGB;
        borders.push({
          r: row,
          c: column,
          style: props.s,
          color: rgb
        });
      } else {
      }
    }
    borders.forEach((border) => {
      const { r, c, style, color } = border;
      if (!cache.border.getValue(r, c)) {
        cache.border.setValue(r, c, {});
      }
      cache.border.getValue(r, c)[type2] = {
        type: type2,
        style,
        color
      };
    });
  }
  _setBorderProps(r, c, type2, style, cache) {
    var _a, _b, _c;
    const props = (_a = style.bd) == null ? void 0 : _a[type2];
    if (!props || !cache.border) {
      return;
    }
    const rgb = getColorStyle(props.cl) || COLOR_BLACK_RGB;
    const borderCache = cache.border;
    if (!borderCache.getValue(r, c)) {
      borderCache.setValue(r, c, { [type2]: {} });
    }
    if (type2 === "t" /* TOP */) {
      const borderBottom = (_b = borderCache.getValue(r - 1, c)) == null ? void 0 : _b["b" /* BOTTOM */];
      if (borderBottom && isWhiteColor(rgb)) {
        return;
      }
    } else if (type2 === "l" /* LEFT */) {
      const borderRight = (_c = borderCache.getValue(r, c - 1)) == null ? void 0 : _c["r" /* RIGHT */];
      if (borderRight && isWhiteColor(rgb)) {
        return;
      }
    }
    borderCache.getValue(r, c)[type2] = {
      type: type2,
      style: props.s,
      color: rgb
    };
  }
  getDistanceFromTopLeft(row, col) {
    return {
      x: this.colStartX(col),
      y: this.rowStartY(row)
    };
  }
  colStartX(col) {
    const arr = this.columnWidthAccumulation;
    const i = col - 1;
    if (i === -1) return 0;
    return arr[i];
  }
  rowStartY(row) {
    const arr = this.rowHeightAccumulation;
    const i = row - 1;
    if (i === -1) return 0;
    return arr[i];
  }
  getHiddenRowsInRange(range) {
    const hiddenRows = [];
    for (let i = range.startRow; i <= range.endRow; i++) {
      if (!this.worksheet.getRowVisible(i)) {
        hiddenRows.push(i);
      }
    }
    return hiddenRows;
  }
  getHiddenColumnsInRange(range) {
    const hiddenCols = [];
    for (let i = range.startColumn; i <= range.endColumn; i++) {
      if (!this.worksheet.getColVisible(i)) {
        hiddenCols.push(i);
      }
    }
    return hiddenCols;
  }
  /**
   * @deprecated use function `convertTransformToOffsetX` in same package.
   */
  convertTransformToOffsetX(offsetX, scaleX, scrollXY) {
    const { x: scrollX } = scrollXY;
    return (offsetX - scrollX) * scaleX;
  }
  /**
   * @deprecated use function `convertTransformToOffsetY` in same package.
   */
  convertTransformToOffsetY(offsetY, scaleY, scrollXY) {
    const { y: scrollY } = scrollXY;
    return (offsetY - scrollY) * scaleY;
  }
};
SpreadsheetSkeleton = __decorateClass([
  __decorateParam(2, Inject(LocaleService)),
  __decorateParam(3, IContextService),
  __decorateParam(4, IConfigService),
  __decorateParam(5, Inject(Injector))
], SpreadsheetSkeleton);
function convertTransformToOffsetX(offsetX, scaleX, scrollXY) {
  const { x: scrollX } = scrollXY;
  return (offsetX - scrollX) * scaleX;
}
function convertTransformToOffsetY(offsetY, scaleY, scrollXY) {
  const { y: scrollY } = scrollXY;
  return (offsetY - scrollY) * scaleY;
}
function getDocsSkeletonPageSize(documentSkeleton, angleInDegree = 0) {
  const skeletonData = documentSkeleton == null ? void 0 : documentSkeleton.getSkeletonData();
  const angle = degToRad(angleInDegree);
  if (!skeletonData) {
    return null;
  }
  const { pages } = skeletonData;
  const lastPage = pages[pages.length - 1];
  const { width, height } = lastPage;
  if (angle === 0) {
    return { width, height };
  }
  if (Math.abs(angle) === Math.PI / 2) {
    return { width: height, height: width };
  }
  let allRotatedWidth = 0;
  let allRotatedHeight = 0;
  const widthArray = [];
  columnIterator([lastPage], (column) => {
    const { lines, width: columnWidth, spaceWidth } = column;
    const { rotatedHeight, rotatedWidth } = getRotateOffsetAndFarthestHypotenuse(lines, columnWidth, angle);
    allRotatedHeight += rotatedHeight;
    widthArray.push({ rotatedWidth, spaceWidth });
  });
  const widthCount = widthArray.length;
  for (let i = 0; i < widthCount; i++) {
    const { rotatedWidth } = widthArray[i];
    if (i === 0) {
      allRotatedWidth += rotatedWidth;
    }
  }
  return {
    width: allRotatedWidth,
    height: allRotatedHeight
  };
}

// ../packages/engine-render/src/components/sheets/extensions/font.ts
var UNIQUE_KEY5 = "DefaultFontExtension";
function rotatedBoundingBox(width, height, angleDegrees) {
  const angle = angleDegrees * Math.PI / 180;
  const rotatedWidth = Math.abs(width * Math.cos(angle)) + Math.abs(height * Math.sin(angle));
  const rotatedHeight = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));
  return { rotatedWidth, rotatedHeight };
}
var Font2 = class extends SheetExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "uKey", UNIQUE_KEY5);
    __publicField(this, "Z_INDEX", FONT_EXTENSION_Z_INDEX);
  }
  getDocuments() {
    const parent = this.parent;
    return parent == null ? void 0 : parent.getDocuments();
  }
  draw(ctx, parentScale, spreadsheetSkeleton, diffRanges, moreBoundsInfo) {
    const { stylesCache, worksheet } = spreadsheetSkeleton;
    const { fontMatrix } = stylesCache;
    if (!spreadsheetSkeleton || !worksheet || !fontMatrix) return;
    const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
    if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0 || !worksheet) {
      return;
    }
    const scale = this._getScale(parentScale);
    const { viewRanges = [], checkOutOfViewBound } = moreBoundsInfo;
    const renderFontContext = {
      ctx,
      scale,
      // rowHeightAccumulation,
      columnTotalWidth,
      // columnWidthAccumulation,
      rowTotalHeight,
      viewRanges,
      checkOutOfViewBound: checkOutOfViewBound || true,
      diffRanges,
      spreadsheetSkeleton
    };
    ctx.save();
    const uniqueMergeRanges = [];
    const mergeRangeIDSet = /* @__PURE__ */ new Set();
    const lastRowIndex = spreadsheetSkeleton.getRowCount() - 1;
    const lastColIndex = spreadsheetSkeleton.getColumnCount() - 1;
    viewRanges.forEach((range) => {
      range.startColumn -= EXPAND_SIZE_FOR_RENDER_OVERFLOW;
      range.endColumn += EXPAND_SIZE_FOR_RENDER_OVERFLOW;
      range = clampRange(range, lastRowIndex, lastColIndex);
      const intersectMergeRangesWithViewRanges = spreadsheetSkeleton.worksheet.getMergedCellRange(range.startRow, range.startColumn, range.endRow, range.endColumn);
      intersectMergeRangesWithViewRanges.forEach((mergeRange) => {
        const mergeRangeIndex = spreadsheetSkeleton.worksheet.getSpanModel().getMergeDataIndex(mergeRange.startRow, mergeRange.startColumn);
        if (!mergeRangeIDSet.has(mergeRangeIndex)) {
          mergeRangeIDSet.add(mergeRangeIndex);
          uniqueMergeRanges.push(mergeRange);
        }
      });
      Range.foreach(range, (row, col) => {
        const index = spreadsheetSkeleton.worksheet.getSpanModel().getMergeDataIndex(row, col);
        if (index !== -1) {
          return;
        }
        const cellInfo = spreadsheetSkeleton.getCellWithCoordByIndex(row, col, false);
        if (!cellInfo) return;
        renderFontContext.cellInfo = cellInfo;
        this._renderFontEachCell(renderFontContext, row, col, fontMatrix);
      });
    });
    uniqueMergeRanges.forEach((range) => {
      const cellInfo = spreadsheetSkeleton.getCellWithCoordByIndex(range.startRow, range.startColumn, false);
      renderFontContext.cellInfo = cellInfo;
      this._renderFontEachCell(renderFontContext, range.startRow, range.startColumn, fontMatrix);
    });
    ctx.restore();
  }
  _renderFontEachCell(renderFontCtx, row, col, fontMatrix) {
    var _a, _b;
    const { ctx, viewRanges, diffRanges, spreadsheetSkeleton, cellInfo } = renderFontCtx;
    const { startY, endY, startX, endX } = cellInfo;
    const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
    renderFontCtx.startX = startX;
    renderFontCtx.startY = startY;
    renderFontCtx.endX = endX;
    renderFontCtx.endY = endY;
    if (isMerged && !isMergedMainCell) {
      return true;
    }
    if (isMergedMainCell) {
      renderFontCtx.startX = mergeInfo.startX;
      renderFontCtx.startY = mergeInfo.startY;
      renderFontCtx.endX = mergeInfo.endX;
      renderFontCtx.endY = mergeInfo.endY;
    }
    const fontCache2 = fontMatrix.getValue(row, col);
    if (!fontCache2) return true;
    if (!fontCache2.documentSkeleton) return true;
    renderFontCtx.fontCache = fontCache2;
    const overflowRange = spreadsheetSkeleton.overflowCache.getValue(row, col);
    const renderRange = diffRanges && diffRanges.length > 0 ? diffRanges : viewRanges;
    const notInMergeRange = !isMergedMainCell && !isMerged;
    if (!overflowRange && notInMergeRange) {
      if (!inViewRanges(renderRange, row, col)) {
        return true;
      }
    }
    const visibleRow = spreadsheetSkeleton.worksheet.getRowVisible(row);
    const visibleCol = spreadsheetSkeleton.worksheet.getColVisible(col);
    if (!visibleRow || !visibleCol) return true;
    const cellData = spreadsheetSkeleton.worksheet.getCell(row, col) || {};
    if ((_a = cellData == null ? void 0 : cellData.fontRenderExtension) == null ? void 0 : _a.isSkip) {
      return true;
    }
    ctx.save();
    ctx.beginPath();
    renderFontCtx.overflowRectangle = overflowRange;
    this._clipByRenderBounds(renderFontCtx, row, col);
    ctx.translate(renderFontCtx.startX + FIX_ONE_PIXEL_BLUR_OFFSET, renderFontCtx.startY + FIX_ONE_PIXEL_BLUR_OFFSET);
    this._renderDocuments(ctx, row, col, renderFontCtx, spreadsheetSkeleton.overflowCache);
    ctx.closePath();
    ctx.restore();
    const documentDataModel = fontCache2.documentSkeleton.getViewModel().getDataModel();
    if ((_b = documentDataModel.getDrawingsOrder()) == null ? void 0 : _b.length) {
      ctx.save();
      ctx.beginPath();
      this._clipByRenderBounds(renderFontCtx, row, col, 1);
      this._renderImages(ctx, fontCache2, renderFontCtx.startX, renderFontCtx.startY, renderFontCtx.endX, renderFontCtx.endY);
      ctx.closePath();
      ctx.restore();
    }
    renderFontCtx.startX = 0;
    renderFontCtx.startY = 0;
    renderFontCtx.endX = 0;
    renderFontCtx.endY = 0;
    renderFontCtx.overflowRectangle = null;
    return false;
  }
  _renderImages(ctx, fontsConfig, startX, startY, endX, endY) {
    var _a;
    const { documentSkeleton, verticalAlign, horizontalAlign } = fontsConfig;
    const fontHeight = documentSkeleton.getSkeletonData().pages[0].height;
    const fontWidth = documentSkeleton.getSkeletonData().pages[0].width;
    const PADDING = 2;
    let fontX = startX;
    let fontY = startY;
    switch (verticalAlign) {
      case 1 /* TOP */:
        fontY = startY + PADDING;
        break;
      case 2 /* MIDDLE */:
        fontY = (startY + endY) / 2 - fontHeight / 2;
        break;
      default:
        fontY = endY - fontHeight - PADDING;
        break;
    }
    switch (horizontalAlign) {
      case 3 /* RIGHT */:
        fontX = endX - fontWidth - PADDING;
        break;
      case 2 /* CENTER */:
        fontX = (startX + endX) / 2 - fontWidth / 2;
        break;
      default:
        fontX = startX + PADDING;
        break;
    }
    const documentDataModel = documentSkeleton.getViewModel().getDataModel();
    const drawingDatas = documentDataModel.getDrawings();
    const drawings = (_a = documentSkeleton.getSkeletonData()) == null ? void 0 : _a.pages[0].skeDrawings;
    drawings == null ? void 0 : drawings.forEach((drawing) => {
      const drawingData = drawingDatas == null ? void 0 : drawingDatas[drawing.drawingId];
      if (drawingData) {
        const image = fontsConfig.imageCacheMap.getImage(
          drawingData.imageSourceType,
          drawingData.source,
          () => {
            var _a2;
            (_a2 = this.parent) == null ? void 0 : _a2.makeDirty();
          },
          () => {
            var _a2;
            (_a2 = this.parent) == null ? void 0 : _a2.makeDirty();
          }
        );
        const x = fontX + drawing.aLeft;
        const y = fontY + drawing.aTop;
        const width = drawing.width;
        const height = drawing.height;
        const angle = drawing.angle;
        const { rotatedHeight, rotatedWidth } = rotatedBoundingBox(width, height, angle);
        if (image && image.complete) {
          const angleRadians = angle * Math.PI / 180;
          ctx.save();
          ctx.translate(x + rotatedWidth / 2, y + rotatedHeight / 2);
          ctx.rotate(angleRadians);
          try {
            ctx.drawImage(image, -rotatedWidth / 2, -rotatedHeight / 2, width, height);
          } catch (e) {
            console.error(e);
          }
          ctx.restore();
        }
      }
    });
  }
  /**
   * Change font render bounds, for overflow and filter icon & custom render.
   * @param renderFontContext
   * @param row
   * @param col
   * @param fontCache
   */
  _clipByRenderBounds(renderFontContext, row, col, padding = 0) {
    var _a, _b, _c, _d, _e, _f;
    const { ctx, scale, overflowRectangle, fontCache: fontCache2 } = renderFontContext;
    let { startX, endX, startY, endY } = renderFontContext;
    const { horizontalAlign = 0, vertexAngle = 0, centerAngle = 0 } = fontCache2;
    let horizontalAlignOverFlow = horizontalAlign;
    if (horizontalAlign === 0 /* UNSPECIFIED */) {
      if (centerAngle === VERTICAL_ROTATE_ANGLE && vertexAngle === VERTICAL_ROTATE_ANGLE) {
        horizontalAlignOverFlow = 2 /* CENTER */;
      } else if (vertexAngle > 0 && vertexAngle !== VERTICAL_ROTATE_ANGLE || vertexAngle === -VERTICAL_ROTATE_ANGLE) {
        horizontalAlignOverFlow = 3 /* RIGHT */;
      }
    }
    const rightOffset = (_c = (_b = (_a = fontCache2 == null ? void 0 : fontCache2.cellData) == null ? void 0 : _a.fontRenderExtension) == null ? void 0 : _b.rightOffset) != null ? _c : 0;
    const leftOffset = (_f = (_e = (_d = fontCache2 == null ? void 0 : fontCache2.cellData) == null ? void 0 : _d.fontRenderExtension) == null ? void 0 : _e.leftOffset) != null ? _f : 0;
    let isOverflow = true;
    if (vertexAngle === 0) {
      startX = startX + leftOffset;
      endX = endX - rightOffset;
      if (rightOffset !== 0 || leftOffset !== 0) {
        isOverflow = false;
      }
    }
    const cellWidth = endX - startX;
    const cellHeight = endY - startY;
    if (overflowRectangle && isOverflow) {
      const { startColumn, startRow, endColumn, endRow } = overflowRectangle;
      const { spreadsheetSkeleton } = renderFontContext;
      const { rowHeightAccumulation, columnWidthAccumulation } = spreadsheetSkeleton;
      if (startColumn === endColumn && startColumn === col) {
        ctx.rectByPrecision(
          startX + 1 / scale,
          startY + 1 / scale,
          cellWidth - 2 / scale,
          cellHeight - 2 / scale
        );
        ctx.clip();
      } else {
        if (horizontalAlignOverFlow === 2 /* CENTER */) {
          this._clipRectangleForOverflow(
            ctx,
            startRow,
            endRow,
            startColumn,
            endColumn,
            scale,
            rowHeightAccumulation,
            columnWidthAccumulation,
            padding
          );
        } else if (horizontalAlignOverFlow === 3 /* RIGHT */) {
          this._clipRectangleForOverflow(
            ctx,
            startRow,
            row,
            startColumn,
            col,
            scale,
            rowHeightAccumulation,
            columnWidthAccumulation,
            padding
          );
        } else {
          this._clipRectangleForOverflow(
            ctx,
            row,
            endRow,
            col,
            endColumn,
            scale,
            rowHeightAccumulation,
            columnWidthAccumulation,
            padding
          );
        }
      }
    } else {
      ctx.rectByPrecision(startX + 1 / scale, startY + 1 / scale, cellWidth - 2 / scale, cellHeight - 2 / scale);
      ctx.clip();
    }
    renderFontContext.startX = startX;
    renderFontContext.startY = startY;
    renderFontContext.endX = endX;
    renderFontContext.endY = endY;
  }
  _renderDocuments(ctx, row, col, renderFontCtx, overflowCache) {
    const documents = this.getDocuments();
    if (documents == null) {
      throw new Error("documents is null");
    }
    const { fontCache: fontCache2 } = renderFontCtx;
    if (!fontCache2) return;
    const { documentSkeleton, vertexAngle = 0, wrapStrategy } = fontCache2;
    if (!documentSkeleton) return;
    const documentDataModel = documentSkeleton.getViewModel().getDataModel();
    let { startX, startY, endX, endY } = renderFontCtx;
    if (wrapStrategy === 3 /* WRAP */ && vertexAngle === 0) {
      documentDataModel.updateDocumentDataPageSize(endX - startX);
      documentSkeleton.calculate();
    } else {
      documentDataModel.updateDocumentDataPageSize(Number.POSITIVE_INFINITY);
    }
    const overflowRectangle = overflowCache.getValue(row, col);
    const isOverflow = !(wrapStrategy === 3 /* WRAP */ && vertexAngle === 0);
    if (isOverflow && overflowRectangle) {
      const contentSize = getDocsSkeletonPageSize(documentSkeleton);
      const documentStyle = documentDataModel.getSnapshot().documentStyle;
      if (contentSize && documentStyle) {
        const { width } = contentSize;
        const { marginRight = 0, marginLeft = 0 } = documentStyle;
        documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(width + marginLeft + marginRight);
        documentSkeleton.calculate();
      }
      const endColumn = overflowRectangle.endColumn;
      const startColumn = overflowRectangle.startColumn;
      const startRow = overflowRectangle.startRow;
      const endRow = overflowRectangle.endRow;
      const endCell = renderFontCtx.spreadsheetSkeleton.getCellWithCoordByIndex(endRow, endColumn);
      endX = endCell.endX;
      endY = endCell.endY;
      const startCell = renderFontCtx.spreadsheetSkeleton.getCellWithCoordByIndex(startRow, startColumn);
      startX = startCell.startX;
      startY = startCell.startY;
    }
    const viewBoundRightBottom = {
      right: endX - startX,
      bottom: endY - startY
    };
    documentSkeleton.makeDirty(false);
    documents.resize(endX - startX, endY - startY);
    documents.changeSkeleton(documentSkeleton).render(ctx, {
      viewBound: {
        left: 0,
        top: 0,
        right: viewBoundRightBottom.right,
        bottom: viewBoundRightBottom.bottom
      }
    });
  }
  _clipRectangleForOverflow(ctx, startRow, endRow, startColumn, endColumn, scale, rowHeightAccumulation, columnWidthAccumulation, padding = 0) {
    const startY = rowHeightAccumulation[startRow - 1] || 0;
    const endY = rowHeightAccumulation[endRow] || rowHeightAccumulation[rowHeightAccumulation.length - 1];
    const startX = columnWidthAccumulation[startColumn - 1] || 0;
    const endX = columnWidthAccumulation[endColumn] || columnWidthAccumulation[columnWidthAccumulation.length - 1];
    ctx.rectByPrecision(startX + padding, startY + padding, endX - startX - 2 * padding, endY - startY - 2 * padding);
    ctx.clip();
  }
};
SpreadsheetExtensionRegistry.add(Font2);

// ../packages/engine-render/src/components/sheets/extensions/marker.ts
var UNIQUE_KEY6 = "DefaultMarkerExtension";
var Z_INDEX2 = 60;
var stringifyRange2 = (range) => {
  const { startRow, endRow, startColumn, endColumn } = range;
  return `${startRow}-${endRow}-${startColumn}-${endColumn}`;
};
var Marker = class extends SheetExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "Z_INDEX", Z_INDEX2);
    __publicField(this, "uKey", UNIQUE_KEY6);
  }
  // eslint-disable-next-line max-lines-per-function
  draw(ctx, parentScale, skeleton, diffRanges) {
    if (ctx.__mode === "printing") {
      return;
    }
    const { worksheet, rowColumnSegment } = skeleton;
    if (!worksheet) {
      return;
    }
    const mergeCellRendered = /* @__PURE__ */ new Set();
    Range.foreach(rowColumnSegment, (row, col) => {
      var _a, _b, _c, _d;
      if (!worksheet.getRowVisible(row) || !worksheet.getColVisible(col)) {
        return;
      }
      let cellData = worksheet.getCell(row, col);
      const cellInfo = skeleton.getCellWithCoordByIndex(row, col, false);
      const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
      let { startY, endY, startX, endX } = cellInfo;
      if (isMergedMainCell || isMerged) {
        startY = mergeInfo.startY;
        endY = mergeInfo.endY;
        startX = mergeInfo.startX;
        endX = mergeInfo.endX;
      }
      if (isMerged) {
        const mainCell = {
          row: mergeInfo.startRow,
          col: mergeInfo.startColumn
        };
        cellData = worksheet.getCell(mainCell.row, mainCell.col);
      }
      if (!this.isRenderDiffRangesByRow(mergeInfo.startRow, mergeInfo.endRow, diffRanges)) {
        return true;
      }
      if (cellInfo.isMerged || cellInfo.isMergedMainCell) {
        const rangeStr = stringifyRange2(mergeInfo);
        if (mergeCellRendered.has(rangeStr)) {
          return;
        }
        mergeCellRendered.add(rangeStr);
      }
      if (!cellData) {
        return;
      }
      if ((_a = cellData.markers) == null ? void 0 : _a.tr) {
        ctx.save();
        const marker = cellData.markers.tr;
        const x = endX;
        const y = startY;
        ctx.fillStyle = marker.color;
        ctx.moveTo(x, y);
        ctx.beginPath();
        ctx.lineTo(x - marker.size, y);
        ctx.lineTo(x, y + marker.size);
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      if ((_b = cellData.markers) == null ? void 0 : _b.tl) {
        ctx.save();
        const marker = cellData.markers.tl;
        const x = startX;
        const y = startY;
        ctx.fillStyle = marker.color;
        ctx.moveTo(x, y);
        ctx.beginPath();
        ctx.lineTo(x + marker.size, y);
        ctx.lineTo(x, y + marker.size);
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      if ((_c = cellData.markers) == null ? void 0 : _c.br) {
        ctx.save();
        const marker = cellData.markers.br;
        const x = endX;
        const y = endY;
        ctx.fillStyle = marker.color;
        ctx.moveTo(x, y);
        ctx.beginPath();
        ctx.lineTo(x - marker.size, y);
        ctx.lineTo(x, y - marker.size);
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      if ((_d = cellData.markers) == null ? void 0 : _d.bl) {
        ctx.save();
        const marker = cellData.markers.bl;
        const x = startX;
        const y = endY;
        ctx.fillStyle = marker.color;
        ctx.moveTo(x, y);
        ctx.beginPath();
        ctx.lineTo(x + marker.size, y);
        ctx.lineTo(x, y - marker.size);
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    });
  }
};
SpreadsheetExtensionRegistry.add(Marker);

// ../packages/engine-render/src/components/sheets/extensions/row-header-layout.ts
var UNIQUE_KEY7 = "DefaultRowHeaderLayoutExtension";
var DEFAULT_ROW_STYLE = {
  fontSize: 13,
  fontFamily: DEFAULT_FONTFACE_PLANE,
  fontColor: "#000000",
  backgroundColor: getColor([248, 249, 250]),
  borderColor: getColor([217, 217, 217]),
  textAlign: "center",
  textBaseline: "middle"
};
var RowHeaderLayout = class extends SheetExtension {
  constructor(cfg) {
    super();
    __publicField(this, "uKey", UNIQUE_KEY7);
    __publicField(this, "Z_INDEX", 10);
    __publicField(this, "rowsCfg", []);
    __publicField(this, "headerStyle", {
      fontSize: DEFAULT_ROW_STYLE.fontSize,
      fontFamily: DEFAULT_ROW_STYLE.fontFamily,
      fontColor: DEFAULT_ROW_STYLE.fontColor,
      backgroundColor: DEFAULT_ROW_STYLE.backgroundColor,
      borderColor: DEFAULT_ROW_STYLE.borderColor,
      textAlign: DEFAULT_ROW_STYLE.textAlign,
      textBaseline: DEFAULT_ROW_STYLE.textBaseline
    });
    if (cfg) {
      this.configHeaderRow(cfg);
    }
  }
  configHeaderRow(cfg) {
    this.rowsCfg = cfg.rowsCfg || [];
    this.headerStyle = { ...this.headerStyle, ...cfg.headerStyle };
  }
  getCfgOfCurrentRow(rowIndex) {
    let mergeWithSpecCfg;
    let curRowSpecCfg;
    const rowsCfg = this.rowsCfg || [];
    if (rowsCfg[rowIndex]) {
      if (typeof rowsCfg[rowIndex] == "string") {
        rowsCfg[rowIndex] = { text: rowsCfg[rowIndex] };
      }
      curRowSpecCfg = rowsCfg[rowIndex];
      mergeWithSpecCfg = { ...this.headerStyle, ...curRowSpecCfg };
    } else {
      mergeWithSpecCfg = { ...this.headerStyle, text: `${rowIndex + 1}` };
    }
    const specStyle = Object.keys(curRowSpecCfg || {}).length > 1;
    return [mergeWithSpecCfg, specStyle];
  }
  setStyleToCtx(ctx, rowStyle) {
    if (rowStyle.textAlign) ctx.textAlign = rowStyle.textAlign;
    if (rowStyle.textBaseline) ctx.textBaseline = rowStyle.textBaseline;
    if (rowStyle.fontColor) ctx.fillStyle = rowStyle.fontColor;
    if (rowStyle.borderColor) ctx.strokeStyle = rowStyle.borderColor;
    if (rowStyle.fontSize) ctx.font = `${rowStyle.fontSize}px ${DEFAULT_FONTFACE_PLANE}`;
  }
  // eslint-disable-next-line max-lines-per-function
  draw(ctx, parentScale, spreadsheetSkeleton) {
    const { rowColumnSegment, rowHeaderWidth = 0 } = spreadsheetSkeleton;
    const { startRow, endRow } = rowColumnSegment;
    if (!spreadsheetSkeleton || rowHeaderWidth === 0) {
      return;
    }
    const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
    if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
      return;
    }
    const scale = this._getScale(parentScale);
    this.setStyleToCtx(ctx, this.headerStyle);
    ctx.save();
    ctx.fillStyle = this.headerStyle.backgroundColor;
    ctx.fillRectByPrecision(0, 0, rowHeaderWidth, rowTotalHeight);
    ctx.restore();
    ctx.setLineWidthByPrecision(1);
    ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
    let preRowPosition = 0;
    const rowHeightAccumulationLength = rowHeightAccumulation.length;
    for (let r = startRow - 1; r <= endRow; r++) {
      if (r < 0 || r > rowHeightAccumulationLength - 1) {
        continue;
      }
      const rowEndPosition = rowHeightAccumulation[r];
      if (preRowPosition === rowEndPosition) {
        continue;
      }
      const cellBound = {
        left: 0,
        top: preRowPosition,
        right: rowHeaderWidth,
        bottom: rowEndPosition,
        width: rowHeaderWidth,
        height: rowEndPosition - preRowPosition
      };
      const [curRowCfg, specStyle] = this.getCfgOfCurrentRow(r);
      if (specStyle && curRowCfg.backgroundColor) {
        ctx.save();
        ctx.fillStyle = curRowCfg.backgroundColor;
        ctx.fillRectByPrecision(cellBound.left, cellBound.top, cellBound.width, cellBound.height);
        ctx.restore();
      }
      ctx.beginPath();
      ctx.moveToByPrecision(cellBound.left, cellBound.bottom);
      ctx.lineToByPrecision(cellBound.right, cellBound.bottom);
      ctx.stroke();
      const textX = (() => {
        switch (curRowCfg.textAlign) {
          case "center":
            return cellBound.left + (cellBound.right - cellBound.left) / 2;
          case "right":
            return cellBound.right - MIDDLE_CELL_POS_MAGIC_NUMBER;
          case "left":
            return cellBound.left + MIDDLE_CELL_POS_MAGIC_NUMBER;
          default:
            return cellBound.left + (cellBound.right - cellBound.left) / 2;
        }
      })();
      const middleYCellRect = preRowPosition + (rowEndPosition - preRowPosition) / 2 + MIDDLE_CELL_POS_MAGIC_NUMBER;
      if (specStyle) {
        ctx.save();
        ctx.beginPath();
        this.setStyleToCtx(ctx, curRowCfg);
        ctx.rectByPrecision(cellBound.left, cellBound.top, cellBound.width, cellBound.height);
        ctx.clip();
      }
      ctx.fillText(curRowCfg.text, textX, middleYCellRect);
      if (specStyle) {
        ctx.restore();
      }
      preRowPosition = rowEndPosition;
    }
    const rowHeaderWidthFix = rowHeaderWidth - 0.5 / scale;
    ctx.beginPath();
    ctx.moveToByPrecision(rowHeaderWidthFix, 0);
    ctx.lineToByPrecision(rowHeaderWidthFix, rowTotalHeight);
    ctx.stroke();
  }
};
SheetRowHeaderExtensionRegistry.add(new RowHeaderLayout());

// ../packages/engine-render/src/components/sheets/row-header.ts
var SpreadsheetRowHeader = class extends SpreadsheetHeader {
  constructor(oKey, spreadsheetSkeleton) {
    super(oKey, spreadsheetSkeleton);
    __publicField(this, "_rowHeaderLayoutExtension");
    this._initialDefaultExtension();
    this.makeDirty(true);
  }
  getDocuments() {
    throw new Error("Method not implemented.");
  }
  getNoMergeCellPositionByIndex(rowIndex, columnIndex) {
    throw new Error("Method not implemented.");
  }
  getSelectionBounding(startRow, startColumn, endRow, endColumn) {
    throw new Error("Method not implemented.");
  }
  get rowHeaderLayoutExtension() {
    return this._rowHeaderLayoutExtension;
  }
  draw(ctx, bounds) {
    const spreadsheetSkeleton = this.getSkeleton();
    if (!spreadsheetSkeleton) {
      return;
    }
    const parentScale = this.getParentScale();
    spreadsheetSkeleton.updateVisibleRange(bounds);
    const segment = spreadsheetSkeleton.rowColumnSegment;
    if (!segment) {
      return;
    }
    if (segment.startRow === -1 && segment.endRow === -1) {
      return;
    }
    const { columnHeaderHeight } = spreadsheetSkeleton;
    ctx.translateWithPrecision(0, columnHeaderHeight);
    const extensions = this.getExtensionsByOrder();
    for (const extension of extensions) {
      extension.draw(ctx, parentScale, spreadsheetSkeleton);
    }
  }
  isHit(coord) {
    const oCoord = this.getInverseCoord(coord);
    const skeleton = this.getSkeleton();
    if (!skeleton) {
      return false;
    }
    const { rowHeaderWidth, columnHeaderHeight } = skeleton;
    if (oCoord.x >= 0 && oCoord.x <= rowHeaderWidth && oCoord.y > columnHeaderHeight) {
      return true;
    }
    return false;
  }
  _initialDefaultExtension() {
    SheetRowHeaderExtensionRegistry.getData().forEach((extension) => {
      this.register(extension);
    });
    this._rowHeaderLayoutExtension = this.getExtensionByKey("DefaultRowHeaderLayoutExtension");
  }
  setCustomHeader(cfg) {
    this.makeDirty(true);
    this._rowHeaderLayoutExtension.configHeaderRow(cfg);
  }
};

// ../packages/engine-render/src/components/docs/doc-component.ts
var DocComponent = class extends RenderComponent {
  constructor(oKey, _skeleton, config) {
    super(oKey);
    this._skeleton = _skeleton;
    __publicField(this, "pageMarginLeft", 0);
    __publicField(this, "pageMarginTop", 0);
    __publicField(this, "pageLayoutType", 0 /* VERTICAL */);
    this._setConfig(config);
  }
  getSkeleton() {
    return this._skeleton;
  }
  setSkeleton(skeleton) {
    this._skeleton = skeleton;
  }
  _setConfig(config) {
    if ((config == null ? void 0 : config.pageMarginLeft) != null) {
      this.pageMarginLeft = config == null ? void 0 : config.pageMarginLeft;
    } else {
      this.pageMarginLeft = 17;
    }
    if ((config == null ? void 0 : config.pageMarginTop) != null) {
      this.pageMarginTop = config == null ? void 0 : config.pageMarginTop;
    } else {
      this.pageMarginTop = 14;
    }
    if ((config == null ? void 0 : config.pageLayoutType) != null) {
      this.pageLayoutType = config == null ? void 0 : config.pageLayoutType;
    } else {
      this.pageLayoutType = 0 /* VERTICAL */;
    }
  }
  render(mainCtx, bounds) {
    if (!this.visible) {
      this.makeDirty(false);
      return this;
    }
    if (!this._skeleton) {
      return;
    }
    const m = this.transform.getMatrix();
    mainCtx.save();
    mainCtx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    this._draw(mainCtx, bounds);
    mainCtx.restore();
  }
  getParentScale() {
    if (!this.parent) {
      return { scaleX: 1, scaleY: 1 };
    }
    let { scaleX = 1, scaleY = 1 } = this.parent;
    if (this.parent.classType === "Scene" /* SCENE */) {
      scaleX = this.parent.ancestorScaleX || 1;
      scaleY = this.parent.ancestorScaleY || 1;
    }
    return {
      scaleX,
      scaleY
    };
  }
  isSkipByDiffBounds(page, pageTop, pageLeft, bounds) {
    if (bounds === null || bounds === void 0) {
      return false;
    }
    const { pageWidth, pageHeight, marginBottom, marginTop, marginLeft, marginRight } = page;
    const pageRight = pageLeft + pageWidth + marginLeft + marginRight;
    const pageBottom = pageTop + pageHeight + marginBottom + marginTop;
    const { left, top, right, bottom } = bounds.viewBound;
    if (pageRight < left || pageBottom < top) {
      return true;
    }
    if (pageLeft > right && pageWidth !== Number.POSITIVE_INFINITY) {
      return true;
    }
    if (pageTop > bottom && pageHeight !== Number.POSITIVE_INFINITY) {
      return true;
    }
    return false;
  }
};

// ../packages/engine-render/src/components/docs/doc-extension.ts
var docExtension = class extends ComponentExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "type", 0 /* SPAN */);
    __publicField(this, "translateX", 0);
    __publicField(this, "translateY", 0);
  }
};

// ../packages/engine-render/src/components/docs/extensions/background.ts
var UNIQUE_KEY8 = "DefaultDocsBackgroundExtension";
var DOC_EXTENSION_Z_INDEX2 = 10;
var Background2 = class extends docExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "uKey", UNIQUE_KEY8);
    __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX2);
    __publicField(this, "_preBackgroundColor", "");
  }
  draw(ctx, parentScale, span) {
    var _a;
    const line2 = (_a = span.parent) == null ? void 0 : _a.parent;
    if (line2 == null) {
      return;
    }
    const { contentHeight = 0 } = line2;
    const { ts: textStyle, width, content } = span;
    if ((textStyle == null ? void 0 : textStyle.bg) == null) {
      return;
    }
    const { bg } = textStyle;
    const background = getColorStyle(bg);
    const { spanStartPoint = Vector2.create(0, 0) } = this.extensionOffset;
    const DELTA = 1;
    if (background && content !== "\r") {
      ctx.fillStyle = background;
      ctx.fillRect(spanStartPoint.x - 0.5, spanStartPoint.y + 1, width + 1, contentHeight + 2 * DELTA);
    }
  }
  clearCache() {
    this._preBackgroundColor = "";
  }
};
DocumentsSpanAndLineExtensionRegistry.add(new Background2());

// ../packages/engine-render/src/components/docs/extensions/border.ts
var UNIQUE_KEY9 = "DefaultDocsBorderExtension";
var Border2 = class extends docExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "uKey", UNIQUE_KEY9);
    __publicField(this, "Z_INDEX", 50);
    __publicField(this, "_preBorderStyle");
    __publicField(this, "_preBorderColor", "");
  }
  draw(ctx, parentScale, glyph) {
    var _a;
    const line2 = (_a = glyph.parent) == null ? void 0 : _a.parent;
    if (!line2) {
      return;
    }
    const { asc: maxLineAsc = 0, lineHeight = 0 } = line2;
    const { ts: textStyle, left, width: spanWidth } = glyph;
    if (!textStyle) {
      return;
    }
    const { bd: borderData } = textStyle;
    if (!borderData) {
      return;
    }
    const precisionScale = this._getScale(ctx.getScale());
    const borderCache = this._createBorderCache(borderData);
    ctx.save();
    ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
    const { spanStartPoint = Vector2.create(0, 0) } = this.extensionOffset;
    for (const type2 of borderCache.keys()) {
      const borderCacheValue = borderCache.get(type2);
      if (!borderCacheValue) {
        continue;
      }
      const { s: style, cl: colorStyle } = borderCacheValue;
      const color = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
      const lineWidth = getLineWidth(style);
      if (style !== this._preBorderStyle) {
        setLineType(ctx, style);
        ctx.setLineWidthByPrecision(lineWidth);
        this._preBorderStyle = style;
      }
      if (color !== this._preBorderColor) {
        ctx.strokeStyle = color || COLOR_BLACK_RGB;
        this._preBorderColor = color;
      }
      drawLineByBorderType(ctx, type2, (lineWidth - 1) / 2 / precisionScale, {
        startX: spanStartPoint.x,
        startY: spanStartPoint.y,
        endX: spanStartPoint.x + spanWidth,
        endY: spanStartPoint.y + lineHeight
      });
    }
    ctx.restore();
  }
  clearCache() {
    this._preBorderStyle = null;
    this._preBorderColor = "";
  }
  _createBorderCache(borderData) {
    const { t: t2, b, l, r } = borderData;
    const borderCache = /* @__PURE__ */ new Map();
    t2 && borderCache.set("t" /* TOP */, t2);
    b && borderCache.set("b" /* BOTTOM */, b);
    l && borderCache.set("l" /* LEFT */, l);
    r && borderCache.set("r" /* RIGHT */, r);
    return borderCache;
  }
};
DocumentsSpanAndLineExtensionRegistry.add(new Border2());

// ../packages/engine-render/src/shape/checkbox.ts
var CHECK_OBJECT_ARRAY = ["checked"];
var CheckboxShape = class _CheckboxShape extends Shape {
  constructor(key, props) {
    super(key, props);
    __publicField(this, "_checked", false);
    if (Tools.isDefine(props.checked)) {
      this._checked = props.checked;
    }
  }
  get checked() {
    return this._checked;
  }
  static drawWith(ctx, props) {
    const { width = 16, height = 16, fill, checked, top = 0, left = 0 } = props;
    const uncheckedPath = new Path2D("M12 2.65381H4C3.17157 2.65381 2.5 3.32538 2.5 4.15381V12.1538C2.5 12.9822 3.17157 13.6538 4 13.6538H12C12.8284 13.6538 13.5 12.9822 13.5 12.1538V4.15381C13.5 3.32538 12.8284 2.65381 12 2.65381ZM4 1.65381C2.61929 1.65381 1.5 2.7731 1.5 4.15381V12.1538C1.5 13.5345 2.61929 14.6538 4 14.6538H12C13.3807 14.6538 14.5 13.5345 14.5 12.1538V4.15381C14.5 2.7731 13.3807 1.65381 12 1.65381H4Z");
    const checkedPath = new Path2D("M3.99243 1.65381C2.61172 1.65381 1.49243 2.77295 1.49243 4.15381V12.1538C1.49243 13.5347 2.61172 14.6538 3.99243 14.6538H11.9924C13.3731 14.6538 14.4924 13.5347 14.4924 12.1538V4.15381C14.4924 2.77295 13.3731 1.65381 11.9924 1.65381H3.99243ZM12.3779 6.3623C12.6317 6.1084 12.6317 5.69678 12.3779 5.44287C12.1241 5.18896 11.7125 5.18896 11.4586 5.44287L7.21062 9.69092L5.00681 7.4873C4.75296 7.2334 4.3414 7.2334 4.08755 7.4873C3.83372 7.74072 3.83372 8.15234 4.08757 8.40625L6.85709 11.1758C7.05234 11.3711 7.36893 11.3711 7.56418 11.1758L12.3779 6.3623Z");
    ctx.save();
    ctx.translate(left, top);
    ctx.scale(width / 16, height / 16);
    if (fill) {
      ctx.fillStyle = fill;
    }
    if (checked) {
      ctx.fill(checkedPath, "evenodd");
    } else {
      ctx.fill(uncheckedPath, "evenodd");
    }
    ctx.restore();
  }
  _draw(ctx) {
    _CheckboxShape.drawWith(ctx, this);
  }
  toJson() {
    const props = {};
    CHECK_OBJECT_ARRAY.forEach((key) => {
      if (this[key]) {
        props[key] = this[key];
      }
    });
    return {
      ...super.toJson(),
      ...props
    };
  }
};

// ../packages/engine-render/src/shape/dashedrect.ts
var DashedRect = class _DashedRect extends Rect {
  static drawWith(ctx, props) {
    let { radius, left, top, width, height } = props;
    radius = radius != null ? radius : 0;
    width = width != null ? width : 0;
    height = height != null ? height : 0;
    left = left != null ? left : 0;
    top = top != null ? top : 0;
    ctx.beginPath();
    ctx.setLineDash(props.strokeDashArray);
    if (!radius) {
      ctx.rect(left, top, width, height);
    } else {
      let topLeft = 0;
      let topRight = 0;
      let bottomLeft = 0;
      let bottomRight = 0;
      topLeft = topRight = bottomLeft = bottomRight = Math.min(radius, width / 2, height / 2);
      ctx.moveTo(topLeft, 0);
      ctx.lineTo(width - topRight, 0);
      ctx.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
      ctx.lineTo(width, height - bottomRight);
      ctx.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
      ctx.lineTo(bottomLeft, height);
      ctx.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
      ctx.lineTo(0, topLeft);
      ctx.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
    }
    ctx.closePath();
    this._renderPaintInOrder(ctx, props);
  }
  _draw(ctx, viewportInfo) {
    const { radius, paintFirst, stroke, strokeWidth, fill, strokeScaleEnabled, fillRule, strokeLineCap, strokeDashOffset, strokeLineJoin, strokeMiterLimit, strokeDashArray } = this;
    const parentTrans = this.getParent().transform;
    const startX = parentTrans.getMatrix()[4];
    const startY = parentTrans.getMatrix()[5];
    const endX = startX + this.width;
    const endY = startY + this.height;
    const rect = { left: startX, top: startY, right: endX, bottom: endY };
    let { left, top, right, bottom } = rect;
    let width = right - left;
    let height = bottom - top;
    if (viewportInfo) {
      const intersectRect = Rectangle.getIntersectionBetweenTwoRect(rect, viewportInfo.cacheBound);
      if (intersectRect) {
        left = intersectRect.left - startX;
        top = intersectRect.top - startY;
        right = intersectRect.right;
        bottom = intersectRect.bottom;
        width = intersectRect.width;
        height = intersectRect.height;
      }
    }
    _DashedRect.drawWith(ctx, { ...{ radius, paintFirst, stroke, strokeWidth, fill, strokeScaleEnabled, fillRule, strokeLineCap, strokeDashOffset, strokeLineJoin, strokeMiterLimit, strokeDashArray }, ...{ width, height, left, top } });
  }
};

// ../packages/engine-render/src/shape/image.ts
var Image2 = class extends Shape {
  constructor(id, config) {
    super(id, config);
    __publicField(this, "_props");
    __publicField(this, "_native");
    __publicField(this, "_renderByCropper", false);
    __publicField(this, "_transformCalculateSrcRect", true);
    __publicField(this, "objectType", 3 /* IMAGE */);
    this._props = {
      ...config
    };
    if (config.image) {
      this._native = config.image;
      this._native.crossOrigin = "anonymous";
      this.makeDirty(true);
    } else if (config.url) {
      this._native = document.createElement("img");
      this._native.src = config.url;
      this._native.crossOrigin = "anonymous";
      this._native.onload = () => {
        var _a, _b, _c;
        (_a = config.success) == null ? void 0 : _a.call(config);
        this.makeDirty(true);
        (_c = (_b = this.getEngine()) == null ? void 0 : _b.activeScene) == null ? void 0 : _c.onFileLoaded$.emitEvent(id);
      };
      this._native.onerror = () => {
        if (config.fail) {
          config.fail();
        } else {
          this._native.src = "data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTMwNC4xMjggNDU2LjE5MmM0OC42NCAwIDg4LjA2NC0zOS40MjQgODguMDY0LTg4LjA2NHMtMzkuNDI0LTg4LjA2NC04OC4wNjQtODguMDY0LTg4LjA2NCAzOS40MjQtODguMDY0IDg4LjA2NCAzOS40MjQgODguMDY0IDg4LjA2NCA4OC4wNjR6bTAtMTE2LjIyNGMxNS4zNiAwIDI4LjE2IDEyLjI4OCAyOC4xNiAyOC4xNnMtMTIuMjg4IDI4LjE2LTI4LjE2IDI4LjE2LTI4LjE2LTEyLjI4OC0yOC4xNi0yOC4xNiAxMi4yODgtMjguMTYgMjguMTYtMjguMTZ6IiBmaWxsPSIjZTZlNmU2Ii8+PHBhdGggZD0iTTg4Ny4yOTYgMTU5Ljc0NEgxMzYuNzA0Qzk2Ljc2OCAxNTkuNzQ0IDY0IDE5MiA2NCAyMzIuNDQ4djU1OS4xMDRjMCAzOS45MzYgMzIuMjU2IDcyLjcwNCA3Mi43MDQgNzIuNzA0aDE5OC4xNDRMNTAwLjIyNCA2ODguNjRsLTM2LjM1Mi0yMjIuNzIgMTYyLjMwNC0xMzAuNTYtNjEuNDQgMTQzLjg3MiA5Mi42NzIgMjE0LjAxNi0xMDUuNDcyIDE3MS4wMDhoMzM1LjM2QzkyNy4yMzIgODY0LjI1NiA5NjAgODMyIDk2MCA3OTEuNTUyVjIzMi40NDhjMC0zOS45MzYtMzIuMjU2LTcyLjcwNC03Mi43MDQtNzIuNzA0em0tMTM4Ljc1MiA3MS42OHYuNTEySDg1Ny42YzE2LjM4NCAwIDMwLjIwOCAxMy4zMTIgMzAuMjA4IDMwLjIwOHYzOTkuODcyTDY3My4yOCA0MDguMDY0bDc1LjI2NC0xNzYuNjR6TTMwNC42NCA3OTIuMDY0SDE2NS44ODhjLTE2LjM4NCAwLTMwLjIwOC0xMy4zMTItMzAuMjA4LTMwLjIwOHYtOS43MjhsMTM4Ljc1Mi0xNjQuMzUyIDEwNC45NiAxMjQuNDE2LTc0Ljc1MiA3OS44NzJ6bTgxLjkyLTM1NS44NGwzNy4zNzYgMjI4Ljg2NC0uNTEyLjUxMi0xNDIuODQ4LTE2OS45ODRjLTMuMDcyLTMuNTg0LTkuMjE2LTMuNTg0LTEyLjI4OCAwTDEzNS42OCA2NTIuOFYyNjIuMTQ0YzAtMTYuMzg0IDEzLjMxMi0zMC4yMDggMzAuMjA4LTMwLjIwOGg0NzQuNjI0TDM4Ni41NiA0MzYuMjI0em01MDEuMjQ4IDMyNS42MzJjMCAxNi44OTYtMTMuMzEyIDMwLjIwOC0yOS42OTYgMzAuMjA4SDY4MC45Nmw1Ny4zNDQtOTMuMTg0LTg3LjU1Mi0yMDIuMjQgNy4xNjgtNy42OCAyMjkuODg4IDI3Mi44OTZ6IiBmaWxsPSIjZTZlNmU2Ii8+PC9zdmc+";
          this.makeDirty(true);
        }
      };
    }
    this._init();
  }
  get srcRect() {
    return this._props.srcRect;
  }
  get prstGeom() {
    return this._props.prstGeom;
  }
  get opacity() {
    var _a;
    return (_a = this._props.opacity) != null ? _a : 1;
  }
  setOpacity(opacity) {
    this._props.opacity = opacity;
    this.makeDirty(true);
  }
  get classType() {
    return "Image" /* IMAGE */;
  }
  transformByStateCloseCropper(option) {
    this._transformCalculateSrcRect = false;
    this.transformByState(option);
    this._transformCalculateSrcRect = true;
  }
  changeSource(url) {
    if (this._native == null) {
      this._native = document.createElement("img");
    }
    this._native.src = url;
    this._native.onload = () => {
      this.makeDirty(true);
    };
  }
  resetSize() {
    if (this._native == null) {
      return;
    }
    this.transformByState({
      width: this._native.width,
      height: this._native.height
    });
    this.setSrcRect(null);
  }
  setPrstGeom(prstGeom) {
    this._props.prstGeom = prstGeom;
  }
  setSrcRect(srcRect) {
    this._props.srcRect = srcRect;
    this.makeDirty(true);
  }
  getProps() {
    return this._props;
  }
  getNative() {
    return this._native;
  }
  getNativeSize() {
    if (this._native == null) {
      return { width: this.width, height: this.height };
    }
    return { width: this._native.width, height: this._native.height };
  }
  closeRenderByCropper() {
    this._renderByCropper = false;
  }
  openRenderByCropper() {
    this._renderByCropper = true;
    this._transformBySrcRect();
  }
  // override transformForAngle(transform: Transform) {
  //     if (this.angle === 0) {
  //         return transform;
  //     }
  //     let cx = (this.width + this.strokeWidth) / 2;
  //     let cy = (this.height + this.strokeWidth) / 2;
  //     if (this.srcRect != null) {
  //         const { left = 0, top = 0, right = 0, bottom = 0 } = this.srcRect;
  //         cx = (this.width + left + right + this.strokeWidth) / 2;
  //         cy = (this.height + top + bottom + this.strokeWidth) / 2;
  //     }
  //     transform.rotate(-this.angle);
  //     transform.translate(cx, cy);
  //     transform.rotate(this.angle);
  //     transform.translate(-cx, -cy);
  //     return transform;
  // }
  calculateTransformWithSrcRect() {
    const {
      left: imageLeft,
      top: imageTop,
      width: imageWidth,
      height: imageHeight
    } = this;
    if (this.srcRect == null) {
      return {
        left: imageLeft,
        top: imageTop,
        width: imageWidth,
        height: imageHeight,
        angle: this.angle
      };
    }
    const { left = 0, top = 0, right = 0, bottom = 0 } = this.srcRect;
    const newLeft = imageLeft - left;
    const newTop = imageTop - top;
    const width = imageWidth + right + left;
    const height = imageHeight + bottom + top;
    return {
      left: newLeft,
      top: newTop,
      width,
      height,
      angle: this.angle
    };
  }
  _transformBySrcRect() {
    if (this.srcRect == null) {
      return;
    }
    const { left = 0, top = 0, right = 0, bottom = 0 } = this.srcRect;
    const {
      width: imageWidth,
      height: imageHeight
    } = this;
    let { left: newLeft, top: newTop, width, height } = this.calculateTransformWithSrcRect();
    if (this.angle !== 0) {
      const cx = (imageWidth + this.strokeWidth) / 2;
      const cy = (imageHeight + this.strokeWidth) / 2;
      const newCx = width / 2 - left;
      const newCy = height / 2 - top;
      const finalPoint = offsetRotationAxis(new Vector2(cx, cy), this.angle, new Vector2(newLeft, newTop), new Vector2(newCx, newCy));
      newLeft = finalPoint.x;
      newTop = finalPoint.y;
    }
    this.transformByState({
      left: newLeft,
      top: newTop,
      width,
      height
    });
  }
  render(mainCtx, bounds) {
    if (!this.visible) {
      this.makeDirty(false);
      return this;
    }
    if (this.isRender(bounds)) {
      const { top, left, bottom, right } = bounds.viewBound;
      if (this.width + this.strokeWidth + this.left < left || right < this.left || this.height + this.strokeWidth + this.top < top || bottom < this.top) {
        return this;
      }
    }
    const m = this.transform.getMatrix();
    mainCtx.save();
    mainCtx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    if (this.opacity !== 1) {
      mainCtx.globalAlpha = this.opacity;
    }
    this._draw(mainCtx);
    mainCtx.restore();
    this.makeDirty(false);
    return this;
  }
  _draw(ctx) {
    if (this._native == null) {
      return;
    }
    if (!this._renderByCropper && this.srcRect) {
      const { left = 0, top = 0, right = 0, bottom = 0 } = this.srcRect;
      ctx.beginPath();
      ctx.rect(0, 0, this.width, this.height);
      ctx.clip();
      ctx.drawImage(this._native, -left, -top, this.width + right + left, this.height + bottom + top);
    } else {
      ctx.drawImage(this._native, 0, 0, this.width, this.height);
    }
  }
  _init() {
    this.onTransformChange$.subscribeEvent((state) => {
      this._updateSrcRectByTransform(state);
    });
  }
  _updateSrcRectByTransform(state) {
    if (this.srcRect == null || !this._transformCalculateSrcRect) {
      return;
    }
    const { width, height, left, top, angle } = this;
    const { width: preWidth = 0, height: preHeight = 0, left: preLeft = 0, top: preTop = 0, angle: preAngle } = state.preValue;
    const { left: srcLeft = 0, top: srcTop = 0, right: srcRight = 0, bottom: srcBottom = 0 } = this.srcRect;
    let newLeft = srcLeft;
    let newTop = srcTop;
    let newRight = srcRight;
    let newBottom = srcBottom;
    let isChange = false;
    if (preWidth !== 0 && preWidth !== width) {
      const preLeftRatio = srcLeft / preWidth;
      const preRightRatio = srcRight / preWidth;
      newLeft = width * preLeftRatio;
      newRight = width * preRightRatio;
      isChange = true;
    }
    if (preHeight !== 0 && preHeight !== height) {
      const preTopRatio = srcTop / preHeight;
      const preBottomRatio = srcBottom / preHeight;
      newTop = height * preTopRatio;
      newBottom = height * preBottomRatio;
      isChange = true;
    }
    if (isChange) {
      this.setSrcRect({
        left: newLeft,
        top: newTop,
        right: newRight,
        bottom: newBottom
      });
    }
  }
};

// ../packages/engine-render/src/shape/path.ts
var PATH_OBJECT_ARRAY = ["dataArray"];
var Path3 = class _Path extends Shape {
  constructor(key, props) {
    super(key, props);
    __publicField(this, "_dataArray", []);
    __publicField(this, "_pathLength", 0);
    __publicField(this, "_selfRectCache", {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    });
    __publicField(this, "_reCalculateCache", true);
    if (props == null ? void 0 : props.data) {
      this._dataArray = _Path.parsePathData(props.data);
    } else if (props == null ? void 0 : props.dataArray) {
      this._dataArray = props.dataArray;
    }
    for (let i = 0; i < this.dataArray.length; ++i) {
      this._pathLength += this.dataArray[i].pathLength;
    }
    this._setFixBoundingBox();
    this.onTransformChange$.subscribeEvent((changeState) => {
      const { type: type2, preValue } = changeState;
      if (type2 === 1 /* resize */ || type2 === 5 /* all */) {
        this._reCalculateCache = true;
        const { left, top, width, height } = this._getSelfRect();
        const { width: preWidth, height: preHeight } = preValue;
        let fixX;
        let fixY;
        if (!preWidth) {
          fixX = 0;
        } else {
          fixX = this.width - preWidth;
        }
        if (!preHeight) {
          fixY = 0;
        } else {
          fixY = this.height - preHeight;
        }
        const increaseScaleX = fixX / width;
        const increaseScaleY = fixY / height;
        this.scaleX += increaseScaleX;
        this.scaleY += increaseScaleY;
        this.left = this.left - left * increaseScaleX;
        this.top = this.top - top * increaseScaleY;
        this._setTransForm();
      }
    });
  }
  get dataArray() {
    return this._dataArray;
  }
  static drawWith(ctx, props) {
    const ca = props.dataArray;
    if (!ca) {
      return;
    }
    ctx.beginPath();
    for (let n = 0; n < ca.length; n++) {
      const c = ca[n].command;
      const p = ca[n].points;
      switch (c) {
        case "L":
          ctx.lineTo(p[0], p[1]);
          break;
        case "M":
          ctx.moveTo(p[0], p[1]);
          break;
        case "C":
          ctx.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
          break;
        case "Q":
          ctx.quadraticCurveTo(p[0], p[1], p[2], p[3]);
          break;
        case "A": {
          const cx = p[0];
          const cy = p[1];
          const rx = p[2];
          const ry = p[3];
          const theta = p[4];
          const dTheta = p[5];
          const psi = p[6];
          const fs = p[7];
          const r = rx > ry ? rx : ry;
          const scaleX = rx > ry ? 1 : rx / ry;
          const scaleY = rx > ry ? ry / rx : 1;
          ctx.translate(cx, cy);
          ctx.rotate(psi);
          ctx.scale(scaleX, scaleY);
          ctx.arc(0, 0, r, theta, theta + dTheta, !!(1 - fs));
          ctx.scale(1 / scaleX, 1 / scaleY);
          ctx.rotate(-psi);
          ctx.translate(-cx, -cy);
          break;
        }
        case "z":
          ctx.closePath();
          break;
      }
    }
    this._renderPaintInOrder(ctx, props);
  }
  static getLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  static getPointOnLine(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
    if (fromX === void 0) {
      fromX = P1x;
    }
    if (fromY === void 0) {
      fromY = P1y;
    }
    const m = (P2y - P1y) / (P2x - P1x + 1e-8);
    let run = Math.sqrt(dist * dist / (1 + m * m));
    if (P2x < P1x) {
      run *= -1;
    }
    let rise = m * run;
    let pt;
    if (P2x === P1x) {
      pt = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - P1y) / (fromX - P1x + 1e-8) === m) {
      pt = {
        x: fromX + run,
        y: fromY + rise
      };
    } else {
      const len = this.getLineLength(P1x, P1y, P2x, P2y);
      let u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
      u /= len * len;
      const ix = P1x + u * (P2x - P1x);
      const iy = P1y + u * (P2y - P1y);
      const pRise = this.getLineLength(fromX, fromY, ix, iy);
      const pRun = Math.sqrt(dist * dist - pRise * pRise);
      run = Math.sqrt(pRun * pRun / (1 + m * m));
      if (P2x < P1x) {
        run *= -1;
      }
      rise = m * run;
      pt = {
        x: ix + run,
        y: iy + rise
      };
    }
    return pt;
  }
  static getPointOnCubicBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y, P4x, P4y) {
    function CB1(t2) {
      return t2 * t2 * t2;
    }
    function CB2(t2) {
      return 3 * t2 * t2 * (1 - t2);
    }
    function CB3(t2) {
      return 3 * t2 * (1 - t2) * (1 - t2);
    }
    function CB4(t2) {
      return (1 - t2) * (1 - t2) * (1 - t2);
    }
    const x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
    const y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);
    return {
      x,
      y
    };
  }
  static getPointOnQuadraticBezier(pct, P1x, P1y, P2x, P2y, P3x, P3y) {
    function QB1(t2) {
      return t2 * t2;
    }
    function QB2(t2) {
      return 2 * t2 * (1 - t2);
    }
    function QB3(t2) {
      return (1 - t2) * (1 - t2);
    }
    const x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
    const y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);
    return {
      x,
      y
    };
  }
  static getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
    const cosPsi = Math.cos(psi);
    const sinPsi = Math.sin(psi);
    const pt = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt.x * cosPsi - pt.y * sinPsi),
      y: cy + (pt.x * sinPsi + pt.y * cosPsi)
    };
  }
  /*
   * get parsed data array from the data
   *  string.  V, v, H, h, and l data are converted to
   *  L data for the purpose of high performance Path
   *  rendering
   */
  // eslint-disable-next-line max-lines-per-function, complexity
  static parsePathData(data2) {
    if (!data2) {
      return [];
    }
    let cs = data2;
    const cc = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"];
    cs = cs.replace(new RegExp(" ", "g"), ",");
    for (let n = 0, len = cc.length; n < len; n++) {
      cs = cs.replace(new RegExp(cc[n], "g"), `|${cc[n]}`);
    }
    const arr = cs.split("|");
    const ca = [];
    const coords = [];
    let cpx = 0;
    let cpy = 0;
    const re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
    let match;
    for (let n = 1, len = arr.length; n < len; n++) {
      let str = arr[n];
      let c = str.charAt(0);
      str = str.slice(1);
      coords.length = 0;
      while (match = re.exec(str)) {
        coords.push(match[0]);
      }
      const p = [];
      for (let j = 0, jLen = coords.length; j < jLen; j++) {
        if (coords[j] === "00") {
          p.push(0, 0);
          continue;
        }
        const parsed = Number.parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          p.push(parsed);
        } else {
          p.push(0);
        }
      }
      while (p.length > 0) {
        if (isNaN(p[0])) {
          break;
        }
        let cmd;
        let points = [];
        const startX = cpx;
        const startY = cpy;
        let prevCmd;
        let ctlPtx;
        let ctlPty;
        let rx;
        let ry;
        let psi;
        let fa;
        let fs;
        let x1;
        let y1;
        switch (c) {
          // Note: Keep the lineTo's above the moveTo's in this switch
          case "l":
            cpx += p.shift() || 0;
            cpy += p.shift() || 0;
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "L":
            cpx = p.shift() || 0;
            cpy = p.shift() || 0;
            points.push(cpx, cpy);
            break;
          // Note: lineTo handlers need to be above this point
          case "m": {
            const dx = p.shift() || 0;
            const dy = p.shift() || 0;
            cpx += dx;
            cpy += dy;
            cmd = "M";
            if (ca.length > 2 && ca[ca.length - 1].command === "z") {
              for (let idx = ca.length - 2; idx >= 0; idx--) {
                if (ca[idx].command === "M") {
                  cpx = ca[idx].points[0] + dx;
                  cpy = ca[idx].points[1] + dy;
                  break;
                }
              }
            }
            points.push(cpx, cpy);
            c = "l";
            break;
          }
          case "M":
            cpx = p.shift() || 0;
            cpy = p.shift() || 0;
            cmd = "M";
            points.push(cpx, cpy);
            c = "L";
            break;
          case "h":
            cpx += p.shift() || 0;
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "H":
            cpx = p.shift() || 0;
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "v":
            cpy += p.shift() || 0;
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "V":
            cpy = p.shift() || 0;
            cmd = "L";
            points.push(cpx, cpy);
            break;
          case "C":
            points.push(p.shift() || 0, p.shift() || 0, p.shift() || 0, p.shift() || 0);
            cpx = p.shift() || 0;
            cpy = p.shift() || 0;
            points.push(cpx, cpy);
            break;
          case "c":
            points.push(
              cpx + (p.shift() || 0),
              cpy + (p.shift() || 0),
              cpx + (p.shift() || 0),
              cpy + (p.shift() || 0)
            );
            cpx += p.shift() || 0;
            cpy += p.shift() || 0;
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "S":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "C") {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, p.shift() || 0, p.shift() || 0);
            cpx = p.shift() || 0;
            cpy = p.shift() || 0;
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "s":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "C") {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, cpx + (p.shift() || 0), cpy + (p.shift() || 0));
            cpx += p.shift() || 0;
            cpy += p.shift() || 0;
            cmd = "C";
            points.push(cpx, cpy);
            break;
          case "Q":
            points.push(p.shift() || 0, p.shift() || 0);
            cpx = p.shift() || 0;
            cpy = p.shift() || 0;
            points.push(cpx, cpy);
            break;
          case "q":
            points.push(cpx + (p.shift() || 0), cpy + (p.shift() || 0));
            cpx += p.shift() || 0;
            cpy += p.shift() || 0;
            cmd = "Q";
            points.push(cpx, cpy);
            break;
          case "T":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "Q") {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx = p.shift() || 0;
            cpy = p.shift() || 0;
            cmd = "Q";
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case "t":
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === "Q") {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx += p.shift() || 0;
            cpy += p.shift() || 0;
            cmd = "Q";
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case "A":
            rx = p.shift() || 0;
            ry = p.shift() || 0;
            psi = p.shift() || 0;
            fa = p.shift() || 0;
            fs = p.shift() || 0;
            x1 = cpx;
            y1 = cpy;
            cpx = p.shift() || 0;
            cpy = p.shift() || 0;
            cmd = "A";
            points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
            break;
          case "a":
            rx = p.shift() || 0;
            ry = p.shift() || 0;
            psi = p.shift() || 0;
            fa = p.shift() || 0;
            fs = p.shift() || 0;
            x1 = cpx;
            y1 = cpy;
            cpx += p.shift() || 0;
            cpy += p.shift() || 0;
            cmd = "A";
            points = this.convertEndpointToCenterParameterization(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
            break;
        }
        ca.push({
          command: cmd || c,
          points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, cmd || c, points)
        });
      }
      if (c === "z" || c === "Z") {
        ca.push({
          command: "z",
          points: [],
          start: {
            x: 0,
            y: 0
          },
          pathLength: 0
        });
      }
    }
    return ca;
  }
  static calcLength(x, y, cmd, points) {
    let len;
    let p1;
    let p2;
    let t2;
    const path = _Path;
    switch (cmd) {
      case "L":
        return path.getLineLength(x, y, points[0], points[1]);
      case "C":
        len = 0;
        p1 = path.getPointOnCubicBezier(
          0,
          x,
          y,
          points[0],
          points[1],
          points[2],
          points[3],
          points[4],
          points[5]
        );
        for (t2 = 0.01; t2 <= 1; t2 += 0.01) {
          p2 = path.getPointOnCubicBezier(
            t2,
            x,
            y,
            points[0],
            points[1],
            points[2],
            points[3],
            points[4],
            points[5]
          );
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case "Q":
        len = 0;
        p1 = path.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);
        for (t2 = 0.01; t2 <= 1; t2 += 0.01) {
          p2 = path.getPointOnQuadraticBezier(t2, x, y, points[0], points[1], points[2], points[3]);
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case "A": {
        len = 0;
        const start = points[4];
        const dTheta = points[5];
        const end = points[4] + dTheta;
        let inc = Math.PI / 180;
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        p1 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
        if (dTheta < 0) {
          for (t2 = start - inc; t2 > end; t2 -= inc) {
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        } else {
          for (t2 = start + inc; t2 < end; t2 += inc) {
            p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        }
        p2 = path.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
        return len;
      }
    }
    return 0;
  }
  static convertEndpointToCenterParameterization(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
    const psi = psiDeg * (Math.PI / 180);
    const xp = Math.cos(psi) * (x1 - x2) / 2 + Math.sin(psi) * (y1 - y2) / 2;
    const yp = -1 * Math.sin(psi) * (x1 - x2) / 2 + Math.cos(psi) * (y1 - y2) / 2;
    const lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    let f = Math.sqrt(
      (rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))
    );
    if (fa === fs) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    const cxp = f * rx * yp / ry;
    const cyp = f * -ry * xp / rx;
    const cx = (x1 + x2) / 2 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
    const cy = (y1 + y2) / 2 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
    const vMag = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
    const vRatio = (u2, v2) => (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2));
    const vAngle = (u2, v2) => (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
    const theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    const u = [(xp - cxp) / rx, (yp - cyp) / ry];
    const v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    let dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
      dTheta -= 2 * Math.PI;
    }
    if (fs === 1 && dTheta < 0) {
      dTheta += 2 * Math.PI;
    }
    return [cx, cy, rx, ry, theta, dTheta, psi, fs];
  }
  toJson() {
    const props = {};
    PATH_OBJECT_ARRAY.forEach((key) => {
      if (this[key]) {
        props[key] = this[key];
      }
    });
    return {
      ...super.toJson(),
      ...props
    };
  }
  getState() {
    const { left, top, width, height } = this.getRect();
    return {
      left,
      top,
      width,
      height,
      scaleX: this.scaleX,
      scaleY: this.scaleY,
      angle: this.angle,
      skewX: this.skewX,
      skewY: this.skewY,
      flipX: this.flipX,
      flipY: this.flipY
    };
  }
  getRect() {
    const { left, top, width, height } = this._getSelfRect();
    return {
      left: left * this.scaleX + this.left,
      top: top * this.scaleY + this.top,
      width: width * this.scaleX,
      height: height * this.scaleY
    };
  }
  /**
   * Return length of the path.
   * @method
   * @returns {number} length
   * @example
   * var length = path.getLength();
   */
  getLength() {
    return this._pathLength;
  }
  /**
   * Get point on path at specific length of the path
   * @method
   * @param {number} length length
   * @returns {object} point {x,y} point
   * @example
   * var point = path.getPointAtLength(10);
   */
  getPointAtLength(length) {
    let point;
    let i = 0;
    const ii = this.dataArray.length;
    if (!ii) {
      return null;
    }
    while (i < ii && length > this.dataArray[i].pathLength) {
      length -= this.dataArray[i].pathLength;
      ++i;
    }
    if (i === ii) {
      point = this.dataArray[i - 1].points.slice(-2);
      return {
        x: point[0],
        y: point[1]
      };
    }
    if (length < 0.01) {
      point = this.dataArray[i].points.slice(0, 2);
      return {
        x: point[0],
        y: point[1]
      };
    }
    const cp = this.dataArray[i];
    const p = cp.points;
    switch (cp.command) {
      case "L":
        return _Path.getPointOnLine(length, cp.start.x, cp.start.y, p[0], p[1]);
      case "C":
        return _Path.getPointOnCubicBezier(
          length / cp.pathLength,
          cp.start.x,
          cp.start.y,
          p[0],
          p[1],
          p[2],
          p[3],
          p[4],
          p[5]
        );
      case "Q":
        return _Path.getPointOnQuadraticBezier(
          length / cp.pathLength,
          cp.start.x,
          cp.start.y,
          p[0],
          p[1],
          p[2],
          p[3]
        );
      case "A": {
        const cx = p[0];
        const cy = p[1];
        const rx = p[2];
        const ry = p[3];
        let theta = p[4];
        const dTheta = p[5];
        const psi = p[6];
        theta += dTheta * length / cp.pathLength;
        return _Path.getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi);
      }
    }
    return null;
  }
  _draw(ctx) {
    _Path.drawWith(ctx, this);
  }
  _setFixBoundingBox() {
    const { left, top, width, height } = this._getSelfRect();
    const fixScaleX = this.width / width;
    const fixScaleY = this.height / height;
    this.left = this.left - left * fixScaleX;
    this.top = this.top - top * fixScaleY;
    this.scaleX = fixScaleX;
    this.scaleY = fixScaleY;
    this.width = width;
    this.height = height;
    this._setTransForm();
  }
  _getSelfRect() {
    if (!this._reCalculateCache) {
      return this._selfRectCache;
    }
    let points = [];
    this.dataArray.forEach((data2) => {
      if (data2.command === "A") {
        const start = data2.points[4];
        const dTheta = data2.points[5];
        const end = data2.points[4] + dTheta;
        let inc = Math.PI / 180;
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        if (dTheta < 0) {
          for (let t2 = start - inc; t2 > end; t2 -= inc) {
            const point = _Path.getPointOnEllipticalArc(
              data2.points[0],
              data2.points[1],
              data2.points[2],
              data2.points[3],
              t2,
              0
            );
            points.push(point.x, point.y);
          }
        } else {
          for (let t2 = start + inc; t2 < end; t2 += inc) {
            const point = _Path.getPointOnEllipticalArc(
              data2.points[0],
              data2.points[1],
              data2.points[2],
              data2.points[3],
              t2,
              0
            );
            points.push(point.x, point.y);
          }
        }
      } else if (data2.command === "C") {
        for (let t2 = 0; t2 <= 1; t2 += 0.01) {
          const point = _Path.getPointOnCubicBezier(
            t2,
            data2.start.x,
            data2.start.y,
            data2.points[0],
            data2.points[1],
            data2.points[2],
            data2.points[3],
            data2.points[4],
            data2.points[5]
          );
          points.push(point.x, point.y);
        }
      } else {
        points = points.concat(data2.points);
      }
    });
    let minX = points[0];
    let maxX = points[0];
    let minY = points[1];
    let maxY = points[1];
    let x;
    let y;
    for (let i = 0; i < points.length / 2; i++) {
      x = points[i * 2];
      y = points[i * 2 + 1];
      if (!isNaN(x)) {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
      }
      if (!isNaN(y)) {
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }
    const cache = {
      left: minX,
      top: minY,
      width: maxX - minX,
      height: maxY - minY
    };
    this._selfRectCache = cache;
    return cache;
  }
};

// ../packages/engine-render/src/shape/rich-text.ts
var RICHTEXT_OBJECT_ARRAY = ["text", "richText", "fs"];
var RichText = class extends BaseObject {
  constructor(_localeService, key, props) {
    super(key);
    this._localeService = _localeService;
    __publicField(this, "_documentData");
    __publicField(this, "_documentSkeleton");
    __publicField(this, "_documents");
    __publicField(this, "documentModel");
    /**
     * fontFamily
     */
    __publicField(this, "_ff");
    /**
     * fontSize
     * pt
     */
    __publicField(this, "_fs", 12);
    /**
     * italic
     * 0: false
     * 1: true
     */
    __publicField(this, "_it", 0 /* FALSE */);
    /**
     * bold
     * 0: false
     * 1: true
     */
    __publicField(this, "_bl", 0 /* FALSE */);
    /**
     * underline
     */
    __publicField(this, "_ul", {
      s: 0 /* FALSE */
    });
    /**
     * strikethrough
     */
    __publicField(this, "_st", {
      s: 0 /* FALSE */
    });
    /**
     * overline
     */
    __publicField(this, "_ol", {
      s: 0 /* FALSE */
    });
    /**
     * background
     */
    __publicField(this, "_bg");
    /**
     * border
     */
    __publicField(this, "_bd");
    /**
     * foreground
     */
    __publicField(this, "_cl");
    __publicField(this, "objectType", 1 /* RICH_TEXT */);
    if (props == null ? void 0 : props.richText) {
      this._documentData = props.richText;
    } else if (props) {
      this._fs = props.fs;
      this._ff = props.ff;
      this._it = props.it;
      this._bl = props.bl;
      this._ul = props.ul;
      this._st = props.st;
      this._ol = props.ol;
      this._bg = props.bg;
      this._bd = props.bd;
      this._cl = props.cl;
      this._documentData = this._convertToDocumentData(props.text || "");
    }
    const docModel = this.documentModel = new DocumentDataModel(this._documentData);
    const docViewModel = new DocumentViewModel(docModel);
    this._documentSkeleton = DocumentSkeleton.create(docViewModel, this._localeService);
    this._documents = new Documents(`${this.oKey}_DOCUMENTS`, this._documentSkeleton, {
      pageMarginLeft: 0,
      pageMarginTop: 0
    });
    this._initialProps(props);
    this.onTransformChange$.subscribeEvent((changeState) => {
      const { type: type2 } = changeState;
      if (type2 === 1 /* resize */ || type2 === 5 /* all */) {
        docModel.updateDocumentDataPageSize(this.width);
        this._documentSkeleton.makeDirty(true);
        this._documentSkeleton.calculate();
        const size = this.getDocsSkeletonPageSize();
        this.height = (size == null ? void 0 : size.height) || this.height;
        this._setTransForm();
        this.refreshDocumentByDocData();
      }
    });
  }
  get fs() {
    return this._fs;
  }
  get text() {
    const textBody = this._documentData.body;
    if (!textBody) return "";
    const texts = [];
    if (textBody.textRuns) {
      for (const run of textBody.textRuns) {
        const st = run.st || 0;
        const ed = run.ed || 0;
        texts.push(textBody.dataStream.slice(st, ed));
      }
    }
    return texts.join("");
  }
  get documentData() {
    return this._documentData;
  }
  /**
   * get last page size
   */
  getDocsSkeletonPageSize() {
    var _a;
    const skeletonData = (_a = this._documentSkeleton) == null ? void 0 : _a.getSkeletonData();
    if (!skeletonData) {
      return;
    }
    const { pages } = skeletonData;
    const lastPage = pages[pages.length - 1];
    const { width, height } = lastPage;
    return { width, height };
  }
  /**
   * this[`_${key}`] = props[key];
   * @param props
   */
  setProps(props) {
    if (!props) {
      return;
    }
    const themeKeys = Object.keys(props);
    if (themeKeys.length === 0) {
      return;
    }
    themeKeys.forEach((key) => {
      if (props[key] === void 0) {
        return true;
      }
      if (RICHTEXT_OBJECT_ARRAY.indexOf(key) === -1) {
        this[`_${key}`] = props[key];
      }
    });
    this.makeDirty(true);
    return this;
  }
  render(mainCtx, bounds) {
    if (!this.visible) {
      this.makeDirty(false);
      return this;
    }
    if (this.isRender(bounds)) {
      const { top, left, bottom, right } = bounds.viewBound;
      if (this.width + this.strokeWidth < left || right < 0 || this.height + this.strokeWidth < top || bottom < 0) {
        return this;
      }
    }
    const m = this.transform.getMatrix();
    mainCtx.save();
    mainCtx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    this._draw(mainCtx);
    mainCtx.restore();
    this.makeDirty(false);
    return this;
  }
  toJson() {
    const props = {};
    RICHTEXT_OBJECT_ARRAY.forEach((key) => {
      if (this[key]) {
        props[key] = this[key];
      }
    });
    return {
      ...super.toJson(),
      ...props
    };
  }
  _draw(ctx) {
    this._documents.render(ctx);
  }
  _convertToDocumentData(text) {
    const contentLength = text.length;
    const documentData = {
      id: "d",
      body: {
        dataStream: `${text}${DEFAULT_EMPTY_DOCUMENT_VALUE}`,
        textRuns: [
          {
            ts: {
              fs: this._fs || 14,
              ff: this._ff,
              it: this._it,
              bl: this._bl,
              ul: this._ul,
              st: this._st,
              ol: this._ol,
              bg: this._bg,
              bd: this._bd,
              cl: this._cl
            },
            st: 0,
            ed: contentLength
          }
        ]
      },
      documentStyle: {
        pageSize: {
          width: Number.POSITIVE_INFINITY,
          height: Number.POSITIVE_INFINITY
        }
      }
    };
    return documentData;
  }
  _initialProps(props) {
    this._documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(props == null ? void 0 : props.width, props == null ? void 0 : props.height);
    this._documentSkeleton.calculate();
    const contentSize = this.getDocsSkeletonPageSize();
    this.transformByState({
      width: (contentSize == null ? void 0 : contentSize.width) || 0,
      height: (contentSize == null ? void 0 : contentSize.height) || 0,
      left: (props == null ? void 0 : props.left) || 0,
      top: (props == null ? void 0 : props.top) || 0,
      angle: props == null ? void 0 : props.angle
    });
    this.setProps(props);
    this.makeDirty(true);
  }
  /**
   * After changing editor size & end of editing, update skeleton of doc.
   */
  // TODO: This method should be invoked when _documentData changed.
  // _documentData changed ---> update _documentSkeleton & _documentSkeleton
  // now it is invoked when transformByState(change editor size) & end of editing
  refreshDocumentByDocData() {
    const docModel = this.documentModel = new DocumentDataModel(this._documentData);
    const docViewModel = new DocumentViewModel(docModel);
    this._documentSkeleton = DocumentSkeleton.create(docViewModel, this._localeService);
    this._documents = new Documents(`${this.oKey}_DOCUMENTS`, this._documentSkeleton, {
      pageMarginLeft: 0,
      pageMarginTop: 0
    });
    this._documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(this.width, Infinity);
    this._documentSkeleton.calculate();
  }
  /**
   * invoked when end editing.
   */
  resizeToContentSize() {
    const contentSize = this.getDocsSkeletonPageSize();
    if (contentSize && contentSize.width !== 0 && contentSize.height !== 0) {
      this.transformByState({
        // width: contentSize?.width || 0,
        height: (contentSize == null ? void 0 : contentSize.height) || 0
      });
    }
  }
};

// ../packages/engine-render/src/shape/scroll-bar.ts
var MIN_THUMB_SIZE = 17;
var DEFAULT_TRACK_SIZE = 10;
var HOVER_TRACK_SIZE = 10;
var DEFAULT_THUMB_MARGIN = 2;
var HOVER_THUMB_MARGIN = 1;
var ScrollBar = class _ScrollBar extends Disposable {
  constructor(view, props) {
    super();
    __publicField(this, "_enableHorizontal", true);
    __publicField(this, "_enableVertical", true);
    __publicField(this, "horizontalThumbSize", 0);
    __publicField(this, "horizontalMinusMiniThumb", 0);
    __publicField(this, "horizontalTrackWidth", 0);
    __publicField(this, "horizonScrollTrack");
    __publicField(this, "horizonThumbRect");
    __publicField(this, "verticalThumbSize", 0);
    __publicField(this, "verticalTrackHeight", 0);
    __publicField(this, "verticalMinusMiniThumb", 0);
    __publicField(this, "verticalScrollTrack");
    __publicField(this, "verticalThumbRect");
    __publicField(this, "placeholderBarRect");
    __publicField(this, "_viewport");
    __publicField(this, "_mainScene");
    __publicField(this, "_lastX", -1);
    __publicField(this, "_lastY", -1);
    __publicField(this, "_isHorizonMove", false);
    __publicField(this, "_isVerticalMove", false);
    __publicField(this, "_horizonPointerMoveSub");
    __publicField(this, "_horizonPointerUpSub");
    __publicField(this, "_verticalPointerMoveSub");
    __publicField(this, "_verticalPointerUpSub");
    __publicField(this, "_thumbDefaultBackgroundColor", "rgba(24, 28, 42, 0.20)");
    __publicField(this, "_thumbHoverBackgroundColor", "rgba(24, 28, 42, 0.30)");
    __publicField(this, "_thumbActiveBackgroundColor", "rgba(24, 28, 42, 0.40)");
    __publicField(this, "_trackBackgroundColor", "rgba(255,255,255,0.5)");
    __publicField(this, "_trackBorderColor", "rgba(255,255,255,0.7)");
    /**
     * The thickness of a scrolling track
     * ThumbSize = trackSize - thumbMargin * 2
     */
    __publicField(this, "_trackThickness", DEFAULT_TRACK_SIZE);
    // private _hTrackThickness: number = DEFAULT_TRACK_SIZE;
    // private _vTrackThickness: number = DEFAULT_TRACK_SIZE;
    /**
     * The margin between thumb and bar.
     * ThumbSize = barSize - thumbMargin * 2
     */
    // private _thumbMargin = DEFAULT_THUMB_MARGIN;
    __publicField(this, "_vThumbMargin", DEFAULT_THUMB_MARGIN);
    __publicField(this, "_hThumbMargin", DEFAULT_THUMB_MARGIN);
    // origin: barBorder
    __publicField(this, "_trackBorderThickness", 1);
    __publicField(this, "_thumbLengthRatio", 1);
    /**
     * The min width of horizon thumb, Corresponds to minThumbSizeH in props
     */
    __publicField(this, "_minThumbSizeH", MIN_THUMB_SIZE);
    /**
     * The min height of vertical thumb,  Corresponds to minThumbSizeV in props
     */
    __publicField(this, "_minThumbSizeV", MIN_THUMB_SIZE);
    __publicField(this, "_eventSub", new Subscription());
    __publicField(this, "_viewportH", 0);
    __publicField(this, "_viewportW", 0);
    __publicField(this, "_contentW", 0);
    __publicField(this, "_contentH", 0);
    if (!view) {
      console.warn("Missing viewport");
    }
    this.setProps(props);
    this._viewport = view;
    this._initialScrollRect();
    this._initialVerticalEvent();
    this._initialHorizontalEvent();
    this._viewport.setScrollBar(this);
  }
  setProps(props) {
    if (!props) {
      return;
    }
    const themeKeys = Object.keys(props);
    if (themeKeys.length === 0) {
      return;
    }
    themeKeys.forEach((key) => {
      if (props[key] !== void 0) {
        this[`_${key}`] = props[key];
      }
    });
    if (Tools.isDefine(props.barSize)) {
      this._trackThickness = props.barSize;
    }
    if (Tools.isDefine(props.barBorder)) {
      this._trackBorderThickness = props.barBorder;
    }
    if (Tools.isDefine(props.thumbMargin)) {
      this._hThumbMargin = props.thumbMargin;
      this._vThumbMargin = props.thumbMargin;
    }
  }
  get enableHorizontal() {
    return this._enableHorizontal;
  }
  set enableHorizontal(val) {
    this._enableHorizontal = val;
  }
  get enableVertical() {
    return this._enableVertical;
  }
  set enableVertical(val) {
    this._enableVertical = val;
  }
  get limitX() {
    var _a;
    if (!((_a = this.horizonThumbRect) == null ? void 0 : _a.visible)) {
      return 0;
    }
    return this.horizontalTrackWidth - this.horizontalThumbSize;
  }
  get limitY() {
    var _a;
    if (!((_a = this.verticalThumbRect) == null ? void 0 : _a.visible)) {
      return 0;
    }
    return this.verticalTrackHeight - this.verticalThumbSize;
  }
  get ratioScrollX() {
    if (this._enableHorizontal === false || this.horizontalThumbSize === void 0 || this.horizontalTrackWidth === void 0) {
      return 1;
    }
    const ratio = (this.horizontalThumbSize - this.horizontalMinusMiniThumb) * this.miniThumbRatioX / this.horizontalTrackWidth;
    if (Number.isNaN(ratio)) {
      return 1;
    } else {
      return ratio;
    }
  }
  get ratioScrollY() {
    if (this._enableVertical === false || this.verticalThumbSize === void 0 || this.verticalTrackHeight === void 0) {
      return 1;
    }
    const ratio = (this.verticalThumbSize - this.verticalMinusMiniThumb) * this.miniThumbRatioY / this.verticalTrackHeight;
    if (Number.isNaN(ratio)) {
      return 1;
    } else {
      return ratio;
    }
  }
  get miniThumbRatioX() {
    const limit = this.horizontalTrackWidth - this.horizontalThumbSize;
    if (limit === 0) {
      return 0;
    }
    const actual = this.horizontalTrackWidth - (this.horizontalThumbSize - this.horizontalMinusMiniThumb);
    if (actual === 0) {
      return 0;
    }
    return limit / actual;
  }
  get miniThumbRatioY() {
    const limit = this.verticalTrackHeight - this.verticalThumbSize;
    if (limit === 0) {
      return 0;
    }
    const actual = this.verticalTrackHeight - (this.verticalThumbSize - this.verticalMinusMiniThumb);
    if (actual === 0) {
      return 0;
    }
    return limit / actual;
  }
  hasHorizonThumb() {
    var _a;
    return ((_a = this.horizonThumbRect) == null ? void 0 : _a.visible) || false;
  }
  hasVerticalThumb() {
    var _a;
    return ((_a = this.verticalThumbRect) == null ? void 0 : _a.visible) || false;
  }
  get scrollHorizonThumbThickness() {
    return Math.max(0, this._trackThickness - this._hThumbMargin * 2);
  }
  get scrollVerticalThumbThickness() {
    return Math.max(0, this._trackThickness - this._vThumbMargin * 2);
  }
  set barSize(v) {
    this._trackThickness = v;
  }
  get barSize() {
    return this._trackThickness;
  }
  set trackThickness(v) {
    this._trackThickness = v;
  }
  get trackThickness() {
    return this._trackThickness;
  }
  static attachTo(view, props) {
    return new _ScrollBar(view, props);
  }
  dispose() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    super.dispose();
    (_a = this.horizonScrollTrack) == null ? void 0 : _a.dispose();
    (_b = this.horizonThumbRect) == null ? void 0 : _b.dispose();
    (_c = this.verticalScrollTrack) == null ? void 0 : _c.dispose();
    (_d = this.verticalThumbRect) == null ? void 0 : _d.dispose();
    (_e = this.placeholderBarRect) == null ? void 0 : _e.dispose();
    this.horizonScrollTrack = null;
    this.horizonThumbRect = null;
    this.verticalScrollTrack = null;
    this.verticalThumbRect = null;
    this.placeholderBarRect = null;
    (_f = this._horizonPointerMoveSub) == null ? void 0 : _f.unsubscribe();
    (_g = this._horizonPointerUpSub) == null ? void 0 : _g.unsubscribe();
    (_h = this._verticalPointerMoveSub) == null ? void 0 : _h.unsubscribe();
    (_i = this._verticalPointerUpSub) == null ? void 0 : _i.unsubscribe();
    this._eventSub.unsubscribe();
    this._mainScene = null;
    this._viewport.removeScrollBar();
  }
  render(ctx, left = 0, top = 0) {
    const { scrollX, scrollY } = this._viewport;
    ctx.save();
    const transform = new Transform([1, 0, 0, 1, left, top]);
    const m = transform.getMatrix();
    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    if (this._enableHorizontal) {
      this.horizonScrollTrack.render(ctx);
      this.horizonThumbRect.translate(scrollX).render(ctx);
    }
    if (this._enableVertical) {
      this.verticalScrollTrack.render(ctx);
      this.verticalThumbRect.translate(void 0, scrollY).render(ctx);
    }
    if (this._enableHorizontal && this._enableVertical) {
      this.placeholderBarRect.render(ctx);
    }
    ctx.restore();
  }
  _resizeHorizontal() {
    var _a, _b, _c, _d, _e;
    const viewportH = this._viewportH;
    const viewportW = this._viewportW;
    const contentWidth = this._contentW;
    if (!this._enableHorizontal) {
      return;
    }
    this.horizontalMinusMiniThumb = 0;
    this.horizontalTrackWidth = viewportW - (this._enableVertical ? this._trackThickness : 0) - this._trackBorderThickness;
    this.horizontalThumbSize = this.horizontalTrackWidth * (this.horizontalTrackWidth - this._trackBorderThickness) / contentWidth * this._thumbLengthRatio;
    if (this.horizontalThumbSize < this._minThumbSizeH) {
      this.horizontalMinusMiniThumb = this._minThumbSizeH - this.horizontalThumbSize;
      this.horizontalThumbSize = this._minThumbSizeH;
    }
    (_a = this.horizonScrollTrack) == null ? void 0 : _a.transformByState({
      left: 0,
      top: viewportH - this._trackThickness,
      width: this.horizontalTrackWidth,
      height: Math.max(0, this._trackThickness - this._trackBorderThickness)
    });
    if (this.horizontalThumbSize >= viewportW - (this._trackThickness + 2)) {
      (_b = this.horizonThumbRect) == null ? void 0 : _b.setProps({
        visible: false
      });
    } else {
      if (!((_c = this.horizonThumbRect) == null ? void 0 : _c.visible)) {
        (_d = this.horizonThumbRect) == null ? void 0 : _d.setProps({
          visible: true
        });
      }
      (_e = this.horizonThumbRect) == null ? void 0 : _e.transformByState({
        left: this._viewport.scrollX,
        top: viewportH - this._trackThickness + this._hThumbMargin,
        width: this.horizontalThumbSize,
        height: this.scrollHorizonThumbThickness
      });
    }
  }
  _resizeVertical() {
    var _a, _b, _c, _d, _e;
    const viewportH = this._viewportH;
    const viewportW = this._viewportW;
    const contentHeight = this._contentH;
    if (!this._enableVertical) {
      return;
    }
    this.verticalMinusMiniThumb = 0;
    this.verticalTrackHeight = viewportH - (this._enableHorizontal ? this._trackThickness : 0) - this._trackBorderThickness;
    this.verticalThumbSize = this.verticalTrackHeight * this.verticalTrackHeight / contentHeight * this._thumbLengthRatio;
    if (this.verticalThumbSize < this._minThumbSizeV) {
      this.verticalMinusMiniThumb = this._minThumbSizeV - this.verticalThumbSize;
      this.verticalThumbSize = this._minThumbSizeV;
    }
    (_a = this.verticalScrollTrack) == null ? void 0 : _a.transformByState({
      left: viewportW - this._trackThickness,
      top: 0,
      width: Math.max(0, this._trackThickness - this._trackBorderThickness),
      height: this.verticalTrackHeight
    });
    if (this.verticalThumbSize >= viewportH - this._trackThickness) {
      (_b = this.verticalThumbRect) == null ? void 0 : _b.setProps({
        visible: false
      });
    } else {
      if (!((_c = this.verticalThumbRect) == null ? void 0 : _c.visible)) {
        (_d = this.verticalThumbRect) == null ? void 0 : _d.setProps({
          visible: true
        });
      }
      (_e = this.verticalThumbRect) == null ? void 0 : _e.transformByState({
        left: viewportW - this._trackThickness + this._vThumbMargin,
        top: this._viewport.scrollY,
        width: this.scrollVerticalThumbThickness,
        height: this.verticalThumbSize
      });
    }
  }
  _resizeRightBottomCorner() {
    var _a;
    const viewportH = this._viewportH;
    const viewportW = this._viewportW;
    if (this._enableHorizontal && this._enableVertical) {
      (_a = this.placeholderBarRect) == null ? void 0 : _a.transformByState({
        left: viewportW - this._trackThickness,
        top: viewportH - this._trackThickness,
        width: Math.max(0, this._trackThickness - this._trackBorderThickness),
        height: Math.max(0, this._trackThickness - this._trackBorderThickness)
      });
    }
  }
  /**
   * Adjust scroll track & thumb size based on the viewport size.
   * @param viewportWidth
   * @param viewportHeight
   * @param contentWidth
   * @param contentHeight
   */
  resize(viewportWidth = 0, viewportHeight = 0, contentWidth = 0, contentHeight = 0) {
    if (viewportWidth === 0 && viewportWidth === 0) {
      return;
    }
    this._viewportH = viewportHeight;
    this._viewportW = viewportWidth;
    this._contentW = contentWidth;
    this._contentH = contentHeight;
    this._resizeHorizontal();
    this._resizeVertical();
    this._resizeRightBottomCorner();
  }
  makeDirty(state) {
    var _a, _b, _c, _d, _e;
    (_a = this.horizonScrollTrack) == null ? void 0 : _a.makeDirty(state);
    (_b = this.horizonThumbRect) == null ? void 0 : _b.makeDirty(state);
    (_c = this.verticalScrollTrack) == null ? void 0 : _c.makeDirty(state);
    (_d = this.verticalThumbRect) == null ? void 0 : _d.makeDirty(state);
    (_e = this.placeholderBarRect) == null ? void 0 : _e.makeDirty(state);
    this.makeViewDirty(state);
  }
  makeViewDirty(state) {
    const mainScene = this._mainScene || this._viewport.scene;
    mainScene.makeDirty(state);
  }
  pick(coord) {
    var _a, _b, _c, _d;
    if ((_a = this.horizonThumbRect) == null ? void 0 : _a.isHit(coord)) {
      return this.horizonThumbRect;
    }
    if ((_b = this.verticalThumbRect) == null ? void 0 : _b.isHit(coord)) {
      return this.verticalThumbRect;
    }
    if ((_c = this.horizonScrollTrack) == null ? void 0 : _c.isHit(coord)) {
      return this.horizonScrollTrack;
    }
    if ((_d = this.verticalScrollTrack) == null ? void 0 : _d.isHit(coord)) {
      return this.verticalScrollTrack;
    }
    return null;
  }
  _initialScrollRect() {
    if (this._enableHorizontal) {
      this.horizonScrollTrack = new Rect("__horizonBarRect__", {
        fill: this._trackBackgroundColor,
        strokeWidth: this._trackBorderThickness,
        stroke: this._trackBorderColor
      });
      this.horizonThumbRect = new Rect("__horizonThumbRect__", {
        radius: 6,
        fill: this._thumbDefaultBackgroundColor
      });
    }
    if (this._enableVertical) {
      this.verticalScrollTrack = new Rect("__verticalBarRect__", {
        fill: this._trackBackgroundColor,
        strokeWidth: this._trackBorderThickness,
        stroke: this._trackBorderColor
      });
      this.verticalThumbRect = new Rect("__verticalThumbRect__", {
        radius: 6,
        fill: this._thumbDefaultBackgroundColor
      });
    }
    if (this._enableHorizontal && this._enableVertical) {
      this.placeholderBarRect = new Rect("__placeholderBarRect__", {
        fill: this._trackBackgroundColor,
        strokeWidth: this._trackBorderThickness,
        stroke: this._trackBorderColor
      });
    }
  }
  _initialVerticalEvent() {
    if (!this._enableVertical) {
      return;
    }
    const mainScene = this._mainScene || this._viewport.scene;
    if (this.verticalThumbRect) {
      this._eventSub.add(this.verticalThumbRect.onPointerEnter$.subscribeEvent((evt, state) => {
        this._verticalHoverFunc(this._thumbHoverBackgroundColor, evt, state);
      }));
    }
    if (this.verticalThumbRect) {
      this._eventSub.add(this.verticalThumbRect.onPointerLeave$.subscribeEvent((evt, state) => {
        this._verticalHoverLeaveFunc(this._thumbDefaultBackgroundColor, evt, state);
      }));
    }
    if (this.verticalScrollTrack) {
      this._eventSub.add(this.verticalScrollTrack.onPointerDown$.subscribeEvent((evt, state) => {
        const e = evt;
        this._viewport.scrollToBarPos({
          y: e.offsetY - this._viewport.top - this.verticalThumbSize / 2
        });
        state.stopPropagation();
      }));
    }
    if (this.verticalThumbRect) {
      this._eventSub.add(this.verticalThumbRect.onPointerDown$.subscribeEvent((evt, state) => {
        const e = evt;
        const srcElement = this.verticalThumbRect;
        this._isVerticalMove = true;
        this._lastX = e.offsetX;
        this._lastY = e.offsetY;
        srcElement == null ? void 0 : srcElement.setProps({
          fill: this._thumbActiveBackgroundColor
        });
        mainScene.setCaptureObject(this.verticalThumbRect);
        mainScene.disableObjectsEvent();
        this.makeViewDirty(true);
        state.stopPropagation();
      }));
    }
    this._verticalPointerMoveSub = mainScene.onPointerMove$.subscribeEvent((evt, _state) => {
      var _a;
      const e = evt;
      if (!this._isVerticalMove) {
        return;
      }
      this._viewport.scrollByBarDeltaValue({
        y: e.offsetY - this._lastY
      });
      this._lastY = e.offsetY;
      (_a = mainScene.getEngine()) == null ? void 0 : _a.setCapture();
    });
    this._verticalPointerUpSub = mainScene.onPointerUp$.subscribeEvent((_evt, _state) => {
      const srcElement = this.verticalThumbRect;
      this._isVerticalMove = false;
      mainScene.releaseCapturedObject();
      mainScene.enableObjectsEvent();
      srcElement == null ? void 0 : srcElement.setProps({
        fill: this._thumbHoverBackgroundColor
      });
      this.makeViewDirty(true);
    });
  }
  _horizonHoverFunc(color, evt, state) {
    this._hThumbMargin = HOVER_THUMB_MARGIN;
    this._resizeHorizontal();
    this._resizeRightBottomCorner();
    this._hoverFunc(color, this.horizonThumbRect)(evt, state);
  }
  _horizonHoverLeaveFunc(color, evt, state) {
    this._hThumbMargin = DEFAULT_THUMB_MARGIN;
    this._resizeHorizontal();
    this._resizeRightBottomCorner();
    this._hoverFunc(color, this.horizonThumbRect)(evt, state);
  }
  _verticalHoverFunc(color, evt, state) {
    this._vThumbMargin = HOVER_THUMB_MARGIN;
    this._resizeVertical();
    this._resizeRightBottomCorner();
    this._hoverFunc(color, this.verticalThumbRect)(evt, state);
  }
  _verticalHoverLeaveFunc(color, evt, state) {
    this._vThumbMargin = DEFAULT_THUMB_MARGIN;
    this._resizeVertical();
    this._resizeRightBottomCorner();
    this._hoverFunc(color, this.verticalThumbRect)(evt, state);
  }
  _hoverFunc(color, thumb) {
    return (_evt, _state) => {
      thumb.setProps({
        fill: color
      });
      this._trackThickness = HOVER_TRACK_SIZE;
      this._resizeHorizontal();
      this.makeViewDirty(true);
    };
  }
  _initialHorizontalEvent() {
    if (!this._enableHorizontal) {
      return;
    }
    const mainScene = this._mainScene || this._viewport.scene;
    if (this.horizonThumbRect) {
      this._eventSub.add(this.horizonThumbRect.onPointerEnter$.subscribeEvent((evt, state) => {
        this._horizonHoverFunc(this._thumbHoverBackgroundColor, evt, state);
      }));
    }
    if (this.horizonThumbRect) {
      this._eventSub.add(this.horizonThumbRect.onPointerLeave$.subscribeEvent((evt, state) => {
        this._horizonHoverLeaveFunc(this._thumbDefaultBackgroundColor, evt, state);
      }));
    }
    if (this.horizonScrollTrack) {
      this._eventSub.add(this.horizonScrollTrack.onPointerDown$.subscribeEvent((evt, state) => {
        const e = evt;
        this._viewport.scrollToBarPos({
          x: e.offsetX - this._viewport.left - this.horizontalThumbSize / 2
        });
        state.stopPropagation();
      }));
    }
    if (this.horizonThumbRect) {
      this._eventSub.add(this.horizonThumbRect.onPointerDown$.subscribeEvent((evt, state) => {
        var _a;
        const e = evt;
        this._isHorizonMove = true;
        this._lastX = e.offsetX;
        this._lastY = e.offsetY;
        (_a = this.horizonThumbRect) == null ? void 0 : _a.setProps({
          fill: this._thumbActiveBackgroundColor
        });
        this.makeViewDirty(true);
        mainScene.setCaptureObject(this.horizonThumbRect);
        mainScene.disableObjectsEvent();
        state.stopPropagation();
      }));
    }
    this._horizonPointerMoveSub = mainScene.onPointerMove$.subscribeEvent((evt, _state) => {
      var _a;
      const e = evt;
      if (!this._isHorizonMove) {
        return;
      }
      this._viewport.scrollByBarDeltaValue({
        x: e.offsetX - this._lastX
      });
      this._lastX = e.offsetX;
      (_a = mainScene.getEngine()) == null ? void 0 : _a.setCapture();
    });
    this._horizonPointerUpSub = mainScene.onPointerUp$.subscribeEvent((evt, state) => {
      var _a;
      ;
      this._isHorizonMove = false;
      mainScene.releaseCapturedObject();
      mainScene.enableObjectsEvent();
      (_a = this.horizonThumbRect) == null ? void 0 : _a.setProps({
        fill: this._thumbHoverBackgroundColor
      });
      this.makeViewDirty(true);
    });
  }
};

// ../packages/engine-render/src/components/docs/extensions/font-and-base-line.ts
var UNIQUE_KEY10 = "DefaultDocsFontAndBaseLineExtension";
var DOC_EXTENSION_Z_INDEX3 = 20;
var FontAndBaseLine = class extends docExtension {
  constructor() {
    super();
    __publicField(this, "uKey", UNIQUE_KEY10);
    __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX3);
    __publicField(this, "_preFontColor", "");
    /**
     * ctx.font = val;  then ctx.font is not exactly the same as val
     * that is because canvas would normalize the font string, remove default value and convert pt to px.
     * so we need a map to store actual value and set value
     */
    __publicField(this, "actualFontMap", {});
  }
  // invoked by document.ts
  draw(ctx, _parentScale, glyph, _819, more) {
    var _a;
    const line2 = (_a = glyph.parent) == null ? void 0 : _a.parent;
    if (!line2) {
      return;
    }
    const { ts: textStyle, content, fontStyle, bBox } = glyph;
    const { spanPointWithFont = Vector2.create(0, 0) } = this.extensionOffset;
    if (more) {
      if (more.viewBound) {
        if (spanPointWithFont.x > more.viewBound.right || spanPointWithFont.y - glyph.bBox.aba > more.viewBound.bottom) {
          return;
        }
      }
    }
    if (content == null) {
      return;
    }
    if (!textStyle) {
      this._fillText(ctx, glyph, spanPointWithFont);
      return;
    }
    const fontStringPxStr = (fontStyle == null ? void 0 : fontStyle.fontString) || "";
    if (fontStringPxStr) {
      if (ctx.font !== this.actualFontMap[fontStringPxStr]) {
        ctx.font = fontStringPxStr;
        this.actualFontMap[fontStringPxStr] = ctx.font;
      }
    }
    const { cl: colorStyle, va: baselineOffset } = textStyle;
    const fontColor = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
    if (fontColor && this._preFontColor !== fontColor) {
      ctx.fillStyle = fontColor;
    }
    if (baselineOffset === 3 /* SUPERSCRIPT */) {
      spanPointWithFont.y += -bBox.spo;
    } else if (baselineOffset === 2 /* SUBSCRIPT */) {
      spanPointWithFont.y += bBox.sbo;
    }
    this._fillText(ctx, glyph, spanPointWithFont);
  }
  _fillText(ctx, glyph, spanPointWithFont) {
    var _a, _b;
    const { renderConfig, spanStartPoint, centerPoint } = this.extensionOffset;
    const { content, width, bBox } = glyph;
    const { aba, abd } = bBox;
    if (content == null || spanStartPoint == null || centerPoint == null) {
      return;
    }
    const { vertexAngle, centerAngle } = renderConfig != null ? renderConfig : {};
    const VERTICAL_DEG = 90;
    const isVertical = vertexAngle === VERTICAL_DEG && centerAngle === VERTICAL_DEG;
    if (isVertical && !hasCJK(content)) {
      ctx.save();
      ctx.translate(spanStartPoint.x + centerPoint.x, spanStartPoint.y + centerPoint.y);
      ctx.rotate(Math.PI / 2);
      ctx.translate(-width / 2, (aba + abd) / 2 - abd);
      ctx.fillText(content, 0, 0);
      ctx.restore();
    } else {
      const CHECKED_GLYPH = "\u2611";
      const UNCHECKED_GLYPH = "\u2610";
      if ((content === UNCHECKED_GLYPH || content === CHECKED_GLYPH) && glyph.glyphType === 2 /* LIST */) {
        const size = Math.ceil(((_b = (_a = glyph.ts) == null ? void 0 : _a.fs) != null ? _b : 12) * 1.2);
        ctx.save();
        const fontHeight = glyph.bBox.aba - glyph.bBox.abd;
        const bottom = spanPointWithFont.y;
        const top = bottom - fontHeight;
        const left = spanPointWithFont.x;
        const topOffset = top + (bottom - top - size) / 2;
        const leftOffset = left;
        const BORDER_WIDTH = 1;
        ctx.translate(leftOffset - BORDER_WIDTH / 2, topOffset - BORDER_WIDTH / 2);
        CheckboxShape.drawWith(ctx, {
          width: size,
          height: size,
          checked: content === CHECKED_GLYPH
        });
        ctx.restore();
      } else {
        ctx.fillText(content, spanPointWithFont.x, spanPointWithFont.y);
      }
    }
  }
  clearCache() {
    this._preFontColor = "";
  }
};
DocumentsSpanAndLineExtensionRegistry.add(new FontAndBaseLine());

// ../packages/engine-render/src/components/docs/extensions/line.ts
var UNIQUE_KEY11 = "DefaultDocsLineExtension";
var DOC_EXTENSION_Z_INDEX4 = 40;
var Line = class extends docExtension {
  constructor() {
    super(...arguments);
    __publicField(this, "uKey", UNIQUE_KEY11);
    __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX4);
    __publicField(this, "_preBackgroundColor", "");
  }
  draw(ctx, parentScale, glyph) {
    var _a;
    const line2 = (_a = glyph.parent) == null ? void 0 : _a.parent;
    const { ts: textStyle, bBox, content } = glyph;
    if (line2 == null || textStyle == null || content === "\r") {
      return;
    }
    const { asc, dsc } = line2;
    const { sp: strikeoutPosition, spo, sbo, bd } = bBox;
    const scale = getScale(parentScale);
    const DELTA = 0.5;
    const { ul: underline, st: strikethrough, ol: overline, va: baselineOffset, bbl: bottomBorderLine } = textStyle;
    if (underline) {
      const startY = asc + dsc;
      this._drawLine(ctx, glyph, underline, startY, scale);
    }
    if (bottomBorderLine) {
      const startY = asc + dsc + 3;
      this._drawLine(ctx, glyph, bottomBorderLine, startY, scale, 2);
    }
    if (strikethrough) {
      let startY = asc + bd - strikeoutPosition - DELTA;
      if (baselineOffset === 3 /* SUPERSCRIPT */) {
        startY -= spo;
      } else if (baselineOffset === 2 /* SUBSCRIPT */) {
        startY += sbo;
      }
      this._drawLine(ctx, glyph, strikethrough, startY, scale);
    }
    if (overline) {
      const startY = -DEFAULT_OFFSET_SPACING - DELTA;
      this._drawLine(ctx, glyph, overline, startY, scale);
    }
  }
  clearCache() {
    this._preBackgroundColor = "";
  }
  _drawLine(ctx, glyph, line2, startY, _scale, lineWidth = 1) {
    var _a;
    let { s: show, cl: colorStyle, t: lineType, c = 1 /* TRUE */ } = line2;
    if (show !== 1 /* TRUE */) {
      return;
    }
    if (c == null) {
      c = 1 /* TRUE */;
    }
    const {
      originTranslate = Vector2.create(0, 0),
      alignOffset = Vector2.create(0, 0),
      renderConfig = {}
    } = this.extensionOffset;
    const { left, width } = glyph;
    const { centerAngle: centerAngleDeg = 0, vertexAngle: vertexAngleDeg = 0 } = renderConfig;
    ctx.save();
    const color = (c === 1 /* TRUE */ ? getColorStyle((_a = glyph.ts) == null ? void 0 : _a.cl) : getColorStyle(colorStyle)) || COLOR_BLACK_RGB;
    ctx.strokeStyle = color;
    ctx.lineWidth = lineWidth;
    this._setLineType(ctx, lineType || 12 /* SINGLE */);
    const centerAngle = degToRad(centerAngleDeg);
    const vertexAngle = degToRad(vertexAngleDeg);
    const start = calculateRectRotate(
      originTranslate.addByPoint(left, startY),
      Vector2.create(0, 0),
      centerAngle,
      vertexAngle,
      alignOffset
    );
    const end = calculateRectRotate(
      originTranslate.addByPoint(left + width, startY),
      Vector2.create(0, 0),
      centerAngle,
      vertexAngle,
      alignOffset
    );
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.stroke();
    ctx.restore();
  }
  _setLineType(ctx, style) {
    if (style === 1 /* DASH_DOT_DOT_HEAVY */ || style === 7 /* DOT_DOT_DASH */) {
      ctx.setLineDash([2, 2, 5, 2, 2]);
    } else if (style === 2 /* DASH_DOT_HEAVY */ || style === 6 /* DOT_DASH */) {
      ctx.setLineDash([2, 5, 2]);
    } else if (style === 8 /* DOTTED */ || style === 9 /* DOTTED_HEAVY */) {
      ctx.setLineDash([2]);
    } else if (style === 0 /* DASH */ || style === 3 /* DASHED_HEAVY */) {
      ctx.setLineDash([3]);
    } else if (style === 4 /* DASH_LONG */ || style === 5 /* DASH_LONG_HEAVY */) {
      ctx.setLineDash([6]);
    } else {
      ctx.setLineDash([0]);
    }
  }
};
DocumentsSpanAndLineExtensionRegistry.add(new Line());

// ../packages/engine-render/src/components/docs/document.ts
var Documents = class _Documents extends DocComponent {
  constructor(oKey, documentSkeleton, config) {
    super(oKey, documentSkeleton, config);
    __publicField(this, "_pageRender$", new Subject());
    __publicField(this, "pageRender$", this._pageRender$.asObservable());
    __publicField(this, "_drawLiquid", new Liquid());
    this._initialDefaultExtension();
    this.makeDirty(true);
  }
  static create(oKey, documentSkeleton, config) {
    return new _Documents(oKey, documentSkeleton, config);
  }
  dispose() {
    super.dispose();
    this._pageRender$.complete();
    this._drawLiquid = null;
  }
  getOffsetConfig() {
    const {
      transform: documentTransform,
      pageLayoutType,
      pageMarginLeft,
      pageMarginTop,
      left: docsLeft,
      top: docsTop
    } = this;
    return {
      documentTransform,
      pageLayoutType,
      pageMarginLeft,
      pageMarginTop,
      docsLeft,
      docsTop
    };
  }
  getEngine() {
    return this.getScene().getEngine();
  }
  changeSkeleton(newSkeleton) {
    this.setSkeleton(newSkeleton);
    return this;
  }
  _draw(ctx, bounds) {
    this.draw(ctx, bounds);
  }
  draw(ctx, bounds) {
    var _a, _b, _c, _d;
    const skeletonData = (_a = this.getSkeleton()) == null ? void 0 : _a.getSkeletonData();
    if (skeletonData == null || this._drawLiquid == null) {
      return;
    }
    this._drawLiquid.reset();
    const { pages, skeHeaders, skeFooters } = skeletonData;
    const parentScale = this.getParentScale();
    const extensions = this.getExtensionsByOrder();
    for (const extension of extensions) {
      extension.clearCache();
    }
    const backgroundExtension = extensions.find((e) => e.uKey === "DefaultDocsBackgroundExtension");
    const glyphExtensionsExcludeBackground = extensions.filter((e) => e.type === 0 /* SPAN */ && e.uKey !== "DefaultDocsBackgroundExtension");
    let pageTop = 0;
    let pageLeft = 0;
    for (let i = 0, len = pages.length; i < len; i++) {
      const page = pages[i];
      const {
        sections,
        marginTop: pagePaddingTop = 0,
        marginBottom: pagePaddingBottom = 0,
        marginLeft: pagePaddingLeft = 0,
        marginRight: pagePaddingRight = 0,
        width: actualWidth,
        height: actualHeight,
        pageWidth,
        headerId,
        footerId,
        renderConfig = {},
        skeTables
      } = page;
      const {
        verticalAlign = 1 /* TOP */,
        // Do not make changes, otherwise the document will not render.
        horizontalAlign = 1 /* LEFT */,
        // Do not make changes, otherwise the document will not render.
        centerAngle: centerAngleDeg = 0,
        vertexAngle: vertexAngleDeg = 0,
        wrapStrategy = 0 /* UNSPECIFIED */,
        cellValueType
        // isRotateNonEastAsian = BooleanNumber.FALSE,
      } = renderConfig;
      const horizontalOffsetNoAngle = this._horizontalHandler(
        actualWidth,
        pagePaddingLeft,
        pagePaddingRight,
        horizontalAlign,
        vertexAngleDeg,
        centerAngleDeg,
        cellValueType
      );
      const verticalOffsetNoAngle = this._verticalHandler(
        actualHeight,
        pagePaddingTop,
        pagePaddingBottom,
        verticalAlign
      );
      const alignOffsetNoAngle = Vector2.create(horizontalOffsetNoAngle, verticalOffsetNoAngle);
      const centerAngle = degToRad(centerAngleDeg);
      const vertexAngle = degToRad(vertexAngleDeg);
      const finalAngle = vertexAngle - centerAngle;
      if (this.isSkipByDiffBounds(page, pageTop, pageLeft, bounds)) {
        const { x: x2, y: y2 } = this._drawLiquid.translatePage(
          page,
          this.pageLayoutType,
          this.pageMarginLeft,
          this.pageMarginTop
        );
        pageLeft += x2;
        pageTop += y2;
        continue;
      }
      if (skeTables.size > 0) {
        this._drawTable(
          ctx,
          page,
          skeTables,
          extensions,
          backgroundExtension,
          glyphExtensionsExcludeBackground,
          alignOffsetNoAngle,
          centerAngle,
          vertexAngle,
          renderConfig,
          parentScale
        );
      }
      const headerSkeletonPage = (_b = skeHeaders.get(headerId)) == null ? void 0 : _b.get(pageWidth);
      const headerAlignOffsetNoAngle = Vector2.create(
        horizontalOffsetNoAngle,
        (_c = headerSkeletonPage == null ? void 0 : headerSkeletonPage.marginTop) != null ? _c : 0
      );
      if (headerSkeletonPage) {
        this._drawHeaderFooter(
          headerSkeletonPage,
          ctx,
          extensions,
          backgroundExtension,
          glyphExtensionsExcludeBackground,
          headerAlignOffsetNoAngle,
          centerAngle,
          vertexAngle,
          renderConfig,
          parentScale,
          page,
          true
        );
      }
      this._startRotation(ctx, finalAngle);
      for (const section of sections) {
        const { columns } = section;
        this._drawLiquid.translateSection(section);
        for (const column of columns) {
          const { lines, width: columnWidth } = column;
          this._drawLiquid.translateSave();
          this._drawLiquid.translateColumn(column);
          const linesCount = lines.length;
          let alignOffset = alignOffsetNoAngle;
          let rotateTranslateXListApply = null;
          if (vertexAngle !== 0) {
            const {
              rotateTranslateXList,
              rotatedHeight,
              rotatedWidth,
              fixOffsetX,
              fixOffsetY,
              rotateTranslateY
            } = getRotateOffsetAndFarthestHypotenuse(lines, columnWidth, vertexAngle);
            let exceedWidthFix = rotatedWidth;
            if (rotatedHeight > this.height && wrapStrategy !== 3 /* WRAP */) {
              if (wrapStrategy === 1 /* OVERFLOW */ || vertexAngle > 0) {
                exceedWidthFix = this.height / Math.tan(Math.abs(vertexAngle));
              }
            }
            const horizontalOffset = this._horizontalHandler(
              exceedWidthFix,
              pagePaddingLeft,
              pagePaddingRight,
              horizontalAlign,
              vertexAngleDeg,
              centerAngleDeg
            );
            const verticalOffset = this._verticalHandler(
              rotatedHeight,
              pagePaddingTop,
              pagePaddingBottom,
              verticalAlign
            );
            let exceedHeightFix = verticalOffset - fixOffsetY;
            if (rotatedHeight > this.height) {
              if (vertexAngle < 0) {
                exceedHeightFix = this.height - (rotatedHeight + fixOffsetY);
              } else {
                exceedHeightFix = -fixOffsetY;
              }
            }
            alignOffset = Vector2.create(horizontalOffset + fixOffsetX, exceedHeightFix);
            this._drawLiquid.translate(0, -rotateTranslateY);
            rotateTranslateXListApply = rotateTranslateXList;
          } else if (wrapStrategy === 3 /* WRAP */ && (horizontalAlign !== 0 /* UNSPECIFIED */ || cellValueType !== 2 /* NUMBER */)) {
            alignOffset.x = pagePaddingLeft;
          }
          for (let i2 = 0; i2 < linesCount; i2++) {
            const line2 = lines[i2];
            const { divides, asc = 0, type: type2, lineHeight = 0 } = line2;
            const maxLineAsc = asc;
            const maxLineAscSin = maxLineAsc * Math.sin(centerAngle);
            const maxLineAscCos = maxLineAsc * Math.cos(centerAngle);
            if (type2 === 1 /* BLOCK */) {
              for (const extension of extensions) {
                if (extension.type === 1 /* LINE */) {
                  extension.extensionOffset = {
                    alignOffset,
                    renderConfig
                  };
                  extension.draw(ctx, parentScale, line2);
                }
              }
            } else {
              this._drawLiquid.translateSave();
              this._drawLiquid.translateLine(line2, true, true);
              rotateTranslateXListApply && this._drawLiquid.translate(rotateTranslateXListApply[i2]);
              const divideLength = divides.length;
              for (let i3 = 0; i3 < divideLength; i3++) {
                const divide = divides[i3];
                const { glyphGroup } = divide;
                this._drawLiquid.translateSave();
                this._drawLiquid.translateDivide(divide);
                for (const glyph of glyphGroup) {
                  if (!glyph.content || glyph.content.length === 0) {
                    continue;
                  }
                  const { width: spanWidth, left: spanLeft } = glyph;
                  const { x: translateX, y: translateY } = this._drawLiquid;
                  const originTranslate = Vector2.create(translateX, translateY);
                  const centerPoint = Vector2.create(spanWidth / 2, lineHeight / 2);
                  const spanStartPoint = calculateRectRotate(
                    originTranslate.addByPoint(spanLeft, 0),
                    centerPoint,
                    centerAngle,
                    vertexAngle,
                    alignOffset
                  );
                  const extensionOffset = {
                    spanStartPoint
                  };
                  if (backgroundExtension) {
                    backgroundExtension.extensionOffset = extensionOffset;
                    backgroundExtension.draw(ctx, parentScale, glyph);
                  }
                }
                for (const glyph of glyphGroup) {
                  if (!glyph.content || glyph.content.length === 0) {
                    continue;
                  }
                  const { width: spanWidth, left: spanLeft, xOffset } = glyph;
                  const { x: translateX, y: translateY } = this._drawLiquid;
                  const originTranslate = Vector2.create(translateX, translateY);
                  const centerPoint = Vector2.create(spanWidth / 2, lineHeight / 2);
                  const spanStartPoint = calculateRectRotate(
                    originTranslate.addByPoint(spanLeft + xOffset, 0),
                    centerPoint,
                    centerAngle,
                    vertexAngle,
                    alignOffset
                  );
                  const spanPointWithFont = calculateRectRotate(
                    originTranslate.addByPoint(
                      spanLeft + maxLineAscSin + xOffset,
                      maxLineAscCos
                    ),
                    centerPoint,
                    centerAngle,
                    vertexAngle,
                    alignOffset
                  );
                  const extensionOffset = {
                    originTranslate,
                    spanStartPoint,
                    spanPointWithFont,
                    centerPoint,
                    alignOffset,
                    renderConfig
                  };
                  for (const extension of glyphExtensionsExcludeBackground) {
                    extension.extensionOffset = extensionOffset;
                    extension.draw(ctx, parentScale, glyph, [], {
                      viewBound: bounds == null ? void 0 : bounds.viewBound
                    });
                  }
                }
                this._drawLiquid.translateRestore();
              }
              if (line2.borderBottom) {
                this._drawBorderBottom(ctx, page, line2);
              }
              this._drawLiquid.translateRestore();
            }
          }
          this._drawLiquid.translateRestore();
        }
      }
      this._resetRotation(ctx, finalAngle);
      const footerSkeletonPage = (_d = skeFooters.get(footerId)) == null ? void 0 : _d.get(pageWidth);
      if (footerSkeletonPage) {
        const footerAlignOffsetNoAngle = Vector2.create(
          horizontalOffsetNoAngle,
          page.pageHeight - (footerSkeletonPage == null ? void 0 : footerSkeletonPage.height) - footerSkeletonPage.marginBottom
        );
        this._drawHeaderFooter(
          footerSkeletonPage,
          ctx,
          extensions,
          backgroundExtension,
          glyphExtensionsExcludeBackground,
          footerAlignOffsetNoAngle,
          centerAngle,
          vertexAngle,
          renderConfig,
          parentScale,
          page,
          false
        );
      }
      this._pageRender$.next({
        page,
        pageLeft,
        pageTop,
        ctx
      });
      const { x, y } = this._drawLiquid.translatePage(
        page,
        this.pageLayoutType,
        this.pageMarginLeft,
        this.pageMarginTop
      );
      pageLeft += x;
      pageTop += y;
    }
  }
  _drawTable(ctx, page, skeTables, extensions, backgroundExtension, glyphExtensionsExcludeBackground, alignOffsetNoAngle, centerAngle, vertexAngle, renderConfig, parentScale) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    for (const [_tableId, tableSkeleton] of skeTables) {
      const { top: tableTop, left: tableLeft, rows } = tableSkeleton;
      (_a = this._drawLiquid) == null ? void 0 : _a.translateSave();
      (_b = this._drawLiquid) == null ? void 0 : _b.translate(tableLeft, tableTop);
      for (const row of rows) {
        const { top: rowTop, cells } = row;
        (_c = this._drawLiquid) == null ? void 0 : _c.translateSave();
        (_d = this._drawLiquid) == null ? void 0 : _d.translate(0, rowTop);
        for (const cell of cells) {
          const { left: cellLeft } = cell;
          (_e = this._drawLiquid) == null ? void 0 : _e.translateSave();
          (_f = this._drawLiquid) == null ? void 0 : _f.translate(cellLeft, 0);
          this._drawTableCell(
            ctx,
            page,
            cell,
            extensions,
            backgroundExtension,
            glyphExtensionsExcludeBackground,
            alignOffsetNoAngle,
            centerAngle,
            vertexAngle,
            renderConfig,
            parentScale
          );
          (_g = this._drawLiquid) == null ? void 0 : _g.translateRestore();
        }
        (_h = this._drawLiquid) == null ? void 0 : _h.translateRestore();
      }
      (_i = this._drawLiquid) == null ? void 0 : _i.translateRestore();
    }
  }
  _drawBorderBottom(ctx, page, line2, left = 0, top = 0) {
    var _a, _b, _c, _d;
    if (this._drawLiquid == null) {
      return;
    }
    let { x, y } = this._drawLiquid;
    const { pageWidth, marginLeft, marginRight, marginTop } = page;
    x += marginLeft + (left != null ? left : 0);
    y -= line2.marginTop;
    y -= line2.paddingTop;
    y += marginTop + top + line2.lineHeight + ((_b = (_a = line2.borderBottom) == null ? void 0 : _a.padding) != null ? _b : 0);
    ctx.save();
    ctx.strokeStyle = (_d = (_c = line2.borderBottom) == null ? void 0 : _c.color.rgb) != null ? _d : "#CDD0D8";
    drawLineByBorderType(ctx, "b" /* BOTTOM */, 0, {
      startX: x,
      startY: y,
      endX: x + pageWidth - marginLeft - marginRight,
      endY: y
    });
    ctx.restore();
  }
  // TODO: @JOCS, DRY!!!
  _drawTableCell(ctx, page, cell, extensions, backgroundExtension, glyphExtensionsExcludeBackground, alignOffsetNoAngle, centerAngle, vertexAngle, renderConfig, parentScale) {
    if (this._drawLiquid == null) {
      return;
    }
    this._drawTableCellBorders(ctx, page, cell);
    const { sections, marginLeft, marginTop } = cell;
    alignOffsetNoAngle = Vector2.create(alignOffsetNoAngle.x + marginLeft, alignOffsetNoAngle.y + marginTop);
    ctx.save();
    const { x, y } = this._drawLiquid;
    const { pageWidth, pageHeight } = cell;
    ctx.beginPath();
    ctx.rectByPrecision(x + page.marginLeft, y + page.marginTop, pageWidth, pageHeight);
    ctx.closePath();
    ctx.clip();
    for (const section of sections) {
      const { columns } = section;
      this._drawLiquid.translateSave();
      this._drawLiquid.translateSection(section);
      for (const column of columns) {
        const { lines } = column;
        this._drawLiquid.translateSave();
        this._drawLiquid.translateColumn(column);
        const linesCount = lines.length;
        const alignOffset = alignOffsetNoAngle;
        for (let i = 0; i < linesCount; i++) {
          const line2 = lines[i];
          const { divides, asc = 0, type: type2, lineHeight = 0 } = line2;
          const maxLineAsc = asc;
          const maxLineAscSin = maxLineAsc * Math.sin(centerAngle);
          const maxLineAscCos = maxLineAsc * Math.cos(centerAngle);
          if (type2 === 1 /* BLOCK */) {
            for (const extension of extensions) {
              if (extension.type === 1 /* LINE */) {
                extension.extensionOffset = {
                  alignOffset,
                  renderConfig
                };
                extension.draw(ctx, parentScale, line2);
              }
            }
          } else {
            this._drawLiquid.translateSave();
            this._drawLiquid.translateLine(line2, true, true);
            const divideLength = divides.length;
            for (let i2 = 0; i2 < divideLength; i2++) {
              const divide = divides[i2];
              const { glyphGroup } = divide;
              this._drawLiquid.translateSave();
              this._drawLiquid.translateDivide(divide);
              for (const glyph of glyphGroup) {
                if (!glyph.content || glyph.content.length === 0) {
                  continue;
                }
                const { width: spanWidth, left: spanLeft } = glyph;
                const { x: translateX, y: translateY } = this._drawLiquid;
                const originTranslate = Vector2.create(translateX, translateY);
                const centerPoint = Vector2.create(spanWidth / 2, lineHeight / 2);
                const spanStartPoint = calculateRectRotate(
                  originTranslate.addByPoint(spanLeft, 0),
                  centerPoint,
                  centerAngle,
                  vertexAngle,
                  alignOffset
                );
                const extensionOffset = {
                  spanStartPoint
                };
                if (backgroundExtension) {
                  backgroundExtension.extensionOffset = extensionOffset;
                  backgroundExtension.draw(ctx, parentScale, glyph);
                }
              }
              for (const glyph of glyphGroup) {
                if (!glyph.content || glyph.content.length === 0) {
                  continue;
                }
                const { width: spanWidth, left: spanLeft, xOffset } = glyph;
                const { x: translateX, y: translateY } = this._drawLiquid;
                const originTranslate = Vector2.create(translateX, translateY);
                const centerPoint = Vector2.create(spanWidth / 2, lineHeight / 2);
                const spanStartPoint = calculateRectRotate(
                  originTranslate.addByPoint(spanLeft + xOffset, 0),
                  centerPoint,
                  centerAngle,
                  vertexAngle,
                  alignOffset
                );
                const spanPointWithFont = calculateRectRotate(
                  originTranslate.addByPoint(
                    spanLeft + maxLineAscSin + xOffset,
                    maxLineAscCos
                  ),
                  centerPoint,
                  centerAngle,
                  vertexAngle,
                  alignOffset
                );
                const extensionOffset = {
                  originTranslate,
                  spanStartPoint,
                  spanPointWithFont,
                  centerPoint,
                  alignOffset,
                  renderConfig
                };
                for (const extension of glyphExtensionsExcludeBackground) {
                  extension.extensionOffset = extensionOffset;
                  extension.draw(ctx, parentScale, glyph);
                }
              }
              this._drawLiquid.translateRestore();
            }
            if (line2.borderBottom) {
              this._drawBorderBottom(ctx, cell, line2, page.marginLeft, page.marginTop);
            }
            this._drawLiquid.translateRestore();
          }
        }
        this._drawLiquid.translateRestore();
      }
      this._drawLiquid.translateRestore();
    }
    ctx.restore();
  }
  _drawTableCellBorders(ctx, page, cell) {
    const { marginLeft, marginTop } = page;
    const { pageWidth, pageHeight } = cell;
    if (this._drawLiquid == null) {
      return;
    }
    let { x, y } = this._drawLiquid;
    x += marginLeft;
    y += marginTop;
    drawLineByBorderType(ctx, "l" /* LEFT */, 0, {
      startX: x,
      startY: y,
      endX: x + pageWidth,
      endY: y + pageHeight
    });
    drawLineByBorderType(ctx, "t" /* TOP */, 0, {
      startX: x,
      startY: y,
      endX: x + pageWidth,
      endY: y + pageHeight
    });
    drawLineByBorderType(ctx, "r" /* RIGHT */, 0, {
      startX: x,
      startY: y,
      endX: x + pageWidth,
      endY: y + pageHeight
    });
    drawLineByBorderType(ctx, "b" /* BOTTOM */, 0, {
      startX: x,
      startY: y,
      endX: x + pageWidth,
      endY: y + pageHeight
    });
  }
  _drawHeaderFooter(page, ctx, extensions, backgroundExtension, glyphExtensionsExcludeBackground, alignOffsetNoAngle, centerAngle, vertexAngle, renderConfig, parentScale, parentPage, isHeader = true) {
    if (this._drawLiquid == null) {
      return;
    }
    const { sections } = page;
    const { y: originY } = this._drawLiquid;
    for (const section of sections) {
      const { columns } = section;
      this._drawLiquid.translateSave();
      this._drawLiquid.translateSection(section);
      for (const column of columns) {
        const { lines } = column;
        this._drawLiquid.translateSave();
        this._drawLiquid.translateColumn(column);
        const linesCount = lines.length;
        const alignOffset = alignOffsetNoAngle;
        for (let i = 0; i < linesCount; i++) {
          const line2 = lines[i];
          const { divides, asc = 0, type: type2, lineHeight = 0 } = line2;
          const maxLineAsc = asc;
          const maxLineAscSin = maxLineAsc * Math.sin(centerAngle);
          const maxLineAscCos = maxLineAsc * Math.cos(centerAngle);
          if (type2 === 1 /* BLOCK */) {
            for (const extension of extensions) {
              if (extension.type === 1 /* LINE */) {
                extension.extensionOffset = {
                  alignOffset,
                  renderConfig
                };
                extension.draw(ctx, parentScale, line2);
              }
            }
          } else {
            this._drawLiquid.translateSave();
            this._drawLiquid.translateLine(line2, true, true);
            const { y } = this._drawLiquid;
            if (isHeader) {
              if (y - originY + alignOffset.y > (parentPage.pageHeight - 100) / 2) {
                this._drawLiquid.translateRestore();
                continue;
              }
            } else {
              if (y - originY + alignOffset.y + lineHeight < (parentPage.pageHeight - 100) / 2 + 100) {
                this._drawLiquid.translateRestore();
                continue;
              }
            }
            const divideLength = divides.length;
            for (let i2 = 0; i2 < divideLength; i2++) {
              const divide = divides[i2];
              const { glyphGroup } = divide;
              this._drawLiquid.translateSave();
              this._drawLiquid.translateDivide(divide);
              for (const glyph of glyphGroup) {
                if (!glyph.content || glyph.content.length === 0) {
                  continue;
                }
                const { width: spanWidth, left: spanLeft } = glyph;
                const { x: translateX, y: translateY } = this._drawLiquid;
                const originTranslate = Vector2.create(translateX, translateY);
                const centerPoint = Vector2.create(spanWidth / 2, lineHeight / 2);
                const spanStartPoint = calculateRectRotate(
                  originTranslate.addByPoint(spanLeft, 0),
                  centerPoint,
                  centerAngle,
                  vertexAngle,
                  alignOffset
                );
                const extensionOffset = {
                  spanStartPoint
                };
                if (backgroundExtension) {
                  backgroundExtension.extensionOffset = extensionOffset;
                  backgroundExtension.draw(ctx, parentScale, glyph);
                }
              }
              for (const glyph of glyphGroup) {
                if (!glyph.content || glyph.content.length === 0) {
                  continue;
                }
                const { width: spanWidth, left: spanLeft, xOffset } = glyph;
                const { x: translateX, y: translateY } = this._drawLiquid;
                const originTranslate = Vector2.create(translateX, translateY);
                const centerPoint = Vector2.create(spanWidth / 2, lineHeight / 2);
                const spanStartPoint = calculateRectRotate(
                  originTranslate.addByPoint(spanLeft + xOffset, 0),
                  centerPoint,
                  centerAngle,
                  vertexAngle,
                  alignOffset
                );
                const spanPointWithFont = calculateRectRotate(
                  originTranslate.addByPoint(
                    spanLeft + maxLineAscSin + xOffset,
                    maxLineAscCos
                  ),
                  centerPoint,
                  centerAngle,
                  vertexAngle,
                  alignOffset
                );
                const extensionOffset = {
                  originTranslate,
                  spanStartPoint,
                  spanPointWithFont,
                  centerPoint,
                  alignOffset,
                  renderConfig
                };
                for (const extension of glyphExtensionsExcludeBackground) {
                  extension.extensionOffset = extensionOffset;
                  extension.draw(ctx, parentScale, glyph);
                }
              }
              this._drawLiquid.translateRestore();
            }
            if (line2.borderBottom) {
              this._drawBorderBottom(ctx, page, line2, parentPage.marginLeft);
            }
            this._drawLiquid.translateRestore();
          }
        }
        this._drawLiquid.translateRestore();
      }
      this._drawLiquid.translateRestore();
    }
  }
  _horizontalHandler(pageWidth, pagePaddingLeft, pagePaddingRight, horizontalAlign, vertexAngleDeg = 0, centerAngleDeg = 0, cellValueType) {
    if (horizontalAlign === 0 /* UNSPECIFIED */) {
      if (centerAngleDeg === VERTICAL_ROTATE_ANGLE && vertexAngleDeg === VERTICAL_ROTATE_ANGLE) {
        horizontalAlign = 2 /* CENTER */;
      } else if (vertexAngleDeg > 0 && vertexAngleDeg !== VERTICAL_ROTATE_ANGLE || vertexAngleDeg === -VERTICAL_ROTATE_ANGLE) {
        horizontalAlign = 3 /* RIGHT */;
      } else {
        if (cellValueType === 2 /* NUMBER */) {
          horizontalAlign = 3 /* RIGHT */;
        } else if (cellValueType === 3 /* BOOLEAN */) {
          horizontalAlign = 2 /* CENTER */;
        } else {
          horizontalAlign = 1 /* LEFT */;
        }
      }
    }
    let offsetLeft = 0;
    if (horizontalAlign === 2 /* CENTER */) {
      offsetLeft = (this.width - pageWidth) / 2;
    } else if (horizontalAlign === 3 /* RIGHT */) {
      offsetLeft = this.width - pageWidth - pagePaddingRight;
    } else {
      offsetLeft = pagePaddingLeft;
    }
    return offsetLeft;
  }
  _verticalHandler(pageHeight, pagePaddingTop, pagePaddingBottom, verticalAlign) {
    let offsetTop = 0;
    if (verticalAlign === 2 /* MIDDLE */) {
      offsetTop = (this.height - pageHeight) / 2;
    } else if (verticalAlign === 1 /* TOP */) {
      offsetTop = pagePaddingTop;
    } else {
      offsetTop = this.height - pageHeight - pagePaddingBottom;
    }
    return offsetTop;
  }
  _startRotation(ctx, textAngle) {
    ctx.rotate(textAngle || 0);
  }
  _resetRotation(ctx, textAngle) {
    ctx.rotate(-textAngle || 0);
  }
  _initialDefaultExtension() {
    DocumentsSpanAndLineExtensionRegistry.getData().forEach((extension) => {
      this.register(extension);
    });
  }
};

// ../packages/engine-render/src/components/sheets/spreadsheet.ts
var OBJECT_KEY = "__SHEET_EXTENSION_FONT_DOCUMENT_INSTANCE__";
var Spreadsheet = class extends SheetComponent {
  constructor(oKey, spreadsheetSkeleton, _allowCache = true) {
    super(oKey, spreadsheetSkeleton);
    this._allowCache = _allowCache;
    __publicField(this, "_backgroundExtension");
    __publicField(this, "_borderExtension");
    __publicField(this, "_fontExtension");
    __publicField(this, "_refreshIncrementalState", false);
    __publicField(this, "_dirtyBounds", []);
    __publicField(this, "_forceDisableGridlines", false);
    __publicField(this, "_documents", new Documents(OBJECT_KEY, void 0, {
      pageMarginLeft: 0,
      pageMarginTop: 0
    }));
    __publicField(this, "isPrinting", false);
    this._initialDefaultExtension();
    this.makeDirty(true);
  }
  get backgroundExtension() {
    return this._backgroundExtension;
  }
  get borderExtension() {
    return this._borderExtension;
  }
  get fontExtension() {
    return this._fontExtension;
  }
  getDocuments() {
    return this._documents;
  }
  get allowCache() {
    return this._allowCache;
  }
  get forceDisableGridlines() {
    return this._forceDisableGridlines;
  }
  dispose() {
    var _a;
    super.dispose();
    (_a = this._documents) == null ? void 0 : _a.dispose();
    this._documents = null;
    this._backgroundExtension = null;
    this._borderExtension = null;
    this._fontExtension = null;
  }
  /**
   * draw by viewport
   * @param ctx
   * @param viewportInfo
   */
  draw(ctx, viewportInfo) {
    var _a;
    const spreadsheetSkeleton = this.getSkeleton();
    if (!spreadsheetSkeleton) {
      return;
    }
    this._drawAuxiliary(ctx);
    const parentScale = this.getParentScale();
    const diffRanges = this._refreshIncrementalState && viewportInfo.diffBounds ? (_a = viewportInfo.diffBounds) == null ? void 0 : _a.map((bound) => spreadsheetSkeleton.getRangeByViewBound(bound)) : [];
    const viewRanges = [spreadsheetSkeleton.getCacheRangeByViewport(viewportInfo)];
    const extensions = this.getExtensionsByOrder();
    const scene = this.getScene();
    for (const extension of extensions) {
      const timeKey = `${SHEET_EXTENSION_PREFIX}${extension.uKey}`;
      const st = Tools.now();
      extension.draw(ctx, parentScale, spreadsheetSkeleton, diffRanges, {
        viewRanges,
        checkOutOfViewBound: true,
        viewportKey: viewportInfo.viewportKey,
        viewBound: viewportInfo.cacheBound,
        diffBounds: viewportInfo.diffBounds
      });
      this.addRenderFrameTimeMetricToScene(timeKey, Tools.now() - st, scene);
    }
  }
  addRenderFrameTimeMetricToScene(timeKey, val, scene) {
    scene = scene != null ? scene : this.getScene();
    const engine = scene.getEngine();
    engine.renderFrameTimeMetric$.next([timeKey, val]);
  }
  addRenderTagToScene(renderKey, val, scene) {
    scene = scene != null ? scene : this.getScene();
    const engine = scene.getEngine();
    engine.renderFrameTags$.next([renderKey, val]);
  }
  /**
   * override for return type as Scene.
   * @returns Scene
   */
  getScene() {
    return super.getScene();
  }
  isHit(coord) {
    const oCoord = this.getInverseCoord(coord);
    const skeleton = this.getSkeleton();
    if (!skeleton) {
      return false;
    }
    const { rowHeaderWidth, columnHeaderHeight } = skeleton;
    if (oCoord.x > rowHeaderWidth && oCoord.y > columnHeaderHeight) {
      return true;
    }
    return false;
  }
  getNoMergeCellPositionByIndex(rowIndex, columnIndex) {
    const skeleton = this.getSkeleton();
    if (!skeleton) {
      return { startX: 0, startY: 0, endX: 0, endY: 0 };
    }
    return skeleton.getNoMergeCellWithCoordByIndex(rowIndex, columnIndex);
  }
  getScrollXYByRelativeCoords(coord) {
    const scene = this.getParent();
    let x = 0;
    let y = 0;
    const viewPort = scene.findViewportByPosToScene(coord);
    if (viewPort) {
      const actualX = viewPort.viewportScrollX || 0;
      const actualY = viewPort.viewportScrollY || 0;
      x += actualX;
      y += actualY;
    }
    return {
      x,
      y
    };
  }
  isForceDirty() {
    return this._forceDirty;
  }
  /**
   * canvas resize & zoom would call forceDirty
   * @param state
   */
  makeForceDirty(state = true) {
    this.makeDirty(state);
    this._forceDirty = state;
  }
  setForceDisableGridlines(disabled) {
    this._forceDisableGridlines = disabled;
  }
  getSelectionBounding(startRow, startColumn, endRow, endColumn) {
    var _a;
    return (_a = this.getSkeleton()) == null ? void 0 : _a.expandRangeByMerge({ startRow, startColumn, endRow, endColumn });
  }
  /**
   * Since multiple controllers, not just the sheet-render.controller, invoke spreadsheet.makeDirty() — for instance, the cf.render-controller — it's essential to also call viewport.markDirty() whenever spreadsheet.makeDirty() is triggered.
   * @param state
   */
  makeDirty(state = true) {
    var _a;
    (_a = this.getParent()) == null ? void 0 : _a.getViewports().forEach((vp) => vp.markDirty(state));
    super.makeDirty(state);
    if (state === false) {
      this._dirtyBounds = [];
    }
    return this;
  }
  setDirtyArea(dirtyBounds) {
    this._dirtyBounds = dirtyBounds;
  }
  renderByViewports(mainCtx, viewportInfo, spreadsheetSkeleton) {
    const { diffBounds, diffX, diffY, viewPortPosition, cacheCanvas, leftOrigin, topOrigin, bufferEdgeX, bufferEdgeY, isDirty: isViewportDirty, isForceDirty: isViewportForceDirty } = viewportInfo;
    const { rowHeaderWidth, columnHeaderHeight } = spreadsheetSkeleton;
    const { a: scaleX = 1, d: scaleY = 1 } = mainCtx.getTransform();
    const bufferEdgeSizeX = bufferEdgeX * scaleX / window.devicePixelRatio;
    const bufferEdgeSizeY = bufferEdgeY * scaleY / window.devicePixelRatio;
    const cacheCtx = cacheCanvas.getContext();
    cacheCtx.save();
    const isForceDirty = isViewportForceDirty || this.isForceDirty();
    const isDirty = isViewportDirty || this.isDirty();
    if (diffBounds.length === 0 || diffX === 0 && diffY === 0 || isForceDirty || isDirty) {
      if (isDirty || isForceDirty) {
        this.addRenderTagToScene("scrolling", false);
        this.refreshCacheCanvas(viewportInfo, { cacheCanvas, cacheCtx, mainCtx, topOrigin, leftOrigin, bufferEdgeX, bufferEdgeY });
      }
    } else if (diffBounds.length !== 0 || diffX !== 0 || diffY !== 0) {
      this.addRenderTagToScene("scrolling", true);
      this.paintNewAreaForScrolling(viewportInfo, {
        cacheCanvas,
        cacheCtx,
        mainCtx,
        topOrigin,
        leftOrigin,
        bufferEdgeX,
        bufferEdgeY,
        scaleX,
        scaleY,
        columnHeaderHeight,
        rowHeaderWidth
      });
    }
    const sourceLeft = bufferEdgeSizeX * Math.min(1, window.devicePixelRatio);
    const sourceTop = bufferEdgeSizeY * Math.min(1, window.devicePixelRatio);
    const { left, top, right, bottom } = viewPortPosition;
    const dw = right - left + rowHeaderWidth;
    const dh = bottom - top + columnHeaderHeight;
    this._applyCache(cacheCanvas, mainCtx, sourceLeft, sourceTop, dw, dh, left, top, dw, dh);
    cacheCtx.restore();
  }
  paintNewAreaForScrolling(viewportInfo, param) {
    const { cacheCanvas, cacheCtx, mainCtx, topOrigin, leftOrigin, bufferEdgeX, bufferEdgeY, scaleX, scaleY, columnHeaderHeight, rowHeaderWidth } = param;
    const { shouldCacheUpdate, diffCacheBounds, diffX, diffY } = viewportInfo;
    cacheCtx.save();
    cacheCtx.setTransform(1, 0, 0, 1, 0, 0);
    cacheCtx.globalCompositeOperation = "copy";
    cacheCtx.drawImage(cacheCanvas.getCanvasEle(), diffX * scaleX, diffY * scaleY);
    cacheCtx.restore();
    this._refreshIncrementalState = true;
    const m = mainCtx.getTransform();
    cacheCtx.setTransform(m.a, m.b, m.c, m.d, 0, 0);
    cacheCtx.translateWithPrecision(m.e / m.a - leftOrigin + bufferEdgeX, m.f / m.d - topOrigin + bufferEdgeY);
    if (shouldCacheUpdate) {
      for (const diffBound of diffCacheBounds) {
        const { left: diffLeft, right: diffRight, bottom: diffBottom, top: diffTop } = diffBound;
        const x = diffLeft - rowHeaderWidth;
        const y = diffTop - columnHeaderHeight;
        const w = diffRight - diffLeft;
        const h = diffBottom - diffTop;
        cacheCtx.clearRectByPrecision(x, y, w, h);
        cacheCtx.save();
        cacheCtx.beginPath();
        cacheCtx.rectByPrecision(x, y, w, h);
        cacheCtx.closePath();
        cacheCtx.clip();
        this.draw(cacheCtx, {
          ...viewportInfo,
          diffBounds: [diffBound]
        });
        cacheCtx.restore();
      }
    }
    this._refreshIncrementalState = false;
  }
  /**
   * Redraw the entire viewport.
   */
  refreshCacheCanvas(viewportInfo, param) {
    const { cacheCanvas, cacheCtx, mainCtx, topOrigin, leftOrigin, bufferEdgeX, bufferEdgeY } = param;
    cacheCtx.save();
    cacheCtx.setTransform(1, 0, 0, 1, 0, 0);
    cacheCanvas.clear();
    cacheCtx.restore();
    cacheCtx.save();
    const m = mainCtx.getTransform();
    cacheCtx.setTransform(m.a, m.b, m.c, m.d, 0, 0);
    cacheCtx.translateWithPrecision(m.e / m.a - leftOrigin + bufferEdgeX, m.f / m.d - topOrigin + bufferEdgeY);
    this.draw(cacheCtx, viewportInfo);
    cacheCtx.restore();
  }
  render(mainCtx, viewportInfo) {
    var _a;
    if (!this.visible) {
      this.makeDirty(false);
      return this;
    }
    const spreadsheetSkeleton = this.getSkeleton();
    if (!spreadsheetSkeleton) {
      return;
    }
    spreadsheetSkeleton.setStylesCache(viewportInfo);
    const segment = spreadsheetSkeleton.rowColumnSegment;
    if (!segment) {
      return;
    }
    if (segment.startRow === -1 && segment.endRow === -1 || segment.startColumn === -1 && segment.endColumn === -1) {
      return;
    }
    mainCtx.save();
    const { rowHeaderWidth, columnHeaderHeight } = spreadsheetSkeleton;
    mainCtx.translateWithPrecision(rowHeaderWidth, columnHeaderHeight);
    (_a = this.getScene()) == null ? void 0 : _a.updateTransformerZero(spreadsheetSkeleton.rowHeaderWidth, spreadsheetSkeleton.columnHeaderHeight);
    const { viewportKey } = viewportInfo;
    if (sheetContentViewportKeys.includes(viewportKey)) {
      if (viewportInfo && viewportInfo.cacheCanvas) {
        this.renderByViewports(mainCtx, viewportInfo, spreadsheetSkeleton);
      } else {
        this._draw(mainCtx, viewportInfo);
      }
    } else if (sheetHeaderViewportKeys.includes(viewportKey)) {
    } else {
      if (viewportInfo && viewportInfo.cacheCanvas) {
        this.renderByViewports(mainCtx, viewportInfo, spreadsheetSkeleton);
      } else {
        this._draw(mainCtx, viewportInfo);
      }
    }
    mainCtx.restore();
    return this;
  }
  /**
   * applyCache from cache canvas
   * @param cacheCanvas Source Image
   * @param ctx MainCtx
   * @param sx
   * @param sy
   * @param sw
   * @param sh
   * @param dx
   * @param dy
   * @param dw
   * @param dh
   */
  _applyCache(cacheCanvas, ctx, sx = 0, sy = 0, sw = 0, sh = 0, dx = 0, dy = 0, dw = 0, dh = 0) {
    if (!ctx) {
      return;
    }
    const pixelRatio = cacheCanvas.getPixelRatio();
    const cacheCtx = cacheCanvas.getContext();
    cacheCtx.save();
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    cacheCtx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(
      cacheCanvas.getCanvasEle(),
      sx * pixelRatio,
      sy * pixelRatio,
      sw * pixelRatio,
      sh * pixelRatio,
      dx * pixelRatio,
      dy * pixelRatio,
      dw * pixelRatio,
      dh * pixelRatio
    );
    ctx.restore();
    cacheCtx.restore();
  }
  _draw(ctx, bounds) {
    this.draw(ctx, bounds);
  }
  _getAncestorSize() {
    const parent = this._getAncestorParent();
    if (!parent) {
      return;
    }
    if (parent.classType === "Engine" /* ENGINE */) {
      const mainCanvas = parent.getCanvas();
      return {
        width: mainCanvas.getWidth(),
        height: mainCanvas.getHeight()
      };
    }
    if (parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      return {
        width: parent.width,
        height: parent.height
      };
    }
  }
  _getAncestorParent() {
    let parent = this.parent;
    while (parent) {
      if (parent.classType === "Engine" /* ENGINE */ || parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        return parent;
      }
      parent = (parent == null ? void 0 : parent.getParent) && (parent == null ? void 0 : parent.getParent());
    }
  }
  _initialDefaultExtension() {
    SpreadsheetExtensionRegistry.getData().sort(sortRules).forEach((Extension) => {
      this.register(new Extension());
    });
    this._backgroundExtension = this.getExtensionByKey("DefaultBackgroundExtension");
    this._borderExtension = this.getExtensionByKey("DefaultBorderExtension");
    this._fontExtension = this.getExtensionByKey("DefaultFontExtension");
  }
  /**
   * draw gridlines
   * @param ctx
   */
  // eslint-disable-next-line max-lines-per-function
  _drawAuxiliary(ctx) {
    var _a;
    const spreadsheetSkeleton = this.getSkeleton();
    if (spreadsheetSkeleton == null) {
      return;
    }
    const { rowColumnSegment, overflowCache, showGridlines, gridlinesColor } = spreadsheetSkeleton;
    const mergeCellRanges = spreadsheetSkeleton.getCurrentRowColumnSegmentMergeData(rowColumnSegment);
    const { startRow, endRow, startColumn, endColumn } = rowColumnSegment;
    if (!spreadsheetSkeleton || showGridlines === 0 /* FALSE */ || this._forceDisableGridlines) {
      return;
    }
    const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
    if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
      return;
    }
    ctx.save();
    ctx.setLineWidthByPrecision(1);
    ctx.strokeStyle = (_a = gridlinesColor != null ? gridlinesColor : ctx.renderConfig.gridlinesColor) != null ? _a : getColor([214, 216, 219]);
    const columnWidthAccumulationLength = columnWidthAccumulation.length;
    const rowHeightAccumulationLength = rowHeightAccumulation.length;
    const EXTRA_BOUND = 0.4;
    const rowCount = endRow - startRow + 1;
    const columnCount = endColumn - startColumn + 1;
    const extraRowCount = Math.ceil(rowCount * EXTRA_BOUND);
    const extraColumnCount = Math.ceil(columnCount * EXTRA_BOUND);
    const rowStart = Math.max(Math.floor(startRow - extraRowCount), 0);
    const rowEnd = Math.min(Math.ceil(endRow + extraRowCount), rowHeightAccumulationLength - 1);
    const columnEnd = Math.min(Math.ceil(endColumn + extraColumnCount), columnWidthAccumulationLength - 1);
    const columnStart = Math.max(Math.floor(startColumn - extraColumnCount), 0);
    const startX = columnWidthAccumulation[columnStart - 1] || 0;
    const startY = rowHeightAccumulation[rowStart - 1] || 0;
    const endX = columnWidthAccumulation[columnEnd];
    const endY = rowHeightAccumulation[rowEnd];
    ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
    ctx.beginPath();
    ctx.moveToByPrecision(startX, startY);
    ctx.lineToByPrecision(endX, startY);
    ctx.moveToByPrecision(startX, startY);
    ctx.lineToByPrecision(startX, endY);
    ctx.closePathByEnv();
    ctx.stroke();
    for (let r = rowStart; r <= rowEnd; r++) {
      if (r < 0 || r > rowHeightAccumulationLength - 1) {
        continue;
      }
      const rowEndPosition = rowHeightAccumulation[r];
      ctx.beginPath();
      ctx.moveToByPrecision(startX, rowEndPosition);
      ctx.lineToByPrecision(endX, rowEndPosition);
      ctx.closePathByEnv();
      ctx.stroke();
    }
    for (let c = columnStart; c <= columnEnd; c++) {
      if (c < 0 || c > columnWidthAccumulationLength - 1) {
        continue;
      }
      const columnEndPosition = columnWidthAccumulation[c];
      ctx.beginPath();
      ctx.moveToByPrecision(columnEndPosition, startY);
      ctx.lineToByPrecision(columnEndPosition, endY);
      ctx.closePathByEnv();
      ctx.stroke();
    }
    this._clearRectangle(ctx, rowHeightAccumulation, columnWidthAccumulation, mergeCellRanges);
    this._clearRectangle(ctx, rowHeightAccumulation, columnWidthAccumulation, overflowCache.toNativeArray());
    ctx.restore();
  }
  /**
   * Clear the guide lines within a range in the table, to make room for merged cells and overflow.
   */
  _clearRectangle(ctx, rowHeightAccumulation, columnWidthAccumulation, cellRanges) {
    var _a, _b, _c, _d;
    if (cellRanges == null) {
      return;
    }
    for (const range of cellRanges) {
      const { startRow, endRow, startColumn, endColumn } = range;
      const startY = (_a = rowHeightAccumulation[startRow - 1]) != null ? _a : 0;
      const endY = (_b = rowHeightAccumulation[endRow]) != null ? _b : rowHeightAccumulation[rowHeightAccumulation.length - 1];
      const startX = (_c = columnWidthAccumulation[startColumn - 1]) != null ? _c : 0;
      const endX = (_d = columnWidthAccumulation[endColumn]) != null ? _d : columnWidthAccumulation[columnWidthAccumulation.length - 1];
      ctx.clearRectByPrecision(startX, startY, endX - startX, endY - startY);
      ctx.beginPath();
      ctx.moveToByPrecision(startX, startY);
      ctx.lineToByPrecision(endX, startY);
      ctx.lineToByPrecision(endX, endY);
      ctx.lineToByPrecision(startX, endY);
      ctx.lineToByPrecision(startX, startY);
      ctx.stroke();
      ctx.closePath();
    }
  }
  testShowRuler(cacheCtx, viewportInfo) {
    const { cacheBound } = viewportInfo;
    const spreadsheetSkeleton = this.getSkeleton();
    const { rowHeaderWidth, columnHeaderHeight } = spreadsheetSkeleton;
    const { left, top, right, bottom } = cacheBound;
    const findClosestHundred = (number) => {
      const remainder = number % 100;
      return number + (100 - remainder);
    };
    const startX = findClosestHundred(left);
    const endX = findClosestHundred(right);
    const startY = findClosestHundred(top);
    const endY = findClosestHundred(bottom);
    cacheCtx.save();
    cacheCtx.beginPath();
    cacheCtx.strokeStyle = "#000000";
    cacheCtx.fillStyle = "#000000";
    cacheCtx.font = "16px Arial";
    cacheCtx.lineWidth = 1;
    cacheCtx.textAlign = "center";
    cacheCtx.textBaseline = "middle";
    for (let i = startX; i <= endX; i += 50) {
      cacheCtx.beginPath();
      cacheCtx.strokeStyle = i % 100 === 0 ? "red" : "#aaa";
      cacheCtx.moveTo(i - rowHeaderWidth, top - columnHeaderHeight);
      cacheCtx.lineTo(i - rowHeaderWidth, bottom - columnHeaderHeight);
      cacheCtx.stroke();
      cacheCtx.closePath();
    }
    for (let j = startY; j <= endY; j += 50) {
      cacheCtx.beginPath();
      cacheCtx.strokeStyle = j % 100 === 0 ? "red" : "#aaa";
      cacheCtx.moveTo(left - rowHeaderWidth, j - columnHeaderHeight);
      cacheCtx.lineTo(right - rowHeaderWidth, j - columnHeaderHeight);
      cacheCtx.stroke();
      cacheCtx.closePath();
    }
    cacheCtx.fillStyle = "#666";
    for (let i = startX; i <= endX; i += 100) {
      for (let j = startY; j <= endY; j += 100) {
        cacheCtx.fillText(`${i},${j}`, i - rowHeaderWidth, j - columnHeaderHeight);
      }
    }
    cacheCtx.closePath();
    cacheCtx.restore();
  }
  testGetRandomLightColor() {
    const letters2 = "ABCDEF";
    let color = "#";
    for (let i = 0; i < 6; i++) {
      color += letters2[Math.floor(Math.random() * 6)];
    }
    const r = Number.parseInt(color.substring(1, 3), 16);
    const g = Number.parseInt(color.substring(3, 5), 16);
    const b = Number.parseInt(color.substring(5, 7), 16);
    if (r + g + b < 610) {
      return this.testGetRandomLightColor();
    }
    return color;
  }
};

// ../packages/engine-render/src/components/sheets/watermark/util.ts
function renderWatermark(ctx, config, image, userInfo) {
  const type2 = config.type;
  const watermarkConfig = config.config;
  if (type2 === "userInfo" /* UserInfo */ && watermarkConfig.userInfo) {
    renderUserInfoWatermark(ctx, watermarkConfig.userInfo, userInfo);
  } else if (type2 === "image" /* Image */ && watermarkConfig.image) {
    renderImageWatermark(ctx, watermarkConfig.image, image);
  } else if (type2 === "text" /* Text */ && watermarkConfig.text) {
    renderTextWatermark(ctx, watermarkConfig.text);
  }
}
function renderUserInfoWatermark(ctx, config, userInfo) {
  const { x, y, repeat, spacingX, spacingY, rotate, opacity, name, fontSize, color, bold, italic, direction } = config;
  if (!userInfo) {
    return;
  }
  let watermarkContent = "";
  if (name) {
    watermarkContent += `${userInfo.name} `;
  }
  if (!watermarkContent) {
    return;
  }
  ctx.save();
  ctx.globalAlpha = opacity;
  ctx.direction = direction;
  let fontStyle = "";
  if (italic) fontStyle += "italic ";
  if (bold) fontStyle += "bold ";
  fontStyle += `${fontSize}px Arial`;
  ctx.font = fontStyle;
  ctx.fillStyle = color;
  if (repeat) {
    const canvasWidth = ctx.canvas.width;
    const canvasHeight = ctx.canvas.height;
    for (let posY = y; posY < canvasHeight; posY += fontSize + spacingY) {
      for (let posX = x; posX < canvasWidth; posX += ctx.measureText(watermarkContent).width + spacingX) {
        ctx.save();
        ctx.translate(posX, posY);
        ctx.rotate(Math.PI / 180 * rotate);
        ctx.fillText(watermarkContent, 0, 0);
        ctx.restore();
      }
    }
  } else {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.PI / 180 * rotate);
    ctx.fillText(watermarkContent, 0, 0);
    ctx.restore();
  }
  ctx.restore();
}
function renderTextWatermark(ctx, config) {
  const { x, y, repeat, spacingX, spacingY, rotate, opacity, content, fontSize, color, bold, italic, direction } = config;
  ctx.save();
  ctx.globalAlpha = opacity;
  ctx.direction = direction;
  let fontStyle = "";
  if (italic) fontStyle += "italic ";
  if (bold) fontStyle += "bold ";
  fontStyle += `${fontSize}px Arial`;
  ctx.font = fontStyle;
  ctx.fillStyle = color;
  if (content) {
    if (repeat) {
      const canvasWidth = ctx.canvas.width;
      const canvasHeight = ctx.canvas.height;
      for (let posY = y; posY < canvasHeight; posY += fontSize + spacingY) {
        for (let posX = x; posX < canvasWidth; posX += ctx.measureText(content).width + spacingX) {
          ctx.save();
          ctx.translate(posX, posY);
          ctx.rotate(Math.PI / 180 * rotate);
          ctx.fillText(content, 0, 0);
          ctx.restore();
        }
      }
    } else {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.PI / 180 * rotate);
      ctx.fillText(content, 0, 0);
      ctx.restore();
    }
  }
  ctx.restore();
}
function renderImageWatermark(ctx, config, image) {
  const { x, y, repeat, spacingX, spacingY, rotate, opacity, width, height, maintainAspectRatio, originRatio } = config;
  if (!(image == null ? void 0 : image.complete)) {
    return;
  }
  ctx.save();
  ctx.globalAlpha = opacity;
  const actualWidth = maintainAspectRatio ? width : width;
  const actualHeight = maintainAspectRatio ? width / originRatio : height;
  if (repeat) {
    const canvasWidth = ctx.canvas.width;
    const canvasHeight = ctx.canvas.height;
    for (let posY = y; posY < canvasHeight; posY += actualHeight + spacingY) {
      for (let posX = x; posX < canvasWidth; posX += actualWidth + spacingX) {
        ctx.save();
        ctx.translate(posX, posY);
        ctx.rotate(Math.PI / 180 * rotate);
        ctx.drawImage(image, 0, 0, actualWidth, actualHeight);
        ctx.restore();
      }
    }
  } else {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.PI / 180 * rotate);
    ctx.drawImage(image, 0, 0, actualWidth, actualHeight);
    ctx.restore();
  }
  ctx.restore();
}

// ../packages/engine-render/src/components/sheets/watermark/watermark-layer.ts
var WatermarkLayer = class extends Layer {
  constructor() {
    super(...arguments);
    __publicField(this, "_config");
    __publicField(this, "_image");
    __publicField(this, "_user");
  }
  render(ctx, isMaxLayer = false) {
    var _a;
    super.render(ctx, isMaxLayer);
    const mainCtx = ctx || ((_a = this.scene.getEngine()) == null ? void 0 : _a.getCanvas().getContext());
    if (mainCtx && mainCtx.getId()) {
      this._renderWatermark(mainCtx);
    }
    return this;
  }
  updateConfig(config, user) {
    var _a;
    this._config = config;
    if (((_a = this._config) == null ? void 0 : _a.type) === "image" /* Image */ && this._config.config.image) {
      this._image = new Image();
      this._image.src = this._config.config.image.url;
    }
    if (user) {
      this._user = user;
    }
  }
  _renderWatermark(ctx) {
    if (this._config) {
      renderWatermark(ctx, this._config, this._image, this._user);
    }
  }
};

// ../packages/engine-render/src/components/sheets/watermark/index.ts
var UNIVER_WATERMARK_STORAGE_KEY = "UNIVER_WATERMARK_STORAGE_KEY";
var UNIVER_WATERMARK_LAYER_INDEX = 10;

// ../packages/engine-render/src/basics/quick-event.ts
function attachObjectHover(o, hoverIn, hoverOut) {
  o.onPointerEnter$.subscribeEvent((evt) => {
    hoverIn(o, evt);
  });
  o.onPointerLeave$.subscribeEvent((evt) => {
    hoverOut(o, evt);
  });
}

// ../packages/engine-render/src/scene-viewer.ts
var SceneViewer = class extends BaseObject {
  constructor(key, props) {
    super(key);
    __publicField(this, "_subScenes", /* @__PURE__ */ new Map());
    __publicField(this, "_activeSubScene");
    __publicField(this, "_allowSelectedClipElement", false);
    this._initialProps(props);
  }
  get classType() {
    return "SceneViewer" /* SCENE_VIEWER */;
  }
  render(mainCtx, bounds) {
    var _a;
    if (!this.visible) {
      this.makeDirty(false);
      return this;
    }
    if (bounds) {
      const { left, top, right, bottom } = bounds.cacheBound || bounds.viewBound;
      if (this.width + this.strokeWidth + this.left < left || right < this.left || this.height + this.strokeWidth + this.top < top || bottom < this.top) {
        return this;
      }
    }
    const m = this.transform.getMatrix();
    mainCtx.save();
    mainCtx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    (_a = this._activeSubScene) == null ? void 0 : _a.makeDirtyNoParent(true).render(mainCtx);
    mainCtx.restore();
    this.makeDirty(false);
    return this;
  }
  getSubScenes() {
    return this._subScenes;
  }
  getActiveSubScene() {
    return this._activeSubScene;
  }
  getSubScene(sceneKey) {
    for (const [key, scene] of this._subScenes) {
      if (key === sceneKey) {
        return scene;
      }
    }
  }
  addSubScene(scene) {
    this._activeSubScene = scene;
    this._subScenes.set(scene.sceneKey, scene);
    this.makeDirty();
  }
  removeSubScene(key) {
    const subScene = this._subScenes.get(key);
    this._subScenes.delete(key);
    if (this._activeSubScene === subScene) {
      this._activeSubScene = this._subScenes.values().next().value;
    }
    this.makeDirty();
  }
  activeSubScene(key) {
    if (key == null) {
      return;
    }
    const subScene = this._subScenes.get(key);
    if (this._activeSubScene !== subScene) {
      this._activeSubScene = subScene;
      this.makeDirty();
    }
  }
  enableSelectedClipElement() {
    this._allowSelectedClipElement = true;
  }
  disableSelectedClipElement() {
    this._allowSelectedClipElement = false;
  }
  allowSelectedClipElement() {
    return this._allowSelectedClipElement;
  }
  // 判断被选中的唯一对象
  pick(coord) {
    var _a;
    if (this._activeSubScene === void 0) {
      return;
    }
    const tCoord = this.transform.invert().applyPoint(coord);
    return (_a = this._activeSubScene) == null ? void 0 : _a.pick(tCoord);
  }
  dispose() {
    super.dispose();
    this._subScenes.forEach((scene) => {
      scene.dispose();
    });
  }
  _initialProps(props) {
    if (!props) {
      return;
    }
    const themeKeys = Object.keys(props);
    if (themeKeys.length === 0) {
      return;
    }
    const transformState = {};
    let hasTransformState = false;
    themeKeys.forEach((key) => {
      if (props[key] === void 0) {
        return true;
      }
      transformState[key] = props[key];
      hasTransformState = true;
    });
    if (hasTransformState) {
      this.transformByState(transformState);
    }
    this.makeDirty(true);
  }
};

// ../packages/engine-render/src/components/slides/slide.ts
var arrowPath = "M512 1024C229.248 1024 0 794.752 0 512S229.248 0 512 0s512 229.248 512 512-229.248 512-512 512z m200.746667-478.506667l1.749333-1.664 30.165333-30.165333-330.496-330.581333a42.837333 42.837333 0 0 0-60.288 0 42.538667 42.538667 0 0 0 0 60.330666l270.08 270.165334-270.08 269.952a42.496 42.496 0 0 0 0 60.288c16.64 16.64 43.861333 16.469333 60.288 0.042666l298.581334-298.368z";
var Slide = class extends SceneViewer {
  constructor() {
    super(...arguments);
    __publicField(this, "slideChangePageByNavigation$", new EventSubject());
    __publicField(this, "subSceneChanged$", new EventSubject());
    __publicField(this, "_navigationEnabled", false);
  }
  activeFirstPage() {
    const scenes = this.getSubScenes();
    const firstKey = scenes.keys().next().value;
    if (firstKey == null) {
      return;
    }
    this.changePage(firstKey);
  }
  /**
   * add pageScene to this._subScenes
   * @param pageScene
   */
  addPageScene(pageScene) {
    const key = pageScene.sceneKey;
    if (!this.getSubScene(key)) {
      this.addSubScene(pageScene);
    }
    this.addNavigation();
    this.subSceneChanged$.emitEvent(pageScene);
  }
  changePage(id) {
    if (id === null) {
      return;
    }
    this.removeNavigation();
    this.activeSubScene(id);
    this.addNavigation();
  }
  hasPage(key) {
    return this.getSubScene(key);
  }
  addNavigation() {
    const scene = this.getActiveSubScene();
    if (scene == null || this._navigationEnabled === false) {
      return;
    }
    const leftArrow = new Path3("__slideNavigationLeft__" /* LEFT */, {
      data: arrowPath,
      width: 60,
      height: 60,
      left: 90,
      top: (this.height - 30) / 2,
      fill: this._getArrowColor(),
      flipX: true
    });
    const rightArrow = new Path3("__slideNavigationRight__" /* RIGHT */, {
      data: arrowPath,
      width: 60,
      height: 60,
      left: this.width - 90,
      top: (this.height - 30) / 2,
      fill: this._getArrowColor()
    });
    const hoverIn = (o, evt) => {
      o.setCursor("pointer" /* POINTER */);
      o.setProps({
        fill: this._getArrowColor(true)
      });
    };
    const hoverOut = (o, evt) => {
      o.setCursor("default" /* DEFAULT */);
      o.setProps({
        fill: this._getArrowColor()
      });
    };
    attachObjectHover(leftArrow, hoverIn, hoverOut);
    attachObjectHover(rightArrow, hoverIn, hoverOut);
    this._addNavTrigger(leftArrow, rightArrow);
    scene.addObjects([leftArrow, rightArrow], 7);
  }
  removeNavigation() {
    var _a, _b;
    const scene = this.getActiveSubScene();
    if (scene == null || this._navigationEnabled === false) {
      return;
    }
    (_a = scene.getObject("__slideNavigationLeft__" /* LEFT */)) == null ? void 0 : _a.dispose();
    (_b = scene.getObject("__slideNavigationRight__" /* RIGHT */)) == null ? void 0 : _b.dispose();
  }
  enableNav() {
    this._navigationEnabled = true;
  }
  disableNav() {
    this._navigationEnabled = false;
  }
  hiddenNav() {
    var _a, _b;
    const scene = this.getActiveSubScene();
    if (scene == null || this._navigationEnabled === false) {
      return;
    }
    (_a = scene.getObject("__slideNavigationLeft__" /* LEFT */)) == null ? void 0 : _a.hide();
    (_b = scene.getObject("__slideNavigationRight__" /* RIGHT */)) == null ? void 0 : _b.hide();
  }
  showNav() {
    var _a, _b;
    const scene = this.getActiveSubScene();
    if (scene == null || this._navigationEnabled === false) {
      return;
    }
    (_a = scene.getObject("__slideNavigationLeft__" /* LEFT */)) == null ? void 0 : _a.show();
    (_b = scene.getObject("__slideNavigationRight__" /* RIGHT */)) == null ? void 0 : _b.show();
  }
  renderToThumb(mainCtx, pageId, scaleX = 1, scaleY = 1) {
    const scene = this.getSubScene(pageId);
    if (scene == null) {
      return;
    }
    mainCtx.save();
    mainCtx.scale(scaleX, scaleY);
    scene.makeDirtyNoParent(true).render(mainCtx);
    mainCtx.restore();
  }
  _getSubScenesIndex(key) {
    if (key == null) {
      return;
    }
    const subScenes = Array.from(this.getSubScenes());
    const subScenesLen = subScenes.length;
    let currentIndex = 0;
    for (let i = 0; i < subScenesLen; i++) {
      const [sceneKey] = subScenes[i];
      if (key === sceneKey) {
        currentIndex = i;
        break;
      }
    }
    let next = currentIndex + 1;
    let prev = currentIndex - 1;
    next = next >= subScenesLen ? 0 : next;
    prev = prev < 0 ? subScenesLen - 1 : prev;
    return {
      nextScene: subScenes[next][1],
      previousScene: subScenes[prev][1]
    };
  }
  _addNavTrigger(leftArrow, rightArrow) {
    leftArrow.onPointerDown$.subscribeEvent(() => {
      var _a;
      const result = this._getSubScenesIndex((_a = this.getActiveSubScene()) == null ? void 0 : _a.sceneKey);
      const prevKey = result == null ? void 0 : result.previousScene.sceneKey;
      this.changePage(prevKey);
      this.slideChangePageByNavigation$.emitEvent(prevKey);
    });
    rightArrow.onPointerDown$.subscribeEvent(() => {
      var _a;
      const result = this._getSubScenesIndex((_a = this.getActiveSubScene()) == null ? void 0 : _a.sceneKey);
      const nextKey = result == null ? void 0 : result.nextScene.sceneKey;
      this.changePage(nextKey);
      this.slideChangePageByNavigation$.emitEvent(nextKey);
    });
  }
  _getArrowColor(isHover = false) {
    if (isHover) {
      return getColor(COLORS.white, 0.8);
    }
    return getColor(COLORS.white, 0.5);
  }
};

// ../packages/engine-render/src/components/docs/doc-background.ts
var PAGE_STROKE_COLOR = "rgba(198, 198, 198, 1)";
var PAGE_FILL_COLOR = "rgba(255, 255, 255, 1)";
var MARGIN_STROKE_COLOR = "rgba(158, 158, 158, 1)";
var DocBackground = class _DocBackground extends DocComponent {
  constructor(oKey, documentSkeleton, config) {
    super(oKey, documentSkeleton, config);
    __publicField(this, "_drawLiquid");
    this._drawLiquid = new Liquid();
    this.makeDirty(true);
  }
  static create(oKey, documentSkeleton, config) {
    return new _DocBackground(oKey, documentSkeleton, config);
  }
  draw(ctx, bounds) {
    var _a, _b;
    const skeletonData = (_a = this.getSkeleton()) == null ? void 0 : _a.getSkeletonData();
    const docDataModel = (_b = this.getSkeleton()) == null ? void 0 : _b.getViewModel().getDataModel();
    if (skeletonData == null || docDataModel == null) {
      return;
    }
    const { documentFlavor } = docDataModel.getSnapshot().documentStyle;
    if (documentFlavor !== 1 /* TRADITIONAL */) {
      return;
    }
    this._drawLiquid.reset();
    const { pages } = skeletonData;
    let pageTop = 0;
    let pageLeft = 0;
    for (let i = 0, len = pages.length; i < len; i++) {
      const page = pages[i];
      if (this.isSkipByDiffBounds(page, pageTop, pageLeft, bounds)) {
        const { x: x2, y: y2 } = this._drawLiquid.translatePage(
          page,
          this.pageLayoutType,
          this.pageMarginLeft,
          this.pageMarginTop
        );
        pageLeft += x2;
        pageTop += y2;
        continue;
      }
      const { width, pageWidth, height, pageHeight, originMarginTop, originMarginBottom, marginLeft, marginRight } = page;
      ctx.save();
      ctx.translate(pageLeft - 0.5, pageTop - 0.5);
      const backgroundOptions = {
        width: pageWidth != null ? pageWidth : width,
        height: pageHeight != null ? pageHeight : height,
        strokeWidth: 1,
        stroke: PAGE_STROKE_COLOR,
        fill: PAGE_FILL_COLOR,
        zIndex: 3
      };
      Rect.drawWith(ctx, backgroundOptions);
      const IDENTIFIER_WIDTH = 15;
      const marginIdentification = {
        dataArray: [{
          command: "M",
          points: [marginLeft - IDENTIFIER_WIDTH, originMarginTop]
        }, {
          command: "L",
          points: [marginLeft, originMarginTop]
        }, {
          command: "L",
          points: [marginLeft, originMarginTop - IDENTIFIER_WIDTH]
        }, {
          command: "M",
          points: [pageWidth - marginRight + IDENTIFIER_WIDTH, originMarginTop]
        }, {
          command: "L",
          points: [pageWidth - marginRight, originMarginTop]
        }, {
          command: "L",
          points: [pageWidth - marginRight, originMarginTop - IDENTIFIER_WIDTH]
        }, {
          command: "M",
          points: [marginLeft - IDENTIFIER_WIDTH, pageHeight - originMarginBottom]
        }, {
          command: "L",
          points: [marginLeft, pageHeight - originMarginBottom]
        }, {
          command: "L",
          points: [marginLeft, pageHeight - originMarginBottom + IDENTIFIER_WIDTH]
        }, {
          command: "M",
          points: [pageWidth - marginRight + IDENTIFIER_WIDTH, pageHeight - originMarginBottom]
        }, {
          command: "L",
          points: [pageWidth - marginRight, pageHeight - originMarginBottom]
        }, {
          command: "L",
          points: [pageWidth - marginRight, pageHeight - originMarginBottom + IDENTIFIER_WIDTH]
        }],
        strokeWidth: 1.5,
        stroke: MARGIN_STROKE_COLOR
      };
      Path3.drawWith(ctx, marginIdentification);
      ctx.restore();
      const { x, y } = this._drawLiquid.translatePage(
        page,
        this.pageLayoutType,
        this.pageMarginLeft,
        this.pageMarginTop
      );
      pageLeft += x;
      pageTop += y;
    }
  }
  changeSkeleton(newSkeleton) {
    this.setSkeleton(newSkeleton);
    return this;
  }
  _draw(ctx, bounds) {
    this.draw(ctx, bounds);
  }
};

// ../packages/engine-render/src/basics/viewport-subtract.ts
function subtractViewportRange(range1, range2) {
  if (range2.startRow >= range1.endRow || range2.endRow <= range1.startRow || range2.startColumn >= range1.endColumn || range2.endColumn <= range1.startColumn) {
    return [range1];
  }
  const ranges = [];
  if (range2.startRow > range1.startRow) {
    ranges.push({
      startRow: range1.startRow,
      startColumn: range1.startColumn,
      endRow: range2.startRow,
      endColumn: range1.endColumn
    });
  }
  if (range2.endRow < range1.endRow) {
    ranges.push({
      startRow: range2.endRow,
      startColumn: range1.startColumn,
      endRow: range1.endRow,
      endColumn: range1.endColumn
    });
  }
  const topBoundary = Math.max(range1.startRow, range2.startRow);
  const bottomBoundary = Math.min(range1.endRow, range2.endRow);
  if (range2.startColumn > range1.startColumn) {
    ranges.push({
      startRow: topBoundary,
      startColumn: range1.startColumn,
      endRow: bottomBoundary,
      endColumn: range2.startColumn
    });
  }
  if (range2.endColumn < range1.endColumn) {
    ranges.push({
      startRow: topBoundary,
      startColumn: range2.endColumn,
      endRow: bottomBoundary,
      endColumn: range1.endColumn
    });
  }
  return ranges;
}

// ../packages/engine-render/src/viewport.ts
var MOUSE_WHEEL_SPEED_SMOOTHING_FACTOR = 3;
var Viewport = class {
  constructor(viewportKey, scene, props) {
    __publicField(this, "_viewportKey", "");
    /**
     * scrollX means scroll x value for scrollbar in viewMain
     * use getBarScroll to get scrolling value(scrollX, scrollY) for scrollbar
     */
    __publicField(this, "_scrollX", 0);
    __publicField(this, "_scrollY", 0);
    __publicField(this, "_preScrollX", 0);
    __publicField(this, "_preScrollY", 0);
    /**
     * The viewport scroll offset equals the distance from the content area position to the top, and there is a conversion relationship with scrollX and scrollY
     * use transScroll2ViewportScrollValue to get scrolling value for spreadsheet.
     */
    __publicField(this, "_viewportScrollX", 0);
    __publicField(this, "_viewportScrollY", 0);
    __publicField(this, "_preViewportScrollX", 0);
    __publicField(this, "_preViewportScrollY", 0);
    /**
     * scene size in current viewport port with scale
     * scene size relative to row col settings.
     * if AB col has set to be freeze, then scene size in viewMain will be smaller compared to no freeze state.
     */
    __publicField(this, "_sceneWCurrVpAfterScale", 0);
    __publicField(this, "_sceneHCurrVpAfterScale", 0);
    /**
     * scene size with scale
     */
    __publicField(this, "_sceneWidthAfterScale");
    __publicField(this, "_sceneHeightAfterScale");
    __publicField(this, "onMouseWheel$", new EventSubject());
    __publicField(this, "onScrollAfter$", new EventSubject());
    __publicField(this, "onScrollEnd$", new EventSubject());
    __publicField(this, "onScrollByBar$", new EventSubject());
    __publicField(this, "onResized$", new Subject());
    /**
     * viewport top origin value in logic, scale does not affect it.
     */
    __publicField(this, "_topOrigin", 0);
    /**
     * viewport left origin value in logic, scale does not affect it.
     */
    __publicField(this, "_leftOrigin", 0);
    __publicField(this, "_bottomOrigin", 0);
    __publicField(this, "_rightOrigin", 0);
    __publicField(this, "_widthOrigin");
    __publicField(this, "_heightOrigin");
    /**
     * this._topOrigin * scaleY;
     */
    __publicField(this, "_top", 0);
    /**
     * this._leftOrigin * scaleX;
     */
    __publicField(this, "_left", 0);
    __publicField(this, "_bottom", 0);
    __publicField(this, "_right", 0);
    __publicField(this, "_width");
    __publicField(this, "_height");
    __publicField(this, "_scene");
    __publicField(this, "_scrollBar");
    __publicField(this, "_isWheelPreventDefaultX", false);
    __publicField(this, "_isWheelPreventDefaultY", false);
    __publicField(this, "_scrollStopNum", 0);
    __publicField(this, "_clipViewport", true);
    __publicField(this, "_active", true);
    /**
     * after create a freeze column & row, there is a "padding distance" from row header to curr viewport.
     */
    __publicField(this, "_paddingStartX", 0);
    __publicField(this, "_paddingEndX", 0);
    __publicField(this, "_paddingStartY", 0);
    __publicField(this, "_paddingEndY", 0);
    /**
     * viewbound of cache area, cache area is slightly bigger than viewbound.
     */
    __publicField(this, "_cacheBound");
    __publicField(this, "_preCacheBound");
    __publicField(this, "_preCacheVisibleBound");
    /**
     * bound of visible area
     */
    __publicField(this, "_viewBound", { top: 0, left: 0, bottom: 0, right: 0 });
    __publicField(this, "_preViewBound");
    /**
     *  Whether the viewport needs to be updated.
     *  In future, viewMain dirty would not affect other viewports.
     */
    __publicField(this, "_isDirty", true);
    /**
     * Canvas for cache if allowCache is true.
     */
    __publicField(this, "_cacheCanvas", null);
    /**
     * The configuration comes from the props.allowCache passed in during viewport initialization.
     * When _allowCache is true, a cacheCanvas will be created.
     */
    __publicField(this, "_allowCache", false);
    /**
     * Buffer Area size, default is zero
     */
    __publicField(this, "bufferEdgeX", 0);
    __publicField(this, "bufferEdgeY", 0);
    __publicField(this, "_isForceDirty", true);
    var _a;
    this._viewportKey = viewportKey;
    this._scene = scene;
    this._scene.addViewport(this);
    this._active = Tools.isDefine(props == null ? void 0 : props.active) ? props == null ? void 0 : props.active : true;
    this.setViewportSize(props);
    this.initCacheCanvas(props);
    this._isWheelPreventDefaultX = (props == null ? void 0 : props.isWheelPreventDefaultX) || false;
    this._isWheelPreventDefaultY = (props == null ? void 0 : props.isWheelPreventDefaultY) || false;
    this.resetCanvasSizeAndUpdateScroll();
    this.getBounding();
    (_a = this.scene.getEngine()) == null ? void 0 : _a.onTransformChange$.subscribeEvent(() => {
      this.markForceDirty(true);
    });
    this.markForceDirty(true);
  }
  initCacheCanvas(props) {
    this._allowCache = (props == null ? void 0 : props.allowCache) || false;
    if (this._allowCache) {
      this._cacheCanvas = new Canvas();
      this.bufferEdgeX = (props == null ? void 0 : props.bufferEdgeX) || 0;
      this.bufferEdgeY = (props == null ? void 0 : props.bufferEdgeY) || 0;
    }
  }
  get scene() {
    return this._scene;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get viewportKey() {
    return this._viewportKey;
  }
  get topOrigin() {
    return this._topOrigin;
  }
  get leftOrigin() {
    return this._leftOrigin;
  }
  get bottomOrigin() {
    return this._bottomOrigin;
  }
  get rightOrigin() {
    return this._rightOrigin;
  }
  get top() {
    return this._top;
  }
  get left() {
    return this._left;
  }
  get bottom() {
    return this._bottom;
  }
  get right() {
    return this._right;
  }
  get isWheelPreventDefaultX() {
    return this._isWheelPreventDefaultX;
  }
  get isWheelPreventDefaultY() {
    return this._isWheelPreventDefaultY;
  }
  set width(w) {
    this._width = w;
  }
  set height(height) {
    const maxHeight = this.scene.getParent().height;
    if (Tools.isDefine(height)) {
      this._height = Tools.clamp(height, 0, maxHeight);
    } else {
      this._height = height;
    }
  }
  get isActive() {
    if (this._active === false) {
      return false;
    }
    if ((this.height || 0) <= 0 || (this.width || 0) <= 0) {
      return false;
    }
    return this._active;
  }
  set viewportScrollX(val) {
    this._viewportScrollX = val;
  }
  get viewportScrollX() {
    return this._viewportScrollX;
  }
  set viewportScrollY(val) {
    this._viewportScrollY = val;
  }
  get viewportScrollY() {
    return this._viewportScrollY;
  }
  set scrollX(val) {
    this._scrollX = val;
  }
  set scrollY(val) {
    this._scrollY = val;
  }
  get scrollX() {
    return this._scrollX;
  }
  get scrollY() {
    return this._scrollY;
  }
  set top(num) {
    var _a, _b;
    this._topOrigin = num;
    this._top = toPx(num, (_b = (_a = this._scene) == null ? void 0 : _a.getParent()) == null ? void 0 : _b.height);
  }
  set left(num) {
    var _a;
    this._leftOrigin = num;
    this._left = toPx(num, (_a = this.scene.getParent()) == null ? void 0 : _a.width);
  }
  set bottom(num) {
    var _a;
    this._bottomOrigin = num;
    this._bottom = toPx(num, (_a = this.scene.getParent()) == null ? void 0 : _a.height);
  }
  set right(num) {
    var _a;
    this._rightOrigin = num;
    this._right = toPx(num, (_a = this.scene.getParent()) == null ? void 0 : _a.width);
  }
  get viewBound() {
    return this._viewBound;
  }
  get cacheBound() {
    return this._cacheBound;
  }
  set cacheBound(val) {
    this._cacheBound = val;
  }
  get preCacheBound() {
    return this._preCacheBound;
  }
  set preCacheBound(val) {
    this._preCacheBound = val;
    this._preCacheVisibleBound = Object.assign({}, val);
  }
  get _deltaScrollX() {
    return this.scrollX - this._preScrollX;
  }
  get _deltaScrollY() {
    return this.scrollY - this._preScrollY;
  }
  get _deltaViewportScrollX() {
    return this.viewportScrollX - this._preViewportScrollX;
  }
  get _deltaViewportScrollY() {
    return this.viewportScrollY - this._preViewportScrollY;
  }
  get canvas() {
    return this._cacheCanvas;
  }
  enable() {
    this._active = true;
  }
  disable() {
    this._active = false;
  }
  /**
   * canvas resize & freeze change would invoke this method
   */
  resetCanvasSizeAndUpdateScroll() {
    this._resizeCacheCanvas();
    this._updateScrollByViewportScrollValue();
    this.onResized$.next({
      width: this._width,
      height: this._height,
      left: this._left,
      top: this._top,
      paddingStartX: this._paddingStartX,
      paddingEndX: this._paddingEndX,
      paddingStartY: this._paddingStartY,
      paddingEndY: this._paddingEndY
    });
  }
  setScrollBar(instance) {
    this._scrollBar = instance;
    this._updateScrollByViewportScrollValue();
  }
  removeScrollBar() {
    this._scrollBar = null;
  }
  /**
   * NOT same as resetCanvasSizeAndScrollbar
   * This method is triggered when adjusting the frozen row & col settings, and during initialization,
   * it is not triggered when resizing the window.
   *
   * Note that the 'position' parameter may not always have 'height' and 'width' properties. For the 'viewMain' element, it only has 'left', 'top', 'bottom', and 'right' properties.
   * Additionally, 'this.width' and 'this.height' may also be 'undefined'.
   * Therefore, you should use the '_getViewPortSize' method to retrieve the width and height.
   * @param position
   */
  resizeWhenFreezeChange(position) {
    const positionKeys = Object.keys(position);
    if (positionKeys.length === 0) {
      return;
    }
    this.setViewportSize(position);
    this.resetCanvasSizeAndUpdateScroll();
  }
  setPadding(param) {
    const { startX = 0, startY = 0, endX = 0, endY = 0 } = param;
    this._paddingStartX = startX;
    this._paddingEndX = endX;
    this._paddingStartY = startY;
    this._paddingEndY = endY;
    this.resetCanvasSizeAndUpdateScroll();
  }
  resetPadding() {
    this.setPadding({
      startX: 0,
      endX: 0,
      startY: 0,
      endY: 0
    });
  }
  /**
   * ScrollBar scroll to certain position.
   * @param pos position of scrollBar
   */
  // There are serval cases to call this method.
  // the most common case is scrolling. Other situations include:
  // 1. changing the frozen row & col settings
  // 2. changing curr skeleton
  // 3. changing selection which cross viewport
  // 4. changing the viewport size (also include change window size)
  // 5. changing the scroll bar position(click at certain pos of scroll track)
  // Debug
  // scene.getViewports()[0].scrollTo({x: 14.2, y: 1.8}, true)
  scrollToBarPos(pos) {
    return this._scrollToBarPosCore(pos);
  }
  /**
   * Scrolling by current position plus delta.
   * the most common case is triggered by scroll-timer(in sheet)
   * @param delta
   * @returns isLimited
   */
  scrollByBarDeltaValue(delta, isTrigger = true) {
    const x = this.scrollX + (delta.x || 0);
    const y = this.scrollY + (delta.y || 0);
    return this._scrollToBarPosCore({ x, y }, isTrigger);
  }
  /**
   * Viewport scroll to certain position.
   * @param pos
   * @param isTrigger
   * @returns {ILimitedScrollResult | null | undefined}
   */
  scrollToViewportPos(pos, isTrigger = true) {
    if (!this._scrollBar || this.isActive === false) {
      return;
    }
    const { viewportScrollX, viewportScrollY } = pos;
    return this._scrollToViewportPosCore({ viewportScrollX, viewportScrollY }, isTrigger);
  }
  /**
   * Scrolling by current position plus delta.
   * if viewport can not scroll(e.g. viewport size is bigger than content size), then return null.
   * @param delta
   * @param isTrigger
   * @returns {ILimitedScrollResult | null | undefined}
   */
  scrollByViewportDeltaVal(delta, isTrigger = true) {
    if (!this._scrollBar || this.isActive === false) {
      return;
    }
    const viewportScrollX = this.viewportScrollX + (delta.viewportScrollX || 0);
    const viewportScrollY = this.viewportScrollY + (delta.viewportScrollY || 0);
    return this._scrollToViewportPosCore({ viewportScrollX, viewportScrollY }, isTrigger);
  }
  transViewportScroll2ScrollValue(viewportScrollX, viewportScrollY) {
    let x = viewportScrollX - this._paddingStartX;
    let y = viewportScrollY - this._paddingStartY;
    if (this._scrollBar) {
      x *= this._scrollBar.ratioScrollX;
      y *= this._scrollBar.ratioScrollY;
      const { scaleX, scaleY } = this.scene;
      x *= scaleX;
      y *= scaleY;
    } else {
      if (this.scrollX !== void 0) {
        x = this.scrollX;
      }
      if (this.scrollY !== void 0) {
        y = this.scrollY;
      }
    }
    return {
      x,
      y
    };
  }
  transScroll2ViewportScrollValue(scrollX, scrollY) {
    let x = scrollX;
    let y = scrollY;
    if (this._scrollBar) {
      const { scaleX: scaleX2, scaleY: scaleY2 } = this.scene;
      if (this._scrollBar.ratioScrollX !== 0) {
        x /= this._scrollBar.ratioScrollX;
        x /= scaleX2;
      } else if (this.viewportScrollX !== void 0) {
        x = this.viewportScrollX;
      } else {
        x = 0;
      }
      if (this._scrollBar.ratioScrollY !== 0) {
        y /= this._scrollBar.ratioScrollY;
        y /= scaleY2;
      } else if (this.viewportScrollY !== void 0) {
        y = this.viewportScrollY;
      } else {
        y = 0;
      }
    } else {
      if (this.viewportScrollX !== void 0) {
        x = this.viewportScrollX;
      } else {
        x = 0;
      }
      if (this.viewportScrollY !== void 0) {
        y = this.viewportScrollY;
      } else {
        y = 0;
      }
    }
    const { scaleX, scaleY } = this._scene.getPrecisionScale();
    return {
      x: fixLineWidthByScale(x + this._paddingStartX, scaleX),
      y: fixLineWidthByScale(y + this._paddingStartY, scaleY)
    };
  }
  /**
   * get actual scroll value by scrollXY
   */
  getViewportScrollByScrollXY() {
    const x = this.scrollX;
    const y = this.scrollY;
    return this.transScroll2ViewportScrollValue(x, y);
  }
  getScrollBar() {
    return this._scrollBar;
  }
  /**
   * Just record state of scroll. This method won't scroll viewport and scrollbar.
   * TODO: @lumixraku this method is so wried, viewportMain did not call it, now only called in freeze situation.
   * @param current
   * @returns Viewport
   */
  updateScrollVal(current) {
    this._preScrollX = this.scrollX;
    this._preScrollY = this.scrollY;
    const { scrollX, scrollY, viewportScrollX, viewportScrollY } = current;
    if (scrollX !== void 0) {
      this.scrollX = scrollX;
    }
    if (scrollY !== void 0) {
      this.scrollY = scrollY;
    }
    if (viewportScrollX !== void 0) {
      this._preViewportScrollX = this.viewportScrollX;
      this.viewportScrollX = viewportScrollX;
    }
    if (viewportScrollY !== void 0) {
      this._preViewportScrollY = this.viewportScrollY;
      this.viewportScrollY = viewportScrollY;
    }
    return this;
  }
  getScrollBarTransForm() {
    const composeResult = Transform.create();
    composeResult.multiply(Transform.create([1, 0, 0, 1, this._left, this._top]));
    return composeResult;
  }
  shouldIntoRender() {
    if (this.isActive === false || this.width == null || this.height == null || this.width <= 1 || this.height <= 1) {
      return false;
    }
    return true;
  }
  /**
   * Render function in each render loop.
   * @param parentCtx parentCtx is cacheCtx from layer when layer._allowCache is true
   * @param objects
   * @param isMaxLayer
   */
  render(parentCtx, objects = [], isMaxLayer = false) {
    var _a;
    if (!this.shouldIntoRender()) {
      return;
    }
    const mainCtx = parentCtx || ((_a = this._scene.getEngine()) == null ? void 0 : _a.getCanvas().getContext());
    const sceneTrans = this._scene.transform.clone();
    sceneTrans.multiply(Transform.create([1, 0, 0, 1, -this.viewportScrollX || 0, -this.viewportScrollY || 0]));
    const tm = sceneTrans.getMatrix();
    mainCtx.save();
    if (this._clipViewport) {
      mainCtx.beginPath();
      mainCtx.rect(this.left, this.top, this.width || 0, this.height || 0);
      mainCtx.clip();
    }
    mainCtx.transform(tm[0], tm[1], tm[2], tm[3], tm[4], tm[5]);
    const viewPortInfo = this.calcViewportInfo();
    for (let i = 0, length = objects.length; i < length; i++) {
      objects[i].render(mainCtx, viewPortInfo);
    }
    this.markDirty(false);
    this.markForceDirty(false);
    this._preViewBound = this._viewBound;
    if (viewPortInfo.shouldCacheUpdate) {
      this.preCacheBound = this._cacheBound;
    }
    mainCtx.restore();
    if (this._scrollBar && isMaxLayer) {
      mainCtx.save();
      const scrollbarTM = this.getScrollBarTransForm().getMatrix();
      mainCtx.transform(scrollbarTM[0], scrollbarTM[1], scrollbarTM[2], scrollbarTM[3], scrollbarTM[4], scrollbarTM[5]);
      this._drawScrollbar(mainCtx);
      mainCtx.restore();
    }
    this._afterRender();
  }
  _makeDefaultViewport() {
    return {
      viewBound: {
        left: -1,
        top: -1,
        right: -1,
        bottom: -1
      },
      diffBounds: [],
      diffX: -1,
      diffY: -1,
      viewPortPosition: {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      },
      viewportKey: this.viewportKey,
      isDirty: 0,
      isForceDirty: this.isForceDirty,
      allowCache: false,
      cacheBound: {
        left: -1,
        top: -1,
        right: -1,
        bottom: -1
      },
      diffCacheBounds: [],
      cacheViewPortPosition: {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      },
      shouldCacheUpdate: 0,
      sceneTrans: Transform.create([1, 0, 0, 1, 0, 0]),
      leftOrigin: 0,
      topOrigin: 0,
      bufferEdgeX: this.bufferEdgeX,
      bufferEdgeY: this.bufferEdgeY
    };
  }
  // eslint-disable-next-line max-lines-per-function
  calcViewportInfo() {
    if (this.isActive === false) {
      return this._makeDefaultViewport();
    }
    const sceneTrans = this._scene.transform.clone();
    let width = this._width;
    let height = this._height;
    const size = this._calcViewPortSize();
    width = size.width;
    height = size.height;
    const xFrom = this.left;
    const xTo = (width || 0) + this.left;
    const yFrom = this.top;
    const yTo = (height || 0) + this.top;
    const topLeft = this.transformVector2SceneCoord(Vector2.FromArray([xFrom, yFrom]));
    const bottomRight = this.transformVector2SceneCoord(Vector2.FromArray([xTo, yTo]));
    const viewBound = {
      left: topLeft.x,
      right: bottomRight.x,
      top: topLeft.y,
      bottom: bottomRight.y
    };
    this._viewBound = viewBound;
    const preViewBound = this._preViewBound;
    const diffBounds = this._diffViewBound(viewBound, preViewBound);
    const diffX = ((preViewBound == null ? void 0 : preViewBound.left) || 0) - viewBound.left;
    const diffY = ((preViewBound == null ? void 0 : preViewBound.top) || 0) - viewBound.top;
    const viewPortPosition = {
      top: yFrom,
      left: xFrom,
      bottom: yTo,
      right: xTo
    };
    const cacheBound = this.expandBounds(viewBound);
    this.cacheBound = cacheBound;
    if (!this.preCacheBound) {
      this.preCacheBound = this.expandBounds(viewBound);
    }
    let diffCacheBounds = [];
    if (this._preCacheVisibleBound) {
      if (diffX < 0) {
        this._preCacheVisibleBound.left -= diffX;
      } else if (diffX > 0) {
        this._preCacheVisibleBound.right -= diffX;
      }
      if (diffY < 0) {
        this._preCacheVisibleBound.top -= diffY;
      } else if (diffY > 0) {
        this._preCacheVisibleBound.bottom -= diffY;
      }
    }
    const cacheViewPortPosition = this.expandBounds(viewPortPosition);
    const shouldCacheUpdate = this._calcCacheUpdate(viewBound, this._preCacheVisibleBound, diffX, diffY);
    if (shouldCacheUpdate) {
      diffCacheBounds = this._calcDiffCacheBound(this._preCacheBound, cacheBound);
    }
    return {
      viewBound,
      diffBounds,
      diffX,
      diffY,
      viewPortPosition,
      viewportKey: this.viewportKey,
      isDirty: this.isDirty ? 2 : 0,
      isForceDirty: this.isForceDirty,
      allowCache: this._allowCache,
      cacheBound,
      diffCacheBounds,
      cacheViewPortPosition,
      shouldCacheUpdate,
      sceneTrans,
      cacheCanvas: this._cacheCanvas,
      leftOrigin: this._leftOrigin,
      topOrigin: this._topOrigin,
      bufferEdgeX: this.bufferEdgeX,
      bufferEdgeY: this.bufferEdgeY,
      updatePrevCacheBounds: (viewbound) => {
        this.updatePrevCacheBounds(viewbound);
      }
    };
  }
  /**
   * Get viewport info
   * @deprecated use `calcViewportInfo`
   */
  getBounding() {
    return this.calcViewportInfo();
  }
  /**
   * convert vector to scene coordinate, include row & col
   * @param vec
   * @returns Vector2
   */
  transformVector2SceneCoord(vec) {
    const sceneTrans = this.scene.transform.clone().invert();
    const scroll = this.getViewportScrollByScrollXY();
    const svCoord = sceneTrans.applyPoint(vec).add(Vector2.FromArray([scroll.x, scroll.y]));
    return svCoord;
  }
  getAbsoluteVector(coord) {
    const sceneTrans = this.scene.transform.clone();
    const scroll = this.getViewportScrollByScrollXY();
    const svCoord = sceneTrans.applyPoint(coord.subtract(Vector2.FromArray([scroll.x, scroll.y])));
    return svCoord;
  }
  /**
   * At f7140a7c11, only doc need this method.
   * In sheet, wheel event is handled by scroll.render-controller@scene.onMouseWheel$
   * @param evt
   * @param state
   */
  onMouseWheel(evt, state) {
    if (!this._scrollBar || this.isActive === false) {
      return;
    }
    let offsetX = 0;
    let offsetY = 0;
    const allWidth = this._scene.width;
    const viewWidth = this.width || 1;
    offsetX = viewWidth / allWidth * evt.deltaX;
    const allHeight = this._scene.height;
    const viewHeight = this.height || 1;
    if (evt.shiftKey) {
      offsetX = viewHeight / allHeight * evt.deltaY * MOUSE_WHEEL_SPEED_SMOOTHING_FACTOR;
    } else {
      offsetY = viewHeight / allHeight * evt.deltaY;
    }
    const isLimitedStore = this.scrollByBarDeltaValue({
      x: offsetX,
      y: offsetY
    });
    if (isLimitedStore && !isLimitedStore.isLimitedX && !isLimitedStore.isLimitedY) {
      evt.preventDefault();
      if (this._scene.getParent().classType === "SceneViewer" /* SCENE_VIEWER */) {
        state.stopPropagation();
      }
    }
    if (this._isWheelPreventDefaultX && this._isWheelPreventDefaultY) {
      evt.preventDefault();
    }
    this._scene.makeDirty(true);
  }
  /**
   * Check if coord is in viewport.
   * Coord is relative to canvas (scale is handled in isHit, Just pass in the original coord from event)
   * @param coord
   * @returns {boolean} is in viewport
   */
  isHit(coord) {
    if (this.isActive === false) {
      return false;
    }
    const { width, height } = this._calcViewPortSize();
    if (coord.x >= this.left && coord.x <= this.left + (width || 0) && coord.y >= this.top && coord.y <= this.top + (height || 0)) {
      return true;
    }
    return false;
  }
  pickScrollBar(coord) {
    if (!this._scrollBar) {
      return;
    }
    const scrollBarTrans = this.getScrollBarTransForm();
    const svCoord = scrollBarTrans.invert().applyPoint(coord);
    return this._scrollBar.pick(svCoord);
  }
  openClip() {
    this._clipViewport = true;
  }
  closeClip() {
    this._clipViewport = false;
  }
  dispose() {
    var _a, _b;
    this.onMouseWheel$.complete();
    this.onScrollAfter$.complete();
    this.onScrollEnd$.complete();
    (_a = this._scrollBar) == null ? void 0 : _a.dispose();
    (_b = this._cacheCanvas) == null ? void 0 : _b.dispose();
    this._scene.removeViewport(this._viewportKey);
  }
  limitedScroll(scrollX, scrollY) {
    var _a, _b;
    if (!this._scrollBar) {
      return {
        scrollX: 0,
        scrollY: 0,
        isLimitedX: false,
        isLimitedY: false
      };
    }
    scrollX = scrollX != null ? scrollX : this.scrollX;
    scrollY = scrollY != null ? scrollY : this.scrollY;
    const { height, width } = this._calcViewPortSize();
    if (this._sceneWCurrVpAfterScale <= width) {
      scrollX = 0;
    }
    if (this._sceneHCurrVpAfterScale <= height) {
      scrollY = 0;
    }
    const limitX = (_a = this._scrollBar) == null ? void 0 : _a.limitX;
    const limitY = (_b = this._scrollBar) == null ? void 0 : _b.limitY;
    let isLimitedX = false;
    let isLimitedY = false;
    if (scrollX < 0 || scrollX > limitX) {
      isLimitedX = true;
    }
    if (scrollY < 0 || scrollY > limitY) {
      isLimitedY = true;
    }
    scrollX = Tools.clamp(scrollX, 0, limitX);
    scrollY = Tools.clamp(scrollY, 0, limitY);
    return {
      scrollX,
      scrollY,
      isLimitedX,
      isLimitedY
    };
  }
  /**
   * Still in working progress, do not use it now.
   * @param viewportScrollX
   * @param viewportScrollY
   */
  _limitViewportScroll(viewportScrollX, viewportScrollY) {
    const { width, height } = this._calcViewPortSize();
    const freezeHeight = this._paddingEndY - this._paddingStartY;
    const freezeWidth = this._paddingEndX - this._paddingStartX;
    const scaleY = this.scene.scaleY;
    const scaleX = this.scene.scaleX;
    const maxViewportScrollX = this._sceneWidthAfterScale - freezeWidth * scaleX - width;
    const maxViewportScrollY = this._sceneHeightAfterScale - freezeHeight * scaleY - height;
    return {
      viewportScrollX: Tools.clamp(viewportScrollX, this._paddingStartX, maxViewportScrollX / scaleX),
      viewportScrollY: Tools.clamp(viewportScrollY, this._paddingStartY, maxViewportScrollY / scaleY),
      isLimitedX: viewportScrollX > maxViewportScrollX,
      isLimitedY: viewportScrollY > maxViewportScrollY
    };
  }
  markDirty(state) {
    if (state === void 0) {
      state = true;
    }
    this._isDirty = state;
  }
  get isDirty() {
    return this._isDirty;
  }
  markForceDirty(state) {
    if (state === void 0) {
      state = true;
    }
    this._isForceDirty = state;
  }
  resetPrevCacheBounds() {
    this._preCacheBound = null;
  }
  get isForceDirty() {
    return this._isForceDirty;
  }
  /**
   * resize canvas & use viewportScrollXY to scrollTo
   */
  _resizeCacheCanvas() {
    var _a;
    const { width, height } = this._calcViewPortSize();
    this.width = width;
    this.height = height;
    const scaleX = this.scene.scaleX;
    const scaleY = this.scene.scaleY;
    const canvasW = width !== 0 ? width + this.bufferEdgeX * 2 * scaleX : 0;
    const canvasH = height !== 0 ? height + this.bufferEdgeY * 2 * scaleY : 0;
    (_a = this._cacheCanvas) == null ? void 0 : _a.setSize(canvasW, canvasH);
    this.cacheBound = this._viewBound;
    this.preCacheBound = null;
    this.markForceDirty(true);
  }
  /**
   * Update scroll when viewport is resizing and removing rol & col
   */
  _updateScrollByViewportScrollValue() {
    if (!this.width || this.width < 0) return;
    if (!this.height || this.height < 0) return;
    const { width, height } = this._calcViewPortSize();
    const sceneWidthCurrVpAfterScale = (this._scene.width - this._paddingEndX) * this._scene.scaleX;
    const sceneHeightCurrVpAfterScale = (this._scene.height - this._paddingEndY) * this._scene.scaleY;
    this._sceneWCurrVpAfterScale = sceneWidthCurrVpAfterScale;
    this._sceneHCurrVpAfterScale = sceneHeightCurrVpAfterScale;
    this._sceneWidthAfterScale = this._scene.width * this._scene.scaleX;
    this._sceneHeightAfterScale = this._scene.height * this._scene.scaleY;
    if (this._scrollBar) {
      this._scrollBar.resize(width, height, sceneWidthCurrVpAfterScale, sceneHeightCurrVpAfterScale);
      const viewportScrollX = this.viewportScrollX;
      const viewportScrollY = this.viewportScrollY;
      this.scrollToViewportPos({
        viewportScrollX,
        viewportScrollY
      });
    }
    this.markForceDirty(true);
  }
  _calcViewPortSize() {
    const parent = this._scene.getParent();
    const { width: parentWidth, height: parentHeight } = parent;
    const { scaleX = 1, scaleY = 1 } = this._scene;
    let width;
    let height;
    const left = this._leftOrigin * scaleX;
    const top = this._topOrigin * scaleY;
    this._left = left;
    this._top = top;
    if (Tools.isDefine(this._widthOrigin)) {
      width = (this._widthOrigin || 0) * scaleX;
    } else {
      width = parentWidth - (this._left + this._right);
    }
    if (Tools.isDefine(this._heightOrigin)) {
      height = (this._heightOrigin || 0) * scaleY;
    } else {
      height = parentHeight - (this._top + this._bottom);
    }
    return {
      width,
      height,
      parentHeight
    };
  }
  /**
   * update pre scroll value has handled in updateScroll()
   */
  _afterRender() {
  }
  /**
   * mock scrollend.
   * @param scrollSubParam
   */
  _emitScrollEnd$(scrollSubParam) {
    clearTimeout(this._scrollStopNum);
    this._scrollStopNum = setTimeout(() => {
      var _a, _b;
      this.onScrollEnd$.emitEvent({
        rawScrollX: scrollSubParam.rawScrollX,
        rawScrollY: scrollSubParam.rawScrollY,
        viewport: this,
        scrollX: this.scrollX,
        scrollY: this.scrollY,
        viewportScrollX: this.viewportScrollX,
        viewportScrollY: this.viewportScrollY,
        limitX: (_a = this._scrollBar) == null ? void 0 : _a.limitX,
        limitY: (_b = this._scrollBar) == null ? void 0 : _b.limitY,
        isTrigger: false
      });
    }, 2);
  }
  /**
   *
   * When scroll just in X direction, there is no y definition in scrollXY. So scrollXY is Partial<IScrollBarPosition>
   * @param rawScrollXY Partial<IViewportScrollPosition>
   * @param isTrigger
   */
  _scrollToBarPosCore(rawScrollXY, isTrigger = true) {
    var _a, _b, _c, _d, _e;
    if (this._scrollBar == null) {
      return;
    }
    let scrollX = rawScrollXY.x;
    let scrollY = rawScrollXY.y;
    const afterLimit = this.limitedScroll(scrollX, scrollY);
    const viewportScrollXY = this.transScroll2ViewportScrollValue(afterLimit.scrollX, afterLimit.scrollY);
    this.scrollX = scrollX = afterLimit.scrollX;
    this.scrollY = scrollY = afterLimit.scrollY;
    this.viewportScrollX = viewportScrollXY.x;
    this.viewportScrollY = viewportScrollXY.y;
    const scrollSubParam = {
      viewport: this,
      scrollX,
      scrollY,
      viewportScrollX: viewportScrollXY.x,
      viewportScrollY: viewportScrollXY.y,
      rawScrollX: rawScrollXY.x,
      rawScrollY: rawScrollXY.y,
      limitX: (_a = this._scrollBar) == null ? void 0 : _a.limitX,
      limitY: (_b = this._scrollBar) == null ? void 0 : _b.limitY,
      isTrigger
    };
    (_c = this._scrollBar) == null ? void 0 : _c.makeDirty(true);
    this.onScrollAfter$.emitEvent(scrollSubParam);
    this._emitScrollEnd$(scrollSubParam);
    this.onScrollByBar$.emitEvent({
      viewport: this,
      scrollX: this.scrollX,
      scrollY: this.scrollY,
      viewportScrollX: this.viewportScrollX,
      viewportScrollY: this.viewportScrollY,
      limitX: (_d = this._scrollBar) == null ? void 0 : _d.limitX,
      limitY: (_e = this._scrollBar) == null ? void 0 : _e.limitY,
      isTrigger
    });
    return afterLimit;
  }
  /**
   * Scroll to position in viewport.
   * @param scrollVpPos Partial<IViewportScrollPosition>
   * @param isTrigger
   */
  _scrollToViewportPosCore(scrollVpPos, isTrigger = true) {
    var _a, _b, _c, _d, _e;
    if (this._scrollBar == null) {
      return;
    }
    let viewportScrollX = (_a = scrollVpPos.viewportScrollX) != null ? _a : this.viewportScrollX;
    let viewportScrollY = (_b = scrollVpPos.viewportScrollY) != null ? _b : this.viewportScrollY;
    const rawScrollXY = this.transViewportScroll2ScrollValue(viewportScrollX, viewportScrollY);
    const afterLimitViewportXY = this._limitViewportScroll(viewportScrollX, viewportScrollY);
    viewportScrollX = afterLimitViewportXY.viewportScrollX;
    viewportScrollY = afterLimitViewportXY.viewportScrollY;
    const afterLimitScrollXY = this.transViewportScroll2ScrollValue(viewportScrollX, viewportScrollY);
    const scrollX = afterLimitScrollXY.x;
    const scrollY = afterLimitScrollXY.y;
    this._preScrollX = this.scrollX;
    this._preScrollY = this.scrollY;
    this._preViewportScrollX = this.viewportScrollX;
    this._preViewportScrollY = this.viewportScrollY;
    this.scrollX = scrollX;
    this.scrollY = scrollY;
    this.viewportScrollX = viewportScrollX;
    this.viewportScrollY = viewportScrollY;
    const scrollSubParam = {
      isTrigger,
      viewport: this,
      scrollX: this.scrollX,
      scrollY: this.scrollY,
      viewportScrollX,
      viewportScrollY,
      rawScrollX: rawScrollXY.x,
      rawScrollY: rawScrollXY.y,
      limitX: (_c = this._scrollBar) == null ? void 0 : _c.limitX,
      limitY: (_d = this._scrollBar) == null ? void 0 : _d.limitY
    };
    (_e = this._scrollBar) == null ? void 0 : _e.makeDirty(true);
    this.onScrollAfter$.emitEvent(scrollSubParam);
    this._emitScrollEnd$(scrollSubParam);
    return afterLimitViewportXY;
  }
  expandBounds(value) {
    const onePixelFix = 0;
    return {
      left: value.left - this.bufferEdgeX - onePixelFix,
      right: value.right + this.bufferEdgeX + onePixelFix,
      // left: Math.max(this.leftOrigin, value.left - this.bufferEdgeX) - onePixelFix,
      // top: Math.max(this.topOrigin, value.top - this.bufferEdgeY) - onePixelFix,
      top: value.top - this.bufferEdgeY - onePixelFix,
      bottom: value.bottom + this.bufferEdgeY + onePixelFix
    };
  }
  updatePrevCacheBounds(viewBound) {
    if (viewBound) {
      this.preCacheBound = this.cacheBound = this.expandBounds(viewBound);
    }
  }
  _calcCacheUpdate(viewBound, preCacheVisibleBound, _diffX, _diffY) {
    if (!this._cacheCanvas) return 0;
    if (!preCacheVisibleBound) return 1;
    const viewBoundOutCacheArea = viewBound.right > preCacheVisibleBound.right || viewBound.top < preCacheVisibleBound.top || viewBound.left < preCacheVisibleBound.left || viewBound.bottom > preCacheVisibleBound.bottom ? 1 : 0;
    const edgeX = this.bufferEdgeX / 50;
    const edgeY = this.bufferEdgeY / 50;
    const nearEdge = preCacheVisibleBound.right - viewBound.right < edgeX || viewBound.left - preCacheVisibleBound.left < edgeX || viewBound.top - preCacheVisibleBound.top < edgeY || preCacheVisibleBound.bottom - viewBound.bottom < edgeY ? 5 : 0;
    const shouldCacheUpdate = nearEdge | viewBoundOutCacheArea;
    return shouldCacheUpdate;
  }
  _diffViewBound(mainBound, subBound) {
    if (subBound == null) {
      return [mainBound];
    }
    const range1 = {
      startRow: mainBound.top,
      endRow: mainBound.bottom,
      startColumn: mainBound.left,
      endColumn: mainBound.right
    };
    const range2 = {
      startRow: subBound.top,
      endRow: subBound.bottom,
      startColumn: subBound.left,
      endColumn: subBound.right
    };
    const ranges = subtractViewportRange(range1, range2);
    return ranges.map((range) => {
      const { startRow, endRow, startColumn, endColumn } = range;
      return {
        left: startColumn,
        top: startRow,
        right: endColumn,
        bottom: endRow
      };
    });
  }
  _calcDiffCacheBound(prevBound, currBound) {
    if (!prevBound) {
      return [currBound];
    }
    const additionalAreas = [];
    if (currBound.left < prevBound.left) {
      additionalAreas.push({
        top: currBound.top,
        bottom: currBound.bottom,
        left: currBound.left,
        right: prevBound.left
      });
    }
    if (currBound.right > prevBound.right) {
      additionalAreas.push({
        top: currBound.top,
        bottom: currBound.bottom,
        left: prevBound.right,
        right: currBound.right
      });
    }
    if (currBound.top < prevBound.top) {
      additionalAreas.push({
        top: currBound.top,
        bottom: prevBound.top,
        left: Math.max(prevBound.left, currBound.left),
        right: Math.min(prevBound.right, currBound.right)
      });
    }
    if (currBound.bottom > prevBound.bottom) {
      additionalAreas.push({
        top: prevBound.bottom,
        bottom: currBound.bottom,
        left: Math.max(prevBound.left, currBound.left),
        right: Math.min(prevBound.right, currBound.right)
      });
    }
    const expandX = this.bufferEdgeX;
    const expandY = this.bufferEdgeY;
    for (const bound of additionalAreas) {
      bound.left = bound.left - expandX;
      bound.right = bound.right + expandX;
      bound.top = bound.top - expandY;
      bound.bottom = bound.bottom + expandY;
    }
    return additionalAreas;
  }
  _drawScrollbar(ctx) {
    if (!this._scrollBar) {
      return;
    }
    const parent = this._scene.getParent();
    if (parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
      this._scrollBar.render(ctx);
    } else if (parent.classType === "Engine" /* ENGINE */) {
      this._scrollBar.render(ctx);
    }
  }
  setViewportSize(props) {
    if (Tools.isDefine(props == null ? void 0 : props.top)) {
      this.top = props.top;
    }
    if (Tools.isDefine(props == null ? void 0 : props.left)) {
      this.left = props.left;
    }
    if (Tools.isDefine(props == null ? void 0 : props.bottom)) {
      this.bottom = props.bottom;
    }
    if (Tools.isDefine(props == null ? void 0 : props.right)) {
      this.right = props.right;
    }
    if (Tools.isDefine(props == null ? void 0 : props.width)) {
      this.width = props == null ? void 0 : props.width;
      this._widthOrigin = props == null ? void 0 : props.width;
    } else {
    }
    if (Tools.isDefine(props == null ? void 0 : props.height)) {
      this.height = props == null ? void 0 : props.height;
      this._heightOrigin = props == null ? void 0 : props.height;
    } else {
    }
  }
};

// ../packages/ui/src/common/component-manager.ts
var import_react = __toESM(require_react());
var ComponentManager = class {
  // eslint-disable-next-line max-lines-per-function
  constructor() {
    __publicField(this, "_components", /* @__PURE__ */ new Map());
    __publicField(this, "_componentsReverse", /* @__PURE__ */ new Map());
    const iconList = {
      AlignBottomSingle: align_bottom_single_default,
      AlignTopSingle: align_top_single_default,
      AllBorderSingle: all_border_single_default,
      AmplifySingle: amplify_single_default,
      AutowrapSingle: autowrap_single_default,
      BoldSingle: bold_single_default,
      BrushSingle: brush_single_default,
      Copy: copy_default,
      ClearFormat: clear_format_default,
      DownBorder: down_border_default,
      FontColor: font_color_default,
      FunctionSingle: function_single_default,
      HorizontallySingle: horizontally_single_default,
      InnerBorder: inner_border_default,
      ItalicSingle: italic_single_default,
      KeyboardSingle: keyboard_single_default,
      ContentSingle16: content_single_16_default,
      LeftBorder: left_border_default,
      LeftJustifyingSingle: left_justifying_single_default,
      LeftRotationFortyFiveDegreesSingle: left_rotation_forty_five_degrees_single_default,
      LeftRotationNinetyDegreesSingle: left_rotation_ninety_degrees_single_default,
      MergeAllSingle: merge_all_single_default,
      HorizontalMergeSingle: horizontal_merge_single_default,
      VerticalIntegrationSingle: vertical_integration_single_default,
      PipingSingle: piping_single_default,
      CancelMergeSingle: cancel_merge_single_default,
      NoBorderSingle: no_border_single_default,
      NoColor: no_color_default,
      NoRotationSingle: no_rotation_single_default,
      OuterBorder: outer_border_default,
      OverflowSingle: overflow_single_default,
      PaintBucket: paint_bucket_default,
      PasteSpecial: paste_special_default,
      MenuSingle24: menu_single_24_default,
      RedoSingle: redo_single_default,
      RightBorder: right_border_default,
      RightJustifyingSingle: right_justifying_single_default,
      AlignTextBothSingle: align_text_both_single_default,
      ReduceSingle: reduce_single_default,
      RightRotationFortyFiveDegreesSingle: right_rotation_forty_five_degrees_single_default,
      RightRotationNinetyDegreesSingle: right_rotation_ninety_degrees_single_default,
      StrikethroughSingle: strikethrough_single_default,
      OrderSingle: order_single_default,
      UnorderSingle: unorder_single_default,
      SuperscriptSingle: superscript_single_default,
      SubscriptSingle: subscript_single_default,
      TruncationSingle: truncation_single_default,
      UnderlineSingle: underline_single_default,
      UndoSingle: undo_single_default,
      UpBorder: up_border_default,
      VerticalBorder: vertical_border_default,
      VerticalCenterSingle: vertical_center_single_default,
      VerticalTextSingle: vertical_text_single_default,
      Insert: insert_default,
      InsertCellDown: insert_cell_down_default,
      InsertCellShiftRight: insert_cell_shift_right_default,
      InsertRowAbove: insert_row_above_default,
      InsertRowBelow: insert_row_below_default,
      LeftInsertColumn: left_insert_column_default,
      RightInsertColumn: right_insert_column_default,
      DeleteColumn: delete_column_default,
      DeleteRow: delete_row_default,
      DeleteCellShiftUp: delete_cell_shift_up_default,
      DeleteCellShiftRight: delete_cell_shift_right_default,
      DeleteCellShiftLeft: delete_cell_shift_left_default,
      DeleteCellMoveDown: delete_cell_move_down_default,
      Reduce: reduce_default,
      Hide: hide_default,
      HorizontalBorder: horizontal_border_default,
      AutoHeight: auto_height_default,
      AutoWidth: auto_width_default,
      AdjustHeight: adjust_height_default,
      AdjustWidth: adjust_width_default,
      AvgSingle: avg_single_default,
      CntSingle: cnt_single_default,
      MaxSingle: max_single_default,
      MinSingle: min_single_default,
      SumSingle: sum_single_default,
      CancelFreezeSingle: cancel_freeze_single_default,
      FreezeColumnSingle: freeze_column_single_default,
      FreezeRowSingle: freeze_row_single_default,
      GridSingle: grid_single_default,
      HeaderFooterSingle: header_footer_single_default,
      FreezeToSelectedSingle: freeze_to_selected_single_default,
      CodeSingle: code_single_default,
      FontSizeIncreaseSingle: font_size_increase_single_default,
      FontSizeReduceSingleSingle: font_size_reduce_single_single_default,
      BackSlashSingle: back_slash_single_default,
      LeftDoubleDiagonalSingle: left_double_diagonal_single_default,
      LeftTridiagonalSingle: left_tridiagonal_single_default,
      SlashSingle: slash_single_default,
      RightDoubleDiagonalSingle: right_double_diagonal_single_default,
      DirectExportSingle: direct_export_single_default,
      FolderSingle: folder_single_default,
      ExportSingle: export_single_default,
      Conditions: conditions_default,
      RmbSingle: rmb_single_default,
      MoreDownSingle: more_down_single_default,
      AddDigitsSingle: add_digits_single_default,
      ReduceDigitsSingle: reduce_digits_single_default,
      PercentSingle: percent_single_default,
      EuroSingle: euro_single_default,
      RoubleSingle: rouble_single_default,
      DollarSingle: dollar_single_default
    };
    for (const k in iconList) {
      this.register(k, iconList[k]);
    }
  }
  register(name, component, options) {
    const { framework = "react" } = options || {};
    if (this._components.has(name)) {
      console.warn(`Component ${name} already exists.`);
    }
    this._components.set(name, {
      framework,
      component
    });
    this._componentsReverse.set(component, name);
    return toDisposable(() => {
      this._components.delete(name);
      this._componentsReverse.delete(component);
    });
  }
  getKey(component) {
    return this._componentsReverse.get(component);
  }
  get(name) {
    if (!name) return;
    const value = this._components.get(name);
    if ((value == null ? void 0 : value.framework) === "react") {
      return value.component;
    } else if ((value == null ? void 0 : value.framework) === "vue3") {
      return (props) => (0, import_react.cloneElement)(
        (0, import_react.createElement)(VueComponentWrapper, {
          component: value.component,
          props: {
            ...props
          }
        })
      );
    } else {
    }
  }
  delete(name) {
    this._components.delete(name);
  }
};
async function renderVue3Component(VueComponent, element, args) {
  try {
    const { h, render: render2 } = await import("./vue.runtime.esm-bundler-CGX2BLAZ.js");
    const vnode = h(VueComponent, args);
    const container = document.createElement("div");
    document.body.appendChild(container);
    render2(vnode, element);
    return () => {
      document.body.removeChild(container);
    };
  } catch (error) {
  }
}
function VueComponentWrapper(options) {
  const domRef = (0, import_react.useRef)(null);
  const { component, props } = options;
  (0, import_react.useEffect)(() => {
    if (!domRef.current) return;
    const render2 = renderVue3Component(component, domRef.current, props);
    return () => {
      render2.then((d) => d == null ? void 0 : d());
    };
  }, [props]);
  return (0, import_react.createElement)("div", { ref: domRef });
}

// ../packages/ui/src/common/z-index-manager.ts
var _MAX_INDEX, _MIN_INDEX;
var ZIndexManager = class {
  constructor() {
    __publicField(this, "_list", /* @__PURE__ */ new Map());
  }
  setIndex(name, index) {
    this._list.set(name, index);
  }
  getIndex(name) {
    return this._list.get(name);
  }
  removeIndex(name) {
    this._list.delete(name);
  }
  getMaxIndex() {
    let max2 = -9999999;
    this._list.forEach((item) => {
      if (+item > max2) {
        max2 = +item;
      }
    });
    return max2;
  }
};
_MAX_INDEX = new WeakMap();
_MIN_INDEX = new WeakMap();
__privateAdd(ZIndexManager, _MAX_INDEX, 2147483647);
__privateAdd(ZIndexManager, _MIN_INDEX, -2147483647);

// ../packages/ui/src/services/message/message.service.ts
var IMessageService = createIdentifier("ui.message.service");

// ../packages/ui/src/controllers/error/error.controller.ts
var ErrorController = class extends Disposable {
  constructor(_errorService, _messageService) {
    super();
    this._errorService = _errorService;
    this._messageService = _messageService;
    this.disposeWithMe(this._errorService.error$.subscribe((error) => {
      this._messageService.show({
        content: error.errorKey,
        type: "error" /* Error */
      });
    }));
  }
};
ErrorController = __decorateClass([
  __decorateParam(0, Inject(ErrorService)),
  __decorateParam(1, IMessageService)
], ErrorController);

// ../packages/ui/src/services/clipboard/clipboard.command.ts
var CopyCommandName = "univer.command.copy";
var CopyCommand = {
  id: CopyCommandName,
  name: CopyCommandName,
  multi: true,
  priority: 0,
  type: 0 /* COMMAND */,
  preconditions: () => false,
  handler: () => true
};
var CutCommandName = "univer.command.cut";
var CutCommand = {
  id: CutCommandName,
  name: CutCommandName,
  multi: true,
  priority: 0,
  type: 0 /* COMMAND */,
  preconditions: () => false,
  handler: async () => true
};
var PasteCommandName = "univer.command.paste";
var PasteCommand = {
  id: PasteCommandName,
  name: PasteCommandName,
  multi: true,
  priority: 0,
  type: 0 /* COMMAND */,
  preconditions: () => false,
  handler: () => true
};
var SheetPasteShortKeyCommandName = "sheet.command.paste-by-short-key";

// ../packages/ui/src/services/shortcut/keycode.ts
var KeyCode = /* @__PURE__ */ ((KeyCode2) => {
  KeyCode2[KeyCode2["UNKNOWN"] = 0] = "UNKNOWN";
  KeyCode2[KeyCode2["BACKSPACE"] = 8] = "BACKSPACE";
  KeyCode2[KeyCode2["TAB"] = 9] = "TAB";
  KeyCode2[KeyCode2["ENTER"] = 13] = "ENTER";
  KeyCode2[KeyCode2["SHIFT"] = 16] = "SHIFT";
  KeyCode2[KeyCode2["CTRL"] = 17] = "CTRL";
  KeyCode2[KeyCode2["ESC"] = 27] = "ESC";
  KeyCode2[KeyCode2["SPACE"] = 32] = "SPACE";
  KeyCode2[KeyCode2["ARROW_LEFT"] = 37] = "ARROW_LEFT";
  KeyCode2[KeyCode2["ARROW_UP"] = 38] = "ARROW_UP";
  KeyCode2[KeyCode2["ARROW_RIGHT"] = 39] = "ARROW_RIGHT";
  KeyCode2[KeyCode2["ARROW_DOWN"] = 40] = "ARROW_DOWN";
  KeyCode2[KeyCode2["INSERT"] = 45] = "INSERT";
  KeyCode2[KeyCode2["DELETE"] = 46] = "DELETE";
  KeyCode2[KeyCode2["Digit0"] = 48] = "Digit0";
  KeyCode2[KeyCode2["Digit1"] = 49] = "Digit1";
  KeyCode2[KeyCode2["Digit2"] = 50] = "Digit2";
  KeyCode2[KeyCode2["Digit3"] = 51] = "Digit3";
  KeyCode2[KeyCode2["Digit4"] = 52] = "Digit4";
  KeyCode2[KeyCode2["Digit5"] = 53] = "Digit5";
  KeyCode2[KeyCode2["Digit6"] = 54] = "Digit6";
  KeyCode2[KeyCode2["Digit7"] = 55] = "Digit7";
  KeyCode2[KeyCode2["Digit8"] = 56] = "Digit8";
  KeyCode2[KeyCode2["Digit9"] = 57] = "Digit9";
  KeyCode2[KeyCode2["A"] = 65] = "A";
  KeyCode2[KeyCode2["B"] = 66] = "B";
  KeyCode2[KeyCode2["C"] = 67] = "C";
  KeyCode2[KeyCode2["D"] = 68] = "D";
  KeyCode2[KeyCode2["E"] = 69] = "E";
  KeyCode2[KeyCode2["F"] = 70] = "F";
  KeyCode2[KeyCode2["G"] = 71] = "G";
  KeyCode2[KeyCode2["H"] = 72] = "H";
  KeyCode2[KeyCode2["I"] = 73] = "I";
  KeyCode2[KeyCode2["J"] = 74] = "J";
  KeyCode2[KeyCode2["K"] = 75] = "K";
  KeyCode2[KeyCode2["L"] = 76] = "L";
  KeyCode2[KeyCode2["M"] = 77] = "M";
  KeyCode2[KeyCode2["N"] = 78] = "N";
  KeyCode2[KeyCode2["O"] = 79] = "O";
  KeyCode2[KeyCode2["P"] = 80] = "P";
  KeyCode2[KeyCode2["Q"] = 81] = "Q";
  KeyCode2[KeyCode2["R"] = 82] = "R";
  KeyCode2[KeyCode2["S"] = 83] = "S";
  KeyCode2[KeyCode2["T"] = 84] = "T";
  KeyCode2[KeyCode2["U"] = 85] = "U";
  KeyCode2[KeyCode2["V"] = 86] = "V";
  KeyCode2[KeyCode2["W"] = 87] = "W";
  KeyCode2[KeyCode2["X"] = 88] = "X";
  KeyCode2[KeyCode2["Y"] = 89] = "Y";
  KeyCode2[KeyCode2["Z"] = 90] = "Z";
  KeyCode2[KeyCode2["F1"] = 112] = "F1";
  KeyCode2[KeyCode2["F2"] = 113] = "F2";
  KeyCode2[KeyCode2["F3"] = 114] = "F3";
  KeyCode2[KeyCode2["F4"] = 115] = "F4";
  KeyCode2[KeyCode2["F5"] = 116] = "F5";
  KeyCode2[KeyCode2["F6"] = 117] = "F6";
  KeyCode2[KeyCode2["F7"] = 118] = "F7";
  KeyCode2[KeyCode2["F8"] = 119] = "F8";
  KeyCode2[KeyCode2["F9"] = 120] = "F9";
  KeyCode2[KeyCode2["F10"] = 121] = "F10";
  KeyCode2[KeyCode2["F11"] = 122] = "F11";
  KeyCode2[KeyCode2["F12"] = 123] = "F12";
  KeyCode2[KeyCode2["NUM_LOCK"] = 144] = "NUM_LOCK";
  KeyCode2[KeyCode2["SCROLL_LOCK"] = 145] = "SCROLL_LOCK";
  KeyCode2[KeyCode2["EQUAL"] = 187] = "EQUAL";
  KeyCode2[KeyCode2["COMMA"] = 188] = "COMMA";
  KeyCode2[KeyCode2["MINUS"] = 189] = "MINUS";
  KeyCode2[KeyCode2["PERIOD"] = 190] = "PERIOD";
  KeyCode2[KeyCode2["BACK_SLASH"] = 220] = "BACK_SLASH";
  return KeyCode2;
})(KeyCode || {});
var KeyCodeToChar = {
  [8 /* BACKSPACE */]: "Backspace",
  [9 /* TAB */]: "Tab",
  [13 /* ENTER */]: "Enter",
  [46 /* DELETE */]: "Del",
  [27 /* ESC */]: "Esc",
  [32 /* SPACE */]: "Space",
  [37 /* ARROW_LEFT */]: "\u2190",
  [39 /* ARROW_RIGHT */]: "\u2192",
  [38 /* ARROW_UP */]: "\u2191",
  [40 /* ARROW_DOWN */]: "\u2193",
  [48 /* Digit0 */]: "0",
  [49 /* Digit1 */]: "1",
  [50 /* Digit2 */]: "2",
  [51 /* Digit3 */]: "3",
  [52 /* Digit4 */]: "4",
  [53 /* Digit5 */]: "5",
  [54 /* Digit6 */]: "6",
  [55 /* Digit7 */]: "7",
  [56 /* Digit8 */]: "8",
  [57 /* Digit9 */]: "9",
  [65 /* A */]: "A",
  [66 /* B */]: "B",
  [67 /* C */]: "C",
  [68 /* D */]: "D",
  [69 /* E */]: "E",
  [70 /* F */]: "F",
  [71 /* G */]: "G",
  [72 /* H */]: "H",
  [73 /* I */]: "I",
  [74 /* J */]: "J",
  [75 /* K */]: "K",
  [76 /* L */]: "L",
  [77 /* M */]: "M",
  [78 /* N */]: "N",
  [79 /* O */]: "O",
  [80 /* P */]: "P",
  [81 /* Q */]: "Q",
  [82 /* R */]: "R",
  [83 /* S */]: "S",
  [84 /* T */]: "T",
  [85 /* U */]: "U",
  [86 /* V */]: "V",
  [87 /* W */]: "W",
  [88 /* X */]: "X",
  [89 /* Y */]: "Y",
  [90 /* Z */]: "Z",
  [112 /* F1 */]: "F1",
  [113 /* F2 */]: "F2",
  [114 /* F3 */]: "F3",
  [115 /* F4 */]: "F4",
  [116 /* F5 */]: "F5",
  [117 /* F6 */]: "F6",
  [118 /* F7 */]: "F7",
  [119 /* F8 */]: "F8",
  [120 /* F9 */]: "F9",
  [121 /* F10 */]: "F10",
  [122 /* F11 */]: "F11",
  [123 /* F12 */]: "F12",
  [189 /* MINUS */]: "-",
  [187 /* EQUAL */]: "=",
  [190 /* PERIOD */]: ".",
  [188 /* COMMA */]: ",",
  [220 /* BACK_SLASH */]: "\\"
};

// ../packages/ui/src/common/lifecycle.ts
function fromGlobalEvent(type2, listener, options) {
  window.addEventListener(type2, listener, options);
  return toDisposable(() => window.removeEventListener(type2, listener, options));
}

// ../packages/ui/src/services/layout/layout.service.ts
var FOCUSING_UNIVER = "FOCUSING_UNIVER";
var givingBackFocusElements = [
  "univer-app-layout",
  "univer-toolbar-btn",
  "univer-menu-item",
  "univer-button",
  "univer-sheet-bar-btn",
  "univer-render-canvas",
  "univer-workbench-layout"
];
var ILayoutService = createIdentifier("ui.layout-service");
var DesktopLayoutService = class extends Disposable {
  constructor(_contextService, _univerInstanceService) {
    super();
    this._contextService = _contextService;
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_rootContainerElement", null);
    __publicField(this, "_isFocused", false);
    __publicField(this, "_focusHandlers", /* @__PURE__ */ new Map());
    // FIXME: this don't need to be plural
    __publicField(this, "_contentElements", []);
    __publicField(this, "_allContainers", []);
    this._initUniverFocusListener();
    this._initEditorStatus();
  }
  get isFocused() {
    return this._isFocused;
  }
  get rootContainerElement() {
    return this._rootContainerElement;
  }
  focus() {
    const currentFocused = this._univerInstanceService.getFocusedUnit();
    if (!currentFocused) {
      return;
    }
    let handler;
    if (currentFocused instanceof Workbook) {
      handler = this._focusHandlers.get(O.UNIVER_SHEET);
    } else if (currentFocused instanceof DocumentDataModel) {
      handler = this._focusHandlers.get(O.UNIVER_DOC);
    } else if (currentFocused instanceof SlideDataModel) {
      handler = this._focusHandlers.get(O.UNIVER_SLIDE);
    }
    if (handler) {
      handler(currentFocused.getUnitId());
    }
  }
  registerFocusHandler(type2, handler) {
    if (this._focusHandlers.has(type2)) {
      throw new Error(`[DesktopLayoutService]: handler of type ${type2} bas been registered!`);
    }
    this._focusHandlers.set(type2, handler);
    return toDisposable(() => this._focusHandlers.delete(type2));
  }
  registerContentElement(container) {
    if (this._contentElements.indexOf(container) === -1) {
      this._contentElements.push(container);
      return toDisposable(() => remove(this._contentElements, container));
    }
    throw new Error("[DesktopLayoutService]: content container already registered!");
  }
  getContentElement() {
    return this._contentElements[0];
  }
  registerRootContainerElement(container) {
    if (this._rootContainerElement) {
      throw new Error("[DesktopLayoutService]: root container already registered!");
    }
    this._rootContainerElement = container;
    const dis = this.registerContainerElement(container);
    return toDisposable(() => {
      this._rootContainerElement = null;
      dis.dispose();
    });
  }
  registerContainerElement(container) {
    if (this._allContainers.indexOf(container) === -1) {
      this._allContainers.push(container);
      return toDisposable(() => remove(this._allContainers, container));
    }
    throw new Error("[LayoutService]: container already registered!");
  }
  checkElementInCurrentContainers(element) {
    return this._allContainers.some((container) => container.contains(element));
  }
  checkContentIsFocused() {
    return this._contentElements.some((contentEl) => contentEl === document.activeElement || contentEl.contains(document.activeElement));
  }
  _initUniverFocusListener() {
    this.disposeWithMe(
      fromEvent(window, "focusin").subscribe((event) => {
        var _a;
        const target = event.target;
        if (((_a = this._rootContainerElement) == null ? void 0 : _a.contains(target)) && givingBackFocusElements.some((item) => target.classList.contains(item))) {
          queueMicrotask(() => this.focus());
          return;
        }
        if (target && this.checkElementInCurrentContainers(target)) {
          this._isFocused = true;
        } else {
          this._isFocused = false;
        }
        this._contextService.setContextValue(FOCUSING_UNIVER, this._isFocused);
        this._contextService.setContextValue(FOCUSING_UNIVER_EDITOR, getFocusingUniverEditorStatus());
      })
    );
  }
  _initEditorStatus() {
    this._contextService.setContextValue(FOCUSING_UNIVER_EDITOR, getFocusingUniverEditorStatus());
  }
};
DesktopLayoutService = __decorateClass([
  __decorateParam(0, IContextService),
  __decorateParam(1, IUniverInstanceService)
], DesktopLayoutService);
function getFocusingUniverEditorStatus() {
  var _a;
  return !!((_a = document.activeElement) == null ? void 0 : _a.classList.contains("univer-editor"));
}

// ../packages/ui/src/services/platform/platform.service.ts
var IPlatformService = createIdentifier("ui.platform.service");
var PlatformService = class {
  get isMac() {
    return /Mac/.test(navigator.appVersion);
  }
  get isWindows() {
    return /Windows/.test(navigator.appVersion);
  }
  get isLinux() {
    return /Linux/.test(navigator.appVersion);
  }
};

// ../packages/ui/src/services/shortcut/shortcut.service.ts
var IShortcutService = createIdentifier("ui.shortcut.service");
var ShortcutService = class extends Disposable {
  constructor(_commandService, _platformService, _contextService, _layoutService) {
    super();
    this._commandService = _commandService;
    this._platformService = _platformService;
    this._contextService = _contextService;
    this._layoutService = _layoutService;
    __publicField(this, "_shortCutMapping", /* @__PURE__ */ new Map());
    __publicField(this, "_commandIDMapping", /* @__PURE__ */ new Map());
    __publicField(this, "_shortcutChanged$", new Subject());
    __publicField(this, "shortcutChanged$", this._shortcutChanged$.asObservable());
    __publicField(this, "_forceEscaped", false);
    __publicField(this, "_forceDisabled", false);
    this.disposeWithMe(
      fromGlobalEvent("keydown", (e) => {
        this._resolveKeyboardEvent(e);
      }, {
        capture: true
      })
    );
  }
  getAllShortcuts() {
    return Array.from(this._shortCutMapping.values()).map((v) => Array.from(v.values())).flat();
  }
  registerShortcut(shortcut) {
    const binding = this._getBindingFromItem(shortcut);
    if (!binding) return toDisposable(() => {
    });
    const bindingSet = this._shortCutMapping.get(binding);
    if (bindingSet) {
      bindingSet.add(shortcut);
    } else {
      this._shortCutMapping.set(binding, /* @__PURE__ */ new Set([shortcut]));
    }
    const commandID = shortcut.id;
    const commandIDSet = this._commandIDMapping.get(commandID);
    if (commandIDSet) {
      commandIDSet.add(shortcut);
    } else {
      this._commandIDMapping.set(commandID, /* @__PURE__ */ new Set([shortcut]));
    }
    this._emitShortcutChanged();
    return toDisposable(() => {
      var _a, _b, _c, _d;
      (_a = this._shortCutMapping.get(binding)) == null ? void 0 : _a.delete(shortcut);
      if (((_b = this._shortCutMapping.get(binding)) == null ? void 0 : _b.size) === 0) {
        this._shortCutMapping.delete(binding);
      }
      (_c = this._commandIDMapping.get(commandID)) == null ? void 0 : _c.delete(shortcut);
      if (((_d = this._commandIDMapping.get(commandID)) == null ? void 0 : _d.size) === 0) {
        this._commandIDMapping.delete(commandID);
      }
      this._emitShortcutChanged();
    });
  }
  getShortcutDisplayOfCommand(id) {
    const set = this._commandIDMapping.get(id);
    if (!set) {
      return null;
    }
    const shortcut = set.values().next().value;
    if (shortcut) {
      return this.getShortcutDisplay(shortcut);
    }
    return null;
  }
  getShortcutDisplay(shortcut) {
    var _a;
    const binding = this._getBindingFromItem(shortcut);
    if (!binding) return null;
    const ctrlKey = binding & 4096 /* CTRL_COMMAND */;
    const shiftKey = binding & 1024 /* SHIFT */;
    const altKey = binding & 2048 /* ALT */;
    const macCtrl = binding & 8192 /* MAC_CTRL */;
    const body = (_a = KeyCodeToChar[binding & 255]) != null ? _a : "<->";
    if (this._platformService.isMac) {
      return `${ctrlKey ? "\u2318" : ""}${shiftKey ? "\u21E7" : ""}${altKey ? "\u2325" : ""}${macCtrl ? "\u2303" : ""}${body}`;
    }
    return `${ctrlKey ? "Ctrl+" : ""}${shiftKey ? "Shift+" : ""}${altKey ? "Alt+" : ""}${body}`;
  }
  _emitShortcutChanged() {
    this._shortcutChanged$.next();
  }
  forceEscape() {
    this._forceEscaped = true;
    return toDisposable(() => this._forceEscaped = false);
  }
  forceDisable() {
    this._forceDisabled = true;
    return toDisposable(() => {
      this._forceDisabled = false;
    });
  }
  _resolveKeyboardEvent(e) {
    const candidate = this.dispatch(e);
    if (candidate) {
      this._commandService.executeCommand(candidate.id, candidate.staticParameters);
      e.preventDefault();
    }
  }
  dispatch(e) {
    if (this._forceEscaped || this._forceDisabled) return;
    if (this._layoutService && !this._layoutService.checkElementInCurrentContainers(e.target)) {
      return;
    }
    const binding = this._deriveBindingFromEvent(e);
    if (binding === null) {
      return void 0;
    }
    const shortcuts = this._shortCutMapping.get(binding);
    if (shortcuts === void 0) {
      return void 0;
    }
    const candidateShortcut = Array.from(shortcuts).sort((s1, s2) => {
      var _a, _b;
      return ((_a = s2.priority) != null ? _a : 0) - ((_b = s1.priority) != null ? _b : 0);
    }).find((s) => {
      var _a, _b;
      return (_b = (_a = s.preconditions) == null ? void 0 : _a.call(s, this._contextService)) != null ? _b : true;
    });
    return candidateShortcut;
  }
  _getBindingFromItem(item) {
    if (this._platformService.isMac && item.mac) {
      return item.mac;
    }
    if (this._platformService.isWindows && item.win) {
      return item.win;
    }
    if (this._platformService.isLinux && item.linux) {
      return item.linux;
    }
    return item.binding;
  }
  _deriveBindingFromEvent(e) {
    const { shiftKey, metaKey, altKey, keyCode } = e;
    let binding = keyCode;
    if (shiftKey) {
      binding |= 1024 /* SHIFT */;
    }
    if (altKey) {
      binding |= 2048 /* ALT */;
    }
    const ctrlKey = this._platformService.isMac ? metaKey : e.ctrlKey;
    if (ctrlKey) {
      binding |= 4096 /* CTRL_COMMAND */;
    }
    if (this._platformService.isMac && e.ctrlKey) {
      binding |= 8192 /* MAC_CTRL */;
    }
    return binding;
  }
};
ShortcutService = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IPlatformService),
  __decorateParam(2, IContextService),
  __decorateParam(3, Optional(ILayoutService))
], ShortcutService);

// ../packages/ui/src/controllers/shared-shortcut.controller.ts
function whenEditorFocused(contextService) {
  return contextService.getContextValue(FOCUSING_UNIVER_EDITOR);
}
function whenEditorFocusedButNotCellEditor(contextService) {
  return contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && !(contextService.getContextValue(EDITOR_ACTIVATED) || contextService.getContextValue(FOCUSING_FX_BAR_EDITOR));
}
var CopyShortcutItem = {
  id: CopyCommand.id,
  description: "shortcut.copy",
  group: "1_common-edit",
  binding: 67 /* C */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenEditorFocused
};
var CutShortcutItem = {
  id: CutCommand.id,
  description: "shortcut.cut",
  group: "1_common-edit",
  binding: 88 /* X */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenEditorFocused
};
var OnlyDisplayPasteShortcutItem = {
  id: PasteCommand.id,
  description: "shortcut.paste",
  group: "1_common-edit",
  binding: 86 /* V */ | 4096 /* CTRL_COMMAND */,
  preconditions: () => false
};
var UndoShortcutItem = {
  id: UndoCommand.id,
  description: "shortcut.undo",
  group: "1_common-edit",
  binding: 90 /* Z */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenEditorFocusedButNotCellEditor
};
var RedoShortcutItem = {
  id: RedoCommand.id,
  description: "shortcut.redo",
  group: "1_common-edit",
  binding: 89 /* Y */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenEditorFocusedButNotCellEditor
};
var SharedController = class extends Disposable {
  constructor(_shortcutService, _commandService) {
    super();
    this._shortcutService = _shortcutService;
    this._commandService = _commandService;
    this.initialize();
  }
  initialize() {
    this._registerCommands();
    this._registerShortcuts();
  }
  _registerCommands() {
    [CutCommand, CopyCommand, PasteCommand].forEach(
      (command) => this.disposeWithMe(this._commandService.registerMultipleCommand(command))
    );
  }
  _registerShortcuts() {
    const shortcutItems = [UndoShortcutItem, RedoShortcutItem];
    shortcutItems.push(CutShortcutItem, CopyShortcutItem, OnlyDisplayPasteShortcutItem);
    shortcutItems.forEach((shortcut) => this.disposeWithMe(this._shortcutService.registerShortcut(shortcut)));
  }
};
SharedController = __decorateClass([
  __decorateParam(0, IShortcutService),
  __decorateParam(1, ICommandService)
], SharedController);

// ../packages/ui/src/services/parts/parts.service.ts
var BuiltInUIPart = /* @__PURE__ */ ((BuiltInUIPart2) => {
  BuiltInUIPart2["GLOBAL"] = "global";
  BuiltInUIPart2["HEADER"] = "header";
  BuiltInUIPart2["HEADER_MENU"] = "header-menu";
  BuiltInUIPart2["CONTENT"] = "content";
  BuiltInUIPart2["FOOTER"] = "footer";
  BuiltInUIPart2["LEFT_SIDEBAR"] = "left-sidebar";
  BuiltInUIPart2["FLOATING"] = "floating";
  BuiltInUIPart2["UNIT"] = "unit";
  BuiltInUIPart2["CUSTOM_HEADER"] = "custom-header";
  BuiltInUIPart2["CUSTOM_LEFT"] = "custom-left";
  BuiltInUIPart2["CUSTOM_RIGHT"] = "custom-right";
  BuiltInUIPart2["CUSTOM_FOOTER"] = "custom-footer";
  BuiltInUIPart2["TOOLBAR"] = "toolbar";
  return BuiltInUIPart2;
})(BuiltInUIPart || {});
var IUIPartsService = createIdentifier("ui.parts.service");
var UIPartsService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_componentsByPart", /* @__PURE__ */ new Map());
    __publicField(this, "_componentRegistered$", new Subject());
    __publicField(this, "componentRegistered$", this._componentRegistered$.asObservable());
    __publicField(this, "_uiVisible", /* @__PURE__ */ new Map());
    __publicField(this, "_uiVisibleChange$", new Subject());
    __publicField(this, "uiVisibleChange$", this._uiVisibleChange$.asObservable());
  }
  dispose() {
    super.dispose();
    this._componentRegistered$.complete();
  }
  setUIVisible(part, visible) {
    this._uiVisible.set(part, visible);
    this._uiVisibleChange$.next({ ui: part, visible });
  }
  isUIVisible(part) {
    var _a;
    return (_a = this._uiVisible.get(part)) != null ? _a : true;
  }
  registerComponent(part, componentFactory) {
    const componentType = componentFactory();
    const components = (this._componentsByPart.get(part) || this._componentsByPart.set(part, /* @__PURE__ */ new Set()).get(part)).add(componentType);
    this._componentRegistered$.next(part);
    return toDisposable(() => {
      components.delete(componentType);
      if (components.size === 0) {
        this._componentsByPart.delete(part);
      }
      this._componentRegistered$.next(part);
    });
  }
  getComponents(part) {
    return /* @__PURE__ */ new Set([...this._componentsByPart.get(part) || /* @__PURE__ */ new Set()]);
  }
};

// ../packages/ui/src/utils/di.ts
var import_react3 = __toESM(require_react());

// ../node_modules/.pnpm/@wendellhu+redi@0.17.1/node_modules/@wendellhu/redi/fesm/react-bindings.mjs
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var __REDI_CONTEXT_LOCK__ = "REDI_CONTEXT_LOCK";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var globalObject = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global !== "undefined" && global;
if (!globalObject[__REDI_CONTEXT_LOCK__]) {
  globalObject[__REDI_CONTEXT_LOCK__] = true;
} else if (!isNode) {
  console.error(`[redi]: "RediContext" is already created. You may import "RediContext" from different paths. Use "import { RediContext } from '@wendellhu/redi/react-bindings'; instead."`);
}
var RediContext = React.createContext({
  injector: null
});
RediContext.displayName = "RediContext";
var RediProvider = RediContext.Provider;
var RediConsumer = RediContext.Consumer;
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t2[p] = s[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function connectInjector(Comp, injector) {
  return function ComponentWithInjector(props) {
    return React.createElement(
      RediProvider,
      { value: { injector } },
      React.createElement(Comp, __assign({}, props))
    );
  };
}
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ClassComponentNotInRediContextError = (
  /** @class */
  function(_super) {
    __extends$1(ClassComponentNotInRediContextError2, _super);
    function ClassComponentNotInRediContextError2(component) {
      return _super.call(this, 'You should make "RediContext" as '.concat(component.constructor.name, "'s default context type. ") + "If you want to use multiple context, please check this on React doc site. https://reactjs.org/docs/context.html#classcontexttype") || this;
    }
    return ClassComponentNotInRediContextError2;
  }(RediError)
);
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HooksNotInRediContextError = (
  /** @class */
  function(_super) {
    __extends(HooksNotInRediContextError2, _super);
    function HooksNotInRediContextError2() {
      return _super.call(this, "Using dependency injection outside of a RediContext.") || this;
    }
    return HooksNotInRediContextError2;
  }(RediError)
);
function useInjector() {
  var injectionContext = React.useContext(RediContext);
  if (!injectionContext.injector) {
    throw new HooksNotInRediContextError();
  }
  return injectionContext.injector;
}
function useDependency(id, quantityOrLookUp, lookUp) {
  var injector = useInjector();
  return React.useMemo(function() {
    return injector.get(id, quantityOrLookUp, lookUp);
  }, [id, quantityOrLookUp, lookUp]);
}
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function unwrap(o) {
  if (typeof o === "function") {
    return o();
  }
  return o;
}
function useObservable(observable, defaultValue, shouldHaveSyncValue, deps) {
  if (typeof observable === "function" && !deps) {
    throw new RediError("Expected deps to be provided when observable is a function!");
  }
  var observableRef = (0, import_react2.useRef)(null);
  var initializedRef = (0, import_react2.useRef)(false);
  var destObservable = (0, import_react2.useMemo)(function() {
    return observable;
  }, __spreadArray([], typeof deps !== "undefined" ? deps : [observable], true));
  var _a = (0, import_react2.useState)(0), _819 = _a[0], setRenderCounter = _a[1];
  var valueRef = (0, import_react2.useRef)(function() {
    var innerDefaultValue;
    if (destObservable) {
      var sub = unwrap(destObservable).subscribe(function(value) {
        initializedRef.current = true;
        innerDefaultValue = value;
      });
      sub.unsubscribe();
    }
    return innerDefaultValue !== null && innerDefaultValue !== void 0 ? innerDefaultValue : defaultValue;
  }());
  (0, import_react2.useEffect)(function() {
    var subscription = null;
    if (destObservable) {
      observableRef.current = unwrap(destObservable);
      subscription = observableRef.current.subscribe(function(value) {
        valueRef.current = value;
        setRenderCounter(function(prev) {
          return prev + 1;
        });
      });
    }
    return function() {
      return subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
    };
  }, [destObservable]);
  if (shouldHaveSyncValue && !initializedRef.current) {
    throw new Error("Expect `shouldHaveSyncValue` but not getting a sync value!");
  }
  return valueRef.current;
}

// ../packages/ui/src/utils/di.ts
function unwrap2(o) {
  if (typeof o === "function") {
    return o();
  }
  return o;
}
function useObservableRef(observable, defaultValue) {
  const ref = (0, import_react3.useRef)(defaultValue);
  (0, import_react3.useEffect)(() => {
    if (observable) {
      const sub = unwrap2(observable).subscribe((value) => {
        ref.current = value;
      });
      return () => sub.unsubscribe();
    }
  }, [observable]);
  return ref;
}

// ../packages/ui/src/views/components/dom/FloatDom.tsx
var import_react4 = __toESM(require_react());

// ../packages/ui/src/services/dom/canvas-dom-layer.service.ts
var CanvasFloatDomService = class {
  constructor() {
    __publicField(this, "_domLayerMap", /* @__PURE__ */ new Map());
    __publicField(this, "_domLayers$", new BehaviorSubject([]));
    __publicField(this, "domLayers$", this._domLayers$.asObservable());
  }
  get domLayers() {
    return Array.from(this._domLayerMap.entries());
  }
  _notice() {
    this._domLayers$.next(Array.from(this._domLayerMap.entries()));
  }
  addFloatDom(item) {
    this._domLayerMap.set(item.id, item);
    this._notice();
  }
  removeFloatDom(id) {
    if (this._domLayerMap.delete(id)) {
      this._notice();
    }
  }
  removeAll() {
    this._domLayerMap.clear();
    this._notice();
  }
};

// ../packages/ui/src/views/components/dom/FloatDom.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime());
var FloatDomSingle = (0, import_react4.memo)((props) => {
  var _a, _b;
  const { layer, id } = props;
  const componentManager = useDependency(ComponentManager);
  const size$ = (0, import_react4.useMemo)(() => layer.position$.pipe(
    distinctUntilChanged(
      (prev, curr) => prev.absolute.left === curr.absolute.left && prev.absolute.top === curr.absolute.top && prev.endX - prev.startX === curr.endX - curr.startX && prev.endY - prev.startY === curr.endY - curr.startY
    )
  ), [layer.position$]);
  const position = useObservable((0, import_react4.useMemo)(() => layer.position$.pipe(first()), [layer.position$]));
  const domRef = (0, import_react4.useRef)(null);
  const innerDomRef = (0, import_react4.useRef)(null);
  const transformRef = (0, import_react4.useRef)(`transform: rotate(${position == null ? void 0 : position.rotate}deg) translate(${position == null ? void 0 : position.startX}px, ${position == null ? void 0 : position.startY}px)`);
  const topRef = (0, import_react4.useRef)((_a = position == null ? void 0 : position.startY) != null ? _a : 0);
  const leftRef = (0, import_react4.useRef)((_b = position == null ? void 0 : position.startX) != null ? _b : 0);
  const innerStyle = (0, import_react4.useRef)({});
  const Component = typeof layer.componentKey === "string" ? componentManager.get(layer.componentKey) : layer.componentKey;
  const layerProps = (0, import_react4.useMemo)(() => ({
    data: layer.data,
    ...layer.props
  }), [layer.data, layer.props]);
  (0, import_react4.useEffect)(() => {
    const subscription = layer.position$.subscribe((position2) => {
      var _a2;
      transformRef.current = `rotate(${position2.rotate}deg)`;
      topRef.current = position2.startY;
      leftRef.current = position2.startX;
      if (domRef.current) {
        domRef.current.style.transform = transformRef.current;
        domRef.current.style.top = `${topRef.current}px`;
        domRef.current.style.left = `${leftRef.current}px`;
        domRef.current.style.opacity = `${(_a2 = position2.opacity) != null ? _a2 : 1}`;
      }
    });
    const sizeSubscription = size$.subscribe((size) => {
      if (domRef.current) {
        domRef.current.style.width = `${Math.max(size.endX - size.startX - 2, 0)}px`;
        domRef.current.style.height = `${Math.max(size.endY - size.startY - 2, 0)}px`;
      }
      if (innerDomRef.current) {
        const style = {
          width: `${size.width - 4}px`,
          height: `${size.height - 4}px`,
          left: `${size.absolute.left ? 0 : "auto"}`,
          top: `${size.absolute.top ? 0 : "auto"}`,
          right: `${size.absolute.left ? "auto" : 0}`,
          bottom: `${size.absolute.top ? "auto" : 0}`
        };
        innerDomRef.current.style.width = style.width;
        innerDomRef.current.style.height = style.height;
        innerDomRef.current.style.left = style.left;
        innerDomRef.current.style.top = style.top;
        innerDomRef.current.style.right = style.right;
        innerDomRef.current.style.bottom = style.bottom;
        innerStyle.current = style;
      }
    });
    return () => {
      subscription.unsubscribe();
      sizeSubscription.unsubscribe();
    };
  }, [layer.position$, size$]);
  const component = (0, import_react4.useMemo)(() => Component ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Component, { ...layerProps }) : null, [Component, layerProps]);
  if (!position) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    "div",
    {
      ref: domRef,
      className: "univer-z-10",
      style: {
        position: "absolute",
        top: topRef.current,
        left: leftRef.current,
        width: Math.max(position.endX - position.startX - 2, 0),
        height: Math.max(position.endY - position.startY - 2, 0),
        transform: transformRef.current,
        overflow: "hidden",
        transformOrigin: "center center"
      },
      onPointerMove: (e) => {
        layer.onPointerMove(e.nativeEvent);
      },
      onPointerDown: (e) => {
        layer.onPointerDown(e.nativeEvent);
      },
      onPointerUp: (e) => {
        layer.onPointerUp(e.nativeEvent);
      },
      onWheel: (e) => {
        layer.onWheel(e.nativeEvent);
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
        "div",
        {
          id,
          ref: innerDomRef,
          className: "univer-overflow-hidden",
          style: { position: "absolute", ...innerStyle.current },
          children: component
        }
      )
    }
  );
});
var FloatDom = ({ unitId }) => {
  var _a, _b;
  const instanceService = useDependency(IUniverInstanceService);
  const domLayerService = useDependency(CanvasFloatDomService);
  const layers = useObservable(domLayerService.domLayers$);
  const currentUnitId = unitId || ((_a = instanceService.getFocusedUnit()) == null ? void 0 : _a.getUnitId());
  return (_b = layers == null ? void 0 : layers.filter((layer) => layer[1].unitId === currentUnitId)) == null ? void 0 : _b.map((layer) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(
    FloatDomSingle,
    {
      id: layer[0],
      layer: layer[1]
    },
    layer[0]
  ));
};

// ../packages/ui/src/views/components/popup/CanvasPopup.tsx
var import_react7 = __toESM(require_react());

// ../packages/ui/src/services/popup/canvas-popup.service.ts
var ICanvasPopupService = createIdentifier("ui.popup.service");
var CanvasPopupService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_popupMap", /* @__PURE__ */ new Map());
    __publicField(this, "_popups$", new BehaviorSubject([]));
    __publicField(this, "popups$", this._popups$.asObservable());
    __publicField(this, "_activePopupId", null);
  }
  get popups() {
    return Array.from(this._popupMap.entries());
  }
  get activePopupId() {
    return this._activePopupId;
  }
  _update() {
    this._popups$.next(Array.from(this._popupMap.entries()));
  }
  dispose() {
    super.dispose();
    this._popups$.next([]);
    this._popups$.complete();
    this._popupMap.clear();
  }
  addPopup(item) {
    const id = Tools.generateRandomId();
    this._popupMap.set(id, {
      ...item,
      onPointerEnter: () => {
        this._activePopupId = id;
      },
      onPointerLeave: () => {
        if (this._activePopupId === id) {
          this._activePopupId = null;
        }
      }
    });
    this._update();
    return id;
  }
  removePopup(id) {
    if (this._popupMap.delete(id)) {
      this._update();
    }
  }
  removeAll() {
    this._popupMap.clear();
    this._update();
  }
};

// ../packages/ui/src/views/components/popup/RectPopup.tsx
var import_react6 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// ../packages/ui/src/components/hooks/event.ts
var import_react5 = __toESM(require_react());
function useEvent(func) {
  const funcRef = (0, import_react5.useRef)(func);
  funcRef.current = func;
  return (0, import_react5.useCallback)(
    (...params) => {
      var _a;
      return (_a = funcRef.current) == null ? void 0 : _a.call(funcRef, ...params);
    },
    []
  );
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/views/components/popup/index.module.less
var index_module_default = {
  "popupFixed": "univer-popup-fixed"
};

// ../packages/ui/src/views/components/popup/RectPopup.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var RectPopupContext = (0, import_react6.createContext)({ current: void 0 });
var PUSHING_MINIMUM_GAP = 8;
function calcPopupPosition(layout) {
  const { position, width, height, containerHeight, containerWidth, direction = "vertical" } = layout;
  if (direction === "vertical" || direction.includes("top") || direction.includes("bottom")) {
    const { left: startX2, top: startY2, right: endX2, bottom: endY2 } = position;
    const verticalStyle2 = direction === "vertical" && endY2 > containerHeight - height - PUSHING_MINIMUM_GAP || direction.indexOf("top") > -1 ? { top: Math.max(startY2 - height, PUSHING_MINIMUM_GAP) } : { top: Math.min(endY2, containerHeight - height - PUSHING_MINIMUM_GAP) };
    let horizontalStyle2;
    if (direction.includes("center")) {
      const rectWidth = endX2 - startX2;
      const offsetX = (rectWidth - width) / 2;
      horizontalStyle2 = {
        left: startX2 + offsetX
      };
    } else {
      horizontalStyle2 = startX2 + width > containerWidth ? { left: Math.max(endX2 - width, PUSHING_MINIMUM_GAP) } : { left: Math.min(startX2, containerWidth - width - PUSHING_MINIMUM_GAP) };
    }
    return { ...verticalStyle2, ...horizontalStyle2 };
  }
  const { left: startX, top: startY, right: endX, bottom: endY } = position;
  const horizontalStyle = direction === "left" ? { left: Math.max(startX - width, PUSHING_MINIMUM_GAP) } : { left: Math.min(endX, containerWidth - width - PUSHING_MINIMUM_GAP) };
  const verticalStyle = startY + height > containerHeight ? { top: Math.max(endY - height, PUSHING_MINIMUM_GAP) } : { top: Math.min(startY, containerHeight - height - PUSHING_MINIMUM_GAP) };
  return { ...verticalStyle, ...horizontalStyle };
}
function RectPopup(props) {
  const { portal, children, anchorRect$, direction = "vertical", onClickOutside, excludeOutside, excludeRects, onPointerEnter, onPointerLeave, onClick, hidden, onContextMenu } = props;
  const nodeRef = (0, import_react6.useRef)(null);
  const clickOtherFn = useEvent(onClickOutside != null ? onClickOutside : () => {
  });
  const contextMenuFn = useEvent(onContextMenu != null ? onContextMenu : () => {
  });
  const positionRef = (0, import_react6.useRef)({
    top: -9999,
    left: -9999
  });
  const excludeRectsRef = excludeRects;
  const anchorRectRef = (0, import_react6.useRef)(void 0);
  (0, import_react6.useEffect)(() => {
    const anchorRectSub = anchorRect$.subscribe((anchorRect) => {
      anchorRectRef.current = anchorRect;
      requestAnimationFrame(() => {
        if (!nodeRef.current) return;
        const { clientWidth, clientHeight } = nodeRef.current;
        const innerWidth = window.innerWidth;
        const innerHeight = window.innerHeight;
        positionRef.current = calcPopupPosition(
          {
            position: anchorRect,
            width: clientWidth,
            height: clientHeight,
            containerWidth: innerWidth,
            containerHeight: innerHeight,
            direction
          }
        );
        nodeRef.current.style.top = `${positionRef.current.top}px`;
        nodeRef.current.style.left = `${positionRef.current.left}px`;
      });
    });
    return () => anchorRectSub.unsubscribe();
  }, [anchorRect$, direction]);
  (0, import_react6.useEffect)(() => {
    const handleClickOther = (e) => {
      var _a;
      if (excludeOutside && (excludeOutside.indexOf(e.target) > -1 || excludeOutside.some(
        (item) => item.contains(e.target)
      ))) {
        return;
      }
      const x = e.clientX;
      const y = e.clientY;
      const rects = [...(_a = excludeRectsRef == null ? void 0 : excludeRectsRef.current) != null ? _a : []];
      if (anchorRectRef.current) {
        rects.push(anchorRectRef.current);
      }
      for (const rect of rects) {
        if (x <= rect.right && x >= rect.left && y <= rect.bottom && y >= rect.top) {
          return;
        }
      }
      clickOtherFn(e);
    };
    window.addEventListener("pointerdown", handleClickOther);
    return () => {
      window.removeEventListener("pointerdown", handleClickOther);
    };
  }, [clickOtherFn, excludeOutside, excludeRectsRef]);
  (0, import_react6.useEffect)(() => {
    const handleContextMenu = (e) => {
      if (e.ctrlKey && e.button === 0) {
        return;
      }
      contextMenuFn();
    };
    window.addEventListener("contextmenu", handleContextMenu);
    return () => {
      window.removeEventListener("contextmenu", handleContextMenu);
    };
  }, [contextMenuFn]);
  const ele = /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
    "section",
    {
      onPointerEnter,
      onPointerLeave,
      ref: nodeRef,
      style: { ...positionRef.current, ...hidden ? { display: "none" } : null },
      className: index_module_default.popupFixed,
      onPointerDown: (e) => e.stopPropagation(),
      onClick,
      children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(RectPopupContext.Provider, { value: anchorRectRef, children })
    }
  );
  return !portal ? ele : (0, import_react_dom.createPortal)(ele, document.getElementById("univer-popup-portal"));
}
RectPopup.calcPopupPosition = calcPopupPosition;
RectPopup.useContext = () => (0, import_react6.useContext)(RectPopupContext);

// ../packages/ui/src/views/components/popup/CanvasPopup.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var SingleCanvasPopup = ({ popup, children }) => {
  const [hidden, setHidden] = (0, import_react7.useState)(false);
  const anchorRect$ = (0, import_react7.useMemo)(() => popup.anchorRect$.pipe(
    throttleTime(0, animationFrameScheduler),
    map((anchorRect) => {
      var _a;
      const { bottom, left, right, top } = anchorRect;
      const [x = 0, y = 0] = (_a = popup.offset) != null ? _a : [];
      return {
        left: left - x,
        right: right + x,
        top: top - y,
        bottom: bottom + y
      };
    })
  ), [popup.anchorRect$, popup.offset]);
  const hiddenRects$ = (0, import_react7.useMemo)(() => {
    var _a, _b;
    return (_b = (_a = popup.hiddenRects$) == null ? void 0 : _a.pipe(throttleTime(0, animationFrameScheduler))) != null ? _b : of([]);
  }, [popup.hiddenRects$]);
  const excludeRects$ = (0, import_react7.useMemo)(() => {
    var _a;
    return (_a = popup.excludeRects$) == null ? void 0 : _a.pipe(throttleTime(0, animationFrameScheduler));
  }, [popup.excludeRects$]);
  const excludeRectsRef = useObservableRef(excludeRects$, popup.excludeRects);
  const { canvasElement, hideOnInvisible = true, hiddenType = "destroy" } = popup;
  (0, import_react7.useEffect)(() => {
    if (!hideOnInvisible) {
      return;
    }
    const anchorRectSub = combineLatest([anchorRect$, hiddenRects$]).subscribe(([rectWithOffset, hiddenRects]) => {
      const rect = canvasElement.getBoundingClientRect();
      const { top, left, bottom, right } = rect;
      const rectHeight = rectWithOffset.bottom - rectWithOffset.top;
      const rectWidth = rectWithOffset.right - rectWithOffset.left;
      const isInHiddenRect = hiddenRects.some((hiddenRect) => {
        return rectWithOffset.top >= hiddenRect.top - 0.5 * rectHeight && rectWithOffset.bottom <= hiddenRect.bottom + 0.5 * rectHeight && rectWithOffset.left >= hiddenRect.left - 0.5 * rectWidth && rectWithOffset.right <= hiddenRect.right + 0.5 * rectWidth;
      });
      if (rectWithOffset.bottom < top || rectWithOffset.top > bottom || rectWithOffset.right < left || rectWithOffset.left > right || isInHiddenRect) {
        setHidden(true);
      } else {
        setHidden(false);
      }
    });
    return () => anchorRectSub.unsubscribe();
  }, [canvasElement, hideOnInvisible, anchorRect$, hiddenRects$]);
  if (hidden && hiddenType === "destroy") {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    RectPopup,
    {
      hidden,
      anchorRect$,
      direction: popup.direction,
      onClickOutside: popup.onClickOutside,
      excludeOutside: popup.excludeOutside,
      excludeRects: excludeRectsRef,
      onPointerEnter: popup.onPointerEnter,
      onPointerLeave: popup.onPointerLeave,
      onClick: popup.onClick,
      onContextMenu: popup.onContextMenu,
      children
    }
  );
};
function CanvasPopup() {
  const popupService = useDependency(ICanvasPopupService);
  const componentManager = useDependency(ComponentManager);
  const popups = useObservable(popupService.popups$, void 0, true);
  return popups.map((item) => {
    const [key, popup] = item;
    const Component = componentManager.get(popup.componentKey);
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      SingleCanvasPopup,
      {
        popup,
        children: Component ? /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(Component, { popup }) : null
      },
      key
    );
  });
}

// ../packages/ui/src/views/mobile-workbench/MobileWorkbench.tsx
var import_react15 = __toESM(require_react());

// ../packages/ui/src/views/components/ComponentContainer.tsx
var import_react8 = __toESM(require_react());
function ComponentContainer(props) {
  const { components, fallback, sharedProps } = props;
  if (!components || components.size === 0) return fallback != null ? fallback : null;
  return Array.from(components.values()).map((component, index) => {
    var _a;
    return import_react8.default.createElement(component, { key: `${(_a = component.displayName) != null ? _a : index}`, ...sharedProps });
  });
}
function useComponentsOfPart(part, injector) {
  var _a;
  const uiPartsService = (_a = injector == null ? void 0 : injector.get(IUIPartsService)) != null ? _a : useDependency(IUIPartsService);
  const uiVisibleChange$ = (0, import_react8.useMemo)(() => uiPartsService.uiVisibleChange$.pipe(filter((ui) => ui.ui === part)), [part, uiPartsService]);
  const changeInfo = useObservable(uiVisibleChange$);
  const updateCounterRef = (0, import_react8.useRef)(0);
  const componentPartUpdateCount = useObservable(
    () => uiPartsService.componentRegistered$.pipe(
      filter((key) => key === part),
      debounceTime(200),
      map(() => updateCounterRef.current += 1),
      startWith(updateCounterRef.current += 1)
      // trigger update when subscribe
    ),
    void 0,
    void 0,
    [uiPartsService, part, changeInfo]
  );
  return (0, import_react8.useMemo)(() => uiPartsService.isUIVisible(part) ? uiPartsService.getComponents(part) : /* @__PURE__ */ new Set(), [componentPartUpdateCount]);
}

// ../packages/ui/src/views/components/context-menu/MobileContextMenu.tsx
var import_react11 = __toESM(require_react());

// ../packages/ui/src/components/menu/mobile/MobileMenu.tsx
var import_react10 = __toESM(require_react());

// ../packages/ui/src/common/menu-merge-configs.ts
function mergeMenuConfigs(baseConfig, additionalConfig) {
  if (!additionalConfig || !baseConfig) return baseConfig;
  const { hidden, disabled, activated } = additionalConfig;
  const properties = ["type", "icon", "title", "tooltip"];
  properties.forEach((prop) => {
    if (additionalConfig[prop] !== void 0) {
      baseConfig[prop] = additionalConfig[prop];
    }
  });
  const observableProperties = ["hidden", "disabled", "activated"];
  observableProperties.forEach((prop) => {
    updateReactiveProperty(baseConfig, `${prop}$`, additionalConfig[prop]);
  });
  return baseConfig;
}
function updateReactiveProperty(baseConfig, key, value) {
  if (value !== void 0) {
    if (baseConfig[key]) {
      const subject$ = baseConfig[key].pipe(
        switchMap(() => new BehaviorSubject(value))
      );
      baseConfig[key] = subject$;
    } else {
      baseConfig[key] = new Observable((subscriber) => {
        subscriber.next(value);
      });
    }
  }
}

// ../packages/ui/src/services/menu/types.ts
var MenuManagerPosition = /* @__PURE__ */ ((MenuManagerPosition2) => {
  MenuManagerPosition2["RIBBON"] = "ribbon";
  MenuManagerPosition2["CONTEXT_MENU"] = "contextMenu";
  return MenuManagerPosition2;
})(MenuManagerPosition || {});
var RibbonPosition = /* @__PURE__ */ ((RibbonPosition2) => {
  RibbonPosition2["START"] = "ribbon.start";
  RibbonPosition2["INSERT"] = "ribbon.insert";
  RibbonPosition2["FORMULAS"] = "ribbon.formulas";
  RibbonPosition2["DATA"] = "ribbon.data";
  RibbonPosition2["VIEW"] = "ribbon.view";
  RibbonPosition2["OTHERS"] = "ribbon.others";
  return RibbonPosition2;
})(RibbonPosition || {});
var RibbonStartGroup = /* @__PURE__ */ ((RibbonStartGroup2) => {
  RibbonStartGroup2["HISTORY"] = "ribbon.start.history";
  RibbonStartGroup2["FORMAT"] = "ribbon.start.format";
  RibbonStartGroup2["LAYOUT"] = "ribbon.start.layout";
  RibbonStartGroup2["FORMULAS_INSERT"] = "ribbon.start.insert";
  RibbonStartGroup2["FORMULAS_VIEW"] = "ribbon.start.view";
  RibbonStartGroup2["FILE"] = "ribbon.start.file";
  RibbonStartGroup2["OTHERS"] = "ribbon.start.others";
  return RibbonStartGroup2;
})(RibbonStartGroup || {});

// ../packages/ui/src/services/menu/menu-manager.service.ts
var IMenuManagerService = createIdentifier("univer.menu-manager-service");
var MenuManagerService = class extends Disposable {
  constructor(_injector, _configService) {
    super();
    this._injector = _injector;
    this._configService = _configService;
    __publicField(this, "menuChanged$", new Subject());
    __publicField(this, "_menu", {
      ["ribbon" /* RIBBON */]: {
        ["ribbon.start" /* START */]: {
          order: 0,
          ["ribbon.start.history" /* HISTORY */]: {
            order: 0
          },
          ["ribbon.start.format" /* FORMAT */]: {
            order: 1
          },
          ["ribbon.start.layout" /* LAYOUT */]: {
            order: 2
          },
          ["ribbon.start.insert" /* FORMULAS_INSERT */]: {
            order: 3
          },
          ["ribbon.start.view" /* FORMULAS_VIEW */]: {
            order: 4
          },
          ["ribbon.start.file" /* FILE */]: {
            order: 5
          },
          ["ribbon.start.others" /* OTHERS */]: {
            order: 6
          }
        },
        ["ribbon.insert" /* INSERT */]: {
          order: 1,
          ["ribbon.insert.others" /* OTHERS */]: {
            order: 0
          }
        },
        ["ribbon.formulas" /* FORMULAS */]: {
          order: 2,
          ["ribbon.formulas.others" /* OTHERS */]: {
            order: 0
          }
        },
        ["ribbon.data" /* DATA */]: {
          order: 3,
          ["ribbon.data.others" /* OTHERS */]: {
            order: 0
          }
        },
        ["ribbon.view" /* VIEW */]: {
          order: 4,
          ["ribbon.view.others" /* OTHERS */]: {
            order: 0
          }
        },
        ["ribbon.others" /* OTHERS */]: {
          order: 5,
          ["ribbon.others.others" /* OTHERS */]: {
            order: 0
          }
        }
      },
      ["contextMenu" /* CONTEXT_MENU */]: {
        ["contextMenu.mainArea" /* MAIN_AREA */]: {
          order: 0,
          ["contextMenu.format" /* FORMAT */]: {
            order: 0
          },
          ["contextMenu.layout" /* LAYOUT */]: {
            order: 1
          },
          ["contextMenu.data" /* DATA */]: {
            order: 2
          },
          ["contextMenu.others" /* OTHERS */]: {
            order: 3
          }
        },
        ["contextMenu.colHeader" /* COL_HEADER */]: {
          order: 1,
          ["contextMenu.format" /* FORMAT */]: {
            order: 0
          },
          ["contextMenu.layout" /* LAYOUT */]: {
            order: 1
          },
          ["contextMenu.data" /* DATA */]: {
            order: 2
          },
          ["contextMenu.others" /* OTHERS */]: {
            order: 3
          }
        },
        ["contextMenu.rowHeader" /* ROW_HEADER */]: {
          order: 2,
          ["contextMenu.format" /* FORMAT */]: {
            order: 0
          },
          ["contextMenu.layout" /* LAYOUT */]: {
            order: 1
          },
          ["contextMenu.data" /* DATA */]: {
            order: 2
          },
          ["contextMenu.others" /* OTHERS */]: {
            order: 3
          }
        },
        ["contextMenu.footerTabs" /* FOOTER_TABS */]: {
          order: 3,
          ["contextMenu.format" /* FORMAT */]: {
            order: 0
          },
          ["contextMenu.layout" /* LAYOUT */]: {
            order: 1
          },
          ["contextMenu.data" /* DATA */]: {
            order: 2
          },
          ["contextMenu.others" /* OTHERS */]: {
            order: 3
          }
        },
        ["contextMenu.footerMenu" /* FOOTER_MENU */]: {
          order: 4,
          ["contextMenu.others" /* OTHERS */]: {
            order: 3
          }
        }
      }
    });
  }
  dispose() {
    this.menuChanged$.complete();
  }
  /**
   * Merge source menu to target menu recursively
   * @param source
   * @param target default is root menu
   */
  mergeMenu(source, target) {
    const _target = target != null ? target : this._menu;
    for (const [key, value] of Object.entries(_target)) {
      if (key in source) {
        const _key = key;
        _target[_key] = merge_default({}, _target[_key], source[_key]);
        this.menuChanged$.next();
      } else {
        this.mergeMenu(source, value);
      }
    }
  }
  appendRootMenu(source) {
    this._menu = merge_default({}, this._menu, source);
    this.menuChanged$.next();
  }
  _buildMenuSchema(data2) {
    const result = [];
    for (const [key, value] of Object.entries(data2)) {
      const menuItem = {
        key,
        order: value.order
      };
      if (value.menuItemFactory) {
        const item = this._injector.invoke(value.menuItemFactory);
        if (item) {
          const menuItemConfig = this._configService.getConfig("menu");
          if (menuItemConfig && item.id in menuItemConfig) {
            const _key = item.id;
            menuItem.item = mergeMenuConfigs(item, menuItemConfig[_key]);
          } else {
            menuItem.item = item;
          }
        }
      }
      const children = this._buildMenuSchema(value);
      if (children.length > 0) {
        menuItem.children = children.sort((a, b) => a.order - b.order);
      }
      if (menuItem.item || menuItem.children) {
        result.push(menuItem);
      }
    }
    return result;
  }
  /**
   * Get menu schema by position key
   * @param key
   * @returns Menu schema array or empty array if not found
   */
  getMenuByPositionKey(key) {
    const findKey = (obj) => {
      if (key in obj) {
        return this._buildMenuSchema(obj[key]);
      }
      for (const k in obj) {
        if (k === key) {
          return this._buildMenuSchema(obj[k]);
        }
        if (typeof obj[k] === "object") {
          const result = findKey(obj[k]);
          if (result) {
            return result;
          }
        }
      }
    };
    return findKey(this._menu);
  }
  /**
   * Get flat menu schema by position key
   * @param key
   * @returns Flat menu schema array or empty array if not found
   */
  getFlatMenuByPositionKey(key) {
    const menu = this.getMenuByPositionKey(key);
    function flatMenuItems(items) {
      return items.reduce((acc, item) => {
        if (item.children) {
          return [...acc, item, ...flatMenuItems(item.children)];
        }
        return [...acc, item];
      }, []);
    }
    return flatMenuItems(menu);
  }
};
MenuManagerService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IConfigService)
], MenuManagerService);

// ../packages/ui/src/components/custom-label/CustomLabel.tsx
var import_react9 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
function CustomLabel(props) {
  const { title, icon, label, value, value$ } = props;
  const localeService = useDependency(LocaleService);
  const componentManager = useDependency(ComponentManager);
  const [subscribedValue, setSubscribedValue] = (0, import_react9.useState)(value);
  const [realIcon, setRealIcon] = (0, import_react9.useState)("");
  const nodes = [];
  let index = 0;
  (0, import_react9.useEffect)(() => {
    if (value$) {
      const subscription = value$.subscribe((v) => {
        setSubscribedValue(v);
      });
      return () => {
        subscription.unsubscribe();
      };
    }
  }, [value$]);
  const realValue = (0, import_react9.useMemo)(() => {
    return value != null ? value : subscribedValue;
  }, [subscribedValue, value]);
  (0, import_react9.useEffect)(() => {
    let subscription = null;
    if (isObservable(icon)) {
      subscription = icon.subscribe((v) => {
        setRealIcon(v);
      });
    } else {
      setRealIcon(icon != null ? icon : "");
    }
    return () => {
      subscription == null ? void 0 : subscription.unsubscribe();
    };
  }, [icon]);
  const isValid = (0, import_react9.useMemo)(() => {
    if (realValue && typeof realValue === "string") {
      return new ColorKit(realValue).isValid;
    }
    return false;
  }, [realValue]);
  if (icon) {
    const Icon = componentManager.get(realIcon != null ? realIcon : "");
    if (Icon) {
      nodes.push(
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          Icon,
          {
            extend: { colorChannel1: isValid ? realValue : "#2c53f1" }
          },
          index++
        )
      );
    }
  }
  if (label) {
    const isStringLabel = typeof label === "string";
    const customProps = isStringLabel ? { ...props } : { ...label == null ? void 0 : label.props, ...props };
    const labelName = isStringLabel ? label : label == null ? void 0 : label.name;
    const CustomComponent = componentManager.get(labelName);
    if (CustomComponent) {
      nodes.push(/* @__PURE__ */ (0, import_jsx_runtime4.jsx)(CustomComponent, { ...customProps, value: realValue }, index++));
    } else {
      nodes.push(/* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { children: localeService.t(labelName) }, index++));
    }
  }
  if (title) {
    nodes.push(/* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { children: typeof title === "string" ? localeService.t(title) : title }, index++));
  }
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: nodes });
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/components/menu/mobile/index.module.less
var index_module_default2 = {
  "mobileMenuContainer": "univer-mobile-menu-container",
  "mobileMenuItem": "univer-mobile-menu-item"
};

// ../packages/ui/src/components/menu/mobile/MobileMenu.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
function MobileMenu(props) {
  const { menuType, onOptionSelect } = props;
  const menuManagerService = useDependency(IMenuManagerService);
  if (!menuType) {
    return null;
  }
  const flattedMenuItems = (0, import_react10.useMemo)(() => {
    const menuItems = menuManagerService.getMenuByPositionKey(menuType);
    function flatMenuItems(items) {
      return items.reduce((acc, item) => {
        if (item.children) {
          return [...acc, ...flatMenuItems(item.children)];
        }
        return [...acc, item];
      }, []);
    }
    return flatMenuItems(menuItems);
  }, [menuType]);
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    "div",
    {
      className: index_module_default2.mobileMenuContainer,
      style: {
        gridTemplateColumns: `repeat(${Math.min(2, flattedMenuItems.length)}, 48px)`
      },
      children: flattedMenuItems.map((item) => item.item && /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
        MobileMenuItem,
        {
          menuItem: item.item,
          onClick: (object) => onOptionSelect == null ? void 0 : onOptionSelect({ value: "", label: item.key, ...object })
        },
        item.key
      ))
    }
  );
}
function MobileMenuItem(props) {
  const { menuItem, onClick } = props;
  const { id, type: type2, title, label, icon } = menuItem;
  if (type2 !== 0 /* BUTTON */) {
    throw new Error(`[MobileMenuItem]: on mobile devices only "BUTTON" type menu items are supported. Please check "${id}".`);
  }
  const disabled = useObservable(menuItem.disabled$, false);
  const activated = useObservable(menuItem.activated$, false);
  const hidden = useObservable(menuItem.hidden$, false);
  const value = useObservable(menuItem.value$);
  const className = clsx(index_module_default2.mobileMenuItem, {
    [index_module_default2.mobileMenuItemActivated]: activated,
    [index_module_default2.mobileMenuItemHidden]: hidden
  });
  return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
    "button",
    {
      type: "button",
      className,
      disabled,
      onClick: () => onClick({ id }),
      children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(CustomLabel, { value, title, label, icon })
    },
    id
  );
}

// ../packages/ui/src/services/contextmenu/contextmenu.service.ts
var IContextMenuService = createIdentifier("ui.contextmenu.service");
var ContextMenuService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_currentHandler", null);
    __publicField(this, "disabled", false);
  }
  get visible() {
    var _a, _b;
    return (_b = (_a = this._currentHandler) == null ? void 0 : _a.visible) != null ? _b : false;
  }
  disable() {
    this.disabled = true;
  }
  enable() {
    this.disabled = false;
  }
  triggerContextMenu(event, menuType) {
    var _a;
    event.stopPropagation();
    if (this.disabled) return;
    (_a = this._currentHandler) == null ? void 0 : _a.handleContextMenu(event, menuType);
  }
  hideContextMenu() {
    var _a;
    (_a = this._currentHandler) == null ? void 0 : _a.hideContextMenu();
  }
  registerContextMenuHandler(handler) {
    if (this._currentHandler) {
      throw new Error("There is already a context menu handler!");
    }
    this._currentHandler = handler;
    return toDisposable(() => this._currentHandler = null);
  }
};

// ../packages/ui/src/views/components/context-menu/MobileContextMenu.tsx
var import_jsx_runtime6 = (
  // TODO@wzhudev: change to mobile menu
  __toESM(require_jsx_runtime())
);
function MobileContextMenu() {
  const [visible, setVisible] = (0, import_react11.useState)(false);
  const [menuType, setMenuType] = (0, import_react11.useState)("");
  const [offset, setOffset] = (0, import_react11.useState)([0, 0]);
  const visibleRef = (0, import_react11.useRef)(visible);
  const contextMenuService = useDependency(IContextMenuService);
  const commandService = useDependency(ICommandService);
  visibleRef.current = visible;
  (0, import_react11.useEffect)(() => {
    const disposables = contextMenuService.registerContextMenuHandler({
      handleContextMenu,
      hideContextMenu() {
        setVisible(false);
      },
      get visible() {
        return visibleRef.current;
      }
    });
    document.addEventListener("pointerdown", handleClose);
    document.addEventListener("wheel", handleClose);
    return () => {
      document.removeEventListener("pointerdown", handleClose);
      document.removeEventListener("wheel", handleClose);
      disposables.dispose();
    };
  }, [contextMenuService]);
  function handleContextMenu(event, menuType2) {
    setMenuType(menuType2);
    setOffset([event.clientX, event.clientY]);
    setVisible(true);
  }
  function handleClose() {
    setVisible(false);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(Popup, { visible, offset, children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("section", { onPointerDown: (e) => e.stopPropagation(), children: menuType && /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
    MobileMenu,
    {
      menuType,
      onOptionSelect: (params) => {
        const { label: id, value, commandId } = params;
        commandService && commandService.executeCommand(commandId != null ? commandId : id, { value });
        setVisible(false);
      }
    }
  ) }) });
}

// ../packages/ui/src/views/components/global-zone/GlobalZone.tsx
var import_react12 = __toESM(require_react());

// ../packages/ui/src/services/global-zone/global-zone.service.ts
var IGlobalZoneService = createIdentifier("univer.global-zone-service");

// ../packages/ui/src/views/components/global-zone/GlobalZone.tsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
function GlobalZone() {
  const globalZoneService = useDependency(IGlobalZoneService);
  const [visible, setVisible] = (0, import_react12.useState)(false);
  const componentKey = useObservable(globalZoneService.componentKey$, globalZoneService.componentKey);
  const componentManager = useDependency(ComponentManager);
  const Component = (0, import_react12.useMemo)(() => {
    const Component2 = componentManager.get(componentKey != null ? componentKey : "");
    if (Component2) {
      return Component2;
    }
  }, [componentKey, componentManager]);
  (0, import_react12.useEffect)(() => {
    const subscription = globalZoneService.visible$.subscribe((val) => {
      setVisible(val);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [globalZoneService.visible$]);
  if (!visible) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
    "section",
    {
      className: clsx(
        "univer-absolute univer-bg-gray-100",
        {
          "univer-hidden": !visible,
          "univer-inset-0 univer-z-[100] univer-block univer-size-full": visible
        }
      ),
      children: Component && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(Component, {})
    }
  );
}

// ../packages/ui/src/views/components/sidebar/Sidebar.tsx
var import_react13 = __toESM(require_react());

// ../packages/ui/src/services/sidebar/sidebar.service.ts
var ILeftSidebarService = createIdentifier("ui.left-sidebar.service");
var ISidebarService = createIdentifier("ui.sidebar.service");

// ../packages/ui/src/views/components/sidebar/Sidebar.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
function Sidebar() {
  const sidebarService = useDependency(ISidebarService);
  const sidebarOptions = useObservable(sidebarService.sidebarOptions$);
  const scrollRef = (0, import_react13.useRef)(null);
  const options = (0, import_react13.useMemo)(() => {
    if (!sidebarOptions) {
      return null;
    }
    const copy = { ...sidebarOptions };
    for (const key of ["children", "header", "footer"]) {
      const k = key;
      if (sidebarOptions[k]) {
        const { key: key2, ...props } = sidebarOptions[k];
        if (props) {
          copy[k] = /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(CustomLabel, { ...props }, key2);
        }
      }
    }
    return copy;
  }, [sidebarOptions]);
  (0, import_react13.useEffect)(() => {
    if (scrollRef.current) {
      sidebarService.setContainer(scrollRef.current);
    }
    return () => {
      sidebarService.setContainer(void 0);
    };
  }, [sidebarService]);
  (0, import_react13.useEffect)(() => {
    const handleScroll = (e) => {
      sidebarService.scrollEvent$.next(e);
    };
    const scrollElement = scrollRef.current;
    if (scrollElement) {
      scrollElement.addEventListener("scroll", handleScroll);
    }
    return () => {
      scrollElement == null ? void 0 : scrollElement.removeEventListener("scroll", handleScroll);
    };
  }, [sidebarService]);
  const width = (0, import_react13.useMemo)(() => {
    if (!(options == null ? void 0 : options.visible)) return 0;
    if (typeof options.width === "number") {
      return `${options.width}px`;
    }
    return options.width;
  }, [options]);
  function handleClose() {
    var _a;
    const options2 = {
      ...sidebarOptions,
      visible: false
    };
    sidebarService.options.visible = false;
    sidebarService.sidebarOptions$.next(options2);
    (_a = options2 == null ? void 0 : options2.onClose) == null ? void 0 : _a.call(options2);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
    "section",
    {
      className: clsx("univer-relative univer-h-full univer-text-gray-800", {
        "univer-w-96 univer-translate-x-0": options == null ? void 0 : options.visible,
        "univer-w-0 univer-translate-x-full": !(options == null ? void 0 : options.visible)
      }),
      style: { width },
      children: /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
        "section",
        {
          className: `
                  univer-box-border univer-grid univer-h-0 univer-min-h-full univer-grid-rows-[auto_1fr_auto]
                  univer-overflow-y-auto univer-border-0 univer-border-b univer-border-l univer-border-solid
                  univer-border-gray-200 univer-bg-white univer-scrollbar-thin univer-scrollbar-track-gray-50
                  univer-scrollbar-thumb-gray-300
                `,
          ref: scrollRef,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(
              "header",
              {
                className: `
                      univer-sticky univer-top-0 univer-z-10 univer-box-border univer-flex univer-items-center
                      univer-justify-between univer-bg-white univer-p-4 univer-pb-2 univer-text-base univer-font-medium
                    `,
                children: [
                  options == null ? void 0 : options.header,
                  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("a", { className: "univer-cursor-pointer univer-text-gray-500", onClick: handleClose, children: /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(close_single_default, {}) })
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("section", { className: "univer-box-border univer-px-4", style: options == null ? void 0 : options.bodyStyle, children: options == null ? void 0 : options.children }),
            (options == null ? void 0 : options.footer) && /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
              "footer",
              {
                className: "univer-sticky univer-bottom-0 univer-box-border univer-bg-white univer-p-4",
                children: options.footer
              }
            )
          ]
        }
      )
    }
  );
}

// ../packages/ui/src/views/components/zen-zone/ZenZone.tsx
var import_react14 = __toESM(require_react());

// ../packages/ui/src/services/zen-zone/zen-zone.service.ts
var IZenZoneService = createIdentifier("univer.zen-zone-service");

// ../packages/ui/src/views/components/zen-zone/ZenZone.tsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
function ZenZone() {
  const zenZoneService = useDependency(IZenZoneService);
  const [visible, setVisible] = (0, import_react14.useState)(false);
  const [componentKey, setComponentKey] = (0, import_react14.useState)();
  const hidden = useObservable(zenZoneService.temporaryHidden$);
  const componentManager = useDependency(ComponentManager);
  (0, import_react14.useEffect)(() => {
    const subscriptions = [
      zenZoneService.visible$.subscribe((visible2) => {
        setVisible(visible2);
      }),
      zenZoneService.componentKey$.subscribe((componentKey2) => {
        setComponentKey(componentKey2);
      })
    ];
    return () => {
      subscriptions.forEach((subscription) => {
        subscription.unsubscribe();
      });
    };
  }, []);
  const Component = (0, import_react14.useMemo)(() => {
    const Component2 = componentManager.get(componentKey != null ? componentKey : "");
    if (Component2) {
      return Component2;
    }
  }, [componentKey]);
  return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
    "section",
    {
      className: clsx("univer-absolute univer-z-[-1] univer-flex", {
        "univer-inset-0 univer-z-[100] univer-bg-gray-100 univer-animate-in univer-fade-in": visible,
        "univer-hidden": hidden
      }),
      children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "univer-relative univer-flex-1", children: Component && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(Component, {}) })
    }
  );
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/views/mobile-workbench/mobile-workbench.module.less
var mobile_workbench_module_default = {
  "appLayout": "univer-app-layout",
  "appCustomHeader": "univer-app-custom-header",
  "appHeader": "univer-app-header",
  "appContainer": "univer-app-container",
  "appContainerHeader": "univer-app-container-header",
  "appContainerWrapper": "univer-app-container-wrapper",
  "appContainerContent": "univer-app-container-content",
  "appContainerCanvas": "univer-app-container-canvas",
  "appContainerLeftSidebar": "univer-app-container-left-sidebar",
  "appContainerSidebar": "univer-app-container-sidebar"
};

// ../packages/ui/src/views/mobile-workbench/MobileWorkbench.tsx
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
function MobileWorkbench(props) {
  const {
    header = true,
    footer = true,
    contextMenu = true,
    mountContainer,
    onRendered
  } = props;
  const localeService = useDependency(LocaleService);
  const themeService = useDependency(ThemeService);
  const contentRef = (0, import_react15.useRef)(null);
  const footerComponents = useComponentsOfPart("footer" /* FOOTER */);
  const headerComponents = useComponentsOfPart("header" /* HEADER */);
  const contentComponents = useComponentsOfPart("content" /* CONTENT */);
  const leftSidebarComponents = useComponentsOfPart("left-sidebar" /* LEFT_SIDEBAR */);
  const globalComponents = useComponentsOfPart("global" /* GLOBAL */);
  (0, import_react15.useEffect)(() => {
    if (!themeService.getCurrentTheme()) {
      themeService.setTheme(default_module_default);
    }
  }, []);
  (0, import_react15.useEffect)(() => {
    if (contentRef.current) {
      onRendered == null ? void 0 : onRendered(contentRef.current);
    }
  }, [onRendered]);
  const [locale, setLocale] = (0, import_react15.useState)(localeService.getLocales());
  const portalContainer = (0, import_react15.useMemo)(() => document.createElement("div"), []);
  (0, import_react15.useEffect)(() => {
    document.body.appendChild(portalContainer);
    const subscriptions = [
      localeService.localeChanged$.subscribe(() => {
        setLocale(localeService.getLocales());
      }),
      themeService.currentTheme$.subscribe((theme) => {
        themeInstance.setTheme(mountContainer, theme);
        portalContainer && themeInstance.setTheme(portalContainer, theme);
      })
    ];
    return () => {
      subscriptions.forEach((subscription) => subscription.unsubscribe());
      document.body.removeChild(portalContainer);
    };
  }, [localeService, mountContainer, portalContainer, themeService.currentTheme$]);
  return /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)(ConfigProvider, { locale: locale == null ? void 0 : locale.design, mountContainer: portalContainer, children: [
    /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: mobile_workbench_module_default.appLayout, tabIndex: -1, onBlur: (e) => e.stopPropagation(), children: [
      header && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("header", { className: mobile_workbench_module_default.appContainerHeader }),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("section", { className: mobile_workbench_module_default.appContainer, children: [
        /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: mobile_workbench_module_default.appContainerWrapper, children: [
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("aside", { className: mobile_workbench_module_default.appContainerLeftSidebar, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ComponentContainer, { components: leftSidebarComponents }, "left-sidebar") }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("section", { className: mobile_workbench_module_default.appContainerContent, children: [
            /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("header", { className: mobile_workbench_module_default.appHeader, children: header && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ComponentContainer, { components: headerComponents }, "header") }),
            /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
              "section",
              {
                className: mobile_workbench_module_default.appContainerCanvas,
                ref: contentRef,
                "data-range-selector": true,
                onContextMenu: (e) => e.preventDefault(),
                children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ComponentContainer, { components: contentComponents }, "content")
              }
            )
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("aside", { className: mobile_workbench_module_default.appContainerSidebar, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(Sidebar, {}) })
        ] }),
        footer && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("footer", { className: mobile_workbench_module_default.appFooter, children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ComponentContainer, { components: footerComponents }, "footer") }),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(GlobalZone, {}),
        /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ZenZone, {})
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(ComponentContainer, { components: globalComponents }, "global"),
    contextMenu && /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(MobileContextMenu, {})
  ] });
}

// ../packages/ui/src/controllers/ui/ui-shared.controller.ts
var STEADY_TIMEOUT = 3e3;
var SingleUnitUIController = class extends Disposable {
  constructor(_injector, _instanceService, _layoutService, _lifecycleService, _renderManagerService) {
    super();
    this._injector = _injector;
    this._instanceService = _instanceService;
    this._layoutService = _layoutService;
    this._lifecycleService = _lifecycleService;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_steadyTimeout");
    __publicField(this, "_renderTimeout");
    __publicField(this, "_currentRenderId", null);
  }
  dispose() {
    super.dispose();
    clearTimeout(this._steadyTimeout);
    clearTimeout(this._renderTimeout);
  }
  _bootstrapWorkbench() {
    this.disposeWithMe(this.bootstrap(async (contentElement, containerElement) => {
      if (this._layoutService) {
        this.disposeWithMe(this._layoutService.registerRootContainerElement(containerElement));
        this.disposeWithMe(this._layoutService.registerContentElement(contentElement));
      }
      await this._lifecycleService.onStage(1 /* Ready */);
      this._renderTimeout = window.setTimeout(() => {
        const allRenders = this._renderManagerService.getRenderAll();
        for (const [key, render2] of allRenders) {
          if (this._changeRenderUnit(key, contentElement)) break;
        }
        this.disposeWithMe(this._instanceService.focused$.subscribe((unit) => {
          if (unit) this._changeRenderUnit(unit, contentElement);
        }));
        this.disposeWithMe(this._renderManagerService.created$.subscribe((renderer) => {
          var _a;
          if (renderer.unitId === ((_a = this._instanceService.getFocusedUnit()) == null ? void 0 : _a.getUnitId())) this._changeRenderUnit(renderer.unitId, contentElement);
        }));
        this.disposeWithMe(this._renderManagerService.disposed$.subscribe((renderer) => {
          if (this._currentRenderId === renderer) this._currentRenderId = null;
        }));
        this._lifecycleService.stage = 2 /* Rendered */;
        this._steadyTimeout = window.setTimeout(() => {
          this._lifecycleService.stage = 3 /* Steady */;
        }, STEADY_TIMEOUT);
      }, 300);
    }));
  }
  _changeRenderUnit(rendererId, contentElement) {
    if (this._currentRenderId === rendererId) return false;
    const renderer = this._renderManagerService.getRenderById(rendererId);
    if (!renderer || !renderer.unitId || isInternalEditorID(renderer.unitId)) return false;
    const currentRenderer = this._currentRenderId ? this._renderManagerService.getRenderById(this._currentRenderId) : null;
    currentRenderer == null ? void 0 : currentRenderer.deactivate();
    currentRenderer == null ? void 0 : currentRenderer.engine.unmount();
    renderer.engine.mount(contentElement);
    renderer.activate();
    this._currentRenderId = rendererId;
    return true;
  }
};

// ../packages/ui/src/controllers/ui/ui-mobile.controller.tsx
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var MobileUIController = class extends SingleUnitUIController {
  constructor(_config, injector, lifecycleService, renderManagerService, layoutService, instanceService, uiPartsService) {
    super(injector, instanceService, layoutService, lifecycleService, renderManagerService);
    this._config = _config;
    this._initBuiltinComponents(uiPartsService);
    this._bootstrapWorkbench();
  }
  bootstrap(callback) {
    return bootstrap(this._injector, this._config, callback);
  }
  _initBuiltinComponents(uiPartsService) {
    this.disposeWithMe(uiPartsService.registerComponent("content" /* CONTENT */, () => connectInjector(CanvasPopup, this._injector)));
    this.disposeWithMe(uiPartsService.registerComponent("content" /* CONTENT */, () => connectInjector(FloatDom, this._injector)));
  }
};
MobileUIController = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, Inject(LifecycleService)),
  __decorateParam(3, IRenderManagerService),
  __decorateParam(4, ILayoutService),
  __decorateParam(5, IUniverInstanceService),
  __decorateParam(6, IUIPartsService)
], MobileUIController);
function bootstrap(injector, options, callback) {
  let mountContainer;
  const container = options.container;
  if (typeof container === "string") {
    const containerElement = document.getElementById(container);
    if (!containerElement) {
      mountContainer = createContainer(container);
    } else {
      mountContainer = containerElement;
    }
  } else if (container instanceof HTMLElement) {
    mountContainer = container;
  } else {
    mountContainer = createContainer("univer");
  }
  const ConnectedApp = connectInjector(MobileWorkbench, injector);
  const onRendered = (canvasElement) => callback(canvasElement, mountContainer);
  function render2() {
    render(
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
        ConnectedApp,
        {
          ...options,
          mountContainer,
          onRendered
        }
      ),
      mountContainer
    );
  }
  render2();
  return toDisposable(() => {
    unmount(mountContainer);
  });
}
function createContainer(id) {
  const element = document.createElement("div");
  element.id = id;
  return element;
}

// ../packages/ui/src/controllers/ui/ui.controller.ts
var IUIController = createIdentifier("univer.ui.ui-controller");

// ../packages/ui/src/services/notification/notification.service.ts
var INotificationService = createIdentifier("ui.notification.service");

// ../packages/ui/src/services/before-close/before-close.service.ts
var IBeforeCloseService = createIdentifier("univer.ui.before-close-service");
var DesktopBeforeCloseService = class {
  constructor(_notificationService) {
    this._notificationService = _notificationService;
    __publicField(this, "_beforeUnloadCallbacks", []);
    __publicField(this, "_onCloseCallbacks", []);
    this._init();
  }
  registerBeforeClose(callback) {
    this._beforeUnloadCallbacks.push(callback);
    return {
      dispose: () => {
        this._beforeUnloadCallbacks = this._beforeUnloadCallbacks.filter((cb) => cb !== callback);
      }
    };
  }
  registerOnClose(callback) {
    this._onCloseCallbacks.push(callback);
    return {
      dispose: () => {
        this._onCloseCallbacks = this._onCloseCallbacks.filter((cb) => cb !== callback);
      }
    };
  }
  _init() {
    window.addEventListener("beforeunload", (_event) => {
      let event = _event;
      const message2 = this._beforeUnloadCallbacks.map((callback) => callback()).filter((m) => !!m).join("\n");
      if (message2) {
        this._notificationService.show({
          type: "error",
          title: "Some changes are not saved",
          content: message2
        });
        if (typeof event === "undefined") {
          event = window.event;
        }
        event.returnValue = message2;
        return message2;
      }
    });
    window.addEventListener("unload", () => {
      this._onCloseCallbacks.forEach((callback) => callback());
    });
  }
};
DesktopBeforeCloseService = __decorateClass([
  __decorateParam(0, INotificationService)
], DesktopBeforeCloseService);

// ../packages/ui/src/services/clipboard/clipboard-utils.ts
function supportClipboardAPI() {
  return typeof navigator.clipboard !== "undefined" && typeof navigator.clipboard.readText !== "undefined";
}

// ../packages/ui/src/services/clipboard/clipboard-interface.service.ts
var PLAIN_TEXT_CLIPBOARD_MIME_TYPE = "text/plain";
var HTML_CLIPBOARD_MIME_TYPE = "text/html";
var FILE_PNG_CLIPBOARD_MIME_TYPE = "image/png";
var FILE__JPEG_CLIPBOARD_MIME_TYPE = "image/jpeg";
var FILE__BMP_CLIPBOARD_MIME_TYPE = "image/bmp";
var FILE__WEBP_CLIPBOARD_MIME_TYPE = "image/webp";
var imageMimeTypeSet = /* @__PURE__ */ new Set([
  FILE__BMP_CLIPBOARD_MIME_TYPE,
  FILE__JPEG_CLIPBOARD_MIME_TYPE,
  FILE__WEBP_CLIPBOARD_MIME_TYPE,
  FILE_PNG_CLIPBOARD_MIME_TYPE
]);
var IClipboardInterfaceService = createIdentifier(
  "univer.clipboard-interface-service"
);
var BrowserClipboardService = class extends Disposable {
  constructor(_localeService, _logService, _notificationService) {
    super();
    this._localeService = _localeService;
    this._logService = _logService;
    this._notificationService = _notificationService;
  }
  get supportClipboard() {
    return supportClipboardAPI();
  }
  async write(text, html2) {
    if (!this.supportClipboard) {
      return this._legacyCopyHtml(html2);
    }
    try {
      return await navigator.clipboard.write([
        new ClipboardItem({
          [PLAIN_TEXT_CLIPBOARD_MIME_TYPE]: new Blob([text], { type: PLAIN_TEXT_CLIPBOARD_MIME_TYPE }),
          [HTML_CLIPBOARD_MIME_TYPE]: new Blob([html2], { type: HTML_CLIPBOARD_MIME_TYPE })
        })
      ]);
    } catch (error) {
      this._logService.error("[BrowserClipboardService]", error);
      this._showClipboardAuthenticationNotification();
    }
  }
  async writeText(text) {
    if (!this.supportClipboard) {
      return this._legacyCopyText(text);
    }
    try {
      return await navigator.clipboard.writeText(text);
    } catch (error) {
      this._logService.error("[BrowserClipboardService]", error);
      this._showClipboardAuthenticationNotification();
    }
  }
  async read() {
    if (!this.supportClipboard) {
      throw new Error("[BrowserClipboardService] read() is not supported on this platform.");
    }
    try {
      return navigator.clipboard.read();
    } catch (e) {
      this._logService.error("[BrowserClipboardService]", e);
      this._showClipboardAuthenticationNotification();
      return [];
    }
  }
  async readText() {
    if (!this.supportClipboard) {
      throw new Error("[BrowserClipboardService] read() is not supported on this platform.");
    }
    try {
      return await navigator.clipboard.readText();
    } catch (e) {
      this._logService.error("[BrowserClipboardService]", e);
      this._showClipboardAuthenticationNotification();
      return "";
    }
  }
  _legacyCopyHtml(html2) {
    const activeElement = document.activeElement;
    const container = createCopyHtmlContainer();
    document.body.appendChild(container);
    container.innerHTML = html2;
    try {
      select(container);
      document.execCommand("copy");
    } finally {
      if (activeElement instanceof HTMLElement) {
        activeElement.focus();
      }
      document.body.removeChild(container);
    }
  }
  _legacyCopyText(text) {
    const activeElement = document.activeElement;
    const container = createCopyTextContainer();
    document.body.appendChild(container);
    container.value = text;
    try {
      select(container);
      document.execCommand("copy");
    } finally {
      if (activeElement instanceof HTMLElement) {
        activeElement.focus();
      }
      document.body.removeChild(container);
    }
  }
  _showClipboardAuthenticationNotification() {
    var _a;
    (_a = this._notificationService) == null ? void 0 : _a.show({
      type: "warning",
      title: this._localeService.t("clipboard.authentication.title"),
      content: this._localeService.t("clipboard.authentication.content")
    });
  }
};
BrowserClipboardService = __decorateClass([
  __decorateParam(0, Inject(LocaleService)),
  __decorateParam(1, ILogService),
  __decorateParam(2, Optional(INotificationService))
], BrowserClipboardService);
function createCopyTextContainer() {
  const textArea = document.createElement("textarea");
  textArea.style.position = "absolute";
  textArea.style.height = "1px";
  textArea.style.width = "1px";
  textArea.style.opacity = "0";
  textArea.readOnly = true;
  return textArea;
}
function createCopyHtmlContainer() {
  const div = document.createElement("div");
  div.contentEditable = "true";
  div.style.position = "absolute";
  div.style.opacity = "0";
  div.style.height = "1px";
  div.style.width = "1px";
  return div;
}
function select(element) {
  if (element instanceof HTMLTextAreaElement) {
    const isReadOnly = element.hasAttribute("readonly");
    if (!isReadOnly) {
      element.setAttribute("readonly", "");
    }
    element.select();
    element.setSelectionRange(0, element.value.length);
    if (!isReadOnly) {
      element.removeAttribute("readonly");
    }
    return element.value;
  }
  if (element.hasAttribute("contenteditable")) {
    element.focus();
  }
  const range = document.createRange();
  range.selectNodeContents(element);
  const selection = window.getSelection();
  if (!selection) {
    throw new Error();
  }
  selection.removeAllRanges();
  selection.addRange(range);
  return selection.toString();
}

// ../packages/ui/src/services/confirm/confirm.service.ts
var IConfirmService = createIdentifier("univer.confirm-service");

// ../packages/ui/src/views/components/confirm-part/ConfirmPart.tsx
var import_react16 = __toESM(require_react());
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
function ConfirmPart() {
  const confirmService = useDependency(IConfirmService);
  const [confirmOptions, setConfirmOptions] = (0, import_react16.useState)([]);
  (0, import_react16.useEffect)(() => {
    const subscription = confirmService.confirmOptions$.subscribe((options) => {
      setConfirmOptions(options);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  const props = confirmOptions.map((options) => {
    const { children, title, ...restProps } = options;
    const confirmProps = restProps;
    for (const key of ["children", "title"]) {
      const k = key;
      const props2 = options[k];
      if (props2) {
        confirmProps[k] = /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(CustomLabel, { ...props2 });
      }
    }
    return confirmProps;
  });
  return props == null ? void 0 : props.map((options, index) => /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Confirm, { ...options }, index));
}

// ../packages/ui/src/services/confirm/desktop-confirm.service.ts
var DesktopConfirmService = class extends Disposable {
  constructor(_injector, _uiPartsService) {
    super();
    this._injector = _injector;
    this._uiPartsService = _uiPartsService;
    __publicField(this, "_confirmOptions", []);
    __publicField(this, "confirmOptions$", new BehaviorSubject([]));
    this._initUIPart();
  }
  open(option) {
    if (this._confirmOptions.find((item) => item.id === option.id)) {
      this._confirmOptions = this._confirmOptions.map((item) => ({
        ...item.id === option.id ? option : item,
        visible: item.id === option.id ? true : item.visible
      }));
    } else {
      this._confirmOptions.push({
        ...option,
        visible: true
      });
    }
    this.confirmOptions$.next(this._confirmOptions);
    return toDisposable(() => {
      this._confirmOptions = [];
      this.confirmOptions$.next([]);
    });
  }
  confirm(params) {
    return new Promise((resolve) => {
      const disposeHandler = this.open({
        ...params,
        onConfirm: () => {
          disposeHandler.dispose();
          resolve(true);
        },
        onClose: () => {
          disposeHandler.dispose();
          resolve(false);
        }
      });
    });
  }
  close(id) {
    this._confirmOptions = this._confirmOptions.map((item) => ({
      ...item,
      visible: item.id === id ? false : item.visible
    }));
    this.confirmOptions$.next([...this._confirmOptions]);
  }
  _initUIPart() {
    this.disposeWithMe(
      this._uiPartsService.registerComponent("global" /* GLOBAL */, () => connectInjector(ConfirmPart, this._injector))
    );
  }
};
DesktopConfirmService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IUIPartsService)
], DesktopConfirmService);

// ../packages/ui/src/views/components/dialog-part/DialogPart.tsx
var import_react17 = __toESM(require_react());

// ../packages/ui/src/services/dialog/dialog.service.ts
var IDialogService = createIdentifier("univer.ui.dialog-service");

// ../packages/ui/src/views/components/dialog-part/DialogPart.tsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
function DialogPart() {
  const dialogService = useDependency(IDialogService);
  const [dialogOptions, setDialogOptions] = (0, import_react17.useState)([]);
  (0, import_react17.useEffect)(() => {
    const dialog$ = dialogService.getDialogs$();
    const subscription = dialog$.subscribe((options) => {
      setDialogOptions(options);
    });
    return () => subscription.unsubscribe();
  }, [dialogService]);
  const attrs = dialogOptions.map((options) => {
    const { children, title, closeIcon, footer, ...restProps } = options;
    const dialogProps = restProps;
    for (const key of ["children", "title", "closeIcon", "footer"]) {
      const k = key;
      const props = options[k];
      if (props) {
        dialogProps[k] = /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(CustomLabel, { ...props });
      }
    }
    return dialogProps;
  });
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, { children: attrs == null ? void 0 : attrs.map((options) => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(Dialog, { ...options }, options.id)) });
}

// ../packages/ui/src/services/dialog/desktop-dialog.service.ts
var DesktopDialogService = class extends Disposable {
  constructor(_injector, _uiPartsService) {
    super();
    this._injector = _injector;
    this._uiPartsService = _uiPartsService;
    __publicField(this, "_dialogOptions", []);
    __publicField(this, "_dialogOptions$", new Subject());
    this._initUIPart();
  }
  dispose() {
    super.dispose();
    this._dialogOptions$.complete();
  }
  open(option) {
    if (this._dialogOptions.find((item) => item.id === option.id)) {
      this._dialogOptions = this._dialogOptions.map((item) => ({
        ...item.id === option.id ? option : item,
        visible: item.id === option.id ? true : item.visible
      }));
    } else {
      this._dialogOptions.push({
        ...option,
        visible: true
      });
    }
    this._dialogOptions$.next(this._dialogOptions);
    return toDisposable(() => {
      this._dialogOptions = [];
      this._dialogOptions$.next([]);
    });
  }
  close(id) {
    this._dialogOptions = this._dialogOptions.map((item) => ({
      ...item,
      visible: item.id === id ? false : item.visible
    }));
    this._dialogOptions$.next([...this._dialogOptions]);
  }
  closeAll(expectIds) {
    const expectIdSet = new Set(expectIds);
    this._dialogOptions = this._dialogOptions.map((item) => ({
      ...item,
      visible: expectIdSet.has(item.id) ? item.visible : false
    }));
    this._dialogOptions$.next([...this._dialogOptions]);
  }
  getDialogs$() {
    return this._dialogOptions$.asObservable();
  }
  _initUIPart() {
    this.disposeWithMe(
      this._uiPartsService.registerComponent("global" /* GLOBAL */, () => connectInjector(DialogPart, this._injector))
    );
  }
};
DesktopDialogService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IUIPartsService)
], DesktopDialogService);

// ../packages/ui/src/services/global-zone/desktop-global-zone.service.ts
var DesktopGlobalZoneService = class {
  constructor(_componentManager) {
    this._componentManager = _componentManager;
    __publicField(this, "visible$", new Subject());
    __publicField(this, "componentKey$", new Subject());
    __publicField(this, "_componentKey", "");
  }
  get componentKey() {
    return this._componentKey;
  }
  set(key, component) {
    this._componentManager.register(key, component);
    this.componentKey$.next(key);
    this._componentKey = key;
    return toDisposable(() => {
      this._componentManager.delete(key);
      this.visible$.complete();
      this.componentKey$.complete();
    });
  }
  open() {
    this.visible$.next(true);
  }
  close() {
    this.visible$.next(false);
  }
};
DesktopGlobalZoneService = __decorateClass([
  __decorateParam(0, Inject(ComponentManager))
], DesktopGlobalZoneService);

// ../packages/ui/src/services/local-storage/local-storage.service.ts
var import_localforage = __toESM(require_localforage());
var DesktopLocalStorageService = class {
  getItem(key) {
    return import_localforage.default.getItem(key);
  }
  setItem(key, value) {
    return import_localforage.default.setItem(key, value);
  }
  removeItem(key) {
    return import_localforage.default.removeItem(key);
  }
  clear() {
    return import_localforage.default.clear();
  }
  key(index) {
    return import_localforage.default.key(index);
  }
  keys() {
    return import_localforage.default.keys();
  }
  iterate(iteratee) {
    return import_localforage.default.iterate(iteratee);
  }
};

// ../packages/ui/src/services/message/desktop-message.service.ts
var DesktopMessageService = class extends Disposable {
  constructor(_injector, _uiPartsService) {
    super();
    this._injector = _injector;
    this._uiPartsService = _uiPartsService;
    this._initUIPart();
  }
  _initUIPart() {
    this.disposeWithMe(
      this._uiPartsService.registerComponent("global" /* GLOBAL */, () => connectInjector(Messager, this._injector))
    );
  }
  dispose() {
    removeMessage();
  }
  show(options) {
    message(options);
  }
};
DesktopMessageService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IUIPartsService)
], DesktopMessageService);

// ../node_modules/.pnpm/@babel+runtime@7.25.4/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

// ../node_modules/.pnpm/@babel+runtime@7.25.4/node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

// ../node_modules/.pnpm/@babel+runtime@7.25.4/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// ../node_modules/.pnpm/@babel+runtime@7.25.4/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/hooks/useNotification.js
var React15 = __toESM(require_react());

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/Notifications.js
var React14 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/NoticeList.js
var import_react19 = __toESM(require_react());
var import_classnames2 = __toESM(require_classnames());

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/Notice.js
var import_classnames = __toESM(require_classnames());
var React11 = __toESM(require_react());
var Notify = /* @__PURE__ */ React11.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, style = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, showProgress = props.showProgress, _props$pauseOnHover = props.pauseOnHover, pauseOnHover = _props$pauseOnHover === void 0 ? true : _props$pauseOnHover, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times, forcedHovering = props.hovering;
  var _React$useState = React11.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
  var _React$useState3 = React11.useState(0), _React$useState4 = _slicedToArray(_React$useState3, 2), percent = _React$useState4[0], setPercent = _React$useState4[1];
  var _React$useState5 = React11.useState(0), _React$useState6 = _slicedToArray(_React$useState5, 2), spentTime = _React$useState6[0], setSpentTime = _React$useState6[1];
  var mergedHovering = forcedHovering || hovering;
  var mergedShowProgress = duration > 0 && showProgress;
  var onInternalClose = function onInternalClose2() {
    onNoticeClose(eventKey);
  };
  var onCloseKeyDown = function onCloseKeyDown2(e) {
    if (e.key === "Enter" || e.code === "Enter" || e.keyCode === KeyCode_default.ENTER) {
      onInternalClose();
    }
  };
  React11.useEffect(function() {
    if (!mergedHovering && duration > 0) {
      var start = Date.now() - spentTime;
      var timeout = setTimeout(function() {
        onInternalClose();
      }, duration * 1e3 - spentTime);
      return function() {
        if (pauseOnHover) {
          clearTimeout(timeout);
        }
        setSpentTime(Date.now() - start);
      };
    }
  }, [duration, mergedHovering, times]);
  React11.useEffect(function() {
    if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
      var start = performance.now();
      var animationFrame;
      var calculate = function calculate2() {
        cancelAnimationFrame(animationFrame);
        animationFrame = requestAnimationFrame(function(timestamp) {
          var runtime = timestamp + spentTime - start;
          var progress = Math.min(runtime / (duration * 1e3), 1);
          setPercent(progress * 100);
          if (progress < 1) {
            calculate2();
          }
        });
      };
      calculate();
      return function() {
        if (pauseOnHover) {
          cancelAnimationFrame(animationFrame);
        }
      };
    }
  }, [duration, spentTime, mergedHovering, mergedShowProgress, times]);
  var closableObj = React11.useMemo(function() {
    if (_typeof(closable) === "object" && closable !== null) {
      return closable;
    }
    if (closable) {
      return {
        closeIcon
      };
    }
    return {};
  }, [closable, closeIcon]);
  var ariaProps = pickAttrs(closableObj, true);
  var validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);
  var noticePrefixCls = "".concat(prefixCls, "-notice");
  return /* @__PURE__ */ React11.createElement("div", _extends({}, divProps, {
    ref,
    className: (0, import_classnames.default)(noticePrefixCls, className, _defineProperty({}, "".concat(noticePrefixCls, "-closable"), closable)),
    style,
    onMouseEnter: function onMouseEnter(e) {
      var _divProps$onMouseEnte;
      setHovering(true);
      divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e);
    },
    onMouseLeave: function onMouseLeave(e) {
      var _divProps$onMouseLeav;
      setHovering(false);
      divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e);
    },
    onClick
  }), /* @__PURE__ */ React11.createElement("div", {
    className: "".concat(noticePrefixCls, "-content")
  }, content), closable && /* @__PURE__ */ React11.createElement("a", _extends({
    tabIndex: 0,
    className: "".concat(noticePrefixCls, "-close"),
    onKeyDown: onCloseKeyDown,
    "aria-label": "Close"
  }, ariaProps, {
    onClick: function onClick2(e) {
      e.preventDefault();
      e.stopPropagation();
      onInternalClose();
    }
  }), closableObj.closeIcon), mergedShowProgress && /* @__PURE__ */ React11.createElement("progress", {
    className: "".concat(noticePrefixCls, "-progress"),
    max: "100",
    value: validPercent
  }, validPercent + "%"));
});
var Notice_default = Notify;

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/NotificationProvider.js
var import_react18 = __toESM(require_react());
var NotificationContext = /* @__PURE__ */ import_react18.default.createContext({});

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/hooks/useStack.js
var DEFAULT_OFFSET = 8;
var DEFAULT_THRESHOLD = 3;
var DEFAULT_GAP = 16;
var useStack = function useStack2(config) {
  var result = {
    offset: DEFAULT_OFFSET,
    threshold: DEFAULT_THRESHOLD,
    gap: DEFAULT_GAP
  };
  if (config && _typeof(config) === "object") {
    var _config$offset, _config$threshold, _config$gap;
    result.offset = (_config$offset = config.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET;
    result.threshold = (_config$threshold = config.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;
    result.gap = (_config$gap = config.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;
  }
  return [!!config, result];
};
var useStack_default = useStack;

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/NoticeList.js
var _excluded = ["className", "style", "classNames", "styles"];
var NoticeList = function NoticeList2(props) {
  var configList = props.configList, placement = props.placement, prefixCls = props.prefixCls, className = props.className, style = props.style, motion = props.motion, onAllNoticeRemoved = props.onAllNoticeRemoved, onNoticeClose = props.onNoticeClose, stackConfig = props.stack;
  var _useContext = (0, import_react19.useContext)(NotificationContext), ctxCls = _useContext.classNames;
  var dictRef = (0, import_react19.useRef)({});
  var _useState = (0, import_react19.useState)(null), _useState2 = _slicedToArray(_useState, 2), latestNotice = _useState2[0], setLatestNotice = _useState2[1];
  var _useState3 = (0, import_react19.useState)([]), _useState4 = _slicedToArray(_useState3, 2), hoverKeys = _useState4[0], setHoverKeys = _useState4[1];
  var keys = configList.map(function(config) {
    return {
      config,
      key: String(config.key)
    };
  });
  var _useStack = useStack_default(stackConfig), _useStack2 = _slicedToArray(_useStack, 2), stack = _useStack2[0], _useStack2$ = _useStack2[1], offset = _useStack2$.offset, threshold = _useStack2$.threshold, gap = _useStack2$.gap;
  var expanded = stack && (hoverKeys.length > 0 || keys.length <= threshold);
  var placementMotion = typeof motion === "function" ? motion(placement) : motion;
  (0, import_react19.useEffect)(function() {
    if (stack && hoverKeys.length > 1) {
      setHoverKeys(function(prev) {
        return prev.filter(function(key) {
          return keys.some(function(_ref) {
            var dataKey = _ref.key;
            return key === dataKey;
          });
        });
      });
    }
  }, [hoverKeys, keys, stack]);
  (0, import_react19.useEffect)(function() {
    var _keys;
    if (stack && dictRef.current[(_keys = keys[keys.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {
      var _keys2;
      setLatestNotice(dictRef.current[(_keys2 = keys[keys.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);
    }
  }, [keys, stack]);
  return /* @__PURE__ */ import_react19.default.createElement(CSSMotionList_default, _extends({
    key: placement,
    className: (0, import_classnames2.default)(prefixCls, "".concat(prefixCls, "-").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-stack"), !!stack), "".concat(prefixCls, "-stack-expanded"), expanded)),
    style,
    keys,
    motionAppear: true
  }, placementMotion, {
    onAllRemoved: function onAllRemoved() {
      onAllNoticeRemoved(placement);
    }
  }), function(_ref2, nodeRef) {
    var config = _ref2.config, motionClassName = _ref2.className, motionStyle = _ref2.style, motionIndex = _ref2.index;
    var _ref3 = config, key = _ref3.key, times = _ref3.times;
    var strKey = String(key);
    var _ref4 = config, configClassName = _ref4.className, configStyle = _ref4.style, configClassNames = _ref4.classNames, configStyles = _ref4.styles, restConfig = _objectWithoutProperties(_ref4, _excluded);
    var dataIndex = keys.findIndex(function(item) {
      return item.key === strKey;
    });
    var stackStyle = {};
    if (stack) {
      var index = keys.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
      var transformX = placement === "top" || placement === "bottom" ? "-50%" : "0";
      if (index > 0) {
        var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;
        stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;
        var verticalOffset = 0;
        for (var i = 0; i < index; i++) {
          var _dictRef$current$keys;
          verticalOffset += ((_dictRef$current$keys = dictRef.current[keys[keys.length - 1 - i].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;
        }
        var transformY = (expanded ? verticalOffset : index * offset) * (placement.startsWith("top") ? 1 : -1);
        var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset * 2 * (index < 3 ? index : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;
        stackStyle.transform = "translate3d(".concat(transformX, ", ").concat(transformY, "px, 0) scaleX(").concat(scaleX, ")");
      } else {
        stackStyle.transform = "translate3d(".concat(transformX, ", 0, 0)");
      }
    }
    return /* @__PURE__ */ import_react19.default.createElement("div", {
      ref: nodeRef,
      className: (0, import_classnames2.default)("".concat(prefixCls, "-notice-wrapper"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),
      style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),
      onMouseEnter: function onMouseEnter() {
        return setHoverKeys(function(prev) {
          return prev.includes(strKey) ? prev : [].concat(_toConsumableArray(prev), [strKey]);
        });
      },
      onMouseLeave: function onMouseLeave() {
        return setHoverKeys(function(prev) {
          return prev.filter(function(k) {
            return k !== strKey;
          });
        });
      }
    }, /* @__PURE__ */ import_react19.default.createElement(Notice_default, _extends({}, restConfig, {
      ref: function ref(node) {
        if (dataIndex > -1) {
          dictRef.current[strKey] = node;
        } else {
          delete dictRef.current[strKey];
        }
      },
      prefixCls,
      classNames: configClassNames,
      styles: configStyles,
      className: (0, import_classnames2.default)(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),
      style: configStyle,
      times,
      key,
      eventKey: key,
      onNoticeClose,
      hovering: stack && hoverKeys.length > 0
    })));
  });
};
if (true) {
  NoticeList.displayName = "NoticeList";
}
var NoticeList_default = NoticeList;

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/Notifications.js
var Notifications = /* @__PURE__ */ React14.forwardRef(function(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container = props.container, motion = props.motion, maxCount = props.maxCount, className = props.className, style = props.style, onAllRemoved = props.onAllRemoved, stack = props.stack, renderNotifications = props.renderNotifications;
  var _React$useState = React14.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
  var onNoticeClose = function onNoticeClose2(key) {
    var _config$onClose;
    var config = configList.find(function(item) {
      return item.key === key;
    });
    config === null || config === void 0 || (_config$onClose = config.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config);
    setConfigList(function(list) {
      return list.filter(function(item) {
        return item.key !== key;
      });
    });
  };
  React14.useImperativeHandle(ref, function() {
    return {
      open: function open(config) {
        setConfigList(function(list) {
          var clone = _toConsumableArray(list);
          var index = clone.findIndex(function(item) {
            return item.key === config.key;
          });
          var innerConfig = _objectSpread2({}, config);
          if (index >= 0) {
            var _list$index;
            innerConfig.times = (((_list$index = list[index]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
            clone[index] = innerConfig;
          } else {
            innerConfig.times = 0;
            clone.push(innerConfig);
          }
          if (maxCount > 0 && clone.length > maxCount) {
            clone = clone.slice(-maxCount);
          }
          return clone;
        });
      },
      close: function close(key) {
        onNoticeClose(key);
      },
      destroy: function destroy() {
        setConfigList([]);
      }
    };
  });
  var _React$useState3 = React14.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements = _React$useState4[0], setPlacements = _React$useState4[1];
  React14.useEffect(function() {
    var nextPlacements = {};
    configList.forEach(function(config) {
      var _config$placement = config.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
      if (placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
        nextPlacements[placement].push(config);
      }
    });
    Object.keys(placements).forEach(function(placement) {
      nextPlacements[placement] = nextPlacements[placement] || [];
    });
    setPlacements(nextPlacements);
  }, [configList]);
  var onAllNoticeRemoved = function onAllNoticeRemoved2(placement) {
    setPlacements(function(originPlacements) {
      var clone = _objectSpread2({}, originPlacements);
      var list = clone[placement] || [];
      if (!list.length) {
        delete clone[placement];
      }
      return clone;
    });
  };
  var emptyRef = React14.useRef(false);
  React14.useEffect(function() {
    if (Object.keys(placements).length > 0) {
      emptyRef.current = true;
    } else if (emptyRef.current) {
      onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();
      emptyRef.current = false;
    }
  }, [placements]);
  if (!container) {
    return null;
  }
  var placementList = Object.keys(placements);
  return /* @__PURE__ */ (0, import_react_dom2.createPortal)(/* @__PURE__ */ React14.createElement(React14.Fragment, null, placementList.map(function(placement) {
    var placementConfigList = placements[placement];
    var list = /* @__PURE__ */ React14.createElement(NoticeList_default, {
      key: placement,
      configList: placementConfigList,
      placement,
      prefixCls,
      className: className === null || className === void 0 ? void 0 : className(placement),
      style: style === null || style === void 0 ? void 0 : style(placement),
      motion,
      onNoticeClose,
      onAllNoticeRemoved,
      stack
    });
    return renderNotifications ? renderNotifications(list, {
      prefixCls,
      key: placement
    }) : list;
  })), container);
});
if (true) {
  Notifications.displayName = "Notifications";
}
var Notifications_default = Notifications;

// ../node_modules/.pnpm/rc-notification@5.6.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/rc-notification/es/hooks/useNotification.js
var _excluded2 = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"];
var defaultGetContainer = function defaultGetContainer2() {
  return document.body;
};
var uniqueKey = 0;
function mergeConfig() {
  var clone = {};
  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
    objList[_key] = arguments[_key];
  }
  objList.forEach(function(obj) {
    if (obj) {
      Object.keys(obj).forEach(function(key) {
        var val = obj[key];
        if (val !== void 0) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
function useNotification() {
  var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _rootConfig$getContai = rootConfig.getContainer, getContainer = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, stack = rootConfig.stack, renderNotifications = rootConfig.renderNotifications, shareConfig = _objectWithoutProperties(rootConfig, _excluded2);
  var _React$useState = React15.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];
  var notificationsRef = React15.useRef();
  var contextHolder = /* @__PURE__ */ React15.createElement(Notifications_default, {
    container,
    ref: notificationsRef,
    prefixCls,
    motion,
    maxCount,
    className,
    style,
    onAllRemoved,
    stack,
    renderNotifications
  });
  var _React$useState3 = React15.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue = _React$useState4[0], setTaskQueue = _React$useState4[1];
  var api = React15.useMemo(function() {
    return {
      open: function open(config) {
        var mergedConfig = mergeConfig(shareConfig, config);
        if (mergedConfig.key === null || mergedConfig.key === void 0) {
          mergedConfig.key = "rc-notification-".concat(uniqueKey);
          uniqueKey += 1;
        }
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "open",
            config: mergedConfig
          }]);
        });
      },
      close: function close(key) {
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "close",
            key
          }]);
        });
      },
      destroy: function destroy() {
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "destroy"
          }]);
        });
      }
    };
  }, []);
  React15.useEffect(function() {
    setContainer(getContainer());
  });
  React15.useEffect(function() {
    if (notificationsRef.current && taskQueue.length) {
      taskQueue.forEach(function(task) {
        switch (task.type) {
          case "open":
            notificationsRef.current.open(task.config);
            break;
          case "close":
            notificationsRef.current.close(task.key);
            break;
          case "destroy":
            notificationsRef.current.destroy();
            break;
        }
      });
      setTaskQueue(function(oriQueue) {
        return oriQueue.filter(function(task) {
          return !taskQueue.includes(task);
        });
      });
    }
  }, [taskQueue]);
  return [api, contextHolder];
}

// ../packages/ui/src/components/notification/Notification.tsx
var import_react20 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/components/notification/index.module.less
var index_module_default3 = {
  "notification": "univer-notification",
  "notificationNotice": "univer-notification-notice",
  "notificationNoticeWrapper": "univer-notification-notice-wrapper",
  "notificationNoticeContent": "univer-notification-notice-content",
  "notificationNoticeClose": "univer-notification-notice-close",
  "notificationIcon": "univer-notification-icon",
  "notificationIconSuccess": "univer-notification-icon-success",
  "notificationIconInfo": "univer-notification-icon-info",
  "notificationIconWarning": "univer-notification-icon-warning",
  "notificationIconError": "univer-notification-icon-error",
  "notificationContentContainer": "univer-notification-content-container",
  "notificationTitle": "univer-notification-title",
  "notificationContent": "univer-notification-content",
  "notificationContentEllipsis": "univer-notification-content-ellipsis",
  "notificationTop": "univer-notification-top",
  "notificationTopLeft": "univer-notification-topLeft",
  "notificationTopRight": "univer-notification-topRight",
  "notificationBottom": "univer-notification-bottom",
  "notificationBottomRight": "univer-notification-bottomRight",
  "notificationBottomLeft": "univer-notification-bottomLeft",
  "notificationFade": "univer-notification-fade",
  "notificationFadeAppearPrepare": "univer-notification-fade-appear-prepare",
  "notificationFadeAppearStart": "univer-notification-fade-appear-start",
  "notificationFadeAppearActive": "univer-notification-fade-appear-active",
  "notificationFadeAppear": "univer-notification-fade-appear",
  "notificationFadeEnter": "univer-notification-fade-enter",
  "notificationFadeLeave": "univer-notification-fade-leave",
  "notificationFadeEnterActive": "univer-notification-fade-enter-active",
  "notificationFadeIn": "univer-notification-fade-in",
  "notificationFadeLeaveActive": "univer-notification-fade-leave-active",
  "notificationFadeOut": "univer-notification-fade-out"
};

// ../packages/ui/src/components/notification/Notification.tsx
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var iconMap = {
  success: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(success_single_default, { className: index_module_default3.notificationIconSuccess }),
  info: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(warning_single_default, { className: index_module_default3.notificationIconInfo }),
  warning: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(warning_single_default, { className: index_module_default3.notificationIconWarning }),
  error: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(error_single_default, { className: index_module_default3.notificationIconError })
};
var notificationObserver = new Subject();
var PureContent = (props) => {
  const { type: type2, content, title, lines = 0 } = props;
  const contentClassName = clsx(index_module_default3.notificationContent, {
    [index_module_default3.notificationContentEllipsis]: lines !== 0
  });
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(import_jsx_runtime14.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: index_module_default3.notificationIcon, children: iconMap[type2] }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: index_module_default3.notificationContentContainer, children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: index_module_default3.notificationTitle, children: title }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { className: contentClassName, style: { WebkitLineClamp: lines }, children: content })
    ] })
  ] });
};
function Notification() {
  const { mountContainer } = (0, import_react20.useContext)(ConfigContext);
  if (!mountContainer) return null;
  const [api, contextHolder] = useNotification({
    prefixCls: index_module_default3.notification,
    maxCount: 3,
    closeIcon: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(close_single_default, {}),
    getContainer: () => mountContainer,
    motion: {
      motionName: index_module_default3.notificationFade,
      motionAppear: true,
      motionEnter: true,
      motionLeave: true
    }
  });
  const observerRef = (0, import_react20.useRef)(notificationObserver);
  (0, import_react20.useEffect)(() => {
    const subscription = observerRef.current.subscribe((options) => {
      var _a, _b, _c;
      api.open({
        content: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
          PureContent,
          {
            content: options.content,
            type: options.type,
            title: options.title,
            lines: options.lines
          }
        ),
        key: options.key,
        placement: (_a = options.placement) != null ? _a : "topRight",
        duration: (_b = options.duration) != null ? _b : 4.5,
        closable: (_c = options.closable) != null ? _c : true
      });
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [api]);
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children: contextHolder });
}
var notification = {
  show: (options) => {
    notificationObserver.next(options);
  }
};

// ../packages/ui/src/services/notification/desktop-notification.service.ts
var DesktopNotificationService = class extends Disposable {
  constructor(_injector, _uiPartsService) {
    super();
    this._injector = _injector;
    this._uiPartsService = _uiPartsService;
    this._initUIPart();
  }
  show(params) {
    notification.show(params);
    return toDisposable(() => {
    });
  }
  _initUIPart() {
    this.disposeWithMe(this._uiPartsService.registerComponent("global" /* GLOBAL */, () => connectInjector(Notification, this._injector)));
  }
};
DesktopNotificationService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IUIPartsService)
], DesktopNotificationService);

// ../packages/ui/src/services/shortcut/shortcut-panel.service.ts
var ShortcutPanelService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_open$", new BehaviorSubject(false));
    __publicField(this, "open$", this._open$.pipe(distinctUntilChanged()));
  }
  get isOpen() {
    return this._open$.getValue();
  }
  dispose() {
    super.dispose();
    this._open$.next(false);
    this._open$.complete();
  }
  open() {
    this._open$.next(true);
  }
  close() {
    this._open$.next(false);
  }
};

// ../packages/ui/src/services/sidebar/desktop-sidebar.service.ts
var DesktopSidebarService = class {
  constructor() {
    __publicField(this, "_sidebarOptions", {});
    __publicField(this, "sidebarOptions$", new Subject());
    __publicField(this, "scrollEvent$", new Subject());
    __publicField(this, "_container");
  }
  get visible() {
    return this._sidebarOptions.visible || false;
  }
  get options() {
    return this._sidebarOptions;
  }
  open(params) {
    this._sidebarOptions = {
      ...params,
      id: params.id,
      visible: true
    };
    this.sidebarOptions$.next(this._sidebarOptions);
    return toDisposable(() => {
      this.close();
    });
  }
  close(id) {
    if (id && this._sidebarOptions.id !== id) {
      return;
    }
    this._sidebarOptions = {
      ...this._sidebarOptions,
      visible: false
    };
    this.sidebarOptions$.next(this._sidebarOptions);
    this._sidebarOptions.onClose && this._sidebarOptions.onClose();
  }
  getContainer() {
    return this._container;
  }
  setContainer(element) {
    this._container = element;
  }
};

// ../packages/ui/src/services/zen-zone/desktop-zen-zone.service.ts
var DesktopZenZoneService = class {
  constructor(_componentManager) {
    this._componentManager = _componentManager;
    __publicField(this, "visible$", new BehaviorSubject(false));
    __publicField(this, "componentKey$", new ReplaySubject());
    __publicField(this, "_temporaryHidden$", new BehaviorSubject(false));
    __publicField(this, "temporaryHidden$", this._temporaryHidden$.asObservable());
    __publicField(this, "_visible", false);
  }
  get visible() {
    return this._visible;
  }
  get temporaryHidden() {
    return this._temporaryHidden$.getValue();
  }
  dispose() {
    this.visible$.next(false);
    this.visible$.complete();
    this.componentKey$.complete();
  }
  hide() {
    this._temporaryHidden$.next(true);
  }
  show() {
    this._temporaryHidden$.next(false);
  }
  set(key, component) {
    this._componentManager.register(key, component);
    this.componentKey$.next(key);
    return toDisposable(() => {
      this._componentManager.delete(key);
      this.visible$.complete();
      this.componentKey$.complete();
    });
  }
  open() {
    this._visible = true;
    this.visible$.next(true);
  }
  close() {
    this._visible = false;
    this.visible$.next(false);
  }
};
DesktopZenZoneService = __decorateClass([
  __decorateParam(0, Inject(ComponentManager))
], DesktopZenZoneService);

// ../packages/ui/src/mobile-ui-plugin.ts
var UNIVER_MOBILE_UI_PLUGIN_NAME = "UNIVER_MOBILE_UI_PLUGIN";
var UniverMobileUIPlugin = class extends Plugin {
  constructor(_config, _injector) {
    super();
    this._config = _config;
    this._injector = _injector;
  }
  onStarting() {
    const dependencies = mergeOverrideWithDependencies([
      [ComponentManager],
      [ZIndexManager],
      // services
      [ShortcutPanelService],
      [IUIPartsService, { useClass: UIPartsService }],
      [ILayoutService, { useClass: DesktopLayoutService }],
      [IShortcutService, { useClass: ShortcutService }],
      [IPlatformService, { useClass: PlatformService }],
      [IMenuManagerService, { useClass: MenuManagerService }],
      [IContextMenuService, { useClass: ContextMenuService }],
      [IClipboardInterfaceService, { useClass: BrowserClipboardService, lazy: true }],
      [INotificationService, { useClass: DesktopNotificationService, lazy: true }],
      [IDialogService, { useClass: DesktopDialogService, lazy: true }],
      [IConfirmService, { useClass: DesktopConfirmService, lazy: true }],
      [ISidebarService, { useClass: DesktopSidebarService, lazy: true }],
      [IZenZoneService, { useClass: DesktopZenZoneService, lazy: true }],
      [IGlobalZoneService, { useClass: DesktopGlobalZoneService, lazy: true }],
      [IMessageService, { useClass: DesktopMessageService, lazy: true }],
      [ILocalStorageService, { useClass: DesktopLocalStorageService, lazy: true }],
      [IBeforeCloseService, { useClass: DesktopBeforeCloseService }],
      [ICanvasPopupService, { useClass: CanvasPopupService }],
      [CanvasFloatDomService],
      // controllers
      [
        IUIController,
        {
          useFactory: (injector) => injector.createInstance(MobileUIController, this._config),
          deps: [Injector]
        }
      ],
      [SharedController],
      [ErrorController]
    ], this._config.override);
    dependencies.forEach((dependency) => this._injector.add(dependency));
    this._injector.get(IUIController);
    this._injector.get(ErrorController);
  }
};
__publicField(UniverMobileUIPlugin, "pluginName", UNIVER_MOBILE_UI_PLUGIN_NAME);
UniverMobileUIPlugin = __decorateClass([
  DependentOn(UniverRenderEnginePlugin),
  __decorateParam(1, Inject(Injector))
], UniverMobileUIPlugin);

// ../packages/ui/src/controllers/config.schema.ts
var UI_PLUGIN_CONFIG_KEY = "ui.config";
var configSymbol2 = Symbol(UI_PLUGIN_CONFIG_KEY);
var defaultPluginConfig2 = {};

// ../packages/ui/src/commands/operations/toggle-shortcut-panel.operation.ts
var ShortcutPanelComponentName = "ShortcutPanel";
var ToggleShortcutPanelOperation = {
  id: "base-ui.operation.toggle-shortcut-panel",
  type: 1 /* OPERATION */,
  handler: (accessor) => {
    const shortcutPanelService = accessor.get(ShortcutPanelService);
    const sidebarService = accessor.get(ISidebarService);
    const isOpen = shortcutPanelService.isOpen;
    if (isOpen) {
      shortcutPanelService.close();
      sidebarService.close();
    } else {
      shortcutPanelService.open();
      sidebarService.open({
        header: { title: "shortcut-panel.title" },
        children: { label: ShortcutPanelComponentName }
      });
    }
    return true;
  }
};

// ../packages/ui/src/views/components/shortcut-panel/ShortcutPanel.tsx
var import_react21 = __toESM(require_react());
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
function ShortcutPanel() {
  const shortcutService = useDependency(IShortcutService);
  const localeService = useDependency(LocaleService);
  const currentLocale = useObservable(localeService.currentLocale$);
  const [shortcutItems, setShortcutItems] = import_react21.default.useState([]);
  const updateShortcuts = (0, import_react21.useCallback)(() => {
    var _a;
    const shortcutGroups = /* @__PURE__ */ new Map();
    const shortcuts = shortcutService.getAllShortcuts().filter((item) => !!item.group);
    for (const shortcut of shortcuts) {
      const group = shortcut.group;
      const shortcutItem = {
        title: localeService.t((_a = shortcut.description) != null ? _a : shortcut.id),
        shortcut: shortcutService.getShortcutDisplay(shortcut)
      };
      if (!/\d+_[a-zA-Z0-9]/.test(group)) {
        throw new Error(`[ShortcutPanel]: Invalid shortcut group: ${group}!`);
      }
      if (!shortcutGroups.has(group)) {
        shortcutGroups.set(group, []);
      }
      shortcutGroups.get(group).push(shortcutItem);
    }
    const toRender = Array.from(shortcutGroups.entries()).map(([name, items]) => {
      const groupSequence = name.split("_")[0];
      const groupName = name.slice(groupSequence.length + 1);
      return {
        sequence: +groupSequence,
        name: localeService.t(groupName),
        items
      };
    }).sort((a, b) => a.sequence - b.sequence);
    setShortcutItems(toRender);
  }, [shortcutService, localeService, currentLocale]);
  (0, import_react21.useEffect)(() => {
    updateShortcuts();
    const subscription = shortcutService.shortcutChanged$.subscribe(() => updateShortcuts());
    return () => subscription.unsubscribe();
  }, [shortcutService, updateShortcuts]);
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("ul", { className: "univer-m-0 univer-list-none univer-p-0 univer-text-gray-900", children: shortcutItems.map((group) => /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("li", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: "univer-flex univer-h-10 univer-items-center univer-text-sm univer-font-semibold", children: group.name }),
    /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      "ul",
      {
        className: `
                          univer-list-none univer-p-0
                          [&>li]:univer-border-0 [&>li]:univer-border-b [&>li]:univer-border-solid
                          [&>li]:univer-border-b-gray-200
                        `,
        children: group.items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(
          "li",
          {
            className: `
                                  univer-flex univer-h-10 univer-items-center univer-justify-between univer-text-[13px]
                                  last:univer-border-b-0
                                `,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { className: "univer-line-clamp-1", children: item.title }),
              /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { className: "univer-text-gray-500", children: item.shortcut })
            ]
          },
          `${item.title}-${item.shortcut}`
        ))
      }
    )
  ] }, group.name)) });
}

// ../packages/ui/src/controllers/shortcut-display/shortcut-panel.controller.ts
var ToggleShortcutPanelShortcut = {
  id: ToggleShortcutPanelOperation.id,
  binding: 4096 /* CTRL_COMMAND */ | 220 /* BACK_SLASH */,
  description: "shortcut.shortcut-panel",
  group: "10_global-shortcut"
};
var ShortcutPanelController = class extends Disposable {
  constructor(injector, componentManager, shortcutService, _menuManagerService, commandService) {
    super();
    this._menuManagerService = _menuManagerService;
    this.disposeWithMe(componentManager.register(ShortcutPanelComponentName, ShortcutPanel));
    this.disposeWithMe(commandService.registerCommand(ToggleShortcutPanelOperation));
    this.disposeWithMe(shortcutService.registerShortcut(ToggleShortcutPanelShortcut));
  }
};
ShortcutPanelController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, Inject(ComponentManager)),
  __decorateParam(2, IShortcutService),
  __decorateParam(3, IMenuManagerService),
  __decorateParam(4, ICommandService)
], ShortcutPanelController);

// ../packages/ui/src/views/components/ribbon/Ribbon.tsx
var import_react25 = __toESM(require_react());

// ../packages/ui/src/views/components/ribbon/Button/ToolbarButton.tsx
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
function ToolbarButton(props) {
  const {
    children,
    className,
    style,
    disabled = false,
    active = false,
    noIcon,
    onClick,
    onDoubleClick,
    ...restProps
  } = props;
  const handleClick = (e) => {
    if (disabled) {
      e.preventDefault();
      return;
    }
    onClick && onClick(e);
  };
  const handleDoubleClick = (e) => {
    if (disabled) {
      e.preventDefault();
      return;
    }
    onDoubleClick && onDoubleClick(e);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    "button",
    {
      type: "button",
      className: clsx(`
              univer-flex univer-h-6 univer-min-w-6 univer-cursor-pointer univer-items-center univer-justify-center
              univer-rounded univer-border-none univer-bg-transparent univer-p-0 univer-text-base univer-text-gray-900
              univer-outline-none univer-transition-colors
              [&:disabled]:univer-cursor-not-allowed [&:disabled]:univer-text-gray-200
              [&:disabled]:hover:univer-bg-transparent
              hover:univer-bg-gray-100
            `, {
        "univer-p-4": noIcon,
        "!univer-bg-gray-200": active,
        "univer-text-gray-100": disabled
      }),
      style,
      disabled,
      onClick: handleClick,
      onDoubleClick: handleDoubleClick,
      ...restProps,
      children
    }
  );
}

// ../packages/ui/src/views/components/ribbon/ToolbarItem.tsx
var import_react24 = __toESM(require_react());

// ../packages/ui/src/views/components/ribbon/hook.ts
var import_react22 = __toESM(require_react());
function useToolbarItemStatus(menuItem) {
  const { disabled$, hidden$, activated$, value$ } = menuItem;
  const [value, setValue] = (0, import_react22.useState)();
  const [disabled, setDisabled] = (0, import_react22.useState)(false);
  const [activated, setActivated] = (0, import_react22.useState)(false);
  const [hidden, setHidden] = (0, import_react22.useState)(false);
  (0, import_react22.useEffect)(() => {
    const subscriptions = [];
    disabled$ && subscriptions.push(disabled$.subscribe((disabled2) => setDisabled(disabled2)));
    hidden$ && subscriptions.push(hidden$.subscribe((hidden2) => setHidden(hidden2)));
    activated$ && subscriptions.push(activated$.subscribe((activated2) => setActivated(activated2)));
    value$ && subscriptions.push(value$.subscribe((value2) => setValue(value2)));
    return () => subscriptions.forEach((subscription) => subscription.unsubscribe());
  }, [activated$, disabled$, hidden$, value$]);
  return { disabled, value, activated, hidden };
}

// ../packages/ui/src/views/components/ribbon/TooltipButtonWrapper.tsx
var import_react23 = __toESM(require_react());
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var TooltipWrapperContext = (0, import_react23.createContext)({
  dropdownVisible: false,
  setDropdownVisible: (_visible) => {
  }
});
var TooltipWrapper = (0, import_react23.forwardRef)((props, ref) => {
  const { children, ...tooltipProps } = props;
  const spanRef = (0, import_react23.useRef)(null);
  const [tooltipVisible, setTooltipVisible] = (0, import_react23.useState)(false);
  const [dropdownVisible, setDropdownVisible] = (0, import_react23.useState)(false);
  function handleChangeTooltipVisible(visible) {
    if (dropdownVisible) {
      setTooltipVisible(false);
    } else {
      setTooltipVisible(visible);
    }
  }
  function handleChangeDropdownVisible(visible) {
    setDropdownVisible(visible);
    setTooltipVisible(false);
  }
  const contextValue = (0, import_react23.useMemo)(() => ({
    dropdownVisible,
    setDropdownVisible: handleChangeDropdownVisible
  }), [dropdownVisible]);
  (0, import_react23.useImperativeHandle)(ref, () => ({
    el: spanRef.current
  }));
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    Tooltip,
    {
      ...tooltipProps,
      visible: tooltipVisible,
      onVisibleChange: handleChangeTooltipVisible,
      children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("span", { ref: spanRef, children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(TooltipWrapperContext.Provider, { value: contextValue, children }) })
    }
  );
});
function DropdownWrapper(props) {
  const { children, overlay, disabled, align = "start" } = props;
  const { setDropdownVisible } = (0, import_react23.useContext)(TooltipWrapperContext);
  function handleVisibleChange(visible) {
    setDropdownVisible(visible);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    Dropdown,
    {
      align,
      overlay: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "univer-grid univer-gap-2 univer-theme", children: overlay }),
      disabled,
      onOpenChange: handleVisibleChange,
      children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)("div", { className: "univer-h-full", onClick: (e) => e.stopPropagation(), children })
    }
  );
}
function Label({ icon, value, option, onOptionSelect }) {
  var _a;
  const onChange = (v) => {
    onOptionSelect == null ? void 0 : onOptionSelect({ value: v, label: option == null ? void 0 : option.label, commandId: option == null ? void 0 : option.commandId });
  };
  const hasCheckMark = typeof option.label === "string" || typeof option.label === "object" && ((_a = option.label) == null ? void 0 : _a.selectable) !== false;
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsxs)(
    "div",
    {
      className: clsx("univer-relative univer-flex univer-items-center univer-gap-2", {
        "univer-pl-6": hasCheckMark
      }),
      children: [
        hasCheckMark && String(value) === String(option.value) && /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          check_mark_single_default,
          {
            className: "univer-absolute univer-left-1 univer-top-0.5 univer-text-primary-600"
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          CustomLabel,
          {
            icon,
            value$: option.value$,
            value: option.value,
            label: option.label,
            onChange
          }
        )
      ]
    }
  );
}
function DropdownMenuWrapper({
  menuId,
  slot,
  value,
  options,
  children,
  disabled,
  onOptionSelect
}) {
  var _a;
  const { setDropdownVisible } = (0, import_react23.useContext)(TooltipWrapperContext);
  const menuManagerService = useDependency(IMenuManagerService);
  const [hiddenStates, setHiddenStates] = (0, import_react23.useState)({});
  const menuItems = (0, import_react23.useMemo)(() => {
    return menuId ? menuManagerService.getMenuByPositionKey(menuId) : [];
  }, [menuId]);
  const filteredMenuItems = (0, import_react23.useMemo)(() => {
    return menuItems.filter((item) => {
      var _a2;
      if (!item.children) return item;
      const itemKey = ((_a2 = item.key) == null ? void 0 : _a2.toString()) || "";
      return !hiddenStates[itemKey];
    });
  }, [menuItems, hiddenStates]);
  function handleVisibleChange(visible) {
    setDropdownVisible(visible);
  }
  (0, import_react23.useEffect)(() => {
    const subscriptions = menuItems.map((item) => {
      if (!item.children) return null;
      const hiddenObservables = item.children.map((subItem) => {
        var _a2, _b;
        return (_b = (_a2 = subItem.item) == null ? void 0 : _a2.hidden$) != null ? _b : of(false);
      });
      return combineLatest(hiddenObservables).subscribe((hiddenValues) => {
        const isAllHidden = hiddenValues.every((hidden) => hidden === true);
        setHiddenStates((prev) => ({
          ...prev,
          [item.key]: isAllHidden
        }));
      });
    });
    return () => {
      subscriptions.forEach((sub) => sub == null ? void 0 : sub.unsubscribe());
      setHiddenStates({});
    };
  }, [menuItems]);
  if (slot) {
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      DropdownWrapper,
      {
        disabled,
        overlay: options.map((option, index) => /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          Label,
          {
            value,
            option,
            onOptionSelect
          },
          index
        )),
        children
      }
    );
  }
  if (options == null ? void 0 : options.length) {
    const items = options.map((option) => {
      var _a2;
      return {
        type: "item",
        className: clsx({
          "focus:univer-bg-white": typeof option.label !== "string" && ((_a2 = option.label) == null ? void 0 : _a2.hoverable) === false
        }),
        children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          Label,
          {
            icon: option.icon,
            value,
            option,
            onOptionSelect
          }
        ),
        disabled: option.disabled,
        onSelect: () => {
          if (typeof option.value === "undefined") return;
          onOptionSelect == null ? void 0 : onOptionSelect({
            ...option
          });
        }
      };
    });
    for (const menuItem of filteredMenuItems) {
      if (!menuItem.item) continue;
      const { title, id, commandId, icon } = menuItem.item;
      if (!title) {
        throw new Error("Menu item title is required");
      }
      items.push({
        type: "item",
        children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
          Label,
          {
            icon,
            value,
            option: {
              label: {
                name: title,
                selectable: false
              }
            }
          }
        ),
        onSelect: () => {
          onOptionSelect == null ? void 0 : onOptionSelect({
            commandId,
            id
          });
        }
      });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      DropdownMenu,
      {
        align: "start",
        items,
        disabled,
        onOpenChange: handleVisibleChange,
        children
      }
    );
  } else {
    const items = [];
    for (const menuItem of filteredMenuItems) {
      if (menuItem.item) {
        const { title, id, commandId, icon } = menuItem.item;
        if (!title) {
          throw new Error("Menu item title is required");
        }
        items.push({
          type: "item",
          children: /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
            Label,
            {
              icon,
              value,
              option: {
                label: {
                  name: title,
                  selectable: false
                }
              }
            }
          ),
          onSelect: () => {
            onOptionSelect == null ? void 0 : onOptionSelect({
              commandId,
              id
            });
          }
        });
      } else if ((_a = menuItem.children) == null ? void 0 : _a.length) {
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      DropdownMenu,
      {
        align: "start",
        items,
        disabled,
        onOpenChange: handleVisibleChange,
        children
      }
    );
  }
}

// ../packages/ui/src/views/components/ribbon/ToolbarItem.tsx
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var ToolbarItem = (0, import_react24.forwardRef)((props, ref) => {
  const localeService = useDependency(LocaleService);
  const commandService = useDependency(ICommandService);
  const layoutService = useDependency(ILayoutService);
  const componentManager = useDependency(ComponentManager);
  const { value, hidden, disabled, activated } = useToolbarItemStatus(props);
  const executeCommand = (commandId2, params) => {
    layoutService.focus();
    commandService.executeCommand(commandId2, params);
  };
  const { tooltip, shortcut, icon, title, label, id, commandId, type: type2, slot } = props;
  const tooltipTitle = localeService.t(tooltip != null ? tooltip : "") + (shortcut ? ` (${shortcut})` : "");
  const { selections } = props;
  const selections$ = (0, import_react24.useMemo)(() => {
    if (isObservable(selections)) {
      return selections;
    } else {
      return new Observable((subscribe) => {
        subscribe.next(selections);
      });
    }
  }, [selections]);
  const options = useObservable(selections$);
  const icon$ = (0, import_react24.useMemo)(() => {
    if (isObservable(icon)) {
      return icon;
    } else {
      return new Observable((subscribe) => {
        var _a, _b;
        const v = (_b = (_a = options == null ? void 0 : options.find((o) => o.value === value)) == null ? void 0 : _a.icon) != null ? _b : icon;
        subscribe.next(v);
      });
    }
  }, [icon, options, value]);
  const iconToDisplay = useObservable(icon$, void 0, true);
  function renderSelectorType(menuType) {
    var _a;
    const selectionsCommandId = props.selectionsCommandId;
    const bId = commandId != null ? commandId : id;
    const sId = (_a = selectionsCommandId != null ? selectionsCommandId : commandId) != null ? _a : id;
    function handleSelect(option) {
      if (disabled) return;
      let commandId2 = sId;
      if (option.id) {
        commandId2 = option.id;
      }
      executeCommand(commandId2, { value: option.value });
    }
    function handleSelectionsValueChange(value2) {
      if (disabled) return;
      executeCommand(sId, { value: value2 });
    }
    function handleClick() {
      if (disabled) return;
      if (menuType === 2 /* BUTTON_SELECTOR */) {
        executeCommand(bId, { value });
      }
    }
    if (menuType === 2 /* BUTTON_SELECTOR */) {
      return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(
        "div",
        {
          className: clsx(`
                      univer-relative univer-flex univer-cursor-pointer univer-items-center univer-rounded
                    `, `
                      univer-group univer-h-6 univer-pr-5 univer-transition-colors
                      hover:univer-bg-gray-100
                    `, {
            "univer-text-gray-900": !disabled,
            "univer-pointer-events-none univer-cursor-not-allowed univer-text-gray-200": disabled
          }),
          "data-disabled": disabled,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
              "div",
              {
                className: clsx(`
                          univer-relative univer-z-[1] univer-flex univer-h-full univer-items-center univer-rounded-l
                          univer-px-1 univer-transition-colors
                          hover:univer-bg-gray-200
                        `, {
                  "univer-bg-gray-200": activated,
                  "univer-bg-gray-50": activated && disabled
                }),
                onClick: handleClick,
                children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                  CustomLabel,
                  {
                    icon: iconToDisplay,
                    title,
                    value,
                    label,
                    onChange: handleSelectionsValueChange
                  }
                )
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
              DropdownMenuWrapper,
              {
                menuId: id,
                slot,
                value,
                options,
                disabled,
                onOptionSelect: handleSelect,
                children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                  "div",
                  {
                    className: clsx(`
                              univer-absolute univer-right-0 univer-top-0 univer-box-border univer-flex univer-h-6
                              univer-w-5 univer-items-center univer-justify-center univer-rounded-r
                              univer-transition-colors
                              hover:univer-bg-gray-200
                            `, {
                      "univer-pointer-events-none univer-cursor-not-allowed univer-text-gray-200": disabled,
                      "univer-bg-gray-200": activated,
                      "univer-bg-gray-50": activated && disabled
                    }),
                    "data-disabled": disabled,
                    children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(more_down_single_default, {})
                  }
                )
              }
            )
          ]
        }
      );
    } else {
      return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        DropdownMenuWrapper,
        {
          menuId: id,
          slot,
          value,
          options,
          disabled,
          onOptionSelect: handleSelect,
          children: /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(
            "div",
            {
              className: clsx(`
                          univer-relative univer-flex univer-h-6 univer-cursor-pointer univer-items-center univer-gap-2
                          univer-rounded univer-px-1 univer-transition-colors
                          hover:univer-bg-gray-100
                        `, {
                "univer-text-gray-900": !disabled,
                "univer-pointer-events-none univer-cursor-not-allowed univer-text-gray-200": disabled,
                "univer-bg-gray-200": activated,
                "univer-bg-gray-50": activated && disabled
              }),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                  CustomLabel,
                  {
                    icon: iconToDisplay,
                    title,
                    value,
                    label,
                    onChange: handleSelectionsValueChange
                  }
                ),
                /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
                  "div",
                  {
                    className: clsx("univer-flex univer-h-full univer-items-center", {
                      "univer-pointer-events-none univer-cursor-not-allowed univer-text-gray-200": disabled
                    }),
                    children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(more_down_single_default, {})
                  }
                )
              ]
            }
          )
        }
      );
    }
  }
  function renderButtonType() {
    var _a;
    const isCustomComponent = componentManager.get(typeof label === "string" ? label : (_a = label == null ? void 0 : label.name) != null ? _a : "");
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
      ToolbarButton,
      {
        noIcon: !icon,
        active: activated,
        disabled,
        onClick: () => {
          var _a2;
          return executeCommand((_a2 = props.commandId) != null ? _a2 : props.id);
        },
        onDoubleClick: () => props.subId && executeCommand(props.subId),
        children: isCustomComponent ? /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(CustomLabel, { title, value, label }) : icon ? /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(CustomLabel, { icon }) : /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(CustomLabel, { title })
      }
    );
  }
  function renderItem() {
    switch (type2) {
      case 2 /* BUTTON_SELECTOR */:
      case 1 /* SELECTOR */:
      case 3 /* SUBITEMS */:
        return renderSelectorType(type2);
      case 0 /* BUTTON */:
      default:
        return renderButtonType();
    }
  }
  return !hidden && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
    TooltipWrapper,
    {
      ref,
      title: tooltipTitle,
      placement: "bottom",
      children: renderItem()
    }
  );
});

// ../packages/ui/src/views/components/ribbon/Ribbon.tsx
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
function Divider() {
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Separator, { className: "!univer-h-5", orientation: "vertical" });
}
function Ribbon(props) {
  const { headerMenuComponents } = props;
  const menuManagerService = useDependency(IMenuManagerService);
  const localeService = useDependency(LocaleService);
  const toolbarRef = (0, import_react25.useRef)(null);
  const toolbarItemRefs = (0, import_react25.useRef)({});
  const [ribbon, setRibbon] = (0, import_react25.useState)([]);
  const [activatedTab, setActivatedTab] = (0, import_react25.useState)("ribbon.start" /* START */);
  const [collapsedIds, setCollapsedIds] = (0, import_react25.useState)([]);
  const handleSelectTab = (0, import_react25.useCallback)((group) => {
    toolbarItemRefs.current = {};
    setActivatedTab(group.key);
  }, []);
  (0, import_react25.useEffect)(() => {
    function getRibbon() {
      const ribbon2 = menuManagerService.getMenuByPositionKey("ribbon" /* RIBBON */);
      setRibbon(ribbon2);
    }
    getRibbon();
    const subscription = menuManagerService.menuChanged$.subscribe(getRibbon);
    return () => {
      subscription.unsubscribe();
    };
  }, [menuManagerService]);
  (0, import_react25.useEffect)(() => {
    const observer = new ResizeObserver((entries) => {
      requestAnimationFrame(() => {
        var _a, _b;
        const toolbar = entries[0].target;
        const toolbarWidth = toolbar.clientWidth;
        const toolbarItems = Object.values(toolbarItemRefs.current);
        const collapsedIds2 = [];
        let totalWidth = 0;
        const allGroups = (_b = (_a = ribbon.find((group) => group.key === activatedTab)) == null ? void 0 : _a.children) != null ? _b : [];
        for (const { el, key } of toolbarItems) {
          if (!el) continue;
          totalWidth += (el == null ? void 0 : el.getBoundingClientRect().width) + 8;
          if (totalWidth > toolbarWidth - 32 - 8 * (allGroups.length - 1)) {
            collapsedIds2.push(key);
          }
        }
        setCollapsedIds(collapsedIds2);
      });
    });
    if (toolbarRef.current) {
      observer.observe(toolbarRef.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [ribbon, activatedTab]);
  const activeGroup = (0, import_react25.useMemo)(() => {
    var _a, _b;
    const allGroups = (_b = (_a = ribbon.find((group) => group.key === activatedTab)) == null ? void 0 : _a.children) != null ? _b : [];
    const visibleGroups = [];
    const hiddenGroups = [];
    for (const item of allGroups) {
      if (item.children) {
        const visibleChildren = item.children.filter((child) => !collapsedIds.includes(child.key));
        if (visibleChildren.length > 0) {
          visibleGroups.push({ ...item, children: visibleChildren });
        }
        if (visibleChildren.length < item.children.length) {
          hiddenGroups.push({ ...item, children: item.children.filter((child) => collapsedIds.includes(child.key)) });
        }
      }
    }
    return {
      allGroups,
      visibleGroups,
      hiddenGroups
    };
  }, [ribbon, activatedTab, collapsedIds]);
  const fakeToolbarContent = (0, import_react25.useMemo)(() => activeGroup.allGroups.map((groupItem) => {
    var _a;
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_react25.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "univer-flex univer-flex-nowrap univer-gap-2 univer-px-2", children: (_a = groupItem.children) == null ? void 0 : _a.map((child) => child.item && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        ToolbarItem,
        {
          ...child.item,
          ref: (ref) => {
            if (ref == null ? void 0 : ref.el) {
              toolbarItemRefs.current[child.key] = {
                el: ref.el,
                key: child.key
              };
            }
          }
        },
        child.key
      )) }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Divider, {})
    ] }, groupItem.key);
  }), [activeGroup.allGroups]);
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("header", { className: "univer-relative univer-select-none", children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "div",
        {
          className: clsx(`
                      univer-flex univer-h-0 univer-items-center univer-justify-center univer-gap-2
                      univer-overflow-hidden univer-transition-all univer-animate-in
                    `, {
            "univer-h-8 univer-slide-in-from-top-full": ribbon.length > 1 || headerMenuComponents && headerMenuComponents.size > 0
          }),
          children: ribbon.length > 1 && ribbon.map((group) => /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
            "a",
            {
              className: clsx(`
                              univer-box-border univer-cursor-pointer univer-rounded univer-px-2 univer-py-0.5
                              univer-text-sm univer-text-gray-700 univer-transition-colors
                              hover:univer-bg-gray-300
                            `, {
                "univer-bg-primary-500 univer-text-white hover:!univer-bg-primary-500": group.key === activatedTab
              }),
              onClick: () => handleSelectTab(group),
              children: localeService.t(group.key)
            },
            group.key
          ))
        }
      ),
      headerMenuComponents && headerMenuComponents.size > 0 && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "div",
        {
          className: `
                          univer-absolute univer-right-2 univer-top-0 univer-flex univer-h-full univer-items-center
                          univer-gap-2
                          [&>*]:univer-inline-flex [&>*]:univer-h-6 [&>*]:univer-items-center [&>*]:univer-rounded
                          [&>*]:univer-px-1 [&>*]:univer-transition-colors
                          hover:[&>*]:univer-bg-gray-300
                        `,
          children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ComponentContainer, { components: headerMenuComponents })
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "section",
      {
        role: "toolbar",
        className: `
                  univer-relative univer-box-border univer-flex univer-h-8 univer-select-none univer-items-center
                  univer-border-0 univer-border-b univer-border-solid univer-border-b-gray-200 univer-bg-white
                  univer-text-base univer-text-gray-800
                  dark:univer-bg-gray-900
                `,
        children: /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(
          "div",
          {
            className: `
                      univer-mx-auto univer-box-border univer-flex univer-h-full univer-flex-1 univer-items-center
                      univer-justify-center univer-gap-1 univer-overflow-hidden univer-px-4
                    `,
            children: [
              activeGroup.visibleGroups.map((groupItem, index) => {
                var _a, _b;
                return (((_a = groupItem.children) == null ? void 0 : _a.length) || groupItem.item) && /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_react25.Fragment, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "univer-flex univer-flex-nowrap univer-gap-2 univer-px-2", children: groupItem.children ? (_b = groupItem.children) == null ? void 0 : _b.map((child) => child.item && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ToolbarItem, { ...child.item }, child.key)) : groupItem.item && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ToolbarItem, { ...groupItem.item }, groupItem.key) }),
                  index < activeGroup.visibleGroups.length - 1 && activeGroup.visibleGroups.some((groupItem2) => {
                    var _a2;
                    return ((_a2 = groupItem2.children) == null ? void 0 : _a2.length) || !!groupItem2.item;
                  }) && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Divider, {})
                ] }, groupItem.key);
              }),
              collapsedIds.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(Divider, {}),
                /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(TooltipWrapper, { title: localeService.t("ribbon.more"), placement: "bottom", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                  DropdownWrapper,
                  {
                    align: "end",
                    overlay: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                      "div",
                      {
                        className: `
                                              univer-box-border univer-grid
                                              univer-max-w-[var(--radix-popper-available-width)] univer-gap-2 univer-p-2
                                            `,
                        children: activeGroup.hiddenGroups.map((groupItem) => {
                          var _a;
                          return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
                            "div",
                            {
                              className: "univer-flex univer-items-center univer-gap-2",
                              children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "univer-flex univer-flex-wrap univer-gap-2", children: groupItem.children ? (_a = groupItem.children) == null ? void 0 : _a.map((child) => child.item && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ToolbarItem, { ...child.item }, child.key)) : groupItem.item && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ToolbarItem, { ...groupItem.item }, groupItem.key) })
                            },
                            groupItem.key
                          );
                        })
                      }
                    ),
                    children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(ToolbarButton, { children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(more_function_single_default, {}) })
                  }
                ) })
              ] })
            ]
          }
        )
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "div",
      {
        "aria-hidden": true,
        ref: toolbarRef,
        className: `
                  univer-invisible univer-absolute univer-left-0 univer-right-0 univer-top-[-99999px] univer-mx-auto
                  univer-box-border univer-flex univer-h-full univer-flex-1 univer-items-center univer-justify-center
                  univer-gap-1 univer-overflow-hidden univer-px-4
                `,
        children: fakeToolbarContent
      }
    )
  ] });
}

// ../packages/ui/src/views/workbench/Workbench.tsx
var import_react29 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// ../packages/ui/src/views/components/context-menu/ContextMenu.tsx
var import_react28 = __toESM(require_react());

// ../packages/ui/src/components/menu/desktop/Menu.tsx
var import_react27 = __toESM(require_react());

// ../packages/ui/src/components/hooks/layout.ts
var import_react26 = __toESM(require_react());
function useScrollYOverContainer(element, container) {
  const updater = useEvent(() => {
    if (!element || !container) {
      return;
    }
    const elStyle = element.style;
    const elRect = element.getBoundingClientRect();
    const { y, height } = elRect;
    const containerRect = container.getBoundingClientRect();
    const scrolled = element.scrollHeight > height;
    const isOverViewport = y < 0 || y + height > containerRect.height;
    if (!isOverViewport && !scrolled) {
      elStyle.overflowY = "";
      elStyle.maxHeight = "";
      return;
    }
    if (isOverViewport) {
      elStyle.overflowY = "auto";
      elStyle.maxHeight = y < 0 ? `${element.scrollHeight + y}px` : `${containerRect.height - y}px`;
    }
  });
  (0, import_react26.useEffect)(() => {
    if (!isBrowser() || !element || !container) return;
    updater();
    const resizeObserver = resizeObserverCtor(updater);
    resizeObserver.observe(element);
    return () => {
      resizeObserver.unobserve(element);
    };
  }, [element, container]);
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/components/menu/desktop/index.module.less
var index_module_default4 = {
  "menuItemNoHover": "univer-menu-item-no-hover",
  "menuItemActive": "univer-menu-item-active",
  "menuItemActivated": "univer-menu-item-activated",
  "menuItemContent": "univer-menu-item-content",
  "menuItemSelectable": "univer-menu-item-selectable",
  "menuItemSelectableIcon": "univer-menu-item-selectable-icon",
  "menuItemMoreIcon": "univer-menu-item-more-icon"
};

// ../packages/ui/src/components/menu/desktop/Menu.tsx
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
function MenuWrapper(props) {
  const { menuType, onOptionSelect } = props;
  const menuManagerService = useDependency(IMenuManagerService);
  const menuItems = (0, import_react27.useMemo)(() => menuType ? menuManagerService.getMenuByPositionKey(menuType) : [], [menuType, menuManagerService]);
  const [hiddenStates, setHiddenStates] = (0, import_react27.useState)({});
  const filteredMenuItems = (0, import_react27.useMemo)(() => {
    return menuItems.filter((item) => {
      var _a;
      if (!item.children) return item;
      const itemKey = ((_a = item.key) == null ? void 0 : _a.toString()) || "";
      return !hiddenStates[itemKey];
    });
  }, [menuItems, hiddenStates]);
  (0, import_react27.useEffect)(() => {
    const subscriptions = menuItems.map((item) => {
      if (!item.children) return null;
      const hiddenObservables = item.children.map((subItem) => {
        var _a, _b;
        return (_b = (_a = subItem.item) == null ? void 0 : _a.hidden$) != null ? _b : of(false);
      });
      return combineLatest(hiddenObservables).subscribe((hiddenValues) => {
        const isAllHidden = hiddenValues.every((hidden) => hidden === true);
        setHiddenStates((prev) => ({
          ...prev,
          [item.key]: isAllHidden
        }));
      });
    });
    return () => {
      subscriptions.forEach((sub) => sub == null ? void 0 : sub.unsubscribe());
      setHiddenStates({});
    };
  }, [menuItems]);
  if (!menuType) {
    return null;
  }
  ;
  return filteredMenuItems && filteredMenuItems.map((item) => {
    var _a;
    return item.item ? /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      MenuItem2,
      {
        menuItem: item.item,
        onClick: (object) => {
          onOptionSelect == null ? void 0 : onOptionSelect({ value: "", label: item.key, ...object });
        }
      },
      item.key
    ) : ((_a = item.children) == null ? void 0 : _a.length) ? /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(MenuItemGroup, { eventKey: item.key, children: item.children.map((child) => child.item && /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      MenuItem2,
      {
        menuItem: child.item,
        onClick: (object) => {
          onOptionSelect == null ? void 0 : onOptionSelect({ value: "", label: child.key, ...object });
        }
      },
      child.key
    )) }, item.key) : null;
  });
}
function MenuOptionsWrapper(props) {
  var _a;
  const { options, value, onOptionSelect, parentKey } = props;
  return (_a = options == null ? void 0 : options.map((option, index) => {
    var _a2, _b, _c;
    const key = `${parentKey}-${(_a2 = option.label) != null ? _a2 : option.id}-${index}`;
    const onChange = (v) => {
      onOptionSelect == null ? void 0 : onOptionSelect({ value: v, label: option == null ? void 0 : option.label, commandId: option == null ? void 0 : option.commandId });
    };
    const handleClick = () => {
      if (typeof option.value === "undefined") return;
      onOptionSelect == null ? void 0 : onOptionSelect({
        ...option
      });
    };
    const _className = clsx({
      [index_module_default4.menuItemNoHover]: typeof option.label !== "string" && !((_b = option.label) == null ? void 0 : _b.hoverable)
    });
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(MenuItem, { disabled: option.disabled, eventKey: key, className: _className, onClick: handleClick, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(
      "span",
      {
        className: clsx(index_module_default4.menuItemContent, {
          [index_module_default4.menuItemSelectable]: !(typeof option.label !== "string" && !((_c = option.label) == null ? void 0 : _c.hoverable))
        }),
        children: [
          typeof value !== "undefined" && String(value) === String(option.value) && /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: index_module_default4.menuItemSelectableIcon, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(check_mark_single_default, { style: { color: "rgb(var(--success-color))" } }) }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            CustomLabel,
            {
              value$: option.value$,
              value: option.value,
              label: option.label,
              icon: option.icon,
              onChange
            }
          )
        ]
      }
    ) }, key);
  })) != null ? _a : null;
}
var Menu2 = (props) => {
  const { overViewport, ...restProps } = props;
  const [menuEl, setMenuEl] = (0, import_react27.useState)();
  const layoutService = useDependency(ILayoutService);
  useScrollYOverContainer(overViewport === "scroll" ? menuEl : null, layoutService.rootContainerElement);
  function handleSetMenuEl(ref) {
    if (ref) {
      setMenuEl(ref.list);
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(
    Menu,
    {
      ref: handleSetMenuEl,
      selectable: false,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(MenuOptionsWrapper, { ...restProps }),
        /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(MenuWrapper, { ...restProps })
      ]
    }
  );
};
function MenuItem2({ menuItem, onClick }) {
  const menuManagerService = useDependency(IMenuManagerService);
  const disabled = useObservable(menuItem.disabled$, false);
  const activated = useObservable(menuItem.activated$, false);
  const hidden = useObservable(menuItem.hidden$, false);
  const value = useObservable(menuItem.value$);
  const item = menuItem;
  const selectionsFromObservable = useObservable(isObservable(item.selections) ? item.selections : void 0);
  const [inputValue, setInputValue] = (0, import_react27.useState)(value);
  (0, import_react27.useEffect)(() => {
    setInputValue(value);
  }, [value]);
  if (hidden) {
    return null;
  }
  const onChange = (v) => {
    const newValue = isRealNum(v) && typeof v === "string" ? Number.parseInt(v) : v;
    setInputValue(newValue);
  };
  const renderButtonType = () => {
    const item2 = menuItem;
    const { title, label } = item2;
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      MenuItem,
      {
        eventKey: item2.id,
        disabled,
        className: clsx({
          [index_module_default4.menuItemActivated]: activated
        }),
        onClick: () => {
          onClick({ commandId: item2.commandId, value: inputValue, id: item2.id });
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: index_module_default4.menuItemContent, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
          CustomLabel,
          {
            value,
            title,
            label,
            icon: item2.icon,
            onChange
          }
        ) })
      },
      item2.id
    );
  };
  const renderSelectorType = () => {
    var _a;
    const selections = (_a = selectionsFromObservable != null ? selectionsFromObservable : item.selections) != null ? _a : [];
    if (selections.length > 0) {
      return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
        SubMenu,
        {
          eventKey: item.id,
          popupOffset: [18, 0],
          title: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("span", { className: index_module_default4.menuItemContent, children: [
            /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
              CustomLabel,
              {
                title: item.title,
                value: inputValue,
                onChange,
                icon: item.icon,
                label: item.label
              }
            ),
            item.shortcut && ` (${item.shortcut})`
          ] }),
          expandIcon: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(more_single_default, { className: index_module_default4.menuItemMoreIcon }),
          children: selections.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            MenuOptionsWrapper,
            {
              parentKey: item.id,
              menuType: item.id,
              options: selections,
              onOptionSelect: (v) => {
                onClick({ value: v.value, id: item.id, commandId: v.commandId });
              }
            }
          )
        },
        item.id
      );
    }
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(MenuItem, { eventKey: item.id, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("span", { className: index_module_default4.menuItemContent, children: [
      /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
        CustomLabel,
        {
          title: item.title,
          value: inputValue,
          icon: item.icon,
          label: item.label,
          onChange
        }
      ),
      item.shortcut && ` (${item.shortcut})`
    ] }) }, item.id);
  };
  const subMenuItems = menuItem.id ? menuManagerService.getMenuByPositionKey(menuItem.id) : [];
  const renderSubItemsType = () => {
    const item2 = menuItem;
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      SubMenu,
      {
        eventKey: item2.id,
        popupOffset: [18, 0],
        title: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("span", { className: index_module_default4.menuItemContent, children: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(CustomLabel, { title: item2.title, icon: item2.icon, label: item2.label, onChange }) }),
        expandIcon: /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(more_single_default, { className: index_module_default4.menuItemMoreIcon }),
        children: subMenuItems.length && /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(MenuWrapper, { menuType: item2.id, parentKey: item2.id, onOptionSelect: onClick })
      },
      item2.id
    );
  };
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(import_jsx_runtime20.Fragment, { children: [
    menuItem.type === 1 /* SELECTOR */ && renderSelectorType(),
    menuItem.type === 3 /* SUBITEMS */ && renderSubItemsType(),
    menuItem.type === 0 /* BUTTON */ && renderButtonType()
  ] });
}

// ../packages/ui/src/views/components/context-menu/ContextMenu.tsx
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
function DesktopContextMenu() {
  const contentRef = (0, import_react28.useRef)(null);
  const [visible, setVisible] = (0, import_react28.useState)(false);
  const [menuType, setMenuType] = (0, import_react28.useState)("");
  const [offset, setOffset] = (0, import_react28.useState)([0, 0]);
  const visibleRef = (0, import_react28.useRef)(visible);
  const contextMenuService = useDependency(IContextMenuService);
  const commandService = useDependency(ICommandService);
  const injector = useInjector();
  visibleRef.current = visible;
  (0, import_react28.useEffect)(() => {
    const disposables = contextMenuService.registerContextMenuHandler({
      handleContextMenu,
      hideContextMenu() {
        setVisible(false);
      },
      get visible() {
        return visibleRef.current;
      }
    });
    function handleClickOutside(event) {
      if (contentRef.current && !contentRef.current.contains(event.target)) {
        handleClose();
      }
    }
    document.addEventListener("pointerdown", handleClickOutside);
    document.addEventListener("wheel", handleClose);
    return () => {
      document.removeEventListener("pointerdown", handleClickOutside);
      document.removeEventListener("wheel", handleClose);
      disposables.dispose();
    };
  }, [contextMenuService]);
  function handleContextMenu(event, menuType2) {
    setVisible(false);
    requestAnimationFrame(() => {
      setMenuType(menuType2);
      setOffset([event.clientX, event.clientY]);
      setVisible(true);
    });
  }
  function handleClose() {
    setVisible(false);
  }
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(Popup, { visible, offset, children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("section", { ref: contentRef, children: menuType && /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
    Menu2,
    {
      menuType,
      onOptionSelect: (params) => {
        const { label: id, commandId, value } = params;
        if (commandService) {
          commandService.executeCommand(commandId != null ? commandId : id, { value });
        }
        const layoutService = injector.get(ILayoutService);
        layoutService.focus();
        setVisible(false);
      }
    }
  ) }) });
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/views/workbench/workbench.module.less
var workbench_module_default = {
  "workbenchLayout": "univer-workbench-layout",
  "workbenchCustomHeader": "univer-workbench-custom-header",
  "workbenchContainer": "univer-workbench-container",
  "workbenchContainerHeader": "univer-workbench-container-header",
  "workbenchContainerWrapper": "univer-workbench-container-wrapper",
  "workbenchContainerContent": "univer-workbench-container-content",
  "workbenchContainerDocContent": "univer-workbench-container-doc-content",
  "workbenchContainerCanvas": "univer-workbench-container-canvas",
  "workbenchContainerLeftSidebar": "univer-workbench-container-left-sidebar",
  "workbenchContainerSidebar": "univer-workbench-container-sidebar"
};

// ../packages/ui/src/views/workbench/Workbench.tsx
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
function DesktopWorkbench(props) {
  const {
    header = true,
    toolbar = true,
    footer = true,
    contextMenu = true,
    mountContainer,
    onRendered
  } = props;
  const localeService = useDependency(LocaleService);
  const themeService = useDependency(ThemeService);
  const instanceService = useDependency(IUniverInstanceService);
  const contentRef = (0, import_react29.useRef)(null);
  const customHeaderComponents = useComponentsOfPart("custom-header" /* CUSTOM_HEADER */);
  const footerComponents = useComponentsOfPart("footer" /* FOOTER */);
  const headerComponents = useComponentsOfPart("header" /* HEADER */);
  const headerMenuComponents = useComponentsOfPart("header-menu" /* HEADER_MENU */);
  const contentComponents = useComponentsOfPart("content" /* CONTENT */);
  const leftSidebarComponents = useComponentsOfPart("left-sidebar" /* LEFT_SIDEBAR */);
  const globalComponents = useComponentsOfPart("global" /* GLOBAL */);
  const toolbarComponents = useComponentsOfPart("toolbar" /* TOOLBAR */);
  const [docSnapShot, setDocSnapShot] = (0, import_react29.useState)(null);
  (0, import_react29.useEffect)(() => {
    const sub = instanceService.focused$.subscribe((id) => {
      if (id == null) {
        return;
      }
      const instanceType = instanceService.getUnitType(id);
      const instance = instanceService.getUnit(id);
      if (instanceType === O.UNIVER_DOC && instance) {
        setDocSnapShot(instance.getSnapshot());
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, []);
  (0, import_react29.useEffect)(() => {
    if (!themeService.getCurrentTheme()) {
      themeService.setTheme(default_module_default);
    }
  }, []);
  (0, import_react29.useEffect)(() => {
    if (contentRef.current) {
      onRendered == null ? void 0 : onRendered(contentRef.current);
    }
  }, [onRendered]);
  const [locale, setLocale] = (0, import_react29.useState)(localeService.getLocales());
  const portalContainer = (0, import_react29.useMemo)(() => document.createElement("div"), []);
  (0, import_react29.useEffect)(() => {
    document.body.appendChild(portalContainer);
    const subscriptions = [
      localeService.localeChanged$.subscribe(() => {
        setLocale(localeService.getLocales());
      }),
      themeService.currentTheme$.subscribe((theme) => {
        themeInstance.setTheme(mountContainer, theme);
        if (portalContainer) {
          themeInstance.setTheme(portalContainer, theme);
        }
      })
    ];
    return () => {
      subscriptions.forEach((subscription) => subscription.unsubscribe());
      document.body.removeChild(portalContainer);
    };
  }, [localeService, mountContainer, portalContainer, themeService.currentTheme$]);
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)(ConfigProvider, { locale: locale == null ? void 0 : locale.design, mountContainer: portalContainer, children: [
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: workbench_module_default.workbenchLayout, tabIndex: -1, onBlur: (e) => e.stopPropagation(), children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: workbench_module_default.workbenchCustomHeader, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: customHeaderComponents }, "custom-header") }),
      header && toolbar && /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("header", { className: workbench_module_default.workbenchContainerHeader, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
        ComponentContainer,
        {
          components: toolbarComponents,
          sharedProps: {
            headerMenuComponents
          }
        },
        "toolbar"
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("section", { className: workbench_module_default.workbenchContainer, children: [
        /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: workbench_module_default.workbenchContainerWrapper, children: [
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("aside", { className: workbench_module_default.workbenchContainerLeftSidebar, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: leftSidebarComponents }, "left-sidebar") }),
          /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)(
            "section",
            {
              className: clsx(
                workbench_module_default.workbenchContainerContent,
                {
                  [workbench_module_default.workbenchContainerDocContent]: (docSnapShot == null ? void 0 : docSnapShot.documentStyle.documentFlavor) === 1 /* TRADITIONAL */
                }
              ),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("header", { children: header && /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: headerComponents }, "header") }),
                /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
                  "section",
                  {
                    className: workbench_module_default.workbenchContainerCanvas,
                    ref: contentRef,
                    "data-range-selector": true,
                    onContextMenu: (e) => e.preventDefault(),
                    children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: contentComponents }, "content")
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("aside", { className: workbench_module_default.workbenchContainerSidebar, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(Sidebar, {}) })
        ] }),
        footer && /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("footer", { className: workbench_module_default.workbenchFooter, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: footerComponents, sharedProps: { contextMenu } }, "footer") }),
        /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ZenZone, {})
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: globalComponents }, "global"),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(GlobalZone, {}),
    contextMenu && /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(DesktopContextMenu, {}),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(FloatingContainer, {}),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { id: "univer-popup-portal" })
  ] });
}
function FloatingContainer() {
  const { mountContainer } = (0, import_react29.useContext)(ConfigContext);
  const floatingComponents = useComponentsOfPart("floating" /* FLOATING */);
  return (0, import_react_dom3.createPortal)(/* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: floatingComponents }, "floating"), mountContainer);
}

// ../packages/ui/src/common/menu-hidden-observable.ts
function getMenuHiddenObservable(accessor, targetUniverType, matchUnitId, needHideUnitId) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  return new Observable((subscriber) => {
    const subscription = univerInstanceService.focused$.subscribe((unitId) => {
      if (unitId == null) {
        return subscriber.next(true);
      }
      if (matchUnitId && matchUnitId !== unitId) {
        return subscriber.next(true);
      }
      if (needHideUnitId && (Array.isArray(needHideUnitId) ? needHideUnitId.includes(unitId) : needHideUnitId === unitId)) {
        return subscriber.next(true);
      }
      const univerType2 = univerInstanceService.getUnitType(unitId);
      subscriber.next(univerType2 !== targetUniverType);
    });
    const focusedUniverInstance = univerInstanceService.getFocusedUnit();
    if (focusedUniverInstance == null) {
      return subscriber.next(true);
    }
    const univerType = univerInstanceService.getUnitType(focusedUniverInstance.getUnitId());
    subscriber.next(univerType !== targetUniverType);
    return () => subscription.unsubscribe();
  });
}

// ../packages/ui/src/controllers/shortcut-display/menu.ts
function ShortcutPanelMenuItemFactory(accessor) {
  return {
    id: ToggleShortcutPanelOperation.id,
    title: "toggle-shortcut-panel",
    tooltip: "toggle-shortcut-panel",
    icon: "KeyboardSingle",
    type: 0 /* BUTTON */,
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
    // disabled$: getCurrentSheetDisabled$(accessor),
  };
}

// ../packages/ui/src/controllers/menus/menus.ts
var undoRedoDisableFactory$ = (accessor, isUndo) => {
  const undoRedoService = accessor.get(IUndoRedoService);
  const contextService = accessor.get(IContextService);
  return combineLatest([
    undoRedoService.undoRedoStatus$.pipe(map((v) => isUndo ? v.undos <= 0 : v.redos <= 0)),
    merge([of({}), contextService.contextChanged$])
  ]).pipe(map(([undoDisable]) => {
    return undoDisable || contextService.getContextValue(EDITOR_ACTIVATED) || contextService.getContextValue(FOCUSING_FX_BAR_EDITOR);
  }));
};
function UndoMenuItemFactory(accessor) {
  return {
    id: UndoCommand.id,
    type: 0 /* BUTTON */,
    icon: "UndoSingle",
    title: "Undo",
    tooltip: "toolbar.undo",
    disabled$: undoRedoDisableFactory$(accessor, true)
  };
}
function RedoMenuItemFactory(accessor) {
  return {
    id: RedoCommand.id,
    type: 0 /* BUTTON */,
    icon: "RedoSingle",
    title: "Redo",
    tooltip: "toolbar.redo",
    disabled$: undoRedoDisableFactory$(accessor, false)
  };
}

// ../packages/ui/src/controllers/menus/menu.schema.ts
var menuSchema = {
  ["ribbon.start.history" /* HISTORY */]: {
    [UndoCommand.id]: {
      order: 0,
      menuItemFactory: UndoMenuItemFactory
    },
    [RedoCommand.id]: {
      order: 1,
      menuItemFactory: RedoMenuItemFactory
    }
  },
  ["ribbon.start.others" /* OTHERS */]: {
    [ToggleShortcutPanelOperation.id]: {
      order: 99,
      menuItemFactory: ShortcutPanelMenuItemFactory
    }
  }
};

// ../packages/ui/src/controllers/ui/ui-desktop.controller.tsx
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var DesktopUIController = class extends SingleUnitUIController {
  constructor(_config, injector, lifecycleService, renderManagerService, layoutService, instanceService, menuManagerService, uiPartsService) {
    super(injector, instanceService, layoutService, lifecycleService, renderManagerService);
    this._config = _config;
    menuManagerService.mergeMenu(menuSchema);
    this._initBuiltinComponents(uiPartsService);
    this._bootstrapWorkbench();
  }
  bootstrap(callback) {
    return bootstrap2(this._injector, this._config, callback);
  }
  _initBuiltinComponents(uiPartsService) {
    this.disposeWithMe(uiPartsService.registerComponent("floating" /* FLOATING */, () => connectInjector(CanvasPopup, this._injector)));
    this.disposeWithMe(uiPartsService.registerComponent("content" /* CONTENT */, () => connectInjector(FloatDom, this._injector)));
    this.disposeWithMe(uiPartsService.registerComponent("toolbar" /* TOOLBAR */, () => connectInjector(Ribbon, this._injector)));
  }
};
DesktopUIController = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, Inject(LifecycleService)),
  __decorateParam(3, IRenderManagerService),
  __decorateParam(4, ILayoutService),
  __decorateParam(5, IUniverInstanceService),
  __decorateParam(6, IMenuManagerService),
  __decorateParam(7, IUIPartsService)
], DesktopUIController);
function bootstrap2(injector, options, callback) {
  let mountContainer;
  const container = options.container;
  if (typeof container === "string") {
    const containerElement = document.getElementById(container);
    if (!containerElement) {
      mountContainer = createContainer2(container);
    } else {
      mountContainer = containerElement;
    }
  } else if (container instanceof HTMLElement) {
    mountContainer = container;
  } else {
    mountContainer = createContainer2("univer");
  }
  const ConnectedApp = connectInjector(DesktopWorkbench, injector);
  const onRendered = (contentElement) => callback(contentElement, mountContainer);
  function render2() {
    render(
      /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
        ConnectedApp,
        {
          ...options,
          mountContainer,
          onRendered
        }
      ),
      mountContainer
    );
  }
  render2();
  return toDisposable(() => {
    render(/* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", {}), mountContainer);
    setTimeout(() => render(/* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", {}), mountContainer), 200);
    setTimeout(() => unmount(mountContainer), 500);
  });
}
function createContainer2(id) {
  const element = document.createElement("div");
  element.id = id;
  return element;
}

// ../packages/ui/src/services/local-file/desktop-local-file.service.ts
var DesktopLocalFileService = class extends Disposable {
  openFile(options) {
    return new Promise((resolve) => {
      var _a, _b;
      const inputElement = document.createElement("input");
      inputElement.type = "file";
      inputElement.accept = (_a = options == null ? void 0 : options.accept) != null ? _a : "";
      inputElement.multiple = (_b = options == null ? void 0 : options.multiple) != null ? _b : false;
      inputElement.onchange = (event) => {
        const fileList = event.target.files;
        if (fileList) {
          resolve(Array.from(fileList));
        }
      };
      inputElement.click();
    });
  }
  downloadFile(data2, fileName) {
    const a = document.createElement("a");
    a.download = fileName;
    a.href = window.URL.createObjectURL(data2);
    a.click();
  }
};

// ../packages/ui/src/services/local-file/local-file.service.ts
var ILocalFileService = createIdentifier("univer-ui.local-file.service");

// ../packages/ui/src/ui-plugin.ts
var UNIVER_UI_PLUGIN_NAME = "UNIVER_UI_PLUGIN";
var DISABLE_AUTO_FOCUS_KEY = "DISABLE_AUTO_FOCUS";
var UniverUIPlugin = class extends Plugin {
  constructor(_config = defaultPluginConfig2, _contextService, _injector, _configService) {
    super();
    this._config = _config;
    this._contextService = _contextService;
    this._injector = _injector;
    this._configService = _configService;
    const { menu, ...rest } = merge_default(
      {},
      defaultPluginConfig2,
      this._config
    );
    if (rest.disableAutoFocus) {
      this._contextService.setContextValue(DISABLE_AUTO_FOCUS_KEY, true);
    }
    if (menu) {
      this._configService.setConfig("menu", menu, { merge: true });
    }
    this._configService.setConfig(UI_PLUGIN_CONFIG_KEY, rest);
  }
  onStarting() {
    const dependencies = mergeOverrideWithDependencies([
      [ComponentManager],
      [ZIndexManager],
      [ShortcutPanelService],
      [IUIPartsService, { useClass: UIPartsService }],
      [ILayoutService, { useClass: DesktopLayoutService }],
      [IShortcutService, { useClass: ShortcutService }],
      [IPlatformService, { useClass: PlatformService }],
      [IMenuManagerService, { useClass: MenuManagerService }],
      [IContextMenuService, { useClass: ContextMenuService }],
      [IClipboardInterfaceService, { useClass: BrowserClipboardService, lazy: true }],
      [INotificationService, { useClass: DesktopNotificationService, lazy: true }],
      [IDialogService, { useClass: DesktopDialogService, lazy: true }],
      [IConfirmService, { useClass: DesktopConfirmService, lazy: true }],
      [ISidebarService, { useClass: DesktopSidebarService, lazy: true }],
      [IZenZoneService, { useClass: DesktopZenZoneService, lazy: true }],
      [IGlobalZoneService, { useClass: DesktopGlobalZoneService, lazy: true }],
      [IMessageService, { useClass: DesktopMessageService, lazy: true }],
      [ILocalStorageService, { useClass: DesktopLocalStorageService, lazy: true }],
      [IBeforeCloseService, { useClass: DesktopBeforeCloseService }],
      [ILocalFileService, { useClass: DesktopLocalFileService }],
      [ICanvasPopupService, { useClass: CanvasPopupService }],
      [CanvasFloatDomService],
      [IUIController, {
        useFactory: (injector) => injector.createInstance(DesktopUIController, this._config),
        deps: [Injector]
      }],
      [SharedController],
      [ErrorController],
      [ShortcutPanelController]
    ], this._config.override);
    dependencies.forEach((dependency) => this._injector.add(dependency));
    this._injector.get(IUIController);
    this._injector.get(ErrorController);
  }
  onReady() {
    this._injector.get(SharedController);
  }
  onSteady() {
    this._injector.get(ShortcutPanelController);
  }
};
__publicField(UniverUIPlugin, "pluginName", UNIVER_UI_PLUGIN_NAME);
UniverUIPlugin = __decorateClass([
  DependentOn(UniverRenderEnginePlugin),
  __decorateParam(1, IContextService),
  __decorateParam(2, Inject(Injector)),
  __decorateParam(3, IConfigService)
], UniverUIPlugin);

// ../packages/ui/src/components/font-family/FontFamily.tsx
var import_react30 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/components/font-family/index.module.less
var index_module_default5 = {
  "uiPluginSheetsFontFamily": "univer-ui-plugin-sheets-font-family",
  "uiPluginSheetsFontFamilyItem": "univer-ui-plugin-sheets-font-family-item"
};

// ../packages/ui/src/components/font-family/FontFamily.tsx
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var FontFamily = (props) => {
  const { value } = props;
  const localeService = useDependency(LocaleService);
  const viewValue = (0, import_react30.useMemo)(() => {
    if (value == null) return "";
    let fontFamily = localeService.t(`fontFamily.${`${value != null ? value : ""}`.replace(/\s/g, "")}`);
    if (fontFamily.startsWith("fontFamily.") && typeof value === "string") {
      fontFamily = value.split(",")[0];
    }
    return fontFamily;
  }, [value]);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: index_module_default5.uiPluginSheetsFontFamily, style: { fontFamily: value }, children: viewValue });
};

// ../packages/ui/src/components/font-family/FontFamilyItem.tsx
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var FontFamilyItem = (props) => {
  const { value } = props;
  const localeService = useDependency(LocaleService);
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("span", { className: index_module_default5.uiPluginSheetsFontFamilyItem, style: { fontFamily: value }, children: localeService.t(`fontFamily.${`${value != null ? value : ""}`.replace(/\s/g, "")}`) });
};

// ../packages/ui/src/components/font-family/interface.ts
var FONT_FAMILY_LIST = [
  {
    value: "Arial"
  },
  {
    value: "Times New Roman"
  },
  {
    value: "Tahoma"
  },
  {
    value: "Verdana"
  },
  {
    value: "Microsoft YaHei"
  },
  {
    value: "SimSun"
  },
  {
    value: "SimHei"
  },
  {
    value: "Kaiti"
  },
  {
    value: "FangSong"
  },
  {
    value: "NSimSun"
  },
  {
    value: "STXinwei"
  },
  {
    value: "STXingkai"
  },
  {
    value: "STLiti"
  }
  // The following 3 fonts do not work, temporarily delete
  // {
  //     label: 'fontFamily.HanaleiFill',
  //     style: { 'font-family': 'HanaleiFill' },
  //     value: 'HanaleiFill',
  // },
  // {
  //     label: 'fontFamily.Anton',
  //     style: { 'font-family': 'Anton' },
  //     value: 'Anton',
  // },
  // {
  //     label: 'fontFamily.Pacifico',
  //     style: { 'font-family': 'Pacifico' },
  //     value: 'Pacifico',
  // },
];

// ../packages/ui/src/components/font-size/FontSize.tsx
var import_react31 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/components/font-size/index.module.less
var index_module_default6 = {
  "uiPluginSheetsFontSize": "univer-ui-plugin-sheets-font-size",
  "uiPluginSheetsFontSizeInput": "univer-ui-plugin-sheets-font-size-input"
};

// ../packages/ui/src/components/font-size/FontSize.tsx
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var FontSize = (props) => {
  const { value, min: min2, max: max2, onChange, disabled$ } = props;
  const disabled = useObservable(disabled$);
  const [realValue, setRealValue] = (0, import_react31.useState)(Number(value != null ? value : 0));
  const _value = (0, import_react31.useMemo)(() => Number(value != null ? value : realValue), [value]);
  function handleChange(value2) {
    if (value2 === null) return;
    setRealValue(value2);
  }
  function handleStopPropagation(e) {
    e.stopPropagation();
    if (e.code === "Enter") {
      onChange(realValue.toString());
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { className: index_module_default6.uiPluginSheetsFontSize, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
    InputNumber,
    {
      className: index_module_default6.uiPluginSheetsFontSizeInput,
      value: _value,
      controls: false,
      min: min2,
      max: max2,
      onKeyDown: handleStopPropagation,
      onChange: handleChange,
      disabled
    }
  ) });
};

// ../packages/ui/src/components/font-size/interface.ts
var FONT_SIZE_LIST = [
  {
    label: "9",
    value: 9
  },
  {
    label: "10",
    value: 10
  },
  {
    label: "11",
    value: 11
  },
  {
    label: "12",
    value: 12
  },
  {
    label: "14",
    value: 14
  },
  {
    label: "16",
    value: 16
  },
  {
    label: "18",
    value: 18
  },
  {
    label: "20",
    value: 20
  },
  {
    label: "22",
    value: 22
  },
  {
    label: "24",
    value: 24
  },
  {
    label: "26",
    value: 26
  },
  {
    label: "28",
    value: 28
  },
  {
    label: "36",
    value: 36
  },
  {
    label: "48",
    value: 48
  },
  {
    label: "72",
    value: 72
  }
];

// ../packages/ui/src/components/slider/Slider.tsx
var import_react32 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/components/slider/index.module.less
var index_module_default7 = {
  "sliderWidth": "116",
  "sliderHandleSize": "12",
  "slider": "univer-slider",
  "sliderDisabled": "univer-slider-disabled",
  "sliderRail": "univer-slider-rail",
  "sliderHandle": "univer-slider-handle",
  "sliderResetPoint": "univer-slider-reset-point",
  "sliderValue": "univer-slider-value",
  "sliderInnerRail": "univer-slider-inner-rail",
  "dropdownOpen": "univer-dropdown-open"
};

// ../packages/ui/src/components/slider/Slider.tsx
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
function Slider(props) {
  const localeService = useDependency(LocaleService);
  const { value, min: min2 = 0, max: max2 = 400, disabled = false, resetPoint = 100, shortcuts, onChange } = props;
  const sliderInnerRailRef = (0, import_react32.useRef)(null);
  const [zoomListVisible, setZoomListVisible] = (0, import_react32.useState)(false);
  function handleReset() {
    if (disabled) return;
    onChange && onChange(resetPoint);
  }
  function handleStep(offset2) {
    if (disabled) return;
    let result = value + offset2;
    if (value + offset2 <= min2) {
      result = min2;
    } else if (value + offset2 >= max2) {
      result = max2;
    }
    onChange && onChange(result);
  }
  const offset = (0, import_react32.useMemo)(() => {
    if (value <= resetPoint) {
      const ratio = 50 / (resetPoint - min2);
      return (value - min2) * ratio;
    }
    if (value <= max2) {
      return resetPoint * 0.5 + (value - resetPoint) / (max2 - resetPoint) * 50;
    }
  }, [min2, max2, resetPoint, value]);
  function handleMouseDown(e) {
    if (disabled) return;
    e.preventDefault();
    const rail = sliderInnerRailRef.current;
    let isDragging = true;
    function onMouseMove(e2) {
      if (isDragging) {
        const pureOffsetX = e2.clientX - rail.getBoundingClientRect().x;
        let offsetX = pureOffsetX;
        if (offsetX <= 0) {
          offsetX = 0;
        } else if (offsetX >= +index_module_default7.sliderWidth) {
          offsetX = +index_module_default7.sliderWidth;
        }
        const ratio = offsetX / +index_module_default7.sliderWidth;
        let result = 0;
        if (ratio <= 0.5) {
          result = min2 + ratio * (resetPoint - min2) * 2;
        } else {
          result = resetPoint + (ratio - 0.5) * (max2 - resetPoint) * 2;
        }
        onChange && onChange(Math.ceil(result));
      }
    }
    function onMouseUp() {
      isDragging = false;
      document.removeEventListener("pointermove", onMouseMove);
      window.removeEventListener("pointerup", onMouseUp);
    }
    function onMouseOut(e2) {
      e2.relatedTarget === null && onMouseUp();
    }
    window.addEventListener("pointermove", onMouseMove);
    window.addEventListener("pointerup", onMouseUp);
    window.addEventListener("pointerout", onMouseOut);
  }
  function handleSelectZoomLevel(value2) {
    if (disabled) return;
    setZoomListVisible(false);
    onChange && onChange(value2);
  }
  const items = [{
    type: "radio",
    value: value.toString(),
    options: shortcuts.map((item) => ({ value: item.toString(), label: `${item}%` })),
    onSelect: (value2) => handleSelectZoomLevel(+value2)
  }];
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
    "div",
    {
      className: clsx(index_module_default7.slider, {
        [index_module_default7.sliderDisabled]: disabled
      }),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Button, { type: "text", size: "small", disabled: value <= min2 || disabled, onClick: () => handleStep(-10), children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(reduce_single_default, {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("div", { className: index_module_default7.sliderRail, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { ref: sliderInnerRailRef, role: "track", className: index_module_default7.sliderInnerRail, children: [
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Tooltip, { title: `${localeService.t("zoom-slider.resetTo")} ${resetPoint}%`, placement: "top", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
            "a",
            {
              className: `
                              univer-absolute univer-left-1/2 univer-top-1/2 univer-box-border univer-block univer-h-0.5
                              univer-w-0.5 -univer-translate-x-1/2 -univer-translate-y-1/2 univer-cursor-pointer
                              univer-rounded-full univer-bg-white
                            `,
              role: "button",
              onClick: handleReset
            },
            "reset-button"
          ) }),
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
            "div",
            {
              className: index_module_default7.sliderHandle,
              role: "handle",
              style: {
                left: `${offset}%`
              },
              onPointerDown: handleMouseDown
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Button, { type: "text", size: "small", disabled: value >= max2 || disabled, onClick: () => handleStep(10), children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(increase_single_default, {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
          DropdownMenu,
          {
            align: "end",
            items,
            open: zoomListVisible,
            onOpenChange: setZoomListVisible,
            children: /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
              "a",
              {
                className: `
                      univer-flex univer-h-7 univer-w-[55px] univer-cursor-pointer univer-items-center
                      univer-justify-center univer-rounded univer-text-sm univer-text-gray-800 univer-transition-all
                      hover:univer-bg-gray-100
                    `,
                children: [
                  value,
                  "%"
                ]
              }
            )
          }
        )
      ]
    }
  );
}

// ../packages/ui/src/components/hooks/update-effect.ts
var import_react33 = __toESM(require_react());
var useUpdateEffect = (effect, deps) => {
  const hasMount = import_react33.default.useRef(false);
  (0, import_react33.useEffect)(() => {
    if (hasMount.current) {
      return effect();
    } else {
      hasMount.current = true;
    }
  }, deps);
};

// ../packages/ui/src/components/hooks/use-click-out-side.ts
var import_react34 = __toESM(require_react());

// ../packages/ui/src/components/hooks/virtual-list.ts
var import_react35 = __toESM(require_react());

// ../packages/ui/src/components/progress-bar/ProgressBar.tsx
var import_react36 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/ui/src/components/progress-bar/index.module.less
var index_module_default8 = {
  "progressBar": "univer-progress-bar",
  "progressBarContainer": "univer-progress-bar-container",
  "progressBarLabel": "univer-progress-bar-label",
  "progressBarInner": "univer-progress-bar-inner",
  "progressBarCloseButton": "univer-progress-bar-close-button"
};

// ../packages/ui/src/components/progress-bar/ProgressBar.tsx
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
function ProgressBar(props) {
  const { barColor, progress, onTerminate, onClearProgress } = props;
  const { count, done, label = "" } = progress;
  const themeService = useDependency(ThemeService);
  const color = barColor != null ? barColor : themeService.getCurrentTheme().primaryColor;
  ;
  const progressBarInnerRef = (0, import_react36.useRef)(null);
  const progressBarContainerRef = (0, import_react36.useRef)(null);
  (0, import_react36.useEffect)(() => {
    const progressBarInner = progressBarInnerRef.current;
    const progressBarContainer = progressBarContainerRef.current;
    if (!progressBarInner || !progressBarContainer) return;
    if (count === 0 && done === 0) {
      progressBarContainer.style.display = "none";
      progressBarInner.style.width = "0%";
      return;
    } else if (count > 0) {
      progressBarContainer.style.display = "flex";
      const width = Math.floor(done / count * 100);
      if (done === count) {
        requestAnimationFrame(() => {
          progressBarInner.style.width = `${width - 1}%`;
          requestAnimationFrame(() => {
            progressBarInner.style.width = `${width}%`;
          });
        });
      } else {
        progressBarInner.style.width = `${width}%`;
      }
    }
    const handleTransitionEnd = () => {
      if (done === count) {
        progressBarContainer.style.display = "none";
        progressBarInner.style.width = "0%";
        onClearProgress && onClearProgress();
      }
    };
    progressBarInner.addEventListener("transitionend", handleTransitionEnd);
    return () => {
      progressBarInner.removeEventListener("transitionend", handleTransitionEnd);
    };
  }, [count, done]);
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)("div", { ref: progressBarContainerRef, className: index_module_default8.progressBarContainer, style: { display: "none" }, children: [
    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Tooltip, { showIfEllipsis: true, title: label, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("span", { className: index_module_default8.progressBarLabel, children: label }) }),
    /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: index_module_default8.progressBar, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(
      "div",
      {
        ref: progressBarInnerRef,
        className: index_module_default8.progressBarInner,
        style: {
          backgroundColor: color
        }
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)("div", { className: index_module_default8.progressBarCloseButton, onClick: onTerminate, children: [
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(close_single_default, {})
    ] })
  ] });
}

// ../packages/ui/src/const.ts
var UNI_DISABLE_CHANGING_FOCUS_KEY = "UNI_DISABLE_CHANGING_FOCUS";

// ../packages/ui/src/services/sidebar/hooks/use-sidebar-click.ts
var import_react37 = __toESM(require_react());
var useSidebarClick = (cb) => {
  const sidebarService = useDependency(ISidebarService);
  const container = sidebarService.getContainer();
  (0, import_react37.useEffect)(() => {
    if (container) {
      container.addEventListener("mousedown", cb);
      return () => {
        container.removeEventListener("mousedown", cb);
      };
    }
  }, [cb, container]);
};

// ../packages/ui/src/utils/util.ts
function textTrim(x) {
  if (x.length === 0) {
    return x;
  }
  return x.replace(/^\s+|\s+$/gm, "");
}

// ../packages/ui/src/utils/cell.ts
var PX_TO_PT_RATIO2 = 0.75;
var MAX_FONT_SIZE = 78;
var MIN_FONT_SIZE = 9;
var DEFAULT_BACKGROUND_COLOR_RGBA = "rgba(0,0,0,0)";
var DEFAULT_BACKGROUND_COLOR_RGB = "rgb(0,0,0)";
function handleStringToStyle($dom, cssStyle = "") {
  var _a, _b;
  let cssText = (_b = (_a = $dom == null ? void 0 : $dom.style) == null ? void 0 : _a.cssText) != null ? _b : "";
  cssText += cssStyle;
  cssText = cssText.replace(/[\r\n]+/g, "");
  if (cssText.length === 0) {
    return {};
  }
  const cssTextArray = cssText.split(";");
  const styleList = {};
  const borderInfo = {
    t: "",
    r: "",
    b: "",
    l: ""
  };
  cssTextArray.forEach((originStr) => {
    var _a2;
    const s = originStr.toLowerCase();
    const key = textTrim(s.substr(0, s.indexOf(":")));
    const value = textTrim(s.substr(s.indexOf(":") + 1));
    if (key === "font-weight") {
      if (value === "bold" || value === "700") {
        styleList.bl = 1;
      } else {
        styleList.bl = 0;
      }
    } else if (key === "font-style") {
      if (value === "italic") {
        styleList.it = 1;
      } else {
        styleList.it = 0;
      }
    } else if (key === "font-family") {
      const trimValue = textTrim(originStr);
      const fontFamily = extractFontFamily(trimValue);
      styleList.ff = fontFamily;
    } else if (key === "font-size") {
      let fs = Number.parseInt(value);
      if (cssText.indexOf("vertical-align") > -1 && (cssText.indexOf("sub") > -1 || cssText.indexOf("sup") > -1)) {
        fs *= 2;
      }
      if (value.indexOf("px") !== -1) {
        fs = getPtFontSizeByPx(Number.parseInt(value, 10));
      }
      styleList.fs = fs;
    } else if (key === "color") {
      const colorKit = new ColorKit(value);
      styleList.cl = {
        rgb: colorKit.isValid ? colorKit.toRgbString() : "rgb(0,0,0)"
      };
    } else if (key === "background" || key === "background-color") {
      const backgroundColor = new ColorKit(value);
      if (backgroundColor) {
        const backgroundStr = backgroundColor.toRgbString();
        if (backgroundStr !== DEFAULT_BACKGROUND_COLOR_RGBA && backgroundStr !== DEFAULT_BACKGROUND_COLOR_RGB) {
          styleList.bg = {
            rgb: backgroundColor.toRgbString()
          };
        }
      }
    } else if (key === "text-decoration-line") {
      if (value === "underline") {
        if (!styleList.ul) {
          styleList.ul = { s: 1 };
        }
        styleList.ul.s = 1;
      } else if (value === "line-through") {
        if (!styleList.st) {
          styleList.st = { s: 1 };
        }
        styleList.st.s = 1;
      } else if (value === "overline") {
        if (!styleList.ol) {
          styleList.ol = { s: 1 };
        }
        styleList.ol.s = 1;
      }
    } else if (key === "text-decoration-color") {
      if (styleList.hasOwnProperty("ul")) {
        if (!styleList.ul) {
          styleList.ul = { s: 1, cl: { rgb: value } };
        }
        styleList.ul.cl = {
          rgb: value
        };
      }
      if (styleList.hasOwnProperty("st")) {
        if (!styleList.st) {
          styleList.st = { s: 1, cl: { rgb: value } };
        }
        styleList.st.cl = {
          rgb: value
        };
      }
      if (styleList.hasOwnProperty("ol")) {
        if (!styleList.ol) {
          styleList.ol = { s: 1, cl: { rgb: value } };
        }
        styleList.ol.cl = {
          rgb: value
        };
      }
    } else if (key === "text-decoration-style") {
      if (styleList.hasOwnProperty("ul")) {
        if (!styleList.ul) {
          styleList.ul = { s: 1, t: Number(value) };
        }
        styleList.ul.t = Number(value);
      }
      if (styleList.hasOwnProperty("st")) {
        if (!styleList.st) {
          styleList.st = { s: 1, t: Number(value) };
        }
        styleList.st.t = Number(value);
      }
      if (styleList.hasOwnProperty("ol")) {
        if (!styleList.ol) {
          styleList.ol = { s: 1, t: Number(value) };
        }
        styleList.ol.t = Number(value);
      }
    } else if (key === "text-decoration" || key === "univer-strike") {
      const lineValue = (_a2 = value.split(" ")) == null ? void 0 : _a2[0];
      if (lineValue === "underline") {
        if (!styleList.ul) {
          styleList.ul = { s: 1 };
        }
        styleList.ul.s = 1;
      } else if (lineValue === "line-through") {
        if (!styleList.st) {
          styleList.st = { s: 1 };
        }
        styleList.st.s = 1;
      } else if (lineValue === "overline") {
        if (!styleList.ol) {
          styleList.ol = { s: 1 };
        }
        styleList.ol.s = 1;
      }
    }
    if (key === "univer-underline") {
      styleList.ul = {
        s: 1
      };
    }
    if (key === "vertical-align") {
      if (value === "sub") {
        styleList.va = 2 /* SUBSCRIPT */;
      } else if (value === "super") {
        styleList.va = 3 /* SUPERSCRIPT */;
      } else if (value === "top") {
        styleList.vt = 1;
      } else if (value === "middle") {
        styleList.vt = 2;
      } else if (value === "bottom") {
        styleList.vt = 3;
      } else {
        styleList.va = 1 /* NORMAL */;
      }
    }
    if (key === "transform") {
      const values = value.split(")");
      const index = values.findIndex((item) => item.includes("rotate"));
      if (index > -1) {
        const match = values[index].match(/\d+/g);
        let angle = 0;
        let ver = 0;
        if (match == null ? void 0 : match.length) {
          angle = +match[0];
        }
        if ($dom == null ? void 0 : $dom.dataset.vertical) {
          ver = +$dom.dataset.vertical;
        }
        styleList.tr = {
          a: angle,
          v: ver
        };
      }
    }
    if (key === "text-align") {
      if (value === "left") {
        styleList.ht = 1;
      } else if (value === "center") {
        styleList.ht = 2;
      } else if (value === "right") {
        styleList.ht = 3;
      } else if (value === "justify") {
        styleList.ht = 4;
      } else {
        styleList.ht = 0;
      }
    }
    if (styleList.tb !== 1) {
      if (key === "overflow-wrap" || key === "word-wrap") {
        if (value === "break-word") {
          styleList.tb = 3;
        }
      } else if (key === "text-overflow") {
        if (value === "clip") {
          styleList.tb = 2;
        }
      } else if (key === "text-break") {
        if (value === "overflow") {
          styleList.tb = 1;
        }
      }
    }
    if (key === "white-space") {
      if (value === "nowrap") {
        styleList.tb = 1;
      } else if (value === "normal") {
        styleList.tb = 3;
      } else if (value === "clip") {
        styleList.tb = 2;
      }
    }
    if (key === "border-color") {
      const colors = handleBorder(value, ")");
      if (!styleList.bd) {
        styleList.bd = {
          b: {
            cl: {
              rgb: "#000"
            },
            s: 0
          },
          t: {
            cl: {
              rgb: "#000"
            },
            s: 0
          },
          l: {
            cl: {
              rgb: "#000"
            },
            s: 0
          },
          r: {
            cl: {
              rgb: "#000"
            },
            s: 0
          }
        };
        for (const k in colors) {
          styleList.bd[k].cl.rgb = colors[k];
        }
      } else {
        for (const k in colors) {
          styleList.bd[k].cl.rgb = colors[k];
        }
      }
    }
    if (key === "border-width" || key === "border-style") {
      const width = handleBorder(value, " ");
      for (const k in width) {
        borderInfo[k] += ` ${width[k]}`;
      }
      if (!styleList.bd) {
        styleList.bd = {
          b: {
            cl: {
              rgb: "#000"
            },
            s: getBorderStyleType(borderInfo.b)
          },
          t: {
            cl: {
              rgb: "#000"
            },
            s: getBorderStyleType(borderInfo.t)
          },
          l: {
            cl: {
              rgb: "#000"
            },
            s: getBorderStyleType(borderInfo.l)
          },
          r: {
            cl: {
              rgb: "#000"
            },
            s: getBorderStyleType(borderInfo.r)
          }
        };
      } else {
        styleList.bd.b.s = getBorderStyleType(borderInfo.b);
        styleList.bd.t.s = getBorderStyleType(borderInfo.t);
        styleList.bd.l.s = getBorderStyleType(borderInfo.l);
        styleList.bd.r.s = getBorderStyleType(borderInfo.r);
      }
    }
    if (key === "border-bottom" || key === "border-top" || key === "border-left" || key === "border-right" || key === "border") {
      if (!styleList.bd) {
        styleList.bd = {};
      }
      const arr = value.split(" ");
      const type2 = `${arr[0]} ${arr[1]}`;
      arr.splice(0, 2);
      const color = arr.join("");
      const lineType = getBorderStyleType(type2);
      if (lineType !== 0 /* NONE */ && color) {
        const obj = {
          cl: {
            rgb: color
          },
          s: getBorderStyleType(type2)
        };
        if (key === "border-bottom") {
          styleList.bd.b = value === "none" ? null : obj;
        } else if (key === "border-top") {
          styleList.bd.t = value === "none" ? null : obj;
        } else if (key === "border-left") {
          styleList.bd.l = value === "none" ? null : obj;
        } else if (key === "border-right") {
          styleList.bd.r = value === "none" ? null : obj;
        } else if (key === "border") {
          styleList.bd = {
            r: value === "none" ? null : obj,
            t: value === "none" ? null : obj,
            b: value === "none" ? null : obj,
            l: value === "none" ? null : obj
          };
        }
      }
    } else if (key === "--data-rotate") {
      const regex = /[+-]?\d+/;
      const match = value.match(regex);
      if (value === "(0deg ,1)") {
        styleList.tr = { a: 0, v: 1 };
      } else if (match) {
        styleList.tr = { a: Number(match[0]) };
      }
    }
  });
  Object.keys(styleList).forEach((key) => {
    if (typeof styleList[key] === "object" && !Object.keys(styleList[key]).length) {
      delete styleList[key];
    }
  });
  return styleList;
}
function handleBorder(border, param) {
  let arr;
  if (param === " ") {
    arr = border.trim().split(param);
  } else {
    arr = border.trim().split(param).slice(0, -1);
  }
  arr.forEach((item) => `${item.trim()})`);
  let obj = {};
  if (arr.length === 1) {
    obj = {
      t: arr[0],
      r: arr[0],
      b: arr[0],
      l: arr[0]
    };
  } else if (arr.length === 2) {
    obj = {
      t: arr[0],
      r: arr[1],
      b: arr[0],
      l: arr[1]
    };
  } else if (arr.length === 3) {
    obj = {
      t: arr[0],
      r: arr[1],
      b: arr[2],
      l: arr[1]
    };
  } else if (arr.length === 4) {
    obj = {
      t: arr[0],
      r: arr[1],
      b: arr[2],
      l: arr[3]
    };
  }
  return obj;
}
function getPtFontSizeByPx(size) {
  const ptSize = Math.round(size * PX_TO_PT_RATIO2);
  if (ptSize < MIN_FONT_SIZE) return MIN_FONT_SIZE;
  if (ptSize > MAX_FONT_SIZE) return MAX_FONT_SIZE;
  return ptSize;
}
function extractFontFamily(styleStr) {
  const regex = /font-family:\s*(?:"([^"]+)"|'([^']+)'|([^;]+))/i;
  const matches = styleStr.match(regex);
  return matches ? (matches[1] || matches[2] || matches[3]).trim() : null;
}

// ../packages/drawing/src/services/drawing-manager.service.ts
var IDrawingManagerService = createIdentifier("univer.drawing-manager.service");

// ../packages/drawing/src/commands/operations/set-drawing-selected.operation.ts
var SetDrawingSelectedOperation = {
  id: "drawing.operation.set-drawing-selected",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    const drawingManagerService = accessor.get(IDrawingManagerService);
    if (params == null) {
      return false;
    }
    drawingManagerService.focusDrawing(params);
    return true;
  }
};

// ../packages/drawing/src/controllers/config.schema.ts
var DRAWING_PLUGIN_CONFIG_KEY = "drawing.config";
var configSymbol3 = Symbol(DRAWING_PLUGIN_CONFIG_KEY);
var defaultPluginConfig3 = {};

// ../packages/drawing/src/services/drawing-manager-impl.service.ts
var json1 = __toESM(require_dist());
var UnitDrawingService = class {
  constructor() {
    __publicField(this, "drawingManagerData", {});
    __publicField(this, "_oldDrawingManagerData", {});
    __publicField(this, "_focusDrawings", []);
    __publicField(this, "_remove$", new Subject());
    __publicField(this, "remove$", this._remove$.asObservable());
    __publicField(this, "_add$", new Subject());
    __publicField(this, "add$", this._add$.asObservable());
    __publicField(this, "_update$", new Subject());
    __publicField(this, "update$", this._update$.asObservable());
    __publicField(this, "_order$", new Subject());
    __publicField(this, "order$", this._order$.asObservable());
    __publicField(this, "_group$", new Subject());
    __publicField(this, "group$", this._group$.asObservable());
    __publicField(this, "_ungroup$", new Subject());
    __publicField(this, "ungroup$", this._ungroup$.asObservable());
    __publicField(this, "_refreshTransform$", new Subject());
    __publicField(this, "refreshTransform$", this._refreshTransform$.asObservable());
    __publicField(this, "_visible$", new Subject());
    __publicField(this, "visible$", this._visible$.asObservable());
    // private readonly _externalUpdate$ = new Subject<T[]>();
    // readonly externalUpdate$ = this._externalUpdate$.asObservable();
    __publicField(this, "_focus$", new Subject());
    __publicField(this, "focus$", this._focus$.asObservable());
    __publicField(this, "_featurePluginUpdate$", new Subject());
    __publicField(this, "featurePluginUpdate$", this._featurePluginUpdate$.asObservable());
    __publicField(this, "_featurePluginAdd$", new Subject());
    __publicField(this, "featurePluginAdd$", this._featurePluginAdd$.asObservable());
    __publicField(this, "_featurePluginRemove$", new Subject());
    __publicField(this, "featurePluginRemove$", this._featurePluginRemove$.asObservable());
    __publicField(this, "_featurePluginOrderUpdate$", new Subject());
    __publicField(this, "featurePluginOrderUpdate$", this._featurePluginOrderUpdate$.asObservable());
    __publicField(this, "_featurePluginGroupUpdate$", new Subject());
    __publicField(this, "featurePluginGroupUpdate$", this._featurePluginGroupUpdate$.asObservable());
    __publicField(this, "_featurePluginUngroupUpdate$", new Subject());
    __publicField(this, "featurePluginUngroupUpdate$", this._featurePluginUngroupUpdate$.asObservable());
    __publicField(this, "_visible", true);
    __publicField(this, "_editable", true);
  }
  dispose() {
    this._remove$.complete();
    this._add$.complete();
    this._update$.complete();
    this._order$.complete();
    this._focus$.complete();
    this._featurePluginUpdate$.complete();
    this._featurePluginAdd$.complete();
    this._featurePluginRemove$.complete();
    this._featurePluginOrderUpdate$.complete();
    this.drawingManagerData = {};
    this._oldDrawingManagerData = {};
  }
  visibleNotification(visibleParams) {
    this._visible$.next(visibleParams);
  }
  refreshTransform(updateParams) {
    updateParams.forEach((updateParam) => {
      const param = this._getCurrentBySearch(updateParam);
      if (param == null) {
        return;
      }
      param.transform = updateParam.transform;
      param.transforms = updateParam.transforms;
      param.isMultiTransform = updateParam.isMultiTransform;
    });
    this.refreshTransformNotification(updateParams);
  }
  getDrawingDataForUnit(unitId) {
    return this.drawingManagerData[unitId] || {};
  }
  removeDrawingDataForUnit(unitId) {
    const subUnits = this.drawingManagerData[unitId];
    if (subUnits == null) {
      return;
    }
    delete this.drawingManagerData[unitId];
    const drawings = [];
    Object.keys(subUnits).forEach((subUnitId) => {
      const subUnit = subUnits[subUnitId];
      if ((subUnit == null ? void 0 : subUnit.data) == null) {
        return;
      }
      Object.keys(subUnit.data).forEach((drawingId) => {
        drawings.push({ unitId, subUnitId, drawingId });
      });
    });
    if (drawings.length > 0) {
      this.removeNotification(drawings);
    }
  }
  registerDrawingData(unitId, data2) {
    this.drawingManagerData[unitId] = data2;
  }
  initializeNotification(unitId) {
    const drawings = [];
    const data2 = this.drawingManagerData[unitId];
    if (data2 == null) {
      return;
    }
    Object.keys(data2).forEach((subUnitId) => {
      this._establishDrawingMap(unitId, subUnitId);
      const subUnitData = data2[subUnitId];
      Object.keys(subUnitData.data).forEach((drawingId) => {
        const drawing = subUnitData.data[drawingId];
        drawing.unitId = unitId;
        drawing.subUnitId = subUnitId;
        drawings.push(drawing);
      });
    });
    if (drawings.length > 0) {
      this.addNotification(drawings);
    }
  }
  getDrawingData(unitId, subUnitId) {
    return this._getDrawingData(unitId, subUnitId);
  }
  // Use in doc only.
  setDrawingData(unitId, subUnitId, data2) {
    this.drawingManagerData[unitId][subUnitId].data = data2;
  }
  getBatchAddOp(insertParams) {
    const objects = [];
    const ops = [];
    const invertOps = [];
    insertParams.forEach((insertParam) => {
      const { op: op2, invertOp: invertOp2 } = this._addByParam(insertParam);
      objects.push({ unitId: insertParam.unitId, subUnitId: insertParam.subUnitId, drawingId: insertParam.drawingId });
      ops.push(op2);
      invertOps.push(invertOp2);
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = invertOps.reduce(json1.type.compose, null);
    const { unitId, subUnitId } = insertParams[0];
    return { undo: invertOp, redo: op, unitId, subUnitId, objects };
  }
  getBatchRemoveOp(removeParams) {
    const ops = [];
    const invertOps = [];
    removeParams.forEach((removeParam) => {
      const { op: op2, invertOp: invertOp2 } = this._removeByParam(removeParam);
      ops.unshift(op2);
      invertOps.push(invertOp2);
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = invertOps.reduce(json1.type.compose, null);
    const { unitId, subUnitId } = removeParams[0];
    return { undo: invertOp, redo: op, unitId, subUnitId, objects: removeParams };
  }
  getBatchUpdateOp(updateParams) {
    const objects = [];
    const ops = [];
    const invertOps = [];
    updateParams.forEach((updateParam) => {
      const { op: op2, invertOp: invertOp2 } = this._updateByParam(updateParam);
      objects.push({ unitId: updateParam.unitId, subUnitId: updateParam.subUnitId, drawingId: updateParam.drawingId });
      ops.push(op2);
      invertOps.push(invertOp2);
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = invertOps.reduce(json1.type.compose, null);
    const { unitId, subUnitId } = updateParams[0];
    return { undo: invertOp, redo: op, unitId, subUnitId, objects };
  }
  removeNotification(removeParams) {
    this._remove$.next(removeParams);
  }
  addNotification(insertParams) {
    this._add$.next(insertParams);
  }
  updateNotification(updateParams) {
    this._update$.next(updateParams);
  }
  orderNotification(orderParams) {
    this._order$.next(orderParams);
  }
  groupUpdateNotification(groupParams) {
    this._group$.next(groupParams);
  }
  ungroupUpdateNotification(groupParams) {
    this._ungroup$.next(groupParams);
  }
  refreshTransformNotification(refreshParams) {
    this._refreshTransform$.next(refreshParams);
  }
  getGroupDrawingOp(groupParams) {
    const ops = [];
    const { unitId, subUnitId } = groupParams[0].parent;
    groupParams.forEach((groupParam) => {
      ops.push(this._getGroupDrawingOp(groupParam));
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { undo: invertOp, redo: op, unitId, subUnitId, objects: groupParams };
  }
  getUngroupDrawingOp(groupParams) {
    const ops = [];
    const { unitId, subUnitId } = groupParams[0].parent;
    groupParams.forEach((groupParam) => {
      ops.push(this._getUngroupDrawingOp(groupParam));
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { undo: invertOp, redo: op, unitId, subUnitId, objects: groupParams };
  }
  getDrawingsByGroup(groupParam) {
    const { unitId, subUnitId, drawingId } = groupParam;
    const group = this.getDrawingByParam({ unitId, subUnitId, drawingId });
    if (group == null) {
      return [];
    }
    const drawings = this._getDrawingData(unitId, subUnitId);
    const children = [];
    Object.keys(drawings).forEach((key) => {
      const drawing = drawings[key];
      if (drawing.groupId === drawingId) {
        children.push(drawing);
      }
    });
    return children;
  }
  _getGroupDrawingOp(groupParam) {
    const { parent, children } = groupParam;
    const { unitId: groupUnitId, subUnitId: groupSubUnitId, drawingId: groupDrawingId } = parent;
    const ops = [];
    ops.push(
      json1.insertOp([groupUnitId, groupSubUnitId, "data" /* data */, groupDrawingId], parent)
    );
    let maxChildIndex = Number.NEGATIVE_INFINITY;
    children.forEach((child) => {
      const { unitId, subUnitId, drawingId } = child;
      const index = this._hasDrawingOrder({ unitId, subUnitId, drawingId });
      maxChildIndex = Math.max(maxChildIndex, index);
      ops.push(
        ...this._getUpdateParamCompareOp(child, this.getDrawingByParam({ unitId, subUnitId, drawingId }))
      );
    });
    if (maxChildIndex === Number.NEGATIVE_INFINITY) {
      maxChildIndex = this._getDrawingOrder(groupUnitId, groupSubUnitId).length;
    }
    ops.push(
      json1.insertOp([groupUnitId, groupSubUnitId, "order" /* order */, maxChildIndex], groupDrawingId)
    );
    return ops.reduce(json1.type.compose, null);
  }
  _getUngroupDrawingOp(groupParam) {
    const { parent, children } = groupParam;
    const { unitId: groupUnitId, subUnitId: groupSubUnitId, drawingId: groupDrawingId } = parent;
    const ops = [];
    children.forEach((child) => {
      const { unitId, subUnitId, drawingId } = child;
      ops.push(
        ...this._getUpdateParamCompareOp(child, this.getDrawingByParam({ unitId, subUnitId, drawingId }))
      );
    });
    ops.push(
      json1.removeOp([groupUnitId, groupSubUnitId, "data" /* data */, groupDrawingId], true)
    );
    ops.push(
      json1.removeOp([groupUnitId, groupSubUnitId, "order" /* order */, this._getDrawingOrder(groupUnitId, groupSubUnitId).indexOf(groupDrawingId)], true)
    );
    return ops.reduce(json1.type.compose, null);
  }
  applyJson1(unitId, subUnitId, jsonOp) {
    this._establishDrawingMap(unitId, subUnitId);
    this._oldDrawingManagerData = { ...this.drawingManagerData };
    this.drawingManagerData = json1.type.apply(this.drawingManagerData, jsonOp);
  }
  // private _fillMissingFields(jsonOp: JSONOp) {
  //     if (jsonOp == null) {
  //         return;
  //     }
  //     let object: { [key: string]: {} } = this.drawingManagerData;
  //     for (let i = 0; i < jsonOp.length; i++) {
  //         const op = jsonOp[i];
  //         if (Array.isArray(op)) {
  //             const opKey = op[0] as string;
  //             if (!(opKey in object)) {
  //                 object[opKey] = null as unknown as never;
  //             }
  //         } else if (typeof op === 'string') {
  //             object = object[op];
  //             if (object == null) {
  //                 break;
  //             }
  //         }
  //     }
  // }
  featurePluginUpdateNotification(updateParams) {
    this._featurePluginUpdate$.next(updateParams);
  }
  featurePluginOrderUpdateNotification(drawingOrderUpdateParam) {
    this._featurePluginOrderUpdate$.next(drawingOrderUpdateParam);
  }
  featurePluginAddNotification(insertParams) {
    this._featurePluginAdd$.next(insertParams);
  }
  featurePluginRemoveNotification(removeParams) {
    this._featurePluginRemove$.next(removeParams);
  }
  featurePluginGroupUpdateNotification(groupParams) {
    this._featurePluginGroupUpdate$.next(groupParams);
  }
  featurePluginUngroupUpdateNotification(groupParams) {
    this._featurePluginUngroupUpdate$.next(groupParams);
  }
  getDrawingByParam(param) {
    return this._getCurrentBySearch(param);
  }
  getOldDrawingByParam(param) {
    return this._getOldBySearch(param);
  }
  getDrawingOKey(oKey) {
    const [unitId, subUnitId, drawingId] = oKey.split("#-#");
    return this._getCurrentBySearch({ unitId, subUnitId, drawingId });
  }
  focusDrawing(params) {
    if (params == null || params.length === 0) {
      this._focusDrawings = [];
      this._focus$.next([]);
      return;
    }
    const drawingParams = [];
    params.forEach((param) => {
      var _a;
      const { unitId, subUnitId, drawingId } = param;
      const item = (_a = this._getDrawingData(unitId, subUnitId)) == null ? void 0 : _a[drawingId];
      if (item != null) {
        drawingParams.push(item);
      }
    });
    if (drawingParams.length > 0) {
      this._focusDrawings = drawingParams;
      this._focus$.next(drawingParams);
    }
  }
  getFocusDrawings() {
    const drawingParams = [];
    this._focusDrawings.forEach((param) => {
      var _a;
      const { unitId, subUnitId, drawingId } = param;
      const item = (_a = this._getDrawingData(unitId, subUnitId)) == null ? void 0 : _a[drawingId];
      if (item != null) {
        drawingParams.push(item);
      }
    });
    return drawingParams;
  }
  getDrawingOrder(unitId, subUnitId) {
    return this._getDrawingOrder(unitId, subUnitId);
  }
  // Use in doc only.
  setDrawingOrder(unitId, subUnitId, order) {
    this.drawingManagerData[unitId][subUnitId].order = order;
  }
  orderUpdateNotification(orderParams) {
    this._order$.next(orderParams);
  }
  getForwardDrawingsOp(orderParams) {
    const { unitId, subUnitId, drawingIds } = orderParams;
    const ops = [];
    const orders = this.getDrawingOrder(unitId, subUnitId);
    const newIds = [...drawingIds];
    drawingIds.forEach((drawingId) => {
      const index = this._hasDrawingOrder({ unitId, subUnitId, drawingId });
      if (index === -1 || index === orders.length - 1) {
        return;
      }
      const op2 = json1.moveOp([unitId, subUnitId, "order" /* order */, index], [unitId, subUnitId, "order" /* order */, index + 1]);
      ops.push(op2);
      if (!newIds.includes(orders[index + 1])) {
        newIds.push(orders[index + 1]);
      }
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { undo: invertOp, redo: op, unitId, subUnitId, objects: { ...orderParams, drawingIds: newIds } };
  }
  getBackwardDrawingOp(orderParams) {
    const { unitId, subUnitId, drawingIds } = orderParams;
    const ops = [];
    const orders = this.getDrawingOrder(unitId, subUnitId);
    const newIds = [...drawingIds];
    drawingIds.forEach((drawingId) => {
      const index = this._hasDrawingOrder({ unitId, subUnitId, drawingId });
      if (index === -1 || index === 0) {
        return;
      }
      const op2 = json1.moveOp([unitId, subUnitId, "order" /* order */, index], [unitId, subUnitId, "order" /* order */, index - 1]);
      ops.push(op2);
      if (!newIds.includes(orders[index - 1])) {
        newIds.push(orders[index - 1]);
      }
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { undo: invertOp, redo: op, unitId, subUnitId, objects: { ...orderParams, drawingIds: newIds } };
  }
  getFrontDrawingsOp(orderParams) {
    const { unitId, subUnitId, drawingIds } = orderParams;
    const orderDrawingIds = this._getOrderFromSearchParams(unitId, subUnitId, drawingIds);
    const newIds = [...drawingIds];
    const orders = this.getDrawingOrder(unitId, subUnitId);
    const ops = [];
    orderDrawingIds.forEach((orderDrawingId) => {
      const { drawingId } = orderDrawingId;
      const index = this._getDrawingCount(unitId, subUnitId) - 1;
      const op2 = json1.moveOp([unitId, subUnitId, "order" /* order */, this._getDrawingOrder(unitId, subUnitId).indexOf(drawingId)], [unitId, subUnitId, "order" /* order */, index]);
      ops.push(op2);
      if (!newIds.includes(orders[index])) {
        newIds.push(orders[index]);
      }
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { undo: invertOp, redo: op, unitId, subUnitId, objects: { ...orderParams, drawingIds: newIds } };
  }
  getBackDrawingsOp(orderParams) {
    const { unitId, subUnitId, drawingIds } = orderParams;
    const orderSearchParams = this._getOrderFromSearchParams(unitId, subUnitId, drawingIds, true);
    const newIds = [...drawingIds];
    const orders = this.getDrawingOrder(unitId, subUnitId);
    const ops = [];
    orderSearchParams.forEach((orderSearchParam) => {
      const { drawingId } = orderSearchParam;
      const op2 = json1.moveOp([unitId, subUnitId, "order" /* order */, this._getDrawingOrder(unitId, subUnitId).indexOf(drawingId)], [unitId, subUnitId, "order" /* order */, 0]);
      ops.push(op2);
      if (!newIds.includes(orders[0])) {
        newIds.push(orders[0]);
      }
    });
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { undo: invertOp, redo: op, unitId, subUnitId, objects: { ...orderParams, drawingIds: newIds } };
  }
  _getDrawingCount(unitId, subUnitId) {
    return this.getDrawingOrder(unitId, subUnitId).length || 0;
  }
  _getOrderFromSearchParams(unitId, subUnitId, drawingIds, isDesc = false) {
    return drawingIds.map((drawingId) => {
      const zIndex = this._hasDrawingOrder({ unitId, subUnitId, drawingId });
      return { drawingId, zIndex };
    }).sort(isDesc === false ? sortRules : sortRulesByDesc);
  }
  _hasDrawingOrder(searchParam) {
    if (searchParam == null) {
      return -1;
    }
    const { unitId, subUnitId, drawingId } = searchParam;
    this._establishDrawingMap(unitId, subUnitId);
    return this._getDrawingOrder(unitId, subUnitId).indexOf(drawingId);
  }
  _getCurrentBySearch(searchParam) {
    var _a, _b, _c;
    if (searchParam == null) {
      return;
    }
    const { unitId, subUnitId, drawingId } = searchParam;
    return (_c = (_b = (_a = this.drawingManagerData[unitId]) == null ? void 0 : _a[subUnitId]) == null ? void 0 : _b.data) == null ? void 0 : _c[drawingId];
  }
  _getOldBySearch(searchParam) {
    var _a, _b, _c;
    if (searchParam == null) {
      return;
    }
    const { unitId, subUnitId, drawingId } = searchParam;
    return (_c = (_b = (_a = this._oldDrawingManagerData[unitId]) == null ? void 0 : _a[subUnitId]) == null ? void 0 : _b.data) == null ? void 0 : _c[drawingId];
  }
  _establishDrawingMap(unitId, subUnitId, drawingId) {
    var _a;
    if (!this.drawingManagerData[unitId]) {
      this.drawingManagerData[unitId] = {};
    }
    if (!this.drawingManagerData[unitId][subUnitId]) {
      this.drawingManagerData[unitId][subUnitId] = {
        data: {},
        order: []
      };
    }
    if (drawingId == null) {
      return null;
    }
    return (_a = this.drawingManagerData[unitId][subUnitId].data) == null ? void 0 : _a[drawingId];
  }
  _addByParam(insertParam) {
    const { unitId, subUnitId, drawingId } = insertParam;
    this._establishDrawingMap(unitId, subUnitId, drawingId);
    const op1 = json1.insertOp([unitId, subUnitId, "data" /* data */, drawingId], insertParam);
    const op2 = json1.insertOp([unitId, subUnitId, "order" /* order */, this._getDrawingOrder(unitId, subUnitId).length], drawingId);
    const op = [op1, op2].reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { op, invertOp };
  }
  _removeByParam(searchParam) {
    if (searchParam == null) {
      return { op: [], invertOp: [] };
    }
    const { unitId, subUnitId, drawingId } = searchParam;
    const object = this._establishDrawingMap(unitId, subUnitId, drawingId);
    if (object == null) {
      return { op: [], invertOp: [] };
    }
    const op1 = json1.removeOp([unitId, subUnitId, "data" /* data */, drawingId], true);
    const op2 = json1.removeOp([unitId, subUnitId, "order" /* order */, this._getDrawingOrder(unitId, subUnitId).indexOf(drawingId)], true);
    const op = [op1, op2].reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { op, invertOp };
  }
  _updateByParam(updateParam) {
    const { unitId, subUnitId, drawingId } = updateParam;
    const object = this._establishDrawingMap(unitId, subUnitId, drawingId);
    if (object == null) {
      return { op: [], invertOp: [] };
    }
    const ops = this._getUpdateParamCompareOp(updateParam, object);
    const op = ops.reduce(json1.type.compose, null);
    const invertOp = json1.type.invertWithDoc(op, this.drawingManagerData);
    return { op, invertOp };
  }
  // private _initializeDrawingData(updateParam: T, oldParam: T) {
  //     Object.keys(updateParam).forEach((key) => {
  //         if (!(key in oldParam)) {
  //             oldParam[key as keyof IDrawingParam] = null as unknown as never;
  //         }
  //     });
  // }
  _getUpdateParamCompareOp(newParam, oldParam) {
    const { unitId, subUnitId, drawingId } = newParam;
    const ops = [];
    Object.keys(newParam).forEach((key) => {
      const newVal = newParam[key];
      const oldVal = oldParam[key];
      if (oldVal === newVal) {
        return;
      }
      ops.push(
        json1.replaceOp([unitId, subUnitId, "data" /* data */, drawingId, key], oldVal, newVal)
      );
    });
    return ops;
  }
  _getDrawingData(unitId, subUnitId) {
    var _a, _b;
    return ((_b = (_a = this.drawingManagerData[unitId]) == null ? void 0 : _a[subUnitId]) == null ? void 0 : _b.data) || {};
  }
  _getDrawingOrder(unitId, subUnitId) {
    var _a, _b;
    return ((_b = (_a = this.drawingManagerData[unitId]) == null ? void 0 : _a[subUnitId]) == null ? void 0 : _b.order) || [];
  }
  getDrawingVisible() {
    return this._visible;
  }
  getDrawingEditable() {
    return this._editable;
  }
  setDrawingVisible(visible) {
    this._visible = visible;
  }
  setDrawingEditable(editable) {
    this._editable = editable;
  }
};
var DrawingManagerService = class extends UnitDrawingService {
};

// ../packages/drawing/src/basics/config.ts
var DRAWING_IMAGE_WIDTH_LIMIT = 500;
var DRAWING_IMAGE_HEIGHT_LIMIT = 500;
var DRAWING_IMAGE_COUNT_LIMIT = 10;
var DRAWING_IMAGE_ALLOW_SIZE = 5 * 1024 * 1024;
var DRAWING_IMAGE_ALLOW_IMAGE_LIST = ["image/png", "image/jpeg", "image/jpg", "image/gif", "image/bmp"];

// ../packages/drawing/src/services/image-io-impl.service.ts
var ImageIoService = class {
  constructor() {
    __publicField(this, "_waitCount", 0);
    __publicField(this, "_change$", new Subject());
    __publicField(this, "change$", this._change$);
    __publicField(this, "_imageSourceCache", /* @__PURE__ */ new Map());
  }
  setWaitCount(count) {
    this._waitCount = count;
    this._change$.next(count);
  }
  getImageSourceCache(source, imageSourceType) {
    if (imageSourceType === "BASE64" /* BASE64 */) {
      const image = new Image();
      image.src = source;
      return image;
    }
    return this._imageSourceCache.get(source);
  }
  addImageSourceCache(source, imageSourceType, imageSource) {
    if (imageSourceType === "BASE64" /* BASE64 */ || imageSource == null) {
      return;
    }
    this._imageSourceCache.set(source, imageSource);
  }
  async getImage(imageId) {
    return Promise.resolve(imageId);
  }
  async saveImage(imageFile) {
    return new Promise((resolve, reject) => {
      if (!DRAWING_IMAGE_ALLOW_IMAGE_LIST.includes(imageFile.type)) {
        reject(new Error("2" /* ERROR_IMAGE_TYPE */));
        this._decreaseWaiting();
        return;
      }
      if (imageFile.size > DRAWING_IMAGE_ALLOW_SIZE) {
        reject(new Error("1" /* ERROR_EXCEED_SIZE */));
        this._decreaseWaiting();
        return;
      }
      const reader = new FileReader();
      reader.readAsDataURL(imageFile);
      reader.onload = (evt) => {
        var _a;
        const replaceSrc = (_a = evt.target) == null ? void 0 : _a.result;
        if (replaceSrc == null) {
          reject(new Error("4" /* ERROR_IMAGE */));
          this._decreaseWaiting();
          return;
        }
        const imageId = Tools.generateRandomId(6);
        resolve({
          imageId,
          imageSourceType: "BASE64" /* BASE64 */,
          source: replaceSrc,
          base64Cache: replaceSrc,
          status: "0" /* SUCCUSS */
        });
        this._decreaseWaiting();
      };
    });
  }
  _decreaseWaiting() {
    this._waitCount -= 1;
    this._change$.next(this._waitCount);
  }
};

// ../packages/drawing/src/plugin.ts
var PLUGIN_NAME2 = "UNIVER_DRAWING_PLUGIN";
var UniverDrawingPlugin = class extends Plugin {
  constructor(_config = defaultPluginConfig3, _injector, _configService, _commandService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    this._commandService = _commandService;
    const { ...rest } = merge_default(
      {},
      defaultPluginConfig3,
      this._config
    );
    this._configService.setConfig(DRAWING_PLUGIN_CONFIG_KEY, rest);
  }
  onStarting() {
    this._initCommands();
    this._initDependencies();
  }
  _initDependencies() {
    var _a;
    const dependencies = [
      [IImageIoService, { useClass: ImageIoService }],
      [IDrawingManagerService, { useClass: DrawingManagerService }]
    ];
    const dependency = mergeOverrideWithDependencies(dependencies, (_a = this._config) == null ? void 0 : _a.override);
    dependency.forEach((d) => this._injector.add(d));
  }
  _initCommands() {
    [
      SetDrawingSelectedOperation
    ].forEach((command) => this.disposeWithMe(this._commandService.registerCommand(command)));
  }
};
__publicField(UniverDrawingPlugin, "pluginName", PLUGIN_NAME2);
UniverDrawingPlugin = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService),
  __decorateParam(3, ICommandService)
], UniverDrawingPlugin);

// ../packages/drawing/src/utils/get-image-shape-key.ts
function getDrawingShapeKeyByDrawingSearch({ unitId, subUnitId, drawingId }, index) {
  return typeof index === "number" ? `${unitId}#-#${subUnitId}#-#${drawingId}#-#${index}` : `${unitId}#-#${subUnitId}#-#${drawingId}`;
}

// ../packages/drawing/src/utils/get-image-size.ts
var getImageSize = async (src) => {
  return new Promise((resolve, reject) => {
    const image = new Image();
    image.src = src;
    image.onload = () => {
      resolve({
        width: image.width,
        height: image.height,
        image
      });
    };
    image.onerror = (error) => {
      reject(error);
    };
  });
};

// ../packages/docs/src/commands/operations/text-selection.operation.ts
var SetTextSelectionsOperation = {
  id: "doc.operation.set-selections",
  type: 1 /* OPERATION */,
  handler: () => {
    return true;
  }
};

// ../packages/docs/src/services/doc-selection-manager.service.ts
var DocSelectionManagerService = class extends RxDisposable {
  constructor(_commandService, _univerInstanceService) {
    super();
    this._commandService = _commandService;
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_currentSelection", null);
    __publicField(this, "_textSelectionInfo", /* @__PURE__ */ new Map());
    __publicField(this, "_textSelection$", new Subject());
    __publicField(this, "textSelection$", this._textSelection$.asObservable());
    __publicField(this, "_refreshSelection$", new BehaviorSubject(null));
    __publicField(this, "refreshSelection$", this._refreshSelection$.asObservable());
    this._listenCurrentUnit();
  }
  _listenCurrentUnit() {
    this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_DOC).pipe(takeUntil(this.dispose$)).subscribe((documentModel) => {
      if (documentModel == null) {
        return;
      }
      const unitId = documentModel.getUnitId();
      this._setCurrentSelectionNotRefresh({
        unitId,
        subUnitId: unitId
      });
    });
  }
  __getCurrentSelection() {
    return this._currentSelection;
  }
  getSelectionInfo(params = this._currentSelection) {
    return this._getTextRanges(params);
  }
  refreshSelection(params = this._currentSelection) {
    if (params == null) {
      return;
    }
    this._refresh(params);
  }
  // **Only used in test case** because this does not go through the render layer.
  __TEST_ONLY_setCurrentSelection(param) {
    this._currentSelection = param;
    this._refresh(param);
  }
  getTextRanges(params = this._currentSelection) {
    var _a;
    return (_a = this._getTextRanges(params)) == null ? void 0 : _a.textRanges;
  }
  getRectRanges(params = this._currentSelection) {
    var _a;
    return (_a = this._getTextRanges(params)) == null ? void 0 : _a.rectRanges;
  }
  getDocRanges(params = this._currentSelection) {
    var _a, _b;
    const textRanges = (_a = this.getTextRanges(params)) != null ? _a : [];
    const rectRanges = (_b = this.getRectRanges(params)) != null ? _b : [];
    const allRanges = [...textRanges, ...rectRanges].filter((range) => range.startOffset != null && range.endOffset != null).sort((a, b) => {
      if (a.startOffset > b.startOffset) {
        return 1;
      } else if (a.startOffset < b.startOffset) {
        return -1;
      } else {
        return 0;
      }
    });
    return allRanges;
  }
  getActiveTextRange() {
    const selectionInfo = this._getTextRanges(this._currentSelection);
    if (selectionInfo == null) {
      return;
    }
    const { textRanges } = selectionInfo;
    return textRanges.find((textRange) => textRange.isActive);
  }
  /**
   *
   * @deprecated
   */
  getActiveRectRange() {
    const selectionInfo = this._getTextRanges(this._currentSelection);
    if (selectionInfo == null) {
      return;
    }
    const { rectRanges } = selectionInfo;
    return rectRanges.find((rectRange) => rectRange.isActive);
  }
  // **Only used in test case** because this does not go through the render layer.
  __TEST_ONLY_add(textRanges, isEditing = true) {
    if (this._currentSelection == null) {
      return;
    }
    this._addByParam({
      ...this._currentSelection,
      textRanges,
      rectRanges: [],
      segmentId: "",
      segmentPage: -1,
      isEditing,
      style: NORMAL_TEXT_SELECTION_PLUGIN_STYLE
      // mock style.
    });
  }
  // Use to replace the current editor selection.
  /**
   * @deprecated pls use replaceDocRanges.
   */
  replaceTextRanges(docRanges, isEditing = true, options) {
    return this.replaceDocRanges(
      docRanges,
      this._currentSelection,
      isEditing,
      options
    );
  }
  replaceDocRanges(docRanges, params = this._currentSelection, isEditing = true, options) {
    if (params == null) {
      return;
    }
    const { unitId, subUnitId } = params;
    this._refreshSelection$.next({
      unitId,
      subUnitId,
      docRanges,
      isEditing,
      options
    });
  }
  // Only use in doc-selection-render.controller.ts
  __replaceTextRangesWithNoRefresh(textSelectionInfo, search) {
    if (this._currentSelection == null) {
      return;
    }
    const params = {
      ...textSelectionInfo,
      ...search
    };
    this._replaceByParam(params);
    this._textSelection$.next(params);
    const { unitId, subUnitId, segmentId, style, textRanges, rectRanges, isEditing } = params;
    const ranges = [...textRanges, ...rectRanges].filter((range) => range.startOffset != null && range.endOffset != null).sort((a, b) => {
      if (a.startOffset > b.startOffset) {
        return 1;
      } else if (a.startOffset < b.startOffset) {
        return -1;
      } else {
        return 0;
      }
    });
    this._commandService.executeCommand(SetTextSelectionsOperation.id, {
      unitId,
      subUnitId,
      segmentId,
      style,
      isEditing,
      ranges
    });
  }
  dispose() {
    this._textSelection$.complete();
  }
  _setCurrentSelectionNotRefresh(param) {
    this._currentSelection = param;
  }
  _getTextRanges(param) {
    var _a;
    if (param == null) {
      return;
    }
    const { unitId, subUnitId = "" } = param;
    return (_a = this._textSelectionInfo.get(unitId)) == null ? void 0 : _a.get(subUnitId);
  }
  _refresh(param) {
    const allTextSelectionInfo = this._getTextRanges(param);
    if (allTextSelectionInfo == null) {
      return;
    }
    const { textRanges, rectRanges } = allTextSelectionInfo;
    const docRanges = [...textRanges, ...rectRanges];
    const { unitId, subUnitId } = param;
    this._refreshSelection$.next({
      unitId,
      subUnitId,
      docRanges,
      isEditing: false
    });
  }
  _replaceByParam(insertParam) {
    const { unitId, subUnitId, ...selectionInsertParam } = insertParam;
    if (!this._textSelectionInfo.has(unitId)) {
      this._textSelectionInfo.set(unitId, /* @__PURE__ */ new Map());
    }
    const unitTextRange = this._textSelectionInfo.get(unitId);
    unitTextRange.set(subUnitId, { ...selectionInsertParam });
  }
  _addByParam(insertParam) {
    const { unitId, subUnitId, ...selectionInsertParam } = insertParam;
    if (!this._textSelectionInfo.has(unitId)) {
      this._textSelectionInfo.set(unitId, /* @__PURE__ */ new Map());
    }
    const unitTextRange = this._textSelectionInfo.get(unitId);
    if (!unitTextRange.has(subUnitId)) {
      unitTextRange.set(subUnitId, { ...selectionInsertParam });
    } else {
      const OldTextRanges = unitTextRange.get(subUnitId);
      OldTextRanges.textRanges.push(...insertParam.textRanges);
    }
  }
};
DocSelectionManagerService = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IUniverInstanceService)
], DocSelectionManagerService);

// ../packages/docs/src/services/doc-skeleton-manager.service.ts
var DocSkeletonManagerService = class extends RxDisposable {
  constructor(_context, _localeService, _univerInstanceService) {
    super();
    this._context = _context;
    this._localeService = _localeService;
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_skeleton");
    __publicField(this, "_docViewModel");
    __publicField(this, "_currentSkeleton$", new BehaviorSubject(null));
    __publicField(this, "currentSkeleton$", this._currentSkeleton$.asObservable());
    // CurrentSkeletonBefore for pre-triggered logic during registration
    __publicField(this, "_currentSkeletonBefore$", new BehaviorSubject(null));
    __publicField(this, "currentSkeletonBefore$", this._currentSkeletonBefore$.asObservable());
    __publicField(this, "_currentViewModel$", new BehaviorSubject(null));
    __publicField(this, "currentViewModel$", this._currentViewModel$.asObservable());
    this._init();
    this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_DOC).pipe(takeUntil(this.dispose$)).subscribe((documentModel) => {
      if (documentModel && documentModel.getUnitId() === this._context.unitId) {
        this._update(documentModel);
      }
    });
  }
  dispose() {
    super.dispose();
    this._currentSkeletonBefore$.complete();
    this._currentSkeleton$.complete();
  }
  getSkeleton() {
    return this._skeleton;
  }
  getViewModel() {
    return this._docViewModel;
  }
  _init() {
    const documentDataModel = this._context.unit;
    this._update(documentDataModel);
  }
  _update(documentDataModel) {
    const unitId = this._context.unitId;
    if (documentDataModel.getBody() == null) {
      return;
    }
    if (this._docViewModel && isInternalEditorID(unitId)) {
      this._docViewModel.reset(documentDataModel);
      this._context.unit = documentDataModel;
    } else if (!this._docViewModel) {
      this._docViewModel = this._buildDocViewModel(documentDataModel);
    }
    if (!this._skeleton) {
      this._skeleton = this._buildSkeleton(this._docViewModel);
    }
    const skeleton = this._skeleton;
    skeleton.calculate();
    this._currentSkeletonBefore$.next(skeleton);
    this._currentSkeleton$.next(skeleton);
    this._currentViewModel$.next(this._docViewModel);
  }
  _buildSkeleton(documentViewModel) {
    return DocumentSkeleton.create(documentViewModel, this._localeService);
  }
  _buildDocViewModel(documentDataModel) {
    return new DocumentViewModel(documentDataModel);
  }
};
DocSkeletonManagerService = __decorateClass([
  __decorateParam(1, Inject(LocaleService)),
  __decorateParam(2, IUniverInstanceService)
], DocSkeletonManagerService);

// ../packages/docs/src/services/doc-state-emit.service.ts
var DocStateEmitService = class extends RxDisposable {
  constructor() {
    super();
    __publicField(this, "_docStateChangeParams$", new BehaviorSubject(null));
    __publicField(this, "docStateChangeParams$", this._docStateChangeParams$.asObservable());
  }
  emitStateChangeInfo(params) {
    this._docStateChangeParams$.next(params);
  }
  dispose() {
    super.dispose();
    this._docStateChangeParams$.complete();
  }
};

// ../packages/docs/src/commands/mutations/core-editing.mutation.ts
var RichTextEditingMutationId = "doc.mutation.rich-text-editing";
var RichTextEditingMutation = {
  id: RichTextEditingMutationId,
  type: 2 /* MUTATION */,
  // eslint-disable-next-line max-lines-per-function
  handler: (accessor, params) => {
    var _a, _b;
    const {
      unitId,
      segmentId = "",
      actions,
      textRanges,
      prevTextRanges,
      trigger,
      noHistory,
      isCompositionEnd,
      noNeedSetTextRange,
      debounce,
      isEditing = true,
      isSync,
      syncer
    } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const renderManagerService = accessor.get(IRenderManagerService);
    const docStateEmitService = accessor.get(DocStateEmitService);
    const documentDataModel = univerInstanceService.getUniverDocInstance(unitId);
    const documentViewModel = (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService).getViewModel();
    if (documentDataModel == null || documentViewModel == null) {
      throw new Error(`DocumentDataModel or documentViewModel not found for unitId: ${unitId}`);
    }
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const docRanges = (_b = docSelectionManagerService.getDocRanges()) != null ? _b : [];
    const disabled = !!documentDataModel.getSnapshot().disabled;
    if (JSONX.isNoop(actions) || actions && actions.length === 0 || disabled) {
      return {
        unitId,
        actions: [],
        textRanges: docRanges
      };
    }
    const undoActions = JSONX.invertWithDoc(actions, documentDataModel.getSnapshot());
    documentDataModel.apply(actions);
    documentViewModel.reset(documentDataModel);
    if (!noNeedSetTextRange && textRanges && trigger != null && !isSync) {
      queueMicrotask(() => {
        docSelectionManagerService.replaceDocRanges(textRanges, { unitId, subUnitId: unitId }, isEditing, params.options);
      });
    }
    const changeState = {
      commandId: RichTextEditingMutationId,
      unitId,
      segmentId,
      trigger,
      noHistory,
      debounce,
      redoState: {
        actions,
        textRanges
      },
      undoState: {
        actions: undoActions,
        textRanges: prevTextRanges != null ? prevTextRanges : docRanges
      },
      isCompositionEnd,
      isSync,
      syncer
    };
    docStateEmitService.emitStateChangeInfo(changeState);
    return {
      unitId,
      actions: undoActions,
      textRanges: docRanges
    };
  }
};

// ../packages/docs/src/commands/mutations/docs-rename.mutation.ts
var DocsRenameMutation = {
  id: "doc.mutation.rename-doc",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const doc = univerInstanceService.getUnit(params.unitId, O.UNIVER_DOC);
    if (!doc) {
      return false;
    }
    doc.setName(params.name);
    return true;
  }
};

// ../packages/docs/src/controllers/config.schema.ts
var DOCS_PLUGIN_CONFIG_KEY = "docs.config";
var configSymbol4 = Symbol(DOCS_PLUGIN_CONFIG_KEY);
var defaultPluginConfig4 = {};

// ../packages/docs/src/controllers/custom-range.controller.ts
var DocCustomRangeController = class extends Disposable {
  constructor(_commandService, _textSelectionManagerService, _univerInstanceService) {
    super();
    this._commandService = _commandService;
    this._textSelectionManagerService = _textSelectionManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._initSelectionChange();
  }
  _transformCustomRange(doc, selection) {
    var _a;
    const { startOffset, endOffset, collapsed } = selection;
    const customRanges = (_a = doc.getCustomRanges()) == null ? void 0 : _a.filter((range) => {
      if (!range.wholeEntity) {
        return false;
      }
      if (startOffset <= range.startIndex && endOffset > range.endIndex) {
        return false;
      }
      if (collapsed) {
        return range.startIndex < startOffset && range.endIndex >= endOffset;
      }
      return BuildTextUtils.range.isIntersects(startOffset, endOffset - 1, range.startIndex, range.endIndex);
    });
    if (customRanges == null ? void 0 : customRanges.length) {
      let start = startOffset;
      let end = endOffset;
      customRanges.forEach((range) => {
        start = Math.min(range.startIndex, start);
        end = Math.max(range.endIndex + 1, end);
      });
      return {
        ...selection,
        startOffset: start,
        endOffset: end,
        collapsed: start === end
      };
    }
    return selection;
  }
  _initSelectionChange() {
    this.disposeWithMe(this._commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetTextSelectionsOperation.id) {
        const params = commandInfo.params;
        const { unitId, ranges, isEditing } = params;
        const doc = this._univerInstanceService.getUnit(unitId);
        if (!doc) {
          return;
        }
        const transformedRanges = ranges.map((range) => this._transformCustomRange(doc, range));
        if (transformedRanges.some((range, i) => ranges[i] !== range)) {
          this._textSelectionManagerService.replaceTextRanges(transformedRanges, isEditing);
        }
      }
    }));
  }
};
DocCustomRangeController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, Inject(DocSelectionManagerService)),
  __decorateParam(2, IUniverInstanceService)
], DocCustomRangeController);

// ../packages/docs/src/doc-plugin.ts
var PLUGIN_NAME3 = "DOCS_PLUGIN";
var UniverDocsPlugin = class extends Plugin {
  // static override type = UniverInstanceType.UNIVER_DOC;
  constructor(_config = defaultPluginConfig4, _injector, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    const { ...rest } = merge_default(
      {},
      defaultPluginConfig4,
      this._config
    );
    this._configService.setConfig(DOCS_PLUGIN_CONFIG_KEY, rest);
  }
  onStarting() {
    this._initializeDependencies();
    this._initializeCommands();
  }
  _initializeCommands() {
    [
      RichTextEditingMutation,
      DocsRenameMutation,
      SetTextSelectionsOperation
    ].forEach((command) => {
      this._injector.get(ICommandService).registerCommand(command);
    });
  }
  _initializeDependencies() {
    [
      [DocSelectionManagerService],
      [DocStateEmitService],
      [DocCustomRangeController]
    ].forEach((d) => this._injector.add(d));
  }
  onReady() {
    this._injector.get(DocCustomRangeController);
  }
};
__publicField(UniverDocsPlugin, "pluginName", PLUGIN_NAME3);
UniverDocsPlugin = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], UniverDocsPlugin);

// ../packages/docs/src/services/doc-interceptor/interceptor-const.ts
var CUSTOM_RANGE = createInterceptorKey("CUSTOM_RANGE");
var CUSTOM_DECORATION = createInterceptorKey("CUSTOM_DECORATION");
var DOC_INTERCEPTOR_POINT = {
  CUSTOM_RANGE,
  CUSTOM_DECORATION
};

// ../packages/docs/src/services/doc-interceptor/doc-interceptor.service.ts
var DocInterceptorService = class extends Disposable {
  constructor(_context, _docSkeletonManagerService) {
    super();
    this._context = _context;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    __publicField(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    const viewModel = this._docSkeletonManagerService.getViewModel();
    const unitId = viewModel.getDataModel().getUnitId();
    if (unitId === DOCS_NORMAL_EDITOR_UNIT_ID_KEY || unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) {
      return;
    }
    this.disposeWithMe(this.interceptDocumentViewModel(viewModel));
    this.disposeWithMe(this.intercept(DOC_INTERCEPTOR_POINT.CUSTOM_RANGE, {
      priority: -1,
      handler: (data2, pos, next) => {
        return next(data2);
      }
    }));
    let disposableCollection = new DisposableCollection();
    viewModel.segmentViewModels$.subscribe((segmentViewModels) => {
      disposableCollection.dispose();
      disposableCollection = new DisposableCollection();
      segmentViewModels.forEach((segmentViewModel) => {
        disposableCollection.add(this.interceptDocumentViewModel(segmentViewModel));
      });
    });
    this.disposeWithMe(disposableCollection);
  }
  intercept(name, interceptor) {
    const key = name;
    if (!this._interceptorsByName.has(key)) {
      this._interceptorsByName.set(key, []);
    }
    const interceptors = this._interceptorsByName.get(key);
    interceptors.push(interceptor);
    this._interceptorsByName.set(
      key,
      interceptors.sort((a, b) => {
        var _a, _b;
        return ((_a = b.priority) != null ? _a : 0) - ((_b = a.priority) != null ? _b : 0);
      })
    );
    return this.disposeWithMe(toDisposable(() => remove(this._interceptorsByName.get(key), interceptor)));
  }
  fetchThroughInterceptors(name) {
    const key = name;
    const interceptors = this._interceptorsByName.get(key);
    return composeInterceptors(interceptors || []);
  }
  interceptDocumentViewModel(viewModel) {
    const disposableCollection = new DisposableCollection();
    disposableCollection.add(viewModel.registerCustomRangeInterceptor({
      getCustomRange: (index) => {
        var _a;
        return this.fetchThroughInterceptors(DOC_INTERCEPTOR_POINT.CUSTOM_RANGE)(
          viewModel.getCustomRangeRaw(index),
          {
            index,
            unitId: viewModel.getDataModel().getUnitId(),
            customRanges: (_a = viewModel.getDataModel().getCustomRanges()) != null ? _a : []
          }
        );
      },
      getCustomDecoration: (index) => {
        var _a;
        return this.fetchThroughInterceptors(DOC_INTERCEPTOR_POINT.CUSTOM_DECORATION)(
          viewModel.getCustomDecorationRaw(index),
          {
            index,
            unitId: viewModel.getDataModel().getUnitId(),
            customDecorations: (_a = viewModel.getDataModel().getCustomDecorations()) != null ? _a : []
          }
        );
      }
    }));
    return disposableCollection;
  }
};
DocInterceptorService = __decorateClass([
  __decorateParam(1, Inject(DocSkeletonManagerService))
], DocInterceptorService);

// ../packages/docs/src/utils/custom-range-factory.ts
function getRichTextEditPath(docDataModel, segmentId = "") {
  if (!segmentId) {
    return ["body"];
  }
  const { headers, footers } = docDataModel.getSnapshot();
  if (headers == null && footers == null) {
    throw new Error("Document data model must have headers or footers when update by segment id");
  }
  if ((headers == null ? void 0 : headers[segmentId]) != null) {
    return ["headers", segmentId, "body"];
  } else if ((footers == null ? void 0 : footers[segmentId]) != null) {
    return ["footers", segmentId, "body"];
  } else {
    throw new Error("Segment id not found in headers or footers");
  }
}
function addCustomRangeBySelectionFactory(accessor, param) {
  var _a;
  const { rangeId, rangeType, wholeEntity, properties, unitId, selections: propSelection } = param;
  const docSelectionManagerService = accessor.get(DocSelectionManagerService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selections = propSelection != null ? propSelection : docSelectionManagerService.getTextRanges({ unitId, subUnitId: unitId });
  const segmentId = (_a = selections == null ? void 0 : selections[0]) == null ? void 0 : _a.segmentId;
  if (!(selections == null ? void 0 : selections.length)) {
    return false;
  }
  const documentDataModel = univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
  if (!documentDataModel) {
    return false;
  }
  const body = documentDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
  if (!body) {
    return false;
  }
  const textX = BuildTextUtils.customRange.add({
    ranges: selections,
    rangeId,
    rangeType,
    segmentId,
    wholeEntity,
    properties,
    body
  });
  if (!textX) {
    return false;
  }
  const jsonX = JSONX.getInstance();
  const doMutation = {
    id: RichTextEditingMutation.id,
    params: {
      unitId,
      actions: [],
      textRanges: textX.selections,
      segmentId
    },
    textX
  };
  const path = getRichTextEditPath(documentDataModel, segmentId);
  doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
  return doMutation;
}
function deleteCustomRangeFactory(accessor, params) {
  const { unitId, segmentId, insert } = params;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const documentDataModel = univerInstanceService.getUnit(unitId);
  if (!documentDataModel) {
    return false;
  }
  const doMutation = {
    id: RichTextEditingMutation.id,
    params: {
      unitId: params.unitId,
      actions: [],
      textRanges: void 0,
      segmentId
    }
  };
  const jsonX = JSONX.getInstance();
  const textX = BuildTextUtils.customRange.delete({
    documentDataModel,
    rangeId: params.rangeId,
    insert,
    segmentId
  });
  if (!textX) {
    return false;
  }
  const path = getRichTextEditPath(documentDataModel, segmentId);
  doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
  doMutation.params.textRanges = textX.selections;
  return doMutation;
}

// ../packages/docs/src/utils/replace-selection-factory.ts
function replaceSelectionFactory(accessor, params) {
  var _a, _b, _c, _d;
  const { unitId, body: insertBody, doc } = params;
  let docDataModel = doc;
  if (!docDataModel) {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    docDataModel = univerInstanceService.getUnit(unitId);
  }
  if (!docDataModel) {
    return false;
  }
  const segmentId = (_a = params.selection) == null ? void 0 : _a.segmentId;
  const body = (_b = docDataModel.getSelfOrHeaderFooterModel(segmentId)) == null ? void 0 : _b.getBody();
  if (!body) return false;
  const docSelectionManagerService = accessor.get(DocSelectionManagerService);
  const selection = (_c = params.selection) != null ? _c : docSelectionManagerService.getActiveTextRange();
  if (!selection || !body) {
    return false;
  }
  const textRanges = (_d = params.textRanges) != null ? _d : [{
    startOffset: selection.startOffset + insertBody.dataStream.length,
    endOffset: selection.startOffset + insertBody.dataStream.length,
    collapsed: true,
    segmentId
  }];
  const textX = BuildTextUtils.selection.replace({
    selection,
    body: insertBody,
    doc: docDataModel
  });
  if (!textX) {
    return false;
  }
  const doMutation = {
    id: RichTextEditingMutation.id,
    params: {
      unitId,
      actions: [],
      textRanges,
      debounce: true,
      segmentId
    },
    textX
  };
  const jsonX = JSONX.getInstance();
  doMutation.params.actions = jsonX.editOp(textX.serialize());
  return doMutation;
}

// ../packages/docs-ui/src/basics/selection.ts
function findFirstCursorOffset(snapshot) {
  var _a;
  const { dataStream } = (_a = snapshot.body) != null ? _a : {};
  const EXCLUDE_TOKENS = [
    "" /* TABLE_START */,
    "" /* TABLE_CELL_END */,
    "" /* TABLE_CELL_START */,
    "" /* TABLE_END */,
    "" /* TABLE_ROW_END */,
    "\x1B" /* TABLE_ROW_START */,
    "\v" /* COLUMN_BREAK */,
    "\f" /* PAGE_BREAK */,
    "	" /* TAB */,
    "\0" /* DOCS_END */,
    "\b" /* CUSTOM_BLOCK */
  ];
  if (typeof dataStream === "string") {
    for (let i = 0; i < dataStream.length; i++) {
      const char = dataStream[i];
      if (!EXCLUDE_TOKENS.includes(char)) {
        return i;
      }
    }
  }
  return 0;
}

// ../packages/docs-ui/src/basics/docs-view-key.ts
var DOCS_COMPONENT_BACKGROUND_LAYER_INDEX = 0;
var DOCS_COMPONENT_MAIN_LAYER_INDEX = 2;
var DOCS_COMPONENT_HEADER_LAYER_INDEX = 4;
var DOCS_COMPONENT_DEFAULT_Z_INDEX = 10;

// ../packages/docs-ui/src/basics/component-tools.ts
function neoGetDocObject(renderContext) {
  const { mainComponent, scene, engine, components } = renderContext;
  const document2 = mainComponent;
  const docBackground = components.get("__Document_Render_Background__" /* BACKGROUND */);
  return {
    document: document2,
    docBackground,
    scene,
    engine
  };
}
function getDocObject(univerInstanceService, renderManagerService) {
  const documentModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
  if (!documentModel) {
    return null;
  }
  const unitId = documentModel.getUnitId();
  const currentRender = renderManagerService.getRenderById(unitId);
  if (currentRender == null) {
    return;
  }
  const { mainComponent, scene, engine, components } = currentRender;
  const document2 = mainComponent;
  const docBackground = components.get("__Document_Render_Background__" /* BACKGROUND */);
  return {
    document: document2,
    docBackground,
    scene,
    engine
  };
}

// ../packages/docs-ui/src/commands/util.ts
function getCommandSkeleton(accessor, unitId) {
  var _a;
  const renderManagerService = accessor.get(IRenderManagerService);
  return (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService);
}
function getRichTextEditPath2(docDataModel, segmentId = "") {
  if (!segmentId) {
    return ["body"];
  }
  const { headers, footers } = docDataModel.getSnapshot();
  if (headers == null && footers == null) {
    throw new Error("Document data model must have headers or footers when update by segment id");
  }
  if ((headers == null ? void 0 : headers[segmentId]) != null) {
    return ["headers", segmentId, "body"];
  } else if ((footers == null ? void 0 : footers[segmentId]) != null) {
    return ["footers", segmentId, "body"];
  } else {
    throw new Error("Segment id not found in headers or footers");
  }
}

// ../packages/docs-ui/src/commands/commands/replace-content.command.ts
var ReplaceSnapshotCommand = {
  id: "doc.command-replace-snapshot",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: (accessor, params) => {
    const { unitId, snapshot, textRanges, segmentId = "", options } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const docDataModel = univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    const prevSnapshot = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getSnapshot();
    if (docDataModel == null || prevSnapshot == null) {
      return false;
    }
    const { body, tableSource, footers, headers, lists, drawings, drawingsOrder, documentStyle } = Tools.deepClone(snapshot);
    const {
      body: prevBody,
      tableSource: prevTableSource,
      footers: prevFooters,
      headers: prevHeaders,
      lists: prevLists,
      drawings: prevDrawings,
      drawingsOrder: prevDrawingsOrder,
      documentStyle: prevDocumentStyle
    } = prevSnapshot;
    if (body == null || prevBody == null) {
      return false;
    }
    if (Tools.diffValue(body, prevBody) && textRanges) {
      docSelectionManagerService.replaceDocRanges(textRanges, {
        unitId,
        subUnitId: unitId
      }, false);
      return true;
    }
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    if (options) {
      doMutation.params.options = options;
    }
    const rawActions = [];
    const jsonX = JSONX.getInstance();
    if (!Tools.diffValue(prevDocumentStyle, documentStyle)) {
      const actions = jsonX.replaceOp(["documentStyle"], prevDocumentStyle, documentStyle);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    if (!Tools.diffValue(body, prevBody)) {
      const actions = jsonX.replaceOp(["body"], prevBody, body);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    if (!Tools.diffValue(tableSource, prevTableSource)) {
      const actions = jsonX.replaceOp(["tableSource"], prevTableSource, tableSource);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    if (!Tools.diffValue(footers, prevFooters)) {
      const actions = jsonX.replaceOp(["footers"], prevFooters, footers);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    if (!Tools.diffValue(headers, prevHeaders)) {
      const actions = jsonX.replaceOp(["headers"], prevHeaders, headers);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    if (!Tools.diffValue(lists, prevLists)) {
      const actions = jsonX.replaceOp(["lists"], prevLists, lists);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    if (!Tools.diffValue(drawings, prevDrawings)) {
      const actions = jsonX.replaceOp(["drawings"], prevDrawings, drawings);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    if (!Tools.diffValue(drawingsOrder, prevDrawingsOrder)) {
      const actions = jsonX.replaceOp(["drawingsOrder"], prevDrawingsOrder, drawingsOrder);
      if (actions != null) {
        rawActions.push(actions);
      }
    }
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var ReplaceContentCommand = {
  id: "doc.command-replace-content",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const { unitId, body, textRanges, segmentId = "", options } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const docDataModel = univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    const prevBody = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getSnapshot().body;
    if (docDataModel == null || prevBody == null) {
      return false;
    }
    const doMutation = getMutationParams(unitId, segmentId, docDataModel, prevBody, body);
    doMutation.params.textRanges = textRanges;
    if (options) {
      doMutation.params.options = options;
    }
    if (doMutation.params.actions == null && textRanges) {
      docSelectionManagerService.replaceDocRanges(textRanges, {
        unitId,
        subUnitId: unitId
      }, false);
      return true;
    }
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var CoverContentCommand = {
  id: "doc.command-cover-content",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const { unitId, body, segmentId = "" } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const docDatModel = univerInstanceService.getUniverDocInstance(unitId);
    const prevBody = docDatModel == null ? void 0 : docDatModel.getSnapshot().body;
    if (docDatModel == null || prevBody == null) {
      return false;
    }
    const doMutation = getMutationParams(unitId, segmentId, docDatModel, prevBody, body);
    doMutation.params.noNeedSetTextRange = true;
    doMutation.params.noHistory = true;
    commandService.syncExecuteCommand(
      doMutation.id,
      doMutation.params
    );
    undoRedoService.clearUndoRedo(unitId);
    return true;
  }
};
function getMutationActions(segmentId, docDatModel, prevBody, body) {
  const textX = new TextX();
  const jsonX = JSONX.getInstance();
  const deleteLen = (prevBody == null ? void 0 : prevBody.dataStream.length) - 2;
  if (deleteLen > 0) {
    textX.push({
      t: "d" /* DELETE */,
      len: deleteLen
    });
  }
  if (body.dataStream.length > 0) {
    textX.push({
      t: "i" /* INSERT */,
      body,
      len: body.dataStream.length
    });
  }
  const path = getRichTextEditPath2(docDatModel, segmentId);
  return jsonX.editOp(textX.serialize(), path);
}
function getMutationParams(unitId, segmentId, docDatModel, prevBody, body) {
  const doMutation = {
    id: RichTextEditingMutation.id,
    params: {
      unitId,
      actions: [],
      textRanges: []
    }
  };
  const actions = getMutationActions(segmentId, docDatModel, prevBody, body);
  doMutation.params.actions = actions;
  return doMutation;
}
var ReplaceSelectionCommand = {
  id: "doc.command.replace-selection",
  type: 0 /* COMMAND */,
  handler(accessor, params) {
    var _a;
    if (!params) {
      return false;
    }
    const { unitId, body: insertBody, textRanges } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docDataModel = univerInstanceService.getUnit(unitId);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    if (!docDataModel) {
      return false;
    }
    const body = docDataModel.getBody();
    const selection = (_a = params.selection) != null ? _a : docSelectionManagerService.getActiveTextRange();
    if (!selection || !body) {
      return false;
    }
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges,
        debounce: true
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    textX.push(...BuildTextUtils.selection.delete([selection], body, 0, insertBody));
    doMutation.params.actions = jsonX.editOp(textX.serialize());
    return true;
  }
};
var ReplaceTextRunsCommand = {
  id: "doc.command.replace-text-runs",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const { unitId, body, textRanges, segmentId = "", options } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docDataModel = univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    const prevBody = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getSnapshot().body;
    if (docDataModel == null || prevBody == null) {
      return false;
    }
    const textX = BuildTextUtils.selection.replaceTextRuns({
      doc: docDataModel,
      body,
      selection: {
        startOffset: 0,
        endOffset: prevBody.dataStream.length - 2,
        collapsed: false
      }
    });
    if (!textX) {
      return false;
    }
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges,
        noHistory: true
      }
    };
    const jsonX = JSONX.getInstance();
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    doMutation.params.textRanges = textRanges;
    if (options) {
      doMutation.params.options = options;
    }
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/services/selection/convert-text-range.ts
var NodePositionType = /* @__PURE__ */ ((NodePositionType2) => {
  NodePositionType2[NodePositionType2["page"] = 0] = "page";
  NodePositionType2[NodePositionType2["section"] = 1] = "section";
  NodePositionType2[NodePositionType2["column"] = 2] = "column";
  NodePositionType2[NodePositionType2["line"] = 3] = "line";
  NodePositionType2[NodePositionType2["divide"] = 4] = "divide";
  NodePositionType2[NodePositionType2["glyph"] = 5] = "glyph";
  return NodePositionType2;
})(NodePositionType || {});
var NodePositionMap = {
  page: 0,
  section: 1,
  column: 2,
  line: 3,
  divide: 4,
  glyph: 5
};
function compareNodePositionLogic(pos1, pos2) {
  if (pos1.page > pos2.page) {
    return false;
  }
  if (pos1.page < pos2.page) {
    return true;
  }
  if (pos1.section > pos2.section) {
    return false;
  }
  if (pos1.section < pos2.section) {
    return true;
  }
  if (pos1.column > pos2.column) {
    return false;
  }
  if (pos1.column < pos2.column) {
    return true;
  }
  if (pos1.line > pos2.line) {
    return false;
  }
  if (pos1.line < pos2.line) {
    return true;
  }
  if (pos1.divide > pos2.divide) {
    return false;
  }
  if (pos1.divide < pos2.divide) {
    return true;
  }
  if (pos1.glyph > pos2.glyph) {
    return false;
  }
  if (pos1.glyph < pos2.glyph) {
    return true;
  }
  return true;
}
function compareNodePosition(pos1, pos2) {
  const compare2 = compareNodePositionLogic(pos1, pos2);
  if (compare2) {
    return {
      start: pos1,
      end: pos2
    };
  }
  return {
    start: pos2,
    end: pos1
  };
}
function getOneTextSelectionRange(rangeList) {
  const rangeCount = rangeList.length;
  if (rangeCount === 0) {
    return;
  }
  const firstCursor = rangeList[0];
  const lastCursor = rangeList[rangeCount - 1];
  const collapsed = rangeList.length === 1 && firstCursor.collapsed;
  return {
    startOffset: firstCursor.startOffset,
    endOffset: lastCursor.endOffset,
    collapsed
  };
}
function getOffsetInDivide(glyphGroup, startGlyphIndex, endGlyphIndex, st) {
  let startOffset = st;
  let endOffset = st;
  for (let i = 0; i < glyphGroup.length; i++) {
    const glyph = glyphGroup[i];
    const contentLength = glyph.count;
    if (i < startGlyphIndex) {
      startOffset += contentLength;
    }
    if (i < endGlyphIndex) {
      endOffset += contentLength;
    }
  }
  return {
    startOffset,
    endOffset
  };
}
function pushToPoints(position) {
  const { startX, startY, endX, endY } = position;
  const points = [];
  points.push({
    x: startX,
    y: startY
  });
  points.push({
    x: endX,
    y: startY
  });
  points.push({
    x: endX,
    y: endY
  });
  points.push({
    x: startX,
    y: endY
  });
  points.push({
    x: startX,
    y: startY
  });
  return points;
}
var NodePositionConvertToCursor = class {
  constructor(_documentOffsetConfig, _docSkeleton) {
    this._documentOffsetConfig = _documentOffsetConfig;
    this._docSkeleton = _docSkeleton;
    __publicField(this, "_liquid", new Liquid());
    __publicField(this, "_currentStartState", {
      page: 0 /* NORMAL */,
      section: 0 /* NORMAL */,
      column: 0 /* NORMAL */,
      line: 0 /* NORMAL */,
      divide: 0 /* NORMAL */,
      glyph: 0 /* NORMAL */
    });
    __publicField(this, "_currentEndState", {
      page: 0 /* NORMAL */,
      section: 0 /* NORMAL */,
      column: 0 /* NORMAL */,
      line: 0 /* NORMAL */,
      divide: 0 /* NORMAL */,
      glyph: 0 /* NORMAL */
    });
  }
  // eslint-disable-next-line max-lines-per-function
  getRangePointData(startOrigin, endOrigin) {
    const borderBoxPointGroup = [];
    const contentBoxPointGroup = [];
    const cursorList = [];
    if (startOrigin == null || endOrigin == null) {
      return {
        borderBoxPointGroup,
        contentBoxPointGroup,
        cursorList
      };
    }
    const isValid = this._isValidPosition(startOrigin, endOrigin);
    if (!isValid) {
      throw new Error(
        `
                Invalid positions in NodePositionConvertToCursor,
                they are not in the same segment page when in header or footer.`
      );
    }
    const { start, end } = compareNodePosition(startOrigin, endOrigin);
    this._selectionIterator(start, end, (start_sp, end_sp, isFirst, isLast, divide, line2) => {
      const { lineHeight, asc, paddingTop, marginTop, marginBottom } = line2;
      const { glyphGroup, st } = divide;
      if (glyphGroup.length === 0) {
        return;
      }
      const { x: startX, y: startY } = this._liquid;
      let borderBoxPosition;
      let contentBoxPosition;
      const firstGlyph = glyphGroup[start_sp];
      const lastGlyph = glyphGroup[end_sp];
      const preGlyph = glyphGroup[start_sp - 1];
      const firstGlyphLeft = (firstGlyph == null ? void 0 : firstGlyph.left) || 0;
      const firstGlyphWidth = (firstGlyph == null ? void 0 : firstGlyph.width) || 0;
      const lastGlyphLeft = (lastGlyph == null ? void 0 : lastGlyph.left) || 0;
      const lastGlyphWidth = (lastGlyph == null ? void 0 : lastGlyph.width) || 0;
      const isCurrentList = (firstGlyph == null ? void 0 : firstGlyph.glyphType) === 2 /* LIST */;
      const { startOffset, endOffset } = getOffsetInDivide(glyphGroup, start_sp, end_sp, st);
      const isStartBack = start.glyph === start_sp && isFirst ? start.isBack : true;
      const isEndBack = end.glyph === end_sp && isLast ? end.isBack : false;
      const collapsed = start === end;
      const anchorGlyph = isStartBack ? preGlyph != null ? preGlyph : firstGlyph : firstGlyph;
      if (start_sp === 0 && end_sp === glyphGroup.length - 1) {
        borderBoxPosition = {
          startX: startX + firstGlyphLeft + (isCurrentList ? firstGlyphWidth : 0),
          startY,
          endX: startX + lastGlyphLeft + (isEndBack ? 0 : lastGlyphWidth),
          endY: startY + lineHeight - marginTop - marginBottom
        };
        contentBoxPosition = {
          startX: startX + firstGlyphLeft + (isCurrentList ? firstGlyphWidth : 0),
          startY: startY + paddingTop + asc - anchorGlyph.bBox.ba,
          endX: startX + lastGlyphLeft + (isEndBack ? 0 : lastGlyphWidth),
          endY: startY + paddingTop + asc + anchorGlyph.bBox.bd
        };
      } else {
        const isStartBackFin = isStartBack && !isCurrentList;
        borderBoxPosition = {
          startX: startX + firstGlyphLeft + (isStartBackFin ? 0 : firstGlyphWidth),
          startY,
          endX: startX + lastGlyphLeft + (isEndBack ? 0 : lastGlyphWidth),
          endY: startY + lineHeight - marginTop - marginBottom
        };
        contentBoxPosition = {
          startX: startX + firstGlyphLeft + (isStartBackFin ? 0 : firstGlyphWidth),
          startY: startY + paddingTop + asc - anchorGlyph.bBox.ba,
          endX: startX + lastGlyphLeft + (isEndBack ? 0 : lastGlyphWidth),
          endY: startY + paddingTop + asc + anchorGlyph.bBox.bd
        };
      }
      borderBoxPointGroup.push(pushToPoints(borderBoxPosition));
      contentBoxPointGroup.push(pushToPoints(contentBoxPosition));
      cursorList.push({
        startOffset: isStartBack ? startOffset : startOffset + firstGlyph.count,
        endOffset: isEndBack ? endOffset : endOffset + lastGlyph.count,
        collapsed
      });
    });
    return {
      borderBoxPointGroup,
      contentBoxPointGroup,
      cursorList
    };
  }
  _isValidPosition(startOrigin, endOrigin) {
    const { segmentPage: startPage, pageType: startPageType } = startOrigin;
    const { segmentPage: endPage, pageType: endPageType } = endOrigin;
    if (startPageType !== endPageType) {
      return false;
    }
    if (startPageType === 1 /* HEADER */ || startPageType === 2 /* FOOTER */) {
      return startPage === endPage;
    }
    return true;
  }
  _resetCurrentNodePositionState() {
    this._currentStartState = {
      page: 0 /* NORMAL */,
      section: 0 /* NORMAL */,
      column: 0 /* NORMAL */,
      line: 0 /* NORMAL */,
      divide: 0 /* NORMAL */,
      glyph: 0 /* NORMAL */
    };
    this._currentEndState = {
      page: 0 /* NORMAL */,
      section: 0 /* NORMAL */,
      column: 0 /* NORMAL */,
      line: 0 /* NORMAL */,
      divide: 0 /* NORMAL */,
      glyph: 0 /* NORMAL */
    };
  }
  _setNodePositionState(type2 = 0 /* page */, start, end, current) {
    if (current === start) {
      this._currentStartState[type2] = 1 /* START */;
    } else {
      this._currentStartState[type2] = 0 /* NORMAL */;
    }
    if (current === end) {
      this._currentEndState[type2] = 2 /* END */;
    } else {
      this._currentEndState[type2] = 0 /* NORMAL */;
    }
  }
  _checkPreviousNodePositionState(typeIndex, isStart = true) {
    let index = typeIndex;
    let resultState;
    while (index >= 0) {
      const type2 = NodePositionType[index];
      let state;
      if (isStart) {
        state = this._currentStartState[type2];
      } else {
        state = this._currentEndState[type2];
      }
      if (state === void 0) {
        return;
      }
      if (resultState === void 0) {
        resultState = state;
      }
      if (state !== resultState) {
        return 0 /* NORMAL */;
      }
      index--;
    }
    return resultState;
  }
  _getSelectionRuler(typeIndex, startPosition, endPosition, nextLength, current) {
    let start_next = 0;
    let end_next = nextLength;
    const type2 = NodePositionType[typeIndex];
    const nextType = NodePositionType[typeIndex + 1];
    if (nextType === null || type2 === null) {
      return {
        start_next,
        end_next
      };
    }
    const start = startPosition[type2];
    const end = endPosition[type2];
    this._setNodePositionState(type2, start, end, current);
    const preStartNestType = this._checkPreviousNodePositionState(typeIndex);
    const preEndNestType = this._checkPreviousNodePositionState(typeIndex, false);
    if (preStartNestType === 1 /* START */) {
      start_next = startPosition[nextType];
    }
    if (preEndNestType === 2 /* END */) {
      end_next = endPosition[nextType];
    }
    return {
      start_next,
      end_next
    };
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _selectionIterator(startPosition, endPosition, func) {
    var _a, _b;
    const skeleton = this._docSkeleton;
    if (!skeleton) {
      return [];
    }
    const { pageType, path } = startPosition;
    this._liquid.reset();
    const skeletonData = skeleton.getSkeletonData();
    if (skeletonData == null) {
      return [];
    }
    const { pages, skeHeaders, skeFooters } = skeletonData;
    const { page: pageIndex, segmentPage } = startPosition;
    const { page: endPageIndex, segmentPage: endSegmentPage } = endPosition;
    this._resetCurrentNodePositionState();
    if (this._documentOffsetConfig == null) {
      return [];
    }
    const { pageLayoutType, pageMarginLeft, pageMarginTop } = this._documentOffsetConfig;
    const skipPageIndex = pageType === 0 /* BODY */ || pageType === 3 /* CELL */ ? pageIndex : segmentPage;
    for (let p = 0; p < skipPageIndex; p++) {
      const page = pages[p];
      this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
    }
    const endIndex = pageType === 0 /* BODY */ || pageType === 3 /* CELL */ ? endPageIndex : endSegmentPage;
    for (let p = skipPageIndex; p <= endIndex; p++) {
      const page = pages[p];
      const { headerId, footerId, pageWidth } = page;
      let segmentPage2 = page;
      if (pageType === 1 /* HEADER */) {
        segmentPage2 = (_a = skeHeaders.get(headerId)) == null ? void 0 : _a.get(pageWidth);
      } else if (pageType === 2 /* FOOTER */) {
        segmentPage2 = (_b = skeFooters.get(footerId)) == null ? void 0 : _b.get(pageWidth);
      } else if (pageType === 3 /* CELL */) {
        segmentPage2 = getPageFromPath(skeletonData, path);
      }
      if (segmentPage2 == null) {
        this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
        continue;
      }
      const sections = segmentPage2.sections;
      const { start_next: start_s, end_next: end_s } = this._getSelectionRuler(
        NodePositionMap.page,
        startPosition,
        endPosition,
        sections.length - 1,
        pageType === 0 /* BODY */ || pageType === 3 /* CELL */ ? p : 0
      );
      this._liquid.translateSave();
      switch (pageType) {
        case 1 /* HEADER */:
          this._liquid.translatePagePadding({
            ...segmentPage2,
            marginLeft: page.marginLeft
            // Because header or footer margin Left is 0.
          });
          break;
        case 2 /* FOOTER */: {
          const footerTop = page.pageHeight - segmentPage2.height - segmentPage2.marginBottom;
          this._liquid.translate(page.marginLeft, footerTop);
          break;
        }
        case 3 /* CELL */: {
          this._liquid.translatePagePadding(page);
          const rowSke = segmentPage2.parent;
          const tableSke = rowSke.parent;
          const { left: cellLeft } = segmentPage2;
          const { top: tableTop, left: tableLeft } = tableSke;
          const { top: rowTop } = rowSke;
          this._liquid.translate(tableLeft + cellLeft, tableTop + rowTop);
          this._liquid.translatePagePadding(segmentPage2);
          break;
        }
        default:
          this._liquid.translatePagePadding(page);
          break;
      }
      for (let s = start_s; s <= end_s; s++) {
        const section = sections[s];
        const columns = section.columns;
        const { start_next: start_c, end_next: end_c } = this._getSelectionRuler(
          NodePositionMap.section,
          startPosition,
          endPosition,
          columns.length - 1,
          s
        );
        this._liquid.translateSection(section);
        for (let c = start_c; c <= end_c; c++) {
          const column = columns[c];
          const lines = column.lines;
          const { start_next: start_l, end_next: end_l } = this._getSelectionRuler(
            NodePositionMap.column,
            startPosition,
            endPosition,
            lines.length - 1,
            c
          );
          this._liquid.translateColumn(column);
          for (let l = start_l; l <= end_l; l++) {
            const line2 = lines[l];
            const { divides } = line2;
            const { start_next: start_d, end_next: end_d } = this._getSelectionRuler(
              NodePositionMap.line,
              startPosition,
              endPosition,
              divides.length - 1,
              l
            );
            this._liquid.translateSave();
            this._liquid.translateLine(line2, true, false);
            for (let d = start_d; d <= end_d; d++) {
              const divide = divides[d];
              this._liquid.translateSave();
              this._liquid.translateDivide(divide);
              const { glyphGroup } = divide;
              const { start_next: start_sp, end_next: end_sp } = this._getSelectionRuler(
                NodePositionMap.divide,
                startPosition,
                endPosition,
                glyphGroup.length - 1,
                d
              );
              let isFirst = false;
              let isLast = false;
              if (p === skipPageIndex && s === start_s && c === start_c && l === start_l && d === start_d) {
                isFirst = true;
              }
              if (p === endIndex && s === end_s && c === end_c && l === end_l && d === end_d) {
                isLast = true;
              }
              func && func(start_sp, end_sp, isFirst, isLast, divide, line2, column, section, segmentPage2);
              this._liquid.translateRestore();
            }
            this._liquid.translateRestore();
          }
        }
      }
      this._liquid.translateRestore();
      this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
    }
  }
};

// ../packages/docs-ui/src/services/selection/convert-rect-range.ts
function isValidRectRange(anchorNodePosition, focusNodePosition) {
  const { path: anchorPath } = anchorNodePosition;
  const { path: focusPath } = focusNodePosition;
  if (anchorPath.length !== focusPath.length) {
    return false;
  }
  if (anchorPath.indexOf("cells") === -1) {
    return false;
  }
  const tableIdIndex = anchorPath.indexOf("skeTables") + 1;
  const rowIndex = anchorPath.indexOf("rows") + 1;
  const cellIndex = anchorPath.indexOf("cells") + 1;
  const { tableId: anchorTableId, sliceIndex: anchorSliceIndex } = getTableIdAndSliceIndex(anchorPath[tableIdIndex]);
  const { tableId: focusTableId, sliceIndex: focusSliceIndex } = getTableIdAndSliceIndex(focusPath[tableIdIndex]);
  if (anchorTableId !== focusTableId) {
    return false;
  }
  const anchorRowIndex = anchorPath[rowIndex];
  const focusRowIndex = focusPath[rowIndex];
  const anchorCellIndex = anchorPath[cellIndex];
  const focusCellIndex = focusPath[cellIndex];
  if (anchorRowIndex === focusRowIndex && anchorCellIndex === focusCellIndex && anchorSliceIndex === focusSliceIndex) {
    return false;
  }
  return true;
}
function isInSameTableCell(anchorNodePosition, focusNodePosition) {
  const { path: anchorPath } = anchorNodePosition;
  const { path: focusPath } = focusNodePosition;
  if (anchorPath.indexOf("cells") === -1 || focusPath.indexOf("cells") === -1) {
    return false;
  }
  if (anchorPath.length !== focusPath.length) {
    return false;
  }
  return Tools.diffValue(anchorPath, focusPath);
}
function isInSameTableCellData(skeleton, anchorNodePosition, focusNodePosition) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { path: anchorPath } = anchorNodePosition;
  const { path: focusPath } = focusNodePosition;
  if (anchorPath.indexOf("cells") === -1 || focusPath.indexOf("cells") === -1) {
    return false;
  }
  const anchorGlyph = skeleton.findGlyphByPosition(anchorNodePosition);
  const focusGlyph = skeleton.findGlyphByPosition(focusNodePosition);
  const anchorCellPage = (_d = (_c = (_b = (_a = anchorGlyph == null ? void 0 : anchorGlyph.parent) == null ? void 0 : _a.parent) == null ? void 0 : _b.parent) == null ? void 0 : _c.parent) == null ? void 0 : _d.parent;
  const focusCellPage = (_h = (_g = (_f = (_e = focusGlyph == null ? void 0 : focusGlyph.parent) == null ? void 0 : _e.parent) == null ? void 0 : _f.parent) == null ? void 0 : _g.parent) == null ? void 0 : _h.parent;
  if (anchorCellPage == null || focusCellPage == null) {
    return false;
  }
  const anchorRow = anchorCellPage.parent;
  const focusRow = focusCellPage.parent;
  const anchorColIndex = anchorRow.cells.indexOf(anchorCellPage);
  const focusColIndex = focusRow.cells.indexOf(focusCellPage);
  return anchorColIndex === focusColIndex && anchorRow.index === focusRow.index;
}
function compareNodePositionInTable(a, b) {
  if (isInSameTableCell(a, b)) {
    return compareNodePositionLogic(a, b);
  }
  const { path: aPath } = a;
  const { path: bPath } = b;
  const aTableId = aPath[aPath.length - 5];
  const bTableId = bPath[bPath.length - 5];
  if (aTableId !== bTableId && typeof aTableId === "string" && typeof bTableId === "string") {
    const aSlideId = aTableId.split("#-#")[1];
    const bSlideId = bTableId.split("#-#")[1];
    return +aSlideId < +bSlideId;
  }
  const aRowCount = aPath[aPath.length - 3];
  const bRowCount = bPath[bPath.length - 3];
  const aCellCount = aPath[aPath.length - 1];
  const bCellCount = bPath[bPath.length - 1];
  if (aRowCount < bRowCount) {
    return true;
  }
  if (aRowCount > bRowCount) {
    return false;
  }
  return aCellCount <= bCellCount;
}
function isEmptyCellPage(cell) {
  return cell.sections[0].columns[0].lines.length === 0;
}
function findNonEmptyCellPages(cells, startCol, endCol) {
  let s = startCol;
  let e = endCol;
  let startCell = cells[s];
  let endCell = cells[e];
  while (s < e && (isEmptyCellPage(startCell) || isEmptyCellPage(endCell))) {
    if (isEmptyCellPage(startCell)) {
      s++;
      startCell = cells[s];
    } else if (isEmptyCellPage(endCell)) {
      e--;
      endCell = cells[e];
    }
  }
  if (!isEmptyCellPage(startCell) && !isEmptyCellPage(endCell)) {
    return [startCell, endCell];
  }
}
var NodePositionConvertToRectRange = class {
  constructor(_documentOffsetConfig, _docSkeleton) {
    this._documentOffsetConfig = _documentOffsetConfig;
    this._docSkeleton = _docSkeleton;
    __publicField(this, "_liquid", new Liquid());
  }
  // eslint-disable-next-line max-lines-per-function
  getRangePointData(startNodePosition, endNodePosition) {
    const pointGroup = [];
    const docSkeleton = this._docSkeleton;
    const skeletonData = docSkeleton.getSkeletonData();
    if (skeletonData == null) {
      return;
    }
    const { pages } = skeletonData;
    const { segmentPage: startSegmentPage, page: startPage, pageType } = startNodePosition;
    const rectInfo = this._getTableRectRangeInfo(startNodePosition, endNodePosition);
    if (rectInfo == null) {
      return;
    }
    const {
      tableId,
      startRowIndex: startRow,
      startColumnIndex: startColumn,
      endRowIndex: endRow,
      endColumnIndex: endColumn
    } = rectInfo;
    this._liquid.reset();
    const { pageLayoutType, pageMarginLeft, pageMarginTop } = this._documentOffsetConfig;
    const skipPageIndex = pageType === 0 /* BODY */ || pageType === 3 /* CELL */ ? startPage : startSegmentPage;
    for (let p = 0; p < skipPageIndex; p++) {
      const page = pages[p];
      this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
    }
    for (let p = skipPageIndex; p < pages.length; p++) {
      const page = pages[p];
      this._liquid.translatePagePadding(page);
      const { skeTables } = page;
      let table2 = null;
      for (const [id, tableSke] of skeTables.entries()) {
        if (id.startsWith(tableId)) {
          table2 = tableSke;
        }
      }
      if (table2 == null) {
        this._liquid.restorePagePadding(page);
        this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
        continue;
      }
      this._liquid.translateSave();
      this._liquid.translate(0, table2.top);
      const { x, y } = this._liquid;
      const { left: tableLeft } = table2;
      for (const row of table2.rows) {
        if (row.index >= startRow && row.index <= endRow) {
          const cells = findNonEmptyCellPages(row.cells, startColumn, endColumn);
          if (cells == null) {
            continue;
          }
          const [rowStartCell, rowEndCell] = cells;
          const position = {
            startX: x + rowStartCell.left + tableLeft,
            startY: y + row.top,
            endX: x + rowEndCell.left + rowEndCell.pageWidth + tableLeft,
            endY: y + row.top + row.height
          };
          pointGroup.push(pushToPoints(position));
        }
      }
      this._liquid.translateRestore();
      this._liquid.restorePagePadding(page);
      this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
    }
    return {
      pointGroup,
      startRow,
      startColumn,
      endRow,
      endColumn,
      tableId
    };
  }
  getNodePositionGroup(anchorNodePosition, focusNodePosition) {
    const nodePositionGroup = [];
    const anchorIndex = this._docSkeleton.findCharIndexByPosition(anchorNodePosition);
    const focusIndex = this._docSkeleton.findCharIndexByPosition(focusNodePosition);
    if (anchorIndex == null || focusIndex == null) {
      return;
    }
    const compare2 = anchorIndex < focusIndex;
    const rectInfo = this._getTableRectRangeInfo(anchorNodePosition, focusNodePosition);
    if (rectInfo == null) {
      return;
    }
    const { tableId, startRowIndex, startColumnIndex, endRowIndex, endColumnIndex } = rectInfo;
    const tableNode = this._docSkeleton.getViewModel().findTableNodeById(tableId);
    if (tableNode == null) {
      return;
    }
    const totalColumns = tableNode.children[0].children.length;
    const spanEntireRow = startColumnIndex === 0 && endColumnIndex === totalColumns - 1;
    if (spanEntireRow) {
      const startCellNode = tableNode.children[startRowIndex].children[startColumnIndex];
      const startNodePosition = this._docSkeleton.findNodePositionByCharIndex(startCellNode.startIndex + 1);
      const endCellNode = tableNode.children[endRowIndex].children[endColumnIndex];
      const endNodePosition = this._docSkeleton.findNodePositionByCharIndex(endCellNode.endIndex - 2);
      if (startNodePosition == null || endNodePosition == null) {
        return;
      }
      nodePositionGroup.push({
        anchor: compare2 ? startNodePosition : endNodePosition,
        focus: compare2 ? endNodePosition : startNodePosition
      });
    } else {
      for (let i = startRowIndex; i <= endRowIndex; i++) {
        const rowNode = tableNode.children[i];
        const startCellNode = rowNode.children[startColumnIndex];
        const endCellNode = rowNode.children[endColumnIndex];
        const startNodePosition = this._docSkeleton.findNodePositionByCharIndex(startCellNode.startIndex + 1);
        const endNodePosition = this._docSkeleton.findNodePositionByCharIndex(endCellNode.endIndex - 2);
        if (startNodePosition == null || endNodePosition == null) {
          return;
        }
        nodePositionGroup.push({
          anchor: compare2 ? startNodePosition : endNodePosition,
          focus: compare2 ? endNodePosition : startNodePosition
        });
      }
    }
    return nodePositionGroup;
  }
  _getTableRectRangeInfo(anchorPosition, focusPosition) {
    const docSkeleton = this._docSkeleton;
    const skeletonData = docSkeleton.getSkeletonData();
    if (skeletonData == null) {
      return;
    }
    const { pages } = skeletonData;
    const { path: anchorPath } = anchorPosition;
    const { path: focusPath } = focusPosition;
    const anchorCell = getPageFromPath(skeletonData, anchorPath);
    const focusCell = getPageFromPath(skeletonData, focusPath);
    if (anchorCell == null || focusCell == null) {
      return;
    }
    const tableId = anchorCell.segmentId;
    const anchorRow = anchorCell.parent.index;
    const anchorColumn = anchorCell.parent.cells.indexOf(anchorCell);
    const focusRow = (focusCell == null ? void 0 : focusCell.parent).index;
    const focusColumn = (focusCell == null ? void 0 : focusCell.parent).cells.indexOf(focusCell);
    const startRowIndex = Math.min(anchorRow, focusRow);
    const endRowIndex = Math.max(anchorRow, focusRow);
    const startColumnIndex = Math.min(anchorColumn, focusColumn);
    const endColumnIndex = Math.max(anchorColumn, focusColumn);
    return {
      pages,
      tableId,
      startRowIndex,
      startColumnIndex,
      endRowIndex,
      endColumnIndex
    };
  }
};

// ../packages/docs-ui/src/services/selection/text-range.ts
var TEXT_RANGE_KEY_PREFIX = "__TestSelectionRange__";
var TEXT_ANCHOR_KEY_PREFIX = "__TestSelectionAnchor__";
var ID_LENGTH = 6;
var BLINK_ON = 500;
var BLINK_OFF = 500;
var TEXT_RANGE_LAYER_INDEX = 3;
function getAnchorBounding(pointsGroup) {
  const points = pointsGroup[0];
  const startPoint = points[0];
  const endPoint = points[2];
  const { x: startX, y: startY } = startPoint;
  const { x: endX, y: endY } = endPoint;
  return {
    left: startX,
    top: startY,
    width: endX - startX,
    height: endY - startY
  };
}
function getLineBounding(pointsGroup) {
  return pointsGroup.map((line2) => {
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;
    line2.forEach((point) => {
      xMin = Math.min(point.x, xMin);
      xMax = Math.max(point.x, xMax);
      yMax = Math.max(point.y, yMax);
      yMin = Math.min(point.y, yMin);
    });
    return {
      left: xMin,
      right: xMax,
      top: yMin,
      bottom: yMax
    };
  });
}
var TextRange = class {
  constructor(_scene, _document, _docSkeleton, anchorNodePosition, focusNodePosition, style = NORMAL_TEXT_SELECTION_PLUGIN_STYLE, _segmentId = "", _segmentPage = -1) {
    this._scene = _scene;
    this._document = _document;
    this._docSkeleton = _docSkeleton;
    this.anchorNodePosition = anchorNodePosition;
    this.focusNodePosition = focusNodePosition;
    this.style = style;
    this._segmentId = _segmentId;
    this._segmentPage = _segmentPage;
    __publicField(this, "rangeType", "TEXT" /* TEXT */);
    // Identifies whether the range is the current one, most of which is the last range.
    __publicField(this, "_current", false);
    // The rendered range graphic when collapsed is false
    __publicField(this, "_rangeShape");
    // The rendered range graphic when collapsed is true
    __publicField(this, "_anchorShape");
    __publicField(this, "_cursorList", []);
    __publicField(this, "_anchorBlinkTimer", null);
    this._anchorBlink();
    this.refresh();
  }
  _anchorBlink() {
    setTimeout(() => {
      if (this._anchorShape) {
        if (this._anchorShape.visible) {
          this.deactivateStatic();
        }
      }
    }, BLINK_ON);
    this._anchorBlinkTimer = setInterval(() => {
      if (this._anchorShape) {
        if (this._anchorShape.visible) {
          this.activeStatic();
          setTimeout(() => {
            this.deactivateStatic();
          }, BLINK_ON);
        }
      }
    }, BLINK_OFF + BLINK_ON);
  }
  // The start position of the range
  get startOffset() {
    var _a;
    const { startOffset } = (_a = getOneTextSelectionRange(this._cursorList)) != null ? _a : {};
    const body = this._docSkeleton.getViewModel().getDataModel().getSelfOrHeaderFooterModel(this._segmentId).getBody();
    if (startOffset == null || body == null) {
      return startOffset;
    }
    const maxLength = body.dataStream.length - 2;
    return Math.min(maxLength, startOffset);
  }
  // The end position of the range
  get endOffset() {
    var _a;
    const { endOffset } = (_a = getOneTextSelectionRange(this._cursorList)) != null ? _a : {};
    const body = this._docSkeleton.getViewModel().getDataModel().getSelfOrHeaderFooterModel(this._segmentId).getBody();
    if (endOffset == null || body == null) {
      return endOffset;
    }
    const maxLength = body.dataStream.length - 2;
    return Math.min(endOffset, maxLength);
  }
  get collapsed() {
    const { startOffset, endOffset } = this;
    return startOffset != null && startOffset === endOffset;
  }
  get startNodePosition() {
    if (this.anchorNodePosition == null) {
      return null;
    }
    if (this.focusNodePosition == null) {
      return this.anchorNodePosition;
    }
    const { start } = compareNodePosition(this.anchorNodePosition, this.focusNodePosition);
    return start;
  }
  get endNodePosition() {
    if (this.anchorNodePosition == null) {
      return this.focusNodePosition;
    }
    if (this.focusNodePosition == null) {
      return null;
    }
    const { end } = compareNodePosition(this.anchorNodePosition, this.focusNodePosition);
    return end;
  }
  get direction() {
    const { collapsed, anchorNodePosition, focusNodePosition } = this;
    if (collapsed || anchorNodePosition == null || focusNodePosition == null) {
      return "none" /* NONE */;
    }
    const compare2 = compareNodePositionLogic(anchorNodePosition, focusNodePosition);
    return compare2 ? "forward" /* FORWARD */ : "backward" /* BACKWARD */;
  }
  get segmentId() {
    return this._segmentId;
  }
  get segmentPage() {
    return this._segmentPage;
  }
  getAbsolutePosition() {
    const anchor = this.anchorNodePosition;
    const focus = this.focusNodePosition;
    if (this._isEmpty()) {
      return;
    }
    const documentOffsetConfig = this._document.getOffsetConfig();
    const { docsLeft, docsTop } = documentOffsetConfig;
    const convertor = new NodePositionConvertToCursor(documentOffsetConfig, this._docSkeleton);
    if (this._isCollapsed()) {
      const { contentBoxPointGroup, cursorList: cursorList2 } = convertor.getRangePointData(anchor, anchor);
      this._setCursorList(cursorList2);
      if (contentBoxPointGroup.length === 0) {
        return;
      }
      const pos2 = getAnchorBounding(contentBoxPointGroup);
      return {
        ...pos2,
        left: pos2.left + docsLeft,
        top: pos2.top + docsTop
      };
    }
    const { borderBoxPointGroup, cursorList } = convertor.getRangePointData(anchor, focus);
    this._setCursorList(cursorList);
    if (borderBoxPointGroup.length === 0) {
      return;
    }
    const pos = getAnchorBounding(borderBoxPointGroup);
    return {
      ...pos,
      left: pos.left + docsLeft,
      top: pos.top + docsTop
    };
  }
  getAnchor() {
    return this._anchorShape;
  }
  activeStatic() {
    var _a, _b;
    (_b = this._anchorShape) == null ? void 0 : _b.setProps({
      stroke: ((_a = this.style) == null ? void 0 : _a.strokeActive) || getColor(COLORS.black, 1)
    });
  }
  deactivateStatic() {
    var _a, _b;
    (_b = this._anchorShape) == null ? void 0 : _b.setProps({
      stroke: ((_a = this.style) == null ? void 0 : _a.stroke) || getColor(COLORS.black, 0)
    });
  }
  isActive() {
    return this._current === true;
  }
  activate() {
    this._current = true;
  }
  deactivate() {
    this._current = false;
  }
  dispose() {
    var _a, _b;
    (_a = this._rangeShape) == null ? void 0 : _a.dispose();
    this._rangeShape = null;
    (_b = this._anchorShape) == null ? void 0 : _b.dispose();
    this._anchorShape = null;
    if (this._anchorBlinkTimer) {
      clearInterval(this._anchorBlinkTimer);
      this._anchorBlinkTimer = null;
    }
  }
  isIntersection(compareRange) {
    const { startOffset: activeStart, endOffset: activeEnd } = this;
    const { startOffset: compareStart, endOffset: compareEnd } = compareRange;
    if (activeStart == null || activeEnd == null || compareStart == null || compareEnd == null) {
      return false;
    }
    return activeStart <= compareEnd && activeEnd >= compareStart;
  }
  // render cursor and selection.
  refresh() {
    var _a, _b;
    const { _document, _docSkeleton } = this;
    const anchor = this.anchorNodePosition;
    const focus = this.focusNodePosition;
    (_a = this._anchorShape) == null ? void 0 : _a.hide();
    (_b = this._rangeShape) == null ? void 0 : _b.hide();
    if (this._isEmpty()) {
      return;
    }
    const documentOffsetConfig = _document.getOffsetConfig();
    const { docsLeft, docsTop } = documentOffsetConfig;
    const convertor = new NodePositionConvertToCursor(documentOffsetConfig, _docSkeleton);
    if (this._isCollapsed()) {
      const { contentBoxPointGroup, cursorList: cursorList2 } = convertor.getRangePointData(anchor, anchor);
      this._setCursorList(cursorList2);
      if (contentBoxPointGroup.length > 0) {
        const glyphAtCursor = _docSkeleton.findGlyphByPosition(anchor);
        this._createOrUpdateAnchor(contentBoxPointGroup, docsLeft, docsTop, glyphAtCursor);
      }
      return;
    }
    const { borderBoxPointGroup, cursorList } = convertor.getRangePointData(anchor, focus);
    this._setCursorList(cursorList);
    if (borderBoxPointGroup.length > 0) {
      this._createOrUpdateRange(borderBoxPointGroup, docsLeft, docsTop);
    }
  }
  _isEmpty() {
    return this.anchorNodePosition == null && this.focusNodePosition == null;
  }
  _isCollapsed() {
    const anchor = this.anchorNodePosition;
    const focus = this.focusNodePosition;
    if (anchor != null && focus == null) {
      return true;
    }
    if (anchor == null || focus == null) {
      return false;
    }
    const keys = Object.keys(NodePositionMap);
    for (const key of keys) {
      const startNodeValue = anchor[key];
      const endNodeValue = focus[key];
      if (startNodeValue !== endNodeValue) {
        return false;
      }
    }
    if (anchor.isBack !== focus.isBack) {
      return false;
    }
    return true;
  }
  _createOrUpdateRange(pointsGroup, left, top) {
    var _a;
    if (this._rangeShape) {
      this._rangeShape.translate(left, top);
      this._rangeShape.updatePointGroup(pointsGroup);
      this._rangeShape.show();
      return;
    }
    const OPACITY = 0.3;
    const polygon = new RegularPolygon(TEXT_RANGE_KEY_PREFIX + Tools.generateRandomId(ID_LENGTH), {
      pointsGroup,
      fill: ((_a = this.style) == null ? void 0 : _a.fill) || getColor(COLORS.black, OPACITY),
      left,
      top,
      evented: false,
      debounceParentDirty: false
    });
    this._rangeShape = polygon;
    this._scene.addObject(polygon, TEXT_RANGE_LAYER_INDEX);
  }
  _createOrUpdateAnchor(pointsGroup, docsLeft, docsTop, glyph) {
    var _a, _b, _c;
    const bounding = getAnchorBounding(pointsGroup);
    const { left: boundingLeft } = bounding;
    let { top: boundingTop, height } = bounding;
    const MIN_CURSOR_HEIGHT = 14;
    if (height < MIN_CURSOR_HEIGHT) {
      boundingTop -= MIN_CURSOR_HEIGHT - height;
      height = MIN_CURSOR_HEIGHT;
    }
    const ITALIC_DEGREE = 12;
    let left = boundingLeft + docsLeft;
    const top = boundingTop + docsTop;
    const isItalic = ((_a = glyph == null ? void 0 : glyph.ts) == null ? void 0 : _a.it) === 1 /* TRUE */;
    if (isItalic) {
      left += height * Math.tan(ITALIC_DEGREE * Math.PI / 180) / 2;
    }
    if (this._anchorShape) {
      this._anchorShape.transformByState({ left, top, height });
      this._anchorShape.show();
      if (isItalic) {
        this._anchorShape.skew(-ITALIC_DEGREE, 0);
      } else {
        this._anchorShape.skew(0, 0);
      }
      return;
    }
    const anchor = new Rect(TEXT_ANCHOR_KEY_PREFIX + Tools.generateRandomId(ID_LENGTH), {
      left,
      top,
      height,
      strokeWidth: ((_b = this.style) == null ? void 0 : _b.strokeWidth) || 1.5,
      stroke: ((_c = this.style) == null ? void 0 : _c.strokeActive) || getColor(COLORS.black, 1),
      evented: false
    });
    if (isItalic) {
      anchor.skew(-ITALIC_DEGREE, 0);
    }
    this._anchorShape = anchor;
    this._scene.addObject(anchor, TEXT_RANGE_LAYER_INDEX);
    this.activeStatic();
  }
  _setCursorList(cursorList) {
    if (cursorList.length === 0) {
      return;
    }
    this._cursorList = cursorList;
  }
};

// ../packages/docs-ui/src/services/selection/rect-range.ts
var RECT_RANGE_KEY_PREFIX = "__DocTableRectRange__";
var ID_LENGTH2 = 6;
function convertPositionsToRectRanges(scene, document2, docSkeleton, anchorNodePosition, focusNodePosition, style = NORMAL_TEXT_SELECTION_PLUGIN_STYLE, segmentId = "", segmentPage = -1) {
  const documentOffsetConfig = document2.getOffsetConfig();
  const convertor = new NodePositionConvertToRectRange(documentOffsetConfig, docSkeleton);
  const nodePositionGroup = convertor.getNodePositionGroup(anchorNodePosition, focusNodePosition);
  return (nodePositionGroup != null ? nodePositionGroup : []).map((position) => new RectRange(
    scene,
    document2,
    docSkeleton,
    position.anchor,
    position.focus,
    style,
    segmentId,
    segmentPage
  ));
}
var RectRange = class {
  constructor(_scene, _document, _docSkeleton, anchorNodePosition, focusNodePosition, style = NORMAL_TEXT_SELECTION_PLUGIN_STYLE, _segmentId = "", _segmentPage = -1) {
    this._scene = _scene;
    this._document = _document;
    this._docSkeleton = _docSkeleton;
    this.anchorNodePosition = anchorNodePosition;
    this.focusNodePosition = focusNodePosition;
    this.style = style;
    this._segmentId = _segmentId;
    this._segmentPage = _segmentPage;
    __publicField(this, "rangeType", "RECT" /* RECT */);
    // The rendered rect range
    __publicField(this, "_rangeShape");
    // Identifies whether the range is the current one, most of which is the last range.
    __publicField(this, "_current", false);
    // Rect Range start row.
    __publicField(this, "_startRow");
    // Rect Range start column.
    __publicField(this, "_startCol");
    // Rect Range end row.
    __publicField(this, "_endRow");
    // Rect Range end column.
    __publicField(this, "_endCol");
    // table id in view model.
    __publicField(this, "_tableId");
    this.refresh();
  }
  get startOffset() {
    const { startNodePosition } = this;
    return this._docSkeleton.findCharIndexByPosition(startNodePosition);
  }
  get endOffset() {
    const { endNodePosition } = this;
    return this._docSkeleton.findCharIndexByPosition(endNodePosition);
  }
  get collapsed() {
    return false;
  }
  get startRow() {
    return this._startRow;
  }
  get startColumn() {
    return this._startCol;
  }
  get endRow() {
    return this._endRow;
  }
  get endColumn() {
    return this._endCol;
  }
  get tableId() {
    return this._tableId;
  }
  get segmentId() {
    return this._segmentId;
  }
  get segmentPage() {
    return this._segmentPage;
  }
  get spanEntireRow() {
    var _a;
    const viewModel = this._docSkeleton.getViewModel();
    const table2 = (_a = viewModel.getSnapshot().tableSource) == null ? void 0 : _a[this._tableId];
    const { _startCol, _endCol } = this;
    if (table2 == null) {
      throw new Error("Table is not found.");
    }
    const { tableColumns } = table2;
    return _startCol === 0 && _endCol === tableColumns.length - 1;
  }
  get spanEntireColumn() {
    var _a;
    const viewModel = this._docSkeleton.getViewModel();
    const table2 = (_a = viewModel.getSnapshot().tableSource) == null ? void 0 : _a[this._tableId];
    const { _startRow, _endRow } = this;
    if (table2 == null) {
      throw new Error("Table is not found.");
    }
    const { tableRows } = table2;
    return _startRow === 0 && _endRow === tableRows.length - 1;
  }
  get spanEntireTable() {
    return this.spanEntireRow && this.spanEntireColumn;
  }
  get startNodePosition() {
    const { anchorNodePosition, focusNodePosition } = this;
    const compare2 = compareNodePositionInTable(anchorNodePosition, focusNodePosition);
    return compare2 ? anchorNodePosition : focusNodePosition;
  }
  get endNodePosition() {
    const { anchorNodePosition, focusNodePosition } = this;
    const compare2 = compareNodePositionInTable(anchorNodePosition, focusNodePosition);
    return compare2 ? focusNodePosition : anchorNodePosition;
  }
  get direction() {
    const { anchorNodePosition, focusNodePosition } = this;
    const compare2 = compareNodePositionInTable(anchorNodePosition, focusNodePosition);
    return compare2 ? "forward" /* FORWARD */ : "backward" /* BACKWARD */;
  }
  isActive() {
    return this._current === true;
  }
  activate() {
    this._current = true;
  }
  deactivate() {
    this._current = false;
  }
  dispose() {
    var _a;
    (_a = this._rangeShape) == null ? void 0 : _a.dispose();
    this._rangeShape = null;
  }
  isIntersection(compareRange) {
    const { startRow, startColumn, endRow, endColumn } = this;
    const { startRow: cStartRow, startColumn: cStartColumn, endRow: cEndRow, endColumn: cEndColumn } = compareRange;
    const rect1 = {
      left: startColumn,
      top: startRow,
      right: endColumn,
      bottom: endRow
    };
    const rect2 = {
      left: cStartColumn,
      top: cStartRow,
      right: cEndColumn,
      bottom: cEndRow
    };
    return Rectangle.hasIntersectionBetweenTwoRect(rect1, rect2);
  }
  refresh() {
    var _a;
    (_a = this._rangeShape) == null ? void 0 : _a.hide();
    const { startNodePosition, endNodePosition, _document, _docSkeleton } = this;
    const documentOffsetConfig = _document.getOffsetConfig();
    const { docsLeft, docsTop } = documentOffsetConfig;
    const convertor = new NodePositionConvertToRectRange(documentOffsetConfig, _docSkeleton);
    const rectInfo = convertor.getRangePointData(startNodePosition, endNodePosition);
    if (rectInfo == null) {
      return;
    }
    const { pointGroup = [], startRow, endRow, startColumn, endColumn, tableId } = rectInfo;
    if ((pointGroup == null ? void 0 : pointGroup.length) > 0) {
      this._createOrUpdateRange(pointGroup, docsLeft, docsTop);
    }
    this._updateTableInfo(startRow, endRow, startColumn, endColumn, tableId);
  }
  _updateTableInfo(startRow, endRow, startCol, endCol, tableId) {
    this._startRow = startRow;
    this._endRow = endRow;
    this._startCol = startCol;
    this._endCol = endCol;
    this._tableId = tableId;
  }
  _createOrUpdateRange(pointsGroup, left, top) {
    var _a;
    if (this._rangeShape) {
      this._rangeShape.translate(left, top);
      this._rangeShape.updatePointGroup(pointsGroup);
      this._rangeShape.show();
      return;
    }
    const OPACITY = 0.3;
    const polygon = new RegularPolygon(RECT_RANGE_KEY_PREFIX + Tools.generateRandomId(ID_LENGTH2), {
      pointsGroup,
      fill: ((_a = this.style) == null ? void 0 : _a.fill) || getColor(COLORS.black, OPACITY),
      left,
      top,
      evented: false,
      debounceParentDirty: false
    });
    this._rangeShape = polygon;
    this._scene.addObject(polygon, TEXT_RANGE_LAYER_INDEX);
  }
};

// ../packages/docs-ui/src/services/selection/selection-utils.ts
function getTextRangeFromCharIndex(startOffset, endOffset, scene, document2, skeleton, style, segmentId, segmentPage, startIsBack = true, endIsBack = true) {
  const startNodePosition = skeleton.findNodePositionByCharIndex(startOffset, startIsBack, segmentId, segmentPage);
  const endNodePosition = skeleton.findNodePositionByCharIndex(endOffset, endIsBack, segmentId, segmentPage);
  if (startNodePosition == null || endNodePosition == null) {
    return;
  }
  return new TextRange(scene, document2, skeleton, startNodePosition, endNodePosition, style, segmentId, segmentPage);
}
function getRectRangeFromCharIndex(startOffset, endOffset, scene, document2, skeleton, style, segmentId, segmentPage) {
  const startNodePosition = skeleton.findNodePositionByCharIndex(startOffset, true, segmentId, segmentPage);
  const endNodePosition = skeleton.findNodePositionByCharIndex(endOffset, true, segmentId, segmentPage);
  if (startNodePosition == null || endNodePosition == null) {
    return;
  }
  return new RectRange(scene, document2, skeleton, startNodePosition, endNodePosition, style, segmentId, segmentPage);
}
function getRangeListFromCharIndex(startOffset, endOffset, scene, document2, skeleton, style, segmentId, segmentPage) {
  const startNodePosition = skeleton.findNodePositionByCharIndex(startOffset, true, segmentId, segmentPage);
  const endNodePosition = skeleton.findNodePositionByCharIndex(endOffset, true, segmentId, segmentPage);
  if (startNodePosition == null || endNodePosition == null) {
    return;
  }
  return getRangeListFromSelection(
    startNodePosition,
    endNodePosition,
    scene,
    document2,
    skeleton,
    style,
    segmentId,
    segmentPage
  );
}
function getRangeListFromSelection(anchorPosition, focusPosition, scene, document2, skeleton, style, segmentId, segmentPage) {
  const textRanges = [];
  const rectRanges = [];
  const rangeParams = [scene, document2, skeleton, anchorPosition, focusPosition, style, segmentId, segmentPage];
  if (isInSameTableCellData(skeleton, anchorPosition, focusPosition)) {
    if (isInSameTableCell(anchorPosition, focusPosition)) {
      textRanges.push(new TextRange(...rangeParams));
      return {
        textRanges,
        rectRanges
      };
    } else {
      const ranges = convertPositionsToRectRanges(
        ...rangeParams
      );
      rectRanges.push(...ranges);
      return {
        textRanges,
        rectRanges
      };
    }
  }
  if (isValidRectRange(anchorPosition, focusPosition)) {
    const ranges = convertPositionsToRectRanges(
      ...rangeParams
    );
    rectRanges.push(...ranges);
    return {
      textRanges,
      rectRanges
    };
  }
  const viewModel = skeleton.getViewModel().getSelfOrHeaderFooterViewModel(segmentId);
  const anchorOffset = skeleton.findCharIndexByPosition(anchorPosition);
  const focusOffset = skeleton.findCharIndexByPosition(focusPosition);
  if (anchorOffset == null || focusOffset == null) {
    return;
  }
  const direction = anchorOffset <= focusOffset ? "forward" /* FORWARD */ : "backward" /* BACKWARD */;
  const startOffset = Math.min(anchorOffset, focusOffset);
  const endOffset = Math.max(anchorOffset, focusOffset);
  let start = startOffset;
  let end = endOffset;
  for (const section of viewModel.getChildren()) {
    for (const paragraph of section.children) {
      const { startIndex, endIndex, children } = paragraph;
      const paragraphIndex = section.children.indexOf(paragraph);
      const nextParagraph = section.children[paragraphIndex + 1];
      const table2 = children[0];
      let endInTable = false;
      if (table2) {
        const { startIndex: tableStart, endIndex: tableEnd, children: children2 } = table2;
        let tableStartPosition = null;
        let tableEndPosition = null;
        const startRow = children2.find((row) => row.startIndex <= startOffset && row.endIndex >= startOffset);
        const endRow = children2.find((row) => row.startIndex <= endOffset && row.endIndex >= endOffset);
        if (startOffset > tableStart && startOffset < tableEnd) {
          tableStartPosition = skeleton.findNodePositionByCharIndex(startRow.startIndex + 2, true, segmentId, segmentPage);
          tableEndPosition = skeleton.findNodePositionByCharIndex(tableEnd - 4, true, segmentId, segmentPage);
          start = tableEnd + 1;
        } else if (endOffset > tableStart && endOffset < tableEnd) {
          tableStartPosition = skeleton.findNodePositionByCharIndex(tableStart + 3, true, segmentId, segmentPage);
          tableEndPosition = skeleton.findNodePositionByCharIndex(endRow.endIndex - 3, true, segmentId, segmentPage);
          end = tableStart - 1;
          endInTable = true;
        } else if (tableStart > startOffset && tableEnd < endOffset) {
          tableStartPosition = skeleton.findNodePositionByCharIndex(tableStart + 3, true, segmentId, segmentPage);
          tableEndPosition = skeleton.findNodePositionByCharIndex(tableEnd - 4, true, segmentId, segmentPage);
          if (start <= tableStart - 1) {
            const sp = skeleton.findNodePositionByCharIndex(start, true, segmentId, segmentPage);
            const ep = skeleton.findNodePositionByCharIndex(tableStart - 1, false, segmentId, segmentPage);
            const ap = direction === "forward" /* FORWARD */ ? sp : ep;
            const fp = direction === "forward" /* FORWARD */ ? ep : sp;
            textRanges.push(new TextRange(scene, document2, skeleton, ap, fp, style, segmentId, segmentPage));
          }
          start = tableEnd + 1;
        }
        if (tableStartPosition && tableEndPosition) {
          const ap = direction === "forward" /* FORWARD */ ? tableStartPosition : tableEndPosition;
          const fp = direction === "forward" /* FORWARD */ ? tableEndPosition : tableStartPosition;
          rectRanges.push(...convertPositionsToRectRanges(
            scene,
            document2,
            skeleton,
            ap,
            fp,
            style,
            segmentId,
            segmentPage
          ));
        }
      }
      if (end === endIndex + 1 && !endInTable && nextParagraph && nextParagraph.children.length) {
        end = endIndex;
        endInTable = true;
      }
      if (end >= startIndex && end <= endIndex || endInTable) {
        const sp = skeleton.findNodePositionByCharIndex(start, true, segmentId, segmentPage);
        const ep = skeleton.findNodePositionByCharIndex(end, !endInTable, segmentId, segmentPage);
        const ap = direction === "forward" /* FORWARD */ ? sp : ep;
        const fp = direction === "forward" /* FORWARD */ ? ep : sp;
        if (rectRanges.length && Tools.diffValue(ap, fp)) {
          continue;
        }
        textRanges.push(new TextRange(scene, document2, skeleton, ap, fp, style, segmentId, segmentPage));
      }
    }
  }
  return {
    textRanges,
    rectRanges
  };
}
function getCanvasOffsetByEngine(engine) {
  const canvas = engine == null ? void 0 : engine.getCanvasElement();
  if (!canvas) {
    return {
      left: 0,
      top: 0
    };
  }
  const { top, left } = getOffsetRectForDom(canvas);
  return {
    left,
    top
  };
}
function getParagraphInfoByGlyph(node) {
  var _a;
  const line2 = (_a = node.parent) == null ? void 0 : _a.parent;
  const column = line2 == null ? void 0 : line2.parent;
  if (line2 == null || column == null) {
    return;
  }
  const { paragraphIndex } = line2;
  const lines = column.lines.filter((line3) => line3.paragraphIndex === paragraphIndex);
  let nodeIndex = -1;
  let content = "";
  let hasFound = false;
  for (const line3 of lines) {
    for (const divide of line3.divides) {
      for (const glyph of divide.glyphGroup) {
        if (!hasFound) {
          nodeIndex += glyph.count;
        }
        if (glyph === node) {
          hasFound = true;
        }
        content += glyph.count > 0 ? glyph.content : "";
      }
    }
  }
  return {
    st: lines[0].st,
    ed: paragraphIndex,
    content,
    nodeIndex
  };
}
function serializeTextRange(textRange) {
  const { startOffset, endOffset, collapsed, rangeType, startNodePosition, endNodePosition, direction, segmentId, segmentPage } = textRange;
  const serializedTextRange = {
    startOffset,
    endOffset,
    collapsed,
    rangeType,
    startNodePosition,
    endNodePosition,
    direction,
    segmentId,
    segmentPage,
    isActive: textRange.isActive()
  };
  return serializedTextRange;
}
function serializeRectRange(rectRange) {
  const serializedTextRange = serializeTextRange(rectRange);
  const {
    startRow,
    startColumn,
    endRow,
    endColumn,
    tableId,
    spanEntireRow,
    spanEntireColumn,
    spanEntireTable
  } = rectRange;
  return {
    ...serializedTextRange,
    startRow,
    startColumn,
    endRow,
    endColumn,
    tableId,
    spanEntireRow,
    spanEntireColumn,
    spanEntireTable
  };
}

// ../packages/docs-ui/src/services/selection/doc-selection-render.service.ts
var DocSelectionRenderService = class extends RxDisposable {
  constructor(_context, _layoutService, _logService, _univerInstanceService, _docSkeletonManagerService) {
    super();
    this._context = _context;
    this._layoutService = _layoutService;
    this._logService = _logService;
    this._univerInstanceService = _univerInstanceService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    __publicField(this, "_onInputBefore$", new Subject());
    __publicField(this, "onInputBefore$", this._onInputBefore$.asObservable());
    __publicField(this, "_onKeydown$", new Subject());
    __publicField(this, "onKeydown$", this._onKeydown$.asObservable());
    __publicField(this, "_onInput$", new Subject());
    __publicField(this, "onInput$", this._onInput$.asObservable());
    __publicField(this, "_onCompositionstart$", new BehaviorSubject(null));
    __publicField(this, "onCompositionstart$", this._onCompositionstart$.asObservable());
    __publicField(this, "_onCompositionupdate$", new BehaviorSubject(null));
    __publicField(this, "onCompositionupdate$", this._onCompositionupdate$.asObservable());
    __publicField(this, "_onCompositionend$", new BehaviorSubject(null));
    __publicField(this, "onCompositionend$", this._onCompositionend$.asObservable());
    __publicField(this, "_onSelectionStart$", new BehaviorSubject(null));
    __publicField(this, "onSelectionStart$", this._onSelectionStart$.asObservable());
    __publicField(this, "onChangeByEvent$", merge(
      this._onInput$,
      this._onKeydown$.pipe(filter((e) => e.event.keyCode === 8 /* BACKSPACE */)),
      this._onCompositionend$
    ));
    __publicField(this, "_onPaste$", new Subject());
    __publicField(this, "onPaste$", this._onPaste$.asObservable());
    __publicField(this, "_textSelectionInner$", new BehaviorSubject(null));
    __publicField(this, "textSelectionInner$", this._textSelectionInner$.asObservable());
    __publicField(this, "_onFocus$", new Subject());
    __publicField(this, "onFocus$", this._onFocus$.asObservable());
    __publicField(this, "_onBlur$", new Subject());
    __publicField(this, "onBlur$", this._onBlur$.asObservable());
    __publicField(this, "_onPointerDown$", new Subject());
    __publicField(this, "onPointerDown$", this._onPointerDown$.asObservable());
    __publicField(this, "_container");
    __publicField(this, "_inputParent");
    __publicField(this, "_input");
    __publicField(this, "_scrollTimers", []);
    __publicField(this, "_rangeList", []);
    // Use to cache range list in moving.
    __publicField(this, "_rangeListCache", []);
    // Rect range list.
    __publicField(this, "_rectRangeList", []);
    // Use to cache rect range list in moving.
    __publicField(this, "_rectRangeListCache", []);
    __publicField(this, "_anchorNodePosition", null);
    __publicField(this, "_focusNodePosition", null);
    __publicField(this, "_currentSegmentId", "");
    __publicField(this, "_currentSegmentPage", -1);
    __publicField(this, "_selectionStyle", NORMAL_TEXT_SELECTION_PLUGIN_STYLE);
    __publicField(this, "_onPointerEvent", false);
    __publicField(this, "_viewPortObserverMap", /* @__PURE__ */ new Map());
    __publicField(this, "_isIMEInputApply", false);
    __publicField(this, "_scenePointerMoveSubs", []);
    __publicField(this, "_scenePointerUpSubs", []);
    // When the user switches editors, whether to clear the doc ranges.
    __publicField(this, "_reserveRanges", false);
    this._initDOM();
    this._registerContainer();
    this._setSystemHighlightColorToStyle();
    this._listenCurrentUnitChange();
  }
  get isOnPointerEvent() {
    return this._onPointerEvent;
  }
  get isFocusing() {
    return this._input === document.activeElement;
  }
  get canFocusing() {
    return this.isFocusing || document.activeElement === document.body || document.activeElement === null;
  }
  _listenCurrentUnitChange() {
    this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_DOC).pipe(takeUntil(this.dispose$)).subscribe((documentModel) => {
      if (documentModel == null) {
        return;
      }
      const unitId = documentModel.getUnitId();
      if (unitId !== this._context.unitId && !this._reserveRanges) {
        this.removeAllRanges();
      }
    });
  }
  get activeViewPort() {
    return this._context.scene.getViewports()[0];
  }
  setSegment(id) {
    this._currentSegmentId = id;
  }
  getSegment() {
    return this._currentSegmentId;
  }
  setSegmentPage(pageIndex) {
    this._currentSegmentPage = pageIndex;
  }
  getSegmentPage() {
    return this._currentSegmentPage;
  }
  setReserveRangesStatus(status) {
    this._reserveRanges = status;
  }
  _setRangeStyle(style = NORMAL_TEXT_SELECTION_PLUGIN_STYLE) {
    this._selectionStyle = style;
  }
  // eslint-disable-next-line max-lines-per-function
  addDocRanges(ranges, isEditing = true, options) {
    const {
      _currentSegmentId: segmentId,
      _currentSegmentPage: segmentPage,
      _selectionStyle: style
    } = this;
    const { scene, mainComponent } = this._context;
    const document2 = mainComponent;
    const docSkeleton = this._docSkeletonManagerService.getSkeleton();
    const generalAddRange = (startOffset, endOffset) => {
      const rangeList = getRangeListFromCharIndex(
        startOffset,
        endOffset,
        scene,
        document2,
        docSkeleton,
        style,
        segmentId,
        segmentPage
      );
      if (rangeList == null) {
        return;
      }
      const { textRanges, rectRanges } = rangeList;
      for (const textRange of textRanges) {
        this._addTextRange(textRange);
      }
      this._addRectRanges(rectRanges);
    };
    for (const range of ranges) {
      const { startOffset, endOffset, rangeType, startNodePosition, endNodePosition } = range;
      if (rangeType === "RECT" /* RECT */) {
        const rectRange = getRectRangeFromCharIndex(
          startOffset,
          endOffset,
          scene,
          document2,
          docSkeleton,
          style,
          segmentId,
          segmentPage
        );
        if (rectRange) {
          this._addRectRanges([rectRange]);
        }
      } else if (rangeType === "TEXT" /* TEXT */) {
        try {
          let textRange = null;
          if (startNodePosition && endNodePosition) {
            textRange = getTextRangeFromCharIndex(
              startNodePosition.isBack ? startOffset : startOffset - 1,
              endNodePosition.isBack ? endOffset : endOffset - 1,
              scene,
              document2,
              docSkeleton,
              style,
              segmentId,
              segmentPage,
              startNodePosition.isBack,
              endNodePosition.isBack
            );
          } else {
            textRange = getTextRangeFromCharIndex(
              startOffset,
              endOffset,
              scene,
              document2,
              docSkeleton,
              style,
              segmentId,
              segmentPage
            );
          }
          if (textRange) {
            this._addTextRange(textRange);
          }
        } catch (_e) {
          generalAddRange(startOffset, endOffset);
        }
      } else {
        generalAddRange(startOffset, endOffset);
      }
    }
    this._textSelectionInner$.next({
      textRanges: this._getAllTextRanges(),
      rectRanges: this._getAllRectRanges(),
      segmentId,
      segmentPage,
      style,
      isEditing,
      options
    });
    if (!ranges.length || (options == null ? void 0 : options.shouldFocus) === false) return;
    this._updateInputPosition(options == null ? void 0 : options.forceFocus);
  }
  setCursorManually(evtOffsetX, evtOffsetY) {
    const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY, {
      strict: true,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    });
    const position = this._getNodePosition(startNode);
    if (position == null) {
      this._removeAllRanges();
      return;
    }
    if ((startNode == null ? void 0 : startNode.node.streamType) === "\r" /* PARAGRAPH */) {
      position.isBack = true;
    }
    this._createTextRangeByAnchorPosition(position);
    this._textSelectionInner$.next({
      textRanges: this._getAllTextRanges(),
      rectRanges: this._getAllRectRanges(),
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage,
      style: this._selectionStyle,
      isEditing: false
    });
  }
  // Sync canvas selection to dom selection.
  sync() {
    this._updateInputPosition();
  }
  /**
   * @deprecated
   */
  activate(x, y, force = false) {
    this._container.style.left = `${x}px`;
    this._container.style.top = `${y}px`;
    this._container.style.zIndex = "1000";
    if (this.canFocusing || force) {
      this.focus();
    }
  }
  hasFocus() {
    return document.activeElement === this._input;
  }
  focus() {
    this._input.focus();
  }
  blur() {
    this._input.blur();
  }
  // FIXME: for editor cell editor we don't need to blur the input element
  /**
   * @deprecated
   */
  deactivate() {
    this._container.style.left = "0px";
    this._container.style.top = "0px";
  }
  // Handler double click.
  __handleDblClick(evt) {
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY, {
      strict: false,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    });
    if (startNode == null || startNode.node == null) {
      return;
    }
    const paragraphInfo = getParagraphInfoByGlyph(startNode.node);
    if (paragraphInfo == null) {
      return;
    }
    const { content, st, nodeIndex } = paragraphInfo;
    if (nodeIndex === -1) {
      return;
    }
    if (Intl.Segmenter == null) {
      return;
    }
    const segmenter = new Intl.Segmenter(void 0, { granularity: "word" });
    const segments = segmenter.segment(content);
    let startOffset = Number.NEGATIVE_INFINITY;
    let endOffset = Number.NEGATIVE_INFINITY;
    for (const { segment, index, isWordLike } of segments) {
      if (index <= nodeIndex && nodeIndex < index + segment.length && isWordLike) {
        startOffset = index + st;
        endOffset = index + st + segment.length;
        break;
      }
    }
    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {
      this.removeAllRanges();
      const textRanges = [
        {
          startOffset,
          endOffset
        }
      ];
      this.addDocRanges(textRanges, false, { forceFocus: true });
    }
  }
  __handleTripleClick(evt) {
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY, {
      strict: false,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    });
    if (startNode == null || startNode.node == null) {
      return;
    }
    const paragraphInfo = getParagraphInfoByGlyph(startNode.node);
    if (paragraphInfo == null) {
      return;
    }
    this.removeAllRanges();
    const { st, ed } = paragraphInfo;
    const textRanges = [
      {
        startOffset: st,
        endOffset: ed
      }
    ];
    this.addDocRanges(textRanges, false, { forceFocus: true });
  }
  // Handle pointer down.
  // eslint-disable-next-line max-lines-per-function, complexity
  __onPointDown(evt) {
    var _a, _b;
    const { scene, mainComponent } = this._context;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY, {
      strict: false,
      segmentId: this._currentSegmentId,
      segmentPage: this._currentSegmentPage
    });
    const position = this._getNodePosition(startNode);
    if (position == null || startNode == null) {
      this._removeAllRanges();
      return;
    }
    if ((startNode == null ? void 0 : startNode.node.streamType) === "\r" /* PARAGRAPH */) {
      position.isBack = true;
    }
    const docSelection = this._textSelectionInner$.value;
    if (startNode && evt.button === 2 && docSelection) {
      const nodeCharIndex = skeleton.findCharIndexByPosition(position);
      if (typeof nodeCharIndex === "number" && docSelection.textRanges.some((textRange) => textRange.startOffset <= nodeCharIndex && textRange.endOffset > nodeCharIndex)) {
        return;
      }
      if (typeof nodeCharIndex === "number" && docSelection.rectRanges.some((rectRange) => rectRange.startOffset <= nodeCharIndex && rectRange.endOffset >= nodeCharIndex)) {
        return;
      }
    }
    const { segmentId, segmentPage } = startNode;
    if (segmentId && this._currentSegmentId && segmentId !== this._currentSegmentId) {
      this.setSegment(segmentId);
    }
    if (segmentId && segmentPage !== this._currentSegmentPage) {
      this.setSegmentPage(segmentPage);
    }
    this._anchorNodePosition = position;
    if (evt.shiftKey && this._getActiveRangeInstance()) {
      this._updateActiveRangePosition(position);
    } else if (evt.ctrlKey) {
      this._removeAllCollapsedTextRanges();
    } else if (!this._isEmpty()) {
      this._removeAllRanges();
    }
    scene.disableObjectsEvent();
    const scrollTimer = ScrollTimer.create(scene);
    this._scrollTimers.push(scrollTimer);
    scrollTimer.startScroll(evtOffsetX, evtOffsetY);
    this._onSelectionStart$.next((_a = this._getActiveRangeInstance()) == null ? void 0 : _a.startNodePosition);
    (_b = scene.getTransformer()) == null ? void 0 : _b.clearSelectedObjects();
    let preMoveOffsetX = evtOffsetX;
    let preMoveOffsetY = evtOffsetY;
    this._onPointerEvent = true;
    this._scenePointerMoveSubs.push(scene.onPointerMove$.subscribeEvent((moveEvt) => {
      const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
      scene.setCursor("text" /* TEXT */);
      if (Math.sqrt((moveOffsetX - preMoveOffsetX) ** 2 + (moveOffsetY - preMoveOffsetY) ** 2) < 3) {
        return;
      }
      this._moving(moveOffsetX, moveOffsetY);
      scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
        this._moving(moveOffsetX, moveOffsetY);
      });
      preMoveOffsetX = moveOffsetX;
      preMoveOffsetY = moveOffsetY;
    }));
    this._scenePointerUpSubs.push(scene.onPointerUp$.subscribeEvent(() => {
      [...this._scenePointerMoveSubs, ...this._scenePointerUpSubs].forEach((e) => {
        e.unsubscribe();
      });
      this._onPointerEvent = false;
      scene.enableObjectsEvent();
      if (this._anchorNodePosition && !this._focusNodePosition) {
        if (evt.ctrlKey) {
          this._disposeScrollTimers();
          return;
        }
        const textRange = new TextRange(scene, mainComponent, skeleton, this._anchorNodePosition, void 0, this._selectionStyle, this._currentSegmentId, this._currentSegmentPage);
        this._addTextRange(textRange);
      } else if (this._anchorNodePosition && this._focusNodePosition) {
        for (const textRange of this._rangeListCache) {
          if (evt.ctrlKey) {
            if (textRange.collapsed) {
              textRange.dispose();
            } else {
              this._addTextRange(textRange);
            }
          } else {
            this._addTextRange(textRange);
          }
        }
        this._addRectRanges(this._rectRangeListCache);
        this._rangeListCache = [];
        this._rectRangeListCache = [];
      }
      this._anchorNodePosition = null;
      this._focusNodePosition = null;
      const selectionInfo = {
        textRanges: this._getAllTextRanges(),
        rectRanges: this._getAllRectRanges(),
        segmentId: this._currentSegmentId,
        segmentPage: this._currentSegmentPage,
        style: this._selectionStyle,
        isEditing: false
      };
      this._textSelectionInner$.next(selectionInfo);
      this._disposeScrollTimers();
      this._updateInputPosition(true);
    }));
  }
  removeAllRanges() {
    this._removeAllRanges();
    this.deactivate();
  }
  getActiveTextRange() {
    return this._getActiveRangeInstance();
  }
  _disposeScrollTimers() {
    this._scrollTimers.forEach((timer) => {
      timer == null ? void 0 : timer.dispose();
    });
    this._scrollTimers = [];
  }
  _setSystemHighlightColorToStyle() {
    const { r, g, b, a } = getSystemHighlightColor();
    const style = {
      strokeWidth: 1.5,
      stroke: "rgba(0, 0, 0, 0)",
      strokeActive: "rgba(0, 0, 0, 1)",
      fill: `rgba(${r}, ${g}, ${b}, ${a != null ? a : 0.3})`
    };
    this._setRangeStyle(style);
  }
  _getAllTextRanges() {
    return this._rangeList.map(serializeTextRange);
  }
  _getAllRectRanges() {
    return this._rectRangeList.map(serializeRectRange);
  }
  getAllTextRanges() {
    return this._getAllTextRanges();
  }
  getAllRectRanges() {
    return this._getAllRectRanges();
  }
  _getActiveRange() {
    const activeRange = this._rangeList.find((range) => range.isActive());
    if (activeRange == null) {
      return null;
    }
    const { startOffset, endOffset } = activeRange;
    if (startOffset == null || endOffset == null) {
      return null;
    }
    return serializeTextRange(activeRange);
  }
  _getActiveRangeInstance() {
    return this._rangeList.find((range) => range.isActive());
  }
  dispose() {
    super.dispose();
    this._detachEvent();
    this._removeAllRanges();
    this._container.remove();
  }
  _initDOM() {
    const { unitId } = this._context;
    const container = document.createElement("div");
    container.style.position = "fixed";
    container.style.left = "0px";
    container.style.top = "0px";
    container.id = `univer-doc-selection-container-${unitId}`;
    const inputParent = document.createElement("div");
    const inputDom = document.createElement("div");
    inputParent.appendChild(inputDom);
    container.appendChild(inputParent);
    this._container = container;
    this._inputParent = inputParent;
    this._input = inputDom;
    this._initInput();
    this._initInputEvents();
    document.body.appendChild(container);
  }
  _registerContainer() {
    this.disposeWithMe(
      // the content editable div should be regarded as part of the applications container
      this._layoutService.registerContainerElement(this._container)
    );
  }
  _initInput() {
    this._inputParent.style.cssText = `
            position:absolute;
            height:1px;
            width:1px;
            overflow: hidden;
        `;
    this._input.contentEditable = "true";
    this._input.classList.add("univer-editor");
    this._input.id = `__editor_${this._context.unitId}`;
    this._input.style.cssText = `
            position: absolute;
            overflow: hidden;
            opacity: 1;
            background: #000;
            color: transparent;
            outline: none;
            z-index: -2;
            caret-color: transparent;
            white-space: pre-wrap;
            user-select: text;
        `;
  }
  _getNodePosition(node) {
    if (node == null) {
      return;
    }
    const { node: glyph, ratioX, segmentPage } = node;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    const position = skeleton.findPositionByGlyph(glyph, segmentPage);
    if (position == null) {
      return;
    }
    const HALF = 0.5;
    let isBack = ratioX < HALF;
    if (glyph.glyphType === 2 /* LIST */) {
      isBack = true;
    }
    return {
      ...position,
      isBack
    };
  }
  _interactTextRanges(textRanges) {
    const newTextRanges = [];
    for (const range of this._rangeList) {
      if (textRanges.some((textRange) => textRange.isIntersection(range))) {
        range.dispose();
        continue;
      }
      newTextRanges.push(range);
    }
    this._rangeList = newTextRanges;
  }
  _interactRectRanges(rectRanges) {
    const newRanges = [];
    for (const range of this._rectRangeList) {
      if (rectRanges.some((rectRange) => rectRange.isIntersection(range))) {
        range.dispose();
        continue;
      }
      newRanges.push(range);
    }
    this._rectRangeList = newRanges;
  }
  _removeAllRanges() {
    this._removeAllTextRanges();
    this._removeAllRectRanges();
  }
  _removeAllCacheRanges() {
    this._rangeListCache.forEach((range) => {
      range.dispose();
    });
    this._rectRangeListCache.forEach((range) => {
      range.dispose();
    });
    this._rangeListCache = [];
    this._rectRangeListCache = [];
  }
  _removeAllTextRanges() {
    this._rangeList.forEach((range) => {
      range.dispose();
    });
    this._rangeList = [];
  }
  _removeAllRectRanges() {
    this._rectRangeList.forEach((range) => {
      range.dispose();
    });
    this._rectRangeList = [];
  }
  _removeAllCollapsedTextRanges() {
    for (const range of this._rangeList) {
      if (range.collapsed) {
        range.dispose();
      }
    }
  }
  _deactivateAllTextRanges() {
    this._rangeList.forEach((range) => {
      range.deactivate();
    });
  }
  _deactivateAllRectRanges() {
    this._rectRangeList.forEach((range) => {
      range.deactivate();
    });
  }
  _addTextRangesToCache(textRanges) {
    this._rangeListCache.push(...textRanges);
  }
  _addTextRange(textRange) {
    this._deactivateAllTextRanges();
    textRange.activate();
    this._rangeList.push(textRange);
  }
  _addRectRangesToCache(rectRanges) {
    this._rectRangeListCache.push(...rectRanges);
  }
  _addRectRanges(rectRanges) {
    if (rectRanges.length === 0) {
      return;
    }
    this._deactivateAllRectRanges();
    rectRanges[rectRanges.length - 1].activate();
    this._rectRangeList.push(...rectRanges);
  }
  _createTextRangeByAnchorPosition(position) {
    this._removeAllRanges();
    const { scene, mainComponent } = this._context;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    const lastRange = new TextRange(scene, mainComponent, skeleton, position, void 0, this._selectionStyle, this._currentSegmentId, this._currentSegmentPage);
    this._addTextRange(lastRange);
  }
  _updateActiveRangePosition(position) {
    const activeTextRange = this._getActiveRangeInstance();
    if (activeTextRange == null || activeTextRange.anchorNodePosition == null) {
      this._logService.error(
        "[DocSelectionRenderService] _updateActiveRangeFocusPosition: active range has no anchor"
      );
      return;
    }
    this._removeAllRanges();
    this._anchorNodePosition = activeTextRange.anchorNodePosition;
    this._focusNodePosition = position;
    const { scene, mainComponent } = this._context;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    const { _anchorNodePosition, _focusNodePosition, _selectionStyle, _currentSegmentId, _currentSegmentPage } = this;
    if (_anchorNodePosition == null || _focusNodePosition == null || mainComponent == null) {
      return;
    }
    const ranges = getRangeListFromSelection(
      _anchorNodePosition,
      _focusNodePosition,
      scene,
      mainComponent,
      skeleton,
      _selectionStyle,
      _currentSegmentId,
      _currentSegmentPage
    );
    if (ranges == null) {
      return;
    }
    const { textRanges, rectRanges } = ranges;
    this._addTextRangesToCache(textRanges);
    this._addRectRangesToCache(rectRanges);
    this.deactivate();
  }
  _isEmpty() {
    return this._rangeList.length === 0 && this._rectRangeList.length === 0;
  }
  _getCanvasOffset() {
    var _a;
    const engine = (_a = this._context.scene) == null ? void 0 : _a.getEngine();
    return getCanvasOffsetByEngine(engine);
  }
  _updateInputPosition(forceFocus = false) {
    const activeRangeInstance = this._getActiveRangeInstance();
    const anchor = activeRangeInstance == null ? void 0 : activeRangeInstance.getAnchor();
    if (!anchor || anchor && !anchor.visible || this.activeViewPort == null) {
      this.focus();
      return;
    }
    const { left, top } = anchor;
    const absoluteCoord = this.activeViewPort.getAbsoluteVector(Vector2.FromArray([left, top]));
    const { x, y } = absoluteCoord;
    let { left: canvasLeft, top: canvasTop } = this._getCanvasOffset();
    canvasLeft += x;
    canvasTop += y;
    this.activate(canvasLeft, canvasTop, forceFocus);
  }
  _moving(moveOffsetX, moveOffsetY) {
    var _a, _b;
    const { _currentSegmentId: segmentId, _currentSegmentPage: segmentPage } = this;
    const focusNode = this._findNodeByCoord(moveOffsetX, moveOffsetY, {
      strict: true,
      segmentId,
      segmentPage
    });
    const focusNodePosition = this._getNodePosition(focusNode);
    if (focusNodePosition == null || focusNode == null) {
      return;
    }
    const divide = focusNode == null ? void 0 : focusNode.node.parent;
    const nextGlyph = divide == null ? void 0 : divide.glyphGroup[divide.glyphGroup.indexOf(focusNode.node) + 1];
    if ((focusNode == null ? void 0 : focusNode.node.streamType) === "\r" /* PARAGRAPH */ && (nextGlyph == null ? void 0 : nextGlyph.streamType) === "\n" /* SECTION_BREAK */) {
      focusNodePosition.isBack = true;
    }
    this._focusNodePosition = focusNodePosition;
    this._removeAllCacheRanges();
    const { _anchorNodePosition, _selectionStyle } = this;
    const { scene, mainComponent } = this._context;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    if (_anchorNodePosition == null || mainComponent == null) {
      return;
    }
    const ranges = getRangeListFromSelection(
      _anchorNodePosition,
      focusNodePosition,
      scene,
      mainComponent,
      skeleton,
      _selectionStyle,
      segmentId,
      segmentPage
    );
    if (ranges == null) {
      return;
    }
    const { textRanges, rectRanges } = ranges;
    if (this._rangeList.length > 0 && textRanges.length > 0) {
      this._interactTextRanges(textRanges);
    }
    if (this._rectRangeList.length > 0 && rectRanges.length > 0) {
      this._interactRectRanges(rectRanges);
    }
    this._addTextRangesToCache(textRanges);
    this._addRectRangesToCache(rectRanges);
    this.deactivate();
    (_b = (_a = this._context.scene) == null ? void 0 : _a.getEngine()) == null ? void 0 : _b.setCapture();
  }
  __attachScrollEvent() {
    const viewport = this.activeViewPort;
    if (!viewport) {
      return;
    }
    const { unitId } = this._context;
    if (this._viewPortObserverMap.has(unitId)) {
      return;
    }
    const scrollBefore = viewport.onScrollAfter$.subscribeEvent((param) => {
      const viewport2 = param.viewport;
      if (!viewport2) {
        return;
      }
      const activeRangeInstance = this._getActiveRangeInstance();
      activeRangeInstance == null ? void 0 : activeRangeInstance.activeStatic();
    });
    const scrollStop = viewport.onScrollEnd$.subscribeEvent((param) => {
      const viewport2 = param.viewport;
      if (!viewport2) {
        return;
      }
      const bounds = viewport2.getBounding();
      const activeRangeInstance = this._getActiveRangeInstance();
      const anchor = activeRangeInstance == null ? void 0 : activeRangeInstance.getAnchor();
      if (!anchor || anchor && !anchor.visible) {
        return;
      }
      if (bounds) {
        const { left, top, right, bottom } = bounds.viewBound;
        if (anchor.left < left || anchor.left > right || anchor.top < top || anchor.top > bottom) {
          activeRangeInstance == null ? void 0 : activeRangeInstance.deactivateStatic();
          return;
        }
      }
      this._updateInputPosition();
    });
    this._viewPortObserverMap.set(unitId, {
      scrollBefore,
      scrollStop
    });
  }
  // FIXME: listeners here are not correctly disposed
  // eslint-disable-next-line max-lines-per-function
  _initInputEvents() {
    this.disposeWithMe(
      fromEvent(this._input, "keydown").subscribe((e) => {
        if (this._isIMEInputApply) {
          return;
        }
        this._eventHandle(e, (config) => {
          this._onKeydown$.next(config);
        });
      })
    );
    this.disposeWithMe(
      fromEvent(this._input, "input").subscribe((e) => {
        if (e.inputType === "historyUndo" || e.inputType === "historyRedo") {
          return;
        }
        if (this._rectRangeList.length > 0) {
          e.stopPropagation();
          return e.preventDefault();
        }
        if (this._isIMEInputApply) {
          return;
        }
        this._eventHandle(e, (config) => {
          this._onInputBefore$.next(config);
          this._onInput$.next(config);
        });
      })
    );
    this.disposeWithMe(
      fromEvent(this._input, "compositionstart").subscribe((e) => {
        if (this._rectRangeList.length > 0) {
          e.stopPropagation();
          return e.preventDefault();
        }
        this._isIMEInputApply = true;
        this._eventHandle(e, (config) => {
          this._onCompositionstart$.next(config);
        });
      })
    );
    this.disposeWithMe(
      fromEvent(this._input, "compositionend").subscribe((e) => {
        this._isIMEInputApply = false;
        this._eventHandle(e, (config) => {
          this._onCompositionend$.next(config);
        });
      })
    );
    this.disposeWithMe(
      fromEvent(this._input, "compositionupdate").subscribe((e) => {
        this._eventHandle(e, (config) => {
          this._onInputBefore$.next(config);
          this._onCompositionupdate$.next(config);
        });
      })
    );
    this.disposeWithMe(
      fromEvent(this._input, "paste").subscribe((e) => {
        this._eventHandle(e, (config) => {
          this._onPaste$.next(config);
        });
      })
    );
    this.disposeWithMe(
      fromEvent(this._input, "focus").subscribe((e) => {
        this._eventHandle(e, (config) => {
          this._onFocus$.next(config);
        });
      })
    );
    this.disposeWithMe(
      fromEvent(this._input, "blur").subscribe((e) => {
        this._eventHandle(e, (config) => {
          this._onBlur$.next(config);
        });
      })
    );
  }
  _eventHandle(e, func) {
    const content = this._input.textContent || "";
    this._input.innerHTML = "";
    const activeRange = this._getActiveRange();
    const rangeList = this._getAllTextRanges();
    func({
      event: e,
      content,
      activeRange,
      rangeList
    });
  }
  _getTransformCoordForDocumentOffset(evtOffsetX, evtOffsetY) {
    const document2 = this._context.mainComponent;
    const { documentTransform } = document2.getOffsetConfig();
    if (this.activeViewPort == null || documentTransform == null) {
      return;
    }
    const originCoord = this.activeViewPort.transformVector2SceneCoord(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    if (!originCoord) {
      return;
    }
    return documentTransform.clone().invert().applyPoint(originCoord);
  }
  _findNodeByCoord(evtOffsetX, evtOffsetY, restrictions) {
    const coord = this._getTransformCoordForDocumentOffset(evtOffsetX, evtOffsetY);
    if (coord == null) {
      return;
    }
    const document2 = this._context.mainComponent;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    const {
      pageLayoutType = 0 /* VERTICAL */,
      pageMarginLeft,
      pageMarginTop
    } = document2.getOffsetConfig();
    const nodeInfo = skeleton.findNodeByCoord(
      coord,
      pageLayoutType,
      pageMarginLeft,
      pageMarginTop,
      restrictions
    );
    return nodeInfo;
  }
  _detachEvent() {
    this._onInputBefore$.complete();
    this._onKeydown$.complete();
    this._onInput$.complete();
    this._onCompositionstart$.complete();
    this._onCompositionupdate$.complete();
    this._onCompositionend$.complete();
    this._onSelectionStart$.complete();
    this._textSelectionInner$.complete();
    this._onPaste$.complete();
    this._onFocus$.complete();
    this._onBlur$.complete();
    this._onPointerDown$.complete();
  }
};
DocSelectionRenderService = __decorateClass([
  __decorateParam(1, ILayoutService),
  __decorateParam(2, ILogService),
  __decorateParam(3, IUniverInstanceService),
  __decorateParam(4, Inject(DocSkeletonManagerService))
], DocSelectionRenderService);

// ../packages/docs-ui/src/services/editor/editor.ts
var Editor = class extends Disposable {
  constructor(_param, _univerInstanceService, _docSelectionManagerService, _commandService, _undoRedoService) {
    super();
    this._param = _param;
    this._univerInstanceService = _univerInstanceService;
    this._docSelectionManagerService = _docSelectionManagerService;
    this._commandService = _commandService;
    this._undoRedoService = _undoRedoService;
    // Emit change event when editor lose focus.
    __publicField(this, "_change$", new Subject());
    __publicField(this, "change$", this._change$.asObservable());
    // The input event fires when the value of a editor has been changed as a direct result of a user action.
    __publicField(this, "_input$", new Subject());
    __publicField(this, "input$", this._input$.asObservable());
    // paste event.
    __publicField(this, "_paste$", new Subject());
    __publicField(this, "paste$", this._paste$.asObservable());
    // Editor get focus.
    __publicField(this, "_focus$", new Subject());
    __publicField(this, "focus$", this._focus$.asObservable());
    // Editor lose focus.
    __publicField(this, "_blur$", new Subject());
    __publicField(this, "blur$", this._blur$.asObservable());
    // Emit when doc selection changed.
    __publicField(this, "_selectionChange$", new Subject());
    __publicField(this, "selectionChange$", this._selectionChange$.asObservable());
    this._listenSelection();
  }
  get docSelectionRenderService() {
    return this._param.render.with(DocSelectionRenderService);
  }
  _listenSelection() {
    const docSelectionRenderService = this._param.render.with(DocSelectionRenderService);
    this.disposeWithMe(
      docSelectionRenderService.onBlur$.subscribe((e) => {
        this._blur$.next(e);
        const data2 = this.getDocumentData();
        this._change$.next({
          target: this,
          data: data2
        });
      })
    );
    this.disposeWithMe(
      docSelectionRenderService.onFocus$.subscribe((e) => {
        this._focus$.next(e);
      })
    );
    this.disposeWithMe(
      docSelectionRenderService.onPaste$.subscribe((e) => {
        this._paste$.next(e);
      })
    );
    this.disposeWithMe(
      merge(
        docSelectionRenderService.onInput$,
        docSelectionRenderService.onKeydown$.pipe(filter((e) => {
          const event = e.event;
          if (event.ctrlKey || event.metaKey) {
            return [88 /* X */, 86 /* V */].includes(event.keyCode);
          }
          return [8 /* BACKSPACE */].includes(event.keyCode);
        })),
        docSelectionRenderService.onCompositionupdate$,
        docSelectionRenderService.onCompositionend$,
        docSelectionRenderService.onPaste$
      ).subscribe((e) => {
        if (e == null) {
          return;
        }
        const { content = "" } = e;
        const data2 = this.getDocumentData();
        this._input$.next({
          target: this,
          content,
          data: data2,
          isComposing: e.event.type === "compositionupdate"
        });
      })
    );
    this.disposeWithMe(
      this._docSelectionManagerService.textSelection$.subscribe((e) => {
        if (e == null) {
          return;
        }
        const { unitId, subUnitId, ...params } = e;
        const editorId = this.getEditorId();
        if (unitId === editorId) {
          this._selectionChange$.next(params);
        }
      })
    );
  }
  isFocus() {
    const docSelectionRenderService = this._param.render.with(DocSelectionRenderService);
    return docSelectionRenderService.isFocusing && Boolean(docSelectionRenderService.getActiveTextRange());
  }
  /**
   * @deprecated use `IEditorService.focus` as instead. this is for internal usage.
   */
  focus() {
    const curDoc = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const editorUnitId = this.getEditorId();
    if (curDoc == null || curDoc.getUnitId() !== editorUnitId) {
      this._univerInstanceService.setCurrentUnitForType(editorUnitId);
    }
    const docSelectionRenderService = this._param.render.with(DocSelectionRenderService);
    docSelectionRenderService.focus();
  }
  /**
   * @deprecated use `IEditorService.blur` as instead. this is for internal usage.
   */
  blur() {
    const docSelectionRenderService = this._param.render.with(DocSelectionRenderService);
    docSelectionRenderService.blur();
  }
  // Selects the entire content of the editor.
  // Calling editor.select() will not necessarily focus the editor, so it is often used with Editor.focus
  select() {
    const documentData = this.getDocumentData();
    return this.setSelectionRanges([{
      startOffset: 0,
      endOffset: documentData.body ? documentData.body.dataStream.length - 2 : 0
    }]);
  }
  // Selects the specified range of characters within editor.
  setSelectionRanges(ranges, shouldFocus = true) {
    const editorUnitId = this.getEditorId();
    const params = {
      unitId: editorUnitId,
      subUnitId: editorUnitId
    };
    return this._docSelectionManagerService.replaceDocRanges(ranges, params, false, { shouldFocus });
  }
  // Get current doc ranges. include text range and rect range.
  getSelectionRanges() {
    const editorUnitId = this.getEditorId();
    const params = {
      unitId: editorUnitId,
      subUnitId: editorUnitId
    };
    return this._docSelectionManagerService.getDocRanges(params);
  }
  getCursorPosition() {
    var _a, _b;
    const selectionRanges = this.getSelectionRanges();
    return (_b = (_a = selectionRanges.find((range) => range.collapsed)) == null ? void 0 : _a.startOffset) != null ? _b : -1;
  }
  // get editor id.
  getEditorId() {
    return this._getEditorId();
  }
  // get document data.
  getDocumentData() {
    const docDataModel = this._getDocDataModel();
    return docDataModel.getSnapshot();
  }
  getDocumentDataModel() {
    return this._getDocDataModel();
  }
  // Set the new document data.
  setDocumentData(data2, textRanges) {
    const { id } = data2;
    this._commandService.syncExecuteCommand(ReplaceSnapshotCommand.id, {
      unitId: id,
      snapshot: data2,
      textRanges
    });
  }
  replaceText(text, resetCursor = true) {
    const data2 = this.getDocumentData();
    this.setDocumentData(
      {
        ...data2,
        body: {
          dataStream: `${text}\r
`,
          paragraphs: [{
            startIndex: 0
          }],
          customRanges: [],
          sectionBreaks: [],
          tables: [],
          textRuns: []
        }
      },
      typeof resetCursor === "object" ? resetCursor : resetCursor ? [{
        startOffset: text.length,
        endOffset: text.length,
        collapsed: true
      }] : null
    );
  }
  // Clear the undo redo history of this editor.
  clearUndoRedoHistory() {
    const editorUnitId = this.getEditorId();
    return this._undoRedoService.clearUndoRedo(editorUnitId);
  }
  dispose() {
    const docDataModel = this._getDocDataModel();
    docDataModel.dispose();
  }
  /**
   * @deprecated use getEditorId.
   */
  get editorUnitId() {
    return this._param.editorUnitId;
  }
  /**
   * @deprecated @TODO: @JOCS remove this in the future.
   */
  get params() {
    return this._param;
  }
  get cancelDefaultResizeListener() {
    return this._param.cancelDefaultResizeListener;
  }
  get render() {
    return this._param.render;
  }
  isReadOnly() {
    return this._param.readonly === true;
  }
  getBoundingClientRect() {
    return this._param.editorDom.getBoundingClientRect();
  }
  get editorDOM() {
    return this._param.editorDom;
  }
  isVisible() {
    return this._param.visible;
  }
  isSheetEditor() {
    return isInternalEditorID(this._getEditorId());
  }
  /**
   * @deprecated use getDocumentData.
   */
  getValue() {
    var _a;
    const docDataModel = this._getDocDataModel();
    const value = ((_a = docDataModel.getBody()) == null ? void 0 : _a.dataStream) || "";
    return value.replace(/\r\n/g, "").replace(/\n/g, "").replace(/\n/g, "");
  }
  /**
   * @deprecated use getDocumentData.
   */
  getBody() {
    const docDataModel = this._getDocDataModel();
    return docDataModel.getBody();
  }
  /**
   * @deprecated.
   */
  update(param) {
    this._param = {
      ...this._param,
      ...param
    };
  }
  /**
   * @deprecated.
   */
  updateCanvasStyle() {
    var _a;
    const docDataModel = this._getDocDataModel();
    if (docDataModel == null) {
      return;
    }
    const documentStyle = {};
    if ((_a = this._param.canvasStyle) == null ? void 0 : _a.fontSize) {
      if (documentStyle.textStyle == null) {
        documentStyle.textStyle = {};
      }
      documentStyle.textStyle.fs = this._param.canvasStyle.fontSize;
    }
    docDataModel.updateDocumentStyle(documentStyle);
  }
  _getDocDataModel() {
    const editorUnitId = this._getEditorId();
    const docDataModel = this._univerInstanceService.getUnit(editorUnitId, O.UNIVER_DOC);
    return docDataModel;
  }
  _getEditorId() {
    var _a;
    return ((_a = this._param.initialSnapshot) == null ? void 0 : _a.id) || this._param.editorUnitId || "";
  }
};

// ../packages/docs-ui/src/services/editor/editor-manager.service.ts
var editorFocusInElements = [
  "univer-editor",
  "univer-range-selector",
  "univer-range-selector-editor",
  "univer-render-canvas",
  "univer-text-editor-container-placeholder"
];
var EditorService = class extends Disposable {
  constructor(_univerInstanceService, _renderManagerService, _docSelectionManagerService, _contextService, _commandService, _undoRedoService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    this._docSelectionManagerService = _docSelectionManagerService;
    this._contextService = _contextService;
    this._commandService = _commandService;
    this._undoRedoService = _undoRedoService;
    __publicField(this, "_editors", /* @__PURE__ */ new Map());
    __publicField(this, "_focusEditorUnitId");
    __publicField(this, "_blur$", new Subject());
    __publicField(this, "blur$", this._blur$.asObservable());
    __publicField(this, "_focus$", new Subject());
    __publicField(this, "focus$", this._focus$.asObservable());
    this._initUniverFocusListener();
  }
  // REFACTOR: @Gggpound The specific business processing should not be placed here,
  // I moved from the layout service. https://github.com/dream-num/univer-pro/issues/1708
  _initUniverFocusListener() {
    this.disposeWithMe(
      fromEvent(window, "focusin").subscribe((event) => {
        const target = event.target;
        this._blurSheetEditor(target);
      })
    );
  }
  _blurSheetEditor(target) {
    if (editorFocusInElements.some((item) => target.classList.contains(item))) {
      return;
    }
    const focusEditor = this.getFocusEditor();
    if (focusEditor && focusEditor.isSheetEditor() !== true) {
      this.blur();
    }
  }
  _setFocusId(id) {
    this._focusEditorUnitId = id;
  }
  getFocusId() {
    return this._focusEditorUnitId;
  }
  getFocusEditor() {
    if (this._focusEditorUnitId) {
      return this.getEditor(this._focusEditorUnitId);
    }
  }
  isEditor(editorUnitId) {
    return this._editors.has(editorUnitId);
  }
  isSheetEditor(editorUnitId) {
    const editor = this._editors.get(editorUnitId);
    return !!(editor && editor.isSheetEditor());
  }
  blur(force) {
    const focusingEditor = this.getFocusEditor();
    if (force) {
      focusingEditor == null ? void 0 : focusingEditor.setSelectionRanges([]);
    }
    focusingEditor == null ? void 0 : focusingEditor.blur();
    this._contextService.setContextValue(EDITOR_ACTIVATED, false);
    this._contextService.setContextValue(FOCUSING_EDITOR_STANDALONE, false);
    this._setFocusId(null);
    this._blur$.next(null);
  }
  focus(editorUnitId) {
    if (editorUnitId === this._focusEditorUnitId) {
      return;
    }
    if (this._focusEditorUnitId) {
      this.blur();
    }
    if (editorUnitId == null) {
      return;
    }
    const editor = this.getEditor(editorUnitId);
    if (editor == null) {
      return;
    }
    this._univerInstanceService.setCurrentUnitForType(editorUnitId);
    const valueCount = editor.getValue().length;
    this._contextService.setContextValue(EDITOR_ACTIVATED, true);
    if (!isInternalEditorID(editorUnitId)) {
      this._contextService.setContextValue(FOCUSING_EDITOR_STANDALONE, true);
    }
    editor.focus();
    this._setFocusId(editorUnitId);
    this._focus$.next({
      startOffset: valueCount,
      endOffset: valueCount
    });
  }
  dispose() {
    this._editors.clear();
    super.dispose();
  }
  getEditor(id = this._getCurrentEditorUnitId()) {
    return this._editors.get(id);
  }
  getAllEditor() {
    return this._editors;
  }
  register(config, container) {
    var _a, _b, _c, _d;
    const { initialSnapshot, canvasStyle = {} } = config;
    const editorUnitId = initialSnapshot.id;
    const documentDataModel = this._univerInstanceService.getUnit(editorUnitId, O.UNIVER_DOC);
    if (documentDataModel == null) {
      this._univerInstanceService.createUnit(
        O.UNIVER_DOC,
        initialSnapshot || this._getBlank(editorUnitId),
        { makeCurrent: false }
      );
    }
    let render2 = this._renderManagerService.getRenderById(editorUnitId);
    if (render2 == null) {
      this._renderManagerService.create(editorUnitId);
      render2 = this._renderManagerService.getRenderById(editorUnitId);
    }
    if (render2) {
      render2.engine.setContainer(container);
      const editor = new Editor(
        { ...config, render: render2, editorDom: container, canvasStyle },
        this._univerInstanceService,
        this._docSelectionManagerService,
        this._commandService,
        this._undoRedoService
      );
      this._editors.set(editorUnitId, editor);
      if (!config.scrollBar) {
        (_d = (_c = (_b = (_a = render2.mainComponent) == null ? void 0 : _a.getScene()) == null ? void 0 : _b.getViewports()) == null ? void 0 : _c[0].getScrollBar()) == null ? void 0 : _d.dispose();
      }
    }
    return toDisposable(() => {
      this._unRegister(editorUnitId);
    });
  }
  _unRegister(editorUnitId) {
    const editor = this._editors.get(editorUnitId);
    if (editor == null) {
      return;
    }
    this._renderManagerService.removeRender(editorUnitId);
    editor.dispose();
    this._editors.delete(editorUnitId);
    this._univerInstanceService.disposeUnit(editorUnitId);
  }
  _getCurrentEditorUnitId() {
    const current = this._univerInstanceService.getCurrentUniverDocInstance();
    return current.getUnitId();
  }
  _getBlank(id) {
    return {
      id,
      body: {
        dataStream: `${DEFAULT_EMPTY_DOCUMENT_VALUE}`,
        textRuns: [],
        paragraphs: [
          {
            startIndex: 0
          }
        ]
      },
      documentStyle: {
        renderConfig: {
          verticalAlign: 1 /* TOP */,
          horizontalAlign: 1 /* LEFT */
        },
        marginLeft: 3,
        marginTop: 0,
        marginRight: 3
      }
    };
  }
};
EditorService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, Inject(DocSelectionManagerService)),
  __decorateParam(3, IContextService),
  __decorateParam(4, ICommandService),
  __decorateParam(5, IUndoRedoService)
], EditorService);
var IEditorService = createIdentifier("univer.editor.service");

// ../packages/docs-ui/src/views/header-footer/panel/component-name.ts
var COMPONENT_DOC_HEADER_FOOTER_PANEL = "COMPONENT_DOC_HEADER_FOOTER_PANEL";

// ../packages/docs-ui/src/views/header-footer/panel/DocHeaderFooterPanel.tsx
var import_react39 = __toESM(require_react());

// ../packages/docs-ui/src/views/header-footer/panel/DocHeaderFooterOptions.tsx
var import_react38 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/docs-ui/src/views/header-footer/panel/index.module.less
var index_module_default9 = {
  "panel": "univer-panel",
  "optionsSection": "univer-options-section",
  "optionsFormItem": "univer-options-form-item",
  "optionsInput": "univer-options-input",
  "optionsMarginSetting": "univer-options-margin-setting"
};

// ../packages/docs-ui/src/views/header-footer/panel/DocHeaderFooterOptions.tsx
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
function getSegmentId(documentStyle, editArea, pageIndex) {
  const { useFirstPageHeaderFooter, evenAndOddHeaders, defaultHeaderId, defaultFooterId, firstPageHeaderId, firstPageFooterId, evenPageHeaderId, evenPageFooterId } = documentStyle;
  if (editArea === "HEADER" /* HEADER */) {
    if (useFirstPageHeaderFooter === 1 /* TRUE */) {
      if (pageIndex === 0) {
        return firstPageHeaderId;
      } else {
        return evenAndOddHeaders === 1 /* TRUE */ && pageIndex % 2 === 1 ? evenPageHeaderId : defaultHeaderId;
      }
    } else {
      return evenAndOddHeaders === 1 /* TRUE */ && pageIndex % 2 === 1 ? evenPageHeaderId : defaultHeaderId;
    }
  } else {
    if (useFirstPageHeaderFooter === 1 /* TRUE */) {
      if (pageIndex === 0) {
        return firstPageFooterId;
      } else {
        return evenAndOddHeaders === 1 /* TRUE */ && pageIndex % 2 === 1 ? evenPageFooterId : defaultFooterId;
      }
    } else {
      return evenAndOddHeaders === 1 /* TRUE */ && pageIndex % 2 === 1 ? evenPageFooterId : defaultFooterId;
    }
  }
}
var DocHeaderFooterOptions = (props) => {
  const localeService = useDependency(LocaleService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const renderManagerService = useDependency(IRenderManagerService);
  const commandService = useDependency(ICommandService);
  const layoutService = useDependency(ILayoutService);
  const { unitId } = props;
  const docSelectionRenderService = renderManagerService.getRenderById(unitId).with(DocSelectionRenderService);
  const [options, setOptions] = (0, import_react38.useState)({});
  const handleCheckboxChange = (val, type2) => {
    var _a;
    setOptions((prev) => ({
      ...prev,
      [type2]: val ? 1 /* TRUE */ : 0 /* FALSE */
    }));
    const docDataModel = univerInstanceService.getUniverDocInstance(unitId);
    const documentStyle = docDataModel == null ? void 0 : docDataModel.getSnapshot().documentStyle;
    const docSkeletonManagerService = (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService);
    const viewModel = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getViewModel();
    if (documentStyle == null || viewModel == null) {
      return;
    }
    const editArea = viewModel.getEditArea();
    let needCreateHeaderFooter = false;
    const segmentPage = docSelectionRenderService.getSegmentPage();
    let needChangeSegmentId = false;
    if (type2 === "useFirstPageHeaderFooter" && val === true) {
      if (editArea === "HEADER" /* HEADER */ && !documentStyle.firstPageHeaderId) {
        needCreateHeaderFooter = true;
      } else if (editArea === "FOOTER" /* FOOTER */ && !documentStyle.firstPageFooterId) {
        needCreateHeaderFooter = true;
      }
      if (needCreateHeaderFooter && segmentPage === 0) {
        needChangeSegmentId = true;
      }
    }
    if (type2 === "evenAndOddHeaders" && val === true) {
      if (editArea === "HEADER" /* HEADER */ && !documentStyle.evenPageHeaderId) {
        needCreateHeaderFooter = true;
      } else if (editArea === "FOOTER" /* FOOTER */ && !documentStyle.evenPageFooterId) {
        needCreateHeaderFooter = true;
      }
      if (needCreateHeaderFooter && segmentPage % 2 === 1) {
        needChangeSegmentId = true;
      }
    }
    if (needCreateHeaderFooter) {
      const SEGMENT_ID_LEN = 6;
      const segmentId = Tools.generateRandomId(SEGMENT_ID_LEN);
      if (needChangeSegmentId) {
        docSelectionRenderService.setSegment(segmentId);
      }
      commandService.executeCommand(CoreHeaderFooterCommandId, {
        unitId,
        segmentId,
        headerFooterProps: {
          [type2]: val ? 1 /* TRUE */ : 0 /* FALSE */
        }
      });
    } else {
      const segmentPageIndex = docSelectionRenderService.getSegmentPage();
      const prevSegmentId = docSelectionRenderService.getSegment();
      const needFocusSegmentId = getSegmentId(
        {
          ...documentStyle,
          [type2]: val ? 1 /* TRUE */ : 0 /* FALSE */
        },
        editArea,
        segmentPageIndex
      );
      if (needFocusSegmentId && needFocusSegmentId !== prevSegmentId) {
        docSelectionRenderService.setSegment(needFocusSegmentId);
      }
      commandService.executeCommand(CoreHeaderFooterCommandId, {
        unitId,
        headerFooterProps: {
          [type2]: val ? 1 /* TRUE */ : 0 /* FALSE */
        }
      });
    }
    layoutService.focus();
  };
  const handleMarginChange = async (val, type2) => {
    setOptions((prev) => ({
      ...prev,
      [type2]: val
    }));
    await commandService.executeCommand(CoreHeaderFooterCommandId, {
      unitId,
      headerFooterProps: {
        [type2]: val
      }
    });
    docSelectionRenderService.removeAllRanges();
    docSelectionRenderService.blur();
  };
  const closeHeaderFooter = () => {
    commandService.executeCommand(CloseHeaderFooterCommand.id, {
      unitId
    });
  };
  (0, import_react38.useEffect)(() => {
    const docDataModel = univerInstanceService.getUniverDocInstance(unitId);
    const documentStyle = docDataModel == null ? void 0 : docDataModel.getSnapshot().documentStyle;
    if (documentStyle) {
      const {
        marginHeader = 0,
        marginFooter = 0,
        useFirstPageHeaderFooter = 0 /* FALSE */,
        evenAndOddHeaders = 0 /* FALSE */
      } = documentStyle;
      setOptions({
        marginHeader,
        marginFooter,
        useFirstPageHeaderFooter,
        evenAndOddHeaders
      });
    }
  }, [unitId]);
  return /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: index_module_default9.options, children: [
    /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: index_module_default9.optionsSection, children: [
      /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: index_module_default9.optionsFormItem, children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
        Checkbox,
        {
          checked: options.useFirstPageHeaderFooter === 1 /* TRUE */,
          onChange: (val) => {
            handleCheckboxChange(val, "useFirstPageHeaderFooter");
          },
          children: localeService.t("headerFooter.firstPageCheckBox")
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: index_module_default9.optionsFormItem, children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
        Checkbox,
        {
          checked: options.evenAndOddHeaders === 1 /* TRUE */,
          onChange: (val) => {
            handleCheckboxChange(val, "evenAndOddHeaders");
          },
          children: localeService.t("headerFooter.oddEvenCheckBox")
        }
      ) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: clsx(index_module_default9.optionsSection, index_module_default9.optionsMarginSetting), children: [
      /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: index_module_default9.optionsMarginItem, children: [
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("span", { children: localeService.t("headerFooter.headerTopMargin") }),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
          InputNumber,
          {
            min: 0,
            max: 200,
            precision: 1,
            value: options.marginHeader,
            onChange: (val) => {
              handleMarginChange(val, "marginHeader");
            },
            className: index_module_default9.optionsInput
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)("div", { className: index_module_default9.optionsMarginItem, children: [
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("span", { children: localeService.t("headerFooter.footerBottomMargin") }),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
          InputNumber,
          {
            min: 0,
            max: 200,
            precision: 1,
            value: options.marginFooter,
            onChange: (val) => {
              handleMarginChange(val, "marginFooter");
            },
            className: index_module_default9.optionsInput
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: index_module_default9.optionsSection, children: /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(Button, { onClick: closeHeaderFooter, children: localeService.t("headerFooter.closeHeaderFooter") }) })
  ] });
};

// ../packages/docs-ui/src/views/header-footer/panel/DocHeaderFooterPanel.tsx
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var DocHeaderFooterPanel = () => {
  var _a;
  const localeService = useDependency(LocaleService);
  const renderManagerService = useDependency(IRenderManagerService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const documentDataModel = univerInstanceService.getCurrentUniverDocInstance();
  const unitId = documentDataModel.getUnitId();
  const docSkeletonManagerService = (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService);
  const viewModel = docSkeletonManagerService.getViewModel();
  const [isEditHeaderFooter, setIsEditHeaderFooter] = (0, import_react39.useState)(true);
  (0, import_react39.useEffect)(() => {
    const editArea = viewModel.getEditArea();
    setIsEditHeaderFooter(editArea !== "BODY" /* BODY */);
    const subscription = viewModel.editAreaChange$.subscribe((editArea2) => {
      if (editArea2 == null) {
        return;
      }
      setIsEditHeaderFooter(editArea2 !== "BODY" /* BODY */);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: index_module_default9.panel, children: isEditHeaderFooter ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(DocHeaderFooterOptions, { unitId }) : /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: index_module_default9.panelDisableText, children: localeService.t("headerFooter.disableText") }) });
};

// ../packages/docs-ui/src/views/header-footer/text-bubble.ts
var COLLAB_CURSOR_LABEL_HEIGHT = 18;
var COLLAB_CURSOR_LABEL_MAX_WIDTH = 200;
var COLLAB_CURSOR_LABEL_TEXT_PADDING_LR = 6;
var COLLAB_CURSOR_LABEL_TEXT_PADDING_TB = 4;
function drawBubble(ctx, props) {
  let { radius, width, height } = props;
  radius = radius != null ? radius : 0;
  width = width != null ? width : 30;
  height = height != null ? height : 30;
  let bottomRight = 0;
  bottomRight = Math.min(radius, width / 2, height / 2);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(width, 0);
  ctx.lineTo(width, height - bottomRight);
  ctx.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
  ctx.lineTo(0, height);
  ctx.lineTo(0, 0);
  ctx.closePath();
  if (props.fill) {
    ctx.save();
    ctx.fillStyle = props.fill;
    if (props.fillRule === "evenodd") {
      ctx.fill("evenodd");
    } else {
      ctx.fill();
    }
    ctx.restore();
  }
}
var TextBubbleShape = class _TextBubbleShape extends Shape {
  constructor(key, props) {
    super(key, props);
    __publicField(this, "color");
    __publicField(this, "text");
    this.color = props == null ? void 0 : props.color;
    this.text = props == null ? void 0 : props.text;
  }
  static drawWith(ctx, props) {
    const { text, color } = props;
    ctx.save();
    ctx.font = "13px Source Han Sans CN";
    const textWidth = ctx.measureText(text).width;
    const realInfoWidth = Math.min(
      textWidth + 2 * COLLAB_CURSOR_LABEL_TEXT_PADDING_LR,
      COLLAB_CURSOR_LABEL_MAX_WIDTH
    );
    drawBubble(ctx, {
      height: COLLAB_CURSOR_LABEL_HEIGHT,
      width: realInfoWidth,
      radius: 4,
      fill: color,
      evented: false
    });
    ctx.fillStyle = "rgba(58, 96, 247, 1)";
    const offsetX = COLLAB_CURSOR_LABEL_TEXT_PADDING_LR;
    const offsetY = COLLAB_CURSOR_LABEL_HEIGHT - COLLAB_CURSOR_LABEL_TEXT_PADDING_TB;
    const maxTextWidth = COLLAB_CURSOR_LABEL_MAX_WIDTH - 2 * COLLAB_CURSOR_LABEL_TEXT_PADDING_LR;
    if (textWidth > maxTextWidth) {
      let truncatedText = "";
      let currentWidth = 0;
      for (const element of text) {
        const charWidth = ctx.measureText(element).width;
        if (currentWidth + charWidth <= maxTextWidth - ctx.measureText("...").width) {
          truncatedText += element;
          currentWidth += charWidth;
        } else {
          truncatedText += "...";
          break;
        }
      }
      ctx.fillText(truncatedText, offsetX, offsetY);
    } else {
      ctx.fillText(text, offsetX, offsetY);
    }
    ctx.restore();
  }
  _draw(ctx) {
    _TextBubbleShape.drawWith(ctx, this);
  }
};

// ../packages/docs-ui/src/controllers/doc-header-footer.controller.ts
var HEADER_FOOTER_STROKE_COLOR = "rgba(58, 96, 247, 1)";
var HEADER_FOOTER_FILL_COLOR = "rgba(58, 96, 247, 0.08)";
function checkCreateHeaderFooterType(viewModel, editArea, segmentPage) {
  const { documentStyle } = viewModel.getDataModel().getSnapshot();
  const {
    defaultHeaderId,
    defaultFooterId,
    evenPageHeaderId,
    evenPageFooterId,
    firstPageHeaderId,
    firstPageFooterId,
    evenAndOddHeaders,
    useFirstPageHeaderFooter
  } = documentStyle;
  switch (editArea) {
    case "BODY" /* BODY */:
      return {
        createType: null,
        headerFooterId: null
      };
    case "HEADER" /* HEADER */: {
      if (useFirstPageHeaderFooter === 1 /* TRUE */ && !firstPageHeaderId) {
        return {
          createType: 0 /* FIRST_PAGE_HEADER */,
          headerFooterId: null
        };
      }
      if (evenAndOddHeaders === 1 /* TRUE */ && segmentPage % 2 === 0 && !evenPageHeaderId) {
        return {
          createType: 4 /* EVEN_PAGE_HEADER */,
          headerFooterId: null
        };
      }
      return defaultHeaderId ? {
        createType: null,
        headerFooterId: defaultHeaderId
      } : {
        createType: 2 /* DEFAULT_HEADER */,
        headerFooterId: null
      };
    }
    case "FOOTER" /* FOOTER */: {
      if (useFirstPageHeaderFooter === 1 /* TRUE */ && !firstPageFooterId) {
        return {
          createType: 1 /* FIRST_PAGE_FOOTER */,
          headerFooterId: null
        };
      }
      if (evenAndOddHeaders === 1 /* TRUE */ && segmentPage % 2 === 0 && !evenPageFooterId) {
        return {
          createType: 5 /* EVEN_PAGE_FOOTER */,
          headerFooterId: null
        };
      }
      return defaultFooterId ? {
        createType: null,
        headerFooterId: defaultFooterId
      } : {
        createType: 3 /* DEFAULT_FOOTER */,
        headerFooterId: null
      };
    }
    default:
      throw new Error(`Invalid editArea: ${editArea}`);
  }
}
var DocHeaderFooterController = class extends Disposable {
  constructor(_context, _commandService, _editorService, _instanceSrv, _renderManagerService, _docSkeletonManagerService, _docSelectionRenderService, _localeService, _componentManager) {
    super();
    this._context = _context;
    this._commandService = _commandService;
    this._editorService = _editorService;
    this._instanceSrv = _instanceSrv;
    this._renderManagerService = _renderManagerService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._docSelectionRenderService = _docSelectionRenderService;
    this._localeService = _localeService;
    this._componentManager = _componentManager;
    __publicField(this, "_loadedMap", /* @__PURE__ */ new WeakSet());
    this._initialize();
  }
  _initialize() {
    this._init();
    this._drawHeaderFooterLabel();
    this._initCustomComponents();
    this._listenSwitchMode();
  }
  // Close header footer panel when switch mode.
  _listenSwitchMode() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (RichTextEditingMutation.id === command.id) {
          const docDataModel = this._context.unit;
          const viewModel = this._docSkeletonManagerService.getViewModel();
          const editArea = viewModel.getEditArea();
          const documentFlavor = docDataModel.getSnapshot().documentStyle.documentFlavor;
          if (editArea !== "BODY" /* BODY */ && documentFlavor === 2 /* MODERN */) {
            this._commandService.executeCommand(CloseHeaderFooterCommand.id, {
              unitId: this._context.unitId
            });
          }
        }
      })
    );
  }
  _initCustomComponents() {
    if (!this._componentManager.get(COMPONENT_DOC_HEADER_FOOTER_PANEL)) {
      this.disposeWithMe(this._componentManager.register(COMPONENT_DOC_HEADER_FOOTER_PANEL, DocHeaderFooterPanel));
    }
  }
  _init() {
    const { unitId } = this._context;
    const docObject = neoGetDocObject(this._context);
    if (docObject == null || docObject.document == null) {
      return;
    }
    if (!this._loadedMap.has(docObject.document)) {
      this._initialMain(unitId);
      this._loadedMap.add(docObject.document);
    }
  }
  _initialMain(unitId) {
    const docObject = neoGetDocObject(this._context);
    const { document: document2 } = docObject;
    this.disposeWithMe(document2.onDblclick$.subscribeEvent(async (evt) => {
      if (this._isEditorReadOnly(unitId)) {
        return;
      }
      if (!this._isTraditionalMode()) {
        return;
      }
      const { offsetX, offsetY } = evt;
      const {
        pageLayoutType = 0 /* VERTICAL */,
        pageMarginLeft,
        pageMarginTop
      } = document2.getOffsetConfig();
      const coord = this._getTransformCoordForDocumentOffset(offsetX, offsetY);
      if (coord == null) {
        return;
      }
      const viewModel = this._docSkeletonManagerService.getViewModel();
      const skeleton = this._docSkeletonManagerService.getSkeleton();
      const preEditArea = viewModel.getEditArea();
      const { editArea, pageNumber } = skeleton.findEditAreaByCoord(
        coord,
        pageLayoutType,
        pageMarginLeft,
        pageMarginTop
      );
      if (preEditArea === editArea) {
        return;
      }
      viewModel.setEditArea(editArea);
      const { createType, headerFooterId } = checkCreateHeaderFooterType(viewModel, editArea, pageNumber);
      if (editArea === "BODY" /* BODY */) {
        this._docSelectionRenderService.setSegment("");
        this._docSelectionRenderService.setSegmentPage(-1);
        this._docSelectionRenderService.setCursorManually(offsetX, offsetY);
      } else {
        if (createType != null) {
          const SEGMENT_ID_LEN = 6;
          const segmentId = Tools.generateRandomId(SEGMENT_ID_LEN);
          this._docSelectionRenderService.setSegment(segmentId);
          this._docSelectionRenderService.setSegmentPage(pageNumber);
          await this._commandService.executeCommand(CoreHeaderFooterCommand.id, {
            unitId,
            createType,
            segmentId
          });
        } else if (headerFooterId != null) {
          this._docSelectionRenderService.setSegment(headerFooterId);
          this._docSelectionRenderService.setSegmentPage(pageNumber);
          this._docSelectionRenderService.setCursorManually(offsetX, offsetY);
        }
      }
    }));
  }
  _getTransformCoordForDocumentOffset(evtOffsetX, evtOffsetY) {
    const docObject = neoGetDocObject(this._context);
    const { document: document2, scene } = docObject;
    const { documentTransform } = document2.getOffsetConfig();
    const activeViewport = scene.getViewports()[0];
    if (activeViewport == null) {
      return;
    }
    const originCoord = activeViewport.transformVector2SceneCoord(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    return documentTransform.clone().invert().applyPoint(originCoord);
  }
  // eslint-disable-next-line max-lines-per-function
  _drawHeaderFooterLabel() {
    const localeService = this._localeService;
    this._instanceSrv.getCurrentTypeOfUnit$(O.UNIVER_DOC).subscribe((unit) => {
      if (unit == null) {
        return;
      }
      const unitId = unit.getUnitId();
      const currentRender = this._renderManagerService.getRenderById(unitId);
      if (this._editorService.isEditor(unitId) || this._instanceSrv.getUniverDocInstance(unitId) == null) {
        return;
      }
      if (currentRender == null) {
        return;
      }
      const { mainComponent } = currentRender;
      const docsComponent = mainComponent;
      this.disposeWithMe(
        toDisposable(
          // eslint-disable-next-line max-lines-per-function
          docsComponent.pageRender$.subscribe((config) => {
            if (this._editorService.isEditor(unitId)) {
              return;
            }
            if (!this._isTraditionalMode()) {
              return;
            }
            const viewModel = this._docSkeletonManagerService.getViewModel();
            const editArea = viewModel.getEditArea();
            const isEditBody = editArea === "BODY" /* BODY */;
            const { page, pageLeft, pageTop, ctx } = config;
            const { pageWidth, pageHeight, marginTop, marginBottom } = page;
            ctx.save();
            ctx.translate(pageLeft - 0.5, pageTop - 0.5);
            if (isEditBody) {
              Rect.drawWith(ctx, {
                left: 0,
                top: 0,
                width: pageWidth,
                height: marginTop,
                fill: "rgba(255, 255, 255, 0.5)"
              });
              ctx.save();
              ctx.translate(0, pageHeight - marginBottom);
              Rect.drawWith(ctx, {
                left: 0,
                top: 0,
                width: pageWidth,
                height: marginBottom,
                fill: "rgba(255, 255, 255, 0.5)"
              });
              ctx.restore();
            } else {
              ctx.save();
              ctx.translate(0, marginTop);
              Rect.drawWith(ctx, {
                left: 0,
                top: marginTop,
                width: pageWidth,
                height: pageHeight - marginTop - marginBottom,
                fill: "rgba(255, 255, 255, 0.5)"
              });
              ctx.restore();
            }
            if (!isEditBody) {
              const headerPathConfigIPathProps = {
                dataArray: [{
                  command: "M",
                  points: [0, marginTop]
                }, {
                  command: "L",
                  points: [pageWidth, marginTop]
                }],
                strokeWidth: 1,
                stroke: HEADER_FOOTER_STROKE_COLOR
              };
              const footerPathConfigIPathProps = {
                dataArray: [{
                  command: "M",
                  points: [0, pageHeight - marginBottom]
                }, {
                  command: "L",
                  points: [pageWidth, pageHeight - marginBottom]
                }],
                strokeWidth: 1,
                stroke: HEADER_FOOTER_STROKE_COLOR
              };
              Path3.drawWith(ctx, headerPathConfigIPathProps);
              Path3.drawWith(ctx, footerPathConfigIPathProps);
              ctx.translate(0, marginTop + 1);
              TextBubbleShape.drawWith(ctx, {
                text: localeService.t("headerFooter.header"),
                color: HEADER_FOOTER_FILL_COLOR
              });
              ctx.translate(0, pageHeight - marginTop - marginBottom);
              TextBubbleShape.drawWith(ctx, {
                text: localeService.t("headerFooter.footer"),
                color: HEADER_FOOTER_FILL_COLOR
              });
            }
            ctx.restore();
          })
        )
      );
    });
  }
  _isEditorReadOnly(unitId) {
    const editor = this._editorService.getEditor(unitId);
    if (!editor) {
      return false;
    }
    return editor.isReadOnly();
  }
  _isTraditionalMode() {
    const docDataModel = this._context.unit;
    const documentFlavor = docDataModel.getSnapshot().documentStyle.documentFlavor;
    return documentFlavor === 1 /* TRADITIONAL */;
  }
};
DocHeaderFooterController = __decorateClass([
  __decorateParam(1, ICommandService),
  __decorateParam(2, IEditorService),
  __decorateParam(3, IUniverInstanceService),
  __decorateParam(4, IRenderManagerService),
  __decorateParam(5, Inject(DocSkeletonManagerService)),
  __decorateParam(6, Inject(DocSelectionRenderService)),
  __decorateParam(7, Inject(LocaleService)),
  __decorateParam(8, Inject(ComponentManager))
], DocHeaderFooterController);

// ../packages/docs-ui/src/commands/operations/doc-header-footer-panel.operation.ts
var SidebarDocHeaderFooterPanelOperation = {
  id: "sidebar.operation.doc-header-footer-panel",
  type: 1 /* OPERATION */,
  handler: async (accessor, params) => {
    const sidebarService = accessor.get(ISidebarService);
    const localeService = accessor.get(LocaleService);
    switch (params.value) {
      case "open":
        sidebarService.open({
          header: { title: localeService.t("headerFooter.panel") },
          children: { label: COMPONENT_DOC_HEADER_FOOTER_PANEL },
          onClose: () => {
          },
          width: 400
        });
        break;
      case "close":
      default:
        sidebarService.close();
        break;
    }
    return true;
  }
};

// ../packages/docs-ui/src/commands/commands/doc-header-footer.command.ts
function getEmptyHeaderFooterBody() {
  return {
    dataStream: "\r\n",
    textRuns: [{
      st: 0,
      ed: 0,
      ts: {
        fs: 9
        // The default header footer text size.
      }
    }],
    customBlocks: [],
    paragraphs: [
      {
        startIndex: 0,
        paragraphStyle: {
          spaceAbove: { v: 0 },
          lineSpacing: 1.5,
          spaceBelow: { v: 0 }
        }
      }
    ],
    sectionBreaks: [
      {
        startIndex: 1
      }
    ]
  };
}
function createHeaderFooterAction(segmentId, createType, documentStyle, actions) {
  const jsonX = JSONX.getInstance();
  const ID_LEN = 6;
  const firstSegmentId = segmentId != null ? segmentId : Tools.generateRandomId(ID_LEN);
  const isHeader = createType === 2 /* DEFAULT_HEADER */ || createType === 0 /* FIRST_PAGE_HEADER */ || createType === 4 /* EVEN_PAGE_HEADER */;
  const insertAction = jsonX.insertOp([isHeader ? "headers" : "footers", firstSegmentId], {
    [isHeader ? "headerId" : "footerId"]: firstSegmentId,
    body: getEmptyHeaderFooterBody()
  });
  actions.push(insertAction);
  const secondSegmentId = Tools.generateRandomId(ID_LEN);
  const insertPairAction = jsonX.insertOp([isHeader ? "footers" : "headers", secondSegmentId], {
    [isHeader ? "footerId" : "headerId"]: secondSegmentId,
    body: getEmptyHeaderFooterBody()
  });
  actions.push(insertPairAction);
  let key = "defaultHeaderId";
  let pairKey = "defaultFooterId";
  switch (createType) {
    case 2 /* DEFAULT_HEADER */:
      key = "defaultHeaderId";
      pairKey = "defaultFooterId";
      break;
    case 3 /* DEFAULT_FOOTER */:
      key = "defaultFooterId";
      pairKey = "defaultHeaderId";
      break;
    case 0 /* FIRST_PAGE_HEADER */:
      key = "firstPageHeaderId";
      pairKey = "firstPageFooterId";
      break;
    case 1 /* FIRST_PAGE_FOOTER */:
      key = "firstPageFooterId";
      pairKey = "firstPageHeaderId";
      break;
    case 4 /* EVEN_PAGE_HEADER */:
      key = "evenPageHeaderId";
      pairKey = "evenPageFooterId";
      break;
    case 5 /* EVEN_PAGE_FOOTER */:
      key = "evenPageFooterId";
      pairKey = "evenPageHeaderId";
      break;
    default:
      throw new Error(`Unknown header footer type: ${createType}`);
  }
  for (const [k, id] of [[key, firstSegmentId], [pairKey, secondSegmentId]]) {
    if (documentStyle[k] != null) {
      const replaceAction = jsonX.replaceOp(["documentStyle", k], documentStyle[k], id);
      actions.push(replaceAction);
    } else {
      const insertAction2 = jsonX.insertOp(["documentStyle", k], id);
      actions.push(insertAction2);
    }
  }
  return actions;
}
var CoreHeaderFooterCommandId = "doc.command.core-header-footer";
var CoreHeaderFooterCommand = {
  id: CoreHeaderFooterCommandId,
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a;
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const renderManagerService = accessor.get(IRenderManagerService);
    const { unitId, segmentId, createType, headerFooterProps } = params;
    const docSkeletonManagerService = (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService);
    const docDataModel = univerInstanceService.getUniverDocInstance(unitId);
    const docViewModel = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getViewModel();
    if (docDataModel == null || docViewModel == null) {
      return false;
    }
    const editArea = docViewModel.getEditArea();
    const { documentStyle } = docDataModel.getSnapshot();
    const isUpdateMargin = (headerFooterProps == null ? void 0 : headerFooterProps.marginFooter) != null || (headerFooterProps == null ? void 0 : headerFooterProps.marginHeader) != null;
    const textRanges = [{
      startOffset: 0,
      endOffset: 0,
      collapsed: true
    }];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges,
        debounce: true
      }
    };
    if (isUpdateMargin) {
      doMutation.params.noNeedSetTextRange = true;
    }
    const jsonX = JSONX.getInstance();
    const rawActions = [];
    if (createType != null) {
      createHeaderFooterAction(segmentId, createType, documentStyle, rawActions);
    }
    if (headerFooterProps != null) {
      Object.keys(headerFooterProps).forEach((key) => {
        const value = headerFooterProps[key];
        const oldValue = documentStyle[key];
        if (value === oldValue) {
          return;
        }
        let action;
        if (oldValue === void 0) {
          action = jsonX.insertOp(["documentStyle", key], value);
        } else {
          action = jsonX.replaceOp(["documentStyle", key], oldValue, value);
        }
        rawActions.push(action);
        if (key === "useFirstPageHeaderFooter" && value === 1 /* TRUE */ && !documentStyle.firstPageHeaderId) {
          const headerFooterType = editArea === "HEADER" /* HEADER */ ? 0 /* FIRST_PAGE_HEADER */ : 1 /* FIRST_PAGE_FOOTER */;
          createHeaderFooterAction(segmentId, headerFooterType, documentStyle, rawActions);
        } else if (key === "evenAndOddHeaders" && value === 1 /* TRUE */ && !documentStyle.evenPageHeaderId) {
          const headerFooterType = editArea === "HEADER" /* HEADER */ ? 4 /* EVEN_PAGE_HEADER */ : 5 /* EVEN_PAGE_FOOTER */;
          createHeaderFooterAction(segmentId, headerFooterType, documentStyle, rawActions);
        }
      });
    }
    if (rawActions.length === 0) {
      return false;
    }
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var OpenHeaderFooterPanelCommand = {
  id: "doc.command.open-header-footer-panel",
  type: 0 /* COMMAND */,
  handler: async (accessor, _params) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SidebarDocHeaderFooterPanelOperation.id, { value: "open" });
  }
};
var CloseHeaderFooterCommand = {
  id: "doc.command.close-header-footer",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    var _a;
    const commandService = accessor.get(ICommandService);
    const renderManagerService = accessor.get(IRenderManagerService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const instanceService = accessor.get(IUniverInstanceService);
    const { unitId } = params;
    const renderObject = renderManagerService.getRenderById(unitId);
    if (renderObject == null) {
      return false;
    }
    const { scene } = renderObject;
    const transformer = scene.getTransformerByCreate();
    const docSkeletonManagerService = renderObject.with(DocSkeletonManagerService);
    const docSelectionRenderService = renderObject.with(DocSelectionRenderService);
    const skeleton = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getSkeleton();
    const viewModel = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getViewModel();
    if (viewModel == null || skeleton == null) {
      return false;
    }
    docSelectionManagerService.replaceDocRanges([]);
    transformer.clearSelectedObjects();
    docSelectionRenderService.setSegment("");
    docSelectionRenderService.setSegmentPage(-1);
    viewModel.setEditArea("BODY" /* BODY */);
    skeleton.calculate();
    (_a = renderObject.mainComponent) == null ? void 0 : _a.makeDirty(true);
    queueMicrotask(() => {
      const docDataModel = instanceService.getUnit(unitId);
      const snapshot = docDataModel == null ? void 0 : docDataModel.getSnapshot();
      if (snapshot == null) {
        return;
      }
      const offset = findFirstCursorOffset(snapshot);
      docSelectionManagerService.replaceDocRanges([
        {
          startOffset: offset,
          endOffset: offset
        }
      ]);
    });
    commandService.executeCommand(SidebarDocHeaderFooterPanelOperation.id, { value: "close" });
    return true;
  }
};

// ../packages/docs-ui/src/components/const.ts
var COMPONENT_PREFIX = "UI_PLUGIN_DOCS";

// ../packages/docs-ui/src/components/color-picker/interface.ts
var COLOR_PICKER_COMPONENT = `${COMPONENT_PREFIX}_COLOR_PICKER_COMPONENT`;

// ../packages/docs-ui/src/components/font-family/interface.ts
var FONT_FAMILY_COMPONENT = `${COMPONENT_PREFIX}_FONT_FAMILY_COMPONENT`;
var FONT_FAMILY_ITEM_COMPONENT = `${COMPONENT_PREFIX}_FONT_FAMILY_ITEM_COMPONENT`;

// ../packages/docs-ui/src/components/font-size/interface.ts
var FONT_SIZE_COMPONENT = `${COMPONENT_PREFIX}_FONT_SIZE_COMPONENT`;

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/docs-ui/src/components/list-type-picker/index.module.less
var index_module_default10 = {
  "docListTypePicker": "univer-doc-list-type-picker",
  "docListTypePickerItem": "univer-doc-list-type-picker-item",
  "docListTypePickerItemActive": "univer-doc-list-type-picker-item-active"
};

// ../packages/docs-ui/src/components/list-type-picker/picker.tsx
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var ListTypePicker = (props) => {
  const { value, onChange, options } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: clsx(index_module_default10.docListTypePicker, "univer-theme"), children: options.map((item) => {
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
      "img",
      {
        className: index_module_default10.docListTypePickerItem + (value === item.value ? `
                              ${index_module_default10.docListTypePickerItemActive}
                            ` : ""),
        onClick: () => {
          onChange(item.value);
        },
        src: item.img
      },
      item.value
    );
  }) });
};
var orderListOptions = [
  {
    value: "ORDER_LIST" /* ORDER_LIST */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAAzAAEAAgMBAQEAAAAAAAAAAAAABwkGCAoFBAMBAQADAQEAAAAAAAAAAAAAAAACAwQBBf/aAAwDAQACEAMQAAAA7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACrPRXpvZDoUx3gAAAAAAAAAAAfgc027P0wYdAxI12AAAAAAAAMuNiAADmf3Z7hc1u7dU/iMYAAAAAAAAPtMnAAINnHyDYmEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANdZxpZ1VSZHt8mS4YwQUAAAAAZOTqAAAAVM6K9WLIaG3Q6j/P0zhHvmGCAAAAAHqGdAAAAESy5UDpqsJpnjnW+VMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVPortYz2AAAAAAAAAAAACnDTVcfmtGPkOgAGQkwgAAAAAAAHN1to6MMV/qnikYgAHtEnAAAAAAAAGgN0Isly1HPYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEcuUc66bn8tuwcJAAAAAAAAAAACn7TVaznt5wNufpnw6BhZhYAAAAAAAPaJOABBE488WynpNxXyPHoj4j4AAAAAAAGQkwgApU1Uw1LljdNkISjbJntAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH//EACoQAAEEAgIBAgYCAwAAAAAAAAYABQcXBAgJFgMKEAECFSBAYDA4FDpw/9oACAEBAAEIAP1PkJ5Ph/SMkjyEwngx3J3W2nknkmDt1/yfhi43wyfnzfhwP/3Z58vc6ycjDFXTIxOyES7IRLshEuyES7IRLshEuyES7IRLshEuyES7IRLshEuyES7IRLshEuyES7IRIFe3nMKmvHy/t4H/AO7PPkhPkT1GNtxzfQodTi3Ybrh+bAz68D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D03Bo21Znhz8D7Yl1pgeCSmXTaIGHUnWgX2CK9rB7/hO2x3OMaa3y4a60xnxR7+TrG7HLu3PD/tPs47TXvFx4bg+xk45jUNuWfgWGYKwzBWGYKwzBWGYKwzBWGYKwzBWGYKwzBWGYINMiR1JG3Az/4ebLdeTtCOPyTpyheNeEuDDuKhyWdx/T9/JAfh5OuVvD1djzZfXyWpGk+IoxTy047425LXl1QOqqB1VQOqqB1VQOqqB1VQOqqB1VQOqqB1VQOpmj5mY3LGdMT+GdYLijZeJTiDJwC/T5aei2A3BT9AmgmtGss5zHsDCut/GxqXqhsNsFs/Cv7gT8nWSO8p4Pxn/J+UW7rzkz84MYaHYXsVO2QxsOe6YlrkStciVrkStciVrkSFZBeXx+wGvL/BkH/aNgxZL6yYTo2MeYiFn+vM+Y0qoVUKqFVCqhQ9HH0F4w3b8J80CEHzkeDeRzy7D8U0X7EchGtPIY9/rs7TtE2s0TG05Tl4PUFYTqN3MNau7SwfuTC4rPuvX5HLVoZNvIJ8mm0YB7q6h0aBjg9PHpucPwPTdyYy7G/sXl/VPpyt5W8reVvK3lbyt5W8reVvK3lbyt5W8reVvIekf688YbT9uy+ykO6iQmdbBTy1RRvFz2+dmOthYiiKNIEjQMhyHPY7E3En+lf4FUESqgiVUESqgiVUESqgiVUESqgiVUESqgiVUESqgiVUESqgiVUESqgiQrHzyxv2A6Zf2c0HGjO/JqCwHHMU+LUT1Cvg8Xj8Ph0WirfyLmmRsfe/jH0S2j0yINqXrZH9m//EAD0QAAEDAgMGBAIIBAYDAAAAAAUCAwQBBgAHEggRExSUpZXU1eUV0wkQICIjM0BgISQwWRYXQkRit2Rwtv/aAAgBAQAJPwD9p5DZw7T21TngDKE8lMlsrQSnYZuo+ekS4SvG7NMxdsW5CIuN/E58AHcEuHF1TJMKKORIIxrsBlL22dNocNloNse1QlqDrRytJxC2aoO9bOtUvb41kpcoAeYtKLAGF7nOXOSkxBrMz4s+7NlyJP6mOxSY4w3Fcl0abpJXGZcddajrfoniqYadfecbaquraHHnVpTRTi61/uKXl/21tIfXIfiyG+R4b8d1xh5GsjDQvQ60pK06kKUhWlVNSVKTXfStaYPmvFJ3z8HzXik75+D5rxSd8/B814pO+fg+a8UnfPwfNeKTvn4PmvFJ3z8HzXik75+D5rxSd8/B814pO+fg+a8UnfPwfNeKTvn4PmvFJ3z8HzXik75+D5rxSd8/B814pO+fg+a8UnfPwXKSo7nPcRiRPlvsr0Dpi0a2nXVIVpWlK06k10qSlVN1aUr9r+4peX/bW0hjNFMzacy/BKP3BZC7cuWMOq1HFDTpQYLu2QKbtcsdChTIwoVEQirstiK/K4SH3gx5kVhnjxH+HxWuI61r4TqHm/xGVtup0utoV91dN+7dXemtaVEdwKedwI7gU87gR3Ap53AjuBTzuBHcCnncCO4FPO4EdwKedwI7gU87gR3Ap53AjuBTzuBHcCnncCO4FPO4EdwKedwI7gU87gR3Ap53AjuBTzuBHcCnncDeBLY4nCd5ye7o4rS2XPw3pTjStTTi0/eRXdv303KpStPs5YWzYN1593pJzEziOAWJDM7MG9phE2WlXIfU/JfQ8RfJXIcmLWwhhurxOTWjdKKTROSeX4jaLvgEzbV15vQgbDV4Gg7LECJViRN31abkyYYoXBnkozDBMlBHQYJCZKiRGGW//ROVf+defYe1loypy0XPHDolwXiVnwgwyQUklSwGGoJbqiK7oPQ6mhcokGCzx0CdGnyozqfpbtu/K/aTvkBAuorlzs55gwMqsmMoj5aJHnsWPNsK0VM2/en+E1qaFnnhMi2x5abGnMxZUyM58ZI5iIzuzZ2H70tKPZ+fKg0MGZzOyoveIQct167x45NYyLjGj4IIq5PlSiRmei63oBgsZn2++dLfU9wJbHJ8J3htO6OLPisufhvIcaVqacWn7yK7t++m5VKVoX7eL8lgv28X5LBft4vyWC/bxfksF+3i/JYL9vF+SwX7eL8lgv28X5LBft4vyWC/bxfksF+3i/JYJceI/wA5xWuTgNa+FAlPN/iMxW3U6XW0K+6um/durvTWtK/0YkOuac07Z+XFl3ATHNGBlkEr3KKhyb0liZLT0AjJCiYpH4DGKocDquiSDWXhlhyJIYjthbXe05mPctnDb/vnNIxtS3haWWcFwoGaPFZeXom1CQwVbeXUOO84+K5wwWjMikc2zMiD1MwolyH7wyDFhMpA2W113Lcpm8idyCAhMuJmG27quB6QXuAOSNQicu2ysp51My3XRTsZdYimMZzZcX7mfksQQKzWsS1brEGbmsIkqVJHuQrkFwpLsmBJhk4csSSaWmqhRiM+JJUikmlxaYW+3HlcHiLjqbQ9TgPtSEaFOtvIpvWymitTat6aqpTdWtFUmmuog+nYmmuog+nYmmuog+nYmmuog+nYmmuog+nYmmuog+nYmmuog+nYmmuog+nYmmuog+nYmmuog+nYmmuog+nYklHJEXjcNEh6ItmvHYdjr1pahMrruQ8qqdLidyqJrXfSlU1/o2WKzAytzFDqCXXaxejyY82NSQxNhy4suI7HnijAcnFhGAJwXKhlgZqBALipkQhDjSG889u3M/IcW6yqLsv5hbU1xO7PNI8Z2j0Uc7Y1ngrOnPDI7lK1TBcuBTLyVLblUfacWhVmv2TeOd9rZa2VdYITMbh2AJtfKW2htpWQGsyy4USKKtWCLBiYMWscemjLnCqqjaNW6ljFbezX2lJ06dmHPmXSaLhoqjVxO3hc0W1Ak6Q5EAwbmu1bdwFIieZajy4sSEDoHDMJGfvHZfzVJMXflw9fj20QzMo1aA3TaZi7G349t/AHkEbGZqHdtErfDt3jHR9/LrbDNsT9CJ736qfbadn66ti4hngXHOW7Hculd+R7ozDEtyGLmq9SSwMpDtsYmo1LNW6uJeXr3vVpT6kMuSIvK8NEhLi2a8eZHjr1pacZXXch5VU6XE7lUTWu+lKprCC9PO9RxCC9PO9RxCC9PO9RxCC9PO9RxCC9PO9RxGGNx5XNcRcdmWh6nAhyJCNCnZryKb1sporU2remqqU3VrRVP0P9s8v/APd5w4MCohs0iY6HDySERgoWaHNJeIODB7ryJc9EBlaXZi4rLqYrSkuP1QitK/VI5Tm+X/mODx+HwJTEn8ris6tXB0fmJ06tX8d2mtw9p9zxcPafc8XD2n3PFw9p9zxcPafc8Geb5TmP5f4dwOJx4r8b83nntOnja/y1atOn+G/VT9DmBcjF62bs9StnuNlu2MFqtaaGlGrqNKuF8qpXxZsmh26pDNIraeVq3EZVWupa8Zs5q2zfmzgJCCB9gApo5dnXMxapu57iAJW/MjuFLejSSN3F494QBrr0G6hHBhcATJdJkCX7dvYTl7lfl6JWZui6DK3asRWKutRYcKFDitSCBc0XISIooECFRZhc4XmQhQqFLny2GHPox/pH7i2U0sVKq2iIGTMFwI5acdt10he0QUwZlCHrSiMx35Xxx284w9MRCVzpA+SusRF6xb5y3u1D7cUg3HkjyYgvAUloxbVyBpzbJAHcYSSqkckNmNJVTUzMiOyxsyDNk/qDuX8XZ6sLahs3NjattO8j1wByd95cWzPFRagbYhiLYuAdcUytulL8rQLccwIKeMPW8+uZRTFZMGbb1jWBYdtyCBIhMdgW/a1o2lbQ1T8mTIdXWKMCggYmGpa1V5eEPgxq/lMtbqCFgtlzNrbyzENbNw1sVKCiq2pEnHJLkq34D0eHGQHYtc1YFvt8jEaaizLemiHtEgU5Fi/UO5/n+b/3fK8LleW/8aRxOJzH/DTo/wBWr7tvd29sxb3dvbMW93b2zFvd29sxb3dvbMW93b2zFvd29sxb3dvbMW93b2zFvd29sxb3dvbMW93b2zFvd29sxb3dvbMW93b2zFvd29swG5Tm+Y/mPiPH4fAivyfyuRZ1auDo/MTp1av47tNfsXbGs3LXL8ZSeYJOIVJnz5ch5EQRb1vjG60kGbkuEm9GFAxMb8WZOktUWtiOl+Qy/dOxN9FKQlwrgsfZ9t+e3C2gNqkFEkUm27c+ZRqkaQ1b1nmHW45iGxVPwb4fQau1rfuWXUXm21ZgXL7LLL4Kxb9n2fb7C2BgYYwtx5SEKecflzJkyW/JIlSpGTLKmSsuaWLTZpKbKlPfU9CZ5HnuLzjj7ermeT4fD4MaRv3cuvXq0bt6d2rfXTNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxNC9RO9OxJGOR4vNcREd6Wt6vHhyI6NCXYTKK7lvJqrU4ncmiq031pRNfsZ4WNlPaWV2YB7Mq9QV/W0UuoJe9ysDBYnL958NCaegTo1tw5d9MzIRlp+DMZuSjKor6KvUT9K/s4sssoQ0001si5aNtNNNpohttttGWlEoQhNKJQhNKJSmlKUpSlKUxtS5e7TxYwRtt7LchYOVNvZWt2gOhxi6Llhk49v27bzZlZeTIDPxHpLclcNMCQhtbaZCkq2zLt2rWc8MyB902ANPv3S9BsQaPm3hLJF0R7pNm0hT96JuQUwbt+2FMW6MatQYhmaZouNUX+5v//EADkRAAICAAQDBAUJCQAAAAAAAAECAxESITFBAARREzJAYWBxc6HwFCIzgZGxssHRIzRCQ1NUcJPx/9oACAECAQE/APROGAyhnLrHGh+ezHTK8hufKx+XHNxRRrAYgadCxJJtu6QSCaBz2A93i+b+i5P2I/DH4vm/ouT9iPwx8GGQRCYr+zJoNY6kaXYFirr7x4ppHcKGYkIKUH+EZCh9g4MkhQRlzgBsLeQPxtp/gqMIzqHbAhPzmq6Gv2nQdLvhuYhRisfLRMgNBnGJmA3xHMXtrXuHMxoFimjXAsoNpdhWGteWo6CtBdeJ5WJZplRu7RYgZE1tfnvWdXXXhuacMVijjjAJAURgtrVMSDZ65DPjnMfYcv2gAe2xAACjQyoZA1r58FHVVZlYK3dJBAPqO/iEdo2DocLLmCPj7RweclOYWJX/AKixjH67JOf1cPM7oqMbCFiOpLGySdTZPDzySIkbm1Tu5AbUL60Mh+vpiIL5cz9ouTVg3OYGt5HO6ru534sRIeVabPGJcAzyqlOnXPxa/uD+3H4V4/LxQmIgMFCi+PFvdAV024TmGSF4QqkPeZ1FgA+vQV0PX0eRGdgiAszGgB8adToBx8jN4DPAJNMGLO+mmvlXEkbxMUcUw942IO4PXxPLTJD2rEHGYysZABAY9cxWdZja+MyazJJ9ZJP3knjnv5CsbkWECTc3lr53iP13v4mNGkcIgtjp+ZPQDc8FouUsJUvMaFz3IzuFG5H/AEju8MzOxZiWZjZJ3+PdoPE8rOkBdmQsWAUEEAgb5+eWnTjtOT/t5P8AYf14laFsPZRtHV4sTFr0rUmqz4nljlEeCIR4VokVnpllVgVkTnnt6T//xAA2EQACAQEFAwkGBwEAAAAAAAABAhEDABIhMUFAYYETMlFgcZGhsfAiQlJywdIjNENTcHOS4f/aAAgBAwEBPwDqm9QIQoBZjko+p08bUXdjUDnFWiBEDOQO7ftdHn1vnPm210efW+c+bWvqWKT7Q0/7l67dqCqpJAgsZO82urevQLxwnX+CmJCkqJaMBv8AWNhTciWquGOMKYA3QM+EWpM156bGShwPSN/hvx2mq5RCRngBunX1rYUVIl2ZiRJN7DhutRjlal0ysYHiLBlJIBBIzAOW0EBgQRIOYsKCZS5HwlvZ7hHnYIqsWAgkAbgBAEDhZaaqzMBBbPzw49ceU/EFO6cRN7TKe7SZzwjay7Csqe6Unjjrw2s/mF/r+7ayk1BUnJbsd+PjZqYZ1eTK6aYeWePT1eJCgkmAMzbl9RTqFfijx6I42Vg4DKZB9QdpqIXugRdDAsDOIHRh2+FsAOgDuAFqH6hHNLm72Y/SPQ2lmCgschaHrYtKU9F95uid2vlPOsAFAAEAZDaatNqgUAgAEkzqdO7Hvtdr/uL/AJH22QOJvsGyiBEdOgtTRkvXnLSZGeGeOJzOvZ1n/9k="
  },
  {
    value: "ORDER_LIST_1" /* ORDER_LIST_1 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAAyAAEAAgMBAQEAAAAAAAAAAAAABwkGCAoFAwQBAQADAQAAAAAAAAAAAAAAAAACAwQB/9oADAMBAAIQAxAAAADv4AAAAAAAAAAAAAAAAAAAAAAAAAAAABB8+ThDoAAAAAAAAAAAqz0V6b2Q8ProwxXgAAAAAAAAAAD4HNNuzyjHt82S7Ked1gPIAAAAAAABlxsQAAcz+7PlvO9F2K/6mJHwAAAAAAAB+0ycAAg2cdIrY2n57AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABh/eZhzoAAAAAAAAAAAA50dtHRdivAAAAAAAAAAA11nGlnVVJkexTLnR1ivxggoAAAAAycnUAAAAqZ0V6sWQ0NuhuPVPo4xX+YYIAAAAAeoZ0AAAARLLlQOmqwmmem1kbmM1oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGId5X1dDSa2HQbjvAAAAAAAAAAAHmFS2mrUGyPR1ivx8h0AAyEmEAAAAAAAHh9c+Wyjzjo6xX+KRiAAe0ScAAAAAAAD8ZofdDSy2F5+S4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACI5co5103P5battFd5mS4AAAAAAAAAACn7TVaznt5wNufK+d6PMV/wCIiQAAAAAAAHtEnAAgiceeLZT0m4r6CtdPR5iv88g0AAAAAAAGQkwgApU1Uw1Lli9Nlbt1fQ3jvAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/8QAKRAAAAYCAQQCAgIDAAAAAAAAAAUGBwgXBAkDAQIKFhVAIGAwODY5UP/aAAgBAQABCAD/ALTfSSZF03SeJkkL9jYTs+T8I1I3jJonRjMma0p3J2TI6a+zPNy4ObQNdmxJNfY6YuN0ye/N6aH/AO7O/IeTqSYRhqhcBQcyGN81QIlHHxkFAoD7hPjvh4fZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEPZFEEKdnOYqivHy/x0P/3Z35DyJO7JexCwY19pbg4ODF4OHGxhkoVK5mRkZeRXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPBcjU2VZnDn4H4tLGlh2JVLurZoEfBp0FTtEX8/5CfqyMcNAOPhmxi3n2isz5NeG9rkb4v8Ary2Xb4tpG93FrGls9Uc/H1bcjd2XOn+U8nDZ65xa8Jg+Qpz9EEYapH/LQsjHMKk2ZZ+BYawFhrAWGsBYawFhrAWGsBYawFhrAWGsBYawFhrAI1ZKQ1UhbgZ/8O7Ka7nQI1+Oc+TLtrpLYxdtUnHZmP4/fYwfDs62t4cXd1nbyv3NHThCJOg5Kcc8Lckry6oToqhOiqE6KoToqhOiqE6KoToqhOiqE6KoToqhOgmb4mIzLGNMT+F9WLaiS7SrhjHwRfj5Q9S2AXIo+YSAkaIyvm8cgWVipEx+VtsmldsRlx+3uCrOqBQS3XXTWFsA49oEbFW8xzqnXB3E6Zc1NQy7+wd5XLgkxvm4+j6Zj2zygen5AyB2B9ORn98unR6CUKo2yCMhzzTEtdRC11ELXUQtdRC11EEq4JyeH2AV5f0FP/jahHi4/wCqJIib3d1e/wAgXVIyxUFCT/PE+YUioRUIqEVCKhCebj4E4wzb6Jjh9piX5xf3674NIzWjFnHjukdVTGu04kiZp7QpK/rr7Ps00ZmmWz5PlweQVhGqbuZNRdlKx8yWXSr+x610SBdxr5wzZ1gyO+vtqgY9uwTshs2CPNTVHNojDA6OPG5w+A6LtmLutvsy6UZuj0vSRIgZZnx5dn54t4W8LeFvC3hbwt4W8LeFvC3hbwt4W8LeFvBPOP8APHGGU/jJeSjOxEZNdSCfkqaicW+3nJl1IVomibRhG0RjOM5tn6cbqbZNFzCkIN8TkzyozweGqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEEq3xyRn2AaZf4boNaL77NUKwbctTxRE8hXg4uPh4YNtfPdpyRyu2euvkr5p27O5cbQsz9m/8QAPhAAAQQBAgMGBAMFBQkAAAAABAIDBQYBAAcIEhMRFJSl1NUVldPlCSFAICIjM2AWJDBZtxAXMkFQVVe0tf/aAAgBAQAJPwD/AK1fgJrdjYEyuhbvUN2OnYawU1dtCIkqwWSLOxcYmUiZ0AZ0yLnIJyUhix8suNHqSQPl39RsNvDxPcVO+EHKSeymy21sEp0ObzHnpiXJK42zlMXWK4FIuN/EzwIOwFhi8xhIQscgiRGtkHKXbh04h4bbSNo9VhKpHVHa2TElt1YO606qy9fjWZSywEfMVIUCMl7POWeSJEjWTPiz7ppZBOfhlF30n1cAXFehD2AYyWq16NxNbU2OXwwO7ksqrySp60GHP5SS4JtlU4NL/cVLSz+oHYwY4w2K4XhpvBKxmXHXWh1v4T1VMNOvvONtZXltDjzq0pwpxec/5ily/wBWuJDSktStC3j2Ot1ZJx+T4k6u6sVXvIi+dOWiURFolsYcThzOGlOp5MYVlxCOlIzdWr8ue3ytI6ZslEiGFI5GHXmEcj7zieVl51pPZ2NuuIxhWdTcu0y1LyTTTTUkY22222Y8lDbaEvYShCE4wlCE4wlKcYxjGMY1PzXzQ76+p+a+aHfX1PzXzQ76+p+a+aHfX1PzXzQ76+p+a+aHfX1PzXzQ76+p+a+aHfX1PzXzQ76+p+a+aHfX1PzXzQ76+p+a+aHfX1PzXzQ76+p+a+aHfX1PzXzQ76+p+a+aHfX1LyhQ7nfuowQeW+yvkjjFo52nXVIVyrSlaeZOeVSUqx2ZxjP7X+Ypcv8AVriQ0tb9440OMihxxYLGHHHB9qtuWXHdwbAS2ytp1kGuH3CozhhPeGFIjoyScZypbK1sMtDjDtNsDjsNoZYYYZRhtpllpvCW2mmm0pQ22hKUIQnCU4wnGMf7IvqEFPukPud+kUc7z7inXV8iDEoTzLUpXKhKUp7exKcYxjGojzCU9bqI8wlPW6iPMJT1uojzCU9bqI8wlPW6iPMJT1uojzCU9bqI8wlPW6iPMJT1uojzCU9bqI8wlPW6iPMJT1uojzCU9bqI8wlPW6iPMJT1uojzCU9bqN6BbHU6TvfD3eTqtLZc/hvFONK5mnFp/eRns7e3HYrGM4/Z2wrNBte/d0J3E3inIFghk7cG7GSM3LFWSfU+S+h6RfkrJOGLWwhhvL0mTnDeMKThM7t7J1vbfamM2U4KqLSpezS8nTK7OInHN075uQ3P1WvxsVe7CuWLiIoSqSNijEV2elAzz+8R4b5v9LXmn3yPgZ+Rqk6dTLNC2gOFtMQkdctWpYqDNOYjp+LQYIuRhzFsyISSh1EjNYfayr9UMqM4bfxdqGdeAgG0NiQVT4vdoAD82k6MZxleEqvcUoEuyuMISVNXPdaDWSpqPrwuMfp9q/8AfXv3D1ZaNqdtFnx0cJYLjKnhQ0YRKEystAhqhK6qRXaJ4PM1FlSUNCnxwBwx5QzqfxbuO/a/iTvMABapXbnhz3BA2q2Y2in5YQc9ijm0KoqZr90/smtTUXPPRJFbj5Y0Y5kUowZz4zI7iI3u3Z4H7pUh6fvyqGDg5nc7ai7iSDldet8fHJyMixxseDBSrh5RUlMnotbwExLTJ9ffnZbPTte1H4lOzsfEOIYQt1yKs7JVjngcvKdaV3WQVtxEimBcyWT2V8r60YZR26e6BbHc+k702neTqnisufw3kONK5mnFp/eRns7e3HYrGM4l/L4v0Wpfy+L9FqX8vi/Ral/L4v0Wpfy+L9FqX8vi/Ral/L4v0Wpfy+L9FqX8vi/Ral/L4v0Wpfy+L9FqS64j/fOq13MBrn6QBTzf8RkVt1PK62hX7q8dvZ2Z7U5zjP8AgiB53TNnaftxS7BJxzUxGUiSu8ooMm6FxJLTwEiTCxIsj8BGlUOQ6rQTBrlw5aOQTDSPGFxd8Tm49lp0bf7zulMcUtwqW2YLkpDNT0qXt7E1SSjIqt7dBjvOPxXfJiWGZikd7ZMEj1MhCWSfuGwcXCbSQ221rstlmblJ2SIhJOXiTJtu1WB4iXsEPJTQUmXW5Up51JlddinRl5EUxpCpWXtfFqjiZvkcKjrEQm2uw7IBklLGsuuIGQNKVo7cruLzrRGMPVo5tWE5U2Mfpb7Y5XR6ix1Noex0H2iEcinW3kY7VspwrmbV2pyrGOzOcKwbNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0TKOEC9bpoIeEWznrsOjr50tBMrz2IeVlPK4nsVhOc9uMZTn/BpcVuBtbuLDqhLXVpfDyRzRsEMGhliliOjnxUxDyYoUxAzkWUHLQc0ABLxRgkgGMQ3vnx27n7DxbrKheF/cLimsTvDzgcZ3Dwsc7RqfBU456MHcxnKQXLApl5KltlYfacWhVNfpNx3vq22tKtcFEmNh0CJq+0tajalSIamUsIQWKqoMXBxIIuR49OGXOllWG0c3Zih/2FLjYoLho4INu5G2026m0/YCCdeLsu5pDtMm7JDwE5uzMOOTQkS7JN2WsNWW91+TQuNkAHHf6vr1htuaXULLbMVSpApk7XZs1yGNmMV6sxq3h0SFhmu5/DYUFb7KS5IkZhTzeHMrTw7W3YePD3Ftu1ZNOusqm2RVsjYyKhy3ZuDnnqzUfjMUWLP5hZsVdeaYi5+PmYRB0rgJZapyYmK/tZNn8UXBvLT58nJku8OG68rHS81t61LTC+tIL23s1sjWMPNqIfmJ47cQ7HSCiMNtfqMpw+HGHlM5UnmTh0cV15vKk5/wCJOFoT2p/54/LR1ckdxZHczcarEk1avj1mJzE1mRDGi0IixnXmkPoaeXh57C+Z5XZnOMdmkuDm720viC4crh0kqbbm6xBRL5kOCY50VoeRE2DeNE40hC+qgkIPLqmmcoyvSGXCBe69NBCXFs565g46+dLTjK89iHlZTyuJ7FYTnPbjGU5ChfDne46ChfDne46ChfDne46ChfDne46ChfDne46GjGxyu9dRY7JaHsdAMghHIp015GO1bKcK5m1dqcqxjsznCsfoP+xy3/oEa/8AN28//wBmO0nviOG7Z7fbiYu7rXOQzCRlvj5qAr/eksN4wKUTaNsayNlJJKeRqbiiFMYQSKk/RHdO993/ALx0ev0+gUwT/K6rPNzdHk/mJ5ebm/Ps5c2Hyn7nqw+U/c9WHyn7nqw+U/c9WHyn7nqZ733TvH93+HdDqdcV8b+b357l5etz/wAtXNy8v5dvNj9AtTaDgyg1uJxjKm0lMLYUtOM/llScLyrGM/lnOPz/AC1erbuZW67ZrrfF2Obr7WLGQuxutSJoA0DVmTXj1jYE6YAkcMVInuLSwwO8QttpW2t72k3O4n7orafYnavc2sydKvW2fCjta/HRlSbs9RlRwJKBse4BcBByU7HSYOHVvVIOxAOqGtLynf6du0Tt7tft7ErmbRaJlbuWBWMutChhBBitESEvNS8gQLFQUFFCmS85LmBRUUEWeWww5+GP+I/YuFNLGZVXEQBsyC5COVMdt12QuwkUxMlRD1SEZHfK+OO3MaPSIhKziI8leREXUW87b21D7Ysg2OTHycRLgKS1MVqyQxzbMhB2OEJVgeSjTGkqxzMmCOlxpgJpO49p3SnNrZQTiJ4VtzdxbAdP3e6cN25OY0pymyk7NkLlLOVtJKTMRX/jLiijDj3LUytTEVBRqMfp53b8Xh6oXFDTd2OK2p3KesEPJ3vbisnxQuYGsBxFYsEdYjM12UvmcQtjMhIp6Yerz6zMKYySCbXqNQKHWyJCSkDHQK/VqjUq1GqfJJIdXkWMhYKDiQ1LWrPdwo8EbP8AKZa7MRC4Lhc3a48txJrhujW4oqFis1QQ6cJcKr4Dw4YyIdirzVAr7fcRGmhTK8bEPchEU4KK60Gfu7NbucJt6ypbrTcvXJ1uHjKjHmYR2tlJYm95Z6TAbcwnLctHxjmcrS2jLGm+t3EIozpc/T6vdmHHun1OVfJz8nLz8i+Xt7eVXZ2Zr3m32zVe82+2ar3m32zVe82+2ar3m32zVe82+2ar3m32zVe82+2ar3m32zVe82+2ar3m32zVe82+2ar3m32zVe82+2ar3m32zVe82+2ahu6d77x/ePiPX6fQFfJ/ldxZ5ubo8n8xPLzc359nLn9i2jU3bXb+MwfMSTiFEnnlkPIEiK9X4xvOCJmyWGTeGioOJG/imHEtYWtgdL5DL9p4JvwpZAsKwUfh9r57YXEBxUwQhGDa7Z9yprAxDVep8w62PMBsZT8G+H4jV1av2UvMXu21TIXb7bLb6FYr9Pp9fYWxGQ0Ywtx5SEKecfLMMMLfJkZWVkSS5WZlSzZaWNNkjSinsNGWat727qcQ9hGxlayIyq7dIoNuANU0w8hxI0gxtrd/476UsJehEpx3lHemE6UhLxseaI0p3KsNpcJGcZQpzKUrVhGFLxleUoWrCe3OEqz+WTYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2jYXxB3t2iYxwcXvXUQO8Wt7PXDIHRyJdCZRnsW8nKuZxPYnCs47c4wnP7G+FG2nqW124E9uVdYK/VqUtUJd7KxGRcTt+8/DBNPAHDVsMu9MmBTLT4JjNkwyoV9GXsJ/Ff4cWWWUIaaaa4RdtG2mmm04Q2222jbTCUIQnGEoQnGEpTjGMYxjGMa4qduuJiRkjq8Xt5K0bayubVDUuJjxJjFpHl24GvV1iV+KPvRBI5JaCFANx5KUuNIfVhSly2x20MUVwQ8F0k807iMsUHT5NT+7e6dXey6pkyHl7Q7YRK/LtY5Do26TYJDA5sWtkb+pv//EAD0RAAIBAQUEBgUJCQAAAAAAAAECEQMABBIhMUBBUWETIjJxkaEjQmCBsRQzNFNzgrLB8ENQUlRykpPR8f/aAAgBAgEBPwD99MjqquRCvOE5EGNdDkRwMHaaNA1Qzl1p00PXZjplOQ3nlI/K17pUqa0DSBh0LEkmW7JBIJgHPcB5Woelu9aidUHTU+MjtD35D7xO1Xv5q5/Yj8NO1w+kAbmVwe6J+IFjkSOBPx2m9/NXP7Efhp2uXVNWsdKVJv7m0Hvg7U1R3ChmJCCFB9UZCB4CxqqKAooGlmx1SYAJHZCwTkOcZjT2XKlYxAiRIkESDoRO7ntZ9NdMXr3Yx30208DpwCnjtFMIzqHbAhPWaJga+J0HCZs14ooxWndqTIDAZxiZgN+I5id2seQvNNAtKtTXAtUGUmQrDWOWo4CNBMWuefyhDo1BifdkPxbRdaS1qyo3ZgsQMiY3Tz3xnExxs16cMVpU6dMAkBRTBbWIYkGTxyGdr5j6C79IAHlsQAAgwMoGQMa87XXqUrzVOUU+jU8Wfd44fHw2dHamwdDhZcwR+vEWN8qnMLSV/rFpjH3ySc/dZ6zuioxkIWI4ksZJJ1Mk2qVEFCnRpmc8dVoIlzouYBIXugwCPbBRJAkCSBJyAkxJO4DfavR6CoFDh+qGkCIMnIiTBynXQg2vAFSnSvIAlh0dUD6xRkfvAeGHjtIteqSUaxRJw4VOZk52o9a6XlT6hRxyJOfiFjaRqO+1/wDpB/oX4WpdS53hv42RBziCfJj4eG01qpr1MZAUkAQDllzNrw6qlKhTYMtMYnZTIao2sHeBJiOMbvZ5EZ2CICzMYAH604nQC3yMzgNegKmmDFnPDTXlFqlN6TFHEMPMbiDvB42rIrUqVdFChupUVRAWou8AaYgCfDjtF2rJR6ViDjNMrTIAIDHjmIzjMbptmTGZJPeST8STa/fsFYzUWiBU3mctec4j7532ode63pD6oWoOREz5KNopo1RwiCWOn5k8AN5sWpXSQkVbxoXPYpneFG8j/pHZszM7FmJZmMknf+vLQWu/Vu97c6FVQcyZHliHjtF1rpQLsyFiwCgggEDfnzy04W6S5/y9T/If92qtRbD0NNk1xSxadIiSdM7Vj0NCnQ0ZvS1e89lT3CJ7h7T/AP/EADcRAAIBAgIGBwYFBQAAAAAAAAECEQMhAEESMUBRYXEiMoGRscHwE0JSYHKhBDNDktFQU4LS4f/aAAgBAwEBPwD+tBgSQDdYkbp1bS9QIQoBZjqUeZy++KLuxqBzdWiBEDXIHdxxU6FRKmR6DduqfHsG1UevW+s+LY/Efl8mGBcDltNHr1vrPi2K9wiDW7juGvxG1BVUkgQWMnicBCahdogCEAm28mwvyyPD5XBB1EHK2/a+pWj3aonkw/nxbhtDEhSVEtFhx9XwKbkS1VwxvCmAOEDX2RikzaT02MlDY7xx+3G+K9vZtmrj738toquUQka7AcJz9Z4FFSJdmYkSTpW7OGKMe1qaJlYse0Yq9J6Sb20jyH/J2ggMCCJB1jAoJqlyPhLdHuEeOAiqxYCCQBwAEAQOzCqxqM7CPdQWMLvtv77kfOBMAm5gTA1nlxxTf2izoxci958MUzou9I5dJfpOV90987VRcuktrkjdipatSbfK+v3bV+H/AC/8j5YfpV6a/CCx4eoG1U0FNdGZuTOKYJZ6jAgsYUGxCjhx5ZTn8vEhQSTAGs49vmKdQr8UffdHbhWDgMpkH1BxTYh3psSY6Sk6ypy4x/O0VEL6IEaIYFgZuButz+2LAbgO4AYofqEdUudHlfyj0MVLVaTb5U8vTHaGYKCx1DEPWu0pTyX3m3Twz8J62AAoAAgDUMVb1aIzBJ7BB8jtFWm1QKAQACSZzOXdfvxo1/7i/tH+uEDidNg26BEb8hhOnUapkOgnZrI8uZ+Z/wD/2Q=="
  },
  {
    value: "ORDER_LIST_2" /* ORDER_LIST_2 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAAzAAEAAgMBAQEAAAAAAAAAAAAABwoGCAkFBAMBAQADAQEAAAAAAAAAAAAAAAACAwQBBf/aAAwDAQACEAMQAAAAv8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHLPRXpvZCwpjvAAAAAAAAAAAA/ArTbs9mDDoGJGuwAAAAAAABlxsQAAVn92fsLmt3bqn8RjAAAAAAAAB9pk4ABBs4+QbEwkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMB7ytZuotI4NGoNkeXmiqwDjvAAAAAAAAAAGH95Wz3UWfMGiMZc4EbKbIuG8YwQUAAAAAZOTqAAACs/uz9+sd8vx7XB3Ud2Md02x75hggAAAAB6hnQAAANQbYeEbf1z1mnGO5c35pmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOWd9ewsZbhVS4B7KLAOO/D+84q6qu7WS4AAAAAAAAAcZtNXrHVrPZVP9DPbZ87TrhOPATZTaKwaBj5DoABkJMIAAAABpFbDVmyPXLNbXL3UWN8N/wBZWi3Z7JuHR6Z4pGIAB7RJwAAAABD0uRFLmv8AZGQI9ybiXI91xnyOJc6o57AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIjlzhzrp7P5bdg4SAAAAAAAAAAAHH7TV1Zz21wNuezPh0DCzCwAAAAAAAe0ScACCJxrxbKbJuK+R49EfEfAAAAAAAAyEmEAHFTVTDUudG6bIQlHrJntAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH//xAAqEAABAwQCAAQHAQEAAAAAAAAGAAcIBAUJFwMWChAVYAEgMDg5OkACFP/aAAgBAQABCAD2nkJyfD8IyRvGTCcGMyZrSncnJMHTX/p+FLTfCp/3W/DA/wDezny8zqpqKMVulRSdkIl2QiXZCJdkIl2QiXZCJdkIl2QiXZCJdkIl2QiXZCJdkIl2QiXZCJdkIl2QiQLe7zWFVrp6v5cD/wB7OfJCeROIxtMc3gUOq426jutHzUFfrwPWvA9a8D1rwPWvA9a8D1rwPWvA9a8D1rwPWvA9a8D1rwPWvA9a8D1rwPWvA9W4NG7VWcNfQfK0saWHYkpd02aCwxJjQLyCK5WD3ux0nSb5k28LXYdYj8QeRO3OCEzNxBUyZ3xcgM3dI5coMZOWeQM753SkYdxf5j9vQV1g6+t65mYkZGwzJB4doUD0dsq0DokAEVOVDr9k3Lp5mVxrLUN3KvoNhmC2GYLYZgthmC2GYLYZgthmC2GYLYZgthmC2GYINMiS6kltoK/6Ga78n/h8U+EimHjQLW43kHS1VNW01PWUcOv2TcuiIJJx+E3nEI6E6vNpp75bam11eqB1aoHVqgdWqB1aoHVqgdWqB1aoHVqgdWqB1aoHVZm+s1juVNdKT6EhoPMPJ95Itvs6s58fEaMijdiTYyZGRuxho2PCAwBQpYxtpcPpNoYcLGlE1z5rNpP4t91ZDcucT8ewUSfErx+yu55xQ8ZCVVTz8/BS8HNU1M6vEHxei44gGzjEo9cMBasVupy5sec67Ky0yMD0JI7/AMk6IGxLaSMGVKVgXgJ/EJClHIbY3FCTFvifOdD2NEK4DQxauMClFEpg5mt5a2mkgQAwY2nib4jgTd+RVdqix2GvulJtciW1yJbXIltciW1yJCrg3m+X6gtdX9PJn+N7IIsBP4hIUq13i0Xun5Kuy+Jy+0qGSuVzttmoKu63ji5eLn4uPm4XX/acjMq69Wa2VdsoLkiGz+vWestK1CtQrUK1CtQoebj0G8Ud2+pIZn7bIZgXyYG8xAiAMxDh83UPR/F1i8bjFu2bntu3eRKAQfkRbBpWwM8hUJhXITFg7i4YxZj8PRTjozUcBMmx7BpNkkbzJHzz0xUtrPd+oiv0ae3X2fZpozNMbPk+XB4gqiuo3uYai7KVj5ksuKv7Hr+jLVAx7cgn+IbNgH3W6hzaBlwvV48NzR8F6t2TF3W38i8v6p6ctvLby28tvLby28tvLby28tvLby28tvLby28tvIecf168Udp+WS8lGdiIyZ1IJ+bU1E4s9vPZjqQrRNE2jCNoGM4znkdidxJ/Sv8Ag1QRLVBEtUES1QRLVBEtUES1QRLVBEtUES1QRLVBEtUES1QRLVBEtUES1QRIVb682O/UF0q/kzQY0X3yagrBty1PFETxCvBxcfDwwWaqfjXWlxqed+MeCUo4ZEEqb1JH3N//xAA9EAABBAECAwYDBAoCAQUAAAAEAgMFBgEABwgSExEUlKXU1ZXT5RUhIrcJECAjMDNAWFlgJFZCRGJktbb/2gAIAQEACT8A/wBT2G3h4nuKnfCDlJPZTZba2CU6HN5jz0xLklcbZymLrFcCkXG/tM8CDsBYYvMYSELHIIkRrZByl24dOIeG20jaPVYSqR1R2tkxJbdWDutOqsvX41mUssBHzFSFAjJezzlnkiRI1kz7WfdNLIJ/qR2MGOMNiuF4abwSsZlx11odb+E9VTDTr7zjbWV5bQ486tKcKcXnP+RS5fm1xIfrIfFIb7j03x3XGHkc8iGhfI60pK08yFKQrlVjmSpSc9uM5xqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9S8oUO537qMEHlvsr5I4xaOdp11SFcq0pWnmTnlUlKsdmcYz+1/kUuX5tcSGt0UmcTm38EqfsFIXXLKNHZaHio2dlIyLtpEU3V5adhYWZjJSViApV0tgV8rpIfehp5mK0z1xH+n1Wuo61z9J1Dzf7xlbbqeV1tCvwrx29nZntTnOMxHmEp63UR5hKet1EeYSnrdRHmEp63UR5hKet1EeYSnrdRHmEp63UR5hKet1EeYSnrdRHmEp63UR5hKet1EeYSnrdRHmEp63UR5hKet1EeYSnrdRHmEp63UR5hKet1G9AtjqdJ3vh7vJ1Wlsufu3inGlczTi0/iRns7e3HYrGM4/Z2wrNBte/d0J3E3inIFghk7cG7GSM3LFWSfU+S+h6RfkrJOGLWwhhvL0mTnDeMKThOye38RxF3iCZrVr3eCg2GrhNQ7LAAmWCDe3LTZJIcVFgnyQzDEnJAxwIMgYUIIwy3/tlriqNt1Q4cift9tm3HWoqChxlIS8aYphp9/LaVuNtpQyy68664hpptbi0pztF9o8JHEHxAY2UmuJLeClW2HTu3IRc3SALyPsLF5m60VEiUMC8QCpGfucVIGGS9gDDeqUSxFOOTWtzBaDCzL8gBU4tmLlrBaLtMxozRREJVK9CBmmyJyGyBeu+9gSKjkkskS0lHh5USjYIbh62r2t2gou5+2dJucLNg78sxl4zTZKtSu5hb887X2FW6nW2Ot4dfiq0GuDEmI2PXNTWRHpGQ/pqhXb9Q7SKgCzU23RAU/WbFHoJYL+zpyEkmSI6WjnXxmVER5474ZSEdElh1lS21V+DqlXgOJjdSMgq3WokCCgIWNGt3CagaPiYeLHFjo0EdH4GBAx2WGk/hbbTj7v1bYUPcGxbWSxdg21l7pVYWzmUKwm9xw/YqiuaDNxAWHsjQksTsYkaWFQzlApjKHXkuf268MH5Q8N363ugWx3PpO9Np3k6p4rLn7t5DjSuZpxafxIz2dvbjsVjGcS/l8X6LUv5fF+i1L+XxfotS/l8X6LUv5fF+i1L+XxfotS/l8X6LUv5fF+i1L+XxfotS/l8X6LUv5fF+i1JdcR/vnVa7mA1z9IAp5v8AeMitup5XW0K/CvHb2dme1Oc4z/A/um3b/wD2HCdrd/bzZioS9hj6pF2Tci1xFShz7HKNkvhQ4p0wUKw8YsUM091CFZwLGgnyRamAAiiGSGCwy2GihCxXWyBihiG0usEDvtKW08w80tLjTralNuNqStCspzjOf7deGD8oeG7W8+2sBvvf4UixUnaOXuEIBf7RCjd/6h8JWSTG5M9paYmYcFSwwp01mFmng232oeSWLpb7Y5XR6ix1Noex0H2iEcinW3kY7VspwrmbV2pyrGOzOcKwbNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0bNeIB9u0TKOEC9bpoIeEWznrsOjr50tBMrz2IeVlPK4nsVhOc9uMZTn+BH2Yu/8AB7dJy+7LkQljJhosGw2E+kSUk5YY1llxqeFUTt9XMsivraS0hotGFZwUrKa5YZ2u0e7CX2tvVa0ydSlwZpgAyJLYUfGqzgiMl4qQLj5ER9lxfTW2UA+DIjCmsxzEPWqpBxNbr0QLlzI0VBwYA8XExw+XluvZYBAFHGay6445ltpPOtau1WQLI1vpxE1Sm0zck8yxEF1oqEokDUq5ANxFdWykeJJbjKVBJKIaecUS82S6rCckKximzhXEVtVBhQtblQ7VKgVclyIZmBoCbnayM4gWUnIAWdOGjSlvNDLZSEmRDkMxoGR/9qt0Vufv0LDypdQ4bdv5kaX3Hmjo+MLlFE20eKZmHNs6WACEXKz9ztgQ4oULHyT8QBPyY7MOTRmttX94IKcmHaOxY121mAVC3Gx1PoN2JyDra5JJOIDB/UVCg5Z733Xke6HeHnmhhhmnHyCH3EMsMMMoy468865lLbTTTaVLccWpKEITlSs4TjOdR8Zxc7kz249RpN/IoN1ZB2u2qGtJ5kewzPboRMDcIOVvrzwBywKFDNEEoFiZx6elIF+PHDkNXapbd0qCYUTNW68WKIqtaiR0pUrL0jOThYMaGjsSrsUQS3hXZnCe3P3a28mLrtjMUS9WdriZlJU6swtklqKJNPyLe3dIkKuo+1UvJ8MVAIup05X0lzQUymNhjYyPEkpb+k2YrY/EZu9wccYExdt3ph6UsluceltgLyGcHWyJ8+RDo8YWAywAdH0oOAHlRWUYmEyDuXHV/wDSLz+cO4umXyK1eqtYabYRxSHAyX4OzxJcJLMjls5w8K+6AcQhohrOHGHFJdRnCk41tBVtpKa5+k74dZCTHg0HHzdkk8bZb/tolrfbp4yWttwlWWV90FkbNNypYQCGY4N0ePHYGa1R07jbcRd2r9/zUn5ufgo+SsNXbkEwuZZ+tycRJHRg7kk8+TEqOQBJZQ2NJsGAKIDfqddotIqv6NmYiKzUalDR9ercBFjy3EH0QIiGihxY+PFbypS8MjDtoy4tbisZWtas/qQy4QL3XpoIS4tnPXMHHXzpacZXnsQ8rKeVxPYrCc57cYynIUL4c73HQUL4c73HQUL4c73HQUL4c73HQUL4c73HQ0Y2OV3rqLHZLQ9joBkEI5FOmvIx2rZThXM2rtTlWMdmc4Vj+H/ZFxXfkPfdf9IvP5w7i6lI6XEaKLBdKizhjx2zQH1inBuPCOutoKDJbcHLHUrDw77a2XkIcSpOP8mHDt+Wm/mpAGJiwGFknyUkWwCAEM1jtcILMKcaHGYbx963XnENox96lYxpxDzLyEOtOtLS40604nC23G3EZylaFpzhSFpzlKk5xnGc4zjOv8dc9/8AbcQWpaMjzpslwOGDOPFELly2WVEOixg77rbx5LQ6FvuMCoddQylTqk4QnKsaI7p3vu//ACOj1+n0CmCf5XVZ5ubo8n8xPLzc339nLmw+U/U9WHyn6nqw+U/U9WHyn6nqw+U/U9TPe+6d4/4/2d0Op1xXxv5vfnuXl63P/LVzcvL93bzY/hzB1dh98dntzNn5WwRjDBUlBRu5lLm6WdMR4xWcCknRgs26aIwTnDDz7Dbb2cNqVq52a2VjbypWmoi3QxAkDajhLVP2SeKOR9lc40bIhOWR9kEgXmyzkUcjsy7zY1uluLumPuhuKq/SUlfMxgjcXkaKHhIsCMhoZpqObOxHDN4n57CUF2EloRTg4IUdHgC7gWTboDabiFofELHSlYjIuULl5mh167V4SvGsyqkssRh7N2KIJKY7SmnQR0tYyhxzV8t+20PdJCqy2LXTcsPHhn1KxR9iAZkYcxxqPsMKSQAls2HOcabUvu54z4siAEUzYLHaq5sxQYGhQ9ithAxFglw4MXDCDJBQbAwbHOrmSKCIw2LGhJGjx8ZZGQrO4dmGu+3mwxuw4W2zUXFLqsjEmlXkpc8VLLV9rtSKFXktCRmk92zgEfOc9rjmt290dvZjhMt7lmh4KklhpjbUwuy1W2d1w+bhT9SllylRjmCrLBoXIFxWUhvNZfj4c2O/127RO3u1+3sSuZtFomVu5YFYy60KGEEGK0RIS81LyBAsVBQUUKZLzkuYFFRQRZ5bDDn6Mf8ASP2LhTSxmVVxEAbMguQjlTHbddkLsJFMTJUQ9UhGR3yvtx25jR6REJWcRHkryIi6i3nbe2ofbFkGxyY+TiJcBSWpitWSGObZkIOxwhKsDyUaY0lWOZkwR0uNMBNJ/qJ3b8Xh6oXFDTd2OK2p3KesEPJ3vbisnxQuYGsBxFYsEdYjM12UvmcQtjMhIp6Yerz6zMKYySCbXqNQKHWyJCSkDHQK/VqjUq1GqfJJIdXkWMhYKDiQ1LWrPdwo8EbP8plrsxELguFzdrjy3EmuG6NbiioWKzVBDpwlwqvgPDhjIh2KvNUCvt9xEaaFMrxsQ9yERTgov6o7v/f+9/8Aq+69Luvdv/jEdTqd4/8AZy8n/lzfhr3m30zVe82+mar3m30zVe82+mar3m30zVe82+mar3m30zVe82+mar3m30zVe82+mar3m30zVe82+mar3m30zVe82+mar3m30zVe82+mahu6d77x/wAj7R6/T6Ar5P8AK7izzc3R5P5ieXm5vv7OXP7FtGpu2u38Zg+YknEKJPPLIeQJEV6vxjecETNksMm8NFQcSN+9MOJawtbA6XyGX7TwTfopZAsKwUfh9r57YXEBxUwQhGDa7Z9yprAxDVep8w62PMBsZT9jfZ+I1dWr9lLzF7ttUyF2+2y2+hWK/T6fX2FsRkNGMLceUhCnnHyzDDC3yZGVlZEkuVmZUs2WljTZI0op79TwTPce/dXvjj7fN3nufT6fRGI7ezu6+fm5OztT2c3bnlNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aNhfEHe3aJjHBxe9dRA7xa3s9cMgdHIl0JlGexbycq5nE9icKzjtzjCc/sb4UbaepbXbgT25V1gr9WpS1Ql3srEZFxO37z8ME08AcNWwy70yYFMtPgmM2TDKhX0Zewn9K/w4sssoQ0001wi7aNtNNNpwhttttG2mEoQhOMJQhOMJSnGMYxjGMY1xS7e8T0tMSNbe23kKDtTXtrW6hHBjS6LKHJj1+u15uZXLkkQz4jxLZKw0gEIbW2khSVcZlt4rWd8NyI+00CNn37S8DRI2PNuBclLoHtM3NphZ+6JskUxN1+sKYrsY1VIxDJszhY2Yv8A2b//xAA6EQEAAQIEAwMICQMFAAAAAAABAgMRABIhMQRBUUBhcRATMjM0YHOyIiOBkaGxwdHwFELxNUNUk8P/2gAIAQIBAT8A906NBqkps406cH6cpO2l9Dm91z9McXSpU40GkNpwZKreXoooth15B+Ha+L9VwfwT5afa+L9VwfwT5aeGjUKRWY/VrYlc6pte4XLXt+Z2qVScyJKSkC0R/tNCx9xhqVGBTZuQbkb6D/OW3vbGMpyIxLyWwHNwcGRpVZVJfWQhn83FHLcUztnezoO3PUtilRqVpZacbpa7sA81f89MV+HhSo05xnnlKbGSJk0uOXS+iWvfXXTbs4sUYqJsjZPB5Y4ZWhxqqrTjddV0qc/ISlESMpBItIFMx0bbnc4q+w8P8SfzVO0cL6jjPhx/KpiMJzbQjKTa9oituunkq+w8P8SfzVMEJsWZGTAbMgco97tzPvOzwqzpxqQja1UIyuX0LmnT0nFGtOhJlBLplbly2/5mFVV1VVeq6uGrOVOFJtkgrHTW6q3ftcRr1I0pURMkm7prra4PRt+3vXR4epWSxlhcvOWkS7bS9szyA522xWp+aqzp3zZU1ta9wdrvXr5KPB1Kgyn9XHKpmPpSt0io5dS691t/IDJtEZLsAr9xifCTp0WrOQSGJ5s1S9vSR0dRtZ08dOyUqtSVTh6bJyRq07R0D0ze27437scZ7TV8T5Y4FikjcRPEbmOEqTq1qsqkmT5ie+x9KGgFgO4DyU6k6Us1OWWVkvYdHfcfvwLLgKqqrXFVuvq93stD19H4tP5zHGe01fE+WPk4D1tT4E/mh5Y/6fU+Mf8An2WEsk4TC7CUZB1yo2/DFWo1akqiAyRtuaAfpjiOIeIlGTGMcsbac+e7y6HLFGs0JSkBLNBhrfQUb6eGKNVo1CoBK19HvLb8nvxUm1JymgMlbGxfBWShKhlLSnnza3vpp0/txR4howqwIxkVCyvLRPtNdn9/d6EJTkQgMpSbAfzbq7Bj+jb5GvQKm2TNrfptv3WxUpzpSYTLSPxOSPMevaeGrQo+dkjnabGmgISeupbW2pyvjVbaqviq/mrjjv8AYjJvUjRCpzb6b998z9t+faacJVJkIF5O36r0Dm4ZUuEuQtV4jZm+hTeZE5p/lPRxKUpyZSWUpN1ef8/DY7TwteFBnKUGTIIiIIc9e/TbpjznB/8AHqf9j++KsqMsvmqcqdr5s0mV9rbra2uK9WnVKeSkU8sbKW1200tcLaLrry95/wD/xAA5EQACAQEFBQQIBAcBAAAAAAABAhEDABIhMUFAUXGRsRBhcoETIjIzNGCh8ARCwdFDUlOSwtLh8f/aAAgBAwEBPwD5TeoEIUAsxyUfqdPrai7sagc4q0QIgZyBy79ro+3W8Z6ttdH263jPVrX1LFJ9Yaf9y++O1BVUkgQWMnvNrq3r0C8cJ1+bSQASTAGZsa0ugUeqzReIOOU3eE68t9mdUEsY3bzwFqdVndlK3QACAc9M+IM5bOQCIIBG44i1UAPQAwF44DivYQDBIBjKRMcN1l+IqeFei7RV95Q8R6rYsFEsQBliY7F+IqeFei2vKCFkScQJxPls7IGKsZlDI+mfKzorgBtDOGFgIEDIYWCAOXxlgAd2EftY01LhyPWHLunh81vVVBiZbRRn57h3n62Rr6hoidM9Y7HrqpAHrGRMHAeeOPd2EgCSQBvOAstYNUCKJEH1uG4ajDP7OyOihajAesVaTnod+Xlaj7pOB6mxEgg5ERztWVURQoAHpB0bM5nz7GVXEMJEzH/liAPxCACB6PIZfm2Wp7t/A3Q2o+6Tgep7PxHsL4x0btPxCeA/5bKwvKV3gjmIsi3VCzMAics7U6YpggEmTOP3zOtqiekAExDBuU/vZ0DqVJInUd3WyrdULnAjGxSagqTkt2Of72emHKkki6dNdfI4Zj5eJCgkmAMzb0+op1Cv80fXdHnZWDgMpkH7g7TUQvdAi6GBYGcQN2HH6WwA3AcgBah/EI9kubvDH9I+xtLMFBY5C0PWxaUp6L+Zt092vSfasAFAAEAZDaatNqgUAgAEkzqdOWPO12v/AFF/tH+tkDib7BsogRG/QWpoyXrzlpMjPDPHE5nXh8z/AP/Z"
  },
  {
    value: "ORDER_LIST_3" /* ORDER_LIST_3 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAAzAAEAAgMBAQEAAAAAAAAAAAAABwkGCAoFBAMBAQADAQEAAAAAAAAAAAAAAAACAwQBBf/aAAwDAQACEAMQAAAA7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcdPpZewDzdXrAAAAAAAAAAAA1LsjURpqk6Pb3clw8g1gAAAAAAABlxsQADmI355/r7oddHoOx3bt1T/ExEAAAAAAAH2mTgAgicZ3hKBpx842KhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAa6zjSzqqkyPb5MlwxggoAAAAAycnUAAAAqZ0V6sWQ0Nuh1H+fpnCPfMMEAAAAAPUM6AAAAIllyoHTVYTTPHOt8qZgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACqfRXaxnsAAAAAAAAAAAAFOGmq4/NaMfIdAAMhJhAAAAAAAAObrbR0YYr/VPFIxAAPaJOAAAAAAAANAboRZLlqOewAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACte+vR26G9tM7HaLAAAAAAAAAAABzG7895GS6h7XT1F4NA+IiQAAAAAAAHtEnAA5evQz2c551N6K+rDz9I88g0AAAAAAAGQkwgApz01QxOORc7NsJWyZ7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB//8QAKRAAAAYCAQMEAwADAAAAAAAAAAUGBwgXBAkDAgoWEBUgQAEwYBk6cP/aAAgBAQABCAD+Unrt9m238+XqcOOpAfE6pIiVTp77E7JREEL4hP8AyZP9X+t/GVOmFbtQ+nb3yGVbkwkzo2O16KDl5OEhO+bh8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQ8kUQQp2c5iqK8fL+G8fPM5tSwgRp0ReL288e8LGx8LCYllCnSbuva5pSjk2JxG4ps8GvTqGTj8OZj5GJkV4jxXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jwXI1NlWZw5+B8C2MTBFEgD+VBeHtjAwMj8lu857+uI8aOSRvFLrk/4RLZdvi2kb3cWsaWz1Rz8fVtyN3Zc6f5TycNnrnFrwmD6LIxzCpNmWfgWGsBYawFhrAWGsBYawFhrAWGsBYawFhrAWGsBYawCNWSkNVIW4Gf+ndlNdzoEa/HOfJl210lsYu2qTjszH7fvoYPh2dbW8OLreSXj47TjOe0TYg5Kcc8Lckry6oToqhOiqE6KoToqhOiqE6KoToqhOiqE6KoToqhOgmb4mIzLGNMT9L6sW1El2lXDGPgi+3yh6lsAuRR8wkBI0RlfN45AsrG/WxEuKEhpBSfZX+wU+zrJTu09D6z+j7Stmu+RPvBbCB2F6Ko2yCMhzzTEtdRC11ELXUQtdRC11EEq4JyeH2AV5f0XB/2jWMGSekmEaFhHmBQk/vxPmFIqEVCKhFQioQnm49hOMM2+keQCSB5seRuxzlkPqma+RGwiNOww7/ndjGzto9a5Wy2e6HF3AqX/PLx/jmgttSiRsGz1kkmY+x3CxwUJ5+tLB+f8s64RcHHyc3Mh1CiZvdw21knYZehlme3l2fni3hbwt4W8LeFvC3hbwt4W8LeFvC3hbwt4W8E84/vxxhlPx7jFHplwnh03IFa/wCErVEH7agg027ItauLB30N8TkzyozweGqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEEq3xyRn2AaZfw2065XqntlxEVLD9UXe4M6unq6fxGLT24BTKhLzh2Cv9BCTzqbKoyTDQ/wDTf//EADkQAAAGAAMGBAMHBAIDAAAAAAECAwQFBgAHEggRE5Sl1RSV1OUJFdMQICEiM0BgFhcjJDAxWXC2/9oACAEBAAk/AP4pPKrfDz+Hdmjs5ZObXtfaVOtv0LvYMwbbMRmYR/nstWZO2xknGzISmWyKtfmIiMj5es198q3eHsLYszINpeAscTGz0HKszio0k4eXZoyEZINTiBRO2esnCDlA4gAmSVKO4N+79yqxD+1WXU3MVtjIKlSbT1+fplhMuqwYTHIYf6lvMnX4Q3DEyhE3x1SkPwxKJSyGaXxGahmJnrm9Zp5kZeXZ27PCKLIZYWJ4DxmRynO0yJbUe7+HWZ6Ym+DMLtkFBEVXBjs8+NgrMmzbK+ZEI9VVNKs4imPHKVAcOEXCp3SbFlDIPaExVWRaFXWy/kOE2IVId/2KHSWSiJJVJVI5k1E1E2axiKJnKIGIchgAxDlEDFMACAgIYn5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4l5R03U8dxEHD92uifRHPDk1pKqmIbScpTl1FHSYpTBuEAH7s7Lx0VnPeU9oTahkawuqnLVzJaipzhItFZb5bIxKKsgwh8xpuKQnCLMULjA5dun0csm+jTqbcHxRWjNogk1aNGu1uzbtmrZumVJBu3QSyxIkigikQiaSSZCppplKQhSlKABmDmjdNmL4m+VTqoEu+ddqaWe0qbStXsLt7Cf1BZo+s19OyTrifkIurwoqNvGCpnwJ5JdczNNwOaJR2q3FbGyJ5fp1uyrMygWmLZkDBL2lKKPXGtk/tyge9BFOZJExq6ZFYqovHDdkrgnEbukVW66eoxNaK6ZklSayGKcuohjF1EMUxd+8pgEAHER1CU9biI6hKetxEdQlPW4iOoSnrcRHUJT1uIjqEp63ER1CU9biI6hKetxEdQlPW4iOoSnrcRHUJT1uIjqEp63ER1CU9biI6hKetxEdQlPW4iOoSnrcRvAdocThK+Mfq6OKkdFT/Gs6USNqSUOX8xB3b94bjAAh9zK2robQ9oqCNCnM2RQcr2t5Tm5IUiNfK4cOVWrOPKSuw5dDFq2OYGptahvFPPEYytrOYr/KS2oXvLORnEnZZKj3Bqo0Wb2GuyMe7ZPY6RSWYMVyqorgHHZM1xKKrVA6eSlBPtLIV0aojnKeFSNdEYQYpSAFFJ8JhRTfDXlla2MyRuE0NbVUrwyHyU5mI/8AojKv+9efcPVjkypy0O/jo5pYLjKv2UNGOJRzKy0CzNCV00ie0TzMZqLdSUNCv45g+bP3TZUvxbtu/K/aTvMAwtUrlzs55gsMqsmMop+WaN36FHe0KomRr90/pM5koueWiXFbj5Z62fItXTxsp85kcxCZ3Zs7D90qTen58mhmcHM5nZUXdpIKV1a3x8cUWxLHGx7GClVH7p1JTL8lrWYTEtMv6+vOy32LcB2h4PhK8NJXRxX7VFT/ABrEUSNqSUOX8xB3b94bjAAhL9Pi/RYl+nxfosS/T4v0WJfp8X6LEv0+L9FiX6fF+ixL9Pi/RYl+nxfosS/T4v0WJfp8X6LEv0+L9FiS47RfxnFS8GwS18Jg6WT/AMiLVNUulVMhvynDfu3DvKIgP/C0Zjmm9naflxS7BJxyUxGUiSu8oZm5ujuJcpLMJFzCxLWR+QtpUikOa0OYM8uzlo4jmGkdsLa72nMx7LTo2/3nNKY2pbhUss2KkpDJT0q7y9iapJRkVW8umbdZReK8ZMSzZGKJ4tF40jzIsmlkn7hkHFwmUkNlta7LZZm5SdkiISTl4l5Np2qwLOJewQ8lNMpN3W5V0sqV5XVYpVscWhkMZzZcX3M/JaQJFZrUSq2uImbNQpIzpzHqMrJFsnKrlg5ZybN3EySRyiaKmGy8TJA1kkjtQwddNu64PEO3MmRYOAuk4JoMqmsQN50SgbUmbeUTAG4RAwPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsOZRRw143DI4WaHRHjoKtz6ypMkTjuIsYS6VC7jAUR3gAlH/hpcVmBlbmLDmhLXVpcFit3rYHCD1m7au2ird/FTEPJtWUxAzkW6Zy0HNMGEvFPGkgzbOE889u3M/IeLVRM12X8wtqaxK7PIN2yoLNY5WjU+Cpz5aMbqAIlYqWAyKxTHTdAukochqavSbjnfVstaVa4KJeJs6BE1fKWtRtSpENTKWyaNYqqsYuDiWLUW8eUEVOEJgTJq3BRpWvZr7Sj58+zDfvLTNS8M1NNWJW4WZrVIR84UaQLGzW06dglGhfEpN3bVoygwh4ZAsZ/Mdl/NWSQt+XC18W2iEXgJVCN01OYtia7et/IFiSNGRGHVqMreFbfGKx9+ONYRrD/QR+t+6f1suz9ati6Qzwl45Sut1LSe+N7RmHEpuELMKwOUIwGdbjCjGlRFMVCrH171hAPsIio4a+F4ZHBVDojx3jdufWVJRE47iLGEulQu4wFEd4AJRZQvLvu44ZQvLvu44ZQvLvu44ZQvLvu44ZQvLvu44bRibd14riHbouyLBwGbhwTQZV6sQN50SgbUmbeUTAG4RAwfsf8Axny//wB3nDiYimk3NEeKw8O5kGiEpLJRyRVpBSMj1ViO35GCJyqvDtUVStUjFUXEhBAfsceE8X4f/Y4PH4fAdIOf0uKjq1cHR+oXTq1fju0jYek+54sPSfc8WHpPueLD0n3PFh6T7niZ8X4TxH+v8u4HE47Vdt+r45bTp42v9M2rTp/DfqD9jmBZELrTdnp1s9tst04yLNVnsM6mrVNGsK8qY3zZOTIranCINUy+FFNoiYR1HPjNnNWs3zZwiYSIj6BBPY49OsyFVm7PYoAp13jdSUrzZzI26Xb3BhGqrMbVEcFlwIlyrJyEl/HcsM6c1X+fFylaJRa5klX6zZLE4sUY3iVk2KkXYbbVlnbmWWmWTCHZw/zN89fHFuVsQ5keL8L34taaIqEBVRLZRjllSJCYAUOmkfMNAqqhS7xImZZEpzABRVTAROE7cqnm7lykd1fsiM5Kktl9m9VI9N8SLVk3lfO9lomUj2cmojGy69bn5sa8/dRzSxEiV5eII+/cSkdBwMH8QOnzE3NzD5tGREPERlyyieyUpKST1VBnHx0ezQWdvnztZFs0bIqrrqppJnOG2PsqoookOqqqrtC5RpppJplE6iiih7eBSEIUBMc5hApSgIiIAAjhUt1yM2YdmW5UTah2iaSzcq5SZl3eegMxK/T8uoq+MShWL9NQx7zRpls8j3skZ9HU96DM7mLprZ4h9ifG8CydPOFr4fF8Mgotw+JpPo16NOvQfTv36Tbtw17q3tmK91b2zFe6t7ZivdW9sxXure2Yr3VvbMV7q3tmK91b2zFe6t7ZivdW9sxXure2Yr3VvbMV7q3tmK91b2zFe6t7ZivdW9sxDeE8X4j/AGPmPH4fAaruf0vAo6tXB0fqF06tX47tI/chmdjpt428K9T7bXpEpzx89WbNaMp4WehnxEzpqHZykU9dsXJSKEOZBc4FOURAwbDOSHlUz3rEncKHkDt5Z0SeQueuyateLXasqV3D6w5YVlpmxT61aZSedwE/XlMxgnpaVYPEflxYBlFtFGleslijHf2GIVZ7HvWiRlRMCZVHLZREhlBKU5gIBjgJxKQ5gLvECmH8BewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3YewvMPu3Ycxijdr4riEbrOzrDx2bhuTQVVkiQdx1iibUoXcUDCG8QAo/czko2TF+2Us5nGdEBOXqsSVrj3NiZK1eRq50otkB2zgsXNVlu8dtZJJZm9QMDdRI6ZlCj8UDZbIJiiAHLsn1cTEEQ3AYoHqZyCYv/YayGLvD8xTBvAdsO37ce0Tly3cp5PRrqmRWXGT2UTx6m5RcStaokW9fRSkm2BfxcMaIi6hEx0uJp51CytgbxMvF7ZV0y72fMnqynF3/AGb2UjZyRFukWi9nXfFZQ7CRbU2Rjr+2l4SJtrizRziXjG1fReRTl8sSHbwf8m//xAA9EQACAQIEAwQFBw0BAAAAAAABAhEDIQAEEjETQVEyQGFxFGCRodEiI1OBk8HhEDRCQ1RkcHJzgpKxsvD/2gAIAQIBAT8A9VKOWpNRVXHz1dXamZNgoBGxiCIN5ME9DBEEg7ix7zSpmrUSmP0mAPgN2P1CTjMV4zQZOzRKooG0IflDyJkeIjGcQLV1r2Kyiop5Se177/3d5ynzVOtmSBKjRTnYsY+Ki3InHpjn9Vl/svxw7elZVmhQ9BphBA0EXgSYEXP8mOBU4XG0/NzEyOumYmY1W8+8cRygp6joBkLym9/efyLUdNQRioYQ0cx0PtxxH0cPUdEzpm07/wC7xtN9/wCBNMIzqHbQhPymiYG/tOw6TOGzFFGK08tSZAYDONTMBz1G4nlvHuGZpoFpVqa6FqgykyFYbx4bjoI2Ex3nK0lrVlRuzBYgWJjlPjzi8THXDZpwxWlTp0wCQFFMFt4hiQZPWwvjOa+Bl+IAHltQAAgwLQLAxv44KOqqzKwVuySCAfI8+8I7U2DodLLcEf8AvaMHOVTcLSV/pFpjX5ySb/Vh6zuioxkIWI6ksZJJ3Mk4evUqIlNzKp2bAcoE9YFh8fXEUJy5r8RbNGjmbgbzY3mI7N572KSHKtWvrFXQL2iFO3W/e1/MH/rj/lcfd3oViKBoQIL69XOYAjpywmYZKL0QqkPNzuJAB89hHQ9fV6hQavrhlUIJYsSBF+gO0GZx6H+8Zf7T8MVcvUowWgq2zqdSnwm1/MX5bHvOSEpmgLk0iABzs2ODV+iqf4N8MEGlkmp1bPUcNTQ9pQCpJK7rsd+vU95yRIXMkGCKUg9CAxBx6VmPpX9v4YRjmaFfiwXorrSpADbMdJIAkHTAH3gd5y1daPEDqWFRdJAMWvPuOOJk/wBnqfaH44fMg0zSo0hSRu1cszebWMdZm1pi2Eq01oVKZpBnY2qWkC3M3Ecote/j6zf/xAA5EQACAQEEBAwCCwEAAAAAAAABAhEDABIhMUBBYYETIlFSYHGRkqGx0fAjMhA0QlNjcHJzwdLh8f/aAAgBAwEBPwDoo9Vw5K/IhUNtnPVOzcOW2eOku1xWbkHjq8bU6fwiDm4JO/LswPXagxKXTmhKndl6btJrcdkpA5mWjkHsnrjZbgF59Tvf5ZRwNUCSVqCJPOnxP9rX1v3J40TG6e2MdIurevRxoidn0MqtEiYMjYbXVvXoF7ljH3GHVh+RLEhSVEtGA2+8bCm5EtVcMcYUwBsgZ7otSZrz02MlDgeUbfDbjpNVyiEjPADZOv3rsKKkS7MxIkm9hu2WoxwtS6ZWMDvFgykkAgkZgHLSCAwIIkHMWFBMpcjmluL2CPOwRVYsBBIA2ACAIG6y01VmYCC2fnhv6Y8J8QU7pxE3tWU9mqZzwjSy7CsqfZKTvx17tLP1hf2/7aWUmoKk5Ldjtx8bNTDOryZXVqw8s8eXo9UqCnEgm8YEW4b8Op3bJUV5AkEZgiD78tek1vmo/r/lbX05694ethD1wy4hVIZhkTBETkcx2bNJrgFqQOReD1ErbgaXMHj62YcFUp3JAc3WWSRmBOOvHw5J0mrTZ7pUgFTOO70tdr/eL3f8stI3r7tfYZYQBu8sosyMaisHIUDFfeGOuf8AnSb/2Q=="
  },
  {
    value: "ORDER_LIST_4" /* ORDER_LIST_4 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAAzAAEAAgMBAQEAAAAAAAAAAAAABwkGCAoFBAMBAQADAQEAAAAAAAAAAAAAAAACAwQBBf/aAAwDAQACEAMQAAAA7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcdPpZewDzdXrAAAAAAAAAAAA1LsjURpqk6Pb3clw8g1gAAAAAAABlxsQADmI355/r7oddHoOx3bt1T/ExEAAAAAAAH2mTgAgicZ3hKBpx842KhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAV8XQ0+theRkuAAAAAAAAAAAAjOXOevZR0wYdAxggoAAAAAycnUAAAAA5n92e/PHfNse+YYIAAAAAeoZ0AAAAAag2wwbrfemYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqn0V2sZ7AAAAAAAAAAAABThpquPzWjHyHQADISYQAAAAAAADm620dGGK/wBU8UjEAA9ok4AAAAAAAA0BuhFkuWo57AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK1769Hbob20zsdosAAAAAAAAAAAHMbvz3kZLqHtdPUXg0D4iJAAAAAAAAe0ScADl69DPZznnU3or6sPP0jzyDQAAAAAAAZCTCACnPTVDE45Fzs2wlbJnsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/xAApEAABAwQCAAYCAwEAAAAAAAAGAAUXBAcICQMWAgoQFUBgASAZMDg6/9oACAEBAAEIAPqmeu33Nu3+fN6rh46sD8zlLEyk498jOzKJgwvxCv8A5Mv+r/W/TFOmE3tRfTy9+QxXcnCSuxsu16EHLycLC983D2QiXZCJdkIl2QiXZCJdkIl2QiXZCJdkIl2QiXZCJdkIl2QiXZCJdkIl2QiQK9vNYVNdPV/pvHr3PNrLDAjToF0vl58e6Kmp6KisTZRp0m7r7XWlaOTYniNxZs8GvTxKpp+Gsp6ikqI8D1Hgeo8D1Hgeo8D1Hgeo8D1Hgeo8D1Hgeo8D1Hgeo8D1Hgeo8D1Hgem4NG2qs4a+g/RtxisE0ZAP+VDer24wWByPqbd117/HiPjRyZG8WXXJ9uzt2b4p69GVmnPTbsqyM2EF2dDLkN8l7svaEmuOMXgJND/+2d+XqZONY1DblX0EhmCkMwUhmCkMwUhmCkMwUhmCkMwUhmCkMwUhmCDTIkdSRtoK/wDr0P8A+2d+SZ8k8fiC9hNjayJ5aad8balrq4oHVFA6ooHVFA6ooHVFA6ooHVFA6ooHVFA6ooHUzW+ZmNypnSk/rxpwesPidcTJy6FoAzWniYB5unmwce+4E+zqpHdp4PrP8Hyi3Ne+TPvBthgdRehU7VDGw17pSSuRKVyJSuRKVyJSuRIVuC8vj9QNdX8G4P8A1G2MVS+slE6NjHWIhZ/fmesaVEKiFRCohUQoetx7C8Ubt8J8wCEHzY8G7HOXIfVNa/IjYRjTsMe/ruxjZ3aPWu12Wr7ocXmBRf8APLx/jmwW2pYkbBq8yErMfI8ws8NA9frSw/v/AC514RcHHyc3MDkITm95hu1mTuGXo5Vnt7dX16l5S8peUvKXlLyl5S8peUvKXlLyl5S8peUvIeuP788UbT+vmMQ8ZuFeHTcAmv8ACVqiV+7UMGm3ZFrVpcHfR3pOSvanOh4YoIlFBEooIlFBEooIlFBEooIlFBEooIlFBEooIlFBEooIlFBEooIlFBEhW3zyxv1A6Vf6badct6s9qvEQpsP4sXfMGeLw+Lw/jGLT3cBpyoF84dgt/sEMnrqbKsZMwwf7N//EADkQAAAGAAMGBAMGBgMBAAAAAAECAwQFBgAHEggRE5Sl1RSV1OUJFdMQICEzQGAWFyIjJFkwMbe2/9oACAEBAAk/AP2pPKrfDz+Hdmjs5ZObXtfaVOtv0LvYMwbbMRmYR/nstWZO2xknGzISmWyKtfmIiMj5es198q3eHsLYszINpeAscTGz0HKszio0k4eXZoyEZINTiBRO2esnCDlA4gAmSVKO4N+79SqxD+VWXU3MVtjIKlSbT1+fplhMuqwYTHIYf4lvMnX4Q3DEyhE3x1SkPwxKJSyGaXxGahmJnrm9Zp5kZeXZ27PCKLIZYWJ4DxmRynO0yJbUe7+HWZ6Ym+DMLtkFBEVXBjs8+NgrMmzbK+ZEI9VVNKs4imPHKVAcOEXCp3SbFlDIPaExVWRaFXWy/kOE2IVId/2KHSWSiJJVJVI5k1E1E2axiKJnKIGIchgAxDlEDFMACAgIYn5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4n5rzR99fE/NeaPvr4l5R03U8dxEHD92uifRHPDk1pKqmIbScpTl1FHSYpTBuEAH7s7Lx0VnPeU9oTahkawuqnLVzJaipzhItFZb5bIxKKsgwh8xpuKQnCLMULjA5dun0csm+jTqbcHxRWjNogk1aNGu1uzbtmrZumVJBu3QSyxIkigikQiaSSZCppplKQhSlKABmDmjdNmL4m+VTqoEu+ddqaWe0qbStXsLt7CfxBZo+s19OyTrifkIurwoqNvGCpnwJ5JdczNNwOaJR2q3FbGyJ5fp1uyrMygWmLZkDBL2lKKPXGtk/lyge9BFOZJExq6ZFYqovHDdkrgnEbukVW66eoxNaK6ZklSayGKcuohjF1EMUxd+8pgEAHER1CU9biI6hKetxEdQlPW4iOoSnrcRHUJT1uIjqEp63ER1CU9biI6hKetxEdQlPW4iOoSnrcRHUJT1uIjqEp63ER1CU9biI6hKetxEdQlPW4iOoSnrcRvAdocThK+Mfq6OKkdFT+2s6USNqSUOX+og7t+8NxgAQ+5lbV0Noe0VBGhTmbIoOV7W8pzckKRGvlcOHKrVnHlJXYcuhi1bHMDU2tQ3inniMZW1nMV/lJbUL3lnIziTsslR7g1UaLN7DXZGPdsnsdIpLMGK5VUVwDjsma4lFVqgdPJSgn2lkK6NURzlPCpGuiMIMUpACik+EwopvhryytbGZI3CaGtqqV4ZD5KczEf3daJyQzHuzFdfKzJSgVyTtmaGaL4jssa3jqvFNEk4pp4uVUSjU5KxzEJFeMVTakdqvFUGq2U1PyUf7NeckBl7XMuYRjPpXCng/d5hsZ+pZly8zOP2s/baw/p7eKkJCIgam0PIpShgh0UlW7dp+pywoNhzVpMU4hKVmNO1KDl7rTYl44VdvmNTskgxcytbQkHCplJEIV0xM/EqRXhlyIIlT/wBily/9a2kPtW4DtDwfCV4aSujiv2qKn9tYiiRtSShy/wBRB3b94bjAAhL9Pi/RYl+nxfosS/T4v0WJfp8X6LEv0+L9FiX6fF+ixL9Pi/RYl+nxfosS/T4v0WJfp8X6LEv0+L9FiS47RfxnFS8GwS18Jg6WT/uItU1S6VUyG/pOG/duHeURAf8Aj/2KXL/1raQxnPlrK5/U2CbWa05OsbhCOcxIKBdpMXCUpI1VN4aWQbFbSsQ7ciLbWzaTMM7dkQby8aq6wddNu64PEO3MmRYOAuk4JoMqmsQN50SgbUmbeUTAG4RAwPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsPZrmGPbsOZRRw143DI4WaHRHjoKtz6ypMkTjuIsYS6VC7jAUR3gAlH/AI4+zM7XtcZrSGc2cS09Y3M4xe3aTnLbYXS8AyXRSJBRwyV1nDEj0DKpkRUbJAfc3KI0uaR2kcxIJaEm5p1aph5WGir2Ji4CXnYWrLLCxjZ2bg4dlFyLkp1WgN/FqMWLJ3IyDl1+8Nl/NWSQt+XC18W2iEXgJVCN01OYtia7et/IFiSNGRGHVqMreFbfGKx9+ONYRrD/AEEfrfqn9bLs/WrYukM8JeOUrrdS0nvje0ZhxKbhCzCsDlCMBnW4woxpURTFQqx9e9YQD7CIqOGvheGRwVQ6I8d43bn1lSUROO4ixhLpULuMBRHeACUWULy77uOGULy77uOGULy77uOGULy77uOGULy77uOG0Ym3deK4h26LsiwcBm4cE0GVerEDedEoG1Jm3lEwBuEQMH6H/WfL/wD3ecOJiKaTc0R4rDw7mQaISkslHJFWkFIyPVWI7fkYInKq8O1RVK1SMVRcSEEB+xx4Txfh/wDI4PH4fAdIOfyuKjq1cHR+YXTq1fju0jYek+54sPSfc8WHpPueLD0n3PFh6T7niZ8X4TxH+P8ALuBxOO1Xbfm+OW06eNr/ACzatOn8N+oP0OYFkQutN2enWz22y3TjIs1WewzqatU0awrypjfNk5MitqcIg1TL4UU2iJhHUc+M2c1azfNnCJhIiPoEE9jj06zIVWbs9igCnXeN1JSvNnMjbpdvcGEaqsxtURwWXAiXKsnISX7dywzpzVf58XKVolFrmSVfrNksTixRjeJWTYqRdhttWWduZZaZZMIdnD/M3z18cW5WxDmR4vwvfi1poioQFVEtlGOWVIkJgBQ6aR8w0CqqFLvEiZlkSnMAFFVMBE4TtyqebuXKR3V+yIzkqS2X2b1Uj03xItWTeV872WiZSPZyaiMbLr1ufmxrz91HNLESJXl4gj79RKR0HAwfxA6fMTc3MPm0ZEQ8RGXLKJ7JSkpJPVUGcfHR7NBZ2+fO1kWzRsiquuqmkmc4bY+yqiiiQ6qqqu0LlGmmkmmUTqKKKHt4FIQhQExzmEClKAiIgACOFS3XIzZh2ZblRNqHaJpLNyrlJmXd56AzEr9Py6ir4xKFYv01DHvNGmWzyPeyRn0dT3oMzuYumtniH2J8bwLJ084Wvh8XwyCi3D4mk+jXo069B9O/fpNu3DXure2Yr3VvbMV7q3tmK91b2zFe6t7ZivdW9sxXure2Yr3VvbMV7q3tmK91b2zFe6t7ZivdW9sxXure2Yr3VvbMV7q3tmK91b2zEN4TxfiP8j5jx+HwGq7n8rwKOrVwdH5hdOrV+O7SP3IZnY6beNvCvU+216RKc8fPVmzWjKeFnoZ8RM6ah2cpFPXbFyUihDmQXOBTlEQMGwzkh5VM96xJ3Ch5A7eWdEnkLnrsmrXi12rKldw+sOWFZaZsU+tWmUnncBP15TMYJ6WlWDxH5cWAZRbRRpXrJYox39hiFWex71okZUTAmVRy2URIZQSlOYCAY4CcSkOYC7xAph/AXsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HsLzD7t2HMYo3a+K4hG6zs6w8dm4bk0FVZIkHcdYom1KF3FAwhvEAKP3M5KNkxftlLOZxnRATl6rEla49zYmStXkaudKLZAds4LFzVZbvHbWSSWZvUDA3USOmZQo/FA2WyCYogBy7J9XExBENwGKB6mcgmL/ANhrIYu8P6imDeA7Ydv249onLlu5TyejXVMisuMnsonj1Nyi4la1RIt6+ilJNsC/i4Y0RF1CJjpcTTzqFlbA3iZeL2yrpl3s+ZPVlOLv+zeykbOSIt0i0Xs674rKHYSLamyMdf20vCRNtcWaOcS8Y2r6LyKcvliQ7eD/AHN//8QAPBEAAQMCAwUDCQQLAAAAAAAAAQIDERIhAAQxEzJAQVFgYXEUI3ORk6Gy0eEzU4HBECI0QkNUZHKCkrH/2gAIAQIBAT8A7KM5ZpTKUrHnn0rU2ZNgkAjQxBEG8mCehgiCQdRY8S02XXENj95QB7hqo/gJOMw/GaCkbrJShIGkIP6w8CZHeIxnEBLtadx5IcSeUne99/8ALicp5pt7MkCUihudCox80i3InHliz/Cy/svrhavKsqpUJC2FTCBAoIvAkwIuf7MbBzZbanzcxMjrTMTMVW8eI2iygN1GgGQnlN7+8/oS4tFQQopChCo5jofXjaLo2dRomaZtOv8A28aTfXte0w48TQBSN5ajCU85J+QOMywhkMlCivaJKioxB3SCkRYGeZNo4oKUElIUQk3KQSAT3jQ/jjN/ZZP0I+Fvi839lk/Qj4W8ULCQspVQTAVBpJ6TpyPqPFOOrcS2lUQ2mlMCLQBfroMF9wtBkkUAyBAnWYJ6SZ7YhicuX9omyoo5m4Gs2N5iN288WGkHKqevWHaBe0Qk6db8Wn9gX6cfCnH5cUHiGCxAgrrq5zAEdOWEZhSGVshKSFzc6iQAfHQR0PXs8wwp+uFJSECVFRIEX6A6QZnHkf8AUZf2n0w7l3GYKoKVaLSaknum1/EX5aHickJRmgLktEADnZWNi7905/or5YILWSU27ZbiwptB3kgFJJKdU6HXr1PE5IkJzJBghqQehAUQceVZj71fr+mEKOZYf2sFbKa0OQArRRpJAEg0wB+YHE5Z9LO0C0lQcTSQDFrz7jjaZP8Al3PaH54XmQWy0y0GkK3rlSleKrGOsza0xbCHW0sONloKWo2ctIFuZuI5Ra9+/tN//8QAOBEAAQIEAQcKBAcBAAAAAAAAAQIRAxIhMQATQEFhcYGRIjJRUmCSobHR8CNy0uEQNEJTY3PB8f/aAAgBAwEBPwDsouKsLJTzEFIVre+h9W4dOL1zlapEqV0Dx0eOIcP4RBusEnfbhQ7cQFEolN0EpO63puzmNy1IhA3LqboHsna2rGQT14ne+2EjIxQHJTEDOes/ifqxOmeR+Uztufi1c4lTNM3KZn1fgpKVM4di41HEqZpmE3S1fbU2U7XriJRc1NgKk7B64hRFLK5gBKWbSL0OsNqzpgSCwcWLVGw4g8+N8581Z3B58b5z5qxMl5XEwqQ9eGdJQElRDuoudtbccCGkLK25R102t2xynxBDlNQ82iz8NDvejZ2VqEZKP0lD766d2dn8wn+v6s7KHiCI9kytxr44VDClpW5dOjRTyvXp7PRIghs4JmLBsZb+OJ3cIiJW4Dgi4IY+/LTnMbnQfn/1OJ0ddPeHrgMuOFJqEpIUoWJYhnsbjhqzmOAVQgbFbHYSnGRhdQePrhQyUSHI4CzKpLki4D1018Oh85iw1LlKSAUl67vTEsf9xPd+2EwjNOtU6hajAbvKzYUhRiJUFkJAqn3Sul/+dpv/2Q=="
  },
  {
    value: "ORDER_LIST_5" /* ORDER_LIST_5 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAAyAAEAAgMBAQAAAAAAAAAAAAAABwkGCAoFBAEBAAMBAQAAAAAAAAAAAAAAAAIDBAEF/9oADAMBAAIQAxAAAADv4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKxr669bobzVSoz11dlPmagAAAAAAAAAAOavdn6VMOjmr3Z/hOmLDoA1JAAAAAAAMuNiAAc6e2i1LPZV5orjzvLxst0qx7Ise4WAAAAAAAfaZOAD4SqvRXatnshmcfV53N+dybgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUfaqa/b4dVPn6Pa50QUYwAAAAZOTqAAAAAcuu/PXpdX1vedp2rrn9hgp5YAAAB6hnQAAAABVJorw7vNpa5bh1zyTgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADWyccN63FrkAAAAAAAAAAABqpZHBu83kqmIeMeAMhJhAAAAAAAABoNdCK5Rs6z2+mRieKAe0ScAAAAAAAACEp8gGUfj633pmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEsuUX66b2cl1al9fnlxma0AAAAAAAAAAc127P0c4tHOXto29qlofdDp/waAIkPiAAAAAAPaJOABzUbs/Svh0c2W7POsJTLDtuee0CDTzwAAAAADISYQAadWwqI0V3AZref7ZRujVLYqE7Ys9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//EACkQAAAGAgIBAwUAAwAAAAAAAAAFBgcIFwQJAgMWAQoQFSAwQGA3OXD/2gAIAQEAAQgA/k9rc/TDX/HIqVjf8oGb3MFA8nvw9c+zVOy9gsq5QOtNDeVN5yTCMrhRE/X2u93JWbldFrdm4094eKUbN9+zV8fcscePBtdcnDh8+SKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIeSKIIU7OcxVFePl/Zv5RKzbDMgRsuQ/bsfgr0sD3Sd9fb6t8tlejpq7Dl/7lr/G+uYS4l6w8HWWOH+kY0TsIB9mub95mrFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPFeI8V4jxXiPBcjU2VZnTn4H2GZYWnRaYExzjaMNS+G5PF1uguLi8oL8EpKXxjSw8lcJFFr7vmwbNSYbU8Z9+0WjEm3KQS6AQX/CJft1s/l5M3sjg085mrm1pZQCWnIyybPi9VJ0hVBR8LJZKQqUhlgYFhrAWGsBYawFhrAWGsBYawFhrAWGsBYawCNWSkNVIW4Gf+POM3o21bSJoxIW2/qBmvaC0QPTGQ/rIZjIyxdZpx5BlxiXm5fgmxSDlviY8Msk0y6oToqhOiqE6KoToqhOiqE6KoToqhOiqE6CZviYjMsY0xPxy106RVlm+WHJzu46LIE57SOq2K5l9rpi9ORh0RHWQKNSCbb5IJRBI7+vmFIj1iZGN6ZIekBJZZE44mNHKHK/ZnS7ixYKF0rXwbzWm/bgyhgfGGQLrfCqcE5Iz7PK8S11ELXUQtdRBKuCcnh9gFeX+ltU/wBZ8/BpN5ceGqCDfPmTnRMoi3FOU+FC3H144zDYVCKhFQhPNx9BOMM2/TkqyRXJSPT3R6PG7gchULr46NeHdrcgMjtbkZi6NSI/m30fRqI0tMtnwe/j7htMdRBxeQxZR6WwkU1KFe5mZY7jWXj0+BhFdoIn7m2XkC/nRE15/wBbef6+j/Sy1Ea/TrtTqf7k/wBiT7tA/b2Mk7+2DX8Wad9frvwmRkmlnJ/fqYp9wJT6hWKan5MnS+nmOfgC3hbwt4W8LeFvC3hbwt4W8LeFvC3gnnH+vHGGU/buR49TSbO9IUnz4aQOy1Zybv5Rks5toLv5UgOzXRrE12apUtD9TqiSb5/Ju2Z9nmpnndNUKIVQohVCiFUKIVQohVCiFUKIVQohVCiFUKIVQohVCiFUKIJVvjkjPsA0y/snfCRodgsbVjG55OuEvuAchFdkbDCEcMmsgNGNCxlZKM2mrcBEE3eJQsEkoqb+C9VpjPV+zyCEnpqm0Ws6Of8ASf/EADoQAAEEAQIEAwYCCgEFAAAAAAQCAwUGAQAHCBESExSUpRWV09TV5QkhEBYXICIjJDNAYDBYWXC1t//aAAgBAQAJPwD/AFOnjbl8Q29G4EBsdw3bbFd9YVl3WuKCcRhk0OIQGYRXoFodRRogxsc5LyT8LXEysQ5OtSYn4tY0lxM+zM2t/h0M2K2+xw/Fy6RfaGdrRrEp7EeGM8S0zA4tzNBDbThbzyXBsOqncQDm2V+4eP2i1Tiuo4UfJOqpF62dgE2S5kQcMRl+ccipasuB2GLinvFmxxxchUFHS0lAFnEbMbk8LXBjuBxMbXbWD787zUqqM7h8RRNmMPKOiaLUbMLZ4qH2vzX4yRILtcHiVljZHMSO1Za6SiUr7v8Aj4derUPuHvLuOwEvn4J20RCaTLRB60JyjD5kSbS4x4RbuXPA991Q6UYMKS/ocMylF8Rm3F4XCOoSVFe19xD99JC4JcAfw4I6maWYyxKsray27gFsdaFMpw2lKUIR+IntAlCE4wlKUpgLPhKUpxywlKcYxjGMYxjGMcsfl+5PzXvQ74+p+a96HfH1PzXvQ74+p+a96HfH1PzXvQ74+p+a96HfH1PzXvQ74+p+a96HfH1PzXvQ74+p+a96HfH1PzXvQ74+p+a96HfH1PzXvQ74+p+a96HfH1PzXvQ74+peUKHc8d3GCDy32V9EcYtHW066pCulaUrT1Jz0qSlWOWcYz+7WJW4j/h88RwVn3ersC0hUsTsduJK05u5SqVKXjkwAVTY2uZew28mKTeHpwxCIiNlCGeKXZtezDFZ/WldlbukQqRyLkBMg3CpqXiMW7N0eS40EzRMweLi5LutwyYT2mtIua1IU4/8AEZ4obRu5Q67LNJakxNma1PXFdAdISplD6Rval2uUdCrW8UPJV+MibAAQQHNtFk/9xXaH/wBDaNWwmobcw8vBwCzI+ElrHLSM7YjPBxMREwkKKXIHGEKS+S5hDSWRQAzTinmRhXXE2Bi1bcboVKDu9KsI45YaZWu2IBmRjSXAZBgWRjiuw+ls2MkhRJKNMQ+BICjGDvsN6iPUJT53UR6hKfO6iPUJT53UR6hKfO6iPUJT53UR6hKfO6iPUJT53UR6hKfO6iPUJT53UR6hKfO6iPUJT53UR6hKfO6iPUJT53UR6hKfO6iPUJT53Ub2C2O52nfGHu9HdaWy5/LeKcaV1NOLT/EjPLnzxyVjGcfuR4MtDywJcZKxUmIwfGycaew4KdHyAJTbopoJorroxYhLTjBDDjjLza21qTngi2qxaUSftZEc6deSNu0meJcLwhOz5Ftd2kSAl51WEROKRiKQwloVAWBWGWWwQ4uKiwxo6NjY4ZgKPjo8JhAwYIIYyGhhAxBmmxxhh222GGG0NNIQ2hKcbYVnc4Hbq6Ru4lIGszBD7Vau0Qy+xG2SNwOSNlEiGyUQ2ytzLjeEur5t55/ltzWd09tLGsB6XqNrCyZHEFRZjR8acwttxgyPkY8xhsgKSjihDxV4z2SEYWvCq5D1CkUqAiarUarXgB4uCrlcgQWIyGhIiOFQ2MDHRseMwIIMyhLbLDSEJxyx/wCCdybvwNcBdH29jLJb+J3bVVVL3Z3yvpqYY0ij0CWRNfrZQRYj2ziMwe2DBsJIrNtkJIy0DHVuCR+IlxX8WG0NL3HoFb354eOMi8J3fYtdLt8w1EGmVa6SrWHqkY5KYh4gNMHAhS8Y7LLmMWEsIWSgZpTq4qyQsXPRi32ssPrj5gFiRCU8yrOVMuqGIby41nOctrzlGc5zj9Ml2BGPB9prwYDvR3QBXnP5jwrjqup1xav4l55c+WOScYxiX9Pi/ktS/p8X8lqX9Pi/ktS/p8X8lqX9Pi/ktS/p8X8lqX9Pi/ktS/p8X8lqX9Pi/ktSXfEf8Z3WvBgNdfaAKeb/AJjIrbqel1tCv4V458uWeac5xn/j4nt5OGfhM4GWKdCj7NcPNyTtduVvtYp7D4spbLnd2hiJ2SpbcmCek6LFAchg4SXog0cmMnzjbTL33elziV3LtdTH24o924h9x9xcy9birAIdebdOUmfmzo/9Xo+PGXHtWA8JoVm1yUMKA5k5XQ3uxRNnKK9SNrayNaNwbFH1yJLsMtTg346ECIkHmvGypQsfInIBES8SmOjZKRcbQDHmkMHBykVKBiyMZJxxTBsfIx5rCCQzgTBlujFhljOtkClDuOMPsOIdaWttaVZ0TKNkFdnuIHeEQzjsMNDo6EuhPLxzQynKupxXNWVZxyxnCcGzXmAfp2jZrzAP07Rs15gH6do2a8wD9O0bNeYB+naNmvMA/TtGzXmAfp2jZrzAP07Rs15gH6domUcIF73bQQ8ItnPfYdHX1paCZXnkh5WU9LieSsJznnjGU5/47Tv9w5cRKIUevTO8/ClunnZ+9W2KBHGBjmrSfmAsYciYBGCDQzUwyAHMkQosdESEgbHwsGPGw27m7Nl3uGqoG6XEDu1uzYb7xGWqLptvgbzCw2NzZlDi67CqsVbhy5WIqcPAx854Mf2uOa6KG6NWJ+boO3ExWZ+kkwNokq5Z4CVqsEXWAiB5oDP9U2bXZGRiJQSRFMDLaMyYgdmVDjDwYtqDqNIrcFUKrCsOkvsQ9brUWLDQcWy+a8SY81HxgQojbpZBBLiGcLfeddypav8Ab9ubXu1naCknW/8AZ7SulM/Y8CvjD5aQUsY3EXEx+Csy1lm8R8kqBrQEvMoi5NYCQCNpbTsg/uhHTRi9ubcZmUkIjMLZZiueMj5pURX3J+uTXsj2xW512vwa5aGNDNxGDoeR1f5L0eNfNouHrd3cemkSoKJSMZs1No03PwjshGuqQ2eGiQBHUQI4tKCGsKaUrGFZzomKL3F3V2zBtNtJhIxqGiXpYiRkhnFgxbK3GgmMtCtYwyhak4VhWef5/pGjHBxfC9tZDJa3s98MchfWpo1lGeS3lYT0tp5JwnGeecZVkKF8ud9R0FC+XO+o6ChfLnfUdDRjY5Xiu4sdktD2OwGQQjoU6a8jHNbKcK6m1c05VjHLOcKx/hf9H3EP/wDLLPpSUIRsfGKWtWcJSlKZiaypSlZ5YSlOMZznOc4xjGOefy1LRk7DnJcUFKw54snGlpaecHdUKcE6+KQlt9p1hzLTq8IeacbVyWhScamfCeL8P/T+zu/2+wKwN/d8cz1dXZ6/7aenq6fz5dWbD6T9z1YfSfuerD6T9z1M+L8J4j+n9ndjud8V8b+7457p6e91/wBtXV09P5c+rH+FNyFaht7tqr3tXK2GKHHLk4OPvdbka2XKx4pmcCkGAMSKyR2Sc4YcdbSh3PRnOr3d5Lbz9g1r2BN3AjHgq3fHa7bombh5CaBcFZMiwJhkacIyw06IdGPZbSxIAmhPEivbh3Lc2JEuVqu5FmujYAhXtK1Oh5IAiIiMxkOFhRmo8dxALb5SnpQiVlXX+7JLZa/1u6RVA2w29h3Zu02eXy8pkQZC0MDCBhiNESEvMShrw8ZCQcUKZLTUqWJGRgZRpTDC/wAOH8Q+O4SXncPscTjmzY7lRxW1LxyuxYSZRMaPUEjJfOXLs2stPhm0NNNPSDyQU26Mve2G5EExYqhaYlTnhZKPecdHebdYIbZMj5OMPHLiZqHkBxpSFmQT4iUEFkAiR2tluIPjW4ooGOYmLjs7wvUEm7FbdRhIwpbJO4E+hXg4Rahz4158WOEnCIpuQDVPoiMlh4J2T3+4JuJ6VDdkKhtVxOU9uoJ3DFQ2t9DNDsCiEIl5N8VkosIA+LiEzI47iq0TOuNvtMf42XSNrN/eJqW3R3phcPKaHs9T2fxV8B1kxtvDmDAJeFsl/QUwWzkUc1iIOSh18dDocHDvVZ6HXXXa07GBOV92vuBZjVwbkMtjMcuHXHZyAuMUNkJQWci5YyxnLeiinNt+E/jCJn9ngjzCjiYWgbuG3gGOr7DxXPKBY2P2yhZEppntjvT0/NSiWu9JkOuyW39v4oeKLiMtm7u4V9oU9NWoWTrEgICZWoEmfsVVqEs+7GWeX3Al3WFRDY6HrEpbTi05Q2yoGY4wccZNR3EqYkK00faqTtTFzEE7ZLJYMhJekoCpETMRGWNRRqGY42O27tconLjFXknBv0wXe8CaUH3fafb7vhn3Ge52/Z6+jr6Oro619PPl1K5c8171b7ZqverfbNV71b7ZqverfbNV71b7ZqverfbNV71b7ZqverfbNV71b7ZqverfbNV71b7ZqverfbNV71b7ZqG8J4vxH9R7R7/b7Ar5P9rwLPV1dno/uJ6erq/Pl05/cykTb6O37vGx9vsJquxC1qS3HepMbUyJM5eWxwmiBpi3SjxBDzbI4VZMKe5jjvZTp1J+3u4PF5AbT0WcDy0uJn07OmbookpMIhC3FEtGwVrpEsIrpZxgOXbdcwtwjLYlBhd8eNc2Mcf3M3Dn3OvZThNgn0Dtv2XcOQbYKDlLRENHhkqgyMORcPIHQ0aeFbLKYnb43cmd4quPDdcNad0+JG+ZcKcjGi89JFT2pizu8/U6u0C2DDEF5d9py4MYOMOzXK34SoRn6S4hLJsgaW0l18zDiWySXHkJcwkBacLwleMLwla04VzxhSsfnk2F8wd9O0bC+YO+naNhfMHfTtGwvmDvp2jYXzB307RsL5g76do2F8wd9O0bC+YO+naNhfMHfTtGwvmDvp2jYXzB307RsL5g76do2F8wd9O0TGODi+K7iB3i1vZ74ZA6OhLoTKM8lvJyrqcTyThWcc84wnP7jZwcNPPgT9Vt8KgXNm26v0Dl9davFZcLbcZRIxuSjI84ZXbRMV2VnK+++yLLPuJ/En4bE7IvRn6lO8RYu21zc4uc0bsqiXH2xHINiBRbn4VCMrsatz3bg1JEkGtXv2owxNLQS7BUwORMOs1gQ05OXa7zr7khYrpaFhYYS6ZLybmMNhjqSzEQYsXXo1bcfEhJR+I9w8VOyb+3szcfdu0S/DrFXy03O1nEnHOlyVlv1Ws074VJ8rLSDUc1INgokZaTPywow8l9z8U3h+n6mFYYUu0QQfCnt1HlzVdGkhnpqJFPZ26ZeCJkY1BIbBbTzTgzryXm3W1IwrHGZb+EwbZPcqUtt/Yqy7Ey5dQZFyrLiZgdVemIps+w0luCmh4OCsiSq1Kt3CSVIOhpEy1I/wCyf//EADsRAAEDAQYCBgcFCQAAAAAAAAECAxESAAQTITFBUWEiMkBxkbEQFGBzocHwM1JygdEjNEJwgpKisuH/2gAIAQIBAT8A9k7uzjLgmlCQVrVwSOHM/qdrY10qo9W/ZzFdaq4+9Hxif0s8wW3Q2k1BdJbPEKMCdpnI+O9mro0nES4tLjqW1KoQTSiNyREqnYxHA5HtF3yu17I1pQJ5GZHx9F5zYuat6Cmd+jTHh87XHrP+4V5jtFzIVjMExjIhJOlaQY85/KNYtgu14eGquYiDxiZ0jnMc7XxQBaZSZwGwknaogT5CeeW1rj1n/cK8xZttbqqECVQTqBkOZspJQopUIUkkEcCOzaZi3rd4ppxVREbVf3RV+cz6ELWiaFFNQpMbg7WQtTagpCilQ0IsSVEkkkkkknUk6k/yJbUw21WpIdeJgNqmlAzzOyp+Y0zNmlNXpRaUw22opUULbFMEDKQNdzmYMRGhBEEg6gx4dphN2YacDaXHHZNSxUlAGgA0nPXXIzsBc3n3XMwnDSDJCEpgkZAEAGeXDW1C1uKShJUZUYSCTE65bW0yPaG7y42jDhC0TIS4moA65ZjfPvt629UlQKUhE0oSkBAJBBNI1ME5mYnKzbzjSytBAUoEGQCDJnTvz/5YkkkkySSSeJOZPtg0jEcSioJqMVHQfqeA3MCzzeE4puoLpjpDeQDpJgiYIkwe1NJC3W0K0UtKT3EgGz6EtvOITNKVQJzMdqu/27PvUf7C16/eHfxn5W01y7ShVC0LAkoUFAcYM2U8S9jQKqwuk5iRBjuys+8X3KykJMAQOXEnU/KB7OIQpaghAlSjAA+vE7W9TM0h9jE+5XnPDTXlFlJUhRSoQpJgg/Xhxs3dlLRiKUhpsmApxUVfhG/wnazl1UhGIlaHWxqpszHeNh5bx2e6dBu8vDrIbCUngVTn+RAtJmZMzM7zxnja+dJN3e3cahXNSYz/AMvhyteXkulAbkNtoCUgiIO5gE7R4WumTd5Wr7PCKTOhUQYA2J2/qHHs926TF7QOtQFAbkJmcvDx9F66LV1bOobqI3FVPzB+hZphNGM+Shqeikddw8E8AePkM7PXguAISkNtJ6rafNR3PlzOZ7M06plYWnUZEHRQOoP1kYNsW5zWGHKtcOoYc698cqYj+GzrqnnC4vU7DQAaAd3xOZzNnLzdnQkLYWQgUpAXAA7hA2Fi5c4MMLBgwcQ5HbezDrbQcraS5UmEzGRz4gwDOZGeQ9pf/8QANREAAgEBBQUFBwMFAAAAAAAAAQIRAwASITFBE0BRYXGBkaHB0RAzYHKx8PEEIjJSYnDS4f/aAAgBAwEBPwD4TqPcWQJYmFHEn78tbXK0Xtr+7O7Au9OHbFkqBkLEQVm8OBAkx2elnrObpUFVJAvECW6ZiPvlvFX3tEc58R6eyl7ysP7h4lrfqMk+beK4IuVBjcaSORj0jtttEi9eEROflnPLPS1AGHc4bRiR0xj6m36jJPmszBBebKwIYAgyDiDu+xpzNwT2x3THh7GVWi8AYMjrYqGEMJB0sAAIGAGAH+CXFRmuglEAxYZk8BjI/OeFnD0gHDswkAq5nA89O7tsDIBGonecatR1LFVSMFMFuZPD/muNqyIi4E3icASThqbBgqKWIAhc+m8tSVjexVuKmCeufrbYpBBk3oliZbAznp2CzU1ZQpGAiMcRGFgIEDIYD4wZrqloJgTA++/lZGvqGiJ0O9OSEYjMKSOoFqbFkVjmRj371U92/wAjfQ2o+6Tp5m2e8sLyleII7xFggCbOTEETkcbU0FNboJOJOPP4cJCgkmAMzbb67N7v9UYRx4R22BDAEGQcjZqoU3QrOwzCiY62WqGN0hkbQMInp+N3rYtSTRmlhyER525acLUcDUTRWw6GfS1JCgYtBZmJJH4Gs99q+LUgP5XpHEDDHph4Hhu9XCpRbS9BOgxEefd7KOL1m0LwOyfUWeob2zpiX1Oi9ef4xOFkphSWJvOc2P0HAfeAw3d0DqVPYdQeP3pa5W/jtFjK9BvR685nnNkQIoUaeJ4my0qqyVdQWMkxMntBsFrzjUWPlH+tqiM9265WDJ55Y56efxL/AP/Z"
  }
];
var OrderListTypePicker = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    ListTypePicker,
    {
      ...props,
      options: orderListOptions
    }
  );
};
var bulletOptions = [
  {
    value: "BULLET_LIST" /* BULLET_LIST */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAA1AAEAAQUBAQEAAAAAAAAAAAAACAYHCQoLBQEEAQEAAwEBAQAAAAAAAAAAAAAAAgMEBQEG/9oADAMBAAIQAxAAAADf4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqsdDPqc9DNtjc/TtT8/QAAAAAAAAAAAOK79Ryrce+XH897UXy/VAiSAAAAAAAVcSIAAOYl3efgD2U5/cd3Ts4XQAosAAAAAAA/aVOAAeUY+bq8gtVnreAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDeun4ZAaZzkqmAAAAAAAAAABi10VyprlKGuWA/XTnwyXCmCxQAAAABU5fUAAAEVrIwCthloz2YMNdOwbjvHmFCAAAAAHqFdAAAAEMLYQithmby3eiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAClvfNZDfQMkdE8uua0AAAAAAAAAACyM48YT6bljcG5unfj5G0U+WdAAKhLwgAAAAAAsjOPGE+m5Y3Bubp34+RtHilsQAD2i5wAAAAAAPD9YYdNQmDXKfNMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIY2w199lOwVjumZVMAAAAAAAAAAAchX6PmQAuhP6mfXr+c6YFlwAAAAAAD2i5wABxwfpeXFSyMra5djz5rqAR9AAAAAAAKhLwgAGKnRXrRbs+y3h0ZWM9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//xAAnEAABBAIBAwMFAQAAAAAAAAAGAAUIFwcJBAEQFgMKYBogMDhAFf/aAAgBAQABCAD4pu19wryoQHzpFCI3TfZtz6FfpGPTSb7hn15vHrPFGXf9GYsiFmXstZOyqeLDuQyzEeW8XZVAu/khEvJCJeSES8kIl5IRLyQiXkhEvJCJeSES8kIl5IRLyQiXkhEvJCJeSESBXt55hU18fl/bvp1TZQhBKPJObQ9aFNU2TJvyixzms1714HqvA9V4HqvA9V4HqvA9V4HqvA9V4HqvA9V4HqvA9V4HqvA9V4HpuDRtq5no8/gfa+MTITs7mOkvXUJq/wCpX6pp1YWBiFmdvHhj5aX7LZby9yqe4W1Eunre4XwP6XJyDzIHz3xLPbGxEVg38+67OJfHTVnMjKYFCuO4TFCKWBY/ACyyy8CN2/8AiEZgHYyceY1Dblz+BYZgrDMFYZgrDMFYZgrDMFYZgrDMFYZgrDMFYZgg0yJHUkbeBz/wThjGzzLiPIGMLzqr2ENGRAplhNKjJ2VcZ4VCnnI+XoWvjtsz2Ov+zBv7PLTx3xt5LXy6oHVVA6qoHVVA6qoHVVA6qoHVVA6qoHVVA6qoHUzY+ZmNy4zpxPwy515w2nS0t7dKAH9vvrKFSRnJilnZ2geam1iYPlxyXNuPwkxPHn6uXW8vq5dby1vboYubQzbJIHgH+eTP63yC7+z8/ZCYfcqduQxsPPdOJa5ErXIla5ErXIla5EhXILy+P3Aa+X+aTP63yC7+z8/ZCYfchZ/95n5jSqhVQqoVUKqFD2OP8F44bt+cmHGUxGyARI/pyNMy+nI0zKH2sCDMCCQxLom/H5qbAIp6/cf8PIUnunu9IZeV+lwesLZ/xS2A4+5GQ4w/0bPJqGM9ppZoz2RLWLNI0gZNLCmeRrvbyt5W8reVvK3lbyt5W8reVvK3lbyt5W8h7I/+88cNp+6cEYS+GssM7RuM1B6LphM6WGDI2BneqCJVQRKqCJVQRKqCJVQRKqCJVQRKqCJVQRKqCJVQRKqCJVQRKqCJCuPnljfuA6cv7dlun6KOztga+Rlrr7PDKPlfq8bprR0/RT1iMDvyMT/Jv//EADsQAAEEAQIDBgMDCwUBAAAAAAQCAwUGAQAHEhOlCBEUlNTVldPlEBUjFyAhIiQwM0BXYLYJFpeo19j/2gAIAQEACT8A/tSEq9w7QsKGA/uduPbGlTVL2jIlBg5OPqsXXhnx0Wy+Pw5TR8qqRNYgKiguOELCsUuRKRlf7al++8misFpjs1bbDNUyrDqneQ7S80bNTeF/WyjIz0M43lrhRnGcJT3QlUpXaEmAH/yZbk1RtcJS94DYoMgyQrUvXjCiW6luG5GiOSkdiKNcrVvdakwYuLq0ixDQs7/MEkmXbcncC4Xu2klvqJJdsdrsEhOTOXX14wpxSTzn0YzwpxhKcYShCcYTjT5I14203Dpd+p5AbSnymrPULHG2CBWOwj9Yh3EpHi8A+O/n57mu7PH3fmT818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqfmvih3z9T818UO+fqXlCh3PHcxgg8t9lfBHGLRxtOuqQrhWlK08Sc8KkpVjuzjGfzqdKy/ZM30u85fqXdYSKcdr221hucs7MTW01qWC24PV1w03JEi0FySUwLZqr93NxxZs1FWMON1S5aL7JOx1yib1dbpMx5AkDuRY6jIplIHaqpvkoabszspPx4jV8ci1ujVurIkWZE0Calq6JI/bEdQlPW6iOoSnrdRHUJT1uojqEp63UR1CU9bqI6hKet1EdQlPW6iOoSnrdRHUJT1uojqEp63UR1CU9bqI6hKet1EdQlPW6iOoSnrdRHUJT1uo3kFsczlO+MPd4Oa0tlz8N4pxpXE04tP6yM93f347lYxnH5sPFWGvzYJMZMwU5HiS0PLxpjSmC4+TjD2SAjwSmVrZJEKYdYfaUpt1tSFZxnsI9mf77dKyaprG19fxXcEZdS9xNU3A2KeyjmJxnDDME2xjHEnDeEqUnMLE1yAiBkBxUHAxocRDxgjec5QLHxkeyOEEMjKs5QwMw00nOc9ycd+f7u2M223Iqm1tiNo26Hbf7Rs3MwnZngbuCkZyQrm3ETU1/wC8N1ioptx1g2XrzZoYxbkfIJhZCqSMTYJd7sCdtetRrTkhYNlqiBuJsnudIhDcRZEdtjapMVup4lnWGlCCP3FcrxLdaQzCyBK8ZTEWnbzcbbOzEUDfbYjccD7m3P2V3DBcKYKrVtis8OViluAHOQM4whsaVYENGIHjJ6JnoKI/lzDI22C7cRNGiJWOVluRhlbwX2o7PmTccQlaHAz4WPvZcoEewtJMeUI0aNnBA7eowOMgdt9tazEkrDaU199WYmPak7lajON15a5O22w2ZskmvLq0eNk3ks4bHS00jWGoxv8A1FuzZ2g9qt8IEdxxsGasPZmqQW6NN3GLBbThh20fc8XE0keTeypbUDHnjMYZcPPUd9j3ILY8HyneW07wc08Vlz8N5DjSuJpxaf1kZ7u/vx3KxjOJfp8X6LUv0+L9FqX6fF+i1L9Pi/Ral+nxfotS/T4v0Wpfp8X6LUv0+L9FqX6fF+i1L9Pi/Ral+nxfotSXPEf8ZzWvBgNcfKAKeb/EZFbdTwutoV+qvHf3d2e9Oc4z+4KFjk7w7bTlahZg5t54Gv3NlLUzQbMYOP8AtBItYvEXXrAQKz3OlMxqx21JU5hWJFjZ/wD1COzRFR2026+0t8IGgpnclNPDDiK/uvtoQW60JfYO9V9MPPlvV7LjqJA8mRDj81SRrkzK3+n7Y0GvMeIm7je7FFVeuRrecZ5aSZaYKEDS+QrHKEFw6okx/KRxWnn1obVX5+D7HvZk2vtHZv7FMtY4uRgTd6rjbJQlnebfeKipPOSGKq2EmRokS+oYFUsE9DILZCsdatMOF9i32xyuTzFjqbQ9jkPtEI4FOtvIx3rZThXE2rvTlWMd2c4Vg2a8wD7do2a8wD7do2a8wD7do2a8wD7do2a8wD7do2a8wD7do2a8wD7do2a8wD7do2a8wD7do2a8wD7do2a8wD7domUcIF53LQQ8ItnPPYdHXxpaCZXnuQ8rKeFxPcrCc578YynP7nYmpbkSEIwseuXLCpSrbi1planHcDwW4VQPgrgDHJKXg5cH98OQBhrbL8hFGZbTjW1l+3uIri3F12G343j3E3LqUPh1ttrLLVQkptiuSIuG20J8HORsqIrhQpxla2WFNRcdBwcMCLGRENDgjRkVFRoLKBwo+NjgmmBAQRB222BRBWWmB2UIaabQhKU4/u5g4mHpNWsNulRoxth6SIja3ElzJzEeyUSEK6c6KE62I2SYIw4+ptLxLDeVOo2T7bv/ABvsP/8ASetk+27/AMb7D/8A0nqhb+VCY2tq0TbrATvBV9vICNMjZiWVDCsQ71L3T3AKIObKRlx9s0OPYSx3KbJdc/Cx/L/0R3X/AMDnvt/ojRf88e+1DLhAvheWghLi2c88wcdfGlpxlee5Dysp4XE9ysJznvxjKchQvlzvcdBQvlzvcdBQvlzvcdBQvlzvcdBQvlzvcdDRjY5XiuYsdktD2OQGQQjgU6a8jHetlOFcTau9OVYx3ZzhWP339Ed1/wDA577f6I0X/PHvtI8J4vw/7Ryefy+QUwT/AAuazxcXJ4P4ieHi4v093Dmw9J+p6sPSfqerD0n6nqw9J+p6sPSfqepnxfhPEfs/3dyOZzxXxv4vjnuHh53H/DVxcPD+jv4sfvg/vGvWqDlq5PR/iCw/Hws4ARGSgfiwHxThfFAlPseIDJHLY4+YO+y8lDiexx/2F7VP/uOuxx/2F7VP/uOtj/yUWG/QYFctsh+Uvd+9fe0LGHqkwg/CblX+4ggcg5WX/ERgwZbnfy3n3Ge5v+4Nz4+mDTTpAtQqYA70/uBejBFCoNHp9OjuZKyrUdk0PMvLLQLBQiSxFTMqBgsbL3Zl7TGKVkrDT1lw5tfmxNic1SclNVHN0wA6vDXC7gZVwZznOVN83GU4UrdGOuw0P4Fq4VI0ciA3BoJ8gh9QoFzp0mlmVivEuCHMx0uwg2tzqwDnK9Ny4wrr6f5iYKOqxVqlartBCrKU/HVLZ+syRkfRYaMZSrIzCy4tCbBPviIaalbTNTcxlCVnqTjU3IR1WGt8JV94YUVS3Bbfs3ZJcAG/wJoHGlg0lqGy5N1xZCXExdriYKYaQp4BCVfbXurfTNV7q30zVe6t9M1XurfTNV7q30zVe6t9M1XurfTNV7q30zVe6t9M1XurfTNV7q30zVe6t9M1XurfTNV7q30zVe6t9M1DeE8X4j9o+8efy+QK+T/C8CzxcXJ4P4ieHi4v093Dn82NkAS9stw7DEQBh4mQ/wDc1FfPeOoNyAR3cCoy3U8mGsAOW8/htH+GeS0Sw+w1qNKPM3Nv0JFz5Izb6mq9RRCkSV+tkg4P+IPHVenhzM0U4hSXVpDSMLxmPjtOfabC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0bC+YO9u0TGODi+K5iB3i1vZ54ZA6OBLoTKM9y3k5VxOJ7k4VnHfnGE5/NAmKLvFU4oiJo2+dA8CNcYiOceWY1XrICeO/FXintyC1lpgplts6NUVKKq09WSpmULK7cdBzR8FZwzN52UsWLW4FzU9y3avjcDMQ0VlnizltNveZw7hOOblKs5SDL3veG2x6Yu675X1IT9ylYhBfjUVqvBAstRNLqmCUsPkREK14uafCjiLNLTr8VFOA/3N//EADoRAAEDAAYFCQYGAwAAAAAAAAECAxEABCExQVESQGFxkRATFBUiMmBysQVCUoGh0jNTgpKiwSMkQ//aAAgBAgEBPwDwpVanzo5xyQg91IsKts4J+p2C/odWiOaHFU8Zn60rVS5oFxskoHeSbSnaDinDMYk2kawlISlKU3JAA3AQORQCkqSblJIM5EQdZqlYS62lBMOIABBNqgBGkM5xyOyOSt1hLSFIBlxQgAXpB945WXZnZOsgkGQYIuIsIp0l+I55yPMZ43/WhJJkkknE2nxcGG20hVZWpJUJS0gAuEZqJsTOR4zYP9JfZ/zNHBZ0VJ/UBbG6N4o6yppQBhSVCULTalacwfUYboJ1eqoC6w0k3aRO/RBVHzijqy44tZvUoncMB8hA5EnTqbgP/FaFJOQcOiRum2M41hpzmnEOfCoEjMXEfMSKVhkgl1vtMrOklQtCZvSrIg2W+s0SlSyEpBUTcAJPAUdhhgMSC4tQW6BB0AB2UTnicrcCJ1ht51r8NZTN4vSd6TI+cTQ1x8ggKCZv0EpSeMTwNL7T4vAkgC8kDiYp1c/8bX7l/ZTq5/42v3L+yj9Vcq4SVlBCiQNEqNwm2Up1hHfR50+o5faXca859NYR30edPqOX2l3GvOfTWASCCLwZG8U6bWvzf4N/ZTpta/N/g39lHX3XgA4vSAMjspEH9IHiBplx5Wi2mYvNwG8+gvOAp1a7HfbnLtRxj+qOsuMq0XExkb0q3H+rxiBrLDQZaSgC2JUc1G8n0GQAHI+0HmloIEwSk5KAsPGw5iRrLTgdbQse8kE7DiN4MjkdcDTa1n3QY2nADaTGssVlxgnRgpN6DcdoyO3iDFOskx+EZy0xHHRn6UfrLj57ViRcgXDacSdpuwjxP//EADYRAAECAQYLBgcBAAAAAAAAAAECEQMAITFBUZEQEhMyQGFxgaGx8BQiYHLB0QQjQ1Ki0uGC/9oACAEDAQE/APCkaPiHFTOqsmgatZ5cstEd8c8GuZpQo+OcVTBVRFB9jwOqvSCXJJpJJO/ACQQRSCCNo0mNDKFEgd1RcGx6jZq1b8EGGVqBI7oLk2tULddg3aVkobviJumuo4eLzEUokQgCBMVqzQdVvVVPz0z9xYsnB3FmveSFhYcTETKSaQbD1xcaRFJTDURSzXkD1khISlKRUONZ3mfARixkkfUSoH/Id+Q0hacdKk2jjUdxlDW4xFTLTMQa2oItcWcmkSAHJAFpkj5kTKN3EgpQaHNZ2Uj+g6SpCF5yQddd4nkIEMTsT5iSLvfxgSwJsBN0u0w7F3D9pdph2LuH7ShxUxCQkKDB5wPQnSF5qvKeRw/DZyvL6jSF5qvKeRw/DZyvL6jSCHBBoM0shC+38le8shC+38le8kw0IJKQxM1JPMnxAtaUB1FrBWdgl2lL5qmtme7+yQtKw6S9orG0dCzSYiytZUdg1Crq3BDWULCr9YrHVekrSUKKTUeFR3ifAhJUoJFZ4VncJ9JiQkxKZiKCKdmsdBnl2UvnhrWnuf1lDhJh0Tk0k07NQ6Pif//Z"
  },
  {
    value: "BULLET_LIST_1" /* BULLET_LIST_1 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAA0AAEAAgMBAQEAAAAAAAAAAAAABwoGCAkFCwQBAQADAQEBAAAAAAAAAAAAAAACBAUDAQb/2gAMAwEAAhADEAAAAL/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAPPPQAAAAAAAAAAAANbpx+Wlv5/1QMDQn6EgAAAAAAAAAANY+kfly72fd/wAm3SZ1an1IcHQnyEhqSAAAAAAAZcbEAAHAO3xoza1O+Bk3e6tTqBhYAAAAAAB+0ycAAHHqzy7C1uoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGsXSPAG3xsg0u8tR9AAAAAAAAAAAArLXq/Am5xsL0+9kij3GMEFAAAAAGTk6gAAAHy0N/P6W8J3e8q3sPCQ8wwQAAAAA9QzoAAAGvE46u9I9KeHQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYt75WQv8AAdI+E+utbqAAAAAAAAAABCM4/GE+myxcGzbN+PIujHyHQADISYQAAAAAAQjOPxhPpssXBs2zfjyLo8UjEAA9ok4AAAAAAHh+uMNnkNwect+eMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMP8AfKeWlWuM5trJPAAAAAAAAAAAGH++UrNSrrBOO3vOV0HMt5J4ELgAAAAAAHtEnAAhSXlEDXp7C85QpON7jJuSxH0a+gAAAAAAGQkwgAEMy8ola1O+Lk3JWj6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/EACwQAAEEAQIFAgYDAQAAAAAAAAYABwgXBQQJAgMKEBYaQAEVIDA4YBgZOVD/2gAIAQEAAQgA/wC18Mti+LKczB8PuZWPSbMgwb0uGz2H3XJ14idfNnvwxjeAse9iWhcxyfbzLfE9jZF96HybAW3bZ04SdPMn5yP4Lxn/ANrFrt4KeXPnl8J98UWncNH6juz7yOJ28kIl5IRLyQiXkhEvJCJeSES8kIl5IRLyQiXkhEvJCJeSES8kIl5IRLyQiQLm8zrCrF6fV/TI/axhdEx4nx3bG+4d5OeHHPDh3AOCNu1vDuQb3M3uyOB3rwPVeB6rwPVeB6rwPVeB6rwPVeB6rwPVeB6rwPVeB6rwPVeB6rwPWODRvFazk6/QfViNjmBeGnpq59aP9tmQwWWkvHBz2lE4I7u0429YrjPdw1kX4ZmSTd4Z2WF9zP6VuB2QpzZaV2pe7efhNpHIycloA7OnUBYXcTJ8THl3uxlkdZihvJa/QWGYKwzBWGYKwzBWGYKwzBWGYKwzBWGYKwzBWGYINMiTKkmN0Gv+zvdTVJNyvcWJ8e0W3B0sjzO58cE6M+40RPjrDxutG1UbO2ZxOnzmN1OL1dUDqqgdVUDqqgdVUDqqgdVUDqqgdVUDqqgdVUDqwzfYbB5LTZTSfYla17lvdH5y2caeAm05DDbnH9NymK/cDkuxrfhJieZn1cu28vVy7by23t6GLm6GbOSBsD7eTP43yC79H5+SEw+5VltRg8Dr8ppLXIla5ErXIla5ErXIkKuDmc5ntBi9X96TP43yC79H5+SEw+5Dh/n2H1mJVQqoVUKqFVCh5uPkOY0eW++TDmFMRsgESP05GzMvTkbMyh9tgQZgQSGJdE39fcFwQhqAgqcpysN1Yodqp76kfygcYijhig4dgnt3BcEIagIKnKcpyOpWjlJ2T7jxokL6ZnJ/yr8oTQdSrF2N8oAGLLIhxiKOGKDh2CdreVvK3lbyt5W8reVvK3lbyt5W8reVvK3kPOP8+zGjxP0yLjy0crWXPo/vpzel6dgHmcVj7s/33QIsz+uZYHpcnEOpojeLb9i2Oa2NbRATFMr2qgiVUESqgiVUESqgiVUESqgiVUESqgiVUESqgiVUESqgiVUESqgiQq32Zwee0GU1f0yFYBqpSsu4LAPbhulVkRxz31LQZljWRbCNzRgTGMx+zf/EAEYQAAEDAwEEBgYECwcFAAAAAAQDBQYBAgcAERITpQgUFZTU1RAWF5XT5QkjM0AYGSAhIiQmMFdgtiUnN5eo19g0NUVGUP/aAAgBAQAJPwD/AO05N9z2i3ouyrPQwerok1kkLhjuSjfRTrdjeuWKUKiZcjQdUgZdCxS5VFS237zi47pAZjxxjoyaxbBcbdgBJTLlOOqGEraKot2je1IXjObiQi1iGvj4MwujLEm55lCje0k5Vdi+kKW7dnubYUgbWDucHqbbS7CBEGTKsRsxdYjZY3ixVBVI4E5JGTBuaM5RSk1uLH3AuSch4/aJlJsJzE9vKlsHKNpamSIbYIrQjqd6lyJYVXIJqfBAjwQpQxxySpubA3/d8MybpATvG8LPkUdxTElEE3aRloXpJXrqUvUoaszsI6q0hkAzEK6yQlja3BCOs7q8KBhLZWcXjOzw42AvDORYYpj9/wAfqGWX2YUVhaBdELMYWIUTEbI+Isme2npoSkB0SmyVskr0Asi/hm+wP23/AIBnaMV/x0/672jep/A/xF/8n1vqnbf/ALT7J/b9/ZOsnnC5sFOuZEIlRJwpjQXGlHDi34Kug9xtLbsZ3W04JDOoT22q97Zpc9UyBS2UWYglWBJvkWENEnkmIZosKvJIQ5HWXVUbjrxbqX0QKssTdWtJ0EaJEg0ngoSiPxuRpujA2+h/eveh3x9P7170O+Pp/eveh3x9P7170O+Pp/eveh3x9P7170O+Pp/eveh3x9P7170O+Pp/eveh3x9P7170O+Pp/eveh3x9P7170O+Pp/eveh3x9P7170O+Pp/eveh3x9O7oUOp17iIEHlro37jcZfZvpKq3WXbt9tt9u9bXduttupsrSlfyui1MM5Zix3CHHJMX6LsDTZboKdmUQxQs7L7BElw98aTJ2Kpvjom3WPQ7GqA+TqJQV7yJc02UygTfl68mjNZDbaH3YsuxZcf1i3BtsModVO7GtydaUoDQqr7V9r670e/X79ptdFWUYK6QOQYG0ZDknRqnNzMpDYhmpwJtOty48RAUPduyHRKztNuvcuyaVLObptKIHHMuIOSrf6WjmDp43TRzB08bpo5g6eN00cwdPG6aOYOnjdNHMHTxumjmDp43TRzB08bpo5g6eN00cwdPG6aOYOnjdNHMHTxumjmDp43TRzB08bpo5g6eN028AtDicJXrh6u5xUr0VPq1ilErt5JS+39KyuzbtpsupStPysdW0mStqcjAxPVFu9jrRmKriqaXmoGK9U2WS5alUSRG2q3qw2SehM3EaKStURzb/5tnEhxdkZ3YlXTE2U4k+O0Zk2Nsrx+tHjH8wan9gXEe29JvkQoaD8m2FILu0XMfGFW+ojqSnfg1xzHiPHuRZbhbN/ST6P7CGZlHow5Lx1IVI1MY90ruj7H0RzVgW1O5vlxGSsRtPYgkPdGmi0YdJQ4VA1kyH5Yxy/8SxtlkJehXlsqWhanUxrO6vfUhpfG6qqaTswuyAL00kXdWcgBSKVSp95iDvPejt9IdBlRsnYnhjwwNkoYuk7gj1ebwssx9rfTAgbmWZY3lQrLNuzkrVDJM3iPb841MJZhDcU9KboFdKM9dY+SuuPFsYPnR/zZdwFraMudOj2bK0ILIEClFVuHKGEFokLQecvJ62Pj+A0Kh4RlsB6RaLAQ4ky3GMakszwbJ6NiVVTHBxIEReH3DKhaVqtwaE4LdYeqsIoHTIiT25skeN9C3ALQ6nwleGkrucU8VFT6taxRK7eSUvt/Ssrs27abLqUrR35e1+C078va/Bad+XtfgtO/L2vwWnfl7X4LTvy9r8Fp35e1+C078va/Bad+XtfgtO/L2vwWnfl7X4LTlxxF+ucVLqYCW/wgClk/rERU1bd1VOy79G+m3ZsrttrWlf3KL5P8a4uOvwJ0do3EAT5EVMEGR0JskcvjrOzolEvR2SZlc5OjOQEDVyOhw8NbiUlFWmylH5xwNjxbqjkJhKKkN5maJKLW9Je0aWO11jhH8Yglj1pRYSicimNtty4JrXFHBOwqzE0SxPDB+AoWJHQa9qSA5BKqNrxLZIaoXIpc+XJ1usueJG6Obhwq0QsItQtsSt9F66Y5XB4l49ydi1OAukRZuXKprWU23o20u3k7tttbqU2VrS6hr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7Rr13gHy7RLooQLxuHYQsJejXjoKj379qQSN9dli11bd1S3ZdS2tdtKVtr+4yKLiKV5SYFYGRlFVtKeXKCxOTKptc4fYs0ClNtx00tiJDyFD1FXllHZ5Ea3SBU++jRQA3HCDlktZuoDJM6T2gckyzI+KlRM5NN+uEHFijObs2LRyGAMDKvZYlceIeXZcYp/OCBxLPCYtIZc6jNiaCzkQ2xtpLeTkG9EokIVU5UUJVMRMkwRBRe5O1YlBOtytmE+m7/AJb4H/5J6wn03f8ALfA//JPUCz5EHjFsWaZdICcwRfHjA2mNrw7XMwqDOtC8p5AKIOTKsqoumaG3oWobLkyVVPqqfd/4I5X/AKDfvT/BGC/14t6bEVCBeq8Owi1S9GvHMHHv37UlEb67LFrq27qluy6lta7aUrbUJl7ud5joJl7ud5joJl7ud5joJl7ud5joJl7ud5joZsTHK61xLx0S7FqcAMgizcuVNWsptvRtpdvJ3bba3UpsrWl1P338Ecr/ANBv3p/gjBf68W9JHVOt9X/WODx+HwCkCfsuKjvb3B3PtLd3e3vz7N2sh5T8z1IeU/M9SHlPzPUh5T8z1IeU/M9PPW+qdY/V+zuBxOOKuN9r15bd3eNv/Z3b27u/m271P3wfaMelTG7Rx+b+sFh9fZXwAhsdA+tgLinC9aBKXQ6wGSOWhv8AEHXRWtsUt6HH+oXpU/7466HH+oXpU/746wf7KJDPmMCOS1w9peX512syth9zmEH1TJU/mIIHAOuqv1hsGDLU28NZdRHYn/MEqY4RAYQxnySWy2SHoNbGwMbWhcSc4uJxN1iSKCKVldlNtVFlK2IIWKLqJp3Y36j9HyXwYK3TmrW43ZgbXRJyVtpnNwaE1b+NDzuLagbjZFuvlAEXRHkApREpRLhjhI2WXwuXsrdI4tKY44iu7DIGF3FSNbHdocwlVhDm84RZIgYkdW9JVK+26277xKmOEQGEMZ8klstkh6DWxsDG1oXEnOLicTdYkigilZXZTbVRZStiCFii6iad2CmqUfRXZYY08Sujy9tLrfk5EtN4qSNnVzbRCLSw472km3OAEWZxkZ9DBWZjnbA6WzZtWihefof+Kr9T/b3+Fr64RLtP2PbnbPqRxOP2P64dj/Xe0vqns39Uv26/7t/d3rB7ZC/otMZMSWI41NWdtfPaSE5put6q2b02QhdUxxgxZ65pTzG3EAnJkiFcXLIzm5EzAxSBKyNll8Ll7K3SOLSmOOIruwyBhdxUjWx3aHMJVYQ5vOEWSIGJHVvSVSvtutu9Me5t8s1HubfLNR7m3yzUe5t8s1HubfLNR7m3yzUe5t8s1HubfLNR7m3yzUe5t8s1HubfLNR7m3yzUe5t8s1HubfLNR7m3yzTN1TrfWP1jtHj8PgCrk/ZdRR3t7g7n2lu7vb359m7X8iJizXF+SGfseSMZKig61tUCh3Fqd2k9CtpTS/x94DAfGB4DvsLa3hvDNQuoojSlcpssU+jsx+0lZXknSpdXqOMbwpi9vWKKLghbUetaMwZOACCJQkUmPBpAWVkSum6ahSxAEHJ6M8d/E2+oP4PnbHZ8j9et7tXj+2rsvrfbHqf2x/bXV+B7YOu/wB7nbfrz+xOsuM8p+jemTODlqN9JlhfY48ylzxs6LoFN2NmltCvWDdckuIZSCTXORm5THhcbUpOd2rnZfjm6JAQbF+NGJKPRGMt1VlEQQrV1zCySSiVFjHJ2d3Ms55fXlwXIcnp7cHB2ciSTzSF1PQay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0ay94O8u0S2KDi9a4lg6xd61eOGQPZuWqhI2V2XrW1u3lLdltLq021pS2v5MZSl2McmsSjBKGW8hcJe5Gi6BwDi2uAt6ZbY9MjqIC8sjoKpaQ3OoAZiVa3I0trMd3oQN/BnFekeOq0WS13gyzkqkhjEOL3cTq+aLuCo2uDko2qQhtbaUm9Kk3EN8HMigMJxhjRgHjcQjQFy6yQICKixK65JZSq5rk6ujgSY7vbu4LkOLw8HnOjiSQaYQtf/M3/xAA7EQACAQEEBgQLCAMAAAAAAAABAhEDABIhMQQTQVFSYRQiMkAFQmBxcoGRobHS8BAVIzRTkqLxUGKC/9oACAECAQE/AP8ANRt2ZT3qmoZ1DtcRmguRgPrDkJBOFjo9E0dTdFyMDtB454ue3I4YWdQrsqsHUEgMMj9ezcSMe8UkV6iozBFYwWOz+8hOEnHCx0akaWpuwgyO0Hini3nbllhbWv8Aldcuqv3dbj2N08Pu2XrmNujUdTqbvVzveNe454vdGERhaooR2UMHCkgMMj9esbiRj3hNIq1FTRzUCKTdNQzN3hJ3eycASFt0WjqdTd6ud7xr3HO/3RhEYWevVRG0cVA6AkBxMleEHh/oEr3rpVY0dTewyveNd4Z3e+MJjDyupPq3ViAyzDKRIZTgwIPLLnBtV0akzxRe6xUOtNz1aikSDTc+sXWMyDjFnRkYq6lWGwiPXzG4jA96o0zpVIU5AeieqxmDTeeqSNoYSOWA22TRa0BKzU61PZJYOvNHuz6iYOWAm2k6GaAvq4KTkxAcfAN6seUSe86LSFCgL0Bm67k4ROQJ2XR75tX8IKsrRF9uM9geba3uHns9R6jXnYseezzDIDkO8U2VHVmW8FM3cpIyBO6YnPDC1bSKtc9dursQYKPVtPMyfLECSAMyQPaYt93V+Ol+5/kt93V+Ol+5/ktX0Wpo4UuUIYkC6WOQnGVXvCdtPTX4j7fCXYpemfh3hO2npr8R9vhLsUvTPw7wCQQRmDI84t03Sv1f4U/kt03Sv1f4U/ktVr1awAqPeAMjqqIP/IHlAqliFUEsTAAzJsfBx1MhprZkeKf9BzGxsicMsQQQSCCCDBBwII2HvCqWIVQSxMADMmw0F6dNXRyNIU3oB6uXYHPmcDJBwxt0/wDDi4ekTc1cGL2U74nxc5wyxs2g1HpmozTXY3ipiI4Z4tx7I7OWNiCCQQQQYIOBBGw93R2psHQwymQfrMEYEbRbp6mkCqk1ibopwSL3FzXcMycOduh1ruvvnpM34wj0Z3xhw+LEY26eBSN5SK4N0oQQL3FyG8Zzhzs7s7F2Msxkn69gGwd4R2psHUwymQfrYdosfCCam8B+LlcxieKeHlns52dmdi7GWYyT9e7yn//EADYRAAECAwQFCgYDAQAAAAAAAAECEQAhMQMSUWETQEFxoRQiMlJgcoGRwfEEEKKx0fAz0uFC/9oACAEDAQE/AOyiiQkkC8QHA2n94swnGkXfvvzuDYNhl6wkkpBIukh2NR++7HWFEpSSBeIEhjAtFhd9+dwIwbD3rOLif5rhvs9yXSxbHjtu3o0q79958G6rYe9ZwkkpBIKSRMHZ++eLHWFWaEk2oSVEBwkUfFsfcAmNKu/feeGxuq2Hu7zhNmkkWhSUqIe6aA4tj7kBWtaJF++08Nj4tjwedZ9rlpvJIBY7CJMRQ+fCEWqwl1hwCQpSapIreTxcbM4BCg6SCMRrS1aFd5nTaCYHWTt8QZ5zMG1Q95AUhWTMe8mh3+M4sra+bpDKycg/jxlnrNsvSLlMDmpbbn4ng0I+HJmvmjAdL8DichCUpSGSABl6mp8dYUCUkAsTJ8Aatm1M4RZoRQT6xr/nh2xJYE4AnyjlNngvyH9o5TZ4L8h/aLO1TaEhIUGDzA9CdYX0Vd0/Y/P4bpK7vqNYX0Vd0/Y/P4bpK7vqNYIcEGhlGgsur9SvzGgsur9SvzCbNCCSkMTKpP3J7QEgAklgKmOU8+nMpnv/AMwzgEEOJg0OsEgAklgKmDbpUopUl7Myz73tMVE5Hk/O6Q0bXrzimG/OjTygW6UqCUpazEn2793E1M5QCCHEwaHV1JCgUkODWOTkLLlrMTKpUw350aeUaZD6O6NE13a+/d9X/TvKOTkrkXszO9J2w350aeUABIAAYCg1hSQoFJDg1jkyr7PzK3trYNjnTblAASAAGAoO0/8A/9k="
  },
  {
    value: "BULLET_LIST_2" /* BULLET_LIST_2 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAA1AAEAAQUBAQEAAAAAAAAAAAAACgYHCAkLBQMEAQEAAwEBAQAAAAAAAAAAAAAAAwQFAgEG/9oADAMBAAIQAxAAAACfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY8d832469EAAAAAAAAAAAGsueOJbo1p/8Aj3fuAAAAAAAAAACkPWuaeOJvoVp5OTcuPz6BiSAAAAAAAVcZEAAHO72aObsXc2fLtgCiwAAAAAAD9pU4ABaDry3vXmUMfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAh26VXVVYjmyZdvYHD2AAAAAAAAAABq1sR8mD6HNEielP0wsO+KYLFAAAAAFTl9QAAAYrSc8hn6PMtL15MozLU8HJuDzChAAAAAD1CugAAADC6XjX9NxvBqTeiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYRS8R1rsEwbNtAAAAAAAAAAADCmXjlk7+fhFLxN7y7c27KtinyzoABUJeEAAAAAAFg++eXXvZ+rSxH0Nsa9Klz7A8UtiAAe0XOAAAAAAALB986RbUUjalOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABaXryFlqVJx+Vc9jwAAAAAAAAAAAIXepVkMUptlkEgFlwAAAAAAD2i5wAKQ9c7Tao3j496C+PdAGPoAAAAAABUJeEAA1G2Yqb9blqsoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/xAAoEAABBAMAAgEDBAMAAAAAAAAGAAUHFwQICQoWECBAYAIDFTABGFD/2gAIAQEAAQgA/wC3J+3ep8JEuMFzOzvDQQtDW/sH3HXTfTB516PyhO+DwK5Fue+8iP3RPenFxcbCxsfDw/tpAN2KMwM0kco0C7EaQ9H3MiFoE6yS4T9mOyMLc9oXh+JgKB4sj2GIt+fZCJeyES9kIl7IRL2QiXshEvZCJeyES9kIl7IRL2QiXshEvZCJeyES9kIkCvbzmFTXj5f099uZh1zk2VYt/NOvEf07/c/V+zsLvmYfRXgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgeq8D1Xgem4NG2rM/Zz8D6Z9gmMNm4bkOBpm0v1SAdIdYIg1djT8u6ZeUuzwrIhVB+hkS+WF0QEDDHc5V5y9Itf+mEIfql+Evt+104l+unLPciUwL48XubyqNOqILGLT8GTjmNQ25Z+BYZgrDMFYZgrDMFYZgrDMFYZgrDMFYZgrDMFYZgg0yJHUkbcDP/o3h1jZ9y9R9gdYXmdYMlPWuWjmD5qXinc8jpxlol6HSJ8PLTjvjbkteXVA6qoHVVA6qoHVVA6qoHVVA6qoHVVA6qoHVVA6maPmZjcsZ0xP6du+eOme9rPgte0cT+OHyZikoxSz/DOztA81NrEwfl+/m/kCc6YEep0nTk35MH+xc9ksGbz/AHG/W+UG87NeyDYCcd/N/J76LT29TpOi8f7vdk5uSBaF7tfBU7ZDGw57piWuRK1yJWuRK1yJWuRIVkF5fH7Aa8v+7ZvWSFtwIWM4Bn7q5yjmnl9NP6holbGxye3JvZmbg1wabdRW0b2828+CFn/nmfMaVUKqFVCqhVQoejj+BeMN2+w2b1khbcCFjOAZ+5XePFC3PmaTafpJ/IZ4m6O9bYakyepZ1X6x9pevW6mbHunY7gOTUPsbW8/ceUju2Sm5BDfKmB+UHPQO5u6hAsKt3zbyt5W8reVvK3lbyt5W8reVvK3lbyt5W8h6R/554w2n6ZADG+RwM0j52ZNod8/G/wB6TWAi/wAfuIj3pR1WmfojsP8ARVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEqoIlVBEhWPnljfsB0y/p7JcwxTppq05hmBwh0Ue9DefUfBUhfk/wD/xAA6EAABBAECAwYEAgkEAwAAAAAEAgMFBgEABxITpREUlNTV5QgVldMQIBYhIiMkMDNAYBc0VHIYUHP/2gAIAQEACT8A/wDd/E98PG0dxNQK6HU9z96ttqDZS2juHITg0Fa7LEyj6DMLR3VbQq0kcaeVlfFjtlI6cgpyOBmISbhzhpOImIiTGaNjZSLkgnXw5COkA32SwThHnhixnmn2HXGnELz/AHBEcrdKTQxtxsTESLbJTMtu5bxzW4It6PfzhqRjqdGBzV/mo91TTcjD1U2Mw8gg4fChpjcradq6S0lSYLcEouaJ+IzdgWUy9Y7ne3ZbvBFm26q8th8M0Mpx0G8XFsuFk3H4Ks2ODmx2BAxGGhRBBWmxxhRh20tMDjsNJQ0ywy0hLbTTaUtttpShCcJxjGP7bEvmtUGqWG52HEBAzNpnMwlYiS5qV+T1qugyc/YJPuIT/cYaFjjpSSJ5YYAhBLzbSrvOQW49b55T21O68ZFUzcOYgR+LmWqrRAk/PA2iAYwntkXYSVNkIDDgqrHHQ6T4/JVlKJ2U2lvatpFTMCS0bF/PhFLn/iX3eYay5mOkl0atV+Ur0Jh5To5qKE87FEYbtTiXoEasbd7X1CCpFOghu1aQIGux7EcCl8hfa8ce+2x3qTky1OnSsk+VJHvvmlPvOfjPzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+p+a+qHff1PzX1Q77+peUKHc79zGCDy32V8EcYtHG066pCuFaUrTxJzwqSlWOzOMZ/MRY9t9ndx7vibbkdsyTasd8OO+JaXjHwIQ6BfGIr9PvakyMzUXQlCx0PIrnqRhgCLRVxZQHnkHv/8Aj7tOWakYh7PAuJuW7lhbyQh41t8h5yiQEdKjuDcxCLlHOrKw68hj8kR1CU87qI6hKed1EdQlPO6iOoSnndRHUJTzuojqEp53UR1CU87qI6hKed1EdQlPO6iOoSnndRHUJTzuojqEp53UR1CU87qI6hKed1EdQlPO6jeQWxzOU73w93g5rS2XP3bxTjSuJpxaf2kZ7O3tx2KxjOPy1kO3ba7nVs6s2eGLaZWvu5SUuBysW+8y/wDLLDASLQc7W5phvvsHPR0dLgrbMCZcSSZJVbaetrisTskOKLKWeelZM+xWy1SQ4eMDjmWS0S8vMuCNLeQCgxsFsh9sZDqv8uodN3YmKcefX7PvzuI5Jn7bKsAD7Q54m3NXrspDSFyj455JwKrdJT8RCmSI3PhIuxwChJeRo3w/7wUl0ptUtU26lNbeTKAMP4ceYrNugZ49qIOW1jI7J1grVyGZQrjcjCHcYXomRh5ivHDwO6G11mUIm57aWYll18UKWwE46JJwc2OOQdVbRHKzHzoTBTS2o6ci52DiP7cwyNtgu3ETRoiVjlZbkYZW8F9qOz5k3HEJWhwM+Fj72XKBHsLSTHlCNGjZwQO3+Jbuax8Rm2u6+39ujFvv9yc/QuiTu80BM4ESru65aMkNuXYwE15GXRIywzorDiEyJCHvwe5BbHc+U7y2neDmnisufu3kONK4mnFp/aRns7e3HYrGM4l+nxfktS/T4vyWpfp8X5LUv0+L8lqX6fF+S1L9Pi/Jal+nxfktS/T4vyWpfp8X5LUv0+L8lqX6fF+S1Jc8R/vnNa7mA1x8oAp5v94yK26nhdbQr9leO3s7M9qc5xn+QULHJ3h22nK1CzBzbzwNfubKWpmg2Ywcf+IJFrF4i69YCBWex0pmNWO2pKnMKxT5Wi7l7dzhMDZq7LMLadZfZ7HBjwH8pwzJwcwE4PLQM2Ct6Nm4cwKUjiCAi2Hl6r0jA7d1Gq2PbvYR+TFeCVerlaeKDu9xg8vN4UZWahW2pmnuSDSe5SdhsxogRjhVUmRW/wAFvtjlcnmLHU2h7HIfaIRwKdbeRjtWynCuJtXanKsY7M5wrBs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07RMo4QLzuWgh4RbOeew6OvjS0EyvPYh5WU8LiexWE5z24xlOf5Ow9Q3LNhxnRa/b1Zk6xuFXB3cuOd1hNwakfB28OM7y5312CzMO180xtp6RijMt4xrYCY3JOAfUQBGbsbi2+5VdhxSeHCSqpmRj69OMITlXCLZI6ZGypXGtpbiGlNxcdBwcMCLGRENDgjRkVFRoLKBwo+NjgmmBAQRB222BRBWWmB2UIaabQhKU4/y+a/5EVt9t9FEDfpnunc+7KeCqlUCeV/0InJwhHyqtRXMkpJz/AGwxYlI2s/1Tu5ZPw+bhQSPlFMqvzclDMLszfDTXf/iPV9xZBbHzKVfejbIkTvcYUz/cST6gx3/kNFpEQppVq3MvhYRhkPTK0y72tNvlNBFGSkuXhMdAQwh0qcpSR2xyJr/kRW3u3sUQT+hm1lM7yp4Kq1UJ5X/QicnCEfNbLK8ySknP9qKJq2PlllvxVM+HHfiwFOEEkkkOMxte2i3Nk31LdefedWNFUG5mOKcccULWLC8pSouS/FDLhAvdeWghLi2c88wcdfGlpxleexDysp4XE9isJzntxjKchQvhzvUdBQvhzvUdBQvhzvUdBQvhzvUdBQvhzvUdDRjY5XeuYsdktD2OQGQQjgU6a8jHatlOFcTau1OVYx2ZzhWP51MBu+3F3ByOcCRjDMlDyTOFqirPWJVKFFQFpgClYNhZoLKSBCE5bcw+G+UKQk677E3c48jZTescDLMbZ41nOX11izoYwoWA3FgBVITNQqlpHkh0pnoFT8W+tAUedLzEucJGRUVGCEHyUnJHkNigx8eCK26UacaU60MIIM06QSQ62yy2txaU5rYMv8UsuC1J7cbcSbQ58b8PMaeP2tyEg3nmim7wmiu5QWWjLo9DHdci4txc4uQkGPwI7p3vu/8AEcnn8vkFME/0uazxcXJ4P6ieHi4v19nDmw9J9z1Yek+56sPSfc9WHpPuerD0n3PUz3vuneP4f5dyOZzxXxv6vfnuHh53H/TVxcPD+rt4sfz6YDd9uLuDkc4EjGGZKHkmcLVFWesSqUKKgLTAFKwbCzQWUkCEJy25h8N8oUi3g/EHuPE2mWH+HY6TgcARu19JXnKY6zyEURzRTd4TRXXAi5sTGYmuDtuOVlKDJJ4oX/IZn5BtztPT5q7W2SQ2kgvEZDCrI7jFh5cazIzksRhiJgYlpxJEtMnARo3aQU1jN5pPwp7FwRjViuhbW0u3G5sFtVtamT7qEbdrLuPVJ6bue4E+02sCIgKudSmrPMpOejw6rW4qbm4OdKtMxGw8YBLWY4KMjTrHJBhMDnTpkdCiAQwBUuU27IEBRIIUYK8QtgAQcVtplH9w2dY7tuLY6Jdd3oavPc+SnJidmEgbHbN90RngeOnLA+Dfzo8hTTqX2NtTB18osjGRIozdOcFDuu/t1BQl5227qSoA+ZgcaRU20QTVqejhqlNaU0K1mGjcTDoI8xOTLpP417q3tmq91b2zVe6t7ZqvdW9s1Xure2ar3VvbNV7q3tmq91b2zVe6t7ZqvdW9s1Xure2ar3VvbNV7q3tmq91b2zVe6t7ZqG7p3vvH8R8x5/L5Ar5P9LuLPFxcng/qJ4eLi/X2cOfySdkhYu81Sw1CSmKbYZSo26KBskSXDlyVXtUI+LMVuwgsGLJhpyLJYPipBoc4R1DzCM4mLDvr8Nk3L/paLSrhIGgVbejbiZeKRC7nbeTZ7E87t7uGMpJMTa8w+JGKXaYiTg7MBZQ4+DlWErsuNmpEvd2QKdEYcgSN7txHJGC2qrgQ5bmXB4fbusx1gnqsyBh5dbJo9HYdWwy4L3j8hsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RsL4g707RMY4OL3rmIHeLW9nnhkDo4EuhMoz2LeTlXE4nsThWcducYTn8rMVD/EHtkiUt/w+3kxlpChLNkVtUnQZk7Lo62KfuQOEJDS7jjyx4WWYr9tUGe5XER5dbdrO9260vLby7yxZ7ISZeEsFnSKDWage6Mlb7btUosTWgZGLKKJ+W2l6z5a7v3p1hH+T/wD/xAA3EQACAQEFBQQIBQUAAAAAAAABAhEDBCExQVEAEkBhgSIycZEFEBNCYHKxwSNSodHwUGKCkuL/2gAIAQIBAT8A/ra06jCVpuw1VWI8wI2IIJBEEXEHEHQ8TZqPtqqp7vec6KMfO5RzM7Wy0iiooUey0AErduLFwGjEeQ5kEcOoLEKMWIAkgCSYEk3DxN21azVaEFwCp95ZKg6EwIPjjltZ1FlszVnHaYb0HGMEXqTJ8eWzMXYsxlmJJPM8TY64r0zRqwzKI7V++nOcSMD0Ou3pGr3KI+dvoo01PlxSO1NldTDKZH7HkcCMxtVqGrUao1xY4DIAQB0AA+L6FgLqHrErN4Qd6P7iZidImMSDcG9HUSIUup1kN5gi/oRtWoPQfdfA3qwwYcuYzGXhBPD2VA9opKcN4nx3QWjrHrt6BrOWzRlI6kKena/QcRSqeyqJU/KwJGowI6iRsjrUUOhlWEg/zAjMZH1ekKy7ooqZYkM/IC8DxJg+A58TTrVaR/DcrOIxU+KmR1idmttoYRv7vyqAfOJHQjbG8/GFGi9ZwiDxOSjU/YZ7Wiw7iB6UtujtqbyYxYfddMOJo0XrOETxJOCjMn9szdtRopQQIg+Zs2Op+wy9VssmNakNS6D9WX6kdRxFOo1Ng6GGH8g6g5jaz2hbQsi5x3l05jVTkcsDthebgMTta7X7WadMxTHeb8//AD9cTxNOo1Ng6GGH8g6g5ja0W16yhFG4sDfg946fLyzz+IkRnZUUSzEAdfsMSchtUs9ls1IGqDUc3DtMpZoyAIAUamYGMmATeSQIE3DTlffdz4mwUgA1oe4KCFJwAA7bdBd/ttaKxr1C57ouQaLl1OJ58gOIU7pDXGCDBEgwZvGY1Gexp0bbSDgBKgESMVYe6wzXMTfBkRftbGFCzrRS7e7PPdW9j/kYB1k8VZq5oVJ9xoDjlqOa4jW8Z7WuqK1ZiplFAVcYIGJ6mfER8Uf/xAAzEQEAAQICBwYFAwUAAAAAAAABAgMRITEAEkBBUWGRBHGBobHBECJg0fAyQlJQctLh8f/aAAgBAwEBPwD+tsomDKI80PXaqs9SDLfkd7l0z8NKNLXdeeJfC/7ni8Q83uTaFsLwx46QqwqYDjwcHvOP5fSotWqQHAbf5Phj00AiAZBY2mtTacteOAu7DVfs7unDTs0f1Tf7T1fbz2pCQiXHP89NIRIRImR/18/q+p2iykAbYMnK/Lj3+pmdpmONk4Wt0T3HSnUjULnibx/Mn3ubRVWNOSZ2t1Q9/j2dSoH8hHwL+20TjrxlHiee58HRGKiWTM+HZ4N9dMASPNyXuDDveTtMoQn+qI89/Ux0KFMb2v3tzp9/rGc4043fA3r+Zu7SlX1m07F35Xccn2eu0zmU46z4HF4aTnKctaXgbg4Hwo1soTeUX2fZ2iUSQxkXH866VKbTeI5Ps8/hRo6vzS/VuP4/79NplEkMZFx/OulOgQWS6zf5eR9/qJSIycgu6RqVas7RSJvwGxzuYvda/Iu6efPae0TvanHNstvKPo9NKcCnEN+cni/YyNoS4nHDDB8HdprToTYuMc7OScTOzx54Y6URqVGbux8XI8MU4WNqq0ypG37jGL7dz9ndpRhqQBLLi+x087/VH//Z"
  },
  {
    value: "BULLET_LIST_3" /* BULLET_LIST_3 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAA0AAEAAgMBAQEAAAAAAAAAAAAABwkGCgsIBQQBAQEAAwEBAAAAAAAAAAAAAAADAgQFAQb/2gAMAwEAAhADEAAAAN/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGj71dTxfXD2hLPeC5W2AAAAAAAAAAAOTF9Fzas7ztMhTrO/O9IDySAAAAAAAZceiAADkxfRc2rO87TIU6zvzvSAwsAAAAAAA/aZOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVTbEtXTfhvrcjc/cAAAAAAAAAAAVyXnyre/z4Dzx21efs9BTjboxggoAAAAAycnUAAAGEe+cz/u6FIm1Lpg8Lfvx1LD5hggAAAAB9QzoAAAAwj3yrPYncHrVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFM+zKMsvLTdenpjDIAAAAAAAAAACuu2GV+PdMs9f8A3I7AGnYY+Q6AAZCTCAAAAAADxBXCIMvLN4U19NyGwlp3HxSMQAD7RJwAAAAAABWLeflWmNzetWScfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKmNiUWZJTxWz69QAAAAAAAAAAByYvoubVnedpkKdZ353pAQuAAAAAAAfaJOAAOTF9Fzas7ztMhTrO/O9IDz6AAAAAAAZCTCAAa8m7CAs/J9w92G9K4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8QAJxAAAAYCAQMEAwEAAAAAAAAAAAUGBwgXBAkWAxA5CiBAYBUaMAL/2gAIAQEAAQgA+qbEfUtTriRNqR8bW4/bl2QjXd6lqdct5tRwja4/yN2vldnN20leV2DPs5IohyRRDkiiHJFEOSKIckUQ5IohyRRDkiiHJFEOSKIckUQ5IohyRRDkiiCFOznMVRXj5ft3a+V2c3bSV5XYM+yvEeK8R4rxHivEeK8R4rxHivEeK8R4rxHivEeK8R4rxHivEeK8R4rxHguRqbKszo5+B912ubXGW1fMt/pTKbU36lp1yB+1Kgdi5YZlp2Wl5yTfH2mbByLWrE9TSGMZOScemYL0rN/n+Hp2t0bmM447ba+3w7LIxzCpNmWfgWGsBYawFhrAWGsBYawFhrAWGsBYawFhrAWGsBYawCNWSkNVIW4Gf/Bym1QLxIFWta6W67SivtbC+yHSa1tW1XzxL5JNa1ulHSigdbCBx3RdHsclOOeFuSV5dUJ0VQnRVCdFUJ0VQnRVCdFUJ0VQnRVCdFUJ0VQnQTN8TEZljGmJ/Fym1QLxIFWta6WuXSjEbWwvnSdJrfuEgNt/WxHuVUU4CGk/NvDFdLJXUlYmS9YObjPFD4R2+Ptpkwpof65ZXyBROt6ISHhLD5nGXSY4ngQi3utmXtj2VRtkEZDnmmJa6iFrqIWuoha6iFrqIJVwTk8PsAry/wC2yWLmZNKCsmozlOqidKbmTGxMFKlysrGwsbIzc1jloVbKtw3TlM1fZQk/54nzCkVCKhFQioRUITzcfgTjDNvgS41NRglc4fQfjFzNHHWdXH6CZl20TPNawbdJhpGX+vvbvN1Zxzddcse8v7G+mYMlvN1ZyMddDMezXyN2vldnN20leV2DPst4W8LeFvC3hbwt4W8LeFvC3hbwt4W8LeCecf8APHGGU+7dr5XZzdtJXldgz7KoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEEq3xyRn2AaZftlJ6aWCkt5ButJJx/1Gtbwi36aWCkSJBtTJJuPs3//EAD4QAAEDAgIHBQQHCAMBAAAAAAQCAwUBBgAHCBESE5Sl1RSV09TlEBVXtQkgMDNAYHIWFyEiIySX2Bg3qNf/2gAIAQEACT8A/KmU+iXN2Nk/mKbaNtSt72LnDJXYdGjx8eUh+dOgc+LbhyTquFuJW5HwUYxVCUUoMlVFKVknoRf43z4/2TxlPolwljZwZihWjcsrZFi5wxt2AxpEfIFLfgjp7Pi5IcY6jgjaUOSEFJsUQpdKjKVVKk/iPjdKfJoX2fG6L+TTX1J+a70O8fE/Nd6HePifmu9DvHxPzXeh3j4n5rvQ7x8T813od4+J+a70O8fE/Nd6HePifmu9DvHxPzXeh3j4n5rvQ7x8T813od4+J+a70O8fE/Nd6HePifmu9DvHxLyhQ7nbt4wQeW+yvYjjFo22nXVIVsrSladpNdlSUqpqrSlfrfG6U+TQvs+N0X8mmvqRHMJTzuIjmEp53ERzCU87iI5hKedxEcwlPO4iOYSnncRHMJTzuIjmEp53ERzCU87iI5hKedxEcwlPO4iOYSnncRHMJTzuIjmEp53ERzCU87iN3BbG83TvbD3djetLZc/pvFONK2mnFp/mRXVr101KpStPzqoG9s9r2BPHyUyUHPozJXRJM0qwu57nWxVRUBl1AFKQqamlIS/JPpTAwKX5R9awr3/a3KDO29y5uEzV93sh/wDHy5J4lDbUR7uAa/6Q+4E93oSSfYu798DunR70u1SQBl4eXBEk4qVjCxz42TjTx2ygZCPOFcdFNBNFdaJELGddHJHdbeZcW2tKq/h7CuPMe4HpUKycv7aioyUXbj19T4xy4MnMC5wxnQ7Qs8ZQTzxxxb7Jss+geAgW3peSHqzeZ17Zj3sdUg44itWY2HjWarTFWxbEUlahYC1oAVVAoWFColgRhKnHFPmPlFEYEvDNTJjMi4wrRyOloWNlbtvXJm6JkitBYFuOj2TZWYylOIW4+cGwy89l9XtM4CmluJlAxvY9uC2Ox7p3dtO7G9PFZc/pvIcaVtNOLT/MiurXrpqVSlaS/L4vyWJfl8X5LEvy+L8liX5fF+SxL8vi/JYl+XxfksS/L4vyWJfl8X5LEvy+L8liX5fF+SxL8vi/JYkt+I/2zetdjAa290AU83/UZFbdTsutoV/KumvVqrrTWtK/YWlB33l5fcGbbl3WjcYTchCzsLIN1aJCNGdp+l4chlTRQRTTBoT45Y7D7Y85fehvfc4pm0bueS5ITWU81IOLcGy3zIJbR+pmzrxeS0Lc4rVAjaj3EO+wZaU5feYd9zgVuWjaNuBOSEzOzMg5RsYMMZun6niCHlNCBCNPmmvjhjvvtjwd96ZF9waWbvu9lLchDZUQ0g2h0nLbLYl1H6WbwvBlLRdzltVCCqPbo7DBfsW+2OVud4sdTaHqbh9ohGwp1t5FNa2U0VtNq1pqqlNVa0VQ2a4gHp2DZriAenYNmuIB6dg2a4gHp2DZriAenYNmuIB6dg2a4gHp2DZriAenYNmuIB6dg2a4gHp2DZriAenYJlHCBd9u0EPCLZrv2HR17aWgmV11IeVVOy4nUqia110pVNfsbSg77y8vuDNty7rRuMJuQhZ2FkG6tEhGjO0/S8OQypooIppg0J8csdh9secvvMO+5yYZtG7swUhSE1lPllIOJdGy2s8ltH6mbgvB5LVwXOK0EEbUcQd9gv8AOGjFmFp/aR1hvqjczmrEnYqw8iMmZuq0oRB5n563GORacXPt7Bzb0OOpTDUnGnW2bNR9xCHxoX0TEfd+Tce04fdEron6RFpZl5nWXDD7RJp7WWMhrl8wSRAGn1qCgnYMWq0b0iXDbqltd7MXjZciUVESQz4z8TdFnXPHUb97Wfe1tG0RJW3c0VV5lZABre6LCICmIkqShJKNky/w5S469rQy6HgrKl2krU/AXjmddVu5VWtcgyUJVSpVtz17R86LR1KhqkRzXa0qG3tKxYzNw0tSHu3Nq6FJaem8wM4LqjA5XMC77gluzsHTBJU48/Hw7smp8uNtiOg4NL6xotjVhlEDlN9Ktkbm+VmHlzE0GjrbG0kNGqJpmGZm2PEi0aHZlbgsd0mMk1MjtuSs9dN03BIvnGmbYfsQy4QL2XdoIS4tmu/MHHXtpacZXXUh5VU7LidSqJrXXSlU1CheHO6jgKF4c7qOAoXhzuo4CheHO6jgKF4c7qOBoxscrtW8WOyWh6m4DIIRsKdNeRTWtlNFbTataaqpTVWtFU+2cabuXMzLU5uyO0loACczFtKRjr7y4HkznKVQHEk33a9ujy5Skq7PGOlu7C6oompqLa0p8jooLKrSnyZnquRd+2FmnY6E2vPykpbh+7k2oC6z41ych5JpJkey4cTbpEiueg5cUYhgQMRh0ossp1scYUYdtTr5BD7qkNMsMtIU4664pLbbaVLWpKU1rR5NwaJf0bGVV/5K5e5rB0oTbWbGk9nSKuIzLfsCSWMO3K2vaWXhLsDJy8e+eI+cJAy0YSVAXlHlq9hHZO19n/uNzv8Ad7gpgn7res7W1udj7xOztbX8dWzW4eU+p4uHlPqeLh5T6ni4eU+p4uHlPqeJntfZO0f2/u7cbzfivjfe9ue2dnfbf3atrZ2f4a9qn28jmto06UAQqBBNJzRYv43KDN0wYcZgYQO6ZGOHMhrvFZbCjBqkzkO/cLUXGiREbcEaA2lpP0kX0gGlPlQ0ulTcmrlzaRZOX91st0b7MNfYtsDKlbnQO43R9p+kpGnNkUo6wWzVZFH7DtnLTLazQax9tWbaMWxEwsWw484US4gdhNFEHHmPkSErJmOESUtJElSUmWWeUQQ5+X9KL9js0ctZx23L1tj9yekVcPuWaZZZIdD99WrlHOW9I7LJDK+0RMseIrb2Uv1UlSU6Y/8A560qf/h2NKL9sc0cypxq3LKtj9yekVb3vqaeZeIaD99XVlHB29HbTI7y+0S0sAInY2VP0UpKVfiPjdKfJoX2fG6L+TTX1Le5t6Zi3ubemYt7m3pmLe5t6Zi3ubemYt7m3pmLe5t6Zi3ubemYt7m3pmLe5t6Zi3ubemYt7m3pmLe5t6Zi3ubemYt7m3pmIbsna+0f3HvHf7vcCvk/ddhZ2trc7H3idna2v46tmv1fjdKfJoX2fG6L+TTX1DYXiDunYNheIO6dg2F4g7p2DYXiDunYNheIO6dg2F4g7p2DYXiDunYNheIO6dg2F4g7p2DYXiDunYNheIO6dg2F4g7p2DYXiDunYNheIO6dg2F4g7p2CYxwcXtW8QO8Wt6u/DIHRsJdCZRXUt5NVbTidSaKrTXWlE1+rmxpaQl85wXSRd1yxVkX1k9G2mDJEDCirYggZ7Ie5JgYGjYjakNyE7Jv0WpdakqTVKU52abv+SMh/wDWzGbGlpN3zk/dI93W1FXvfWT0laZ0kOMUKhidBgch7bmCQatluKW3HzsY/VaUVoSlNFJV+Zv/xAA5EQACAQEEBgcGBAcAAAAAAAABAgMRAAQhMRJAQVGBwRATNFJhcqEUImBxkdIVMlOSQnCiscLw8f/aAAgBAgEBPwD4UhuMUkSOzSAstTQrThVCfW34dB35f3J9lprjFHE7q0hKrUVK040QH11m69ni8nM9F67PL5OY1m69ni8nM9F67PL5OY/kTd7u14agwQfmbd4Dex2DibXi4qUBhFGQUK98D/Px25brZYHAjMaxd4TPIEqFGZJzoM9EbT/04WjjWJQiCij13knaTtPRfbqrK0y0VlFXrgGA2+Dbt+WdNYVipDKSGBqCMwbXW9CcaLUEoGI2MO8vMbPlZmVVLMQFAqScgLXq9NO2itREDgNrHvNyGz56yrFSGUkMDUEZg2nvUk4VWoFAFQuTN3jyGQ+MUu/uCSaRYUP5agl2G9UGNPHjSlupuz+6l5o2zrEKqT5v4eNbSRvExRxQjiCNhB2g/wC46xd4xJPGhyLVPiFBYjiBS08hllZjlUhRuUYAAbMM/Gp6K9bdG0sWu7ronboSGmjXcD/YDWIJOqljc5K2PlODehNLXiIxuSMY3OlG4yZTiMd4yP1pQ9DDqLt1bYSTsrldqxriul4k4gHx2jWY7xJGuh7rx/pyLpLw2jgabaW9r0cY4IY27wWrD5VwH0szM5LMSzHMk1J+IEul4dQ6x1VhUHTQVHyLA/UW9ivX6X9cf32e6XhFLtHRVFSdNDQfIMT9BrN17PF5OZ6L12eXycxrN17PF5OZ6L12eXycxrMd+ljRUVYyFFBUNXjRwPS34jP3Iv2v99pL9LIjIyxgMKGgavCrkenxP//EADYRAQABAgMDBg4CAwAAAAAAAAECAxEAITFAUWEQEjNBctEEExQyUmBxkaGxssHh8GLScIGi/9oACAEDAQE/APVSfhE4zlEI2FMxv9WPKam6Huf7Yh4ROU4xSNlDIb/VtNXpJ9p5KXSQ7RtNXpJ9p5KXSQ7R/gmpUKZvk6H3eHzxSro2m3F19F7vltNSfi48613Q3X48MSkyWUm68lCqiQbo5HWn4+W0IIiXHUxVpNNuZxdHdwfs4BUAuuhilSKZdzk6u7gfd69pQREuOpiFKNNUzXReo3Hf64yq5sYRZyNbZA8XT9trjn1TOVK5/GQoezr+GIyjM50W58R3PH902irJjTlI1DL2rb74pxIRDhd4rq/vVyW5lYtpUG5/KOd/d8VdoqR58JR3mXtMz4mKc+fEv5xlI6xMtOP41OQfGVecebTEHqZOtvYbuDom0ypxk87OMvSi2fz88eJv59Scjdex/vAAWAA6j1ga1OKjKyZOUu7Hj6Xpf8y7sFanJAldcjKXdtNXpJ9p5KXSQ7RtNXpJ9p5KXSQ7RtMvB4SkyWV1vklvpx5NT3z95/XEfB4RkSGVxvmlvp9Z/wD/2Q=="
  },
  {
    value: "BULLET_LIST_4" /* BULLET_LIST_4 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAA3AAEAAQQDAQEBAAAAAAAAAAAACgYHCAkDBQsCAQQBAQADAQEBAAAAAAAAAAAAAAACAwQFAQb/2gAMAwEAAhADEAAAAJ/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAOj9d54AAAAAAAAAAAA4iEB1ck3/la+UAAAAAAAAAAAtjLzz/AHsYos2/PKcwaJ//AB9tzo+jEkAAAAAAAq4yIAAMQbI+Zb3ef6Z3C6GYVcgKLAAAAAAAP7SpwAAYr2RyorkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANDeun8NgNM85KpgAAAAAAAAAAatdFeVNcsoa5aD9dO/DJcKYLFAAAAAFTl9QAAAYrWRwCthtoz2aMNdMg3HeOsKEAAAAAO0K6AAAAMMLYYRWw3N5buxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABS3vkZDfQNkdE9uua0AAAAAAAAAACyM4+MJ9NyxMG5umfHyNop8s6AAVCXhAAAAAABZGcfGE+m5YmDc3TPj5G0dKWxAAO6LnAAAAAAA6P1ph01DMGuWfNMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABqL01bdM1oAAAAAAAAAAA4yPNto857tYfRl4m6Qpjv5QWXAAAAAAAO6LnAAtrLyKn0M8C7r455vI2SsefouTH0Y+gAAAAAAFQl4QAAR+dlEgbHeAAAAAAAAAAAAPk+gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf/8QAKxAAAQIGAQMCBwEBAAAAAAAABgAXAwQFBwgJFgIKEAFAFRkaIDA4YBJQ/9oACAEBAAEIAP8AtckovJOI+nuY8eBKwI0zMxN/FuunfS4CgR4E1AgzMt7e7R6T24EJ8lEt1u7rYJdWqFeI1UWlLd1sFtXUBPEmmWlPCq4ohIEZj45IRLkhEuSES5IRLkhEuSES5IRLkhEuSES5IRLkhEuSES5IRLkhEuSESBa3WZwqpcvN/bmvg3jtn7Zas2TyI9NRWSXzOoesWLhRgtjjgFZujWZx38t4HpvA9N4HpvA9N4HpvA9N4HpvA9N4HpvA9N4HpvA9N4HpvA9N4HqnBo3SpyDPyH3dOLAL0Zp9eaEP+uL9luW+Xt1T2y2omqRu4XsPCmbgzmB+e9pc9rbERWDe33XXxL8dNWeZF0wLCvHcJxQxSsLj8AK7NFkMbt/+IRmAeDKozlKG6lPyDhmCcMwThmCcMwThmCcMwThmCcMwThmCcMwThmCDTIkqpJTZCf8AwZw4x0fMvEfIHGGs6q9hFIuIFUXCbKi511bZ2VCqzce72Ftcq2zPY7X9mFP8Vmky9cpszS5tqB1NQOpqB1NQOpqB1NQOpqB1NQOpqB1NQOpqB1Ua31GodSlqpKfhy5154bZ00mn07KAH7ffWUKklHJimj0ekD1KptCoH9ccl1Nt+EmJ5Wfq5dby+rl1vLW9uhxc2hm1yQOwPt8mf1vyC89n5+yGYfkqq0xQ6DP1SUdciTrkSdciTrkSdciQrcGs1yvSFLm/zZM/rfkF57Pz9kMw/JDR/j1HnKSmhTQpoU0KaFD1uPgNYk6t+cmHKKYjZAIkf05GmZfTkaZlh9rAwZwIJDEuxN/oPmS2/6tx/rrv6PcRYsKBCiRo20XuGMUsKhEiBLARMjL3Rr/8AplJF1c9wpinmwJC4DfuBHgTUCDMy3h3k7yd5O8neTvJ3k7yd5O8neTvJ3k7yd5D1x/j1Yk6T9t1bM2ivoKTYLenaN2v1mbgiJTeHXfxAr5bwFauu18syAiI7d7Ypa2zdo7HC8sEWX8NQRJqCJNQRJqCJNQRJqCJNQRJqCJNQRJqCJNQRJqCJNQRJqCJNQRIVt9WaHXpCqTf3dGpa3EPe905zdPuv89Pp1evX6fxn/8QAPhAAAQMDAQUGAwMLBAMAAAAAAwIEBQEGBwAREhMUpQgVlNTV5RCV0xYzQAkXICEiIyQwV2C2l6jX2CUxUP/aAAgBAQAJPwD/AO0/BW4qQf2kVF72xymFq/7sS/3K7N4Cn1Ft94e/uERsLw+IHi/iTCbNmwiHcODkQEAABRUhTGKSqRiEIaVLIRakoQhNVKrRNK11dQldiOmPwdi9N4tk17nLHquel0qzq5G7FQqIVvltwZoWUZrFUmJmreaS1cPKVYGMJw2cCGdu4ARBgHAZFCCMEo6qGURRqSsZEKUhaFUUmtU1pX8RhvI+cpZmIhBWRi+QxbHXM84dE12gNlrJGMLcUnZVS6jHPFerQIiGrJ05U3bOMEZA/J/43fM3Ubeti3ISS/PBla3HLhy235q91wsAyb48uFkMSDQePRvIadbrkY2Tvi87cfKZ/DAmQ+3/AIviGzVtbVm2k1nJDNeJrSCdtGDpBXk2YTMYrHFvqdt0oi8jNQQ8C2owh4y+bLt1uJqPDWQ8GTToQ1uLHyXKYsl7iZLVRW/vvMSZHydbSxUqmih706F5wii5li0c0cNW/wAJ+a+aPvr6n5r5o++vqfmvmj76+p+a+aPvr6n5r5o++vqfmvmj76+p+a+aPvr6n5r5o++vqfmvmj76+p+a+aPvr6n5r5o++vqfmvmj76+p+a+aPvr6n5r5o++vqfmvmj76+peUdNyc9xAOH7s4V7kc8WjfEUqkK3VpStO8mu6pKVU2VpSv6VkMbjiXAHri0brbhA3vfGdzuG3Ba3hYVw8NbuFmGhEAU5b0UWIn2Yaw1yR0vCOXUeYTUGQy3uZmK/yNHarTXiMUae7E5mpQNCkTAGsECp0UasyXlJ1SLLMQVw1U2TYkdbke3asl3deLhs2cX5ky4m4OG6uy/bk4SXs1KuzLOVs0qsUNANTUh7bjYiFbNWAfjEdQlPO6iOoSnndRHUJTzuojqEp53UR1CU87qI6hKed1EdQlPO6iOoSnndRHUJTzuojqEp53UR1CU87qI6hKed1EdQlPO6iOoSnndRHUJTzuo3gOwcThF5x+Xc4olhJ+7M6IJW8Ii0/tIrs27abFUpWn6UbHjyCTs2V7OpnyWrdDw8CrJAcgJOs6AcY5UGaiZVMc9FiaIC1BRYVFSL+7sGY2yRamLbie2NlDtv8AaNm5mE7M8De7FLYkhbmOIm01/bDKzqKGQoHsvbw3rNs7JHyCYWQtSRibglzdgTtr21GiJIXBha0WGRMJ5OkWTbeduI7GN1SbUdp0ligEpo0PeK5XeWUSAwsg5XSqYi6ceZGxncziwM7YIyOw7myfhXIbEjoDq2rtiq7tVtXZGD4kDOAQNtKgaPWzhvGT0TPQUR+HePI27GuOImxoiVjlVHIwyswX7aOH3k3HOErQRm/hY++3coyfgWlzHumgnratHDceoxnGQON8a2zEuVsxKF31czmPFJ3ldTzfKZa5O7bsezNySa6lWjnZMyQ0G3SISNUFGD/KLdmztB4qzhAtyEGxmrh7M1pMso2bkZ2xGmgC3R3PFxNkt5M1VLFAx79sCgSP36n3wNwHYOT4ReGIu5xX7UJP3ZkEEreERaf2kV2bdtNiqUrSX6fF+S1L9Pi/Jal+nxfktS/T4vyWpfp8X5LUv0+L8lqX6fF+S1L9Pi/Jal+nxfktS/T4vyWpfp8X5LUlx2h+c4ouTYC3+EwdGH+8C1GVO6UaFfsrpt2bK7U1rSv8h01jk5hxtOW1CzD4ZjMbfvMKRTNg3M8bt/4hy1ti+Iu3rgcNQ7Cugxq241JUSiqSIMP/AJQjs0RUdibK+Jb8cNoKZySmz2bOIt/K+NHDsoml+wd9W+mHn3ZreqQqJB+5kWcfW1JG3JmVv+z8Y2DbwOYm7xvu4oq17cjR1pXhpcy0w6aM0ncKpwmjWhVOXh6pbtRGOtA1W/PwfY97MmL7o7N/Yplrji5GBe5qvG7JRyHM2d4qKk61cAtUbJMjYkSdTZiqWZGhkOwsrjtq6Ydl8FnG3dcHiLbqGg1OAcThG4oozIptWFNFbw1bU1VSmytaKo9mvEMfTtPZrxDH07T2a8Qx9O09mvEMfTtPZrxDH07T2a8Qx9O09mvEMfTtPZrxDH07T2a8Qx9O09mvEMfTtPZrxDH07TmUI4a8bhocGaLDXjgK3XvpEyCuuxBlVTukTsVRNa7aUqmv8nBNpZIkIQC29uXlRUpa2RbaCtRC0bwWQrQfwV4MY5LpdHy4PvgkA8ejCeQinlRpprFl/ZucW4si7dhs8ZjyJku0oehRjFUIrQkpsFuSLWgxoTyc5GyrRW6hRArWEChRcdBwcMxaxkRDQ7FtGRUVGsQobso+NjmQgNGLFo3GMDVo1CIDcKECENCEpTT+7gPnMPZNrXDd0q2jBgNJOI224l3MvgR4XTlk1K+K1ZFG0G5eNAEOoaTOQDqoqMJ9t3/TfA//AGT1hPtu/wCm+B/+yerCz5aExi21om7rgc5gtfHkBGvI2YllQzUEOay8p5AdOHw3SKkON6zjwJBsUNyUn7qn4f8Aojlf/A574/0RsX/PDfFASOGvK8NDhJFhrx3jduvfSIgV12IMqqd0idiqJrXbSlU1ZQvh33qOmUL4d96jplC+Hfeo6ZQvh33qOmUL4d96jptGDbuua4i24XaDU4DNw4RuKK9Mim1YU0VvDVtTVVKbK1oqn87+iOV/8Dnvj/RGxf8APDfFxynN8v8AxHB4/D4DoDn7rih3t7g7n3id3e3v17N2tw9J9z1cPSfc9XD0n3PVw9J9z1cPSfc9TPN8pzH8P3dwOJx2p233vPG3d3jb/wB2re3d39W3ep/OZ9429dUHLW5PR/MO2fPws4wcRkoz5tgdq+a80xdHBzDNy3dg3+I3OEyUET2OP9wvap/5x12OP9wvap/5x1g/81Fw39BsLcu2Q/OXl++u9oWMfqk2TPlMlX/eLFhwHyqn5iMbM3ZNvDMcgdg/7huRmUiOy2m4CUScXCa52rOKvpdhr4zke7LrwjVpeFUNG51GAYDYy0ma1GL8QQYQhGspSlWkYhCGmqyEIRdaJQNCaVUtaq0SlNK1rWlKVrq7bQ7THafex7+PgbfsSej7mxnjeYqpwwpL5UvOCeOYyrmDeBOY2O4F46ux87aDjJutnsZAU8HJFzFz9TJAsuUycR+tdy0yCCaRPhn6OVbUUIGSGOomdB8gNohEchrSPTRtS7bU7NvanE2ZRMzat5yooDHOSJgYUBXO4uvWXIGFCqbc7iw4/uSSZXYxkHdYeDpeLRp385MJw2cCGdu4ARBgHAZFCCMEo6qGURRqSsZEKUhaFUUmtU1pX4291b2zVvdW9s1b3VvbNW91b2zVvdW9s1b3VvbNW91b2zVvdW9s1b3VvbNW91b2zVvdW9s1b3VvbNW91b2zVvdW9s1b3VvbNQ3Kc3zH8R3jx+HwGp3P3XIh3t7g7n3id3e3v17N2v6GL8f5Zsx8lVHVr5HtCAvOCIpVUKoakZcLCQaCcjWMRQuhCQ5bmEE4CjMIa0sVYmy3FNns467P7+YdvsV5FS3Cty5irFezRncpji73yqGrEM3Eq8x+8dcjCDjbIYkNONrbnPtx9o/sh9kO63n2k+1fefcv2b7l4PeHfne//jO6+X5zn/4Tg8f9jTBOW8qTUewmWfZ/j5qVi8a4zIZTd+1Y3nLW5JRsnka72SRjbzMch+3x40MaThSR17tBtZ4mL8e4ls5n+tta2NrOt6yYAS95a1FpE23HxrFRyEKUpXCwqMYxSlKRZCkUr4PYXxD707T2F8Q+9O09hfEPvTtPYXxD707T2F8Q+9O09hfEPvTtPYXxD707T2F8Q+9O09hfEPvTtPYXxD707T2F8Q+9O09hfEPvTtPYXxD707T2F8Q+9O09hfEPvTtOYwjdrzXEQ3M7WavHZuG6NxJWQUV2LMmqt4idiaKrTbWlE1/StZiKw/zBucwiiG7Bu2h1drAlxJx0e5nDWiyN3hy2a6c36cyWjZynIpGt1LcFkuIcn4pKaLUlKVL2U3lJRVVUJqr/AN1Smq11TStdiarVWmyqq7f7M//EADwRAAECAgYFCAkDBQAAAAAAAAECEQMSAAQhMUFRExRAcbEQIjJhcoGRogUVI0JSYIKh0kNTkiQzUGLB/9oACAECAQE/AP8ANMWfB2fr2vU1aoze1m0rY3NJvl81m0pAUQCpKBmqZvKFH7UqtVgpaJOmMrAjopPUHNvWq7AA8laqsFTxJ0wVG8lpVHrHxH/W03kE0UAksFJWM0zN5kpP22iFFXBWFoLZjBQyIxHC8W01lGg0/utdjNdLvms3W3UixVxlFay5wGCRkBgON5t2rSHRaLCefvlb5vECHDSFVlaklQdMJABiEZqJsS+R8XsH9Evm+2hHBZlUn6gLW3NvFIsFUJQBZSVB0LTalacweIw3MTs9VQF1iEk3TE75QVN3tSKsxIi1m9SidwwHcGHIkz1OID+itCknIRDKRue1s22iFE0URET4VAkZi4jvDilYgkExYfOgrMyVC0Je9KsiDZbxeiUqWQlIKibgA58BSK0CAIDgxFqC4oDGQAc1D54nK3Ah9ohxosL+2spe8XpO9Jcd7PQ1yOQQFBL3yJSk+LP4Gl9p+bwHIAvJA8S1PV0f44X8l/hT1dH+OF/Jf4Uj1WJVwkrKCFEgSlRuD2ulO0I6aO2niOX0l0IXbPDaEdNHbTxHL6S6ELtnhtAJBBF4LjeKa7Wv3fJD/Cmu1r93yQ/wpFjxYwAiLmALjmpDH6QPmHQHVtM36jfQzPuns2qr1KJFIKwYcPEqDKUMkg8TZk91JEyaOUSSyy4SszUj1OJCJKAVw8CA6kjJQ/6LMS120JUpBdKik5pJB+1KvX1pITG5yTZP7yes4KGeONt1HDTOGZ3wa93yalYr61Epg81IsnYTK3P0Rl72Li6ilKWXUoqOaiSfvtOsq1TQvbPK726Npm8bOzZ80f/EADkRAAECAQgFCQgDAQAAAAAAAAECEQMAEiExQVFhcRNAkaHBBBAjMlJgcrHwFCJCgYKi0dJDUJLh/9oACAEDAQE/AP7rDW9MNM/wNMfe+3drJJAoBVgG4kSixVl0sUC60jE3HDaeaFFWGSxWLrQM7hjtEgSRSCnAtwJ1haErDKGRtGI9Zy0StJo7XrwrfZTurkhCUBkjM2nE+stamifPtmzd797zEUokQgCBQVq6oOF/qyvp00+4sXUg/Is215IWFhxQRQpJrBuPre41iKSmGoitm2kDjJCQlKUiwb7T8zTzETYySP5EqB+kO/kNYWmelSbxvsPyMoa3ExVC00EG1qiL3F3k0iQA5IAvMkdJE0je4kFKDU5tOVY/6DrKkIX1kg427RTIQIYpYnxEkbPz3wJYE3AnZL2mHcvYP2l7TDuXsH7ShxUxCQkKDB6QOBOsL6qvCfI8/Jusrw8RrC+qrwnyPPybrK8PEawQ4INRoloIXZ+5X5loIXZ+5X5kmGhBJSGJorJ8ye8Ok6XRv8L/AFVt/mnWokdKKEspWFQzPAU5SnGdOcznd7XlDjpWAFGarGo5Hgac9YIBoIBzDyicnBDooPZsOVx3ZSYu1tTWvKHycAOuk9mwZ3ndnXIACgAAYBvLWdGNNPaia+E6rypzp70f/9k="
  },
  {
    value: "BULLET_LIST_5" /* BULLET_LIST_5 */,
    img: "data:image/jpeg;base64,/9j/4AAQSkZJRgABAgEA2ADYAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/CABEIAPQA2AMBEQACEQEDEQH/xAA2AAEAAQQDAQEBAAAAAAAAAAAACgYHCAkDBAULAQIBAQADAQEAAAAAAAAAAAAAAAACAwQFAf/aAAwDAQACEAMQAAAAn8AAAAAAAAAAAAAAAAAAAAAAAAAAAA6oO0AAAAAAAAAAAAfyRHejl3ZZbtmVFgAAAAAAAAAAAGkbVTFP6Ge9kfZ+3H284MSQAAAAAACrjIgAAgK9fHREvJxPJ15MQkBRYAAAAAAB3SpwAcBr5uhsNpmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABob10/hsBpnnJVMAAAAAAAAAADVroryprllDXLQfrp34ZLhTBYoAAAAAqcvqAAADFayOAVsNtGezRhrpkG47x5hQgAAAAB6hXQAAABhhbDCK2G5vLd6IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABhFbCOttomDc3UAAAAAAAAAAAMKbYfLJ7/PwithN75eubdytYp8s6AAVCXhAAAAAABYOcfl197n6tNFf0NuNulS8/QPFLYgAHtFzgAAAAAACwc46RdVUjbFeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB0yOztokLY7/c8AAAAAAAAAAAAaK9dOuu6Gxume83JcBZcAAAAAAA9oucAARR+hmgzdbJOJ5WuWDztPODH0AAAAAAAqEvCADgIk3RzSeMGi9EfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/xAApEAAABgIABQQCAwAAAAAAAAAABQYHCBcECQIDChAWASBAYBUwFBhQ/9oACAEBAAEIAP8AYzs7BK8HMMzPBzsE0wcMzLPk8XDw8fDxcHG2jXbA9fmxiQUU4ZxW2jMo/wAtuWwTsfJ3ofwWZje3OwNMSr6jtIzXQHObmSeorfPsC5zzksaxi83mZGNj8/m9vJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEPJFEEKdnOYqivHy/b1TE3zt+JGtlrsZvW/0t79Ph6kDoTri1DuNULG6xGtjP3rxHivEeK8R4rxHivEeK8R4rxHivEeK8R4rxHivEeK8R4rxHivEeK8R4LkamyrM5OfgezK4cnjxsjhw4h6xouRAU6udpOfb1fstlvL11V6y2ok053ULsPyslwcyB892lns2yiVaG+PuufFXx01ZzIdNBQrjuiYoRSYWPyADskuBG7f8AxCWaA7LIxzCpNmWfgWGsBYawFhrAWGsBYawFhrAWGsBYawFhrAWGsBYawCNWSkNVIW4Gf+icMYyeZcR5AxhOdVewgocRFEsJpUOc6rZsqijlx3ehaeG2zPY6f7MC/sclOOeFuSV5dUJ0VQnRVCdFUJ0VQnRVCdFUJ0VQnRVCdFUJ0VQnQTN8TEZljGmJ+mXOvOG06SkvLpQIfp99ZSVUhOplSTk5QniotIiD7fPyfjCa6WEOn0fTU31MH9i37UrGTn+RPqeTG67I9qCQD4z8n4/exZ+zp9H0HT/b7snNyUFAubXZVG2QRkOeaYlrqIWuoha6iFrqIWuoglXBOTw+wCvL/dJuMjLTAZZZsC/21zVG9Or56eJNKUsLDI7Mi8mJtDWhotiKWpuXkvOyhJ/zxPmFIqEVCKhFQioQnm4/AnGGbfAk3GRlpgMss2Bf7Vd08TLa+XpWz/OT9fMcbIzC/OxMRiN5vPat5Hhils0TKmTa0TxIrkd8nZKSEEQpRMdshM1Q70F4jHB66uomAm/KG0zVHymcXPe3hbwt4W8LeFvC3hbwt4W8LeFvC3hbwt4J5x/zxxhlPu6qaevIZaMCWhOiYsw6krNNxcRrYz63+lvYVj/QgdCdeLi42FjY+Hh9qoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEKoUQqhRCqFEEq3xyRn2AaZfsysjl4mNkZfN9dEbv7MJkOXOvZgwsdWNi63ZU08fPs/8A/8QAOhAAAQMDAQYEAwUHBQEAAAAABAIDBQEGBwAIERITFKWU1NXlFZXTCRAgM0AWISIjJDBgFzRQVHJz/9oACAEBAAk/AP8AmDBY6NjhSDpCQOIZEBBBEZWQWYYWQttgUUVhtx8gh9xDLLKFuOLShKlUMFkY2RFHOj5AEhksE4EtlBAhgZY63GChSmHG3xyGHFsvMrQ42tSFJVX9SlK0LTVK0KpRSVJVTcpKk130UlVK1pWlaVpWld1f3ay7aU/iWdtkraq2WtjHaIMlB8L5KxDcdxSf+r+NMM5DGqTIYUyniG+ZBY1sW8A5W0LptyXHvXIIbTAhBRtr3tse7YQIYap3Zd2iwk2ldcma9SjTxOILtKQHaubrXIKQS5AzFlkfGpaEZbuAy04UEhFE/qbhgrRzxsD5fs/JmKDpt58ZjIMNf05EY3yhgM14Ft6SXC5ctOa5EizHsKIS7b4RDxUXGMycmL9mbgfI0Q2h9VvzRmUrtAvax5F3gUmcsG+I60xrns6YbdaZcUVByYiDm2uilWJCNeJCewrlzbyxbNzTSLdt5+dbvPabxXZVCG2HiyMylRFq25fkTACOrLPPzGNbjJpLQojmRrJilVq2K+E68w064GUoZZIjjjaVrFIUGQWGp8dVatOqELKGq4hVWCHmqpcV90/NfNDvr6n5r5od9fU/NfNDvr6n5r5od9fU/NfNDvr6n5r5od9fU/NfNDvr6n5r5od9fU/NfNDvr6n5r5od9fU/NfNDvr6n5r5od9fU/NfNDvr6n5r5od9fU/NfNDvr6l5QodzruYwQeW+yvgjjFo42nXVIVwrSlaeJNeFSUqpurSlfxKlboiMMnRl25IgrWHLmTbuz3esVyLQtIWMjGy35Y6w7HmadKxHocJVcGQ52FLE+IQLVES8rs5YvfcHkGcQw/RE53uoGi6L6eaUQ2dBYqFMa3VrSWYn7vZpzhDrUgiKtGIxJa2LrWaQNWTdhxFEXJdRwzXKTMXpdsisu5LumFJqqlJCekznmG1dMJ0wiGh2/viO4SnndRHcJTzuojuEp53UR3CU87qI7hKed1EdwlPO6iO4SnndRHcJTzuojuEp53UR3CU87qI7hKed1EdwlPO6iO4SnndRHcJTzuojuEp53UbyC2OZynesPd4Oa0tlz+W8U40riacWn+JFd2/fTcqlK0/A6wOYph1Ij5Q7hYzJNW1UYdIEaKCdKYbdqlbo7ZgjjzdFNoKHUqjqLZfyXtK5Mn5+78pbTOU0gXJlq77ru44iVus2OkKBjxliQ8xJmFvLt2yY+FBcYWyzKLlnx0mK/y/BmNskWpi24jbGyhtv7Rs3MwmzPA3uCkZyQtzHETaa/2wysVFNuOsGy9vNmhjFuR8gmFkLUkYm4Jd7YE217ajWnJC4MLWiBkTCeTpEIbiLIjsY3VJit2nSWdYaUII/eK5XiW60hmFkCV0qmIunHmRsZ3MRYGdsEZHA+DZPwrkMFwpgq2rtiq8NViluAHOQM4whsaVYENGIHjJ6JnoKI/TmGRt2C44ibGiJWOVVuRhlZgv20cPmTccQlaHAz4WPvsuUCPYWkmPKEaNGrQgdvUYHGQON8a2zEkrDaU18auYmPak7yuozjdeWuTu27DZm5JNdXVo62TeSzRsdLTSNUajG/tFtmzaDxVnCBHccbBmrh2ZrSCyjZuRiwW00Yduj4PFxNkjyb1VLagY88ZijLh56jvue5BbHR8p3ltO8HNPFZc/lvIcaVxNOLT/Eiu7fvpuVSlaS/b4vyWpft8X5LUv2+L8lqX7fF+S1L9vi/Jal+3xfktS/b4vyWpft8X5LUv2+L8lqX7fF+S1L9vi/JakueI/1nNa6MBrj5QBTzf8xkVt1PC62hX8K6b926u9Na0r/YKFjk5hxtOW1CzBzbzwNv3mylqZsG5jBx/wCoJFti+Iu3rgIFZ3OlMxqx21JU5RVJFjD/ANoRs0RUdibK+Jb8IGgpnJKbPDDiLfyvjQgt1oS/YO+rfTDz5b1vVcdRIHkyIcfW1JG3JmVv+z8Y2DbzHUTd433cUVa9uRrdaV5aSZaYKEDS+QqnKEFo6okx+qRxWnn1obVb8/B7HuzJi+6Nm/Yplrji5GBNzVeN2ShLOZs7xUVJ1qQxarYSZGxIl9QwKpYJ6GQWyFcdtXTDhfct9scrk8xY6m0PU5D7RCOBTrbyKb1sporibVvTVVKbq1oqhs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07Rs14gH07RMo4QLzuWgh4RbNeew6OvjS0Eyuu5Dyqp4XE7lUTWu+lKpr/AGcE2lkiQhGFj25eVFSlrZFtplanHaDwWQrQPgrwBjklLocuD+MOQBhrbL8hFGVbTTWLL+zcRbi3F27DZ4zHkTJdpQ9HW22qstWhJTbFuSItG20J6OcjZURXChTjK1ssKai46Dg4YEWMiIaHBGjIqKjQWUDhR8bHBNMCAgiDttsCiCstMDsoQ002hCUpp/l81/2IrH2Poogb9s8p3n0yngrUtQJ5X/gicnCEfCraiuZJSTn+2GLEsjFn+qd7lk7PmQoJHwizLV+LkoZhcM34aa7/APEe18iyC2PiUq+9G3IkTq4wpn9RJPqDHf8AgNi2REKaVdWTL8LCMMh7Mtpl3e02+U0EUZKS5dEx0BDCHSpylJHbHImv+xFY9x7FEE/sZiyzOpU8FatqhPK/8ETk4Qj4rcsrzJKSc/2oomrsfLLLfirM2cc8XAU4QSSSQ4zG29iLJsm+pbrz7zqxoqwbzMcU444oW2LheUpUXJfehlwgXpeWghLi2a88wcdfGlpxlddyHlVTwuJ3Komtd9KVTUKF8Od6joKF8Od6joKF8Od6joKF8Od6joKF8Od6joaMbHK6rmLHZLQ9TkBkEI4FOmvIpvWymiuJtW9NVUpurWiqf3rMBvfHF7g1HOBIpRmSh5Jmi1RVz2xKpQoqAumAKVQ2FmgqpIEITVtyj4b5QpCTr3wTe5x5GFM1jgVZjbnjWa1fXbFzoYooWAyLACqQmahVLSPJDpTPQKn4t9aAo86XmJc4SMioqMEIPkpOSPIbFBj48EVt0o040p1oYQQZp0gkh1tlltbi0prbYMvtSy4LUnjjHEm0OfG7PMaePvbkJBuvNFNzCaK7VBZaKuj2GO65Fxbi5xchIMfcR0nV9P8A1HJ5/L5BTBP5XNZ4uLk8H5ieHi4v37uGtw9p9z1cPafc9XD2n3PVw9p9z1cPafc9TPV9J1H9P8O5HM54r435vXPcPDzuP8tXFw8P7t/FT+/ZgN744vcGo5wJFKMyUPJM0WqKue2JVKFFQF0wBSqGws0FVJAhCatuUfDfKFIu8HaDyPE3TLD7Ox0nA0AjcX2SutUx1zyEURzRTcwmiuuBFzYlKxNuDtuOWylBkk8UL/j8gTElFBkjDSobQT5caQ+wtpmQFZkRTo94kNxSSWGjwiwnHW0oKFIYqtpeNTMKX3s+5HGxddG1ZY9uzpuzXcr9yKOkMS3Le0cms1cWElZetFkOftYmVKuCzZfhl5F+ZswQVyEjbhg7stO5ooGdtu57ZlgJ63rghJQZsyNmISaiyCo2WipER1ooGQAJIELGdbfHecaWlVf1MJGSez/fEYHsV/aJ29KxI8za0hgrJMyhnE2YLthChiow4PFGRzR4S6DTQJWUlLOugO1wmaBc5GvtUdmXBqzXSZu6NiPM9/S1+7HOTpFx+hhibZBelHLo2f7klXquurnceltR5jqQYNwaAt1Lix52C2cNpRE0zbDWOLrv22btx/f8868kRlvC+brfcbsjILUic4OFDRhSrbumbNJbHt+35plNTVffb3dvbNW93b2zVvd29s1b3dvbNW93b2zVvd29s1b3dvbNW93b2zVvd29s1b3dvbNW93b2zVvd29s1b3dvbNW93b2zVvd29s1DdJ1fUf1HxHn8vkCvk/ldCzxcXJ4PzE8PFxfv3cNfwyjScjbULrNwZCQw4iplv4Ks2bYJoh1NKpfEdyLfcYHDxxTalslwVo37Fkt0oS0quJLpyjdDrg1ZN2HESPbdqhEu8pExel2yCxLbtGHSqi6UkJ6TBZfcRUYTqS1tDuS8VtG5QYQPIM4hh+tGwRap1UUX081UloGdyqUG7urWksxAWg9Wrwh1qTo9GjFjsCBiMNCiCCtNjjCjDtpaYHHYaShplhlpCW2mm0pbbbSlCE0TSlKfcbC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0bC+IO9O0TGODi9VzEDvFrerzwyB0cCXQmUV3LeTVXE4ncmiq031pRNfwJfW0Kw6Q4kUUk0lTbLanFpHDDaIMLfqlNaNCiMPEkOVS0w046tKK3NMYtsC87iYTirZVsuZCLyHD4gtxtuPx3amRb0AckbesR+kCOwbd8DZHxmYkrkmLjklztozJT7dMW2fiXH0PvWLblnRLUeyQWtKUvykwaqrspcM4XRKanT08dJTR600Wae+unF/lH//xAA6EQACAQEGAwQHBQkBAAAAAAABAgMRAAQSITFRQEFxIjJhgRNSYJGhscEQQnKC8AUUIyQzQ1Bi0eL/2gAIAQIBAT8A/wAxrbTI8WzQzQpJKpDA+jklQdpWAGFnH3lZRmTmCKLaS7ugxqRJHykTMfmGqneuXKp4q6dt2hIJSZSrU+6R2lfaqkfG0dxaI4kvDLuMAofBhioR1tebpDgL4liYDM0pGx/BmVrstehPE3CIIjTNkWyUnKiDU56VPwA3tPf0SqwgO3rHuDpzb4DxNpJHlbFIxY+Og8ANAOnEyTySgKThjUALGuSgDTqRufKntgII41DXl2UsKrEgBkI3YnJa7H31yH8k/Z/jRHk5wsv5gM6dKdRaWFomANGVhVHXNXXcH5jl0oTw91QPeIlOmInrhBannS0rmSR3OrMT0HIeQoPsU47nID/ZdGU7CQ4SOlc6b04iKT0UiSeqwJG40I8xUWvEJBMsfahc4lYZha6q2xByz+dbKrOQqgsToAKn3C0tIIBBUGR2DygUOAAdlK78ztnyIrxEc0sX9NytdRqp6qajzpWxvk5BAYLXXAqqffSvuNtcz7YQwvM4RB1PJRufoOdrxccCB4qthHbU5k01YfVdtOJhheZwidSToo5k/wDOZytDCkCBEH4m5sdz9By+y+XTWaIbl0HxZfmR5jiI5GjYOhow/VDuDzFrveFvC1GTjvLt4jdTyPLQ20zOQGpte736WscZpGO83r/+fnqeJjkaNg6GjD9UO4PMWvF9eZQijAtBjoe8dvw+HPn7QfHws90xKskDYg64hGT2xTJgDo2E5HQjLI62IIJBBBGRByIOxHFQEyRtACcan0sJBoca95Qcu8uYzyIrYCWQBbzd5H5CVVpIvXKjgbHrmbTXOWIYgC6UriAIZR/uhzXx1A5kcT+z4cUhlPdjyHi5H0GfUi0kscS4pGCjlXU+AGpPS09/d6rF2F9Y989OS+VT4jif3tYIligAYgdqQjslj3io1OehNBSmRFnd5GxOxZtyfgNh4DL2o//EADQRAAIAAgYGCAcBAQAAAAAAAAECAxEAITFBUWESIkBxgZEEEGChscHR8BMjMkJScuFDgv/aAAgBAwEBPwDsoA6OyoRKWkqNYReAZ1EGzG00WICdEzRvxao8DYRhLltUapQ4qZCCM51FeNGj6Yk0NTxMxuNopCjPMLIuObAb6p8eY2npDzYILqzmxsHAeOVIfR2at9UYfcfTxyoqqgkokPHeb9pSGqTNrGssbSTbu4dsDEZiRCAIFRdvpByx93W/PWvUcYVg8DKXOdEcOJioiplNoOB998xtEUlYbEWylzIHnRFCqqi4d954mvqI0Yykf6KwP/InPwG0OumrLiO+48DSG8xoNU61EG+VhGMxh4SoSAJkgDE0T5kT4ktRQVQ2TN53Wj+g7SyI/wBSg538xXQQIYrkT+xJHL17Yu6w1meAvJ92m6kKPpGTyEzqm4ZHyPPaXcQ10jwGJwo7s7aTcBcBgOqDGsRzkp8j5HaGUMCrCYPvnSJDMM4g2HyOfVBg6Os31XD8f74bSyhgVYTB986Q4AQlidIz1ch69oVjSJWIJFTIsAdHInCYsuOVLaxWDtUTUYRPtOpE/U2E1XG3KQoSi1woirihM0Pmp3bqqJGR6jqtZImYO42HuOG09IeShBa1u4ep8DRVZzJQSfdpsHGidHUVvrHD7f73DI7T8ExGLxJgGxRbK6ZrAzAvnZRVCiSgAZe69/aj/9k="
  }
];
var BulletListTypePicker = (props) => {
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
    ListTypePicker,
    {
      ...props,
      options: bulletOptions
    }
  );
};

// ../packages/docs-ui/src/components/list-type-picker/index.ts
var ORDER_LIST_TYPE_COMPONENT = `${COMPONENT_PREFIX}_ORDER_LIST_TYPE_COMPONENT`;
var BULLET_LIST_TYPE_COMPONENT = `${COMPONENT_PREFIX}_BULLET_LIST_TYPE_COMPONENT`;

// ../packages/docs-ui/src/services/doc-auto-format.service.ts
function getParagraphsInRange(activeRange, paragraphs) {
  var _a, _b;
  const { startOffset, endOffset } = activeRange;
  const results = [];
  let start = -1;
  for (let i = 0; i < paragraphs.length; i++) {
    const paragraph = paragraphs[i];
    const prevParagraph = paragraphs[i - 1];
    const { startIndex } = paragraph;
    if (startOffset > start && startOffset <= startIndex || endOffset > start && endOffset <= startIndex) {
      results.push({
        ...paragraph,
        paragraphStart: ((_a = prevParagraph == null ? void 0 : prevParagraph.startIndex) != null ? _a : -1) + 1,
        paragraphEnd: paragraph.startIndex
      });
    } else if (startIndex >= startOffset && startIndex <= endOffset) {
      results.push({
        ...paragraph,
        paragraphStart: ((_b = prevParagraph == null ? void 0 : prevParagraph.startIndex) != null ? _b : -1) + 1,
        paragraphEnd: paragraph.startIndex
      });
    }
    start = startIndex;
  }
  return results;
}
var DocAutoFormatService = class extends Disposable {
  constructor(_univerInstanceService, _textSelectionManagerService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._textSelectionManagerService = _textSelectionManagerService;
    __publicField(this, "_matches", /* @__PURE__ */ new Map());
  }
  registerAutoFormat(match) {
    const matchList = this._matches.get(match.id);
    if (matchList) {
      matchList.push(match);
      matchList.sort((a, b) => {
        var _a, _b;
        return ((_a = b.priority) != null ? _a : 0) - ((_b = a.priority) != null ? _b : 0);
      });
    } else {
      this._matches.set(match.id, [match]);
    }
    return toDisposable(() => {
      const matchList2 = this._matches.get(match.id);
      if (matchList2) {
        const index = matchList2.findIndex((i) => i === match);
        if (index >= 0) {
          matchList2.splice(index, 1);
        }
      }
    });
  }
  onAutoFormat(id, params) {
    var _a, _b, _c, _d, _e, _f, _g;
    const autoFormats = (_a = this._matches.get(id)) != null ? _a : [];
    const unit = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const docRanges = this._textSelectionManagerService.getDocRanges();
    const selection = (_b = docRanges.find((range) => range.isActive)) != null ? _b : docRanges[0];
    if (unit && selection) {
      const doc = unit.getSelfOrHeaderFooterModel(selection.segmentId);
      const context = {
        unit: doc,
        selection,
        isBody: !selection.segmentId,
        paragraphs: getParagraphsInRange(selection, (_d = (_c = doc.getBody()) == null ? void 0 : _c.paragraphs) != null ? _d : []),
        customRanges: BuildTextUtils.customRange.getCustomRangesInterestsWithSelection(selection, (_f = (_e = doc.getBody()) == null ? void 0 : _e.customRanges) != null ? _f : []),
        commandId: id,
        commandParams: params
      };
      const matched = autoFormats.find((i) => i.match(context));
      return (_g = matched == null ? void 0 : matched.getMutations(context)) != null ? _g : [];
    }
    return [];
  }
};
DocAutoFormatService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, Inject(DocSelectionManagerService))
], DocAutoFormatService);

// ../packages/docs-ui/src/commands/commands/auto-format.command.ts
var TabCommandId = "doc.command.tab";
var TabCommand = {
  id: TabCommandId,
  type: 0 /* COMMAND */,
  async handler(accessor, params) {
    const autoFormatService = accessor.get(DocAutoFormatService);
    const mutations = autoFormatService.onAutoFormat(TabCommand.id, params);
    return (await sequenceExecuteAsync(mutations, accessor.get(ICommandService))).result;
  }
};
var AfterSpaceCommandId = "doc.command.after-space";
var AfterSpaceCommand = {
  id: AfterSpaceCommandId,
  type: 0 /* COMMAND */,
  async handler(accessor) {
    const autoFormatService = accessor.get(DocAutoFormatService);
    const mutations = autoFormatService.onAutoFormat(AfterSpaceCommand.id);
    return (await sequenceExecuteAsync(mutations, accessor.get(ICommandService))).result;
  }
};
var EnterCommand = {
  id: "doc.command.enter",
  type: 0 /* COMMAND */,
  async handler(accessor) {
    const autoFormatService = accessor.get(DocAutoFormatService);
    const mutations = autoFormatService.onAutoFormat(EnterCommand.id);
    return (await sequenceExecuteAsync(mutations, accessor.get(ICommandService))).result;
  }
};

// ../packages/docs-ui/src/shortcuts/utils.ts
function whenDocAndEditorFocused(contextService) {
  return contextService.getContextValue(FOCUSING_DOC) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && !contextService.getContextValue(FOCUSING_COMMON_DRAWINGS);
}
function whenDocAndEditorFocusedWithBreakLine(contextService) {
  return contextService.getContextValue(FOCUSING_DOC) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && !contextService.getContextValue(FOCUSING_COMMON_DRAWINGS);
}

// ../packages/docs-ui/src/shortcuts/format.shortcut.ts
var TabShortCut = {
  id: TabCommand.id,
  binding: 9 /* TAB */,
  preconditions: whenDocAndEditorFocused
};
var ShiftTabShortCut = {
  id: TabCommand.id,
  binding: 9 /* TAB */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    shift: true
  }
};

// ../packages/docs-ui/src/services/doc-menu-style.service.ts
var BODY_DEFAULT_FONTSIZE = 11;
var HEADER_FOOTER_DEFAULT_FONTSIZE = 9;
var DEFAULT_TEXT_STYLE = {
  /**
   * fontFamily
   */
  ff: "Arial",
  /**
   * fontSize
   */
  fs: BODY_DEFAULT_FONTSIZE
};
var DocMenuStyleService = class extends Disposable {
  constructor(_textSelectionManagerService, _univerInstanceService, _renderManagerService) {
    super();
    this._textSelectionManagerService = _textSelectionManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_cacheStyle", null);
    this._init();
  }
  _init() {
    this._listenDocRangeChange();
  }
  _listenDocRangeChange() {
    this.disposeWithMe(
      this._textSelectionManagerService.textSelection$.subscribe(() => {
        this._clearStyleCache();
      })
    );
  }
  getStyleCache() {
    return this._cacheStyle;
  }
  getDefaultStyle() {
    var _a;
    const docDataModel = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    if (docDataModel == null) {
      return {
        ...DEFAULT_TEXT_STYLE
      };
    }
    const unitId = docDataModel == null ? void 0 : docDataModel.getUnitId();
    const docSkeletonManagerService = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService);
    const docViewModel = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getViewModel();
    if (docViewModel == null) {
      return {
        ...DEFAULT_TEXT_STYLE
      };
    }
    const editArea = docViewModel.getEditArea();
    if (editArea === "BODY" /* BODY */) {
      return {
        ...DEFAULT_TEXT_STYLE
      };
    } else {
      return {
        ...DEFAULT_TEXT_STYLE,
        fs: HEADER_FOOTER_DEFAULT_FONTSIZE
      };
    }
  }
  setStyleCache(style) {
    this._cacheStyle = {
      ...this._cacheStyle,
      ...style
    };
  }
  _clearStyleCache() {
    this._cacheStyle = null;
  }
};
DocMenuStyleService = __decorateClass([
  __decorateParam(0, Inject(DocSelectionManagerService)),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IRenderManagerService)
], DocMenuStyleService);

// ../packages/docs-ui/src/commands/commands/inline-format.command.ts
function handleInlineFormat(preCommandId, params, commandService) {
  return commandService.executeCommand(SetInlineFormatCommand.id, {
    preCommandId,
    ...params != null ? params : {}
  });
}
var SetInlineFormatBoldCommandId = "doc.command.set-inline-format-bold";
var SetInlineFormatBoldCommand = {
  id: SetInlineFormatBoldCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatBoldCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatItalicCommandId = "doc.command.set-inline-format-italic";
var SetInlineFormatItalicCommand = {
  id: SetInlineFormatItalicCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatItalicCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatUnderlineCommandId = "doc.command.set-inline-format-underline";
var SetInlineFormatUnderlineCommand = {
  id: SetInlineFormatUnderlineCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatUnderlineCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatStrikethroughCommandId = "doc.command.set-inline-format-strikethrough";
var SetInlineFormatStrikethroughCommand = {
  id: SetInlineFormatStrikethroughCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatStrikethroughCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatSubscriptCommandId = "doc.command.set-inline-format-subscript";
var SetInlineFormatSubscriptCommand = {
  id: SetInlineFormatSubscriptCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatSubscriptCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatSuperscriptCommandId = "doc.command.set-inline-format-superscript";
var SetInlineFormatSuperscriptCommand = {
  id: SetInlineFormatSuperscriptCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatSuperscriptCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatFontSizeCommandId = "doc.command.set-inline-format-fontsize";
var SetInlineFormatFontSizeCommand = {
  id: SetInlineFormatFontSizeCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatFontSizeCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatFontFamilyCommandId = "doc.command.set-inline-format-font-family";
var SetInlineFormatFontFamilyCommand = {
  id: SetInlineFormatFontFamilyCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatFontFamilyCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatTextColorCommandId = "doc.command.set-inline-format-text-color";
var SetInlineFormatTextColorCommand = {
  id: SetInlineFormatTextColorCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatTextColorCommandId,
      params,
      commandService
    );
  }
};
var SetInlineFormatTextBackgroundColorCommandId = "doc.command.set-inline-format-text-background-color";
var SetInlineFormatTextBackgroundColorCommand = {
  id: SetInlineFormatTextBackgroundColorCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      SetInlineFormatTextBackgroundColorCommandId,
      params,
      commandService
    );
  }
};
var ResetInlineFormatTextBackgroundColorCommandId = "doc.command.reset-inline-format-text-background-color";
var ResetInlineFormatTextBackgroundColorCommand = {
  id: ResetInlineFormatTextBackgroundColorCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    return handleInlineFormat(
      ResetInlineFormatTextBackgroundColorCommandId,
      params,
      commandService
    );
  }
};
var COMMAND_ID_TO_FORMAT_KEY_MAP = {
  [SetInlineFormatBoldCommand.id]: "bl",
  [SetInlineFormatItalicCommand.id]: "it",
  [SetInlineFormatUnderlineCommand.id]: "ul",
  [SetInlineFormatStrikethroughCommand.id]: "st",
  [SetInlineFormatFontSizeCommand.id]: "fs",
  [SetInlineFormatFontFamilyCommand.id]: "ff",
  [SetInlineFormatTextColorCommand.id]: "cl",
  [SetInlineFormatTextBackgroundColorCommand.id]: "bg",
  [ResetInlineFormatTextBackgroundColorCommand.id]: "bg",
  [SetInlineFormatSubscriptCommand.id]: "va",
  [SetInlineFormatSuperscriptCommand.id]: "va"
};
var SetInlineFormatCommand = {
  id: "doc.command.set-inline-format",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (accessor, params) => {
    var _a;
    const { value, preCommandId } = params;
    const commandService = accessor.get(ICommandService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docMenuStyleService = accessor.get(DocMenuStyleService);
    const docRanges = docSelectionManagerService.getDocRanges();
    const activeRange = (_a = docRanges.find((r) => r.isActive)) != null ? _a : docRanges[0];
    if (docRanges.length === 0) {
      return false;
    }
    const { segmentId } = docRanges[0];
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    if (docDataModel == null) {
      return false;
    }
    const body = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (body == null) {
      return false;
    }
    const unitId = docDataModel.getUnitId();
    let formatValue;
    switch (preCommandId) {
      case SetInlineFormatBoldCommand.id:
      // fallthrough
      case SetInlineFormatItalicCommand.id:
      // fallthrough
      case SetInlineFormatUnderlineCommand.id:
      // fallthrough
      case SetInlineFormatStrikethroughCommand.id:
      // fallthrough
      case SetInlineFormatSubscriptCommand.id:
      // fallthrough
      case SetInlineFormatSuperscriptCommand.id: {
        const defaultStyle = docMenuStyleService.getDefaultStyle();
        const curTextStyle = getStyleInTextRange(
          body,
          activeRange,
          defaultStyle
        );
        formatValue = getReverseFormatValueInSelection(
          curTextStyle,
          preCommandId
        );
        break;
      }
      case SetInlineFormatFontSizeCommand.id:
      case SetInlineFormatFontFamilyCommand.id: {
        formatValue = value;
        break;
      }
      case SetInlineFormatTextColorCommand.id:
      case SetInlineFormatTextBackgroundColorCommand.id: {
        formatValue = {
          rgb: value
        };
        break;
      }
      case ResetInlineFormatTextBackgroundColorCommand.id: {
        formatValue = {
          rgb: null
        };
        break;
      }
      default: {
        throw new Error(`Unknown command: ${preCommandId} in handleInlineFormat`);
      }
    }
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: docRanges
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const memoryCursor = new MemoryCursor();
    memoryCursor.reset();
    for (const range of docRanges) {
      let { startOffset, endOffset, rangeType } = range;
      if (startOffset == null || endOffset == null) {
        continue;
      }
      if (rangeType === "RECT" /* RECT */) {
        startOffset = startOffset - 1;
      }
      if (startOffset === endOffset) {
        const cacheStyle = docMenuStyleService.getStyleCache();
        const key = COMMAND_ID_TO_FORMAT_KEY_MAP[preCommandId];
        docMenuStyleService.setStyleCache(
          {
            [key]: (cacheStyle == null ? void 0 : cacheStyle[key]) !== void 0 ? getReverseFormatValue(
              cacheStyle,
              key,
              preCommandId
            ) : formatValue
          }
        );
        continue;
      }
      const body2 = {
        dataStream: "",
        textRuns: [
          {
            st: 0,
            ed: endOffset - startOffset,
            ts: {
              [COMMAND_ID_TO_FORMAT_KEY_MAP[preCommandId]]: formatValue
            }
          }
        ]
      };
      const len = startOffset - memoryCursor.cursor;
      if (len !== 0) {
        textX.push({
          t: "r" /* RETAIN */,
          len
        });
      }
      textX.push({
        t: "r" /* RETAIN */,
        body: body2,
        len: endOffset - startOffset
      });
      memoryCursor.reset();
      memoryCursor.moveCursor(endOffset);
    }
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
function isTextDecoration(value) {
  return value !== null && typeof value === "object";
}
function getReverseFormatValue(ts, key, preCommandId) {
  if (/bl|it/.test(key)) {
    return (ts == null ? void 0 : ts[key]) === 1 /* TRUE */ ? 0 /* FALSE */ : 1 /* TRUE */;
  }
  if (/ul|st/.test(key)) {
    return isTextDecoration(ts == null ? void 0 : ts[key]) && (ts == null ? void 0 : ts[key]).s === 1 /* TRUE */ ? {
      s: 0 /* FALSE */
    } : {
      s: 1 /* TRUE */
    };
  }
  if (/va/.test(key)) {
    if (preCommandId === SetInlineFormatSubscriptCommand.id) {
      return (ts == null ? void 0 : ts[key]) === 2 /* SUBSCRIPT */ ? 1 /* NORMAL */ : 2 /* SUBSCRIPT */;
    } else {
      return (ts == null ? void 0 : ts[key]) === 3 /* SUPERSCRIPT */ ? 1 /* NORMAL */ : 3 /* SUPERSCRIPT */;
    }
  }
}
function getStyleInTextRange(body, textRange, defaultStyle) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const { startOffset, endOffset, collapsed } = textRange;
  if (collapsed) {
    const textRuns2 = (_a = body.textRuns) != null ? _a : [];
    let textRun = null;
    for (let i = textRuns2.length - 1; i >= 0; i--) {
      const curTextRun = textRuns2[i];
      if (curTextRun.st < startOffset && startOffset <= curTextRun.ed) {
        textRun = curTextRun;
        break;
      }
    }
    return (textRun == null ? void 0 : textRun.ts) ? { ...defaultStyle, ...textRun.ts } : defaultStyle;
  }
  const { textRuns = [] } = getBodySlice(body, startOffset, endOffset);
  const style = Tools.deepClone(defaultStyle);
  style.fs = Math.max(style.fs, ...textRuns.map((t2) => {
    var _a2, _b2;
    return (_b2 = (_a2 = t2 == null ? void 0 : t2.ts) == null ? void 0 : _a2.fs) != null ? _b2 : style.fs;
  }));
  style.ff = (_d = (_c = (_b = textRuns.find((t2) => {
    var _a2;
    return ((_a2 = t2.ts) == null ? void 0 : _a2.ff) != null;
  })) == null ? void 0 : _b.ts) == null ? void 0 : _c.ff) != null ? _d : style.ff;
  style.it = textRuns.length && textRuns.every((t2) => {
    var _a2;
    return ((_a2 = t2.ts) == null ? void 0 : _a2.it) === 1 /* TRUE */;
  }) ? 1 /* TRUE */ : 0 /* FALSE */;
  style.bl = textRuns.length && textRuns.every((t2) => {
    var _a2;
    return ((_a2 = t2.ts) == null ? void 0 : _a2.bl) === 1 /* TRUE */;
  }) ? 1 /* TRUE */ : 0 /* FALSE */;
  style.ul = textRuns.length && textRuns.every((t2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = t2.ts) == null ? void 0 : _a2.ul) == null ? void 0 : _b2.s) === 1 /* TRUE */;
  }) ? (_e = textRuns[0].ts) == null ? void 0 : _e.ul : style.ul;
  style.st = textRuns.length && textRuns.every((t2) => {
    var _a2, _b2;
    return ((_b2 = (_a2 = t2.ts) == null ? void 0 : _a2.st) == null ? void 0 : _b2.s) === 1 /* TRUE */;
  }) ? (_f = textRuns[0].ts) == null ? void 0 : _f.st : style.st;
  style.bg = (_i = (_h = (_g = textRuns.find((t2) => {
    var _a2;
    return ((_a2 = t2.ts) == null ? void 0 : _a2.bg) != null;
  })) == null ? void 0 : _g.ts) == null ? void 0 : _h.bg) != null ? _i : style.bg;
  style.cl = (_l = (_k = (_j = textRuns.find((t2) => {
    var _a2;
    return ((_a2 = t2.ts) == null ? void 0 : _a2.cl) != null;
  })) == null ? void 0 : _j.ts) == null ? void 0 : _k.cl) != null ? _l : style.cl;
  const vas = textRuns.filter((t2) => {
    var _a2;
    return ((_a2 = t2 == null ? void 0 : t2.ts) == null ? void 0 : _a2.va) != null;
  });
  if (vas.length > 0 && vas.length === textRuns.length) {
    const va = (_m = vas[0].ts) == null ? void 0 : _m.va;
    let isSame = true;
    for (let i = 1; i < vas.length; i++) {
      if (((_n = vas[i].ts) == null ? void 0 : _n.va) !== va) {
        isSame = false;
        break;
      }
    }
    if (isSame) {
      style.va = va;
    }
  }
  return style;
}
function getReverseFormatValueInSelection(textStyle, preCommandId) {
  const key = COMMAND_ID_TO_FORMAT_KEY_MAP[preCommandId];
  const reverseValue = getReverseFormatValue(textStyle, key, preCommandId);
  return reverseValue;
}

// ../packages/docs-ui/src/commands/commands/list.command.ts
var ListOperationCommand = {
  id: "doc.command.list-operation",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a, _b;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const listType = params.listType;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const docRanges = (_a = docSelectionManagerService.getDocRanges()) != null ? _a : [];
    if (docDataModel == null || docRanges.length === 0) {
      return false;
    }
    const segmentId = docRanges[0].segmentId;
    const paragraphs = (_b = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _b.paragraphs;
    if (paragraphs == null) {
      return false;
    }
    const currentParagraphs = getParagraphsInRanges(docRanges, paragraphs);
    const unitId = docDataModel.getUnitId();
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: docRanges,
        isEditing: false
      }
    };
    const memoryCursor = new MemoryCursor();
    memoryCursor.reset();
    const textX = BuildTextUtils.paragraph.bullet.switch({
      paragraphs: currentParagraphs,
      listType,
      document: docDataModel,
      segmentId
    });
    const jsonX = JSONX.getInstance();
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var ChangeListTypeCommand = {
  id: "doc.command.change-list-type",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a, _b;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const { listType } = params;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const activeRanges = docSelectionManagerService.getDocRanges();
    if (docDataModel == null || activeRanges == null || !activeRanges.length) {
      return false;
    }
    const { segmentId } = activeRanges[0];
    const selections = (_a = docSelectionManagerService.getDocRanges()) != null ? _a : [];
    const paragraphs = (_b = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _b.paragraphs;
    if (paragraphs == null) {
      return false;
    }
    const currentParagraphs = getParagraphsInRanges(selections, paragraphs);
    const unitId = docDataModel.getUnitId();
    const textX = BuildTextUtils.paragraph.bullet.set({
      paragraphs: currentParagraphs,
      listType,
      segmentId,
      document: docDataModel
    });
    if (!textX) {
      return false;
    }
    const jsonX = JSONX.getInstance();
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: selections,
        isEditing: false
      }
    };
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var ChangeListNestingLevelCommand = {
  id: "doc.command.change-list-nesting-level",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a, _b;
    if (!params) {
      return false;
    }
    const { type: type2 } = params;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const activeRange = docSelectionManagerService.getActiveTextRange();
    if (docDataModel == null || activeRange == null) {
      return false;
    }
    const { segmentId } = activeRange;
    const selections = (_a = docSelectionManagerService.getDocRanges()) != null ? _a : [];
    const paragraphs = (_b = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _b.paragraphs;
    if (paragraphs == null) {
      return false;
    }
    const currentParagraphs = getParagraphsInRange2(activeRange, paragraphs);
    const unitId = docDataModel.getUnitId();
    const jsonX = JSONX.getInstance();
    const textX = BuildTextUtils.paragraph.bullet.changeNestLevel({
      paragraphs: currentParagraphs,
      type: type2,
      segmentId,
      document: docDataModel
    });
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: selections,
        isEditing: false
      }
    };
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var BulletListCommand = {
  id: "doc.command.bullet-list",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    if (params == null ? void 0 : params.value) {
      return commandService.syncExecuteCommand(ChangeListTypeCommand.id, {
        listType: params.value
      });
    }
    return commandService.syncExecuteCommand(ListOperationCommand.id, {
      listType: "BULLET_LIST" /* BULLET_LIST */
    });
  }
};
var CheckListCommand = {
  id: "doc.command.check-list",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    if (params == null ? void 0 : params.value) {
      return commandService.syncExecuteCommand(ChangeListTypeCommand.id, {
        listType: params.value
      });
    }
    return commandService.syncExecuteCommand(ListOperationCommand.id, {
      listType: "CHECK_LIST" /* CHECK_LIST */
    });
  }
};
var ToggleCheckListCommand = {
  id: "doc.command.toggle-check-list",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a;
    if (!params) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const { index, segmentId, textRanges } = params;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    if (docDataModel == null) {
      return false;
    }
    const paragraphs = (_a = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a.paragraphs;
    if (paragraphs == null) {
      return false;
    }
    const unitId = docDataModel.getUnitId();
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: textRanges != null ? textRanges : [],
        segmentId,
        isEditing: false
      }
    };
    const textX = BuildTextUtils.paragraph.bullet.toggleChecklist({
      document: docDataModel,
      paragraphIndex: index,
      segmentId
    });
    if (!textX) {
      return false;
    }
    const jsonX = JSONX.getInstance();
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var OrderListCommand = {
  id: "doc.command.order-list",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    if (params == null ? void 0 : params.value) {
      return commandService.syncExecuteCommand(ChangeListTypeCommand.id, {
        listType: params.value
      });
    }
    return commandService.syncExecuteCommand(ListOperationCommand.id, {
      listType: "ORDER_LIST" /* ORDER_LIST */
    });
  }
};
var QuickListCommand = {
  id: "doc.command.quick-list",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler(accessor, params) {
    var _a, _b, _c, _d, _e;
    if (!params) {
      return false;
    }
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const activeRange = docSelectionManagerService.getActiveTextRange();
    if (docDataModel == null || activeRange == null) {
      return false;
    }
    const { segmentId } = activeRange;
    const { listType, paragraph } = params;
    const { paragraphStart, paragraphEnd } = paragraph;
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const { defaultTabStop = 36 } = docDataModel.getSnapshot().documentStyle;
    const sectionBreaks = (_b = (_a = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a.sectionBreaks) != null ? _b : [];
    const { startIndex, paragraphStyle = {} } = paragraph;
    const { indentFirstLine, snapToGrid, indentStart } = paragraphStyle;
    const paragraphProperties = PRESET_LIST_TYPE[listType].nestingLevel[0].paragraphProperties || {};
    const { hanging: listHanging, indentStart: listIndentStart } = paragraphProperties;
    const bulletParagraphTextStyle = paragraphProperties.textStyle;
    const { charSpace, gridType } = findNearestSectionBreak(startIndex, sectionBreaks) || { charSpace: 0, gridType: 1 /* LINES */ };
    const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
    const ID_LENGTH4 = 6;
    let listId = Tools.generateRandomId(ID_LENGTH4);
    const paragraphs = (_d = (_c = docDataModel.getBody()) == null ? void 0 : _c.paragraphs) != null ? _d : [];
    const curIndex = paragraphs.findIndex((i) => i.startIndex === paragraph.startIndex);
    const prevParagraph = paragraphs[curIndex - 1];
    const nextParagraph = paragraphs[curIndex + 1];
    if (prevParagraph && prevParagraph.bullet && prevParagraph.bullet.listType.indexOf(listType) === 0) {
      listId = prevParagraph.bullet.listId;
    } else if (nextParagraph && nextParagraph.bullet && nextParagraph.bullet.listType.indexOf(listType) === 0) {
      listId = nextParagraph.bullet.listId;
    }
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId: docDataModel.getUnitId(),
        actions: [],
        textRanges: [{
          startOffset: paragraphStart,
          endOffset: paragraphStart,
          collapsed: true
        }],
        isEditing: false
      }
    };
    textX.push({
      t: "r" /* RETAIN */,
      len: paragraphStart
    });
    textX.push({
      t: "d" /* DELETE */,
      len: paragraphEnd - paragraphStart
    });
    textX.push({
      t: "r" /* RETAIN */,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: {
              ...paragraphStyle,
              textStyle: {
                ...paragraphStyle.textStyle,
                ...bulletParagraphTextStyle
              },
              indentFirstLine: void 0,
              hanging: listHanging,
              indentStart: { v: getNumberUnitValue(listIndentStart, charSpaceApply) - getNumberUnitValue(listHanging, charSpaceApply) + getNumberUnitValue(indentFirstLine, charSpaceApply) + getNumberUnitValue(indentStart, charSpaceApply) }
            },
            bullet: {
              ...(_e = paragraph.bullet) != null ? _e : {
                nestingLevel: 0,
                textStyle: {
                  fs: 20
                }
              },
              listType,
              listId
            }
          }
        ]
      }
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
function getParagraphsInRange2(activeRange, paragraphs) {
  const { startOffset, endOffset } = activeRange;
  const results = [];
  let start = -1;
  for (const paragraph of paragraphs) {
    const { startIndex } = paragraph;
    if (startOffset > start && startOffset <= startIndex || endOffset > start && endOffset <= startIndex) {
      results.push(paragraph);
    } else if (startIndex >= startOffset && startIndex <= endOffset) {
      results.push(paragraph);
    }
    start = startIndex;
  }
  return results;
}
function getParagraphsInRanges(ranges, paragraphs) {
  const results = [];
  for (const range of ranges) {
    const ps = getParagraphsInRange2(range, paragraphs);
    results.push(...ps);
  }
  return results;
}
function findNearestSectionBreak(currentIndex, sectionBreaks) {
  const sortedSectionBreaks = sectionBreaks.sort(sortRulesFactory("startIndex"));
  for (let i = 0; i < sortedSectionBreaks.length; i++) {
    const sectionBreak = sectionBreaks[i];
    if (sectionBreak.startIndex >= currentIndex) {
      return sectionBreak;
    }
  }
}

// ../packages/docs-ui/src/commands/commands/paragraph-align.command.ts
var AlignOperationCommand = {
  id: "doc.command.align-action",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: (accessor, params) => {
    var _a;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const { alignType } = params;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (docDataModel == null) {
      return false;
    }
    const allRanges = docSelectionManagerService.getDocRanges();
    if (allRanges.length === 0) {
      return false;
    }
    const segmentId = allRanges[0].segmentId;
    const paragraphs = (_a = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a.paragraphs;
    if (paragraphs == null) {
      return false;
    }
    const currentParagraphs = getParagraphsInRanges(allRanges, paragraphs);
    const unitId = docDataModel.getUnitId();
    const isAlreadyAligned = currentParagraphs.every((paragraph) => {
      var _a2;
      return ((_a2 = paragraph.paragraphStyle) == null ? void 0 : _a2.horizontalAlign) === alignType;
    });
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: allRanges
      }
    };
    const memoryCursor = new MemoryCursor();
    memoryCursor.reset();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    for (const paragraph of currentParagraphs) {
      const { startIndex } = paragraph;
      textX.push({
        t: "r" /* RETAIN */,
        len: startIndex - memoryCursor.cursor
      });
      const paragraphStyle = {
        ...paragraph.paragraphStyle,
        horizontalAlign: isAlreadyAligned ? 0 /* UNSPECIFIED */ : alignType
      };
      textX.push({
        t: "r" /* RETAIN */,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              ...paragraph,
              paragraphStyle,
              startIndex: 0
            }
          ]
        },
        coverType: 1 /* REPLACE */
      });
      memoryCursor.moveCursorTo(startIndex + 1);
    }
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var AlignLeftCommand = {
  id: "doc.command.align-left",
  type: 0 /* COMMAND */,
  handler: (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.syncExecuteCommand(AlignOperationCommand.id, {
      alignType: 1 /* LEFT */
    });
  }
};
var AlignCenterCommand = {
  id: "doc.command.align-center",
  type: 0 /* COMMAND */,
  handler: (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.syncExecuteCommand(AlignOperationCommand.id, {
      alignType: 2 /* CENTER */
    });
  }
};
var AlignRightCommand = {
  id: "doc.command.align-right",
  type: 0 /* COMMAND */,
  handler: (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.syncExecuteCommand(AlignOperationCommand.id, {
      alignType: 3 /* RIGHT */
    });
  }
};
var AlignJustifyCommand = {
  id: "doc.command.align-justify",
  type: 0 /* COMMAND */,
  handler: (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.syncExecuteCommand(AlignOperationCommand.id, {
      alignType: 4 /* JUSTIFIED */
    });
  }
};

// ../packages/docs-ui/src/shortcuts/toolbar.shortcut.ts
var BoldShortCut = {
  id: SetInlineFormatBoldCommand.id,
  binding: 66 /* B */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenDocAndEditorFocused
};
var ItalicShortCut = {
  id: SetInlineFormatItalicCommand.id,
  binding: 73 /* I */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenDocAndEditorFocused
};
var UnderlineShortCut = {
  id: SetInlineFormatUnderlineCommand.id,
  binding: 85 /* U */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenDocAndEditorFocused
};
var StrikeThroughShortCut = {
  id: SetInlineFormatStrikethroughCommand.id,
  binding: 88 /* X */ | 1024 /* SHIFT */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenDocAndEditorFocused
};
var SubscriptShortCut = {
  id: SetInlineFormatSubscriptCommand.id,
  binding: 188 /* COMMA */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenDocAndEditorFocused
};
var SuperscriptShortCut = {
  id: SetInlineFormatSuperscriptCommand.id,
  binding: 190 /* PERIOD */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenDocAndEditorFocused
};
var AlignLeftShortCut = {
  id: AlignLeftCommand.id,
  binding: 76 /* L */ | 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused
};
var AlignRightShortCut = {
  id: AlignRightCommand.id,
  binding: 82 /* R */ | 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused
};
var AlignCenterShortCut = {
  id: AlignCenterCommand.id,
  binding: 69 /* E */ | 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused
};
var AlignJustifyShortCut = {
  id: AlignJustifyCommand.id,
  binding: 74 /* J */ | 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused
};
var OrderListShortCut = {
  id: OrderListCommand.id,
  binding: 55 /* Digit7 */ | 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused
};
var BulletListShortCut = {
  id: BulletListCommand.id,
  binding: 56 /* Digit8 */ | 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused
};

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/docs-ui/src/views/count-bar/index.module.less
var index_module_default11 = {
  "docCountBar": "univer-doc-count-bar"
};

// ../packages/docs-ui/src/views/count-bar/ZoomSlider.tsx
var import_react40 = __toESM(require_react());

// ../packages/docs-ui/src/commands/operations/set-doc-zoom-ratio.operation.ts
var SetDocZoomRatioUndoMutationFactory = (accessor, params) => {
  const documentModel = accessor.get(IUniverInstanceService).getUniverDocInstance(params.unitId);
  const old = (documentModel == null ? void 0 : documentModel.zoomRatio) || 1;
  return {
    ...Tools.deepClone(params),
    zoomRatio: old
  };
};
var SetDocZoomRatioOperation = {
  id: "doc.operation.set-zoom-ratio",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    const documentModel = accessor.get(IUniverInstanceService).getUniverDocInstance(params.unitId);
    if (!documentModel) {
      return false;
    }
    const documentData = documentModel.getSnapshot();
    if (documentData.settings == null) {
      documentData.settings = {
        zoomRatio: params.zoomRatio
      };
    } else {
      documentData.settings.zoomRatio = params.zoomRatio;
    }
    return true;
  }
};

// ../packages/docs-ui/src/views/count-bar/ZoomSlider.tsx
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var ZOOM_MAP = [50, 80, 100, 130, 150, 170, 200, 400];
var DOC_ZOOM_RANGE = [10, 400];
function ZoomSlider() {
  const commandService = useDependency(ICommandService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const currentDoc$ = (0, import_react40.useMemo)(() => univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_DOC), []);
  const documentDataModel = useObservable(currentDoc$);
  const getCurrentZoom = (0, import_react40.useCallback)(() => {
    var _a, _b;
    if (!documentDataModel) return 100;
    const currentZoom = ((_b = (_a = documentDataModel.getSettings()) == null ? void 0 : _a.zoomRatio) != null ? _b : 1) * 100;
    return Math.round(currentZoom);
  }, [documentDataModel]);
  const [zoom, setZoom] = (0, import_react40.useState)(() => getCurrentZoom());
  (0, import_react40.useEffect)(() => {
    setZoom(getCurrentZoom());
    const disposable = commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetDocZoomRatioOperation.id) {
        const currentZoom = getCurrentZoom();
        setZoom(currentZoom);
      }
    });
    return disposable.dispose;
  }, [commandService, getCurrentZoom]);
  function handleChange(value) {
    setZoom(value);
    if (documentDataModel == null) {
      return;
    }
    const zoomRatio = value / 100;
    commandService.executeCommand(SetDocZoomRatioOperation.id, {
      unitId: documentDataModel.getUnitId(),
      zoomRatio
    });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
    Slider,
    {
      min: DOC_ZOOM_RANGE[0],
      value: zoom,
      shortcuts: ZOOM_MAP,
      onChange: handleChange
    }
  );
}

// ../packages/docs-ui/src/views/count-bar/CountBar.tsx
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
function CountBar(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("section", { className: index_module_default11.docCountBar, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(ZoomSlider, {}) });
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/docs-ui/src/views/doc-footer/index.module.less
var index_module_default12 = {
  "docFooterContainer": "univer-doc-footer-container"
};

// ../packages/docs-ui/src/views/doc-footer/DocFooter.tsx
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var DocFooter = () => {
  const univerInstanceService = useDependency(IUniverInstanceService);
  const workbook = useObservable(() => univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET), void 0, void 0, []);
  return workbook ? null : /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)("div", { className: index_module_default12.docFooterContainer, children: [
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)("div", {}),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(CountBar, {})
  ] });
};

// ../packages/docs-ui/src/basics/const/default-univer-doc-config.ts
var DefaultToolbarConfig = {
  undo: true,
  redo: true,
  // Undo redo
  font: true,
  // 'font'
  fontSize: true,
  // 'Font size'
  bold: true,
  // 'Bold (Ctrl+B)'
  italic: true,
  // 'Italic (Ctrl+I)'
  strikethrough: true,
  // 'Strikethrough (Alt+Shift+5)'
  underline: true,
  // 'Underline (Alt+Shift+6)'
  textColor: true,
  // 'Text color'
  fillColor: true,
  // 'Cell color'
  horizontalAlignMode: true,
  // 'Horizontal alignment'
  verticalAlignMode: true,
  // 'Vertical alignment'
  textWrapMode: true,
  // 'Wrap mode'
  textRotateMode: true
  // 'Text Rotation Mode'
};
var DefaultDocContainerConfig = {
  outerLeft: false,
  outerRight: false,
  header: true,
  footer: true,
  innerLeft: false,
  innerRight: false,
  frozenHeaderLT: false,
  frozenHeaderRT: false,
  frozenHeaderLM: false,
  frozenContent: false,
  infoBar: true,
  toolbar: true
};

// ../packages/docs-ui/src/basics/const/plugin-name.ts
var DOC_UI_PLUGIN_NAME = "DOC_UI_PLUGIN";

// ../packages/docs-ui/src/controllers/config.schema.ts
var DOCS_UI_PLUGIN_CONFIG_KEY = "docs-ui.config";
var configSymbol5 = Symbol(DOCS_UI_PLUGIN_CONFIG_KEY);
var defaultPluginConfig5 = {
  layout: {
    docContainerConfig: DefaultDocContainerConfig,
    toolbarConfig: DefaultToolbarConfig
  }
};

// ../packages/docs-ui/src/basics/paragraph.ts
function getTextRunAtPosition(body, position, defaultStyle, cacheStyle, isCellEditor) {
  const { textRuns = [], dataStream } = body;
  const isFormula = isCellEditor && dataStream.startsWith("=");
  const retTextRun = {
    st: 0,
    ed: 0,
    ts: isCellEditor ? {} : defaultStyle
  };
  if (isFormula) {
    return retTextRun;
  }
  for (let i = textRuns.length - 1; i >= 0; i--) {
    const textRun = textRuns[i];
    const { st, ed } = textRun;
    if (position > st && position <= ed) {
      retTextRun.st = st;
      retTextRun.ed = ed;
      retTextRun.ts = {
        ...retTextRun.ts,
        ...textRun.ts
      };
    }
  }
  if (position === 0) {
    const textRun = textRuns == null ? void 0 : textRuns[0];
    if (textRun && textRun.st === 0) {
      retTextRun.ts = {
        ...retTextRun.ts,
        ...textRun.ts
      };
    }
  }
  if (cacheStyle) {
    retTextRun.ts = {
      ...retTextRun.ts,
      ...cacheStyle
    };
  }
  return retTextRun;
}
function getCustomRangeAtPosition(customRanges, position, extendRange) {
  if (extendRange) {
    const range2 = customRanges.find((customRange) => position >= customRange.startIndex && position <= customRange.endIndex + 1);
    return (range2 == null ? void 0 : range2.wholeEntity) ? null : range2;
  }
  const range = customRanges.find((customRange) => position > customRange.startIndex && position <= customRange.endIndex);
  return (range == null ? void 0 : range.wholeEntity) ? null : range;
}
function getCustomDecorationAtPosition(customDecorations, position) {
  return customDecorations.filter((customDecoration) => position > customDecoration.startIndex && position <= customDecoration.endIndex);
}

// ../packages/docs-ui/src/commands/commands/table/table.ts
function genEmptyTable(rowCount, colCount) {
  let dataStream = "" /* TABLE_START */;
  const paragraphs = [];
  const sectionBreaks = [];
  for (let i = 0; i < rowCount; i++) {
    dataStream += "\x1B" /* TABLE_ROW_START */;
    for (let j = 0; j < colCount; j++) {
      dataStream += `${"" /* TABLE_CELL_START */}\r
${"" /* TABLE_CELL_END */}`;
      paragraphs.push({
        startIndex: dataStream.length - 3,
        paragraphStyle: {
          spaceAbove: { v: 3 },
          lineSpacing: 2,
          spaceBelow: { v: 0 }
        }
      });
      sectionBreaks.push({
        startIndex: dataStream.length - 2
      });
    }
    dataStream += "" /* TABLE_ROW_END */;
  }
  dataStream += "" /* TABLE_END */;
  return {
    dataStream,
    paragraphs,
    sectionBreaks
  };
}
function getEmptyTableCell() {
  const tableCell = {
    margin: {
      start: {
        v: 10
      },
      end: {
        v: 10
      },
      top: {
        v: 5
      },
      bottom: {
        v: 5
      }
    }
  };
  return tableCell;
}
function getEmptyTableRow(col) {
  const tableCell = getEmptyTableCell();
  const tableRow = {
    tableCells: [...new Array(col).fill(null).map(() => Tools.deepClone(tableCell))],
    trHeight: {
      val: { v: 30 },
      hRule: 0 /* AUTO */
    }
  };
  return tableRow;
}
function getTableColumn(width) {
  const tableColumn = {
    size: {
      type: 1 /* SPECIFIED */,
      width: {
        v: width
      }
    }
  };
  return tableColumn;
}
function genTableSource(rowCount, colCount, pageContentWidth) {
  const tableColumn = getTableColumn(pageContentWidth / colCount);
  const tableRow = getEmptyTableRow(colCount);
  const tableRows = [...new Array(rowCount).fill(null).map(() => Tools.deepClone(tableRow))];
  const tableColumns = [...new Array(colCount).fill(null).map(() => Tools.deepClone(tableColumn))];
  const tableId = generateRandomId(6);
  const table2 = {
    tableRows,
    tableColumns,
    tableId,
    align: 0 /* START */,
    indent: {
      v: 0
    },
    textWrap: 0 /* NONE */,
    position: {
      positionH: {
        relativeFrom: 0 /* PAGE */,
        posOffset: 0
      },
      positionV: {
        relativeFrom: 0 /* PAGE */,
        posOffset: 0
      }
    },
    dist: {
      distB: 0,
      distL: 0,
      distR: 0,
      distT: 0
    },
    cellMargin: {
      start: {
        v: 10
      },
      end: {
        v: 10
      },
      top: {
        v: 5
      },
      bottom: {
        v: 5
      }
    },
    size: {
      type: 0 /* UNSPECIFIED */,
      width: {
        v: pageContentWidth
      }
    }
  };
  return table2;
}
function getRangeInfoFromRanges(textRange, rectRanges) {
  if (!textRange && !rectRanges) {
    return null;
  }
  if (rectRanges && rectRanges.length > 0) {
    let startOffset = Number.POSITIVE_INFINITY;
    let endOffset = Number.NEGATIVE_INFINITY;
    const segmentId = "";
    for (const rectRange of rectRanges) {
      const { startOffset: st, endOffset: ed, segmentId: sid } = rectRange;
      if (st == null || ed == null || sid == null) {
        continue;
      }
      startOffset = Math.min(startOffset, st);
      endOffset = Math.max(endOffset, ed);
    }
    if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {
      return {
        startOffset,
        endOffset,
        segmentId
      };
    }
  } else if (textRange) {
    const { startOffset, endOffset, segmentId } = textRange;
    if (startOffset == null || endOffset == null || segmentId == null) {
      return null;
    }
    return {
      startOffset,
      endOffset,
      segmentId
    };
  }
}
function getInsertRowBody(col) {
  let dataStream = "\x1B" /* TABLE_ROW_START */;
  const paragraphs = [];
  const sectionBreaks = [];
  for (let i = 0; i < col; i++) {
    dataStream += `${"" /* TABLE_CELL_START */}\r
${"" /* TABLE_CELL_END */}`;
    paragraphs.push({
      startIndex: dataStream.length - 3,
      paragraphStyle: {
        spaceAbove: { v: 3 },
        lineSpacing: 2,
        spaceBelow: { v: 0 }
      }
    });
    sectionBreaks.push({
      startIndex: dataStream.length - 2
    });
  }
  dataStream += "" /* TABLE_ROW_END */;
  return {
    dataStream,
    paragraphs,
    sectionBreaks
  };
}
function getInsertColumnBody() {
  const dataStream = `${"" /* TABLE_CELL_START */}\r
${"" /* TABLE_CELL_END */}`;
  const paragraphs = [];
  const sectionBreaks = [];
  paragraphs.push({
    startIndex: 1,
    paragraphStyle: {
      spaceAbove: { v: 3 },
      lineSpacing: 2,
      spaceBelow: { v: 0 }
    }
  });
  sectionBreaks.push({
    startIndex: 2
  });
  return {
    dataStream,
    paragraphs,
    sectionBreaks
  };
}
function getInsertRowActionsParams(rangeInfo, position, viewModel) {
  var _a, _b, _c;
  const { startOffset, endOffset, segmentId } = rangeInfo;
  const vm = viewModel.getSelfOrHeaderFooterViewModel(segmentId);
  const index = position === 0 /* ABOVE */ ? startOffset : endOffset;
  let tableRow = null;
  const tableId = (_c = (_b = (_a = viewModel.getBody()) == null ? void 0 : _a.tables) == null ? void 0 : _b.find((t2) => index >= t2.startIndex && index <= t2.endIndex)) == null ? void 0 : _c.tableId;
  let rowIndex = 0;
  for (const section of vm.getChildren()) {
    for (const paragraph of section.children) {
      const { children } = paragraph;
      const table2 = children[0];
      if (table2) {
        for (const row of table2.children) {
          if (row.startIndex <= index && index <= row.endIndex) {
            rowIndex = table2.children.indexOf(row);
            tableRow = row;
            break;
          }
        }
      }
      if (tableRow) {
        break;
      }
    }
    if (tableRow) {
      break;
    }
  }
  if (tableRow == null || tableId == null) {
    return null;
  }
  return {
    offset: position === 0 /* ABOVE */ ? tableRow.startIndex : tableRow.endIndex + 1,
    colCount: tableRow.children.length,
    tableId,
    insertRowIndex: position === 0 /* ABOVE */ ? rowIndex : rowIndex + 1
  };
}
function getInsertColumnActionsParams(rangeInfo, position, viewModel) {
  var _a, _b, _c;
  const { startOffset, endOffset, segmentId } = rangeInfo;
  const vm = viewModel.getSelfOrHeaderFooterViewModel(segmentId);
  const index = position === 0 /* LEFT */ ? startOffset : endOffset;
  const tableId = (_c = (_b = (_a = viewModel.getBody()) == null ? void 0 : _a.tables) == null ? void 0 : _b.find((t2) => index >= t2.startIndex && index <= t2.endIndex)) == null ? void 0 : _c.tableId;
  const offsets = [];
  let table2 = null;
  let columnIndex = -1;
  for (const section of vm.getChildren()) {
    for (const paragraph of section.children) {
      const { children } = paragraph;
      const tableNode = children[0];
      if (tableNode) {
        if (index < tableNode.startIndex || index > tableNode.endIndex) {
          continue;
        }
        table2 = tableNode;
        for (const row of tableNode.children) {
          for (const cell of row.children) {
            const cellIndex = row.children.indexOf(cell);
            if (index >= cell.startIndex && index <= cell.endIndex) {
              columnIndex = cellIndex;
              break;
            }
          }
          if (columnIndex !== -1) {
            break;
          }
        }
      }
      if (table2) {
        break;
      }
    }
    if (table2) {
      break;
    }
  }
  if (table2 == null || tableId == null || columnIndex === -1) {
    return null;
  }
  let cursor = 0;
  for (const row of table2.children) {
    const cell = row.children[columnIndex];
    const insertIndex = position === 0 /* LEFT */ ? cell.startIndex : cell.endIndex + 1;
    offsets.push(insertIndex - cursor);
    cursor = insertIndex;
  }
  return {
    offsets,
    tableId,
    columnIndex,
    rowCount: table2.children.length
  };
}
function getColumnWidths(pageWidth, tableColumns, insertColumnIndex) {
  const widths = [];
  let newColWidth = tableColumns[insertColumnIndex].size.width.v;
  let totalWidth = 0;
  for (let i = 0; i < tableColumns.length; i++) {
    totalWidth += tableColumns[i].size.width.v;
  }
  totalWidth += newColWidth;
  for (let i = 0; i < tableColumns.length; i++) {
    widths.push(tableColumns[i].size.width.v / totalWidth * pageWidth);
  }
  newColWidth = newColWidth / totalWidth * pageWidth;
  return {
    widths,
    newColWidth
  };
}
function getDeleteRowsActionsParams(rangeInfo, viewModel) {
  var _a, _b, _c;
  const { startOffset, endOffset, segmentId } = rangeInfo;
  const vm = viewModel.getSelfOrHeaderFooterViewModel(segmentId);
  const tableId = (_c = (_b = (_a = viewModel.getBody()) == null ? void 0 : _a.tables) == null ? void 0 : _b.find((t2) => startOffset >= t2.startIndex && endOffset <= t2.endIndex)) == null ? void 0 : _c.tableId;
  const rowIndexes = [];
  let offset = -1;
  let len = 0;
  let cursor = -1;
  let selectWholeTable = false;
  for (const section of vm.getChildren()) {
    for (const paragraph of section.children) {
      const { children } = paragraph;
      const table2 = children[0];
      if (table2) {
        if (startOffset < table2.startIndex || endOffset > table2.endIndex) {
          continue;
        }
        cursor = table2.startIndex + 3;
        for (const row of table2.children) {
          const rowIndex = table2.children.indexOf(row);
          const { startIndex, endIndex } = row;
          if (startOffset >= startIndex && startOffset <= endIndex) {
            offset = startIndex;
            rowIndexes.push(rowIndex);
            len += endIndex - startIndex + 1;
          } else if (startIndex > startOffset && endIndex < endOffset) {
            rowIndexes.push(rowIndex);
            len += endIndex - startIndex + 1;
          } else if (endOffset >= startIndex && endOffset <= endIndex) {
            rowIndexes.push(rowIndex);
            len += endIndex - startIndex + 1;
          }
          if (rowIndexes.length === table2.children.length) {
            selectWholeTable = true;
          }
        }
      }
      if (rowIndexes.length) {
        break;
      }
    }
    if (rowIndexes.length) {
      break;
    }
  }
  if (tableId == null || rowIndexes.length === 0) {
    return null;
  }
  return {
    tableId,
    rowIndexes,
    offset,
    len,
    cursor,
    selectWholeTable
  };
}
function getDeleteColumnsActionParams(rangeInfo, viewModel) {
  var _a, _b, _c;
  const { startOffset, endOffset, segmentId } = rangeInfo;
  const vm = viewModel.getSelfOrHeaderFooterViewModel(segmentId);
  const tableId = (_c = (_b = (_a = viewModel.getBody()) == null ? void 0 : _a.tables) == null ? void 0 : _b.find((t2) => startOffset >= t2.startIndex && endOffset <= t2.endIndex)) == null ? void 0 : _c.tableId;
  const offsets = [];
  let table2 = null;
  const columnIndexes = [];
  let cursor = -1;
  let startColumnIndex = -1;
  let endColumnIndex = -1;
  for (const section of vm.getChildren()) {
    for (const paragraph of section.children) {
      const { children } = paragraph;
      const tableNode = children[0];
      if (tableNode) {
        if (startOffset < tableNode.startIndex || endOffset > tableNode.endIndex) {
          continue;
        }
        table2 = tableNode;
        for (const row of tableNode.children) {
          for (const cell of row.children) {
            const cellIndex = row.children.indexOf(cell);
            if (startOffset >= cell.startIndex && startOffset <= cell.endIndex) {
              startColumnIndex = cellIndex;
            }
            if (endOffset >= cell.startIndex && endOffset <= cell.endIndex) {
              endColumnIndex = cellIndex;
            }
          }
        }
      }
      if (table2) {
        break;
      }
    }
    if (table2) {
      break;
    }
  }
  if (table2 == null || tableId == null) {
    return null;
  }
  for (let i = startColumnIndex; i <= endColumnIndex; i++) {
    columnIndexes.push(i);
  }
  let delta = 0;
  for (const row of table2.children) {
    const startCell = row.children[startColumnIndex];
    const endCell = row.children[endColumnIndex];
    offsets.push({
      retain: startCell.startIndex - delta,
      delete: endCell.endIndex - startCell.startIndex + 1
    });
    delta = endCell.endIndex + 1;
  }
  cursor = table2.startIndex + 3;
  return {
    offsets,
    tableId,
    columnIndexes,
    cursor,
    selectWholeTable: columnIndexes.length === table2.children[0].children.length,
    rowCount: table2.children.length
  };
}
function getDeleteTableActionParams(rangeInfo, viewModel) {
  var _a, _b, _c;
  const { startOffset, endOffset, segmentId } = rangeInfo;
  const vm = viewModel.getSelfOrHeaderFooterViewModel(segmentId);
  const tableId = (_c = (_b = (_a = viewModel.getBody()) == null ? void 0 : _a.tables) == null ? void 0 : _b.find((t2) => startOffset >= t2.startIndex && endOffset <= t2.endIndex)) == null ? void 0 : _c.tableId;
  let offset = -1;
  let len = 0;
  let cursor = -1;
  for (const section of vm.getChildren()) {
    for (const paragraph of section.children) {
      const { children } = paragraph;
      const table2 = children[0];
      if (table2) {
        if (startOffset < table2.startIndex || endOffset > table2.endIndex) {
          continue;
        }
        offset = table2.startIndex;
        len = table2.endIndex - table2.startIndex + 1;
        cursor = table2.startIndex;
      }
      if (table2) {
        break;
      }
    }
    if (len > 0) {
      break;
    }
  }
  if (tableId == null) {
    return null;
  }
  return {
    tableId,
    offset,
    len,
    cursor
  };
}
function getDeleteRowContentActionParams(rangeInfo, viewModel) {
  var _a, _b, _c;
  const { startOffset, endOffset, segmentId } = rangeInfo;
  const vm = viewModel.getSelfOrHeaderFooterViewModel(segmentId);
  const tableId = (_c = (_b = (_a = viewModel.getBody()) == null ? void 0 : _a.tables) == null ? void 0 : _b.find((t2) => startOffset >= t2.startIndex && endOffset <= t2.endIndex)) == null ? void 0 : _c.tableId;
  const offsets = [];
  let table2 = null;
  let cursor = -1;
  let rowIndex = -1;
  let startColumnIndex = -1;
  let endColumnIndex = -1;
  for (const section of vm.getChildren()) {
    for (const paragraph of section.children) {
      const { children } = paragraph;
      const tableNode = children[0];
      if (tableNode) {
        if (startOffset < tableNode.startIndex || endOffset > tableNode.endIndex) {
          continue;
        }
        table2 = tableNode;
        for (const row2 of tableNode.children) {
          const rIndex = tableNode.children.indexOf(row2);
          for (const cell of row2.children) {
            const cellIndex = row2.children.indexOf(cell);
            if (startOffset >= cell.startIndex && startOffset <= cell.endIndex) {
              rowIndex = rIndex;
              startColumnIndex = cellIndex;
            }
            if (endOffset >= cell.startIndex && endOffset <= cell.endIndex) {
              endColumnIndex = cellIndex;
            }
          }
        }
      }
      if (table2) {
        break;
      }
    }
    if (table2) {
      break;
    }
  }
  if (table2 == null || tableId == null || rowIndex === -1) {
    return null;
  }
  const row = table2.children[rowIndex];
  for (let i = startColumnIndex; i <= endColumnIndex; i++) {
    const cell = row.children[i];
    offsets.push({
      retain: cell.startIndex + 1,
      delete: cell.endIndex - cell.startIndex - 3
    });
  }
  cursor = table2.startIndex + 3;
  return {
    offsets,
    tableId,
    cursor,
    rowCount: table2.children.length
  };
}
function getCellOffsets(viewModel, range, position) {
  const { startOffset } = range;
  let targetTable = null;
  for (const section of viewModel.getChildren()) {
    for (const paragraph of section.children) {
      const table2 = paragraph.children[0];
      if (table2) {
        if (startOffset > table2.startIndex && startOffset < table2.endIndex) {
          targetTable = table2;
          break;
        }
      }
    }
    if (targetTable) {
      break;
    }
  }
  if (targetTable == null) {
    return null;
  }
  let cellIndex = -1;
  let rowIndex = -1;
  let targetRow = null;
  for (const row of targetTable.children) {
    for (const cell of row.children) {
      if (startOffset > cell.startIndex && startOffset < cell.endIndex) {
        cellIndex = row.children.indexOf(cell);
        rowIndex = targetTable.children.indexOf(row);
        targetRow = row;
        break;
      }
    }
    if (cellIndex > -1) {
      break;
    }
  }
  if (cellIndex === -1 || rowIndex === -1 || targetRow == null) {
    return null;
  }
  let newCell = null;
  if (position === 0 /* NEXT */) {
    newCell = targetRow.children[cellIndex + 1];
    if (!newCell) {
      const nextRow = targetTable.children[rowIndex + 1];
      if (nextRow) {
        newCell = nextRow.children[0];
      }
    }
  } else {
    newCell = targetRow.children[cellIndex - 1];
    if (!newCell) {
      const prevRow = targetTable.children[rowIndex - 1];
      if (prevRow) {
        newCell = prevRow.children[prevRow.children.length - 1];
      }
    }
  }
  if (newCell) {
    const { startIndex, endIndex } = newCell;
    return {
      startOffset: startIndex + 1,
      endOffset: endIndex - 2
    };
  }
}

// ../packages/docs-ui/src/commands/commands/clipboard.inner.command.ts
function getCustomBlockIdsInSelections(body, selections) {
  const customBlockIds = [];
  const { customBlocks = [] } = body;
  for (const selection of selections) {
    const { startOffset, endOffset } = selection;
    if (startOffset == null || endOffset == null) {
      continue;
    }
    for (const customBlock of customBlocks) {
      const { startIndex } = customBlock;
      if (startIndex >= startOffset && startIndex < endOffset) {
        customBlockIds.push(customBlock.blockId);
      }
    }
  }
  return customBlockIds;
}
function hasRangeInTable(ranges) {
  return ranges.some((range) => {
    const { startNodePosition } = range;
    return startNodePosition ? (startNodePosition == null ? void 0 : startNodePosition.path.indexOf("cells")) > -1 : false;
  });
}
var UNITS = SHEET_EDITOR_UNITS;
var InnerPasteCommand = {
  id: "doc.command.inner-paste",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (accessor, params) => {
    var _a, _b, _c, _d, _e, _f;
    const { segmentId, textRanges, doc } = params;
    const commandService = accessor.get(ICommandService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selections = docSelectionManagerService.getTextRanges();
    const rectRanges = docSelectionManagerService.getRectRanges();
    const { body, tableSource, drawings } = doc;
    if (!Array.isArray(selections) || selections.length === 0 || body == null) {
      return false;
    }
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    const originBody = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || originBody == null) {
      return false;
    }
    const unitId = docDataModel.getUnitId();
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges,
        segmentId
      }
    };
    const memoryCursor = new MemoryCursor();
    memoryCursor.reset();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const rawActions = [];
    const hasTable = !!((_a = body.tables) == null ? void 0 : _a.length);
    const hasCustomBlock = !!((_b = body.customBlocks) == null ? void 0 : _b.length);
    if (hasTable && segmentId) {
      return false;
    }
    if (hasTable && hasRangeInTable(selections)) {
      return false;
    }
    if (selections.length && (rectRanges == null ? void 0 : rectRanges.length)) {
      return false;
    }
    for (let i = 0; i < selections.length; i++) {
      const selection = selections[i];
      const { startOffset, endOffset, collapsed } = selection;
      const len = startOffset - memoryCursor.cursor;
      const cloneBody = Tools.deepClone(body);
      if (hasTable) {
        for (const t2 of cloneBody.tables) {
          const { tableId: oldTableId } = t2;
          const tableId = Tools.generateRandomId(6);
          t2.tableId = tableId;
          const table2 = Tools.deepClone(tableSource[oldTableId]);
          table2.tableId = tableId;
          const action = jsonX.insertOp(["tableSource", tableId], table2);
          rawActions.push(action);
        }
      }
      if (hasCustomBlock && drawings) {
        const drawingLen = (_d = (_c = docDataModel.getSnapshot().drawingsOrder) == null ? void 0 : _c.length) != null ? _d : 0;
        for (const block of cloneBody.customBlocks) {
          const { blockId } = block;
          const drawingId = Tools.generateRandomId(6);
          block.blockId = drawingId;
          const drawing = Tools.deepClone(drawings[blockId]);
          drawing.drawingId = drawingId;
          const action = jsonX.insertOp(["drawings", drawingId], drawing);
          const orderAction = jsonX.insertOp(["drawingsOrder", drawingLen], drawingId);
          rawActions.push(action);
          rawActions.push(orderAction);
        }
      }
      const customRange = getCustomRangeAtPosition((_e = originBody.customRanges) != null ? _e : [], endOffset, UNITS.includes(unitId));
      const customDecorations = getCustomDecorationAtPosition((_f = originBody.customDecorations) != null ? _f : [], endOffset);
      if (customRange) {
        cloneBody.customRanges = [{
          ...customRange,
          startIndex: 0,
          endIndex: body.dataStream.length - 1
        }];
      }
      if (customDecorations.length) {
        cloneBody.customDecorations = customDecorations.map((customDecoration) => ({
          ...customDecoration,
          startIndex: 0,
          endIndex: body.dataStream.length - 1
        }));
      }
      if (collapsed) {
        textX.push({
          t: "r" /* RETAIN */,
          len
        });
        textX.push({
          t: "i" /* INSERT */,
          body: cloneBody,
          len: body.dataStream.length
        });
      } else {
        const dos = BuildTextUtils.selection.delete([selection], body, memoryCursor.cursor, cloneBody, selections.length === 1);
        textX.push(...dos);
      }
      memoryCursor.reset();
      memoryCursor.moveCursor(endOffset);
    }
    const path = getRichTextEditPath2(docDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
function adjustSelectionByTable(selection, tables) {
  const { startOffset, endOffset } = selection;
  const endsWithTable = tables.some((t2) => t2.startIndex === endOffset);
  const newEndOffset = Math.max(startOffset, endsWithTable ? endOffset - 1 : endOffset);
  return {
    ...selection,
    endOffset: newEndOffset,
    collapsed: startOffset === newEndOffset
  };
}
function getCutActionsFromTextRanges(selections, docDataModel, segmentId) {
  var _a, _b;
  const originBody = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
  const textX = new TextX();
  const jsonX = JSONX.getInstance();
  const rawActions = [];
  if (originBody == null) {
    return rawActions;
  }
  const { tables = [] } = originBody;
  const memoryCursor = new MemoryCursor();
  memoryCursor.reset();
  for (let i = 0; i < selections.length; i++) {
    const selection = adjustSelectionByTable(selections[i], tables);
    const { startOffset, endOffset, collapsed } = selection;
    const len = startOffset - memoryCursor.cursor;
    if (collapsed) {
      textX.push({
        t: "r" /* RETAIN */,
        len
      });
    } else {
      textX.push(...BuildTextUtils.selection.delete([selection], originBody, memoryCursor.cursor, null, false));
    }
    memoryCursor.reset();
    memoryCursor.moveCursor(endOffset);
  }
  const path = getRichTextEditPath2(docDataModel, segmentId);
  rawActions.push(jsonX.editOp(textX.serialize(), path));
  const removedCustomBlockIds = getCustomBlockIdsInSelections(originBody, selections);
  const drawings = (_a = docDataModel.getDrawings()) != null ? _a : {};
  const drawingOrder = (_b = docDataModel.getDrawingsOrder()) != null ? _b : [];
  const sortedRemovedCustomBlockIds = removedCustomBlockIds.sort((a, b) => {
    if (drawingOrder.indexOf(a) > drawingOrder.indexOf(b)) {
      return -1;
    } else if (drawingOrder.indexOf(a) < drawingOrder.indexOf(b)) {
      return 1;
    }
    return 0;
  });
  if (sortedRemovedCustomBlockIds.length > 0) {
    for (const blockId of sortedRemovedCustomBlockIds) {
      const drawing = drawings[blockId];
      const drawingIndex = drawingOrder.indexOf(blockId);
      if (drawing == null || drawingIndex < 0) {
        continue;
      }
      const removeDrawingAction = jsonX.removeOp(["drawings", blockId], drawing);
      const removeDrawingOrderAction = jsonX.removeOp(["drawingsOrder", drawingIndex], blockId);
      rawActions.push(removeDrawingAction);
      rawActions.push(removeDrawingOrderAction);
    }
  }
  return rawActions.reduce((acc, cur) => {
    return JSONX.compose(acc, cur);
  }, null);
}
function getCutActionsFromRectRanges(ranges, docDataModel, viewModel, segmentId) {
  const rawActions = [];
  const segmentBody = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
  if (segmentBody == null) {
    return rawActions;
  }
  const textX = new TextX();
  const jsonX = JSONX.getInstance();
  const memoryCursor = new MemoryCursor();
  memoryCursor.reset();
  for (const range of ranges) {
    const { startOffset, endOffset, spanEntireRow, spanEntireTable } = range;
    if (startOffset == null || endOffset == null) {
      continue;
    }
    if (spanEntireTable) {
      const actionParams = getDeleteTableActionParams({ startOffset, endOffset, segmentId }, viewModel);
      if (actionParams == null) {
        continue;
      }
      const { offset, len, tableId } = actionParams;
      if (offset - memoryCursor.cursor > 0) {
        textX.push({
          t: "r" /* RETAIN */,
          len: offset - memoryCursor.cursor
        });
      }
      textX.push({
        t: "d" /* DELETE */,
        len
      });
      const action = jsonX.removeOp(["tableSource", tableId]);
      rawActions.push(action);
      memoryCursor.moveCursorTo(offset + len);
    } else if (spanEntireRow) {
      const actionParams = getDeleteRowsActionsParams({ startOffset, endOffset, segmentId }, viewModel);
      if (actionParams == null) {
        continue;
      }
      const { offset, rowIndexes, len, tableId } = actionParams;
      if (offset - memoryCursor.cursor > 0) {
        textX.push({
          t: "r" /* RETAIN */,
          len: offset - memoryCursor.cursor
        });
      }
      textX.push({
        t: "d" /* DELETE */,
        len
      });
      for (const index of rowIndexes.reverse()) {
        const action = jsonX.removeOp(["tableSource", tableId, "tableRows", index]);
        rawActions.push(action);
      }
      memoryCursor.moveCursorTo(offset + len);
    } else {
      const actionParams = getDeleteRowContentActionParams({ startOffset, endOffset, segmentId }, viewModel);
      if (actionParams == null) {
        continue;
      }
      const { offsets } = actionParams;
      for (const offset of offsets) {
        const { retain, delete: delLen } = offset;
        if (retain - memoryCursor.cursor > 0) {
          textX.push({
            t: "r" /* RETAIN */,
            len: retain - memoryCursor.cursor
          });
        }
        textX.push({
          t: "d" /* DELETE */,
          len: delLen
        });
        memoryCursor.moveCursorTo(retain + delLen);
      }
    }
  }
  const path = getRichTextEditPath2(docDataModel, segmentId);
  rawActions.push(jsonX.editOp(textX.serialize(), path));
  return rawActions.reduce((acc, cur) => {
    return JSONX.compose(acc, cur);
  }, null);
}
function getCutActionsFromDocRanges(textRanges, rectRanges, docDataModel, viewModel, segmentId) {
  let rawActions = [];
  if (Array.isArray(textRanges) && (textRanges == null ? void 0 : textRanges.length) !== 0) {
    rawActions = getCutActionsFromTextRanges(textRanges, docDataModel, segmentId);
  }
  if (Array.isArray(rectRanges) && (rectRanges == null ? void 0 : rectRanges.length) !== 0) {
    const actions = getCutActionsFromRectRanges(rectRanges, docDataModel, viewModel, segmentId);
    if (rawActions == null || rawActions.length === 0) {
      rawActions = actions;
    } else {
      rawActions = JSONX.compose(
        rawActions,
        JSONX.transform(actions, rawActions, "right")
      );
    }
  }
  return rawActions;
}
var CutContentCommand = {
  id: "doc.command.inner-cut",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const { segmentId, textRanges, selections = docSelectionManagerService.getTextRanges() } = params;
    const rectRanges = docSelectionManagerService.getRectRanges();
    if ((!Array.isArray(selections) || selections.length === 0) && (!Array.isArray(rectRanges) || rectRanges.length === 0)) {
      return false;
    }
    const unitId = (_a = univerInstanceService.getCurrentUniverDocInstance()) == null ? void 0 : _a.getUnitId();
    if (!unitId) {
      return false;
    }
    const docDataModel = univerInstanceService.getUniverDocInstance(unitId);
    if (docDataModel == null) {
      return false;
    }
    const docSkeletonManagerService = getCommandSkeleton(accessor, unitId);
    if (docSkeletonManagerService == null) {
      return false;
    }
    const viewModel = docSkeletonManagerService.getViewModel();
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    doMutation.params.actions = getCutActionsFromDocRanges(selections, rectRanges, docDataModel, viewModel, segmentId);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/commands/commands/core-editing.command.ts
var EditorInsertTextCommandId = "doc.command.insert-text";
var InsertCommand = {
  id: EditorInsertTextCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    var _a;
    const commandService = accessor.get(ICommandService);
    const { range, segmentId, body, unitId, cursorOffset } = params;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docDataModel = univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    if (docDataModel == null) {
      return false;
    }
    const activeRange = docSelectionManagerService.getActiveTextRange();
    const originBody = docDataModel.getSelfOrHeaderFooterModel((_a = activeRange == null ? void 0 : activeRange.segmentId) != null ? _a : "").getBody();
    if (originBody == null) {
      return false;
    }
    const { startOffset, collapsed } = range;
    const cursorMove = cursorOffset != null ? cursorOffset : body.dataStream.length;
    const textRanges = [
      {
        startOffset: startOffset + cursorMove,
        endOffset: startOffset + cursorMove,
        style: activeRange == null ? void 0 : activeRange.style,
        collapsed
      }
    ];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges,
        debounce: true
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    if (collapsed) {
      if (startOffset > 0) {
        textX.push({
          t: "r" /* RETAIN */,
          len: startOffset
        });
      }
      textX.push({
        t: "i" /* INSERT */,
        body,
        len: body.dataStream.length
      });
    } else {
      const dos = BuildTextUtils.selection.delete([range], originBody, 0, body);
      textX.push(...dos);
    }
    doMutation.params.textRanges = [{
      startOffset: startOffset + cursorMove,
      endOffset: startOffset + cursorMove,
      collapsed
    }];
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var DeleteCommand = {
  id: "doc.command.delete-text",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    var _a;
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const { range, segmentId, unitId, direction, len = 1 } = params;
    const docDataModel = univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const { startOffset } = range;
    let start = direction === 0 /* LEFT */ ? startOffset - len : startOffset;
    let end = direction === 0 /* LEFT */ ? startOffset - 1 : startOffset + len - 1;
    const customRange = (_a = body.customRanges) == null ? void 0 : _a.find((customRange2) => customRange2.startIndex <= start && customRange2.endIndex >= end);
    if (customRange == null ? void 0 : customRange.wholeEntity) {
      start = customRange.startIndex;
      end = Math.max(end, customRange.endIndex);
    }
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: [{
          startOffset: start,
          endOffset: start,
          collapsed: true
        }],
        debounce: true
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const cursor = 0;
    textX.push({
      t: "r" /* RETAIN */,
      len: start - cursor
    });
    textX.push({
      t: "d" /* DELETE */,
      len: end - start + 1
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var UpdateCommand = {
  id: "doc.command.update-text",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const { range, segmentId, updateBody, coverType, unitId, textRanges } = params;
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (docDataModel == null) {
      return false;
    }
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const { startOffset, endOffset } = range;
    textX.push({
      t: "r" /* RETAIN */,
      len: startOffset
    });
    textX.push({
      t: "r" /* RETAIN */,
      body: updateBody,
      len: endOffset - startOffset,
      coverType
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/commands/commands/doc-delete.command.ts
var DeleteCustomBlockCommand = {
  id: "doc.command.delete-custom-block",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    var _a;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const activeRange = docSelectionManagerService.getActiveTextRange();
    const documentDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (activeRange == null || documentDataModel == null) {
      return false;
    }
    const { direction, range, unitId, drawingId } = params;
    const { startOffset, segmentId, style } = activeRange;
    const cursor = direction === 0 /* LEFT */ ? startOffset - 1 : startOffset;
    const textRanges = [
      {
        startOffset: cursor,
        endOffset: cursor,
        style
      }
    ];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges,
        prevTextRanges: [range]
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const rawActions = [];
    if (startOffset > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: direction === 0 /* LEFT */ ? startOffset - 1 : startOffset
      });
    }
    textX.push({
      t: "d" /* DELETE */,
      len: 1
    });
    const path = getRichTextEditPath2(documentDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    const drawing = ((_a = documentDataModel.getDrawings()) != null ? _a : {})[drawingId];
    const drawingOrder = documentDataModel.getDrawingsOrder();
    const drawingIndex = drawingOrder.indexOf(drawingId);
    const removeDrawingAction = jsonX.removeOp(["drawings", drawingId], drawing);
    const removeDrawingOrderAction = jsonX.removeOp(["drawingsOrder", drawingIndex], drawingId);
    rawActions.push(removeDrawingAction);
    rawActions.push(removeDrawingOrderAction);
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var MergeTwoParagraphCommand = {
  id: "doc.command.merge-two-paragraph",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const { direction, range } = params;
    const activeRange = docSelectionManagerService.getActiveTextRange();
    const ranges = docSelectionManagerService.getTextRanges();
    if (activeRange == null || ranges == null) {
      return false;
    }
    const { segmentId, style } = activeRange;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const originBody = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || originBody == null) {
      return false;
    }
    const actualRange = activeRange;
    const unitId = docDataModel.getUnitId();
    const { startOffset, collapsed } = actualRange;
    if (!collapsed) {
      return false;
    }
    const startIndex = direction === 0 /* LEFT */ ? startOffset : startOffset + 1;
    let curParagraph;
    let nextParagraph;
    for (const paragraph of originBody.paragraphs) {
      if (paragraph.startIndex >= startIndex) {
        nextParagraph = paragraph;
        break;
      }
      curParagraph = paragraph;
    }
    if (curParagraph == null || nextParagraph == null) {
      return false;
    }
    const cursor = direction === 0 /* LEFT */ ? startOffset - 1 : startOffset;
    const textRanges = [
      {
        startOffset: cursor,
        endOffset: cursor,
        style
      }
    ];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges,
        prevTextRanges: [range]
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    if (curParagraph.startIndex > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: curParagraph.startIndex
      });
    }
    textX.push({
      t: "d" /* DELETE */,
      len: 1
    });
    if (nextParagraph.startIndex > curParagraph.startIndex + 1) {
      textX.push({
        t: "r" /* RETAIN */,
        len: nextParagraph.startIndex - curParagraph.startIndex - 1
      });
    }
    textX.push({
      t: "r" /* RETAIN */,
      len: 1,
      coverType: 1 /* REPLACE */,
      body: {
        dataStream: "",
        paragraphs: [
          {
            ...Tools.deepClone(curParagraph),
            startIndex: 0
          }
        ]
      }
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var RemoveHorizontalLineCommand = {
  id: "doc.command.remove-horizontal-line",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor) => {
    var _a;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const activeRange = docSelectionManagerService.getActiveTextRange();
    const ranges = docSelectionManagerService.getTextRanges();
    if (activeRange == null || ranges == null) {
      return false;
    }
    const { segmentId, style } = activeRange;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const originBody = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || originBody == null) {
      return false;
    }
    const actualRange = activeRange;
    const unitId = docDataModel.getUnitId();
    const { startOffset, collapsed } = actualRange;
    if (!collapsed) {
      return false;
    }
    const paragraph = (_a = originBody.paragraphs) == null ? void 0 : _a.find((p) => p.startIndex === startOffset - 1);
    if (paragraph == null) {
      return false;
    }
    const textRanges = [
      {
        startOffset,
        endOffset: startOffset,
        style
      }
    ];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    if (paragraph.startIndex > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: paragraph.startIndex
      });
    }
    textX.push({
      t: "r" /* RETAIN */,
      len: 1,
      coverType: 1 /* REPLACE */,
      body: {
        dataStream: "",
        paragraphs: [
          {
            ...Tools.deepClone({
              ...paragraph,
              paragraphStyle: {
                ...paragraph.paragraphStyle,
                borderBottom: void 0
              }
            }),
            startIndex: 0
          }
        ]
      }
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
function getCursorWhenDelete(textRanges, rectRanges) {
  let cursor = 0;
  if (textRanges == null || textRanges.length === 0) {
    if (typeof rectRanges[0].startOffset === "number") {
      const rectRange = rectRanges[0];
      const { spanEntireRow, spanEntireTable } = rectRange;
      if (spanEntireTable) {
        cursor = rectRange.startOffset - 3;
      } else if (spanEntireRow) {
        if (rectRange.startRow > 0) {
          cursor = rectRange.startOffset - 6;
        } else {
          cursor = rectRange.startOffset;
        }
      } else {
        cursor = rectRanges[0].startOffset;
      }
    }
  } else if (textRanges.length > 0 && rectRanges.length > 0) {
    const textRange = textRanges[0];
    const rectRange = rectRanges[0];
    if (textRange.startOffset != null && rectRange.startOffset != null) {
      if (textRange.startOffset < rectRange.startOffset) {
        cursor = textRange.startOffset;
      } else if (textRange.startOffset >= rectRange.startOffset) {
        const { spanEntireRow, spanEntireTable } = rectRange;
        if (spanEntireTable) {
          cursor = rectRange.startOffset - 3;
        } else if (spanEntireRow) {
          cursor = rectRange.startOffset - 6;
        }
      }
    }
  }
  return cursor;
}
var DeleteLeftCommand = {
  id: "doc.command.delete-left",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (accessor) => {
    var _a, _b, _c, _d, _e, _f;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    let result = true;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (docDataModel == null) {
      return false;
    }
    const unitId = docDataModel.getUnitId();
    const docSkeletonManagerService = getCommandSkeleton(accessor, unitId);
    const activeRange = docSelectionManagerService.getActiveTextRange();
    const rectRanges = docSelectionManagerService.getRectRanges();
    const ranges = docSelectionManagerService.getTextRanges();
    const skeleton = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getSkeleton();
    if (skeleton == null) {
      return false;
    }
    if (rectRanges == null ? void 0 : rectRanges.length) {
      const cursor2 = getCursorWhenDelete(ranges, rectRanges);
      const segmentId2 = rectRanges[0].segmentId;
      const textRanges = [
        {
          startOffset: cursor2,
          endOffset: cursor2
        }
      ];
      return commandService.executeCommand(CutContentCommand.id, {
        segmentId: segmentId2,
        textRanges
      });
    }
    if (activeRange == null || ranges == null) {
      return false;
    }
    const { segmentId, style, segmentPage } = activeRange;
    const body = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (body == null) {
      return false;
    }
    const actualRange = activeRange;
    const { startOffset, collapsed } = actualRange;
    const curGlyph = skeleton.findNodeByCharIndex(startOffset, segmentId, segmentPage);
    const isBullet = hasListGlyph(curGlyph);
    const isIndent = isIndentByGlyph(curGlyph, body);
    let cursor = startOffset;
    const preGlyph = skeleton.findNodeByCharIndex(startOffset - 1, segmentId, segmentPage);
    const isUpdateParagraph = isFirstGlyph(curGlyph) && preGlyph !== curGlyph && (isBullet === true || isIndent === true);
    if (isUpdateParagraph && collapsed) {
      const paragraph = getParagraphByGlyph(curGlyph, body);
      if (paragraph == null) {
        return false;
      }
      const paragraphIndex = paragraph == null ? void 0 : paragraph.startIndex;
      const updateParagraph = { startIndex: 0 };
      const paragraphStyle = paragraph.paragraphStyle;
      if (isBullet === true) {
        const paragraphStyle2 = paragraph.paragraphStyle;
        if (paragraphStyle2) {
          updateParagraph.paragraphStyle = paragraphStyle2;
          const { hanging } = paragraphStyle2;
          if (hanging) {
            updateParagraph.paragraphStyle.indentStart = hanging;
            updateParagraph.paragraphStyle.hanging = void 0;
          }
        }
      } else if (isIndent === true) {
        const bullet = paragraph.bullet;
        if (bullet) {
          updateParagraph.bullet = bullet;
        }
        if (paragraphStyle != null) {
          updateParagraph.paragraphStyle = { ...paragraphStyle };
          delete updateParagraph.paragraphStyle.hanging;
          delete updateParagraph.paragraphStyle.indentStart;
        }
      }
      const textRanges = [
        {
          startOffset: cursor,
          endOffset: cursor,
          style
        }
      ];
      result = await commandService.executeCommand(UpdateCommand.id, {
        unitId: docDataModel.getUnitId(),
        updateBody: {
          dataStream: "",
          paragraphs: [{ ...updateParagraph }]
        },
        range: {
          startOffset: paragraphIndex,
          endOffset: paragraphIndex + 1
        },
        textRanges,
        coverType: 1 /* REPLACE */,
        segmentId
      });
    } else {
      if (collapsed === true) {
        if (preGlyph == null) {
          return true;
        }
        if (preGlyph.content === "\r") {
          const paragraph = (_a = body.paragraphs) == null ? void 0 : _a.find((p) => p.startIndex === startOffset - 1);
          if ((_b = paragraph == null ? void 0 : paragraph.paragraphStyle) == null ? void 0 : _b.borderBottom) {
            result = await commandService.executeCommand(RemoveHorizontalLineCommand.id);
          } else {
            result = await commandService.executeCommand(MergeTwoParagraphCommand.id, {
              direction: 0 /* LEFT */,
              range: actualRange
            });
          }
        } else if (preGlyph.streamType === "\b") {
          const drawing = (_d = docDataModel.getSnapshot().drawings) == null ? void 0 : _d[(_c = preGlyph.drawingId) != null ? _c : ""];
          if (drawing == null) {
            return true;
          }
          const customBlock = (_f = (_e = docDataModel.getBody()) == null ? void 0 : _e.customBlocks) == null ? void 0 : _f.find((block) => block.blockId === preGlyph.drawingId);
          const isInlineDrawingOrCustom = drawing.layoutType === 0 /* INLINE */ || (customBlock == null ? void 0 : customBlock.blockType) === 1 /* CUSTOM */;
          if (isInlineDrawingOrCustom) {
            const unitId2 = docDataModel.getUnitId();
            result = await commandService.executeCommand(DeleteCustomBlockCommand.id, {
              direction: 0 /* LEFT */,
              range: activeRange,
              unitId: unitId2,
              drawingId: preGlyph.drawingId
            });
          } else {
            const prePreGlyph = skeleton.findNodeByCharIndex(startOffset - 2);
            if (prePreGlyph == null) {
              return true;
            }
            cursor -= preGlyph.count;
            cursor -= prePreGlyph.count;
            const textRanges = [
              {
                startOffset: cursor,
                endOffset: cursor,
                style
              }
            ];
            result = await commandService.executeCommand(DeleteCommand.id, {
              unitId: docDataModel.getUnitId(),
              range: {
                ...activeRange,
                startOffset: activeRange.startOffset - 1,
                endOffset: activeRange.endOffset - 1
              },
              segmentId,
              direction: 0 /* LEFT */,
              len: prePreGlyph.count,
              textRanges
            });
          }
        } else {
          cursor -= preGlyph.count;
          result = await commandService.executeCommand(DeleteCommand.id, {
            unitId: docDataModel.getUnitId(),
            range: actualRange,
            segmentId,
            direction: 0 /* LEFT */,
            len: preGlyph.count
          });
        }
      } else {
        const textRanges = getTextRangesWhenDelete(actualRange, [actualRange]);
        result = await commandService.executeCommand(CutContentCommand.id, {
          segmentId,
          textRanges,
          selections: [actualRange]
        });
      }
    }
    return result;
  }
};
var DeleteRightCommand = {
  id: "doc.command.delete-right",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (accessor) => {
    var _a, _b;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (!docDataModel) {
      return false;
    }
    const docSkeletonManagerService = getCommandSkeleton(accessor, docDataModel.getUnitId());
    const commandService = accessor.get(ICommandService);
    const activeRange = docSelectionManagerService.getActiveTextRange();
    const rectRanges = docSelectionManagerService.getRectRanges();
    const ranges = docSelectionManagerService.getTextRanges();
    const skeleton = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getSkeleton();
    if (rectRanges == null ? void 0 : rectRanges.length) {
      const cursor = getCursorWhenDelete(ranges, rectRanges);
      const segmentId2 = rectRanges[0].segmentId;
      const textRanges = [
        {
          startOffset: cursor,
          endOffset: cursor
        }
      ];
      return commandService.executeCommand(CutContentCommand.id, {
        segmentId: segmentId2,
        textRanges
      });
    }
    if (activeRange == null || skeleton == null || ranges == null) {
      return false;
    }
    const { segmentId, style, segmentPage } = activeRange;
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (!docDataModel || !body) {
      return false;
    }
    const actualRange = activeRange;
    const { startOffset, endOffset, collapsed } = actualRange;
    if (startOffset === body.dataStream.length - 2 && collapsed) {
      return true;
    }
    let result = false;
    if (collapsed === true) {
      const needDeleteGlyph = skeleton.findNodeByCharIndex(startOffset, segmentId, segmentPage);
      const nextGlyph = skeleton.findNodeByCharIndex(startOffset + 1);
      if (needDeleteGlyph.streamType === "\r" /* PARAGRAPH */ && (nextGlyph == null ? void 0 : nextGlyph.streamType) === "\n" /* SECTION_BREAK */) {
        return false;
      }
      if (needDeleteGlyph.content === "\r") {
        result = await commandService.executeCommand(MergeTwoParagraphCommand.id, {
          direction: 1 /* RIGHT */,
          range: activeRange
        });
      } else if (needDeleteGlyph.streamType === "\b") {
        const drawing = (_b = docDataModel.getSnapshot().drawings) == null ? void 0 : _b[(_a = needDeleteGlyph.drawingId) != null ? _a : ""];
        if (drawing == null) {
          return true;
        }
        const isInlineDrawing = drawing.layoutType === 0 /* INLINE */;
        if (isInlineDrawing) {
          const unitId = docDataModel.getUnitId();
          result = await commandService.executeCommand(DeleteCustomBlockCommand.id, {
            direction: 1 /* RIGHT */,
            range: activeRange,
            unitId,
            drawingId: needDeleteGlyph.drawingId
          });
        } else {
          if (nextGlyph == null) {
            return true;
          }
          const textRanges = [
            {
              startOffset: startOffset + 1,
              endOffset: startOffset + 1,
              style
            }
          ];
          result = await commandService.executeCommand(DeleteCommand.id, {
            unitId: docDataModel.getUnitId(),
            range: {
              ...activeRange,
              startOffset: startOffset + 1,
              endOffset: endOffset + 1
            },
            segmentId,
            direction: 1 /* RIGHT */,
            textRanges,
            len: nextGlyph.count
          });
        }
      } else {
        const textRanges = [
          {
            startOffset,
            endOffset: startOffset,
            style
          }
        ];
        result = await commandService.executeCommand(DeleteCommand.id, {
          unitId: docDataModel.getUnitId(),
          range: actualRange,
          segmentId,
          direction: 1 /* RIGHT */,
          textRanges,
          len: needDeleteGlyph.count
        });
      }
    } else {
      const textRanges = getTextRangesWhenDelete(actualRange, [actualRange]);
      result = await commandService.executeCommand(CutContentCommand.id, {
        segmentId,
        textRanges,
        selections: [actualRange]
      });
    }
    return result;
  }
};
function getTextRangesWhenDelete(activeRange, ranges) {
  let cursor = activeRange.endOffset;
  for (const range of ranges) {
    const { startOffset, endOffset } = range;
    if (startOffset == null || endOffset == null) {
      continue;
    }
    if (endOffset <= activeRange.endOffset) {
      cursor -= endOffset - startOffset;
    }
  }
  const textRanges = [
    {
      startOffset: cursor,
      endOffset: cursor,
      style: activeRange.style
    }
  ];
  return textRanges;
}

// ../packages/docs-ui/src/services/clipboard/copy-content-cache.ts
var COPY_CONTENT_CACHE_LIMIT = 10;
var ID_LENGTH3 = 6;
function genId() {
  return Tools.generateRandomId(ID_LENGTH3);
}
function extractId(html2) {
  const match = html2.match(/data-copy-id="([^\s]+)"/);
  if (match && match[1]) {
    return match[1];
  }
  return null;
}
var CopyContentCache = class {
  constructor() {
    __publicField(this, "_cache", new LRUMap(COPY_CONTENT_CACHE_LIMIT));
  }
  set(id, clipboardData) {
    this._cache.set(id, clipboardData);
  }
  get(id) {
    return this._cache.get(id);
  }
  clear() {
    this._cache.clear();
  }
};
var copyContentCache = new CopyContentCache();

// ../packages/docs-ui/src/services/clipboard/html-to-udm/parse-node-style.ts
function extractNodeStyle(node) {
  const styles = node.style;
  const docStyles = {};
  const tagName = node.tagName.toLowerCase();
  switch (tagName) {
    case "b":
    case "em":
    case "strong": {
      docStyles.bl = 1 /* TRUE */;
      break;
    }
    case "s": {
      docStyles.st = {
        s: 1 /* TRUE */
      };
      break;
    }
    case "u": {
      docStyles.ul = {
        s: 1 /* TRUE */
      };
      break;
    }
    case "i": {
      docStyles.it = 1 /* TRUE */;
      break;
    }
    case "sub":
    case "sup": {
      docStyles.va = tagName === "sup" ? 3 /* SUPERSCRIPT */ : 2 /* SUBSCRIPT */;
      break;
    }
  }
  for (let i = 0; i < styles.length; i++) {
    const cssRule = styles[i];
    const cssValue = styles.getPropertyValue(cssRule);
    switch (cssRule) {
      case "font-family": {
        docStyles.ff = cssValue.replace(/^"/g, "").replace(/"$/g, "");
        break;
      }
      case "font-size": {
        const fontSize = Number.parseInt(cssValue);
        if (!Number.isNaN(fontSize)) {
          if (cssValue.endsWith("pt")) {
            docStyles.fs = fontSize;
          } else if (cssValue.endsWith("px")) {
            docStyles.fs = pixelToPt(fontSize);
          }
        }
        break;
      }
      case "font-style": {
        if (cssValue === "italic") {
          docStyles.it = 1 /* TRUE */;
        }
        break;
      }
      case "font-weight": {
        const MIDDLE_FONT_WEIGHT = 400;
        if (Number(cssValue) > MIDDLE_FONT_WEIGHT || String(cssValue) === "bold") {
          docStyles.bl = 1 /* TRUE */;
        }
        break;
      }
      case "text-decoration": {
        if (/underline/.test(cssValue)) {
          docStyles.ul = {
            s: 1 /* TRUE */
          };
        } else if (/overline/.test(cssValue)) {
          docStyles.ol = {
            s: 1 /* TRUE */
          };
        } else if (/line-through/.test(cssValue)) {
          docStyles.st = {
            s: 1 /* TRUE */
          };
        }
        break;
      }
      case "color": {
        try {
          const color = new ColorKit(cssValue);
          if (color.isValid) {
            docStyles.cl = {
              rgb: color.toRgbString()
            };
          }
        } catch (_e) {
        }
        break;
      }
      case "background-color": {
        const color = new ColorKit(cssValue);
        if (color.isValid) {
          docStyles.bg = {
            rgb: color.toRgbString()
          };
        }
        break;
      }
      default: {
        break;
      }
    }
  }
  return docStyles;
}

// ../packages/docs-ui/src/services/clipboard/html-to-udm/parse-to-dom.ts
function parseToDom(rawHtml) {
  const parser = new DOMParser();
  const html2 = `<x-univer id="univer-root">${rawHtml}</x-univer>`;
  const doc = parser.parseFromString(html2, "text/html");
  return doc.querySelector("#univer-root");
}

// ../packages/docs-ui/src/services/clipboard/html-to-udm/converter.ts
function matchFilter(node, filter2) {
  const tagName = node.tagName.toLowerCase();
  if (typeof filter2 === "string") {
    return tagName === filter2;
  }
  if (Array.isArray(filter2)) {
    return filter2.some((name) => name === tagName);
  }
  return filter2(node);
}
var DEFAULT_TABLE_WIDTH = 660;
var _HtmlToUDMService = class _HtmlToUDMService {
  constructor() {
    __publicField(this, "_tableCache", []);
    __publicField(this, "_styleCache", /* @__PURE__ */ new Map());
    __publicField(this, "_styleRules", []);
    __publicField(this, "_afterProcessRules", []);
  }
  static use(plugin) {
    if (this._pluginList.includes(plugin)) {
      throw new Error(`Univer paste plugin ${plugin.name} already added`);
    }
    this._pluginList.push(plugin);
  }
  convert(html2, metaConfig = {}) {
    var _a;
    const pastePlugin = _HtmlToUDMService._pluginList.find((plugin) => plugin.checkPasteType(html2));
    const dom = parseToDom(html2);
    const body = {
      dataStream: "",
      paragraphs: [],
      sectionBreaks: [],
      tables: [],
      textRuns: [],
      customBlocks: []
    };
    const docData = {
      body,
      tableSource: {},
      id: (_a = metaConfig == null ? void 0 : metaConfig.unitId) != null ? _a : ""
    };
    if (pastePlugin) {
      this._styleRules = [...pastePlugin.stylesRules];
      this._afterProcessRules = [...pastePlugin.afterProcessRules];
    }
    this._tableCache = [];
    this._styleCache.clear();
    this._process(null, dom.childNodes, docData);
    this._styleCache.clear();
    this._styleRules = [];
    this._afterProcessRules = [];
    return docData;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _process(parent, nodes, doc) {
    var _a, _b, _c, _d;
    const body = doc.body;
    for (const node of nodes) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (((_a = node.nodeValue) == null ? void 0 : _a.trim()) === "") {
          continue;
        }
        const text = (_b = node.nodeValue) == null ? void 0 : _b.replace(/[\r\n]/g, "");
        let style;
        if (parent && this._styleCache.has(parent)) {
          style = this._styleCache.get(parent);
        }
        body.dataStream += text;
        if (style && Object.getOwnPropertyNames(style).length) {
          body.textRuns.push({
            st: body.dataStream.length - text.length,
            ed: body.dataStream.length,
            ts: style
          });
        }
      } else if (node.nodeName === "IMG") {
        const element = node;
        const imageSourceType = element.dataset.imageSourceType;
        const source = imageSourceType === "UUID" /* UUID */ ? element.dataset.source : element.src;
        if (source && imageSourceType) {
          const width = Number(element.dataset.width || 100);
          const height = Number(element.dataset.height || 100);
          const docTransformWidth = Number(element.dataset.docTransformWidth || width);
          const docTransformHeight = Number(element.dataset.docTransformHeight || height);
          const id = Tools.generateRandomId(6);
          (_d = (_c = doc.body) == null ? void 0 : _c.customBlocks) == null ? void 0 : _d.push({ startIndex: body.dataStream.length, blockId: id });
          body.dataStream += "\b";
          if (!doc.drawings) {
            doc.drawings = {};
          }
          doc.drawings[id] = {
            drawingId: id,
            title: "",
            description: "",
            imageSourceType,
            source,
            transform: { width, height, left: 0 },
            docTransform: {
              size: { width: docTransformWidth, height: docTransformHeight },
              angle: 0,
              positionH: {
                relativeFrom: 0 /* PAGE */,
                posOffset: 0
              },
              positionV: {
                relativeFrom: 1 /* PARAGRAPH */,
                posOffset: 0
              }
            },
            layoutType: 0 /* INLINE */,
            drawingType: 0 /* DRAWING_IMAGE */,
            unitId: doc.id || "",
            subUnitId: doc.id || ""
          };
        }
      } else if (skipParseTagNames.includes(node.nodeName.toLowerCase())) {
        continue;
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const linkStart = this._processBeforeLink(element, doc);
        const parentStyles = parent ? this._styleCache.get(parent) : {};
        const styleRule = this._styleRules.find(({ filter: filter2 }) => matchFilter(node, filter2));
        const nodeStyles = styleRule ? styleRule.getStyle(node) : extractNodeStyle(node);
        this._styleCache.set(node, { ...parentStyles, ...nodeStyles });
        const { childNodes } = node;
        this._processBeforeTable(node, doc);
        this._process(node, childNodes, doc);
        this._processAfterTable(node, doc);
        const afterProcessRule = this._afterProcessRules.find(
          ({ filter: filter2 }) => matchFilter(node, filter2)
        );
        if (afterProcessRule) {
          afterProcessRule.handler(doc, node);
        }
        this._processAfterLink(element, doc, linkStart);
      }
    }
  }
  _processBeforeTable(node, doc) {
    var _a;
    const tagName = node.tagName.toUpperCase();
    const body = doc.body;
    switch (tagName) {
      case "TABLE": {
        if (body.dataStream[body.dataStream.length - 1] !== "\r") {
          body.dataStream += "\r";
          if (body.paragraphs == null) {
            body.paragraphs = [];
          }
          (_a = body.paragraphs) == null ? void 0 : _a.push({
            startIndex: body.dataStream.length - 1
          });
        }
        const table2 = genTableSource(0, 0, DEFAULT_TABLE_WIDTH);
        this._tableCache.push({
          table: table2,
          startIndex: body.dataStream.length
        });
        body.dataStream += "" /* TABLE_START */;
        break;
      }
      case "TR": {
        const row = getEmptyTableRow(0);
        const lastTable = this._tableCache[this._tableCache.length - 1].table;
        lastTable.tableRows.push(row);
        body.dataStream += "\x1B" /* TABLE_ROW_START */;
        break;
      }
      case "TD": {
        const cell = getEmptyTableCell();
        const lastTable = this._tableCache[this._tableCache.length - 1].table;
        const lastRow = lastTable.tableRows[lastTable.tableRows.length - 1];
        lastRow.tableCells.push(cell);
        body.dataStream += "" /* TABLE_CELL_START */;
        break;
      }
    }
  }
  _processAfterTable(node, doc) {
    var _a, _b;
    const tagName = node.tagName.toUpperCase();
    const body = doc.body;
    if (doc.tableSource == null) {
      doc.tableSource = {};
    }
    if (body.tables == null) {
      body.tables = [];
    }
    if (body.sectionBreaks == null) {
      body.sectionBreaks = [];
    }
    const { tableSource } = doc;
    switch (tagName) {
      case "TABLE": {
        const tableCache = this._tableCache.pop();
        const { startIndex, table: table2 } = tableCache;
        const colCount = table2.tableRows[0].tableCells.length;
        const tableColumn = getTableColumn(DEFAULT_TABLE_WIDTH / colCount);
        const tableColumns = [...new Array(colCount).fill(null).map(() => Tools.deepClone(tableColumn))];
        table2.tableColumns = tableColumns;
        tableSource[table2.tableId] = table2;
        body.dataStream += "" /* TABLE_END */;
        body.tables.push({
          startIndex,
          endIndex: body.dataStream.length,
          tableId: table2.tableId
        });
        break;
      }
      case "TR": {
        body.dataStream += "" /* TABLE_ROW_END */;
        break;
      }
      case "TD": {
        if (body.dataStream[body.dataStream.length - 1] !== "\r") {
          (_a = body.paragraphs) == null ? void 0 : _a.push({
            startIndex: body.dataStream.length
          });
          body.dataStream += "\r";
        }
        (_b = body.sectionBreaks) == null ? void 0 : _b.push({
          startIndex: body.dataStream.length
        });
        body.dataStream += `
${"" /* TABLE_CELL_END */}`;
        break;
      }
    }
  }
  _processBeforeLink(node, doc) {
    const body = doc.body;
    return body.dataStream.length;
  }
  _processAfterLink(node, doc, start) {
    var _a, _b;
    const body = doc.body;
    const element = node;
    if (element.tagName.toUpperCase() === "A") {
      body.customRanges = (_a = body.customRanges) != null ? _a : [];
      body.customRanges.push({
        startIndex: start,
        endIndex: body.dataStream.length - 1,
        rangeId: (_b = element.dataset.rangeid) != null ? _b : generateRandomId(),
        rangeType: 0 /* HYPERLINK */,
        properties: { url: element.href }
      });
    }
  }
};
__publicField(_HtmlToUDMService, "_pluginList", []);
var HtmlToUDMService = _HtmlToUDMService;

// ../packages/docs-ui/src/services/clipboard/html-to-udm/paste-plugins/plugin-lark.ts
var wordPastePlugin = {
  name: "univer-doc-paste-plugin-lark",
  checkPasteType(html2) {
    return /lark-record-clipboard/i.test(html2);
  },
  // TODO: @JOCS, support inline code copy from lark.
  stylesRules: [
    {
      filter: ["s"],
      getStyle(node) {
        const inlineStyle = extractNodeStyle(node);
        return {
          st: {
            s: 1 /* TRUE */
          },
          ...inlineStyle
        };
      }
    }
  ],
  afterProcessRules: [
    {
      filter(el) {
        return el.tagName === "DIV" && /ace-line/i.test(el.className);
      },
      handler(doc) {
        const body = doc.body;
        if (body.paragraphs == null) {
          body.paragraphs = [];
        }
        body.paragraphs.push({
          startIndex: body.dataStream.length
        });
        body.dataStream += "\r";
      }
    }
  ]
};
var plugin_lark_default = wordPastePlugin;

// ../packages/docs-ui/src/services/clipboard/html-to-udm/utils.ts
function getParagraphStyle(el) {
  const styles = el.style;
  const paragraphStyle = {};
  for (let i = 0; i < styles.length; i++) {
    const cssRule = styles[i];
    const cssValue = styles.getPropertyValue(cssRule);
    switch (cssRule) {
      case "margin-top": {
        const marginTopValue = Number.parseInt(cssValue);
        paragraphStyle.spaceAbove = { v: /pt/.test(cssValue) ? ptToPixel(marginTopValue) : marginTopValue };
        break;
      }
      case "margin-bottom": {
        const marginBottomValue = Number.parseInt(cssValue);
        paragraphStyle.spaceBelow = { v: /pt/.test(cssValue) ? ptToPixel(marginBottomValue) : marginBottomValue };
        break;
      }
      case "line-height": {
        let lineHeightValue = Number.parseFloat(cssValue);
        if (cssValue.endsWith("%")) {
          lineHeightValue /= 100;
        }
        paragraphStyle.lineSpacing = lineHeightValue;
        break;
      }
      default: {
        break;
      }
    }
  }
  return Object.getOwnPropertyNames(paragraphStyle).length ? paragraphStyle : null;
}

// ../packages/docs-ui/src/services/clipboard/html-to-udm/paste-plugins/plugin-univer.ts
var univerPastePlugin = {
  name: "univer-doc-paste-plugin-univer",
  checkPasteType(html2) {
    return /UniverNormal/i.test(html2);
  },
  stylesRules: [],
  afterProcessRules: [
    {
      filter(el) {
        return el.tagName === "P" && /UniverNormal/i.test(el.className);
      },
      handler(doc, el) {
        const body = doc.body;
        if (body.paragraphs == null) {
          body.paragraphs = [];
        }
        const paragraph = {
          startIndex: body.dataStream.length
        };
        const paragraphStyle = getParagraphStyle(el);
        if (paragraphStyle) {
          paragraph.paragraphStyle = paragraphStyle;
        }
        body.paragraphs.push(paragraph);
        body.dataStream += "\r";
      }
    }
  ]
};
var plugin_univer_default = univerPastePlugin;

// ../packages/docs-ui/src/services/clipboard/html-to-udm/paste-plugins/plugin-word.ts
var wordPastePlugin2 = {
  name: "univer-doc-paste-plugin-word",
  checkPasteType(html2) {
    return /word|mso/i.test(html2);
  },
  stylesRules: [
    {
      filter: ["b"],
      getStyle(node) {
        const inlineStyle = extractNodeStyle(node);
        return { bl: 1 /* TRUE */, ...inlineStyle };
      }
    }
  ],
  afterProcessRules: [
    {
      filter(el) {
        return el.tagName === "P";
      },
      handler(doc, el) {
        const body = doc.body;
        if (body.paragraphs == null) {
          body.paragraphs = [];
        }
        const paragraph = {
          startIndex: body.dataStream.length
        };
        const paragraphStyle = getParagraphStyle(el);
        if (paragraphStyle) {
          paragraph.paragraphStyle = paragraphStyle;
        }
        body.paragraphs.push(paragraph);
        body.dataStream += "\r";
      }
    }
  ]
};
var plugin_word_default = wordPastePlugin2;

// ../packages/docs-ui/src/services/clipboard/udm-to-html/convertor.ts
function covertImageToHtml(item) {
  var _a, _b;
  const transformObjectToString = (obj2) => {
    let result = "";
    Object.keys(obj2).forEach((key) => {
      if (obj2[key] !== void 0) {
        result += ` ${key}=${obj2[key]}`;
      }
    });
    return result;
  };
  const obj = {
    "data-doc-transform-height": item.docTransform.size.height,
    "data-doc-transform-width": item.docTransform.size.width,
    "data-width": (_a = item.transform) == null ? void 0 : _a.width,
    "data-height": (_b = item.transform) == null ? void 0 : _b.height,
    "data-image-source-type": item.imageSourceType,
    "data-source": item.imageSourceType === "UUID" /* UUID */ ? item.source : void 0,
    src: item.source
  };
  return `<img  ${transformObjectToString(obj)}></img>`;
}
function covertTextRunToHtml(dataStream, textRun) {
  const { st: start, ed, ts = {} } = textRun;
  const { ff, fs, it, bl, ul, st, ol, bg, cl, va } = ts;
  let html2 = dataStream.slice(start, ed);
  const style = [];
  if (it === 1 /* TRUE */) {
    html2 = `<i>${html2}</i>`;
  }
  if (va === 3 /* SUPERSCRIPT */) {
    html2 = `<sup>${html2}</sup>`;
  } else if (va === 2 /* SUBSCRIPT */) {
    html2 = `<sub>${html2}</sub>`;
  }
  if ((ul == null ? void 0 : ul.s) === 1 /* TRUE */) {
    html2 = `<u>${html2}</u>`;
  }
  if ((st == null ? void 0 : st.s) === 1 /* TRUE */) {
    html2 = `<s>${html2}</s>`;
  }
  if (bl === 1 /* TRUE */) {
    html2 = `<strong>${html2}</strong>`;
  }
  if (ff) {
    style.push(`font-family: ${ff}`);
  }
  if (cl) {
    style.push(`color: ${cl.rgb}`);
  }
  if (fs) {
    style.push(`font-size: ${fs}pt`);
  }
  if (ol) {
    style.push("text-decoration: overline");
  }
  if (bg) {
    style.push(`background: ${bg.rgb}`);
  }
  return style.length ? `<span style="${style.join("; ")};">${html2}</span>` : html2;
}
function getBodyInlineSlice(body, startIndex, endIndex) {
  const { dataStream, textRuns = [] } = body;
  if (startIndex === endIndex) {
    return "";
  }
  let cursorIndex = startIndex;
  const spanList = [];
  for (const textRun of textRuns) {
    const { st, ed } = textRun;
    if (Tools.hasIntersectionBetweenTwoRanges(startIndex, endIndex, st, ed)) {
      if (st > cursorIndex) {
        spanList.push(dataStream.slice(cursorIndex, st));
        spanList.push(covertTextRunToHtml(dataStream, {
          ...textRun,
          ed: Math.min(ed, endIndex)
        }));
      } else {
        spanList.push(covertTextRunToHtml(dataStream, {
          ...textRun,
          st: cursorIndex,
          ed: Math.min(ed, endIndex)
        }));
      }
    }
    cursorIndex = Math.max(startIndex, Math.min(ed, endIndex));
  }
  if (cursorIndex !== endIndex) {
    spanList.push(dataStream.slice(cursorIndex, endIndex));
  }
  return spanList.join("");
}
function getBodySliceHtml(doc, startIndex, endIndex) {
  const body = doc.body;
  const drawings = doc.drawings || {};
  const { customRanges = [], customBlocks = [] } = body || {};
  const cloneCustomBlocks = [...customBlocks];
  const customRangesInRange = customRanges.filter((range) => range.startIndex >= startIndex && range.endIndex <= endIndex);
  let cursorIndex = startIndex;
  let html2 = "";
  const handleCustomBlock = (startIndex2, endIndex2) => {
    let sliceHtml = "";
    let customBlockLength = 0;
    let handleCustomBlockCursorIndex = startIndex2;
    let blockItemIndex = cloneCustomBlocks.findIndex((block) => startIndex2 <= block.startIndex && endIndex2 >= block.startIndex);
    if (blockItemIndex === -1) {
      sliceHtml = getBodyInlineSlice(body, startIndex2, endIndex2);
      return { sliceHtml, customBlockLength };
    }
    while (blockItemIndex !== -1) {
      const blockItem = cloneCustomBlocks[blockItemIndex];
      cloneCustomBlocks.splice(blockItemIndex, 1);
      sliceHtml += getBodyInlineSlice(body, handleCustomBlockCursorIndex, blockItem.startIndex);
      const drawingItem = drawings[blockItem.blockId];
      if (drawingItem) {
        switch (drawingItem.drawingType) {
          case 0 /* DRAWING_IMAGE */: {
            sliceHtml += covertImageToHtml(drawingItem);
            customBlockLength++;
            break;
          }
        }
      }
      handleCustomBlockCursorIndex = blockItem.startIndex + 1;
      blockItemIndex = cloneCustomBlocks.findIndex((block) => handleCustomBlockCursorIndex <= block.startIndex && endIndex2 >= block.startIndex);
    }
    sliceHtml = sliceHtml + getBodyInlineSlice(body, handleCustomBlockCursorIndex, endIndex2 + 1);
    return { sliceHtml, customBlockLength };
  };
  customRangesInRange.forEach((range) => {
    var _a, _b;
    const { startIndex: startIndex2, endIndex: endIndex2, rangeType, rangeId } = range;
    const preHtml = handleCustomBlock(cursorIndex, startIndex2);
    html2 += preHtml.sliceHtml;
    const sliceHtml = handleCustomBlock(startIndex2, endIndex2 + 1);
    switch (rangeType) {
      case 0 /* HYPERLINK */: {
        html2 += `<a data-rangeid="${rangeId}" href="${(_b = (_a = range.properties) == null ? void 0 : _a.url) != null ? _b : ""}">${sliceHtml.sliceHtml}</a>`;
        break;
      }
      default: {
        html2 += sliceHtml.sliceHtml;
        break;
      }
    }
    cursorIndex = endIndex2 + 1 + (preHtml.customBlockLength + sliceHtml.customBlockLength);
  });
  const endHtml = handleCustomBlock(cursorIndex, endIndex);
  html2 += endHtml.sliceHtml;
  return html2;
}
function convertBodyToHtml(doc) {
  const body = doc.body || {};
  const { paragraphs = [], sectionBreaks = [] } = body;
  let { dataStream = "" } = body;
  if (!dataStream.endsWith("\r\n")) {
    dataStream += "\r\n";
    paragraphs.push({
      startIndex: dataStream.length - 2
    });
    sectionBreaks.push({
      startIndex: dataStream.length - 1
    });
    body.dataStream = dataStream;
    body.paragraphs = paragraphs;
    body.sectionBreaks = sectionBreaks;
  }
  const result = { html: "" };
  const nodeList = parseDataStreamToTree(dataStream).sectionList;
  for (const node of nodeList) {
    processNode(node, doc, result);
  }
  return result.html;
}
function processNode(node, doc, result) {
  var _a, _b;
  switch (node.nodeType) {
    case "SECTION_BREAK" /* SECTION_BREAK */: {
      for (const n of node.children) {
        processNode(n, doc, result);
      }
      break;
    }
    case "PARAGRAPH" /* PARAGRAPH */: {
      const { children, startIndex, endIndex } = node;
      const paragraph = (_b = (_a = doc.body) == null ? void 0 : _a.paragraphs.find((p) => p.startIndex === endIndex)) != null ? _b : {};
      const { paragraphStyle = {} } = paragraph;
      const { spaceAbove, spaceBelow, lineSpacing } = paragraphStyle;
      const style = [];
      if (spaceAbove != null) {
        if (typeof spaceAbove === "number") {
          style.push(`margin-top: ${spaceAbove}px`);
        } else {
          style.push(`margin-top: ${spaceAbove.v}px`);
        }
      }
      if (spaceBelow != null) {
        if (typeof spaceBelow === "number") {
          style.push(`margin-bottom: ${spaceBelow}px`);
        } else {
          style.push(`margin-bottom: ${spaceBelow.v}px`);
        }
      }
      if (lineSpacing != null) {
        style.push(`line-height: ${lineSpacing}`);
      }
      result.html += `<p class="UniverNormal" ${style.length ? `style="${style.join("; ")};"` : ""}>`;
      if (children.length) {
        for (const table2 of children) {
          processNode(table2, doc, result);
        }
      }
      result.html += `${getBodySliceHtml(doc, startIndex, endIndex)}</p>`;
      break;
    }
    case "TABLE" /* TABLE */: {
      const { children } = node;
      result.html += '<table class="UniverTable" style="width: 100%; border-collapse: collapse;"><tbody>';
      for (const row of children) {
        processNode(row, doc, result);
      }
      result.html += "</tbody></table>";
      break;
    }
    case "TABLE_ROW" /* TABLE_ROW */: {
      const { children } = node;
      result.html += '<tr class="UniverTableRow">';
      for (const cell of children) {
        processNode(cell, doc, result);
      }
      result.html += "</tr>";
      break;
    }
    case "TABLE_CELL" /* TABLE_CELL */: {
      const { children } = node;
      result.html += '<td class="UniverTableCell">';
      for (const n of children) {
        processNode(n, doc, result);
      }
      result.html += "</td>";
      break;
    }
    default: {
      throw new Error(`Unknown node type: ${node.nodeType}`);
    }
  }
}
var UDMToHtmlService = class {
  convert(docList) {
    if (docList.length === 0) {
      throw new Error("The bodyList length at least to be 1");
    }
    let html2 = "";
    for (const doc of Tools.deepClone(docList)) {
      html2 += convertBodyToHtml(doc);
    }
    return html2;
  }
};

// ../packages/docs-ui/src/services/clipboard/clipboard.service.ts
HtmlToUDMService.use(plugin_word_default);
HtmlToUDMService.use(plugin_lark_default);
HtmlToUDMService.use(plugin_univer_default);
function getTableSlice(body, start, end) {
  var _a, _b, _c;
  const bodySlice = getBodySlice(body, start, end + 2);
  const dataStream = "" /* TABLE_START */ + "\x1B" /* TABLE_ROW_START */ + "" /* TABLE_CELL_START */ + bodySlice.dataStream + "" /* TABLE_CELL_END */ + "" /* TABLE_ROW_END */ + "" /* TABLE_END */;
  bodySlice.dataStream = dataStream;
  (_a = bodySlice.textRuns) == null ? void 0 : _a.forEach((textRun) => {
    const { st, ed } = textRun;
    textRun.st = st + 3;
    textRun.ed = ed + 3;
  });
  (_b = bodySlice.tables) == null ? void 0 : _b.forEach((table2) => {
    const { startIndex, endIndex } = table2;
    table2.startIndex = startIndex + 3;
    table2.endIndex = endIndex + 3;
  });
  (_c = bodySlice.paragraphs) == null ? void 0 : _c.forEach((paragraph) => {
    const { startIndex } = paragraph;
    paragraph.startIndex = startIndex + 3;
  });
  return bodySlice;
}
var IDocClipboardService = createIdentifier("doc.clipboard-service");
var DocClipboardService = class extends Disposable {
  constructor(_univerInstanceService, _logService, _commandService, _clipboardInterfaceService, _docSelectionManagerService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._logService = _logService;
    this._commandService = _commandService;
    this._clipboardInterfaceService = _clipboardInterfaceService;
    this._docSelectionManagerService = _docSelectionManagerService;
    __publicField(this, "_clipboardHooks", []);
    __publicField(this, "_htmlToUDM", new HtmlToUDMService());
    __publicField(this, "_umdToHtml", new UDMToHtmlService());
  }
  async copy(sliceType = 0 /* copy */) {
    var _a;
    const { newSnapshotList = [], needCache = false, snapshot } = (_a = this._getDocumentBodyInRanges(sliceType)) != null ? _a : {};
    if (newSnapshotList.length === 0 || snapshot == null) {
      return false;
    }
    try {
      const activeRange = this._docSelectionManagerService.getActiveTextRange();
      const isCopyInHeaderFooter = !!(activeRange == null ? void 0 : activeRange.segmentId);
      this._setClipboardData(newSnapshotList, !isCopyInHeaderFooter && needCache);
    } catch (e) {
      this._logService.error("[DocClipboardService] copy failed", e);
      return false;
    }
    return true;
  }
  async cut() {
    return this._cut();
  }
  async paste(items) {
    const partDocData = await this._genDocDataFromClipboardItems(items);
    return this._paste(partDocData);
  }
  async legacyPaste(options) {
    let { html: html2, text, files } = options;
    const currentDocInstance = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const docUnitId = (currentDocInstance == null ? void 0 : currentDocInstance.getUnitId()) || "";
    if (!html2 && !text && files.length) {
      html2 = await this._createImagePasteHtml(files);
    }
    const partDocData = this._genDocDataFromHtmlAndText(html2, text, docUnitId);
    if (docUnitId === DOCS_NORMAL_EDITOR_UNIT_ID_KEY) {
      if (text) {
        const textDocData = BuildTextUtils.transform.fromPlainText(text);
        return this._paste({ body: textDocData });
      } else {
        partDocData.body.textRuns = [];
      }
    }
    return this._paste(partDocData);
  }
  async _cut() {
    var _a, _b, _c;
    const {
      segmentId,
      endOffset: activeEndOffset,
      style
    } = (_a = this._docSelectionManagerService.getActiveTextRange()) != null ? _a : {};
    const textRanges = (_b = this._docSelectionManagerService.getTextRanges()) != null ? _b : [];
    const rectRanges = (_c = this._docSelectionManagerService.getRectRanges()) != null ? _c : [];
    if (segmentId == null) {
      this._logService.error("[DocClipboardController] segmentId is not existed");
    }
    if (textRanges.length === 0 && rectRanges.length === 0) {
      return false;
    }
    this.copy(1 /* cut */);
    try {
      let cursor = 0;
      if (rectRanges.length > 0) {
        cursor = getCursorWhenDelete(textRanges, rectRanges);
      } else if (activeEndOffset != null) {
        cursor = activeEndOffset;
        for (const range of textRanges) {
          const { startOffset, endOffset } = range;
          if (startOffset == null || endOffset == null) {
            continue;
          }
          if (endOffset <= activeEndOffset) {
            cursor -= endOffset - startOffset;
          }
        }
      }
      const newTextRanges = [
        {
          startOffset: cursor,
          endOffset: cursor,
          style
        }
      ];
      return this._commandService.executeCommand(CutContentCommand.id, { segmentId, textRanges: newTextRanges });
    } catch (_e) {
      this._logService.error("[DocClipboardController] cut content failed");
      return false;
    }
  }
  async _paste(docData) {
    var _a, _b;
    const { body: _body } = docData;
    if (_body == null) {
      return false;
    }
    let body = normalizeBody(_body);
    const unitId = (_a = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC)) == null ? void 0 : _a.getUnitId();
    if (!unitId) {
      return false;
    }
    this._clipboardHooks.forEach((hook) => {
      if (hook.onBeforePaste) {
        body = hook.onBeforePaste(body);
      }
    });
    body.customRanges = (_b = body.customRanges) == null ? void 0 : _b.map(BuildTextUtils.customRange.copyCustomRange);
    const activeRange = this._docSelectionManagerService.getActiveTextRange();
    const { segmentId, endOffset: activeEndOffset, style } = activeRange || {};
    const ranges = this._docSelectionManagerService.getTextRanges();
    if (segmentId == null) {
      this._logService.error("[DocClipboardController] segmentId does not exist!");
    }
    if (activeEndOffset == null || ranges == null) {
      return false;
    }
    try {
      let cursor = activeEndOffset;
      for (const range of ranges) {
        const { startOffset, endOffset } = range;
        if (startOffset == null || endOffset == null) {
          continue;
        }
        if (endOffset <= activeEndOffset) {
          cursor += body.dataStream.length - (endOffset - startOffset);
        }
      }
      const textRanges = [
        {
          startOffset: cursor,
          endOffset: cursor,
          style
        }
      ];
      return this._commandService.executeCommand(InnerPasteCommand.id, {
        doc: {
          ...docData,
          body
        },
        segmentId,
        textRanges
      });
    } catch (_819) {
      this._logService.error("[DocClipboardController]", "clipboard is empty.");
      return false;
    }
  }
  async _setClipboardData(documentList, needCache = true) {
    var _a, _b, _c, _d;
    const copyId = genId();
    const text = (documentList.length > 1 ? documentList.map((doc) => {
      var _a2;
      return ((_a2 = doc.body) == null ? void 0 : _a2.dataStream) || "";
    }).join("\n") : ((_a = documentList[0].body) == null ? void 0 : _a.dataStream) || "").replaceAll("" /* TABLE_START */, "").replaceAll("" /* TABLE_END */, "").replaceAll("\x1B" /* TABLE_ROW_START */, "").replaceAll("" /* TABLE_ROW_END */, "").replaceAll("" /* TABLE_CELL_START */, "").replaceAll("" /* TABLE_CELL_END */, "").replaceAll("\r\n", " ");
    let html2 = this._umdToHtml.convert(documentList);
    if (documentList.length === 1 && needCache) {
      html2 = html2.replace(/(<[a-z]+)/, (_p0, p1) => `${p1} data-copy-id="${copyId}"`);
      const doc = documentList[0];
      const cache = { body: doc.body };
      if ((_c = (_b = doc.body) == null ? void 0 : _b.customBlocks) == null ? void 0 : _c.length) {
        cache.drawings = {};
        for (const block of doc.body.customBlocks) {
          const { blockId } = block;
          const drawing = (_d = doc.drawings) == null ? void 0 : _d[blockId];
          if (drawing) {
            const id = Tools.generateRandomId(6);
            block.blockId = id;
            cache.drawings[id] = {
              ...Tools.deepClone(drawing),
              drawingId: id
            };
          }
        }
      }
      copyContentCache.set(copyId, cache);
    }
    return this._clipboardInterfaceService.write(text, html2);
  }
  addClipboardHook(hook) {
    this._clipboardHooks.push(hook);
    return toDisposable(() => {
      const index = this._clipboardHooks.indexOf(hook);
      if (index > -1) {
        this._clipboardHooks.splice(index, 1);
      }
    });
  }
  _getDocumentBodyInRanges(sliceType) {
    var _a;
    const docDataModel = this._univerInstanceService.getCurrentUniverDocInstance();
    const allRanges = this._docSelectionManagerService.getDocRanges();
    const results = [];
    let needCache = true;
    if (docDataModel == null || allRanges.length === 0) {
      return;
    }
    const segmentId = allRanges[0].segmentId;
    const body = (_a = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId)) == null ? void 0 : _a.getBody();
    const snapshot = docDataModel.getSnapshot();
    if (body == null) {
      return;
    }
    for (const range of allRanges) {
      const { startOffset, endOffset, collapsed, rangeType } = range;
      if (collapsed || startOffset == null || endOffset == null) {
        continue;
      }
      if (rangeType === "RECT" /* RECT */) {
        needCache = false;
        const { spanEntireRow } = range;
        let bodySlice;
        if (!spanEntireRow) {
          bodySlice = getTableSlice(body, startOffset, endOffset);
        } else {
          bodySlice = getTableSlice(body, startOffset, endOffset);
        }
        results.push(bodySlice);
        continue;
      }
      const deleteRange = { startOffset, endOffset, collapsed };
      const docBody = docDataModel.getSelfOrHeaderFooterModel(segmentId).sliceBody(deleteRange.startOffset, deleteRange.endOffset, sliceType);
      if (docBody == null) {
        continue;
      }
      results.push(docBody);
    }
    return {
      newSnapshotList: results.map((e) => ({ ...snapshot, body: e })),
      needCache,
      snapshot
    };
  }
  async _genDocDataFromClipboardItems(items) {
    try {
      let html2 = "";
      let text = "";
      const files = [];
      for (const clipboardItem of items) {
        for (const type2 of clipboardItem.types) {
          switch (type2) {
            case PLAIN_TEXT_CLIPBOARD_MIME_TYPE: {
              text = await clipboardItem.getType(type2).then((blob) => blob && blob.text());
              break;
            }
            case HTML_CLIPBOARD_MIME_TYPE: {
              html2 = await clipboardItem.getType(type2).then((blob) => blob && blob.text());
              break;
            }
            case FILE__BMP_CLIPBOARD_MIME_TYPE:
            case FILE__JPEG_CLIPBOARD_MIME_TYPE:
            case FILE__WEBP_CLIPBOARD_MIME_TYPE:
            case FILE_PNG_CLIPBOARD_MIME_TYPE: {
              const blob = await clipboardItem.getType(type2);
              const file = new File([blob], `pasted_image.${type2.split("/")[1]}`, { type: type2 });
              files.push(file);
              break;
            }
          }
        }
      }
      if (!html2 && !text && files.length) {
        html2 = await this._createImagePasteHtml(files);
      }
      return this._genDocDataFromHtmlAndText(html2, text);
    } catch (e) {
      return Promise.reject(e);
    }
  }
  _genDocDataFromHtmlAndText(html2, text, _unitId) {
    if (!html2) {
      if (text) {
        const body = BuildTextUtils.transform.fromPlainText(text);
        return { body };
      } else {
        throw new Error("[DocClipboardService] html and text cannot be both empty!");
      }
    }
    const copyId = extractId(html2);
    if (copyId) {
      const copyCache = copyContentCache.get(copyId);
      if (copyCache) {
        return copyCache;
      }
    }
    if (!_unitId) {
      const currentDocInstance = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
      const docUnitId = (currentDocInstance == null ? void 0 : currentDocInstance.getUnitId()) || "";
      _unitId = docUnitId;
    }
    const doc = this._htmlToUDM.convert(html2, { unitId: _unitId });
    if (copyId) {
      copyContentCache.set(copyId, doc);
    }
    return doc;
  }
  async _createImagePasteHtml(files) {
    var _a, _b;
    const doc = {
      id: "",
      documentStyle: {},
      body: {
        dataStream: "",
        customBlocks: []
      },
      drawings: {}
    };
    const fileToBase64 = async (file) => {
      const reader = new FileReader();
      return new Promise((res) => {
        reader.onloadend = function() {
          res({
            source: reader.result,
            imageSourceType: "BASE64" /* BASE64 */
          });
        };
        reader.readAsDataURL(file);
      });
    };
    const getImageSize2 = (base64) => {
      const img = new Image();
      const maxWidth = 500;
      return new Promise((resolve) => {
        img.src = typeof base64 === "string" ? base64 : URL.createObjectURL(base64);
        img.onload = () => {
          const width = Math.min(maxWidth, img.naturalWidth);
          const scale = img.naturalHeight / img.naturalWidth;
          resolve({ width, height: width * scale });
        };
      });
    };
    const onBeforePasteImage = (_b = (_a = this._clipboardHooks.find((e) => e.onBeforePasteImage)) == null ? void 0 : _a.onBeforePasteImage) != null ? _b : fileToBase64;
    await Promise.all(files.map(async (file, index) => {
      var _a2;
      const image = await onBeforePasteImage(file);
      if (!image) {
        return Promise.resolve();
      }
      const { width = 100, height = 100 } = await getImageSize2(file);
      const itemId = `paste_image_id_${index}`;
      const body = doc.body;
      const drawings = doc.drawings;
      body.dataStream += "\b";
      (_a2 = body.customBlocks) == null ? void 0 : _a2.push({ startIndex: index, blockId: itemId });
      drawings[itemId] = {
        drawingId: itemId,
        unitId: "",
        subUnitId: "",
        imageSourceType: image.imageSourceType,
        title: "",
        source: image.source,
        description: "",
        layoutType: 0 /* INLINE */,
        drawingType: 0 /* DRAWING_IMAGE */,
        transform: {
          width,
          height,
          angle: 0
        },
        docTransform: {
          angle: 0,
          size: { width, height },
          positionH: { relativeFrom: 2 /* CHARACTER */, posOffset: 0 },
          positionV: { relativeFrom: 2 /* LINE */, posOffset: 0 }
        }
      };
    }));
    const html2 = this._umdToHtml.convert([doc]);
    return html2;
  }
};
DocClipboardService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, ILogService),
  __decorateParam(2, ICommandService),
  __decorateParam(3, IClipboardInterfaceService),
  __decorateParam(4, Inject(DocSelectionManagerService))
], DocClipboardService);

// ../packages/docs-ui/src/commands/commands/clipboard.command.ts
function whenDocOrEditor(contextService) {
  return contextService.getContextValue(FOCUSING_DOC) || contextService.getContextValue(EDITOR_ACTIVATED);
}
var DOC_CLIPBOARD_PRIORITY = 999;
var DocCopyCommand = {
  id: CopyCommand.id,
  name: "doc.command.copy",
  type: 0 /* COMMAND */,
  multi: true,
  priority: DOC_CLIPBOARD_PRIORITY,
  preconditions: whenDocOrEditor,
  handler: async (accessor) => {
    const docClipboardService = accessor.get(IDocClipboardService);
    return docClipboardService.copy();
  }
};
var DocCutCommand = {
  id: CutCommand.id,
  name: "doc.command.cut",
  type: 0 /* COMMAND */,
  multi: true,
  priority: DOC_CLIPBOARD_PRIORITY,
  preconditions: whenDocOrEditor,
  handler: async (accessor) => {
    const docClipboardService = accessor.get(IDocClipboardService);
    return docClipboardService.cut();
  }
};
var DocPasteCommand = {
  id: PasteCommand.id,
  name: "doc.command.paste",
  type: 0 /* COMMAND */,
  multi: true,
  priority: DOC_CLIPBOARD_PRIORITY,
  preconditions: whenDocOrEditor,
  handler: async (accessor) => {
    const docClipboardService = accessor.get(IDocClipboardService);
    const clipboardInterfaceService = accessor.get(IClipboardInterfaceService);
    const clipboardItems = await clipboardInterfaceService.read();
    if (clipboardItems.length === 0) {
      return false;
    }
    return docClipboardService.paste(clipboardItems);
  }
};

// ../packages/docs-ui/src/commands/commands/break-line.command.ts
function generateParagraphs(dataStream, prevParagraph, borderBottom) {
  const paragraphs = [];
  for (let i = 0, len = dataStream.length; i < len; i++) {
    const char = dataStream[i];
    if (char !== "\r" /* PARAGRAPH */) {
      continue;
    }
    paragraphs.push({
      startIndex: i
    });
  }
  if (prevParagraph) {
    for (const paragraph of paragraphs) {
      if (prevParagraph.bullet) {
        paragraph.bullet = Tools.deepClone(prevParagraph.bullet);
      }
      if (prevParagraph.paragraphStyle) {
        paragraph.paragraphStyle = Tools.deepClone(prevParagraph.paragraphStyle);
        delete paragraph.paragraphStyle.borderBottom;
      }
    }
  }
  if (borderBottom) {
    for (const paragraph of paragraphs) {
      if (!paragraph.paragraphStyle) {
        paragraph.paragraphStyle = {};
      }
      paragraph.paragraphStyle.borderBottom = borderBottom;
    }
  }
  return paragraphs;
}
var BreakLineCommand = {
  id: "doc.command.break-line",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a, _b;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docMenuStyleService = accessor.get(DocMenuStyleService);
    const activeTextRange = docSelectionManagerService.getActiveTextRange();
    const rectRanges = docSelectionManagerService.getRectRanges();
    if (activeTextRange == null) {
      return false;
    }
    if (rectRanges && rectRanges.length) {
      const { startOffset: startOffset2 } = activeTextRange;
      docSelectionManagerService.replaceDocRanges([{
        startOffset: startOffset2,
        endOffset: startOffset2
      }]);
      return true;
    }
    const { horizontalLine } = params != null ? params : {};
    const { segmentId } = activeTextRange;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId != null ? segmentId : "").getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const unitId = docDataModel.getUnitId();
    const { startOffset, endOffset } = activeTextRange;
    const paragraphs = (_a = body.paragraphs) != null ? _a : [];
    const prevParagraph = paragraphs.find((p) => p.startIndex >= startOffset);
    if (!prevParagraph) {
      return false;
    }
    const prevParagraphIndex = prevParagraph.startIndex;
    const defaultTextStyle = docMenuStyleService.getDefaultStyle();
    const styleCache = docMenuStyleService.getStyleCache();
    const curTextRun = getTextRunAtPosition(body, endOffset, defaultTextStyle, styleCache);
    const insertBody = {
      dataStream: "\r" /* PARAGRAPH */,
      paragraphs: generateParagraphs(
        "\r" /* PARAGRAPH */,
        prevParagraph,
        horizontalLine
      ),
      textRuns: [{
        st: 0,
        ed: 1,
        ts: {
          ...curTextRun.ts
        }
      }]
    };
    const deleteRange = {
      startOffset,
      endOffset,
      collapsed: startOffset === endOffset
    };
    const result = await commandService.executeCommand(InsertCommand.id, {
      unitId,
      body: insertBody,
      range: deleteRange,
      segmentId
    });
    if (((_b = prevParagraph.bullet) == null ? void 0 : _b.listType) === "CHECK_LIST_CHECKED" /* CHECK_LIST_CHECKED */) {
      const params2 = {
        index: prevParagraphIndex + 1 - (endOffset - startOffset),
        segmentId,
        textRanges: [{
          startOffset: startOffset + 1,
          endOffset: startOffset + 1
        }]
      };
      const toggleCheckListResult = await commandService.executeCommand(ToggleCheckListCommand.id, params2);
      return Boolean(toggleCheckListResult) && result;
    }
    return result;
  }
};

// ../packages/docs-ui/src/commands/commands/doc-horizontal-line.command.ts
var HorizontalLineCommand = {
  id: "doc.command.horizontal-line",
  type: 0 /* COMMAND */,
  handler: (accessor, _params) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(BreakLineCommand.id, {
      horizontalLine: {
        padding: 5,
        color: {
          rgb: "#CDD0D8"
        },
        width: 1,
        dashStyle: 1 /* SOLID */
      }
    });
  }
};

// ../packages/docs-ui/src/commands/commands/switch-doc-mode.command.ts
var SwitchDocModeCommand = {
  id: "doc.command.switch-mode",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: async (accessor) => {
    var _a, _b, _c, _d, _e;
    const commandService = accessor.get(ICommandService);
    const renderManagerService = accessor.get(IRenderManagerService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (docDataModel == null) {
      return false;
    }
    const unitId = docDataModel.getUnitId();
    const skeleton = (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
    const docSelectionRenderService = (_b = renderManagerService.getRenderById(unitId)) == null ? void 0 : _b.with(DocSelectionRenderService);
    if (skeleton == null || docSelectionRenderService == null) {
      return false;
    }
    const segmentId = docSelectionRenderService == null ? void 0 : docSelectionRenderService.getSegment();
    const segmentPage = docSelectionRenderService == null ? void 0 : docSelectionRenderService.getSegmentPage();
    const oldDocumentFlavor = docDataModel.getSnapshot().documentStyle.documentFlavor;
    const docRanges = docSelectionManagerService.getDocRanges();
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: oldDocumentFlavor === 1 /* TRADITIONAL */ && !!segmentId ? [] : docRanges
      }
    };
    const jsonX = JSONX.getInstance();
    const rawActions = [];
    let action;
    if (oldDocumentFlavor === void 0) {
      action = jsonX.insertOp(["documentStyle", "documentFlavor"], 2 /* MODERN */);
    } else {
      if (oldDocumentFlavor === 2 /* MODERN */) {
        action = jsonX.replaceOp(["documentStyle", "documentFlavor"], oldDocumentFlavor, 1 /* TRADITIONAL */);
      } else {
        action = jsonX.replaceOp(["documentStyle", "documentFlavor"], oldDocumentFlavor, 2 /* MODERN */);
      }
    }
    if (action) {
      rawActions.push(action);
    } else {
      return false;
    }
    if (oldDocumentFlavor !== 2 /* MODERN */) {
      const snapshot = docDataModel.getSnapshot();
      const { drawings = {}, body } = snapshot;
      const customBlocks = (_c = body == null ? void 0 : body.customBlocks) != null ? _c : [];
      for (const drawingId in drawings) {
        const drawing = drawings[drawingId];
        const customBlock = customBlocks.find((block) => block.blockId === drawingId);
        if (customBlock == null) {
          continue;
        }
        const drawingPositionV = drawing.docTransform.positionV;
        const { relativeFrom: prevRelativeFrom, posOffset: prevPosOffset } = drawingPositionV;
        if (prevRelativeFrom === 1 /* PARAGRAPH */) {
          continue;
        }
        const { startIndex } = customBlock;
        const glyph = skeleton.findNodeByCharIndex(startIndex, segmentId, segmentPage);
        const line2 = (_d = glyph == null ? void 0 : glyph.parent) == null ? void 0 : _d.parent;
        const column = line2 == null ? void 0 : line2.parent;
        const paragraphStartLine = column == null ? void 0 : column.lines.find((l) => l.paragraphIndex === (line2 == null ? void 0 : line2.paragraphIndex) && l.paragraphStart);
        const page = (_e = column == null ? void 0 : column.parent) == null ? void 0 : _e.parent;
        if (glyph == null || line2 == null || paragraphStartLine == null || column == null || page == null) {
          continue;
        }
        let delta = 0;
        if (prevRelativeFrom === 2 /* LINE */) {
          delta -= line2.top;
        } else if (prevRelativeFrom === 0 /* PAGE */) {
          delta += page.marginTop;
        }
        delta += paragraphStartLine.top;
        const newPositionV = {
          ...drawingPositionV,
          relativeFrom: 1 /* PARAGRAPH */,
          posOffset: (prevPosOffset != null ? prevPosOffset : 0) - delta
        };
        const updateDrawingAction = jsonX.replaceOp(["drawings", drawingId, "docTransform", "positionV"], drawingPositionV, newPositionV);
        if (updateDrawingAction) {
          rawActions.push(updateDrawingAction);
        }
      }
    }
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/commands/commands/table/doc-table-delete.command.ts
var DocTableDeleteRowsCommand = {
  id: "doc.table.delete-rows",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor) => {
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const activeRectRanges = docSelectionManagerService.getRectRanges();
    const activeTextRange = docSelectionManagerService.getActiveTextRange();
    const rangeInfo = getRangeInfoFromRanges(activeTextRange, activeRectRanges);
    if (rangeInfo == null) {
      return false;
    }
    const { segmentId } = rangeInfo;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const docSkeletonManagerService = getCommandSkeleton(accessor, docDataModel.getUnitId());
    if (docSkeletonManagerService == null) {
      return false;
    }
    const viewModel = docSkeletonManagerService.getViewModel();
    const unitId = docDataModel == null ? void 0 : docDataModel.getUnitId();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const actionParams = getDeleteRowsActionsParams(rangeInfo, viewModel);
    if (actionParams == null) {
      return false;
    }
    const { offset, rowIndexes, len, tableId, cursor, selectWholeTable } = actionParams;
    if (selectWholeTable) {
      return commandService.executeCommand(DocTableDeleteTableCommand.id);
    }
    const rawActions = [];
    const textRanges = [{
      startOffset: cursor,
      endOffset: cursor,
      collapsed: true
    }];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    if (offset > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: offset
      });
    }
    textX.push({
      t: "d" /* DELETE */,
      len
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    for (const index of rowIndexes.reverse()) {
      const action = jsonX.removeOp(["tableSource", tableId, "tableRows", index]);
      rawActions.push(action);
    }
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var DocTableDeleteColumnsCommand = {
  id: "doc.table.delete-columns",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor) => {
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const activeRectRanges = docSelectionManagerService.getRectRanges();
    const activeTextRange = docSelectionManagerService.getActiveTextRange();
    const rangeInfo = getRangeInfoFromRanges(activeTextRange, activeRectRanges);
    if (rangeInfo == null) {
      return false;
    }
    const { segmentId } = rangeInfo;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const docSkeletonManagerService = getCommandSkeleton(accessor, docDataModel.getUnitId());
    if (docSkeletonManagerService == null) {
      return false;
    }
    const viewModel = docSkeletonManagerService.getViewModel();
    const unitId = docDataModel == null ? void 0 : docDataModel.getUnitId();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const actionParams = getDeleteColumnsActionParams(rangeInfo, viewModel);
    if (actionParams == null) {
      return false;
    }
    const { offsets, columnIndexes, tableId, cursor, rowCount, selectWholeTable } = actionParams;
    if (selectWholeTable) {
      return commandService.executeCommand(DocTableDeleteTableCommand.id);
    }
    const rawActions = [];
    const textRanges = [{
      startOffset: cursor,
      endOffset: cursor,
      collapsed: true
    }];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    for (const offset of offsets) {
      const { retain, delete: deleteLen } = offset;
      if (retain > 0) {
        textX.push({
          t: "r" /* RETAIN */,
          len: retain
        });
      }
      textX.push({
        t: "d" /* DELETE */,
        len: deleteLen
      });
    }
    const path = getRichTextEditPath2(docDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    columnIndexes.reverse();
    for (let i = 0; i < rowCount; i++) {
      for (const index of columnIndexes) {
        const action = jsonX.removeOp(["tableSource", tableId, "tableRows", i, "tableCells", index]);
        rawActions.push(action);
      }
    }
    for (const index of columnIndexes) {
      const action = jsonX.removeOp(["tableSource", tableId, "tableColumns", index]);
      rawActions.push(action);
    }
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var DocTableDeleteTableCommand = {
  id: "doc.table.delete-table",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor) => {
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const activeRectRanges = docSelectionManagerService.getRectRanges();
    const activeTextRange = docSelectionManagerService.getActiveTextRange();
    const rangeInfo = getRangeInfoFromRanges(activeTextRange, activeRectRanges);
    if (rangeInfo == null) {
      return false;
    }
    const { segmentId } = rangeInfo;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const docSkeletonManagerService = getCommandSkeleton(accessor, docDataModel.getUnitId());
    if (docSkeletonManagerService == null) {
      return false;
    }
    const viewModel = docSkeletonManagerService.getViewModel();
    const unitId = docDataModel == null ? void 0 : docDataModel.getUnitId();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const actionParams = getDeleteTableActionParams(rangeInfo, viewModel);
    if (actionParams == null) {
      return false;
    }
    const { offset, len, tableId, cursor } = actionParams;
    const rawActions = [];
    const textRanges = [{
      startOffset: cursor,
      endOffset: cursor,
      collapsed: true
    }];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    if (offset > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: offset
      });
    }
    textX.push({
      t: "d" /* DELETE */,
      len
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    const action = jsonX.removeOp(["tableSource", tableId]);
    rawActions.push(action);
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/commands/commands/table/doc-table-insert.command.ts
var DocTableInsertRowCommandId = "doc.command.table-insert-row";
var DocTableInsertColumnCommandId = "doc.command.table-insert-column";
var DocTableInsertRowAboveCommandId = "doc.command.table-insert-row-above";
var DocTableInsertRowBellowCommandId = "doc.command.table-insert-row-bellow";
var DocTableInsertColumnLeftCommandId = "doc.command.table-insert-column-left";
var DocTableInsertColumnRightCommandId = "doc.command.table-insert-column-right";
var DocTableInsertRowAboveCommand = {
  id: DocTableInsertRowAboveCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(DocTableInsertRowCommandId, { position: 0 /* ABOVE */ });
  }
};
var DocTableInsertRowBellowCommand = {
  id: DocTableInsertRowBellowCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(DocTableInsertRowCommandId, { position: 1 /* BELLOW */ });
  }
};
var DocTableInsertColumnLeftCommand = {
  id: DocTableInsertColumnLeftCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(DocTableInsertColumnCommandId, { position: 0 /* LEFT */ });
  }
};
var DocTableInsertColumnRightCommand = {
  id: DocTableInsertColumnRightCommandId,
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(DocTableInsertColumnCommandId, { position: 1 /* RIGHT */ });
  }
};
var DocTableInsertRowCommand = {
  id: DocTableInsertRowCommandId,
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    const { position } = params;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const activeRectRanges = docSelectionManagerService.getRectRanges();
    const activeTextRange = docSelectionManagerService.getActiveTextRange();
    const rangeInfo = getRangeInfoFromRanges(activeTextRange, activeRectRanges);
    if (rangeInfo == null) {
      return false;
    }
    const { segmentId } = rangeInfo;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const docSkeletonManagerService = getCommandSkeleton(accessor, docDataModel.getUnitId());
    if (docSkeletonManagerService == null) {
      return false;
    }
    const viewModel = docSkeletonManagerService.getViewModel();
    const unitId = docDataModel == null ? void 0 : docDataModel.getUnitId();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const actionParams = getInsertRowActionsParams(rangeInfo, position, viewModel);
    if (actionParams == null) {
      return false;
    }
    const { offset, colCount, tableId, insertRowIndex } = actionParams;
    const rawActions = [];
    const cursor = offset + 2;
    const textRanges = [{
      startOffset: cursor,
      endOffset: cursor,
      collapsed: true
    }];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    if (offset > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: offset
      });
    }
    const insertBody = getInsertRowBody(colCount);
    textX.push({
      t: "i" /* INSERT */,
      body: insertBody,
      len: insertBody.dataStream.length
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    const insertRow = getEmptyTableRow(colCount);
    const insertTableSource = jsonX.insertOp(["tableSource", tableId, "tableRows", insertRowIndex], insertRow);
    rawActions.push(insertTableSource);
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};
var DocTableInsertColumnCommand = {
  id: DocTableInsertColumnCommandId,
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a, _b, _c;
    const { position } = params;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const activeRectRanges = docSelectionManagerService.getRectRanges();
    const activeTextRange = docSelectionManagerService.getActiveTextRange();
    const rangeInfo = getRangeInfoFromRanges(activeTextRange, activeRectRanges);
    if (rangeInfo == null) {
      return false;
    }
    const { segmentId } = rangeInfo;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const docSkeletonManagerService = getCommandSkeleton(accessor, docDataModel.getUnitId());
    if (docSkeletonManagerService == null) {
      return false;
    }
    const viewModel = docSkeletonManagerService.getViewModel();
    const unitId = docDataModel == null ? void 0 : docDataModel.getUnitId();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const actionParams = getInsertColumnActionsParams(rangeInfo, position, viewModel);
    if (actionParams == null) {
      return false;
    }
    const { offsets, columnIndex, tableId, rowCount } = actionParams;
    const rawActions = [];
    const cursor = offsets[0] + 1;
    const textRanges = [{
      startOffset: cursor,
      endOffset: cursor,
      collapsed: true
    }];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    for (const offset of offsets) {
      textX.push({
        t: "r" /* RETAIN */,
        len: offset
      });
      const insertBody = getInsertColumnBody();
      textX.push({
        t: "i" /* INSERT */,
        body: insertBody,
        len: insertBody.dataStream.length
      });
    }
    const path = getRichTextEditPath2(docDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    for (let i = 0; i < rowCount; i++) {
      const insertCell = getEmptyTableCell();
      const insertTableSource = jsonX.insertOp(["tableSource", tableId, "tableRows", i, "tableCells", columnIndex], insertCell);
      rawActions.push(insertTableSource);
    }
    const snapshot = docDataModel.getSnapshot();
    const documentStyle = snapshot.documentStyle;
    const { marginLeft = 0, marginRight = 0 } = documentStyle;
    const pageWidth = ((_b = (_a = documentStyle.pageSize) == null ? void 0 : _a.width) != null ? _b : 800) - marginLeft - marginRight;
    const tableColumns = (_c = snapshot == null ? void 0 : snapshot.tableSource) == null ? void 0 : _c[tableId].tableColumns;
    const { newColWidth, widths } = getColumnWidths(pageWidth, tableColumns, columnIndex);
    for (let i = 0; i < widths.length; i++) {
      const action = jsonX.replaceOp(["tableSource", tableId, "tableColumns", i, "size", "width", "v"], tableColumns[i].size.width.v, widths[i]);
      rawActions.push(action);
    }
    const insertCol = getTableColumn(newColWidth);
    const insertTableColumn = jsonX.insertOp(["tableSource", tableId, "tableColumns", columnIndex], insertCol);
    rawActions.push(insertTableColumn);
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/views/table/create/component-name.ts
var COMPONENT_DOC_CREATE_TABLE_CONFIRM = "COMPONENT_DOC_CREATE_TABLE_CONFIRM";

// ../packages/docs-ui/src/commands/commands/table/doc-table-create.command.ts
var CreateDocTableCommandId = "doc.command.create-table";
var CreateDocTableCommand = {
  id: CreateDocTableCommandId,
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a, _b, _c, _d, _e;
    const { rowCount, colCount } = params;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docMenuStyleService = accessor.get(DocMenuStyleService);
    const activeRange = docSelectionManagerService.getActiveTextRange();
    if (activeRange == null) {
      return false;
    }
    const { segmentId, segmentPage } = activeRange;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    const body = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (docDataModel == null || body == null) {
      return false;
    }
    const unitId = docDataModel.getUnitId();
    const docSkeletonManagerService = getCommandSkeleton(accessor, unitId);
    const skeleton = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getSkeleton();
    if (skeleton == null) {
      return false;
    }
    const { startOffset } = activeRange;
    const paragraphs = (_a = body.paragraphs) != null ? _a : [];
    const prevParagraph = paragraphs.find((p) => p.startIndex >= startOffset);
    const curGlyph = skeleton.findNodeByCharIndex(startOffset, segmentId, segmentPage);
    if (curGlyph == null) {
      return false;
    }
    const needCreateParagraph = true;
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    const rawActions = [];
    const cursor = startOffset + (needCreateParagraph ? 4 : 3);
    const textRanges = [{
      startOffset: cursor,
      endOffset: cursor,
      collapsed: true
    }];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    if (startOffset > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: startOffset
      });
    }
    if (needCreateParagraph) {
      textX.push({
        t: "i" /* INSERT */,
        body: {
          dataStream: "\r" /* PARAGRAPH */,
          paragraphs: generateParagraphs("\r" /* PARAGRAPH */, prevParagraph)
        },
        len: 1
      });
    }
    const defaultTextStyle = docMenuStyleService.getDefaultStyle();
    const styleCache = docMenuStyleService.getStyleCache();
    const curTextRun = getTextRunAtPosition(
      body,
      startOffset,
      defaultTextStyle,
      styleCache
    );
    const { dataStream: tableDataStream, paragraphs: tableParagraphs, sectionBreaks } = genEmptyTable(rowCount, colCount);
    const page = (_e = (_d = (_c = (_b = curGlyph.parent) == null ? void 0 : _b.parent) == null ? void 0 : _c.parent) == null ? void 0 : _d.parent) == null ? void 0 : _e.parent;
    if (page == null) {
      return false;
    }
    const { pageWidth, marginLeft, marginRight } = page;
    const tableSource = genTableSource(rowCount, colCount, pageWidth - marginLeft - marginRight);
    textX.push({
      t: "i" /* INSERT */,
      body: {
        dataStream: tableDataStream,
        paragraphs: tableParagraphs,
        sectionBreaks,
        textRuns: [{
          ...curTextRun,
          st: 0,
          ed: tableDataStream.length
        }],
        tables: [
          {
            startIndex: 0,
            endIndex: tableDataStream.length,
            tableId: tableSource.tableId
          }
        ]
      },
      len: tableDataStream.length
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    rawActions.push(jsonX.editOp(textX.serialize(), path));
    const insertTableSource = jsonX.insertOp(["tableSource", tableSource.tableId], tableSource);
    rawActions.push(insertTableSource);
    doMutation.params.actions = rawActions.reduce((acc, cur) => {
      return JSONX.compose(acc, cur);
    }, null);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/commands/operations/doc-create-table.operation.ts
var COMPONENT_DOC_CREATE_TABLE_CONFIRM_ID = "doc.component.create-table-confirm";
var DocCreateTableOperation = {
  id: "doc.operation.create-table",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const localeService = accessor.get(LocaleService);
    const confirmService = accessor.get(IConfirmService);
    const commandService = accessor.get(ICommandService);
    const tableCreateParams = {
      rowCount: 3,
      colCount: 5
    };
    const handleRowColChange = (rowCount, colCount) => {
      tableCreateParams.rowCount = rowCount;
      tableCreateParams.colCount = colCount;
    };
    await confirmService.open({
      id: COMPONENT_DOC_CREATE_TABLE_CONFIRM_ID,
      children: {
        label: {
          name: COMPONENT_DOC_CREATE_TABLE_CONFIRM,
          props: {
            handleRowColChange,
            tableCreateParams
          }
        }
      },
      width: 400,
      title: { title: localeService.t("toolbar.table.insert") },
      onConfirm: () => {
        commandService.executeCommand(CreateDocTableCommand.id, tableCreateParams);
        confirmService.close(COMPONENT_DOC_CREATE_TABLE_CONFIRM_ID);
      },
      onClose: () => {
        confirmService.close(COMPONENT_DOC_CREATE_TABLE_CONFIRM_ID);
      }
    });
    return true;
  }
};

// ../packages/docs-ui/src/views/paragraph-setting/index.tsx
var import_react43 = __toESM(require_react());

// ../packages/docs-ui/src/commands/commands/doc-paragraph-setting.command.ts
var DocParagraphSettingCommand = {
  id: "doc-paragraph-setting.command",
  type: 0 /* COMMAND */,
  handler: async (accessor, config) => {
    var _a, _b, _c;
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const docRanges = docSelectionManagerService.getDocRanges();
    if (!docDataModel || docRanges.length === 0 || !config) {
      return false;
    }
    const segmentId = docRanges[0].segmentId;
    const unitId = docDataModel.getUnitId();
    const allParagraphs = (_b = (_a = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a.paragraphs) != null ? _b : [];
    const paragraphs = (_c = getParagraphsInRanges(docRanges, allParagraphs)) != null ? _c : [];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges: docRanges
      }
    };
    const memoryCursor = new MemoryCursor();
    memoryCursor.reset();
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    for (const paragraph of paragraphs) {
      const { startIndex } = paragraph;
      textX.push({
        t: "r" /* RETAIN */,
        len: startIndex - memoryCursor.cursor
      });
      const paragraphStyle = {
        ...paragraph.paragraphStyle,
        ...config.paragraph
      };
      textX.push({
        t: "r" /* RETAIN */,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              ...paragraph,
              paragraphStyle,
              startIndex: 0
            }
          ]
        },
        coverType: 1 /* REPLACE */
      });
      memoryCursor.moveCursorTo(startIndex + 1);
    }
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    return !!result;
  }
};

// ../packages/docs-ui/src/views/paragraph-setting/Setting.tsx
var import_react42 = __toESM(require_react());

// ../packages/docs-ui/src/views/paragraph-setting/hook/utils.ts
var import_react41 = __toESM(require_react());
var useDocRanges = () => {
  const docSelectionManagerService = useDependency(DocSelectionManagerService);
  const docParagraphSettingController = useDependency(DocParagraphSettingController);
  const docRanges = (0, import_react41.useMemo)(() => docSelectionManagerService.getDocRanges(), []);
  (0, import_react41.useEffect)(() => {
    if (!docRanges.length) {
      docParagraphSettingController.closePanel();
    }
  }, [docRanges]);
  return docRanges;
};
var useCurrentParagraph = () => {
  var _a, _b, _c;
  const univerInstanceService = useDependency(IUniverInstanceService);
  const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
  const docRanges = useDocRanges();
  if (!docDataModel || docRanges.length === 0) {
    return [];
  }
  const segmentId = docRanges[0].segmentId;
  const paragraphs = (_b = (_a = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a.paragraphs) != null ? _b : [];
  const currentParagraphs = (_c = getParagraphsInRanges(docRanges, paragraphs)) != null ? _c : [];
  return currentParagraphs;
};
var useFirstParagraphHorizontalAlign = (paragraph, defaultValue) => {
  const commandService = useDependency(ICommandService);
  const [horizontalAlign, _horizontalAlignSet] = (0, import_react41.useState)(() => {
    var _a, _b;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return defaultValue;
    }
    return String((_b = (_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.horizontalAlign) != null ? _b : defaultValue);
  });
  const horizontalAlignSet = (v) => {
    _horizontalAlignSet(v);
    return commandService.executeCommand(DocParagraphSettingCommand.id, {
      paragraph: { horizontalAlign: Number(v) }
    });
  };
  return [horizontalAlign, horizontalAlignSet];
};
var useFirstParagraphIndentStart = (paragraph) => {
  const commandService = useDependency(ICommandService);
  const [indentStart, _indentStartSet] = (0, import_react41.useState)(() => {
    var _a;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 0;
    }
    return getNumberUnitValue((_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.indentStart, 0);
  });
  const indentStartSet = (v) => {
    _indentStartSet(v);
    return commandService.executeCommand(DocParagraphSettingCommand.id, {
      paragraph: { indentStart: { v } }
    });
  };
  return [indentStart, indentStartSet];
};
var useFirstParagraphIndentEnd = (paragraph) => {
  const commandService = useDependency(ICommandService);
  const [indentEnd, _indentEndSet] = (0, import_react41.useState)(() => {
    var _a;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 0;
    }
    return getNumberUnitValue((_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.indentEnd, 0);
  });
  const indentEndSet = (v) => {
    _indentEndSet(v);
    return commandService.executeCommand(DocParagraphSettingCommand.id, {
      paragraph: { indentEnd: { v } }
    });
  };
  return [indentEnd, indentEndSet];
};
var useFirstParagraphIndentFirstLine = (paragraph) => {
  const commandService = useDependency(ICommandService);
  const [indentFirstLine, _indentFirstLineSet] = (0, import_react41.useState)(() => {
    var _a;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 0;
    }
    return getNumberUnitValue((_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.indentFirstLine, 0);
  });
  const indentFirstLineSet = (v) => {
    _indentFirstLineSet(v);
    return commandService.executeCommand(DocParagraphSettingCommand.id, {
      paragraph: { indentFirstLine: { v } }
    });
  };
  return [indentFirstLine, indentFirstLineSet];
};
var useFirstParagraphIndentHanging = (paragraph) => {
  const commandService = useDependency(ICommandService);
  const [hanging, _hangingSet] = (0, import_react41.useState)(() => {
    var _a;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 0;
    }
    return getNumberUnitValue((_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.hanging, 0);
  });
  const hangingSet = (v) => {
    _hangingSet(v);
    return commandService.executeCommand(DocParagraphSettingCommand.id, {
      paragraph: { hanging: { v } }
    });
  };
  return [hanging, hangingSet];
};
var useFirstParagraphIndentSpaceAbove = (paragraph) => {
  const commandService = useDependency(ICommandService);
  const [spaceAbove, _spaceAboveSet] = (0, import_react41.useState)(() => {
    var _a;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 0;
    }
    return getNumberUnitValue((_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.spaceAbove, 0);
  });
  const spaceAboveSet = (v) => {
    _spaceAboveSet(v);
    return commandService.executeCommand(DocParagraphSettingCommand.id, {
      paragraph: { spaceAbove: { v } }
    });
  };
  return [spaceAbove, spaceAboveSet];
};
var useFirstParagraphSpaceBelow = (paragraph) => {
  const commandService = useDependency(ICommandService);
  const [spaceBelow, _spaceBelowSet] = (0, import_react41.useState)(() => {
    var _a;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 0;
    }
    return getNumberUnitValue((_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.spaceBelow, 0);
  });
  const spaceBelowSet = (v) => {
    _spaceBelowSet(v);
    return commandService.executeCommand(DocParagraphSettingCommand.id, {
      paragraph: { spaceBelow: { v } }
    });
  };
  return [spaceBelow, spaceBelowSet];
};
var useFirstParagraphLineSpacing = (paragraph) => {
  const commandService = useDependency(ICommandService);
  const renderManagerService = useDependency(IRenderManagerService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const skeleton = (0, import_react41.useMemo)(() => {
    var _a;
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    if (!docDataModel) {
      return void 0;
    }
    return (_a = renderManagerService.getRenderById(docDataModel == null ? void 0 : docDataModel.getUnitId())) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
  }, []);
  const stateChange$ = (0, import_react41.useMemo)(() => new BehaviorSubject({}), []);
  const [lineSpacing, _lineSpacingSet] = (0, import_react41.useState)(() => {
    var _a, _b;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 1;
    }
    return (_b = (_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.lineSpacing) != null ? _b : 1;
  });
  const lineSpacingCache = (0, import_react41.useRef)(lineSpacing);
  const [spacingRule, _spacingRuleSet] = (0, import_react41.useState)(() => {
    var _a, _b;
    const firstParagraph = paragraph[0];
    if (!firstParagraph) {
      return 0 /* AUTO */;
    }
    return (_b = (_a = firstParagraph.paragraphStyle) == null ? void 0 : _a.spacingRule) != null ? _b : 0 /* AUTO */;
  });
  const lineSpacingSet = async (v) => {
    _lineSpacingSet(v);
    stateChange$.next({ lineSpacing: v, spacingRule });
  };
  const spacingRuleSet = async (v) => {
    if (v !== spacingRule) {
      let cache = lineSpacingCache.current;
      if (v === 1 /* AT_LEAST */) {
        const glyphNode = skeleton == null ? void 0 : skeleton.findNodeByCharIndex(paragraph[0].startIndex);
        const divideNode = glyphNode == null ? void 0 : glyphNode.parent;
        const lineNode = divideNode == null ? void 0 : divideNode.parent;
        if ((lineNode == null ? void 0 : lineNode.contentHeight) !== void 0) {
          cache = Math.max(lineNode.contentHeight, cache);
        }
      } else {
        if (cache > 5) {
          cache = 2;
        }
      }
      lineSpacingCache.current = lineSpacing;
      lineSpacingSet(cache);
      _spacingRuleSet(v);
      stateChange$.next({ spacingRule: v });
    }
  };
  (0, import_react41.useEffect)(() => {
    const dispose = stateChange$.pipe(
      filter((obj) => !!Object.keys(obj).length),
      bufferTime(16),
      filter((list) => !!list.length),
      map((list) => {
        return list.reduce((a, b) => {
          Object.keys(b).forEach((key) => {
            a[key] = b[key];
          });
          return a;
        }, {});
      })
    ).subscribe((v) => {
      return commandService.executeCommand(DocParagraphSettingCommand.id, {
        paragraph: { ...v }
      });
    });
    return () => dispose.unsubscribe();
  }, []);
  return {
    lineSpacing: [lineSpacing, lineSpacingSet],
    spacingRule: [spacingRule, spacingRuleSet]
  };
};

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/docs-ui/src/views/paragraph-setting/index.module.less
var index_module_default13 = {
  "paragraphSettingIconList": "univer-paragraph-setting-icon-list",
  "paragraphSettingIconListItem": "univer-paragraph-setting-icon-list-item",
  "paragraphSettingIconListActive": "univer-paragraph-setting-icon-list-active",
  "paragraphSettingTitle": "univer-paragraph-setting-title",
  "paragraphSettingLabel": "univer-paragraph-setting-label",
  "paragraphSettingMtBase": "univer-paragraph-setting-mt-base",
  "paragraphSettingFlexCol": "univer-paragraph-setting-flex-col",
  "paragraphSettingSpaceLine": "univer-paragraph-setting-space-line"
};

// ../packages/docs-ui/src/views/paragraph-setting/Setting.tsx
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var AutoFocusInputNumber = (props) => {
  const { value, onChange, className = "", min: min2 = 0, max: max2 = 100, step = 1 } = props;
  const ref = (0, import_react42.useRef)(null);
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
    InputNumber,
    {
      step,
      ref,
      min: min2,
      max: max2,
      value,
      onChange: (v) => {
        onChange(v != null ? v : 0).finally(() => {
          setTimeout(() => {
            var _a;
            (_a = ref.current) == null ? void 0 : _a.focus();
          }, 30);
        });
      },
      className
    }
  );
};
function ParagraphSetting() {
  const localeService = useDependency(LocaleService);
  const alignmentOptions = (0, import_react42.useMemo)(() => [
    { label: localeService.t("toolbar.alignLeft"), value: String(1 /* LEFT */), icon: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(left_justifying_single_default, {}) },
    { label: localeService.t("toolbar.alignCenter"), value: String(2 /* CENTER */), icon: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(horizontally_single_default, {}) },
    { label: localeService.t("toolbar.alignRight"), value: String(3 /* RIGHT */), icon: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(right_justifying_single_default, {}) },
    { label: localeService.t("toolbar.alignJustify"), value: String(4 /* JUSTIFIED */), icon: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(align_text_both_single_default, {}) }
  ], []);
  const currentParagraph = useCurrentParagraph();
  const [horizontalAlignValue, horizontalAlignSet] = useFirstParagraphHorizontalAlign(currentParagraph, alignmentOptions[0].value);
  const [indentStart, indentStartSet] = useFirstParagraphIndentStart(currentParagraph);
  const [indentEnd, indentEndSet] = useFirstParagraphIndentEnd(currentParagraph);
  const [indentFirstLine, indentFirstLineSet] = useFirstParagraphIndentFirstLine(currentParagraph);
  const [hanging, hangingSet] = useFirstParagraphIndentHanging(currentParagraph);
  const [spaceAbove, spaceAboveSet] = useFirstParagraphIndentSpaceAbove(currentParagraph);
  const [spaceBelow, spaceBelowSet] = useFirstParagraphSpaceBelow(currentParagraph);
  const { lineSpacing: [lineSpacing, lineSpacingSet], spacingRule: [spacingRule, spacingRuleSet] } = useFirstParagraphLineSpacing(currentParagraph);
  const lineSpaceConfig = (0, import_react42.useMemo)(() => {
    if (spacingRule === 0 /* AUTO */) {
      return { min: 1, max: 5, step: lineSpacing < 2 ? 0.5 : 1 };
    }
    return { min: 1, max: 100 };
  }, [spacingRule, lineSpacing]);
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSetting, children: [
    /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: index_module_default13.paragraphSettingTitle, children: localeService.t("doc.paragraphSetting.alignment") }),
    /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      "div",
      {
        className: `
                  ${index_module_default13.paragraphSettingIconList}
                  ${index_module_default13.paragraphSettingMtBase}
                `,
        children: alignmentOptions.map((item) => {
          return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(Tooltip, { title: item.label, placement: "bottom", children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
            "span",
            {
              className: clsx(index_module_default13.paragraphSettingIconListItem, { [index_module_default13.paragraphSettingIconListActive]: horizontalAlignValue === item.value }),
              onClick: () => horizontalAlignSet(item.value),
              children: item.icon
            }
          ) }, item.value);
        })
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: index_module_default13.paragraphSettingTitle, children: localeService.t("doc.paragraphSetting.indentation") }),
    /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingFlexCol, children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingLabel, children: [
          localeService.t("doc.paragraphSetting.left"),
          "(px)"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(AutoFocusInputNumber, { className: index_module_default13.paragraphSettingMtBase, value: indentStart, onChange: (v) => indentStartSet(v != null ? v : 0) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingFlexCol, children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingLabel, children: [
          localeService.t("doc.paragraphSetting.right"),
          "(px)"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(AutoFocusInputNumber, { className: index_module_default13.paragraphSettingMtBase, value: indentEnd, onChange: (v) => indentEndSet(v != null ? v : 0) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingFlexCol, children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingLabel, children: [
          localeService.t("doc.paragraphSetting.firstLine"),
          "(px)"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(AutoFocusInputNumber, { className: index_module_default13.paragraphSettingMtBase, value: indentFirstLine, onChange: (v) => indentFirstLineSet(v != null ? v : 0) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingFlexCol, children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingLabel, children: [
          localeService.t("doc.paragraphSetting.hanging"),
          "(px)"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(AutoFocusInputNumber, { className: index_module_default13.paragraphSettingMtBase, value: hanging, onChange: (v) => hangingSet(v != null ? v : 0) })
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: index_module_default13.paragraphSettingTitle, children: localeService.t("doc.paragraphSetting.spacing") }),
    /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingFlexCol, children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingLabel, children: [
          localeService.t("doc.paragraphSetting.before"),
          "(px)"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(AutoFocusInputNumber, { className: index_module_default13.paragraphSettingMtBase, value: spaceAbove, onChange: (v) => spaceAboveSet(v != null ? v : 0) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingFlexCol, children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingLabel, children: [
          localeService.t("doc.paragraphSetting.after"),
          "(px)"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(AutoFocusInputNumber, { className: index_module_default13.paragraphSettingMtBase, value: spaceBelow, onChange: (v) => spaceBelowSet(v != null ? v : 0) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)("div", { className: index_module_default13.paragraphSettingFlexCol, children: [
        /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: index_module_default13.paragraphSettingLabel, children: localeService.t("doc.paragraphSetting.lineSpace") }),
        /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(
          "div",
          {
            className: `
                          ${index_module_default13.paragraphSettingMtBase}
                          ${index_module_default13.paragraphSettingSpaceLine}
                        `,
            style: { width: 162 },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
                Select,
                {
                  value: `${spacingRule}`,
                  options: [
                    { label: localeService.t("doc.paragraphSetting.multiSpace"), value: `${0 /* AUTO */}` },
                    { label: localeService.t("doc.paragraphSetting.fixedValue"), value: `${1 /* AT_LEAST */}` }
                  ],
                  onChange: (v) => spacingRuleSet(Number(v))
                }
              ),
              /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
                AutoFocusInputNumber,
                {
                  ...lineSpaceConfig,
                  value: lineSpacing,
                  onChange: (v) => lineSpacingSet(v != null ? v : 0)
                }
              )
            ]
          }
        )
      ] })
    ] })
  ] });
}

// ../packages/docs-ui/src/views/paragraph-setting/index.tsx
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var isRangesEqual = (oldRanges, ranges) => {
  return ranges.length === oldRanges.length && oldRanges.some((oldRange) => ranges.some((range) => range.startOffset === oldRange.startOffset && range.endOffset === oldRange.endOffset));
};
function ParagraphSettingIndex() {
  const commandService = useDependency(ICommandService);
  const localeService = useDependency(LocaleService);
  const currentLocale = useObservable(localeService.currentLocale$);
  const [key, keySet] = (0, import_react43.useState)("");
  const debounceReset = (0, import_react43.useMemo)(() => {
    return debounce_default(() => keySet(generateRandomId(4)), 300);
  }, []);
  const rangeRef = (0, import_react43.useRef)([]);
  (0, import_react43.useEffect)(() => {
    const dispose = commandService.onCommandExecuted((info) => {
      if (SetTextSelectionsOperation.id === info.id) {
        const ranges = info.params.ranges;
        if (!isRangesEqual(ranges, rangeRef.current)) {
          keySet(generateRandomId(4));
        }
        rangeRef.current = ranges;
      }
      if (RichTextEditingMutation.id === info.id) {
        const params = info.params;
        const trigger = params.trigger;
        if (trigger !== DocParagraphSettingCommand.id) {
          debounceReset();
        }
      }
    });
    return () => dispose.dispose();
  }, [debounceReset]);
  (0, import_react43.useEffect)(() => {
    keySet(generateRandomId(4));
  }, [currentLocale]);
  (0, import_react43.useEffect)(() => () => debounceReset.cancel(), [debounceReset]);
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(ParagraphSetting, {}, key);
}

// ../packages/docs-ui/src/controllers/doc-paragraph-setting.controller.ts
var paragraphSettingIndexKey = "doc_ui_paragraph-setting-panel";
var DocParagraphSettingController = class extends Disposable {
  constructor(_commandService, _componentManager, _sidebarService) {
    super();
    this._commandService = _commandService;
    this._componentManager = _componentManager;
    this._sidebarService = _sidebarService;
    __publicField(this, "_id");
    this._init();
  }
  _init() {
    this.disposeWithMe(this._componentManager.register(paragraphSettingIndexKey, ParagraphSettingIndex));
  }
  openPanel() {
    const props = {
      header: { title: "doc.slider.paragraphSetting" },
      id: this._id,
      children: {
        label: paragraphSettingIndexKey
      },
      width: 300
    };
    this._sidebarService.open(props);
  }
  closePanel() {
    this._sidebarService.close(this._id);
  }
};
DocParagraphSettingController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, Inject(ComponentManager)),
  __decorateParam(2, Inject(ISidebarService))
], DocParagraphSettingController);

// ../packages/docs-ui/src/commands/operations/doc-paragraph-setting-panel.operation.ts
var DocParagraphSettingPanelOperation = {
  id: "sidebar.operation.doc-paragraph-setting-panel",
  type: 1 /* OPERATION */,
  handler: (accessor) => {
    const docParagraphSettingController = accessor.get(DocParagraphSettingController);
    docParagraphSettingController.openPanel();
    return true;
  }
};

// ../packages/docs-ui/src/controllers/menu/context-menu.ts
var getDisableOnCollapsedObservable = (accessor) => {
  const docSelectionManagerService = accessor.get(DocSelectionManagerService);
  return new Observable((subscriber) => {
    const observable = docSelectionManagerService.textSelection$.subscribe(() => {
      const ranges = docSelectionManagerService.getDocRanges();
      const legal = ranges.some((range) => range.collapsed === false || range.rangeType === "RECT" /* RECT */);
      if (legal) {
        subscriber.next(false);
      } else {
        subscriber.next(true);
      }
    });
    return () => observable.unsubscribe();
  });
};
function inSameTable(rectRanges) {
  if (rectRanges.length < 2) {
    return true;
  }
  const tableIds = rectRanges.map((rectRange) => rectRange.tableId);
  return tableIds.every((tableId) => tableId === tableIds[0]);
}
function notInTableSubscriber(subscriber, docSelectionManagerService, univerInstanceService) {
  var _a;
  const rectRanges = docSelectionManagerService.getRectRanges();
  const activeRange = docSelectionManagerService.getActiveTextRange();
  if (rectRanges && rectRanges.length && inSameTable(rectRanges) && activeRange == null) {
    subscriber.next(false);
    return;
  }
  if (activeRange && (rectRanges == null || rectRanges.length === 0)) {
    const { segmentId, startOffset, endOffset } = activeRange;
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    const tables = (_a = docDataModel == null ? void 0 : docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a.tables;
    if (tables && tables.length) {
      if (tables.some((table2) => {
        const { startIndex, endIndex } = table2;
        return startOffset > startIndex && startOffset < endIndex || endOffset > startIndex && endOffset < endIndex;
      })) {
        subscriber.next(false);
        return;
      }
    }
  }
  subscriber.next(true);
}
var getDisableWhenSelectionNotInTableObservable = (accessor) => {
  const docSelectionManagerService = accessor.get(DocSelectionManagerService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  return new Observable((subscriber) => {
    const observable = docSelectionManagerService.textSelection$.subscribe(() => {
      notInTableSubscriber(subscriber, docSelectionManagerService, univerInstanceService);
    });
    notInTableSubscriber(subscriber, docSelectionManagerService, univerInstanceService);
    return () => observable.unsubscribe();
  });
};
var CopyMenuFactory = (accessor) => {
  return {
    id: DocCopyCommand.name,
    commandId: DocCopyCommand.id,
    type: 0 /* BUTTON */,
    icon: "Copy",
    title: "rightClick.copy",
    disabled$: getDisableOnCollapsedObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
};
var ParagraphSettingMenuFactory = (accessor) => {
  return {
    id: DocParagraphSettingPanelOperation.id,
    type: 0 /* BUTTON */,
    icon: "MenuSingle24",
    title: "doc.menu.paragraphSetting",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
};
var CutMenuFactory = (accessor) => {
  return {
    id: DocCutCommand.id,
    type: 0 /* BUTTON */,
    icon: "Copy",
    title: "rightClick.cut",
    disabled$: getDisableOnCollapsedObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
};
var PasteMenuFactory = (accessor) => {
  return {
    id: DocPasteCommand.id,
    type: 0 /* BUTTON */,
    icon: "PasteSpecial",
    title: "rightClick.paste",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
};
var DeleteMenuFactory = (accessor) => {
  return {
    id: DeleteLeftCommand.id,
    type: 0 /* BUTTON */,
    icon: "PasteSpecial",
    title: "rightClick.delete",
    disabled$: getDisableOnCollapsedObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
};
var TABLE_INSERT_MENU_ID = "doc.menu.table-insert";
function TableInsertMenuItemFactory(accessor) {
  return {
    id: TABLE_INSERT_MENU_ID,
    type: 3 /* SUBITEMS */,
    title: "table.insert",
    icon: "Insert",
    hidden$: combineLatest(getMenuHiddenObservable(accessor, O.UNIVER_DOC), getDisableWhenSelectionNotInTableObservable(accessor), (one, two) => {
      return one || two;
    })
  };
}
function InsertRowBeforeMenuItemFactory(accessor) {
  return {
    id: DocTableInsertRowAboveCommand.id,
    type: 0 /* BUTTON */,
    title: "table.insertRowAbove",
    icon: "InsertRowAbove",
    disabled$: getDisableWhenSelectionNotInTableObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function InsertRowAfterMenuItemFactory(accessor) {
  return {
    id: DocTableInsertRowBellowCommand.id,
    type: 0 /* BUTTON */,
    title: "table.insertRowBelow",
    icon: "InsertRowBelow",
    disabled$: getDisableWhenSelectionNotInTableObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function InsertColumnLeftMenuItemFactory(accessor) {
  return {
    id: DocTableInsertColumnLeftCommand.id,
    type: 0 /* BUTTON */,
    title: "table.insertColumnLeft",
    icon: "LeftInsertColumn",
    disabled$: getDisableWhenSelectionNotInTableObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function InsertColumnRightMenuItemFactory(accessor) {
  return {
    id: DocTableInsertColumnRightCommand.id,
    type: 0 /* BUTTON */,
    title: "table.insertColumnRight",
    icon: "RightInsertColumn",
    disabled$: getDisableWhenSelectionNotInTableObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
var TABLE_DELETE_MENU_ID = "doc.menu.table-delete";
function TableDeleteMenuItemFactory(accessor) {
  return {
    id: TABLE_DELETE_MENU_ID,
    type: 3 /* SUBITEMS */,
    title: "table.delete",
    icon: "Reduce",
    hidden$: combineLatest(getMenuHiddenObservable(accessor, O.UNIVER_DOC), getDisableWhenSelectionNotInTableObservable(accessor), (one, two) => {
      return one || two;
    })
  };
}
function DeleteRowsMenuItemFactory(accessor) {
  return {
    id: DocTableDeleteRowsCommand.id,
    type: 0 /* BUTTON */,
    title: "table.deleteRows",
    icon: "DeleteRow",
    disabled$: getDisableWhenSelectionNotInTableObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function DeleteColumnsMenuItemFactory(accessor) {
  return {
    id: DocTableDeleteColumnsCommand.id,
    type: 0 /* BUTTON */,
    title: "table.deleteColumns",
    icon: "DeleteColumn",
    disabled$: getDisableWhenSelectionNotInTableObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function DeleteTableMenuItemFactory(accessor) {
  return {
    id: DocTableDeleteTableCommand.id,
    type: 0 /* BUTTON */,
    title: "table.deleteTable",
    icon: "GridSingle",
    disabled$: getDisableWhenSelectionNotInTableObservable(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}

// ../packages/docs-ui/src/controllers/menu/menu.ts
function getInsertTableHiddenObservable(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const renderManagerService = accessor.get(IRenderManagerService);
  return new Observable((subscriber) => {
    const subscription = univerInstanceService.focused$.subscribe((unitId) => {
      if (unitId == null) {
        return subscriber.next(true);
      }
      const univerType = univerInstanceService.getUnitType(unitId);
      if (univerType !== O.UNIVER_DOC) {
        return subscriber.next(true);
      }
      const currentRender = renderManagerService.getRenderById(unitId);
      if (currentRender == null) {
        return subscriber.next(true);
      }
      const viewModel = currentRender.with(DocSkeletonManagerService).getViewModel();
      viewModel.editAreaChange$.subscribe((editArea) => {
        subscriber.next(editArea === "HEADER" /* HEADER */ || editArea === "FOOTER" /* FOOTER */);
      });
    });
    return () => subscription.unsubscribe();
  });
}
function getHeaderFooterMenuHiddenObservable2(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const commandService = accessor.get(ICommandService);
  return new Observable((subscriber) => {
    const subscription0 = commandService.onCommandExecuted((command) => {
      if (command.id === RichTextEditingMutation.id) {
        const { unitId } = command.params;
        const docDataModel2 = univerInstanceService.getUnit(unitId);
        if (docDataModel2 == null) {
          subscriber.next(true);
          return;
        }
        const { documentStyle } = docDataModel2.getSnapshot();
        subscriber.next((documentStyle == null ? void 0 : documentStyle.documentFlavor) !== 1 /* TRADITIONAL */);
      }
    });
    const subscription = univerInstanceService.focused$.subscribe((unitId) => {
      if (unitId == null) {
        return subscriber.next(true);
      }
      const docDataModel2 = univerInstanceService.getUniverDocInstance(unitId);
      const documentFlavor2 = docDataModel2 == null ? void 0 : docDataModel2.getSnapshot().documentStyle.documentFlavor;
      subscriber.next(documentFlavor2 !== 1 /* TRADITIONAL */);
    });
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (docDataModel == null) {
      return subscriber.next(true);
    }
    const documentFlavor = docDataModel == null ? void 0 : docDataModel.getSnapshot().documentStyle.documentFlavor;
    subscriber.next(documentFlavor !== 1 /* TRADITIONAL */);
    return () => {
      subscription0.dispose();
      subscription.unsubscribe();
    };
  });
}
function getTableDisabledObservable(accessor) {
  const docSelectionManagerService = accessor.get(DocSelectionManagerService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  return new Observable((subscriber) => {
    const subscription = docSelectionManagerService.textSelection$.subscribe((selection) => {
      if (selection == null) {
        subscriber.next(true);
        return;
      }
      const { textRanges } = selection;
      if (textRanges.length !== 1) {
        subscriber.next(true);
        return;
      }
      const textRange = textRanges[0];
      const { collapsed, startNodePosition, startOffset } = textRange;
      if (!collapsed || startOffset == null) {
        subscriber.next(true);
        return;
      }
      const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
      if (docDataModel == null) {
        subscriber.next(true);
        return;
      }
      const docSkeletonManagerService = getCommandSkeleton(accessor, docDataModel.getUnitId());
      if (docSkeletonManagerService == null) {
        subscriber.next(true);
        return;
      }
      const viewModel = docSkeletonManagerService.getViewModel();
      const customRange = viewModel.getCustomRangeRaw(startOffset);
      if (customRange) {
        subscriber.next(true);
        return;
      }
      if (startNodePosition != null) {
        const { path } = startNodePosition;
        if (path.indexOf("cells") !== -1) {
          subscriber.next(true);
          return;
        }
      }
      subscriber.next(false);
    });
    return () => subscription.unsubscribe();
  });
}
function disableMenuWhenNoDocRange(accessor) {
  const docSelectionManagerService = accessor.get(DocSelectionManagerService);
  return new Observable((subscriber) => {
    const subscription = docSelectionManagerService.textSelection$.subscribe((selection) => {
      if (selection == null) {
        subscriber.next(true);
        return;
      }
      const { textRanges, rectRanges } = selection;
      if (textRanges.length === 0 && rectRanges.length === 0) {
        subscriber.next(true);
        return;
      }
      subscriber.next(false);
    });
    return () => subscription.unsubscribe();
  });
}
function BoldMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatBoldCommand.id,
    type: 0 /* BUTTON */,
    icon: "BoldSingle",
    title: "Set bold",
    tooltip: "toolbar.bold",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(false);
            return;
          }
          const bl = (_a = textRun.ts) == null ? void 0 : _a.bl;
          subscriber.next(bl === 1 /* TRUE */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function ItalicMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatItalicCommand.id,
    type: 0 /* BUTTON */,
    icon: "ItalicSingle",
    title: "Set italic",
    tooltip: "toolbar.italic",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(false);
            return;
          }
          const it = (_a = textRun.ts) == null ? void 0 : _a.it;
          subscriber.next(it === 1 /* TRUE */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function UnderlineMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatUnderlineCommand.id,
    type: 0 /* BUTTON */,
    icon: "UnderlineSingle",
    title: "Set underline",
    tooltip: "toolbar.underline",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(false);
            return;
          }
          const ul = (_a = textRun.ts) == null ? void 0 : _a.ul;
          subscriber.next((ul == null ? void 0 : ul.s) === 1 /* TRUE */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function StrikeThroughMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatStrikethroughCommand.id,
    type: 0 /* BUTTON */,
    icon: "StrikethroughSingle",
    title: "Set strike through",
    tooltip: "toolbar.strikethrough",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(false);
            return;
          }
          const st = (_a = textRun.ts) == null ? void 0 : _a.st;
          subscriber.next((st == null ? void 0 : st.s) === 1 /* TRUE */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function SubscriptMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatSubscriptCommand.id,
    type: 0 /* BUTTON */,
    icon: "SubscriptSingle",
    tooltip: "toolbar.subscript",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(false);
            return;
          }
          const va = (_a = textRun.ts) == null ? void 0 : _a.va;
          subscriber.next(va === 2 /* SUBSCRIPT */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function SuperscriptMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatSuperscriptCommand.id,
    type: 0 /* BUTTON */,
    icon: "SuperscriptSingle",
    tooltip: "toolbar.superscript",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(false);
            return;
          }
          const va = (_a = textRun.ts) == null ? void 0 : _a.va;
          subscriber.next(va === 3 /* SUPERSCRIPT */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function FontFamilySelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatFontFamilyCommand.id,
    tooltip: "toolbar.font",
    type: 1 /* SELECTOR */,
    label: FONT_FAMILY_COMPONENT,
    selections: FONT_FAMILY_LIST.map((item) => ({
      label: {
        name: FONT_FAMILY_ITEM_COMPONENT
      },
      value: item.value
    })),
    // disabled$: getCurrentSheetDisabled$(accessor),
    value$: new Observable((subscriber) => {
      const defaultValue = DEFAULT_STYLES.ff;
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatFontFamilyCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(defaultValue);
            return;
          }
          const ff = (_a = textRun.ts) == null ? void 0 : _a.ff;
          subscriber.next(ff != null ? ff : defaultValue);
        }
      });
      subscriber.next(defaultValue);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function FontSizeSelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: SetInlineFormatFontSizeCommand.id,
    type: 1 /* SELECTOR */,
    tooltip: "toolbar.fontSize",
    label: {
      name: FONT_SIZE_COMPONENT,
      props: {
        min: 1,
        max: 400
        // disabled$,
      }
    },
    selections: FONT_SIZE_LIST,
    // disabled$,
    value$: new Observable((subscriber) => {
      const DEFAULT_SIZE = DEFAULT_STYLES.fs;
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === SetInlineFormatFontSizeCommand.id) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            subscriber.next(DEFAULT_SIZE);
            return;
          }
          const fs = (_a = textRun.ts) == null ? void 0 : _a.fs;
          subscriber.next(fs != null ? fs : DEFAULT_SIZE);
        }
      });
      subscriber.next(DEFAULT_SIZE);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function TextColorSelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const themeService = accessor.get(ThemeService);
  return {
    id: SetInlineFormatTextColorCommand.id,
    icon: "FontColor",
    tooltip: "toolbar.textColor.main",
    type: 2 /* BUTTON_SELECTOR */,
    selections: [
      {
        label: {
          name: COLOR_PICKER_COMPONENT,
          hoverable: false,
          selectable: false
        }
      }
    ],
    value$: new Observable((subscriber) => {
      const defaultColor = themeService.getCurrentTheme().textColor;
      const disposable = commandService.onCommandExecuted((c) => {
        if (c.id === SetInlineFormatTextColorCommand.id) {
          const color = c.params.value;
          subscriber.next(color != null ? color : defaultColor);
        }
      });
      subscriber.next(defaultColor);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
    // disabled$: getCurrentSheetDisabled$(accessor),
  };
}
function HeaderFooterMenuItemFactory(accessor) {
  return {
    id: OpenHeaderFooterPanelCommand.id,
    type: 0 /* BUTTON */,
    icon: "HeaderFooterSingle",
    tooltip: "toolbar.headerFooter",
    hidden$: combineLatest(getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY), getHeaderFooterMenuHiddenObservable2(accessor), (one, two) => {
      return one || two;
    })
  };
}
var TableIcon = "GridSingle";
var TABLE_MENU_ID = "doc.menu.table";
function TableMenuFactory(accessor) {
  return {
    id: TABLE_MENU_ID,
    type: 3 /* SUBITEMS */,
    icon: TableIcon,
    tooltip: "toolbar.table.main",
    disabled$: getTableDisabledObservable(accessor),
    // Do not show header footer menu and insert table at zen mode.
    hidden$: combineLatest(getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY), getInsertTableHiddenObservable(accessor), (one, two) => {
      return one || two;
    })
  };
}
function InsertTableMenuFactory(_accessor) {
  return {
    id: DocCreateTableOperation.id,
    title: "toolbar.table.insert",
    type: 0 /* BUTTON */,
    hidden$: getMenuHiddenObservable(_accessor, O.UNIVER_DOC)
  };
}
function AlignLeftMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: AlignLeftCommand.id,
    type: 0 /* BUTTON */,
    icon: "LeftJustifyingSingle",
    tooltip: "toolbar.alignLeft",
    disabled$: disableMenuWhenNoDocRange(accessor),
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === AlignOperationCommand.id) {
          const paragraph = getParagraphStyleAtCursor(accessor);
          if (paragraph == null) {
            return;
          }
          const alignType = (_a = paragraph.paragraphStyle) == null ? void 0 : _a.horizontalAlign;
          subscriber.next(alignType === 1 /* LEFT */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY)
  };
}
function AlignCenterMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: AlignCenterCommand.id,
    type: 0 /* BUTTON */,
    icon: "HorizontallySingle",
    tooltip: "toolbar.alignCenter",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === AlignOperationCommand.id) {
          const paragraph = getParagraphStyleAtCursor(accessor);
          if (paragraph == null) {
            return;
          }
          const alignType = (_a = paragraph.paragraphStyle) == null ? void 0 : _a.horizontalAlign;
          subscriber.next(alignType === 2 /* CENTER */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY)
  };
}
function AlignRightMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: AlignRightCommand.id,
    type: 0 /* BUTTON */,
    icon: "RightJustifyingSingle",
    tooltip: "toolbar.alignRight",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === AlignOperationCommand.id) {
          const paragraph = getParagraphStyleAtCursor(accessor);
          if (paragraph == null) {
            return;
          }
          const alignType = (_a = paragraph.paragraphStyle) == null ? void 0 : _a.horizontalAlign;
          subscriber.next(alignType === 3 /* RIGHT */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY)
  };
}
function AlignJustifyMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  return {
    id: AlignJustifyCommand.id,
    type: 0 /* BUTTON */,
    icon: "AlignTextBothSingle",
    tooltip: "toolbar.alignJustify",
    activated$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id === SetTextSelectionsOperation.id || id === AlignOperationCommand.id) {
          const paragraph = getParagraphStyleAtCursor(accessor);
          if (paragraph == null) {
            return;
          }
          const alignType = (_a = paragraph.paragraphStyle) == null ? void 0 : _a.horizontalAlign;
          subscriber.next(alignType === 4 /* JUSTIFIED */);
        }
      });
      subscriber.next(false);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY)
  };
}
function HorizontalLineFactory(accessor) {
  return {
    id: HorizontalLineCommand.id,
    type: 0 /* BUTTON */,
    icon: "ReduceSingle",
    tooltip: "toolbar.horizontalLine",
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY)
  };
}
var listValueFactory$ = (accessor) => {
  return new Observable((subscriber) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    let textSubscription;
    const subscription = univerInstanceService.focused$.subscribe((unitId) => {
      textSubscription == null ? void 0 : textSubscription.unsubscribe();
      if (unitId == null) {
        return;
      }
      const docDataModel = univerInstanceService.getUniverDocInstance(unitId);
      if (docDataModel == null) {
        return;
      }
      textSubscription = docSelectionManagerService.textSelection$.subscribe(() => {
        var _a, _b, _c;
        const docRanges = docSelectionManagerService.getDocRanges();
        const range = (_a = docRanges.find((r) => r.isActive)) != null ? _a : docRanges[0];
        if (range) {
          const doc = docDataModel.getSelfOrHeaderFooterModel(range == null ? void 0 : range.segmentId);
          const paragraphs = getParagraphsInRange2(range, (_c = (_b = doc.getBody()) == null ? void 0 : _b.paragraphs) != null ? _c : []);
          let listType;
          if (paragraphs.every((p) => {
            var _a2;
            if (!listType) {
              listType = (_a2 = p.bullet) == null ? void 0 : _a2.listType;
            }
            return p.bullet && p.bullet.listType === listType;
          })) {
            subscriber.next(listType);
            return;
          }
        }
        subscriber.next(void 0);
      });
    });
    return () => {
      subscription.unsubscribe();
      textSubscription == null ? void 0 : textSubscription.unsubscribe();
    };
  });
};
function OrderListMenuItemFactory(accessor) {
  return {
    id: OrderListCommand.id,
    type: 2 /* BUTTON_SELECTOR */,
    slot: true,
    selections: [
      {
        label: {
          name: ORDER_LIST_TYPE_COMPONENT,
          hoverable: false,
          selectable: false
        },
        value$: listValueFactory$(accessor)
      }
    ],
    icon: "OrderSingle",
    tooltip: "toolbar.order",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC),
    disabled$: disableMenuWhenNoDocRange(accessor),
    activated$: listValueFactory$(accessor).pipe(map((v) => v && v.indexOf("ORDER_LIST") === 0))
  };
}
function BulletListMenuItemFactory(accessor) {
  return {
    id: BulletListCommand.id,
    type: 2 /* BUTTON_SELECTOR */,
    slot: true,
    selections: [
      {
        label: {
          name: BULLET_LIST_TYPE_COMPONENT,
          hoverable: false,
          selectable: false
        },
        value$: listValueFactory$(accessor)
      }
    ],
    icon: "UnorderSingle",
    tooltip: "toolbar.unorder",
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC),
    activated$: listValueFactory$(accessor).pipe(map((v) => v && v.indexOf("BULLET_LIST") === 0))
  };
}
function CheckListMenuItemFactory(accessor) {
  return {
    id: CheckListCommand.id,
    type: 0 /* BUTTON */,
    icon: "TodoList",
    tooltip: "toolbar.checklist",
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC),
    activated$: listValueFactory$(accessor).pipe(map((v) => v && v.indexOf("CHECK_LIST") === 0))
  };
}
function DocSwitchModeMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  return {
    id: SwitchDocModeCommand.id,
    type: 0 /* BUTTON */,
    icon: "KeyboardSingle",
    tooltip: "toolbar.documentFlavor",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC, void 0, DOCS_ZEN_EDITOR_UNIT_ID_KEY),
    activated$: new Observable((subscriber) => {
      var _a;
      const subscription = commandService.onCommandExecuted((c) => {
        var _a2;
        if (c.id === RichTextEditingMutation.id) {
          const instance2 = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
          subscriber.next(((_a2 = instance2 == null ? void 0 : instance2.getSnapshot()) == null ? void 0 : _a2.documentStyle.documentFlavor) === 2 /* MODERN */);
        }
      });
      const instance = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
      subscriber.next(((_a = instance == null ? void 0 : instance.getSnapshot()) == null ? void 0 : _a.documentStyle.documentFlavor) === 2 /* MODERN */);
      return () => subscription.dispose();
    })
  };
}
function ResetBackgroundColorMenuItemFactory(accessor) {
  return {
    id: ResetInlineFormatTextBackgroundColorCommand.id,
    type: 0 /* BUTTON */,
    title: "toolbar.resetColor",
    icon: "NoColor"
  };
}
function BackgroundColorSelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const themeService = accessor.get(ThemeService);
  return {
    id: SetInlineFormatTextBackgroundColorCommand.id,
    tooltip: "toolbar.fillColor.main",
    type: 2 /* BUTTON_SELECTOR */,
    icon: "PaintBucket",
    selections: [
      {
        label: {
          name: COLOR_PICKER_COMPONENT,
          hoverable: false,
          selectable: false
        }
      }
    ],
    value$: new Observable((subscriber) => {
      const defaultColor = themeService.getCurrentTheme().primaryColor;
      const disposable = commandService.onCommandExecuted((c) => {
        if (c.id === SetInlineFormatTextBackgroundColorCommand.id) {
          const color = c.params.value;
          subscriber.next(color != null ? color : defaultColor);
        }
      });
      subscriber.next(defaultColor);
      return disposable.dispose;
    }),
    disabled$: disableMenuWhenNoDocRange(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_DOC)
  };
}
function getFontStyleAtCursor(accessor) {
  var _a, _b;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const textSelectionService = accessor.get(DocSelectionManagerService);
  const docMenuStyleService = accessor.get(DocMenuStyleService);
  const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
  const docRanges = textSelectionService.getDocRanges();
  const activeRange = (_a = docRanges.find((r) => r.isActive)) != null ? _a : docRanges[0];
  const defaultTextStyle = docMenuStyleService.getDefaultStyle();
  const cacheStyle = (_b = docMenuStyleService.getStyleCache()) != null ? _b : {};
  if (docDataModel == null || activeRange == null) {
    return {
      ts: {
        ...defaultTextStyle,
        ...cacheStyle
      }
    };
  }
  const { segmentId } = activeRange;
  const body = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
  if (body == null) {
    return {
      ts: {
        ...defaultTextStyle,
        ...cacheStyle
      }
    };
  }
  const curTextStyle = getStyleInTextRange(body, activeRange, defaultTextStyle);
  return {
    ts: {
      ...curTextStyle,
      ...cacheStyle
    }
  };
}
function getParagraphStyleAtCursor(accessor) {
  var _a, _b;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const textSelectionService = accessor.get(DocSelectionManagerService);
  const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
  const docRanges = textSelectionService.getDocRanges();
  const activeRange = (_a = docRanges.find((r) => r.isActive)) != null ? _a : docRanges[0];
  if (docDataModel == null || activeRange == null) {
    return;
  }
  const { startOffset, segmentId } = activeRange;
  const paragraphs = (_b = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _b.paragraphs;
  if (paragraphs == null) {
    return;
  }
  let prevIndex = -1;
  for (const paragraph of paragraphs) {
    const { startIndex } = paragraph;
    if (startOffset > prevIndex && startOffset <= startIndex) {
      return paragraph;
    }
    prevIndex = startIndex;
  }
  return null;
}

// ../packages/docs-ui/src/controllers/menu.schema.ts
var menuSchema2 = {
  ["ribbon.start.format" /* FORMAT */]: {
    [SetInlineFormatBoldCommand.id]: {
      order: 0,
      menuItemFactory: BoldMenuItemFactory
    },
    [SetInlineFormatItalicCommand.id]: {
      order: 1,
      menuItemFactory: ItalicMenuItemFactory
    },
    [SetInlineFormatUnderlineCommand.id]: {
      order: 2,
      menuItemFactory: UnderlineMenuItemFactory
    },
    [SetInlineFormatStrikethroughCommand.id]: {
      order: 3,
      menuItemFactory: StrikeThroughMenuItemFactory
    },
    [SetInlineFormatSubscriptCommand.id]: {
      order: 4,
      menuItemFactory: SubscriptMenuItemFactory
    },
    [SetInlineFormatSuperscriptCommand.id]: {
      order: 5,
      menuItemFactory: SuperscriptMenuItemFactory
    },
    [SetInlineFormatFontSizeCommand.id]: {
      order: 6,
      menuItemFactory: FontSizeSelectorMenuItemFactory
    },
    [SetInlineFormatFontFamilyCommand.id]: {
      order: 7,
      menuItemFactory: FontFamilySelectorMenuItemFactory
    },
    [SetInlineFormatTextColorCommand.id]: {
      order: 8,
      menuItemFactory: TextColorSelectorMenuItemFactory
    },
    [SetInlineFormatTextBackgroundColorCommand.id]: {
      order: 9,
      menuItemFactory: BackgroundColorSelectorMenuItemFactory,
      [ResetInlineFormatTextBackgroundColorCommand.id]: {
        order: 0,
        menuItemFactory: ResetBackgroundColorMenuItemFactory
      }
    }
  },
  ["ribbon.start.layout" /* LAYOUT */]: {
    [TABLE_MENU_ID]: {
      order: 1,
      menuItemFactory: TableMenuFactory,
      [DocCreateTableOperation.id]: {
        order: 0,
        menuItemFactory: InsertTableMenuFactory
      }
    },
    [AlignLeftCommand.id]: {
      order: 2,
      menuItemFactory: AlignLeftMenuItemFactory
    },
    [AlignCenterCommand.id]: {
      order: 3,
      menuItemFactory: AlignCenterMenuItemFactory
    },
    [AlignRightCommand.id]: {
      order: 4,
      menuItemFactory: AlignRightMenuItemFactory
    },
    [AlignJustifyCommand.id]: {
      order: 5,
      menuItemFactory: AlignJustifyMenuItemFactory
    },
    [HorizontalLineCommand.id]: {
      order: 6,
      menuItemFactory: HorizontalLineFactory
    },
    [OrderListCommand.id]: {
      order: 7,
      menuItemFactory: OrderListMenuItemFactory
    },
    [BulletListCommand.id]: {
      order: 8,
      menuItemFactory: BulletListMenuItemFactory
    },
    [CheckListCommand.id]: {
      order: 9,
      menuItemFactory: CheckListMenuItemFactory
    },
    [OpenHeaderFooterPanelCommand.id]: {
      order: 10,
      menuItemFactory: HeaderFooterMenuItemFactory
    },
    [SwitchDocModeCommand.id]: {
      order: 11,
      menuItemFactory: DocSwitchModeMenuItemFactory
    }
  },
  ["contextMenu.mainArea" /* MAIN_AREA */]: {
    ["contextMenu.format" /* FORMAT */]: {
      [DocCopyCommand.name]: {
        order: 0,
        menuItemFactory: CopyMenuFactory
      },
      [DocCutCommand.id]: {
        order: 1,
        menuItemFactory: CutMenuFactory
      },
      [DocPasteCommand.id]: {
        order: 2,
        menuItemFactory: PasteMenuFactory
      },
      [DeleteLeftCommand.id]: {
        order: 3,
        menuItemFactory: DeleteMenuFactory
      }
    },
    ["contextMenu.layout" /* LAYOUT */]: {
      [DocParagraphSettingPanelOperation.id]: {
        order: 0,
        menuItemFactory: ParagraphSettingMenuFactory
      },
      [TABLE_INSERT_MENU_ID]: {
        order: 1,
        menuItemFactory: TableInsertMenuItemFactory,
        [DocTableInsertRowAboveCommand.id]: {
          order: 1,
          menuItemFactory: InsertRowBeforeMenuItemFactory
        },
        [DocTableInsertRowBellowCommand.id]: {
          order: 2,
          menuItemFactory: InsertRowAfterMenuItemFactory
        },
        [DocTableInsertColumnLeftCommand.id]: {
          order: 3,
          menuItemFactory: InsertColumnLeftMenuItemFactory
        },
        [DocTableInsertColumnRightCommand.id]: {
          order: 4,
          menuItemFactory: InsertColumnRightMenuItemFactory
        }
      },
      [TABLE_DELETE_MENU_ID]: {
        order: 2,
        menuItemFactory: TableDeleteMenuItemFactory,
        [DocTableDeleteRowsCommand.id]: {
          order: 1,
          menuItemFactory: DeleteRowsMenuItemFactory
        },
        [DocTableDeleteColumnsCommand.id]: {
          order: 2,
          menuItemFactory: DeleteColumnsMenuItemFactory
        },
        [DocTableDeleteTableCommand.id]: {
          order: 3,
          menuItemFactory: DeleteTableMenuItemFactory
        }
      }
    }
  }
};

// ../packages/docs-ui/src/controllers/doc-ui.controller.ts
var DocUIController = class extends Disposable {
  constructor(_injector, _componentManager, _commandService, _layoutService, _menuManagerService, _uiPartsService, _univerInstanceService, _shortcutService, _configService) {
    super();
    this._injector = _injector;
    this._componentManager = _componentManager;
    this._commandService = _commandService;
    this._layoutService = _layoutService;
    this._menuManagerService = _menuManagerService;
    this._uiPartsService = _uiPartsService;
    this._univerInstanceService = _univerInstanceService;
    this._shortcutService = _shortcutService;
    this._configService = _configService;
    this._init();
  }
  _initCustomComponents() {
    const componentManager = this._componentManager;
    this.disposeWithMe(componentManager.register(COLOR_PICKER_COMPONENT, ColorPicker));
    this.disposeWithMe(componentManager.register(FONT_FAMILY_COMPONENT, FontFamily));
    this.disposeWithMe(componentManager.register(FONT_FAMILY_ITEM_COMPONENT, FontFamilyItem));
    this.disposeWithMe(componentManager.register(FONT_SIZE_COMPONENT, FontSize));
    this.disposeWithMe(componentManager.register(BULLET_LIST_TYPE_COMPONENT, BulletListTypePicker));
    this.disposeWithMe(componentManager.register(ORDER_LIST_TYPE_COMPONENT, OrderListTypePicker));
    this.disposeWithMe(componentManager.register("TodoList", todo_list_default));
  }
  _initUiParts() {
    var _a, _b;
    const config = this._configService.getConfig(DOCS_UI_PLUGIN_CONFIG_KEY);
    if ((_b = (_a = config == null ? void 0 : config.layout) == null ? void 0 : _a.docContainerConfig) == null ? void 0 : _b.footer) {
      this.disposeWithMe(this._uiPartsService.registerComponent("footer" /* FOOTER */, () => connectInjector(DocFooter, this._injector)));
    }
  }
  _initMenus() {
    this._menuManagerService.mergeMenu(menuSchema2);
  }
  _initShortCut() {
    [
      BoldShortCut,
      ItalicShortCut,
      UnderlineShortCut,
      StrikeThroughShortCut,
      SubscriptShortCut,
      SuperscriptShortCut,
      AlignCenterShortCut,
      AlignJustifyShortCut,
      AlignRightShortCut,
      AlignLeftShortCut,
      OrderListShortCut,
      BulletListShortCut,
      TabShortCut
    ].forEach((shortcut) => {
      this.disposeWithMe(this._shortcutService.registerShortcut(shortcut));
    });
  }
  _init() {
    this._initCustomComponents();
    this._initMenus();
    this._initFocusHandler();
    this._initCommands();
    this._initUiParts();
    this._initShortCut();
  }
  _initCommands() {
    [
      CoreHeaderFooterCommand,
      OpenHeaderFooterPanelCommand,
      SidebarDocHeaderFooterPanelOperation
    ].forEach((command) => this.disposeWithMe(this._commandService.registerCommand(command)));
  }
  _initFocusHandler() {
    this.disposeWithMe(
      this._layoutService.registerFocusHandler(O.UNIVER_DOC, (unitId) => {
        const renderManagerService = this._injector.get(IRenderManagerService);
        const docSelectionRenderService = renderManagerService.getRenderById(unitId).with(DocSelectionRenderService);
        docSelectionRenderService.focus();
      })
    );
  }
};
DocUIController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, Inject(ComponentManager)),
  __decorateParam(2, ICommandService),
  __decorateParam(3, ILayoutService),
  __decorateParam(4, IMenuManagerService),
  __decorateParam(5, IUIPartsService),
  __decorateParam(6, IUniverInstanceService),
  __decorateParam(7, IShortcutService),
  __decorateParam(8, IConfigService)
], DocUIController);

// ../packages/docs-ui/src/commands/commands/doc-select-all.command.ts
var DocSelectAllCommand = {
  id: "doc.command.select-all",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    var _a;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docSelectionManagerService = accessor.get(DocSelectionManagerService);
    const docDataModel = univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
    const docRanges = docSelectionManagerService.getDocRanges();
    const activeRange = (_a = docRanges.find((range) => range.isActive)) != null ? _a : docRanges[0];
    if (docDataModel == null || activeRange == null) {
      return false;
    }
    const { segmentId } = activeRange;
    const unitId = docDataModel.getUnitId();
    const body = docDataModel.getSelfOrHeaderFooterModel(segmentId).getSnapshot().body;
    if (body == null) {
      return false;
    }
    const { tables = [], dataStream } = body;
    if (dataStream === "\r\n") {
      return true;
    }
    const textRanges = [];
    let offset = 0;
    for (const table2 of tables) {
      const { startIndex, endIndex } = table2;
      if (offset !== startIndex) {
        textRanges.push({
          startOffset: offset,
          endOffset: startIndex - 1,
          rangeType: "TEXT" /* TEXT */
        });
      }
      textRanges.push({
        startOffset: startIndex + 3,
        // 3 is TABLE_START, ROW_START, CELL_START.
        endOffset: endIndex - 5,
        // 4 is CELL_END, ROW_END, TABLE_END AND \n.
        rangeType: "RECT" /* RECT */
      });
      offset = endIndex;
    }
    if (offset !== body.dataStream.length - 2) {
      textRanges.push({
        startOffset: offset,
        endOffset: body.dataStream.length - 2,
        rangeType: "TEXT" /* TEXT */
      });
    }
    docSelectionManagerService.replaceDocRanges(textRanges, {
      unitId,
      subUnitId: unitId
    }, false);
    return true;
  }
};

// ../packages/docs-ui/src/services/doc-ime-input-manager.service.ts
var DocIMEInputManagerService = class extends RxDisposable {
  constructor(_context) {
    super();
    this._context = _context;
    __publicField(this, "_previousActiveRange", null);
    __publicField(this, "_undoMutationParamsCache", []);
    __publicField(this, "_redoMutationParamsCache", []);
  }
  clearUndoRedoMutationParamsCache() {
    this._undoMutationParamsCache = [];
    this._redoMutationParamsCache = [];
  }
  getUndoRedoMutationParamsCache() {
    return {
      undoCache: this._undoMutationParamsCache,
      redoCache: this._redoMutationParamsCache
    };
  }
  setUndoRedoMutationParamsCache({ undoCache = [], redoCache = [] }) {
    this._undoMutationParamsCache = undoCache;
    this._redoMutationParamsCache = redoCache;
  }
  getActiveRange() {
    return this._previousActiveRange;
  }
  setActiveRange(range) {
    this._previousActiveRange = range;
  }
  pushUndoRedoMutationParams(undoParams, redoParams) {
    this._undoMutationParamsCache.push(undoParams);
    this._redoMutationParamsCache.push(redoParams);
  }
  fetchComposedUndoRedoMutationParams() {
    if (this._undoMutationParamsCache.length === 0 || this._previousActiveRange == null || this._redoMutationParamsCache.length === 0) {
      return null;
    }
    const { unitId } = this._undoMutationParamsCache[0];
    const undoMutationParams = {
      unitId,
      actions: this._undoMutationParamsCache.reverse().reduce((acc, cur) => {
        return JSONX.compose(acc, cur.actions);
      }, null),
      textRanges: []
      // Add empty array, will never use, just fix type error
    };
    const redoMutationParams = {
      unitId,
      actions: this._redoMutationParamsCache.reduce((acc, cur) => {
        return JSONX.compose(acc, cur.actions);
      }, null),
      textRanges: []
      // Add empty array, will never use, just fix type error
    };
    return { redoMutationParams, undoMutationParams, previousActiveRange: this._previousActiveRange };
  }
  dispose() {
    this._undoMutationParamsCache = [];
    this._redoMutationParamsCache = [];
    this._previousActiveRange = null;
  }
};

// ../packages/docs-ui/src/commands/commands/ime-input.command.ts
var IMEInputCommand = {
  id: "doc.command.ime-input",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a, _b, _c;
    const { unitId, newText, oldTextLen, isCompositionEnd, isCompositionStart } = params;
    const commandService = accessor.get(ICommandService);
    const renderManagerService = accessor.get(IRenderManagerService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docMenuStyleService = accessor.get(DocMenuStyleService);
    const imeInputManagerService = (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocIMEInputManagerService);
    const docDataModel = univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    if (docDataModel == null || imeInputManagerService == null) {
      return false;
    }
    const previousActiveRange = imeInputManagerService.getActiveRange();
    if (previousActiveRange == null) {
      return false;
    }
    const { style, segmentId } = previousActiveRange;
    const body = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (body == null) {
      return false;
    }
    const insertRange = previousActiveRange;
    Object.assign(previousActiveRange, insertRange);
    const { startOffset, endOffset } = previousActiveRange;
    const len = newText.length;
    const textRanges = [
      {
        startOffset: startOffset + len,
        endOffset: startOffset + len,
        collapsed: true,
        style
      }
    ];
    const doMutation = {
      id: RichTextEditingMutation.id,
      params: {
        unitId,
        actions: [],
        textRanges
      }
    };
    const defaultTextStyle = docMenuStyleService.getDefaultStyle();
    const styleCache = docMenuStyleService.getStyleCache();
    const curCustomRange = getCustomRangeAtPosition((_b = body.customRanges) != null ? _b : [], startOffset + oldTextLen, SHEET_EDITOR_UNITS.includes(unitId));
    const curTextRun = getTextRunAtPosition(
      body,
      isCompositionStart ? endOffset : startOffset + oldTextLen,
      defaultTextStyle,
      styleCache,
      SHEET_EDITOR_UNITS.includes(unitId)
    );
    const customDecorations = getCustomDecorationAtPosition((_c = body.customDecorations) != null ? _c : [], startOffset + oldTextLen);
    const textX = new TextX();
    const jsonX = JSONX.getInstance();
    if (!previousActiveRange.collapsed && isCompositionStart) {
      const dos = BuildTextUtils.selection.delete([previousActiveRange], body, 0, null, false);
      textX.push(...dos);
      doMutation.params.textRanges = [{
        startOffset: startOffset + len,
        endOffset: startOffset + len,
        collapsed: true
      }];
    } else {
      textX.push({
        t: "r" /* RETAIN */,
        len: startOffset
      });
    }
    if (oldTextLen > 0) {
      textX.push({
        t: "d" /* DELETE */,
        len: oldTextLen
      });
    }
    textX.push({
      t: "i" /* INSERT */,
      body: {
        dataStream: newText,
        textRuns: curTextRun ? [{
          ...curTextRun,
          st: 0,
          ed: newText.length
        }] : [],
        customRanges: curCustomRange ? [{
          ...curCustomRange,
          startIndex: 0,
          endIndex: newText.length - 1
        }] : [],
        customDecorations: customDecorations.map((customDecoration) => ({
          ...customDecoration,
          startIndex: 0,
          endIndex: newText.length - 1
        }))
      },
      len: newText.length
    });
    const path = getRichTextEditPath2(docDataModel, segmentId);
    doMutation.params.actions = jsonX.editOp(textX.serialize(), path);
    doMutation.params.noHistory = !isCompositionEnd;
    doMutation.params.isCompositionEnd = isCompositionEnd;
    const result = commandService.syncExecuteCommand(doMutation.id, doMutation.params);
    imeInputManagerService.pushUndoRedoMutationParams(result, doMutation.params);
    return Boolean(result);
  }
};

// ../packages/docs-ui/src/commands/commands/insert-custom-range.command.ts
var InsertCustomRangeCommand = {
  id: "doc.command.insert-custom-range",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) return false;
    const commandService = accessor.get(ICommandService);
    const { unitId, rangeId = generateRandomId(), textRanges, properties, text } = params;
    const replaceSelectionParams = {
      unitId,
      textRanges,
      body: {
        dataStream: text,
        customRanges: [{
          startIndex: 0,
          endIndex: text.length - 1,
          rangeId,
          rangeType: 5 /* CUSTOM */,
          properties
        }]
      }
    };
    return commandService.syncExecuteCommand(ReplaceSelectionCommand.id, replaceSelectionParams);
  }
};

// ../packages/docs-ui/src/commands/commands/set-doc-zoom-ratio.command.ts
var SetDocZoomRatioCommand = {
  type: 0 /* COMMAND */,
  id: "doc.command.set-zoom-ratio",
  handler: async (accessor, params) => {
    var _a, _b, _c;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    let documentId = (_a = univerInstanceService.getCurrentUniverDocInstance()) == null ? void 0 : _a.getUnitId();
    if (!documentId) return false;
    let zoomRatio = 1;
    if (params) {
      documentId = (_b = params.documentId) != null ? _b : documentId;
      zoomRatio = (_c = params.zoomRatio) != null ? _c : zoomRatio;
    }
    const workbook = univerInstanceService.getUniverDocInstance(documentId);
    if (!workbook) return false;
    const setZoomRatioMutationParams = {
      zoomRatio,
      unitId: documentId
    };
    const undoMutationParams = SetDocZoomRatioUndoMutationFactory(accessor, setZoomRatioMutationParams);
    const result = commandService.syncExecuteCommand(SetDocZoomRatioOperation.id, setZoomRatioMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: documentId,
        undoMutations: [{ id: SetDocZoomRatioOperation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetDocZoomRatioOperation.id, params: setZoomRatioMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/docs-ui/src/commands/commands/table/doc-table-tab.command.ts
var DocTableTabCommand = {
  id: "doc.table.tab-in-table",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    var _a;
    const { shift } = params;
    const textSelectionManager = accessor.get(DocSelectionManagerService);
    const docRanges = textSelectionManager.getDocRanges();
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const docDataModel = univerInstanceService.getCurrentUniverDocInstance();
    if (!docDataModel) {
      return false;
    }
    const activeRange = (_a = docRanges.find((range) => range.isActive)) != null ? _a : docRanges[0];
    const unitId = docDataModel.getUnitId();
    const docSkeletonManagerService = getCommandSkeleton(accessor, unitId);
    const skeleton = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getSkeleton();
    const viewModel = skeleton == null ? void 0 : skeleton.getViewModel().getSelfOrHeaderFooterViewModel(activeRange == null ? void 0 : activeRange.segmentId);
    if (viewModel == null) {
      return false;
    }
    if (activeRange == null) {
      return false;
    }
    let offsets = null;
    if (shift) {
      offsets = getCellOffsets(viewModel, activeRange, 1 /* PREV */);
    } else {
      offsets = getCellOffsets(viewModel, activeRange, 0 /* NEXT */);
    }
    if (offsets) {
      const { startOffset, endOffset } = offsets;
      const textRanges = [{
        startOffset,
        endOffset
      }];
      textSelectionManager.replaceDocRanges(textRanges);
      return true;
    }
    if (shift === false) {
      const result = await commandService.executeCommand(DocTableInsertRowCommand.id, {
        position: 1 /* BELLOW */
      });
      return result;
    }
    return true;
  }
};

// ../packages/docs-ui/src/commands/operations/doc-cursor.operation.ts
var MoveCursorOperation = {
  id: "doc.operation.move-cursor",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    return true;
  }
};
var MoveSelectionOperation = {
  id: "doc.operation.move-selection",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    return true;
  }
};

// ../packages/docs-ui/src/controllers/doc-container-ui-controller.ts
var DocContainerUIController = class {
  constructor(_localeService, _injector, _configService) {
    this._localeService = _localeService;
    this._injector = _injector;
    this._configService = _configService;
    __publicField(this, "_docContainer");
    // 获取SheetContainer组件
    __publicField(this, "getComponent", (ref) => {
      this._docContainer = ref;
      const container = ref.getContentRef().current;
      if (!container) {
        throw new Error("container is not ready");
      }
    });
    /**
     * Change language
     * @param {string} lang new language
     *
     * e: {target: HTMLSelectElement } reference from  https://stackoverflow.com/a/48443771
     *
     */
    __publicField(this, "changeLocale", (locale) => {
      this._localeService.setLocale(locale);
    });
  }
  getUIConfig() {
    const config = {
      injector: this._injector,
      config: this._configService.getConfig(DOCS_UI_PLUGIN_CONFIG_KEY),
      changeLocale: this.changeLocale,
      getComponent: this.getComponent
    };
    return config;
  }
  getContentRef() {
    return this._docContainer.getContentRef();
  }
  UIDidMount(cb) {
    if (this._docContainer) {
      return cb(this._docContainer);
    }
  }
  getDocContainer() {
    return this._docContainer;
  }
};
DocContainerUIController = __decorateClass([
  __decorateParam(0, Inject(LocaleService)),
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], DocContainerUIController);

// ../packages/docs-ui/src/controllers/app-ui-controller.ts
var AppUIController = class extends RxDisposable {
  constructor(_injector) {
    super();
    this._injector = _injector;
    __publicField(this, "_docContainerController");
    this._docContainerController = this._injector.createInstance(DocContainerUIController);
  }
};
AppUIController = __decorateClass([
  __decorateParam(0, Inject(Injector))
], AppUIController);

// ../packages/docs-ui/src/controllers/doc-auto-format.controller.ts
var DocAutoFormatController = class extends Disposable {
  constructor(_docAutoFormatService, _renderManagerService) {
    super();
    this._docAutoFormatService = _docAutoFormatService;
    this._renderManagerService = _renderManagerService;
    this._initListTabAutoFormat();
    this._initListSpaceAutoFormat();
    this._initDefaultEnterFormat();
    this._initExitListAutoFormat();
  }
  _initListTabAutoFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: TabCommand.id,
        match: (context) => {
          var _a;
          const { selection, paragraphs, unit } = context;
          if (paragraphs.length === 1 && selection.startOffset === paragraphs[0].paragraphStart && paragraphs[0].bullet) {
            const allParagraphs = (_a = unit.getBody()) == null ? void 0 : _a.paragraphs;
            const bulletParagraphs = allParagraphs == null ? void 0 : allParagraphs.filter((p) => {
              var _a2;
              return ((_a2 = p.bullet) == null ? void 0 : _a2.listId) === paragraphs[0].bullet.listId;
            });
            if ((bulletParagraphs == null ? void 0 : bulletParagraphs.findIndex((p) => p.startIndex === paragraphs[0].startIndex)) === 0) {
              return false;
            }
            return true;
          } else if (paragraphs.length > 1 && paragraphs.some((p) => p.bullet)) {
            return true;
          }
          return false;
        },
        // traverse all paragraphs, set paragraph
        getMutations(context) {
          const params = context.commandParams;
          return [{
            id: ChangeListNestingLevelCommand.id,
            params: {
              type: (params == null ? void 0 : params.shift) ? -1 /* decrease */ : 1 /* increase */
            }
          }];
        },
        priority: 100
      })
    );
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: TabCommand.id,
        match: (context) => {
          const { selection, unit } = context;
          const { startNodePosition, endNodePosition } = selection;
          const renderObject = this._renderManagerService.getRenderById(unit.getUnitId());
          const skeleton = renderObject == null ? void 0 : renderObject.with(DocSkeletonManagerService).getSkeleton();
          if (skeleton == null) {
            return false;
          }
          if (startNodePosition && endNodePosition && isInSameTableCellData(skeleton, startNodePosition, endNodePosition)) {
            return true;
          }
          if (startNodePosition && !endNodePosition && startNodePosition.path.indexOf("cells") > -1) {
            return true;
          }
          return false;
        },
        getMutations(context) {
          const params = context.commandParams;
          return [{
            id: DocTableTabCommand.id,
            params: {
              shift: !!(params == null ? void 0 : params.shift)
            }
          }];
        },
        priority: 99
      })
    );
  }
  _initListSpaceAutoFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: AfterSpaceCommand.id,
        match: (context) => {
          var _a;
          const { selection, paragraphs, unit } = context;
          if (!selection.collapsed) {
            return false;
          }
          if (paragraphs.length !== 1) {
            return false;
          }
          const text = (_a = unit.getBody()) == null ? void 0 : _a.dataStream.slice(paragraphs[0].paragraphStart, paragraphs[0].paragraphEnd - 1);
          if (text && Object.keys(QuickListTypeMap).includes(text)) {
            return true;
          }
          return false;
        },
        getMutations(context) {
          var _a;
          const { paragraphs, unit } = context;
          const text = (_a = unit.getBody()) == null ? void 0 : _a.dataStream.slice(paragraphs[0].paragraphStart, paragraphs[0].paragraphEnd - 1);
          if (text && Object.keys(QuickListTypeMap).includes(text)) {
            const type2 = QuickListTypeMap[text];
            return [{
              id: QuickListCommand.id,
              params: {
                listType: type2,
                paragraph: paragraphs[0]
              }
            }];
          }
          return [];
        }
      })
    );
  }
  _initExitListAutoFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: EnterCommand.id,
        match: (context) => {
          const { paragraphs } = context;
          if (paragraphs.length === 1 && paragraphs[0].bullet && paragraphs[0].paragraphStart === paragraphs[0].paragraphEnd) {
            return true;
          }
          return false;
        },
        getMutations: (context) => {
          const bullet = context.paragraphs[0].bullet;
          if (!bullet) {
            return [];
          }
          if (bullet.nestingLevel > 0) {
            return [{
              id: ChangeListNestingLevelCommand.id,
              params: {
                type: -1 /* decrease */
              }
            }];
          }
          return [{
            id: ListOperationCommand.id,
            params: {
              listType: context.paragraphs[0].bullet.listType
            }
          }];
        }
      })
    );
  }
  _initDefaultEnterFormat() {
    this.disposeWithMe(
      this._docAutoFormatService.registerAutoFormat({
        id: EnterCommand.id,
        match: () => {
          return true;
        },
        getMutations() {
          return [{
            id: BreakLineCommand.id
          }];
        },
        priority: -9999
      })
    );
  }
};
DocAutoFormatController = __decorateClass([
  __decorateParam(0, Inject(DocAutoFormatService)),
  __decorateParam(1, IRenderManagerService)
], DocAutoFormatController);

// ../packages/docs-ui/src/basics/table.ts
function firstLineInTable(table2) {
  const firstRow = table2.rows[0];
  const firstCell = firstRow.cells[0];
  const firstLine = firstCell.sections[0].columns[0].lines[0];
  return firstLine;
}
function lastLineInTable(table2) {
  const lastRow = table2.rows[table2.rows.length - 1];
  const lastCell = lastRow.cells[lastRow.cells.length - 1];
  const lastLine = getLastLine(lastCell);
  return lastLine;
}
function findTableAfterLine(line2, page) {
  const { ed } = line2;
  const { skeTables } = page;
  let table2 = null;
  for (const t2 of skeTables.values()) {
    if (t2.st === ed + 1) {
      table2 = t2;
      break;
    }
  }
  return table2;
}
function findLineBeforeAndAfterTable(table2) {
  const tablePage = table2 == null ? void 0 : table2.parent;
  let lineBeforeTable = null;
  let lineAfterTable = null;
  if (table2 == null || tablePage == null) {
    return {
      lineBeforeTable,
      lineAfterTable
    };
  }
  const { st, ed } = table2;
  const pages = tablePage.type === 3 /* CELL */ ? [tablePage] : tablePage.parent.pages;
  lineIterator(pages, (l) => {
    if (l.st === ed + 1) {
      lineAfterTable = l;
    } else if (l.ed === st - 1) {
      lineBeforeTable = l;
    }
  });
  return {
    lineBeforeTable,
    lineAfterTable
  };
}
function isEmptyCellPage2(cell) {
  return cell.sections[0].columns[0].lines.length === 0;
}
function findBellowCell(cell) {
  var _a, _b;
  const row = cell.parent;
  const table2 = row == null ? void 0 : row.parent;
  const tableId = table2 == null ? void 0 : table2.tableId;
  if (row == null || table2 == null) {
    return;
  }
  const col = row.cells.indexOf(cell);
  let bellowRow = table2.rows[table2.rows.indexOf(row) + 1];
  if (bellowRow == null) {
    if (tableId.indexOf("#-#")) {
      const [id, index] = tableId.split("#-#");
      const pages = (_b = (_a = table2.parent) == null ? void 0 : _a.parent) == null ? void 0 : _b.pages;
      const nextTableId = `${id}#-#${Number.parseInt(index) + 1}`;
      if (pages) {
        for (const page of pages) {
          const { skeTables } = page;
          if (skeTables.has(nextTableId)) {
            const nextTable = skeTables.get(nextTableId);
            if (nextTable == null ? void 0 : nextTable.rows.length) {
              bellowRow = nextTable.rows.find((r) => !r.isRepeatRow);
              break;
            }
          }
        }
      }
    }
  }
  if (bellowRow != null) {
    const cell2 = bellowRow.cells[col];
    return isEmptyCellPage2(cell2) ? findBellowCell(cell2) : cell2;
  }
}
function findAboveCell(cell) {
  var _a, _b;
  const row = cell.parent;
  const table2 = row == null ? void 0 : row.parent;
  if (row == null || table2 == null) {
    return;
  }
  let aboveRow = table2.rows[table2.rows.indexOf(row) - 1];
  const col = row.cells.indexOf(cell);
  if (aboveRow == null || aboveRow.isRepeatRow) {
    if (table2.tableId.indexOf("#-#")) {
      const [id, index] = table2.tableId.split("#-#");
      const pages = (_b = (_a = table2.parent) == null ? void 0 : _a.parent) == null ? void 0 : _b.pages;
      const nextTableId = `${id}#-#${Number.parseInt(index) - 1}`;
      if (pages) {
        for (const page of pages) {
          const { skeTables } = page;
          if (skeTables.has(nextTableId)) {
            const nextTable = skeTables.get(nextTableId);
            if (nextTable == null ? void 0 : nextTable.rows.length) {
              aboveRow = nextTable.rows[nextTable.rows.length - 1];
              break;
            }
          }
        }
      }
    }
  }
  if (aboveRow != null) {
    const cell2 = aboveRow.cells[col];
    return isEmptyCellPage2(cell2) ? findAboveCell(cell2) : cell2;
  }
}
function findTableBeforeLine(line2, page) {
  const { st } = line2;
  const { skeTables } = page;
  let table2 = null;
  for (const t2 of skeTables.values()) {
    if (t2.ed === st - 1) {
      table2 = t2;
      break;
    }
  }
  return table2;
}
function firstLineInCell(cell) {
  const firstLine = cell.sections[0].columns[0].lines[0];
  return firstLine;
}
function lastLineInCell(cell) {
  const lastColumn = getLastColumn(cell);
  const lastLine = lastColumn.lines[lastColumn.lines.length - 1];
  return lastLine;
}

// ../packages/docs-ui/src/controllers/render-controllers/back-scroll.render-controller.ts
var ANCHOR_WIDTH = 1.5;
var DocBackScrollRenderController = class extends RxDisposable {
  constructor(_context, _textSelectionManagerService, _editorService, _docSkeletonManagerService) {
    super();
    this._context = _context;
    this._textSelectionManagerService = _textSelectionManagerService;
    this._editorService = _editorService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._init();
  }
  _init() {
    this._textSelectionManagerService.textSelection$.pipe(takeUntil(this.dispose$)).subscribe((params) => {
      if (params == null) {
        return;
      }
      const { isEditing, unitId } = params;
      if (unitId !== this._context.unitId || !isEditing) {
        return;
      }
      if (this._context.unitId === DOCS_NORMAL_EDITOR_UNIT_ID_KEY) {
        return;
      }
      this._scrollToSelection();
    });
  }
  scrollToRange(range) {
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    if (!skeleton) {
      return;
    }
    const { startOffset } = range;
    const anchorNodePosition = skeleton.findNodePositionByCharIndex(startOffset);
    anchorNodePosition && this.scrollToNode(anchorNodePosition);
  }
  scrollToNode(startNodePosition) {
    var _a;
    const { unitId, scene, mainComponent } = this._context;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    if (mainComponent == null || skeleton == null) {
      return;
    }
    const documentOffsetConfig = mainComponent.getOffsetConfig();
    const { docsLeft, docsTop } = documentOffsetConfig;
    const convertor = new NodePositionConvertToCursor(documentOffsetConfig, skeleton);
    const { contentBoxPointGroup } = convertor.getRangePointData(startNodePosition, startNodePosition);
    const { left: aLeft, top: aTop, height } = getAnchorBounding(contentBoxPointGroup);
    const left = aLeft + docsLeft;
    const top = aTop + docsTop;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const editor = this._editorService.getEditor(unitId);
    if (viewportMain == null) {
      return;
    }
    const {
      left: boundLeft,
      top: boundTop,
      right: boundRight,
      bottom: boundBottom
    } = viewportMain.getBounding().viewBound;
    let offsetY = 0;
    let offsetX = 0;
    const delta = editor ? (_a = editor.params.backScrollOffset) != null ? _a : 0 : 100;
    if (top < boundTop) {
      offsetY = top - boundTop - delta;
    } else if (top > boundBottom - height) {
      offsetY = top - boundBottom + height + delta;
    }
    if (left < boundLeft) {
      offsetX = left - boundLeft;
    } else if (left > boundRight - ANCHOR_WIDTH) {
      offsetX = left - boundRight + ANCHOR_WIDTH;
    }
    const config = viewportMain.transViewportScroll2ScrollValue(offsetX, offsetY);
    viewportMain.scrollByBarDeltaValue(config);
  }
  // Let the selection show on the current screen.
  _scrollToSelection() {
    const activeTextRange = this._textSelectionManagerService.getActiveTextRange();
    if (activeTextRange == null) {
      return;
    }
    const { collapsed, startNodePosition } = activeTextRange;
    if (!collapsed) {
      return;
    }
    this.scrollToNode(startNodePosition);
  }
};
DocBackScrollRenderController = __decorateClass([
  __decorateParam(1, Inject(DocSelectionManagerService)),
  __decorateParam(2, IEditorService),
  __decorateParam(3, Inject(DocSkeletonManagerService))
], DocBackScrollRenderController);

// ../packages/docs-ui/src/controllers/doc-move-cursor.controller.ts
var DocMoveCursorController = class extends Disposable {
  constructor(_univerInstanceService, _renderManagerService, _textSelectionManagerService, _commandService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    this._textSelectionManagerService = _textSelectionManagerService;
    this._commandService = _commandService;
    __publicField(this, "_onInputSubscription");
    this._commandExecutedListener();
  }
  dispose() {
    var _a;
    super.dispose();
    (_a = this._onInputSubscription) == null ? void 0 : _a.unsubscribe();
  }
  _commandExecutedListener() {
    const updateCommandList = [MoveCursorOperation.id, MoveSelectionOperation.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (!updateCommandList.includes(command.id)) {
          return;
        }
        const param = command.params;
        switch (command.id) {
          case MoveCursorOperation.id: {
            return this._handleMoveCursor(param.direction);
          }
          case MoveSelectionOperation.id: {
            return this._handleShiftMoveSelection(param.direction);
          }
          default: {
            throw new Error("Unknown command");
          }
        }
      })
    );
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _handleShiftMoveSelection(direction) {
    var _a, _b, _c;
    const activeRange = this._textSelectionManagerService.getActiveTextRange();
    const allRanges = this._textSelectionManagerService.getTextRanges();
    const docDataModel = this._univerInstanceService.getCurrentUniverDocInstance();
    if (docDataModel == null) {
      return;
    }
    const skeleton = (_a = this._renderManagerService.getRenderById(docDataModel.getUnitId())) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
    const docObject = this._getDocObject();
    if (activeRange == null || skeleton == null || docObject == null) {
      return;
    }
    const {
      startOffset,
      endOffset,
      style,
      collapsed,
      direction: rangeDirection,
      segmentId,
      startNodePosition,
      endNodePosition,
      segmentPage
    } = activeRange;
    if (allRanges.length > 1) {
      let min2 = Number.POSITIVE_INFINITY;
      let max2 = Number.NEGATIVE_INFINITY;
      for (const range of allRanges) {
        min2 = Math.min(min2, range.startOffset);
        max2 = Math.max(max2, range.endOffset);
      }
      this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: direction === 3 /* LEFT */ || direction === 0 /* UP */ ? max2 : min2,
          endOffset: direction === 3 /* LEFT */ || direction === 0 /* UP */ ? min2 : max2,
          style
        }
      ], false);
      return;
    }
    const anchorOffset = collapsed ? startOffset : rangeDirection === "forward" /* FORWARD */ ? startOffset : endOffset;
    let focusOffset = collapsed ? endOffset : rangeDirection === "forward" /* FORWARD */ ? endOffset : startOffset;
    const dataStreamLength = (_b = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody().dataStream.length) != null ? _b : Number.POSITIVE_INFINITY;
    if (direction === 3 /* LEFT */ || direction === 1 /* RIGHT */) {
      const preGlyph = skeleton.findNodeByCharIndex(focusOffset - 1, segmentId, segmentPage);
      const curGlyph = skeleton.findNodeByCharIndex(focusOffset, segmentId, segmentPage);
      focusOffset = direction === 1 /* RIGHT */ ? focusOffset + curGlyph.count : focusOffset - ((_c = preGlyph == null ? void 0 : preGlyph.count) != null ? _c : 0);
      focusOffset = Math.min(dataStreamLength - 2, Math.max(0, focusOffset));
      this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: anchorOffset,
          endOffset: focusOffset,
          style
        }
      ], false);
      this._scrollToFocusNodePosition(docDataModel.getUnitId(), focusOffset);
    } else {
      const focusGlyph = skeleton.findNodeByCharIndex(focusOffset, segmentId, segmentPage);
      const documentOffsetConfig = docObject.document.getOffsetConfig();
      const focusNodePosition = collapsed ? startNodePosition : rangeDirection === "forward" /* FORWARD */ ? endNodePosition : startNodePosition;
      const newPos = this._getTopOrBottomPosition(skeleton, focusGlyph, focusNodePosition, direction === 2 /* DOWN */, true);
      if (newPos == null) {
        const newFocusOffset = direction === 0 /* UP */ ? 0 : dataStreamLength - 2;
        if (newFocusOffset === focusOffset) {
          return;
        }
        this._textSelectionManagerService.replaceTextRanges([
          {
            startOffset: anchorOffset,
            endOffset: newFocusOffset,
            style
          }
        ], false);
        return;
      }
      const newActiveRange = new NodePositionConvertToCursor(documentOffsetConfig, skeleton).getRangePointData(
        newPos,
        newPos
      ).cursorList[0];
      this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: anchorOffset,
          endOffset: newActiveRange.endOffset,
          style
        }
      ], false);
      this._scrollToFocusNodePosition(docDataModel.getUnitId(), newActiveRange.endOffset);
    }
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _handleMoveCursor(direction) {
    var _a, _b, _c, _d;
    const activeRange = this._textSelectionManagerService.getActiveTextRange();
    const allRanges = this._textSelectionManagerService.getTextRanges();
    const docDataModel = this._univerInstanceService.getCurrentUniverDocInstance();
    if (docDataModel == null) {
      return false;
    }
    const skeleton = (_a = this._renderManagerService.getRenderById(docDataModel.getUnitId())) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
    const docObject = this._getDocObject();
    if (activeRange == null || skeleton == null || docObject == null || allRanges == null) {
      return;
    }
    const { startOffset, endOffset, style, collapsed, segmentId, startNodePosition, endNodePosition, segmentPage } = activeRange;
    const body = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
    if (body == null) {
      return;
    }
    const dataStreamLength = (_b = body.dataStream.length) != null ? _b : Number.POSITIVE_INFINITY;
    const customRanges = (_c = docDataModel.getCustomRanges()) != null ? _c : [];
    if (direction === 3 /* LEFT */ || direction === 1 /* RIGHT */) {
      let cursor;
      if (!activeRange.collapsed || allRanges.length > 1) {
        let min2 = Number.POSITIVE_INFINITY;
        let max2 = Number.NEGATIVE_INFINITY;
        for (const range of allRanges) {
          min2 = Math.min(min2, range.startOffset);
          max2 = Math.max(max2, range.endOffset);
        }
        cursor = direction === 3 /* LEFT */ ? min2 : max2;
      } else {
        const preSpan = skeleton.findNodeByCharIndex(startOffset - 1, segmentId, segmentPage);
        const curSpan = skeleton.findNodeByCharIndex(startOffset, segmentId, segmentPage);
        const nextGlyph = skeleton.findNodeByCharIndex(startOffset + 1, segmentId, segmentPage);
        if (direction === 3 /* LEFT */) {
          cursor = Math.max(0, startOffset - ((_d = preSpan == null ? void 0 : preSpan.count) != null ? _d : 1));
        } else {
          cursor = Math.min(dataStreamLength - 2, endOffset + curSpan.count + ((nextGlyph == null ? void 0 : nextGlyph.streamType) === "\n" /* SECTION_BREAK */ ? 1 : 0));
        }
      }
      const skipTokens = [
        "" /* TABLE_START */,
        "" /* TABLE_END */,
        "\x1B" /* TABLE_ROW_START */,
        "" /* TABLE_ROW_END */,
        "" /* TABLE_CELL_START */,
        "" /* TABLE_CELL_END */,
        "\n" /* SECTION_BREAK */
      ];
      if (direction === 3 /* LEFT */) {
        while (skipTokens.includes(body.dataStream[cursor])) {
          cursor--;
        }
      } else {
        while (skipTokens.includes(body.dataStream[cursor])) {
          cursor++;
        }
      }
      const relativeRanges = customRanges.filter((range) => range.wholeEntity && range.startIndex < cursor && range.endIndex >= cursor);
      relativeRanges.forEach((range) => {
        if (direction === 3 /* LEFT */) {
          cursor = Math.min(range.startIndex, cursor);
        } else {
          cursor = Math.max(range.endIndex + 1, cursor);
        }
      });
      this._textSelectionManagerService.replaceTextRanges([
        {
          startOffset: Math.max(0, cursor),
          endOffset: Math.max(0, cursor),
          style
        }
      ], false);
      this._scrollToFocusNodePosition(docDataModel.getUnitId(), cursor);
    } else {
      const startNode = skeleton.findNodeByCharIndex(startOffset, segmentId, segmentPage);
      const endNode = skeleton.findNodeByCharIndex(endOffset, segmentId, segmentPage);
      const documentOffsetConfig = docObject.document.getOffsetConfig();
      const newPos = this._getTopOrBottomPosition(
        skeleton,
        direction === 0 /* UP */ ? startNode : collapsed ? startNode : endNode,
        direction === 0 /* UP */ ? startNodePosition : collapsed ? startNodePosition : endNodePosition,
        direction === 2 /* DOWN */
      );
      if (newPos == null) {
        let cursor;
        if (collapsed) {
          cursor = direction === 0 /* UP */ ? 0 : dataStreamLength - 2;
        } else {
          cursor = direction === 0 /* UP */ ? startOffset : endOffset;
        }
        this._textSelectionManagerService.replaceTextRanges([
          {
            startOffset: Math.max(0, cursor),
            endOffset: Math.max(0, cursor),
            style
          }
        ], false);
        return;
      }
      const newActiveRange = new NodePositionConvertToCursor(documentOffsetConfig, skeleton).getRangePointData(
        newPos,
        newPos
      ).cursorList[0];
      this._textSelectionManagerService.replaceTextRanges([
        {
          ...newActiveRange,
          style
        }
      ], false);
      this._scrollToFocusNodePosition(docDataModel.getUnitId(), newActiveRange.endOffset);
    }
  }
  _getTopOrBottomPosition(docSkeleton, glyph, nodePosition, direction, skipCellContent = false) {
    if (glyph == null || nodePosition == null) {
      return;
    }
    const offsetLeft = this._getGlyphLeftOffsetInLine(glyph);
    const line2 = this._getNextOrPrevLine(glyph, direction, skipCellContent);
    if (line2 == null) {
      return;
    }
    const position = this._matchPositionByLeftOffset(docSkeleton, line2, offsetLeft, nodePosition);
    if (position == null) {
      return;
    }
    return { ...position, isBack: true };
  }
  _getGlyphLeftOffsetInLine(glyph) {
    const divide = glyph.parent;
    if (divide == null) {
      return Number.NEGATIVE_INFINITY;
    }
    const divideLeft = divide.left;
    const { left } = glyph;
    const start = divideLeft + left;
    return start;
  }
  _matchPositionByLeftOffset(docSkeleton, line2, offsetLeft, nodePosition) {
    const nearestNode = {
      distance: Number.POSITIVE_INFINITY
    };
    for (const divide of line2.divides) {
      const divideLeft = divide.left;
      for (const glyph of divide.glyphGroup) {
        if (glyph.streamType === "\n" /* SECTION_BREAK */) {
          continue;
        }
        const { left } = glyph;
        const leftSide = divideLeft + left;
        const distance = Math.abs(offsetLeft - leftSide);
        if (distance < nearestNode.distance) {
          nearestNode.glyph = glyph;
          nearestNode.distance = distance;
        }
      }
    }
    if (nearestNode.glyph == null) {
      return;
    }
    const { segmentPage } = nodePosition;
    return docSkeleton.findPositionByGlyph(nearestNode.glyph, segmentPage);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _getNextOrPrevLine(glyph, direction, skipCellContent = false) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const divide = glyph.parent;
    const line2 = divide == null ? void 0 : divide.parent;
    const column = line2 == null ? void 0 : line2.parent;
    const section = column == null ? void 0 : column.parent;
    const page = section == null ? void 0 : section.parent;
    if (divide == null || line2 == null || column == null || section == null || page == null) {
      return;
    }
    const currentLineIndex = column.lines.indexOf(line2);
    if (currentLineIndex === -1) {
      return;
    }
    let newLine;
    if (page.type === 3 /* CELL */ && skipCellContent) {
      const nLine = findAboveOrBellowCellLine(page, direction);
      if (nLine) {
        return nLine;
      }
    }
    if (direction === true) {
      newLine = column.lines[currentLineIndex + 1];
      const tableAfterLine = findTableAfterLine(line2, page);
      if (tableAfterLine) {
        const firstLine = firstLineInTable(tableAfterLine);
        if (firstLine) {
          newLine = firstLine;
        }
      }
    } else {
      newLine = column.lines[currentLineIndex - 1];
      const tableBeforeLine = findTableBeforeLine(line2, page);
      if (tableBeforeLine) {
        const lastLine = lastLineInTable(tableBeforeLine);
        if (lastLine) {
          newLine = lastLine;
        }
      }
    }
    if (newLine != null) {
      return newLine;
    }
    const currentColumnIndex = section.columns.indexOf(column);
    if (currentColumnIndex === -1) {
      return;
    }
    if (direction === true) {
      newLine = (_a = section.columns[currentColumnIndex + 1]) == null ? void 0 : _a.lines[0];
    } else {
      const prevColumnLines = (_c = (_b = section.columns) == null ? void 0 : _b[currentColumnIndex - 1]) == null ? void 0 : _c.lines;
      newLine = prevColumnLines == null ? void 0 : prevColumnLines[prevColumnLines.length - 1];
    }
    if (newLine != null) {
      return newLine;
    }
    const currentSectionIndex = page.sections.indexOf(section);
    if (currentSectionIndex === -1) {
      return;
    }
    if (direction === true) {
      newLine = (_e = (_d = page.sections[currentSectionIndex - 1]) == null ? void 0 : _d.columns[0]) == null ? void 0 : _e.lines[0];
    } else {
      const prevColumns = (_g = (_f = page.sections) == null ? void 0 : _f[currentSectionIndex - 1]) == null ? void 0 : _g.columns;
      const column2 = prevColumns == null ? void 0 : prevColumns[prevColumns.length - 1];
      const prevColumnLines = column2 == null ? void 0 : column2.lines;
      newLine = prevColumnLines == null ? void 0 : prevColumnLines[prevColumnLines.length - 1];
    }
    if (newLine != null) {
      return newLine;
    }
    if (page.type === 3 /* CELL */) {
      return findAboveOrBellowCellLine(page, direction);
    }
    const skeleton = page.parent;
    if (skeleton == null) {
      return;
    }
    const currentPageIndex = skeleton.pages.indexOf(page);
    if (currentPageIndex === -1) {
      return;
    }
    if (direction === true) {
      newLine = (_j = (_i = (_h = skeleton.pages[currentPageIndex + 1]) == null ? void 0 : _h.sections[0]) == null ? void 0 : _i.columns[0]) == null ? void 0 : _j.lines[0];
    } else {
      const prevSections = (_k = skeleton.pages[currentPageIndex - 1]) == null ? void 0 : _k.sections;
      if (prevSections == null) {
        return;
      }
      const prevColumns = (_l = prevSections[prevSections.length - 1]) == null ? void 0 : _l.columns;
      const column2 = prevColumns[prevColumns.length - 1];
      const prevColumnLines = column2 == null ? void 0 : column2.lines;
      newLine = prevColumnLines[prevColumnLines.length - 1];
    }
    if (newLine != null) {
      return newLine;
    }
  }
  _scrollToFocusNodePosition(unitId, offset) {
    var _a;
    const backScrollController = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocBackScrollRenderController);
    if (backScrollController == null) {
      return;
    }
    backScrollController.scrollToRange({
      startOffset: offset,
      endOffset: offset,
      collapsed: true
    });
  }
  _getDocObject() {
    return getDocObject(this._univerInstanceService, this._renderManagerService);
  }
};
DocMoveCursorController = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, Inject(DocSelectionManagerService)),
  __decorateParam(3, ICommandService)
], DocMoveCursorController);
function findAboveOrBellowCellLine(page, direction) {
  var _a, _b;
  let newLine = null;
  if (direction === true) {
    const bellowCell = findBellowCell(page);
    if (bellowCell) {
      newLine = firstLineInCell(bellowCell);
    } else {
      const table2 = (_a = page.parent) == null ? void 0 : _a.parent;
      const { lineAfterTable } = findLineBeforeAndAfterTable(table2);
      if (lineAfterTable) {
        newLine = lineAfterTable;
      }
    }
  } else {
    const aboveCell = findAboveCell(page);
    if (aboveCell) {
      newLine = lastLineInCell(aboveCell);
    } else {
      const table2 = (_b = page.parent) == null ? void 0 : _b.parent;
      const { lineBeforeTable } = findLineBeforeAndAfterTable(table2);
      if (lineBeforeTable) {
        newLine = lineBeforeTable;
      }
    }
  }
  return newLine;
}

// ../packages/docs-ui/src/views/table/create/TableCreate.tsx
var import_react44 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/docs-ui/src/views/table/create/index.module.less
var index_module_default14 = {
  "create": "univer-create",
  "createItem": "univer-create-item",
  "createLabel": "univer-create-label",
  "createInput": "univer-create-input"
};

// ../packages/docs-ui/src/views/table/create/TableCreate.tsx
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var DocCreateTableConfirm = ({
  handleRowColChange,
  tableCreateParams
}) => {
  const localeService = useDependency(LocaleService);
  const [rowCount, setRowCount] = (0, import_react44.useState)(3);
  const [colCount, setColCount] = (0, import_react44.useState)(5);
  function handleInputChange(rowCount2, colCount2) {
    setRowCount(rowCount2);
    setColCount(colCount2);
    handleRowColChange(rowCount2, colCount2);
  }
  (0, import_react44.useEffect)(() => {
    setRowCount(tableCreateParams.rowCount);
    setColCount(tableCreateParams.colCount);
  }, [tableCreateParams]);
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.create, children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.createItem, children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: index_module_default14.createLabel, children: localeService.t("toolbar.table.rowCount") }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        InputNumber,
        {
          min: 1,
          max: 20,
          precision: 0,
          value: rowCount,
          onChange: (val) => {
            handleInputChange(val, colCount);
          },
          className: index_module_default14.createInput
        }
      )
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.createItem, children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: index_module_default14.createLabel, children: localeService.t("toolbar.table.colCount") }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
        InputNumber,
        {
          min: 1,
          max: 20,
          precision: 0,
          value: colCount,
          onChange: (val) => {
            handleInputChange(rowCount, val);
          },
          className: index_module_default14.createInput
        }
      )
    ] })
  ] });
};

// ../packages/docs-ui/src/controllers/doc-table.controller.ts
var DocTableController = class extends Disposable {
  constructor(_commandService, _componentManager) {
    super();
    this._commandService = _commandService;
    this._componentManager = _componentManager;
    this._initialize();
  }
  _initialize() {
    this._init();
    this._registerCommands();
    this._initCustomComponents();
  }
  _registerCommands() {
    [
      DocCreateTableOperation
    ].forEach((command) => this.disposeWithMe(this._commandService.registerCommand(command)));
  }
  _initCustomComponents() {
    const componentManager = this._componentManager;
    this.disposeWithMe(componentManager.register(COMPONENT_DOC_CREATE_TABLE_CONFIRM, DocCreateTableConfirm));
  }
  _init() {
  }
};
DocTableController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, Inject(ComponentManager))
], DocTableController);

// ../packages/docs-ui/src/components/float-toolbar/FloatToolbar.tsx
var import_react45 = __toESM(require_react());
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var DEFAULT_AVALIABLE_MENUS = [
  SetInlineFormatFontFamilyCommand.id,
  SetInlineFormatFontSizeCommand.id,
  SetInlineFormatBoldCommand.id,
  SetInlineFormatItalicCommand.id,
  SetInlineFormatUnderlineCommand.id,
  SetInlineFormatStrikethroughCommand.id,
  SetInlineFormatSubscriptCommand.id,
  SetInlineFormatSuperscriptCommand.id,
  SetInlineFormatTextColorCommand.id,
  SetInlineFormatTextBackgroundColorCommand.id
];
function FloatToolbar(props) {
  const { avaliableMenus = DEFAULT_AVALIABLE_MENUS } = props;
  const menuManagerService = useDependency(IMenuManagerService);
  const [menus, setMenus] = (0, import_react45.useState)([]);
  (0, import_react45.useEffect)(() => {
    function getRibbon() {
      const flatMenus = menuManagerService.getFlatMenuByPositionKey("ribbon" /* RIBBON */);
      const menus2 = [];
      for (const key of avaliableMenus) {
        const item = flatMenus.find((item2) => item2.key === key);
        if (item) {
          menus2.push(item);
        }
      }
      setMenus(menus2);
    }
    getRibbon();
    const subscription = menuManagerService.menuChanged$.subscribe(getRibbon);
    return () => {
      subscription.unsubscribe();
    };
  }, [menuManagerService]);
  return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    "div",
    {
      className: `
              univer-box-border univer-flex univer-rounded-xl univer-border univer-border-solid univer-border-gray-200
              univer-bg-white univer-p-2
              univer-shadow-[0_1px_6px_-2px_rgba(30,40,77,0.08),0_2px_6px_-1px_rgba(30,40,77,0.10)]
            `,
      children: menus.map((groupItem) => groupItem.item && /* @__PURE__ */ (0, import_jsx_runtime38.jsx)("div", { className: "univer-flex univer-flex-nowrap univer-gap-2 univer-px-2", children: /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ToolbarItem, { ...groupItem.item }, groupItem.key) }, groupItem.key))
    }
  );
}

// ../packages/docs-ui/src/services/doc-popup-manager.service.ts
function transformBound2OffsetBound(originBound, scene) {
  const topLeft = transformPosition2Offset(originBound.left, originBound.top, scene);
  const bottomRight = transformPosition2Offset(originBound.right, originBound.bottom, scene);
  return {
    left: topLeft.x,
    top: topLeft.y,
    right: bottomRight.x,
    bottom: bottomRight.y
  };
}
function transformPosition2Offset(x, y, scene) {
  const { scaleX, scaleY } = scene.getAncestorScale();
  const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
  if (!viewMain) {
    return {
      x,
      y
    };
  }
  const { viewportScrollX: actualScrollX, viewportScrollY: actualScrollY } = viewMain;
  const offsetX = (x - actualScrollX) * scaleX;
  const offsetY = (y - actualScrollY) * scaleY;
  return {
    x: offsetX,
    y: offsetY
  };
}
function transformOffset2Bound(offsetX, offsetY, scene) {
  const { scaleX, scaleY } = scene.getAncestorScale();
  const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
  if (!viewMain) {
    return {
      x: offsetX,
      y: offsetY
    };
  }
  const { viewportScrollX: actualScrollX, viewportScrollY: actualScrollY } = viewMain;
  const x = offsetX / scaleX + actualScrollX;
  const y = offsetY / scaleY + actualScrollY;
  return {
    x,
    y
  };
}
var calcDocRangePositions = (range, currentRender) => {
  const { scene, mainComponent, engine } = currentRender;
  const skeleton = currentRender.with(DocSkeletonManagerService).getSkeleton();
  const startPosition = skeleton.findNodePositionByCharIndex(range.startOffset, true, range.segmentId, range.segmentPage);
  const endPosition = skeleton.findNodePositionByCharIndex(range.endOffset, true, range.segmentId, range.segmentPage);
  const document2 = mainComponent;
  if (!endPosition || !startPosition) {
    return;
  }
  const documentOffsetConfig = document2.getOffsetConfig();
  const { docsLeft, docsTop } = documentOffsetConfig;
  const canvasElement = engine.getCanvasElement();
  const canvasClientRect = canvasElement.getBoundingClientRect();
  const widthOfCanvas = pxToNum(canvasElement.style.width);
  const { top, left, width } = canvasClientRect;
  const scaleAdjust = width / widthOfCanvas;
  const { scaleX, scaleY } = scene.getAncestorScale();
  const convertor = new NodePositionConvertToCursor(documentOffsetConfig, skeleton);
  const { borderBoxPointGroup } = convertor.getRangePointData(startPosition, endPosition);
  const bounds = getLineBounding(borderBoxPointGroup);
  const res = bounds.map((bound) => transformBound2OffsetBound(bound, scene)).map((i) => ({
    left: (i.left + docsLeft * scaleX) * scaleAdjust + left,
    right: (i.right + docsLeft * scaleX) * scaleAdjust + left,
    top: (i.top + docsTop * scaleY) * scaleAdjust + top,
    bottom: (i.bottom + docsTop * scaleY) * scaleAdjust + top
  }));
  return res;
};
var DocCanvasPopManagerService = class extends Disposable {
  constructor(_globalPopupManagerService, _renderManagerService, _univerInstanceService, _commandService) {
    super();
    this._globalPopupManagerService = _globalPopupManagerService;
    this._renderManagerService = _renderManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._commandService = _commandService;
  }
  _createObjectPositionObserver(targetObject, currentRender) {
    const calc = () => {
      const { scene, engine } = currentRender;
      const { left, top, width, height } = targetObject;
      const bound = {
        left,
        right: left + width,
        top,
        bottom: top + height
      };
      const canvasElement = engine.getCanvasElement();
      const canvasClientRect = canvasElement.getBoundingClientRect();
      const widthOfCanvas = pxToNum(canvasElement.style.width);
      const offsetBound = transformBound2OffsetBound(bound, scene);
      const { top: topOffset, left: leftOffset, width: domWidth } = canvasClientRect;
      const scaleAdjust = domWidth / widthOfCanvas;
      const position2 = {
        left: offsetBound.left * scaleAdjust + leftOffset,
        right: offsetBound.right * scaleAdjust + leftOffset,
        top: offsetBound.top * scaleAdjust + topOffset,
        bottom: offsetBound.bottom * scaleAdjust + topOffset
      };
      return position2;
    };
    const position = calc();
    const position$ = new BehaviorSubject(position);
    const disposable = new DisposableCollection();
    disposable.add(this._commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetDocZoomRatioOperation.id || commandInfo.id === RichTextEditingMutation.id) {
        const newPosition = calc();
        if (newPosition) {
          position$.next(newPosition);
        }
      }
    }));
    const viewMain = currentRender.scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (viewMain) {
      disposable.add(viewMain.onScrollAfter$.subscribeEvent(() => {
        position$.next(calc());
      }));
    }
    return {
      position,
      position$,
      disposable
    };
  }
  _createRangePositionObserver(range, currentRender) {
    var _a;
    const positions = (_a = calcDocRangePositions(range, currentRender)) != null ? _a : [];
    const positions$ = new BehaviorSubject(positions);
    const disposable = new DisposableCollection();
    disposable.add(this._commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetDocZoomRatioOperation.id || commandInfo.id === RichTextEditingMutation.id) {
        const params = commandInfo.params;
        if (params.unitId === currentRender.unitId) {
          const position = calcDocRangePositions(range, currentRender);
          if (position) {
            positions$.next(position);
          }
        }
      }
    }));
    const viewMain = currentRender.scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (viewMain) {
      disposable.add(viewMain.onScrollAfter$.subscribeEvent(() => {
        const position = calcDocRangePositions(range, currentRender);
        if (position) {
          positions$.next(position);
        }
      }));
    }
    return {
      positions,
      positions$,
      disposable
    };
  }
  // #region attach to object
  /**
   * attach a popup to canvas object
   * @param targetObject target canvas object
   * @param popup popup item
   * @returns disposable
   */
  attachPopupToObject(targetObject, popup, unitId) {
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (!currentRender) {
      throw new Error(`Current render not found, unitId: ${unitId}`);
    }
    const { position, position$, disposable } = this._createObjectPositionObserver(targetObject, currentRender);
    const id = this._globalPopupManagerService.addPopup({
      ...popup,
      unitId,
      subUnitId: "default",
      anchorRect: position,
      anchorRect$: position$,
      canvasElement: currentRender.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(id);
        position$.complete();
        disposable.dispose();
      }
    };
  }
  // #endregion
  // #region attach to range
  /**
   * attach a popup to doc range
   * @param range doc range
   * @param popup popup item
   * @param unitId unit id
   * @returns disposable
   */
  attachPopupToRange(range, popup, unitId) {
    const doc = this._univerInstanceService.getUnit(unitId);
    if (!doc) {
      throw new Error(`Document not found, unitId: ${unitId}`);
    }
    const { direction = "top", multipleDirection } = popup;
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (!currentRender) {
      throw new Error(`Current render not found, unitId: ${unitId}`);
    }
    const { positions: bounds, positions$: bounds$, disposable } = this._createRangePositionObserver(range, currentRender);
    const position$ = bounds$.pipe(map((bounds2) => direction.includes("top") ? bounds2[0] : bounds2[bounds2.length - 1]));
    const id = this._globalPopupManagerService.addPopup({
      ...popup,
      unitId,
      subUnitId: "default",
      anchorRect: direction.includes("top") ? bounds[0] : bounds[bounds.length - 1],
      anchorRect$: position$,
      excludeRects: bounds,
      excludeRects$: bounds$,
      direction: ["top", "bottom", "horizontal"].some((i) => direction.includes(i)) ? bounds.length > 1 ? multipleDirection != null ? multipleDirection : direction : direction : "bottom",
      canvasElement: currentRender.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(id);
        bounds$.complete();
        disposable.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== id
    };
  }
  // #endregion
};
DocCanvasPopManagerService = __decorateClass([
  __decorateParam(0, Inject(ICanvasPopupService)),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, IUniverInstanceService),
  __decorateParam(3, ICommandService)
], DocCanvasPopManagerService);

// ../packages/docs-ui/src/controllers/float-menu.controller.ts
var FLOAT_MENU_COMPONENT_KEY = "univer.doc.float-menu";
var FloatMenuController = class extends Disposable {
  constructor(_docSelectionManagerService, _docCanvasPopManagerService, _componentManager, _univerInstanceService) {
    super();
    this._docSelectionManagerService = _docSelectionManagerService;
    this._docCanvasPopManagerService = _docCanvasPopManagerService;
    this._componentManager = _componentManager;
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_floatMenu", null);
    this._registerFloatMenu();
    this._initSelectionChange();
  }
  _registerFloatMenu() {
    this.disposeWithMe(this._componentManager.register(FLOAT_MENU_COMPONENT_KEY, FloatToolbar));
  }
  _initSelectionChange() {
    this.disposeWithMe(this._docSelectionManagerService.textSelection$.subscribe((selection) => {
      const { unitId, textRanges } = selection;
      if (isInternalEditorID(unitId)) {
        this.hideFloatMenu();
        return;
      }
      if (textRanges.length > 0 && textRanges.some((range) => !range.collapsed)) {
        this.hideFloatMenu();
        this.showFloatMenu(unitId, textRanges.find((range) => !range.collapsed));
      } else {
        this.hideFloatMenu();
      }
    }));
  }
  hideFloatMenu() {
    var _a;
    (_a = this._floatMenu) == null ? void 0 : _a.dispose();
    this._floatMenu = null;
  }
  showFloatMenu(unitId, range) {
    const documentDataModel = this._univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    if (!documentDataModel || documentDataModel.getDisabled()) {
      return;
    }
    this._floatMenu = this._docCanvasPopManagerService.attachPopupToRange(
      range,
      {
        componentKey: FLOAT_MENU_COMPONENT_KEY,
        direction: range.direction === "backward" ? "top-center" : "bottom-center",
        offset: [0, 4]
      },
      unitId
    );
    return toDisposable(() => this.hideFloatMenu());
  }
};
FloatMenuController = __decorateClass([
  __decorateParam(0, Inject(DocSelectionManagerService)),
  __decorateParam(1, Inject(DocCanvasPopManagerService)),
  __decorateParam(2, Inject(ComponentManager)),
  __decorateParam(3, Inject(IUniverInstanceService))
], FloatMenuController);

// ../packages/docs-ui/src/types/const/padding.ts
var DOC_VERTICAL_PADDING = 4;

// ../packages/docs-ui/src/services/doc-event-manager.service.ts
var calcDocRangePositions2 = (range, documents, skeleton, pageIndex) => {
  var _a, _b, _c, _d, _e;
  const startPosition = skeleton.findNodePositionByCharIndex(range.startOffset, true, range.segmentId, pageIndex);
  const skeletonData = skeleton.getSkeletonData();
  let end = range.endOffset;
  if (range.segmentId) {
    const root = (_e = Array.from((_b = (_a = skeletonData == null ? void 0 : skeletonData.skeFooters.get(range.segmentId)) == null ? void 0 : _a.values()) != null ? _b : [])[0]) != null ? _e : Array.from((_d = (_c = skeletonData == null ? void 0 : skeletonData.skeHeaders.get(range.segmentId)) == null ? void 0 : _c.values()) != null ? _d : [])[0];
    if (root) {
      end = Math.min(root.ed, end);
    }
  }
  const endPosition = skeleton.findNodePositionByCharIndex(end, true, range.segmentId, pageIndex);
  if (!endPosition || !startPosition) {
    return;
  }
  const documentOffsetConfig = documents.getOffsetConfig();
  const convertor = new NodePositionConvertToCursor(documentOffsetConfig, skeleton);
  const { borderBoxPointGroup } = convertor.getRangePointData(startPosition, endPosition);
  const bounds = getLineBounding(borderBoxPointGroup);
  return bounds.map((rect) => ({
    top: rect.top + documentOffsetConfig.docsTop - DOC_VERTICAL_PADDING,
    bottom: rect.bottom + documentOffsetConfig.docsTop + DOC_VERTICAL_PADDING,
    left: rect.left + documentOffsetConfig.docsLeft,
    right: rect.right + documentOffsetConfig.docsLeft
  }));
};
var calcDocGlyphPosition = (glyph, documents, skeleton, pageIndex = -1) => {
  const start = skeleton.findPositionByGlyph(glyph, pageIndex);
  if (!start) {
    return;
  }
  const documentOffsetConfig = documents.getOffsetConfig();
  const startPosition = { ...start, isBack: true };
  const convertor = new NodePositionConvertToCursor(documentOffsetConfig, skeleton);
  const { borderBoxPointGroup } = convertor.getRangePointData(startPosition, startPosition);
  const bounds = getLineBounding(borderBoxPointGroup);
  const rect = bounds[0];
  return {
    top: rect.top + documentOffsetConfig.docsTop,
    bottom: rect.bottom + documentOffsetConfig.docsTop,
    left: rect.left + documentOffsetConfig.docsLeft,
    right: rect.left + documentOffsetConfig.docsLeft + glyph.width
  };
};
var DocEventManagerService = class extends Disposable {
  constructor(_context, _docSkeletonManagerService) {
    super();
    this._context = _context;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    __publicField(this, "_hoverCustomRanges$", new BehaviorSubject([]));
    __publicField(this, "hoverCustomRanges$", this._hoverCustomRanges$.pipe(distinctUntilChanged((pre, aft) => pre.length === aft.length && pre.every((item, i) => aft[i].range.rangeId === item.range.rangeId && aft[i].segmentId === item.segmentId && aft[i].segmentPageIndex === item.segmentPageIndex && aft[i].range.startIndex === item.range.startIndex))));
    __publicField(this, "_clickCustomRanges$", new Subject());
    __publicField(this, "clickCustomRanges$", this._clickCustomRanges$.asObservable());
    __publicField(this, "_hoverBullet$", new Subject());
    __publicField(this, "hoverBullet$", this._hoverBullet$.pipe(distinctUntilChanged((pre, aft) => (pre == null ? void 0 : pre.paragraph.startIndex) === (aft == null ? void 0 : aft.paragraph.startIndex) && (pre == null ? void 0 : pre.segmentId) === (aft == null ? void 0 : aft.segmentId) && (pre == null ? void 0 : pre.segmentPageIndex) === (aft == null ? void 0 : aft.segmentPageIndex))));
    __publicField(this, "_clickBullet$", new Subject());
    __publicField(this, "clickBullets$", this._clickBullet$.asObservable());
    __publicField(this, "_customRangeDirty", true);
    __publicField(this, "_bulletDirty", true);
    /**
     * cache the bounding of custom ranges,
     * it will be updated when the doc-skeleton is recalculated
     */
    __publicField(this, "_customRangeBounds", []);
    /**
     * cache the bounding of bullets,
     * it will be updated when the doc-skeleton is recalculated
     */
    __publicField(this, "_bulletBounds", []);
    this._initResetDirty();
    this._initEvents();
    this._initPointer();
  }
  get _skeleton() {
    return this._docSkeletonManagerService.getSkeleton();
  }
  get _documents() {
    return this._context.mainComponent;
  }
  dispose() {
    this._hoverCustomRanges$.complete();
    this._clickCustomRanges$.complete();
    super.dispose();
  }
  _initPointer() {
    let preCursor = "text" /* TEXT */;
    this.disposeWithMe(this.hoverCustomRanges$.subscribe((ranges) => {
      if (ranges.length) {
        preCursor = this._context.scene.getCursor();
        this._context.scene.setCursor("pointer" /* POINTER */);
      } else {
        this._context.scene.setCursor(preCursor);
      }
    }));
  }
  _initResetDirty() {
    this.disposeWithMe(this._skeleton.dirty$.subscribe(() => {
      this._customRangeDirty = true;
      this._bulletDirty = true;
    }));
    this.disposeWithMe(
      fromEventSubject(this._context.engine.onTransformChange$).pipe(
        filter((evt) => evt.type === 1 /* resize */)
      ).subscribe(() => {
        this._customRangeDirty = true;
        this._bulletDirty = true;
      })
    );
  }
  _initEvents() {
    this.disposeWithMe(fromEventSubject(this._context.scene.onPointerMove$).pipe(throttleTime(30)).subscribe((evt) => {
      this._hoverCustomRanges$.next(
        this._calcActiveRanges(evt)
      );
      this._hoverBullet$.next(
        this._calcActiveBullet(evt)
      );
    }));
    this.disposeWithMe(this._context.scene.onPointerEnter$.subscribeEvent(() => {
      this._hoverBullet$.next(null);
      this._hoverCustomRanges$.next([]);
    }));
    const onPointerDown$ = fromEventSubject(this._context.mainComponent.onPointerDown$);
    const onPointerUp$ = fromEventSubject(this._context.scene.onPointerUp$);
    this.disposeWithMe(onPointerDown$.pipe(
      switchMap((down) => onPointerUp$.pipe(take(1), map((up) => ({ down, up })))),
      filter(({ down, up }) => down.target === up.target && up.timeStamp - down.timeStamp < 300)
      // filter(({ down, up }) => down.offsetX === up.offsetX && down.offsetY === up.offsetY)
    ).subscribe(({ down }) => {
      if (down.button === 2) {
        return;
      }
      const ranges = this._calcActiveRanges(down);
      if (ranges.length) {
        this._clickCustomRanges$.next(ranges.pop());
      }
      const bullet = this._calcActiveBullet(down);
      if (bullet) {
        this._clickBullet$.next(bullet);
      }
    }));
  }
  _buildCustomRangeBoundsBySegment(segmentId, segmentPage = -1) {
    var _a, _b, _c;
    const customRanges = (_c = (_b = (_a = this._context.unit.getSelfOrHeaderFooterModel(segmentId)) == null ? void 0 : _a.getBody()) == null ? void 0 : _b.customRanges) != null ? _c : [];
    const layouts = [];
    customRanges.forEach((range) => {
      const textRange = {
        startOffset: range.startIndex,
        endOffset: range.endIndex + 1,
        collapsed: false,
        segmentId
      };
      const rects = calcDocRangePositions2(textRange, this._documents, this._skeleton, segmentPage);
      if (!rects) {
        return null;
      }
      layouts.push({
        customRange: range,
        rects,
        segmentId,
        segmentPageIndex: segmentPage
      });
    });
    return layouts;
  }
  _buildCustomRangeBounds() {
    var _a;
    if (!this._customRangeDirty) {
      return;
    }
    this._customRangeDirty = false;
    const customRangeBounds = [];
    customRangeBounds.push(...this._buildCustomRangeBoundsBySegment());
    (_a = this._skeleton.getSkeletonData()) == null ? void 0 : _a.pages.forEach((page, pageIndex) => {
      if (page.headerId) {
        customRangeBounds.push(...this._buildCustomRangeBoundsBySegment(page.headerId, pageIndex));
      }
      if (page.footerId) {
        customRangeBounds.push(...this._buildCustomRangeBoundsBySegment(page.footerId, pageIndex));
      }
    });
    this._customRangeBounds = customRangeBounds;
  }
  _calcActiveRanges(evt) {
    this._buildCustomRangeBounds();
    const { offsetX, offsetY } = evt;
    const { x, y } = transformOffset2Bound(offsetX, offsetY, this._context.scene);
    const matchedRanges = this._customRangeBounds.filter((layout) => {
      return layout.rects.some((rect) => {
        const { left, right, top, bottom } = rect;
        if (x >= left && x <= right && y >= top && y <= bottom) {
          return true;
        }
        return false;
      });
    });
    return matchedRanges.map(
      (range) => ({
        segmentId: range.segmentId,
        range: range.customRange,
        segmentPageIndex: range.segmentPageIndex,
        rects: range.rects
      })
    );
  }
  _buildBulletBoundsBySegment(segmentId, segmentPage = -1) {
    var _a, _b, _c, _d, _e;
    const body = (_a = this._context.unit.getSelfOrHeaderFooterModel(segmentId)) == null ? void 0 : _a.getBody();
    const paragraphs = ((_b = body == null ? void 0 : body.paragraphs) != null ? _b : []).filter((p) => p.bullet && p.bullet.listType.indexOf("CHECK_LIST") === 0);
    const bounds = [];
    const skeletonData = this._skeleton.getSkeletonData();
    if (!skeletonData) {
      return bounds;
    }
    const calc = (pages) => {
      var _a2, _b2, _c2;
      for (const page of pages) {
        const sections = [...page.sections];
        if (page.skeTables) {
          const tables = Array.from(page.skeTables.values());
          sections.push(...tables.map((i) => i.rows.map((i2) => i2.cells.map((i3) => i3.sections))).flat(4));
        }
        for (const selection of sections) {
          for (const column of selection.columns) {
            for (const line2 of column.lines) {
              if (line2.paragraphStart) {
                const paragraph = paragraphs.find((p) => p.startIndex === line2.paragraphIndex);
                if (paragraph) {
                  const targetLine = line2;
                  const bulletNode = (_c2 = (_b2 = (_a2 = targetLine == null ? void 0 : targetLine.divides) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.glyphGroup) == null ? void 0 : _c2[0];
                  if (!bulletNode) {
                    continue;
                  }
                  const rect = calcDocGlyphPosition(bulletNode, this._documents, this._skeleton, segmentPage);
                  if (!rect) {
                    continue;
                  }
                  bounds.push({
                    rect,
                    segmentId,
                    segmentPageIndex: segmentPage,
                    paragraph
                  });
                }
              }
            }
          }
        }
      }
      return bounds;
    };
    if (segmentId) {
      const page = (_e = (_c = skeletonData.skeFooters.get(segmentId)) == null ? void 0 : _c.values()) != null ? _e : (_d = skeletonData.skeHeaders.get(segmentId)) == null ? void 0 : _d.values();
      if (!page) {
        return bounds;
      }
      return calc(Array.from(page));
    }
    return calc(skeletonData.pages);
  }
  _buildBulletBounds() {
    var _a;
    if (!this._bulletDirty) {
      return;
    }
    this._bulletDirty = false;
    this._bulletBounds = [];
    this._bulletBounds.push(...this._buildBulletBoundsBySegment());
    (_a = this._skeleton.getSkeletonData()) == null ? void 0 : _a.pages.forEach((page, pageIndex) => {
      if (page.headerId) {
        this._bulletBounds.push(...this._buildBulletBoundsBySegment(page.headerId, pageIndex));
      }
      if (page.footerId) {
        this._bulletBounds.push(...this._buildBulletBoundsBySegment(page.footerId, pageIndex));
      }
    });
  }
  _calcActiveBullet(evt) {
    this._buildBulletBounds();
    const { offsetX, offsetY } = evt;
    const { x, y } = transformOffset2Bound(offsetX, offsetY, this._context.scene);
    const bullet = this._bulletBounds.find((layout) => {
      const { left, right, top, bottom } = layout.rect;
      if (x >= left && x <= right && y >= top && y <= bottom) {
        return true;
      }
      return false;
    });
    return bullet;
  }
};
DocEventManagerService = __decorateClass([
  __decorateParam(1, Inject(DocSkeletonManagerService))
], DocEventManagerService);

// ../packages/docs-ui/src/controllers/render-controllers/doc-checklist.render-controller.ts
var DocChecklistRenderController = class extends Disposable {
  constructor(_context, _docSkeletonManagerService, _commandService, _docEventManagerService, _textSelectionManagerService) {
    super();
    this._context = _context;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._commandService = _commandService;
    this._docEventManagerService = _docEventManagerService;
    this._textSelectionManagerService = _textSelectionManagerService;
    this._initPointerDownObserver();
    this._initHoverCursor();
  }
  _initPointerDownObserver() {
    this._docEventManagerService.clickBullets$.subscribe((paragraph) => {
      const textRanges = this._textSelectionManagerService.getTextRanges();
      this._commandService.executeCommand(ToggleCheckListCommand.id, {
        index: paragraph.paragraph.startIndex,
        segmentId: paragraph.segmentId,
        textRanges
      });
    });
  }
  _initHoverCursor() {
    this.disposeWithMe(
      this._docEventManagerService.hoverBullet$.subscribe((paragraph) => {
        if (paragraph) {
          this._context.mainComponent.setCursor("pointer" /* POINTER */);
        } else {
          this._context.mainComponent.setCursor("text" /* TEXT */);
        }
      })
    );
  }
  _getTransformCoordForDocumentOffset(document2, viewport, evtOffsetX, evtOffsetY) {
    const { documentTransform } = document2.getOffsetConfig();
    const originCoord = viewport.transformVector2SceneCoord(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    if (!originCoord) {
      return;
    }
    return documentTransform.clone().invert().applyPoint(originCoord);
  }
};
DocChecklistRenderController = __decorateClass([
  __decorateParam(1, Inject(DocSkeletonManagerService)),
  __decorateParam(2, ICommandService),
  __decorateParam(3, Inject(DocEventManagerService)),
  __decorateParam(4, Inject(DocSelectionManagerService))
], DocChecklistRenderController);

// ../packages/docs-ui/src/controllers/render-controllers/doc-clipboard.controller.ts
var DocClipboardController = class extends RxDisposable {
  constructor(_context, _commandService, _docClipboardService, _docSelectionRenderService, _contextService, _editorService) {
    super();
    this._context = _context;
    this._commandService = _commandService;
    this._docClipboardService = _docClipboardService;
    this._docSelectionRenderService = _docSelectionRenderService;
    this._contextService = _contextService;
    this._editorService = _editorService;
    this._init();
  }
  _init() {
    this._initLegacyPasteCommand();
  }
  _initLegacyPasteCommand() {
    var _a;
    (_a = this._docSelectionRenderService) == null ? void 0 : _a.onPaste$.pipe(takeUntil(this.dispose$)).subscribe((config) => {
      var _a2, _b, _c;
      if (!whenDocOrEditor(this._contextService)) {
        return;
      }
      config.event.preventDefault();
      const clipboardEvent = config.event;
      let htmlContent = (_a2 = clipboardEvent.clipboardData) == null ? void 0 : _a2.getData(HTML_CLIPBOARD_MIME_TYPE);
      const textContent = (_b = clipboardEvent.clipboardData) == null ? void 0 : _b.getData(PLAIN_TEXT_CLIPBOARD_MIME_TYPE);
      const files = [...((_c = clipboardEvent.clipboardData) == null ? void 0 : _c.items) || []].filter((item) => imageMimeTypeSet.has(item.type)).map((item) => item.getAsFile()).filter((e) => !!e);
      const editor = this._editorService.getEditor(this._context.unitId);
      if (!!editor && (htmlContent != null ? htmlContent : "").indexOf("</table>") > -1) {
        htmlContent = "";
      }
      this._docClipboardService.legacyPaste({ html: htmlContent, text: textContent, files });
    });
  }
};
DocClipboardController = __decorateClass([
  __decorateParam(1, ICommandService),
  __decorateParam(2, IDocClipboardService),
  __decorateParam(3, Inject(DocSelectionRenderService)),
  __decorateParam(4, IContextService),
  __decorateParam(5, IEditorService)
], DocClipboardController);

// ../packages/docs-ui/src/controllers/render-controllers/doc-contextmenu.render-controller.ts
var SKIP_UNIT_IDS = [
  DEFAULT_EMPTY_DOCUMENT_VALUE,
  DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
  DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
  DOCS_ZEN_EDITOR_UNIT_ID_KEY
];
var DocContextMenuRenderController = class extends Disposable {
  constructor(_context, _contextMenuService, _commandService) {
    super();
    this._context = _context;
    this._contextMenuService = _contextMenuService;
    this._commandService = _commandService;
    if (!SKIP_UNIT_IDS.includes(this._context.unitId)) {
      this._initPointerDown();
      this._initEditChange();
    }
  }
  _initPointerDown() {
    var _a, _b;
    const documentsPointerDownObserver = (_b = (_a = this._context) == null ? void 0 : _a.mainComponent) == null ? void 0 : _b.onPointerDown$;
    const documentsSubscription = documentsPointerDownObserver.subscribeEvent((event) => {
      if (event.button === 2) {
        this._contextMenuService.triggerContextMenu(event, "contextMenu.mainArea" /* MAIN_AREA */);
      }
    });
    this.disposeWithMe(documentsSubscription);
  }
  _initEditChange() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === RichTextEditingMutation.id) {
          if (this._contextMenuService.visible) {
            this._contextMenuService.hideContextMenu();
          }
        }
      })
    );
  }
};
DocContextMenuRenderController = __decorateClass([
  __decorateParam(1, IContextMenuService),
  __decorateParam(2, ICommandService)
], DocContextMenuRenderController);

// ../packages/docs-ui/src/controllers/render-controllers/doc-editor-bridge.controller.ts
var DocEditorBridgeController = class extends Disposable {
  constructor(_context, _univerInstanceService, _editorService, _commandService, _docSelectionRenderService, _docSkeletonManagerService, _renderManagerService) {
    super();
    this._context = _context;
    this._univerInstanceService = _univerInstanceService;
    this._editorService = _editorService;
    this._commandService = _commandService;
    this._docSelectionRenderService = _docSelectionRenderService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_initialEditors", /* @__PURE__ */ new Set());
    this._initialize();
  }
  _initialize() {
    this._editorService.getAllEditor().forEach((editor) => {
      const unitId = editor.getEditorId();
      if (unitId !== this._context.unitId) {
        return;
      }
      if (this._initialEditors.has(unitId)) {
        return;
      }
      this._initialEditors.add(unitId);
      this._resize(unitId);
    });
    this._commandExecutedListener();
    this._initialBlur();
    this._initialFocus();
  }
  _resize(unitId) {
    if (unitId == null) {
      return;
    }
    const editor = this._editorService.getEditor(unitId);
    if ((editor == null ? void 0 : editor.cancelDefaultResizeListener) === true) {
      return;
    }
    const editorDataModel = this._univerInstanceService.getUniverDocInstance(unitId);
    if (!editorDataModel) {
      return;
    }
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    if (editor == null || editor.render == null || skeleton == null || editorDataModel == null) {
      return;
    }
    skeleton.calculate();
    const { marginTop = 0, marginBottom = 0, marginLeft = 0, marginRight = 0 } = editorDataModel.getSnapshot().documentStyle;
    const { scene, mainComponent } = editor.render;
    let { actualHeight, actualWidth } = skeleton.getActualSize();
    actualHeight += marginTop + marginBottom;
    actualWidth += marginLeft + marginRight;
    const { width, height } = editor.getBoundingClientRect();
    const contentWidth = Math.max(actualWidth, width);
    const contentHeight = Math.max(actualHeight, height);
    scene.transformByState({
      width: contentWidth,
      height: contentHeight
    });
    mainComponent == null ? void 0 : mainComponent.resize(contentWidth, contentHeight);
  }
  _initialBlur() {
    this.disposeWithMe(
      this._editorService.blur$.subscribe(() => {
        this._docSelectionRenderService.blur();
      })
    );
    this.disposeWithMe(
      this._docSelectionRenderService.onBlur$.subscribe(() => {
        const { unitId } = this._context;
        const editor = this._editorService.getEditor(unitId);
        const focusEditor = this._editorService.getFocusEditor();
        if (editor == null || editor.isSheetEditor() || focusEditor && focusEditor.getEditorId() === unitId) {
          return;
        }
        if (unitId.includes("range_selector") || unitId.includes("embedding_formula_editor")) {
          return;
        }
        this._editorService.blur();
      })
    );
  }
  _initialFocus() {
    const focusExcepts = [
      "univer-formula-search",
      "univer-formula-help",
      "formula-help-decorator",
      "univer-formula-help-param"
    ];
    this.disposeWithMe(
      fromEvent(window, "mousedown").subscribe((event) => {
        const target = event.target;
        const hasSearch = target.classList[0] || "";
        if (checkForSubstrings(hasSearch, focusExcepts)) {
          event.stopPropagation();
        }
      })
    );
    const disposableCollection = new DisposableCollection();
    this.disposeWithMe(
      this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).subscribe((unit) => {
        disposableCollection.dispose();
        if (!unit) {
          return;
        }
        const unitId = unit.getUnitId();
        const render2 = this._renderManagerService.getRenderById(unitId);
        const canvasEle = render2 == null ? void 0 : render2.engine.getCanvas().getCanvasEle();
        if (canvasEle == null) {
          return;
        }
        const disposable = fromEvent(canvasEle, "mousedown").subscribe((evt) => {
          evt.stopPropagation();
        });
        disposableCollection.add(disposable);
      })
    );
    this.disposeWithMe(() => disposableCollection.dispose());
  }
  /**
   * Listen to document edits to refresh the size of the formula editor.
   */
  _commandExecutedListener() {
    const updateCommandList = [RichTextEditingMutation.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (updateCommandList.includes(command.id)) {
          const params = command.params;
          const { unitId } = params;
          if (this._editorService.isSheetEditor(unitId) || unitId !== this._context.unitId) {
            return;
          }
          const editor = this._editorService.getEditor(unitId);
          if (editor && !editor.params.scrollBar) {
            this._resize(unitId);
          }
        }
      })
    );
  }
};
DocEditorBridgeController = __decorateClass([
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IEditorService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, Inject(DocSelectionRenderService)),
  __decorateParam(5, Inject(DocSkeletonManagerService)),
  __decorateParam(6, IRenderManagerService)
], DocEditorBridgeController);

// ../packages/docs-ui/src/controllers/render-controllers/doc-ime-input.controller.ts
var DocIMEInputController = class extends Disposable {
  constructor(_context, _docSelectionRenderService, _docImeInputManagerService, _docSkeletonManagerService, _commandService) {
    super();
    this._context = _context;
    this._docSelectionRenderService = _docSelectionRenderService;
    this._docImeInputManagerService = _docImeInputManagerService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._commandService = _commandService;
    __publicField(this, "_previousIMEContent", "");
    __publicField(this, "_isCompositionStart", true);
    __publicField(this, "_onStartSubscription");
    __publicField(this, "_onUpdateSubscription");
    __publicField(this, "_onEndSubscription");
    this._initialize();
  }
  dispose() {
    var _a, _b, _c;
    (_a = this._onStartSubscription) == null ? void 0 : _a.unsubscribe();
    (_b = this._onUpdateSubscription) == null ? void 0 : _b.unsubscribe();
    (_c = this._onEndSubscription) == null ? void 0 : _c.unsubscribe();
  }
  _initialize() {
    this._initialOnCompositionstart();
    this._initialOnCompositionUpdate();
    this._initialOnCompositionend();
  }
  _initialOnCompositionstart() {
    this._onStartSubscription = this._docSelectionRenderService.onCompositionstart$.subscribe((config) => {
      if (config == null) {
        return;
      }
      this._resetIME();
      const { activeRange } = config;
      if (activeRange == null) {
        return;
      }
      this._docImeInputManagerService.setActiveRange(Tools.deepClone(activeRange));
    });
  }
  _initialOnCompositionUpdate() {
    this._onUpdateSubscription = this._docSelectionRenderService.onCompositionupdate$.subscribe((config) => {
      this._updateContent(config, true);
    });
  }
  _initialOnCompositionend() {
    this._onEndSubscription = this._docSelectionRenderService.onCompositionend$.subscribe((config) => {
      this._updateContent(config, false);
    });
  }
  async _updateContent(config, isUpdate) {
    if (config == null) {
      return;
    }
    const unitId = this._context.unitId;
    const skeleton = this._docSkeletonManagerService.getSkeleton();
    const { event, activeRange } = config;
    if (skeleton == null || activeRange == null) {
      return;
    }
    const e = event;
    const content = e.data;
    if (content === this._previousIMEContent && isUpdate) {
      return;
    }
    await this._commandService.executeCommand(IMEInputCommand.id, {
      unitId,
      newText: content,
      oldTextLen: this._previousIMEContent.length,
      isCompositionStart: this._isCompositionStart,
      isCompositionEnd: !isUpdate
    });
    if (isUpdate) {
      if (this._isCompositionStart) {
        this._isCompositionStart = false;
      }
      this._previousIMEContent = content;
    } else {
      this._resetIME();
    }
  }
  _resetIME() {
    this._previousIMEContent = "";
    this._isCompositionStart = true;
    this._docImeInputManagerService.clearUndoRedoMutationParamsCache();
    this._docImeInputManagerService.setActiveRange(null);
  }
};
DocIMEInputController = __decorateClass([
  __decorateParam(1, Inject(DocSelectionRenderService)),
  __decorateParam(2, Inject(DocIMEInputManagerService)),
  __decorateParam(3, Inject(DocSkeletonManagerService)),
  __decorateParam(4, ICommandService)
], DocIMEInputController);

// ../packages/docs-ui/src/controllers/render-controllers/doc-input.controller.ts
var DocInputController = class extends Disposable {
  constructor(_context, _docSelectionRenderService, _docSkeletonManagerService, _commandService, _docMenuStyleService) {
    super();
    this._context = _context;
    this._docSelectionRenderService = _docSelectionRenderService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._commandService = _commandService;
    this._docMenuStyleService = _docMenuStyleService;
    __publicField(this, "_onInputSubscription");
    this._init();
  }
  dispose() {
    var _a;
    super.dispose();
    (_a = this._onInputSubscription) == null ? void 0 : _a.unsubscribe();
  }
  _init() {
    this._initialNormalInput();
  }
  _initialNormalInput() {
    this._onInputSubscription = this._docSelectionRenderService.onInput$.subscribe(async (config) => {
      var _a, _b;
      if (config == null) {
        return;
      }
      const { unitId } = this._context;
      const { event, content = "", activeRange } = config;
      const e = event;
      const skeleton = this._docSkeletonManagerService.getSkeleton();
      if (e.data == null || skeleton == null || activeRange == null) {
        return;
      }
      const { segmentId } = activeRange;
      const docDataModel = this._context.unit;
      const originBody = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
      const defaultTextStyle = this._docMenuStyleService.getDefaultStyle();
      const cacheStyle = this._docMenuStyleService.getStyleCache();
      const curCustomRange = getCustomRangeAtPosition((_a = originBody == null ? void 0 : originBody.customRanges) != null ? _a : [], activeRange.endOffset, SHEET_EDITOR_UNITS.includes(unitId));
      const curTextRun = getTextRunAtPosition(originBody, activeRange.endOffset, defaultTextStyle, cacheStyle, SHEET_EDITOR_UNITS.includes(unitId));
      const curCustomDecorations = getCustomDecorationAtPosition((_b = originBody == null ? void 0 : originBody.customDecorations) != null ? _b : [], activeRange.endOffset);
      await this._commandService.executeCommand(InsertCommand.id, {
        unitId,
        body: {
          dataStream: content,
          textRuns: curTextRun ? [
            {
              ...curTextRun,
              st: 0,
              ed: content.length
            }
          ] : [],
          customRanges: curCustomRange ? [{
            ...curCustomRange,
            startIndex: 0,
            endIndex: content.length - 1
          }] : [],
          customDecorations: curCustomDecorations.map((customDecoration) => ({
            ...customDecoration,
            startIndex: 0,
            endIndex: content.length - 1
          }))
        },
        range: activeRange,
        segmentId
      });
      if (content === " ") {
        await this._commandService.executeCommand(AfterSpaceCommand.id);
      }
    });
  }
};
DocInputController = __decorateClass([
  __decorateParam(1, Inject(DocSelectionRenderService)),
  __decorateParam(2, Inject(DocSkeletonManagerService)),
  __decorateParam(3, ICommandService),
  __decorateParam(4, Inject(DocMenuStyleService))
], DocInputController);

// ../packages/docs-ui/src/services/doc-page-layout.service.ts
var DocPageLayoutService = class extends Disposable {
  constructor(_context) {
    super();
    this._context = _context;
  }
  calculatePagePosition() {
    var _a, _b;
    const docObject = neoGetDocObject(this._context);
    const docDataModel = this._context.unit;
    const zoomRatio = (_b = (_a = docDataModel.getSettings()) == null ? void 0 : _a.zoomRatio) != null ? _b : 1;
    const { document: docsComponent, scene, docBackground } = docObject;
    const parent = scene == null ? void 0 : scene.getParent();
    const { width: docsWidth, height: docsHeight, pageMarginLeft, pageMarginTop } = docsComponent;
    if (parent == null || docsWidth === Number.POSITIVE_INFINITY || docsHeight === Number.POSITIVE_INFINITY) {
      return;
    }
    const { width: engineWidth, height: engineHeight } = parent;
    let docsLeft = 0;
    let docsTop = pageMarginTop;
    let sceneWidth = 0;
    let sceneHeight = 0;
    let scrollToX = Number.POSITIVE_INFINITY;
    if (engineWidth > (docsWidth + pageMarginLeft * 2) * zoomRatio) {
      docsLeft = engineWidth / 2 - docsWidth * zoomRatio / 2;
      docsLeft /= zoomRatio;
      sceneWidth = (engineWidth - pageMarginLeft * 2) / zoomRatio;
      scrollToX = 0;
    } else {
      docsLeft = pageMarginLeft;
      sceneWidth = docsWidth + pageMarginLeft * 2;
      scrollToX = (sceneWidth - engineWidth / zoomRatio) / 2;
    }
    if (engineHeight > docsHeight) {
      sceneHeight = (engineHeight - pageMarginTop * 2) / zoomRatio;
    } else {
      sceneHeight = docsHeight + pageMarginTop * 2;
    }
    scene.resize(sceneWidth, sceneHeight);
    if (engineWidth <= 1) {
      docsLeft = -1e4;
      docsTop = -1e4;
    }
    docsComponent.translate(docsLeft, docsTop);
    docBackground.translate(docsLeft, docsTop);
    const viewport = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (scrollToX !== Number.POSITIVE_INFINITY && viewport != null) {
      viewport.scrollToViewportPos({
        viewportScrollX: scrollToX
      });
    }
    return this;
  }
};

// ../packages/docs-ui/src/controllers/render-controllers/doc-resize.render-controller.ts
var DocResizeRenderController = class extends Disposable {
  constructor(_context, _docPageLayoutService, _textSelectionManagerService) {
    super();
    this._context = _context;
    this._docPageLayoutService = _docPageLayoutService;
    this._textSelectionManagerService = _textSelectionManagerService;
    const unitId = this._context.unitId;
    if (isInternalEditorID(unitId) && unitId !== DOCS_ZEN_EDITOR_UNIT_ID_KEY) return this;
    this._initResize();
  }
  _initResize() {
    this.disposeWithMe(
      fromEventSubject(this._context.engine.onTransformChange$).pipe(
        filter((evt) => evt.type === 1 /* resize */),
        throttleTime(0, animationFrameScheduler)
      ).subscribe(() => {
        this._docPageLayoutService.calculatePagePosition();
        this._textSelectionManagerService.refreshSelection();
      })
    );
  }
};
DocResizeRenderController = __decorateClass([
  __decorateParam(1, Inject(DocPageLayoutService)),
  __decorateParam(2, Inject(DocSelectionManagerService))
], DocResizeRenderController);

// ../packages/docs-ui/src/controllers/render-controllers/doc-selection-render.controller.ts
var DocSelectionRenderController = class extends Disposable {
  constructor(_context, _commandService, _editorService, _instanceSrv, _docSelectionRenderService, _docSkeletonManagerService, _docSelectionManagerService) {
    super();
    this._context = _context;
    this._commandService = _commandService;
    this._editorService = _editorService;
    this._instanceSrv = _instanceSrv;
    this._docSelectionRenderService = _docSelectionRenderService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._docSelectionManagerService = _docSelectionManagerService;
    __publicField(this, "_loadedMap", /* @__PURE__ */ new WeakSet());
    this._initialize();
  }
  _initialize() {
    this._init();
    this._skeletonListener();
    this._commandExecutedListener();
    this._refreshListener();
    this._syncSelection();
  }
  _init() {
    const { unitId } = this._context;
    const docObject = neoGetDocObject(this._context);
    if (docObject == null || docObject.document == null) {
      return;
    }
    if (!this._loadedMap.has(docObject.document)) {
      this._initialMain(unitId);
      this._loadedMap.add(docObject.document);
    }
  }
  _refreshListener() {
    this.disposeWithMe(
      this._docSelectionManagerService.refreshSelection$.subscribe((params) => {
        if (params == null) {
          return;
        }
        const { unitId, docRanges, isEditing, options } = params;
        if (unitId !== this._context.unitId) {
          return;
        }
        this._docSelectionRenderService.removeAllRanges();
        this._docSelectionRenderService.addDocRanges(docRanges, isEditing, options);
      })
    );
  }
  _syncSelection() {
    this.disposeWithMe(
      this._docSelectionRenderService.textSelectionInner$.subscribe((params) => {
        if (params == null) {
          return;
        }
        this._docSelectionManagerService.__replaceTextRangesWithNoRefresh(params, {
          unitId: this._context.unitId,
          subUnitId: this._context.unitId
        });
      })
    );
  }
  // eslint-disable-next-line max-lines-per-function
  _initialMain(unitId) {
    const docObject = neoGetDocObject(this._context);
    const { document: document2, scene } = docObject;
    this.disposeWithMe(document2.onPointerEnter$.subscribeEvent(() => {
      if (this._isEditorReadOnly(unitId)) {
        return;
      }
      document2.cursor = "text" /* TEXT */;
    }));
    this.disposeWithMe(document2.onPointerLeave$.subscribeEvent(() => {
      document2.cursor = "default" /* DEFAULT */;
      scene.resetCursor();
    }));
    this.disposeWithMe(document2.onPointerDown$.subscribeEvent((evt, state) => {
      if (this._isEditorReadOnly(unitId)) {
        return;
      }
      const docDataModel = this._instanceSrv.getCurrentUnitForType(O.UNIVER_DOC);
      if ((docDataModel == null ? void 0 : docDataModel.getUnitId()) !== unitId) {
        this._instanceSrv.setCurrentUnitForType(unitId);
      }
      const skeleton = this._docSkeletonManagerService.getSkeleton();
      const { offsetX, offsetY } = evt;
      const coord = this._getTransformCoordForDocumentOffset(offsetX, offsetY);
      if (coord != null) {
        const {
          pageLayoutType = 0 /* VERTICAL */,
          pageMarginLeft,
          pageMarginTop
        } = document2.getOffsetConfig();
        const { editArea } = skeleton.findEditAreaByCoord(
          coord,
          pageLayoutType,
          pageMarginLeft,
          pageMarginTop
        );
        const viewModel = this._docSkeletonManagerService.getViewModel();
        const preEditArea = viewModel.getEditArea();
        if (preEditArea !== "BODY" /* BODY */ && editArea !== "BODY" /* BODY */ && editArea !== preEditArea) {
          viewModel.setEditArea(editArea);
        }
      }
      this._docSelectionRenderService.__onPointDown(evt);
      if (this._editorService.getEditor(unitId)) {
        this._setEditorFocus(unitId);
        const { offsetX: offsetX2, offsetY: offsetY2 } = evt;
        setTimeout(() => {
          if (unitId === this._editorService.getFocusId()) {
            return;
          }
          this._setEditorFocus(unitId);
          this._docSelectionRenderService.setCursorManually(offsetX2, offsetY2);
        }, 0);
      }
      if (evt.button !== 2) {
        state.stopPropagation();
      }
    }));
    this.disposeWithMe(document2.onDblclick$.subscribeEvent((evt) => {
      if (this._isEditorReadOnly(unitId)) {
        return;
      }
      this._docSelectionRenderService.__handleDblClick(evt);
    }));
    this.disposeWithMe(document2.onTripleClick$.subscribeEvent((evt) => {
      if (this._isEditorReadOnly(unitId)) {
        return;
      }
      this._docSelectionRenderService.__handleTripleClick(evt);
    }));
  }
  _getTransformCoordForDocumentOffset(evtOffsetX, evtOffsetY) {
    const docObject = neoGetDocObject(this._context);
    const { document: document2, scene } = docObject;
    const { documentTransform } = document2.getOffsetConfig();
    const activeViewport = scene.getViewports()[0];
    if (activeViewport == null) {
      return;
    }
    const originCoord = activeViewport.transformVector2SceneCoord(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    return documentTransform.clone().invert().applyPoint(originCoord);
  }
  _isEditorReadOnly(unitId) {
    const editor = this._editorService.getEditor(unitId);
    if (!editor) {
      return false;
    }
    return editor.isReadOnly();
  }
  _setEditorFocus(unitId) {
    this._editorService.focus(unitId);
  }
  _commandExecutedListener() {
    const updateCommandList = [SetDocZoomRatioOperation.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        var _a;
        if (updateCommandList.includes(command.id)) {
          const params = command.params;
          const { unitId: documentId } = params;
          const unitId = (_a = this._docSelectionManagerService.__getCurrentSelection()) == null ? void 0 : _a.unitId;
          if (documentId !== unitId) {
            return;
          }
          this._docSelectionManagerService.refreshSelection();
        }
      })
    );
  }
  _skeletonListener() {
    this.disposeWithMe(this._docSkeletonManagerService.currentSkeleton$.subscribe((skeleton) => {
      if (!skeleton) return;
      const { unitId } = this._context;
      const isInternalEditor = isInternalEditorID(unitId);
      if (!isInternalEditor) {
        this._docSelectionRenderService.focus();
        const docDataModel = this._context.unit;
        const snapshot = docDataModel.getSnapshot();
        const offset = findFirstCursorOffset(snapshot);
        this._docSelectionManagerService.replaceDocRanges([
          {
            startOffset: offset,
            endOffset: offset
          }
        ], {
          unitId,
          subUnitId: unitId
        }, false);
      }
    }));
  }
};
DocSelectionRenderController = __decorateClass([
  __decorateParam(1, ICommandService),
  __decorateParam(2, IEditorService),
  __decorateParam(3, IUniverInstanceService),
  __decorateParam(4, Inject(DocSelectionRenderService)),
  __decorateParam(5, Inject(DocSkeletonManagerService)),
  __decorateParam(6, Inject(DocSelectionManagerService))
], DocSelectionRenderController);

// ../packages/docs-ui/src/controllers/render-controllers/doc.render-controller.ts
var DocRenderController = class extends RxDisposable {
  constructor(_context, _commandService, _docSelectionRenderService, _docSkeletonManagerService, _editorService, _renderManagerService, _univerInstanceService) {
    super();
    this._context = _context;
    this._commandService = _commandService;
    this._docSelectionRenderService = _docSelectionRenderService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._editorService = _editorService;
    this._renderManagerService = _renderManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._addNewRender();
    this._initRenderRefresh();
    this._initCommandListener();
  }
  reRender(unitId) {
    var _a, _b;
    const docSkeletonManagerService = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService);
    const skeleton = docSkeletonManagerService == null ? void 0 : docSkeletonManagerService.getSkeleton();
    if (!skeleton) {
      return;
    }
    const disabled = !!skeleton.getViewModel().getDataModel().getSnapshot().disabled;
    if (disabled) {
      return;
    }
    skeleton.calculate();
    const editor = this._editorService.getEditor(unitId);
    if (this._editorService.isEditor(unitId) && !(editor == null ? void 0 : editor.params.scrollBar)) {
      (_b = this._context.mainComponent) == null ? void 0 : _b.makeDirty();
      return;
    }
    this._recalculateSizeBySkeleton(skeleton);
  }
  _addNewRender() {
    const { scene, engine } = this._context;
    const viewMain = new Viewport("viewMain" /* VIEW_MAIN */, scene, {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0,
      isWheelPreventDefaultX: true
    });
    scene.attachControl();
    scene.onMouseWheel$.subscribeEvent((evt, state) => {
      const currentDocUnit = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
      if ((currentDocUnit == null ? void 0 : currentDocUnit.getUnitId()) !== this._context.unitId) {
        return;
      }
      const e = evt;
      if (e.ctrlKey) {
        const deltaFactor = Math.abs(e.deltaX);
        let scrollNum = deltaFactor < 40 ? 0.2 : deltaFactor < 80 ? 0.4 : 0.2;
        scrollNum *= e.deltaY > 0 ? -1 : 1;
        if (scene.scaleX < 1) {
          scrollNum /= 2;
        }
        if (scene.scaleX + scrollNum > 4) {
          scene.scale(4, 4);
        } else if (scene.scaleX + scrollNum < 0.1) {
          scene.scale(0.1, 0.1);
        } else {
          e.preventDefault();
        }
      } else {
        viewMain.onMouseWheel(e, state);
      }
    });
    new ScrollBar(viewMain);
    scene.addLayer(
      new Layer(scene, [], DOCS_COMPONENT_MAIN_LAYER_INDEX),
      new Layer(scene, [], DOCS_COMPONENT_HEADER_LAYER_INDEX)
    );
    this._addComponent();
    const frameFn = () => scene.render();
    this.disposeWithMe(this._context.activated$.subscribe((activated) => {
      if (activated) {
        engine.runRenderLoop(frameFn);
      } else {
        engine.stopRenderLoop(frameFn);
      }
    }));
    this._docSelectionRenderService.__attachScrollEvent();
  }
  _addComponent() {
    const { scene, unit: documentModel, components } = this._context;
    const DEFAULT_PAGE_MARGIN_LEFT = 20;
    const DEFAULT_PAGE_MARGIN_TOP = 20;
    const config = {
      pageMarginLeft: DEFAULT_PAGE_MARGIN_LEFT,
      pageMarginTop: DEFAULT_PAGE_MARGIN_TOP
    };
    const documents = new Documents("__Document_Render_Main__" /* MAIN */, void 0, config);
    documents.zIndex = DOCS_COMPONENT_DEFAULT_Z_INDEX;
    const docBackground = new DocBackground("__Document_Render_Background__" /* BACKGROUND */, void 0, config);
    docBackground.zIndex = DOCS_COMPONENT_DEFAULT_Z_INDEX;
    this._context.mainComponent = documents;
    components.set("__Document_Render_Main__" /* MAIN */, documents);
    components.set("__Document_Render_Background__" /* BACKGROUND */, docBackground);
    scene.addObjects([documents], DOCS_COMPONENT_MAIN_LAYER_INDEX);
    scene.addObjects([docBackground], DOCS_COMPONENT_BACKGROUND_LAYER_INDEX);
    if (this._editorService.getEditor(documentModel.getUnitId()) == null) {
      scene.enableLayerCache(DOCS_COMPONENT_MAIN_LAYER_INDEX);
    }
  }
  _initRenderRefresh() {
    this._docSkeletonManagerService.currentSkeletonBefore$.pipe(takeUntil(this.dispose$)).subscribe((param) => {
      this._create(param);
    });
  }
  _create(skeleton) {
    var _a;
    if (!skeleton) {
      return;
    }
    const { mainComponent, components } = this._context;
    const docsComponent = mainComponent;
    const docBackground = components.get("__Document_Render_Background__" /* BACKGROUND */);
    docsComponent.changeSkeleton(skeleton);
    docBackground.changeSkeleton(skeleton);
    const { unitId } = this._context;
    const editor = this._editorService.getEditor(unitId);
    if (this._editorService.isEditor(unitId) && !(editor == null ? void 0 : editor.params.scrollBar)) {
      (_a = this._context.mainComponent) == null ? void 0 : _a.makeDirty();
      return;
    }
    this._recalculateSizeBySkeleton(skeleton);
  }
  _initCommandListener() {
    const updateCommandList = [RichTextEditingMutation.id];
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      if (updateCommandList.includes(command.id)) {
        const params = command.params;
        const { unitId } = params;
        this.reRender(unitId);
      }
    }));
  }
  _recalculateSizeBySkeleton(skeleton) {
    var _a;
    const { mainComponent, scene, unitId, components } = this._context;
    const docsComponent = mainComponent;
    const docBackground = components.get("__Document_Render_Background__" /* BACKGROUND */);
    const pages = (_a = skeleton.getSkeletonData()) == null ? void 0 : _a.pages;
    if (pages == null) {
      return;
    }
    let width = 0;
    let height = 0;
    const docDataModel = this._context.unit;
    const documentFlavor = docDataModel.getSnapshot().documentStyle.documentFlavor;
    for (let i = 0, len = pages.length; i < len; i++) {
      const page = pages[i];
      let { pageWidth, pageHeight } = page;
      if (documentFlavor === 2 /* MODERN */) {
        const modernPageSize = getPageSizeInModernMode(page);
        pageWidth = modernPageSize.pageWidth;
        pageHeight = modernPageSize.pageHeight;
      }
      if (docsComponent.pageLayoutType === 0 /* VERTICAL */) {
        height += pageHeight;
        height += docsComponent.pageMarginTop;
        if (i === len - 1) {
          height += docsComponent.pageMarginTop;
        }
        width = Math.max(width, pageWidth);
      } else if (docsComponent.pageLayoutType === 1 /* HORIZONTAL */) {
        width += pageWidth;
        if (i !== len - 1) {
          width += docsComponent.pageMarginLeft;
        }
        height = Math.max(height, pageHeight);
      }
    }
    docsComponent.resize(width, height);
    docBackground.resize(width, height);
    const editor = this._editorService.getEditor(unitId);
    if (!this._editorService.isEditor(unitId) || (editor == null ? void 0 : editor.params.scrollBar)) {
      scene.resize(width, height);
    }
  }
};
DocRenderController = __decorateClass([
  __decorateParam(1, ICommandService),
  __decorateParam(2, Inject(DocSelectionRenderService)),
  __decorateParam(3, Inject(DocSkeletonManagerService)),
  __decorateParam(4, IEditorService),
  __decorateParam(5, IRenderManagerService),
  __decorateParam(6, IUniverInstanceService)
], DocRenderController);
function getPageSizeInModernMode(page) {
  let { pageWidth, pageHeight } = page;
  const { marginLeft, marginRight, marginTop, marginBottom, skeDrawings, skeTables } = page;
  if (pageWidth === Number.POSITIVE_INFINITY) {
    pageWidth = page.width + marginLeft + marginRight;
  }
  if (pageHeight === Number.POSITIVE_INFINITY) {
    pageHeight = page.height + marginTop + marginBottom;
  }
  for (const drawing of skeDrawings.values()) {
    pageWidth = Math.max(pageWidth, drawing.aLeft + drawing.width + marginLeft + marginRight);
    pageHeight = Math.max(pageHeight, drawing.aTop + drawing.height + marginTop + marginBottom);
  }
  for (const table2 of skeTables.values()) {
    pageWidth = Math.max(pageWidth, table2.left + table2.width + marginLeft + marginRight);
    pageHeight = Math.max(pageHeight, table2.top + table2.height + marginTop + marginBottom);
  }
  return { pageWidth, pageHeight };
}

// ../packages/docs-ui/src/controllers/render-controllers/zoom.render-controller.ts
var DocZoomRenderController = class extends Disposable {
  constructor(_context, _contextService, _docSkeletonManagerService, _univerInstanceService, _commandService, _textSelectionManagerService, _editorService, _docPageLayoutService) {
    super();
    this._context = _context;
    this._contextService = _contextService;
    this._docSkeletonManagerService = _docSkeletonManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._commandService = _commandService;
    this._textSelectionManagerService = _textSelectionManagerService;
    this._editorService = _editorService;
    this._docPageLayoutService = _docPageLayoutService;
    this._initSkeletonListener();
    this._initCommandExecutedListener();
    this._initRenderRefresher();
    setTimeout(() => this.updateViewZoom(1, true), 20);
  }
  _initRenderRefresher() {
    this._docSkeletonManagerService.currentSkeleton$.subscribe((param) => {
      if (param == null) {
        return;
      }
      const { unitId, scene } = this._context;
      if (this._editorService.isEditor(unitId)) {
        return;
      }
      this.disposeWithMe(scene.onMouseWheel$.subscribeEvent((e) => {
        if (!e.ctrlKey || !this._contextService.getContextValue(FOCUSING_DOC)) {
          return;
        }
        const documentModel = this._univerInstanceService.getCurrentUniverDocInstance();
        if (!documentModel) {
          return;
        }
        const { documentFlavor } = documentModel.getSnapshot().documentStyle;
        if (documentFlavor === 2 /* MODERN */) {
          return;
        }
        const deltaFactor = Math.abs(e.deltaX);
        let ratioDelta = deltaFactor < 40 ? 0.2 : deltaFactor < 80 ? 0.4 : 0.2;
        ratioDelta *= e.deltaY > 0 ? -1 : 1;
        if (scene.scaleX < 1) {
          ratioDelta /= 2;
        }
        const currentRatio = documentModel.zoomRatio;
        let nextRatio = +Number.parseFloat(`${currentRatio + ratioDelta}`).toFixed(1);
        nextRatio = nextRatio >= 4 ? 4 : nextRatio <= 0.1 ? 0.1 : nextRatio;
        this._commandService.executeCommand(SetDocZoomRatioCommand.id, {
          zoomRatio: nextRatio,
          unitId: documentModel.getUnitId()
        });
        e.preventDefault();
      }));
    });
  }
  _initSkeletonListener() {
    this.disposeWithMe(this._docSkeletonManagerService.currentSkeleton$.subscribe((param) => {
      if (param == null) {
        return;
      }
      const documentModel = this._univerInstanceService.getCurrentUniverDocInstance();
      if (!documentModel) return;
      const zoomRatio = documentModel.zoomRatio || 1;
      this.updateViewZoom(zoomRatio, false);
    }));
  }
  _initCommandExecutedListener() {
    const updateCommandList = [SetDocZoomRatioOperation.id];
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      if (updateCommandList.includes(command.id) && command.params.unitId === this._context.unitId) {
        const documentModel = this._context.unit;
        const zoomRatio = documentModel.zoomRatio || 1;
        this.updateViewZoom(zoomRatio);
      }
    }));
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((command) => {
        if (command.id === SwitchDocModeCommand.id) {
          this._commandService.executeCommand(SetDocZoomRatioCommand.id, {
            zoomRatio: 1,
            unitId: this._context.unitId
          });
        }
      })
    );
  }
  updateViewZoom(zoomRatio, needRefreshSelection = true) {
    var _a;
    const docObject = neoGetDocObject(this._context);
    docObject.scene.scale(zoomRatio, zoomRatio);
    if (!this._editorService.isEditor(this._context.unitId)) {
      this._docPageLayoutService.calculatePagePosition();
    }
    if (needRefreshSelection && !this._editorService.isEditor(this._context.unitId)) {
      this._textSelectionManagerService.refreshSelection();
    }
    (_a = docObject.scene.getTransformer()) == null ? void 0 : _a.clearSelectedObjects();
  }
};
DocZoomRenderController = __decorateClass([
  __decorateParam(1, IContextService),
  __decorateParam(2, Inject(DocSkeletonManagerService)),
  __decorateParam(3, IUniverInstanceService),
  __decorateParam(4, ICommandService),
  __decorateParam(5, Inject(DocSelectionManagerService)),
  __decorateParam(6, IEditorService),
  __decorateParam(7, Inject(DocPageLayoutService))
], DocZoomRenderController);

// ../packages/docs-ui/src/services/doc-state-change-manager.service.ts
var DEBOUNCE_DELAY = 300;
var DocStateChangeManagerService = class extends RxDisposable {
  constructor(_undoRedoService, _commandService, _univerInstanceService, _docStateEmitService, _renderManagerService) {
    super();
    this._undoRedoService = _undoRedoService;
    this._commandService = _commandService;
    this._univerInstanceService = _univerInstanceService;
    this._docStateEmitService = _docStateEmitService;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_docStateChange$", new BehaviorSubject(null));
    __publicField(this, "docStateChange$", this._docStateChange$.asObservable());
    // This cache used for history compose.
    __publicField(this, "_historyStateCache", /* @__PURE__ */ new Map());
    // This cache used for collaboration state compose.
    __publicField(this, "_changeStateCache", /* @__PURE__ */ new Map());
    __publicField(this, "_historyTimer", null);
    __publicField(this, "_changeStateCacheTimer", null);
    this._initialize();
    this._listenDocStateChange();
  }
  getStateCache(unitId) {
    var _a, _b;
    return {
      history: (_a = this._historyStateCache.get(unitId)) != null ? _a : [],
      collaboration: (_b = this._changeStateCache.get(unitId)) != null ? _b : []
    };
  }
  setStateCache(unitId, cache) {
    this._historyStateCache.set(unitId, cache.history);
    this._changeStateCache.set(unitId, cache.collaboration);
  }
  _setChangeState(changeState) {
    this._cacheChangeState(changeState, "history");
    this._cacheChangeState(changeState, "collaboration");
  }
  _initialize() {
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((command) => {
        if (command.id === UndoCommandId || command.id === RedoCommandId) {
          const univerDoc = this._univerInstanceService.getCurrentUniverDocInstance();
          if (univerDoc == null) {
            return;
          }
          const unitId = univerDoc.getUnitId();
          this._pushHistory(unitId);
          this._emitChangeState(unitId);
        }
      })
    );
  }
  _listenDocStateChange() {
    this._docStateEmitService.docStateChangeParams$.pipe(takeUntil(this.dispose$)).subscribe((changeStateInfo) => {
      var _a;
      if (changeStateInfo == null) {
        return;
      }
      const { isCompositionEnd, isSync, syncer, ...changeState } = changeStateInfo;
      const imeInputManagerService = (_a = this._renderManagerService.getRenderById(isSync ? syncer : changeStateInfo.unitId)) == null ? void 0 : _a.with(DocIMEInputManagerService);
      if (imeInputManagerService == null) {
        return;
      }
      if (isCompositionEnd) {
        const historyParams = imeInputManagerService.fetchComposedUndoRedoMutationParams();
        if (historyParams == null) {
          throw new Error("historyParams is null in RichTextEditingMutation");
        }
        const { undoMutationParams, redoMutationParams, previousActiveRange } = historyParams;
        changeState.redoState.actions = redoMutationParams.actions;
        changeState.undoState.actions = undoMutationParams.actions;
        changeState.undoState.textRanges = [previousActiveRange];
      }
      this._setChangeState(changeState);
    });
  }
  _cacheChangeState(changeState, type2 = "history") {
    const { trigger, unitId, noHistory, debounce = false } = changeState;
    if (noHistory || trigger == null) {
      return;
    }
    if (type2 === "history" && (trigger === RedoCommandId || trigger === UndoCommandId)) {
      return;
    }
    const stateCache = type2 === "history" ? this._historyStateCache : this._changeStateCache;
    const cb = type2 === "history" ? this._pushHistory.bind(this) : this._emitChangeState.bind(this);
    if (stateCache.has(unitId)) {
      const cacheStates = stateCache.get(unitId);
      cacheStates == null ? void 0 : cacheStates.push(changeState);
    } else {
      stateCache.set(unitId, [changeState]);
    }
    if (debounce) {
      if (type2 === "history") {
        if (this._historyTimer) {
          clearTimeout(this._historyTimer);
        }
        this._historyTimer = setTimeout(() => {
          cb(unitId);
        }, DEBOUNCE_DELAY);
      } else {
        if (this._changeStateCacheTimer) {
          clearTimeout(this._changeStateCacheTimer);
        }
        this._changeStateCacheTimer = setTimeout(() => {
          cb(unitId);
        }, DEBOUNCE_DELAY);
      }
    } else {
      cb(unitId);
    }
  }
  _pushHistory(unitId) {
    const undoRedoService = this._undoRedoService;
    const cacheStates = this._historyStateCache.get(unitId);
    if (!Array.isArray(cacheStates) || cacheStates.length === 0) {
      return;
    }
    const len = cacheStates.length;
    const commandId = cacheStates[0].commandId;
    const firstState = cacheStates[0];
    const lastState = cacheStates[len - 1];
    const redoParams = {
      unitId,
      actions: cacheStates.reduce((acc, cur) => JSONX.compose(acc, cur.redoState.actions), null),
      textRanges: lastState.redoState.textRanges
    };
    const undoParams = {
      unitId,
      // Always need to put undoParams after redoParams, because `reverse` will change the `cacheStates` order.
      actions: cacheStates.reverse().reduce((acc, cur) => JSONX.compose(acc, cur.undoState.actions), null),
      textRanges: firstState.undoState.textRanges
    };
    undoRedoService.pushUndoRedo({
      unitID: unitId,
      undoMutations: [{ id: commandId, params: undoParams }],
      redoMutations: [{ id: commandId, params: redoParams }]
    });
    cacheStates.length = 0;
  }
  _emitChangeState(unitId) {
    const cacheStates = this._changeStateCache.get(unitId);
    if (!Array.isArray(cacheStates) || cacheStates.length === 0) {
      return;
    }
    const len = cacheStates.length;
    const { commandId, trigger, segmentId, noHistory, debounce } = cacheStates[0];
    const firstState = cacheStates[0];
    const lastState = cacheStates[len - 1];
    const redoState = {
      unitId,
      actions: cacheStates.reduce((acc, cur) => JSONX.compose(acc, cur.redoState.actions), null),
      textRanges: lastState.redoState.textRanges
    };
    const undoState = {
      unitId,
      // Always need to put undoParams after redoParams, because `reverse` will change the `cacheStates` order.
      actions: cacheStates.reverse().reduce((acc, cur) => JSONX.compose(acc, cur.undoState.actions), null),
      textRanges: firstState.undoState.textRanges
    };
    const changeState = {
      commandId,
      unitId,
      trigger,
      redoState,
      undoState,
      segmentId,
      noHistory,
      debounce
    };
    cacheStates.length = 0;
    this._docStateChange$.next(changeState);
  }
};
DocStateChangeManagerService = __decorateClass([
  __decorateParam(0, Inject(IUndoRedoService)),
  __decorateParam(1, ICommandService),
  __decorateParam(2, IUniverInstanceService),
  __decorateParam(3, Inject(DocStateEmitService)),
  __decorateParam(4, IRenderManagerService)
], DocStateChangeManagerService);

// ../packages/docs-ui/src/services/docs-render.service.ts
var DOC_MAIN_CANVAS_ID = "univer-doc-main-canvas";
var DocsRenderService = class extends RxDisposable {
  constructor(_instanceSrv, _renderManagerService) {
    super();
    this._instanceSrv = _instanceSrv;
    this._renderManagerService = _renderManagerService;
    this._init();
  }
  _init() {
    this._renderManagerService.createRender$.pipe(takeUntil(this.dispose$)).subscribe((unitId) => this._createRenderWithId(unitId));
    this._instanceSrv.getAllUnitsForType(O.UNIVER_DOC).forEach((documentModel) => this._createRenderer(documentModel));
    this._instanceSrv.getTypeOfUnitAdded$(O.UNIVER_DOC).pipe(takeUntil(this.dispose$)).subscribe((doc) => this._createRenderer(doc));
    this._instanceSrv.getTypeOfUnitDisposed$(O.UNIVER_DOC).pipe(takeUntil(this.dispose$)).subscribe((doc) => this._disposeRenderer(doc));
  }
  _createRenderer(doc) {
    var _a;
    const unitId = doc.getUnitId();
    const workbookId = (_a = this._instanceSrv.getCurrentUnitForType(O.UNIVER_DOC)) == null ? void 0 : _a.getUnitId();
    this._renderManagerService.created$.subscribe((renderer) => {
      if (renderer.unitId === workbookId) {
        renderer.engine.getCanvas().setId(DOC_MAIN_CANVAS_ID);
        renderer.engine.getCanvas().getContext().setId(DOC_MAIN_CANVAS_ID);
      }
    });
    if (!this._renderManagerService.has(unitId)) {
      this._createRenderWithId(unitId);
    }
  }
  _createRenderWithId(unitId) {
    this._renderManagerService.createRender(unitId);
  }
  _disposeRenderer(doc) {
    const unitId = doc.getUnitId();
    this._renderManagerService.removeRender(unitId);
  }
};
DocsRenderService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService)
], DocsRenderService);

// ../packages/docs-ui/src/services/range-selector/range-selector.service.ts
var RangeSelectorService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_currentSelectorId");
    __publicField(this, "_selectionChange$", new Subject());
    __publicField(this, "selectionChange$", this._selectionChange$.asObservable());
    __publicField(this, "_openSelector$", new Subject());
    __publicField(this, "openSelector$", this._openSelector$.asObservable());
    __publicField(this, "_selectorModalVisible$", new BehaviorSubject(false));
    __publicField(this, "selectorModalVisible$", this._selectorModalVisible$.asObservable());
  }
  get selectorModalVisible() {
    return this._selectorModalVisible$.getValue();
  }
  setCurrentSelectorId(id) {
    this._currentSelectorId = id;
  }
  getCurrentSelectorId() {
    return this._currentSelectorId;
  }
  selectionChange(range) {
    if (!this._currentSelectorId) {
      return;
    }
    this._selectionChange$.next(range);
  }
  openSelector() {
    this._openSelector$.next(null);
  }
  triggerModalVisibleChange(visible) {
    this._selectorModalVisible$.next(visible);
  }
};
var IRangeSelectorService = createIdentifier(
  "univer.range-selector.service"
);

// ../packages/docs-ui/src/shortcuts/core-editing.shortcut.ts
var BreakLineShortcut = {
  id: EnterCommand.id,
  preconditions: whenDocAndEditorFocusedWithBreakLine,
  binding: 13 /* ENTER */
};
var DeleteLeftShortcut = {
  id: DeleteLeftCommand.id,
  preconditions: whenDocAndEditorFocused,
  binding: 8 /* BACKSPACE */
};
var DeleteRightShortcut = {
  id: DeleteRightCommand.id,
  preconditions: whenDocAndEditorFocused,
  binding: 46 /* DELETE */
};

// ../packages/docs-ui/src/shortcuts/cursor.shortcut.ts
var MoveCursorUpShortcut = {
  id: MoveCursorOperation.id,
  binding: 38 /* ARROW_UP */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 0 /* UP */
  }
};
var MoveCursorDownShortcut = {
  id: MoveCursorOperation.id,
  binding: 40 /* ARROW_DOWN */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 2 /* DOWN */
  }
};
var MoveCursorLeftShortcut = {
  id: MoveCursorOperation.id,
  binding: 37 /* ARROW_LEFT */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 3 /* LEFT */
  }
};
var MoveCursorRightShortcut = {
  id: MoveCursorOperation.id,
  binding: 39 /* ARROW_RIGHT */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 1 /* RIGHT */
  }
};
var MoveSelectionUpShortcut = {
  id: MoveSelectionOperation.id,
  binding: 38 /* ARROW_UP */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 0 /* UP */
  }
};
var MoveSelectionDownShortcut = {
  id: MoveSelectionOperation.id,
  binding: 40 /* ARROW_DOWN */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 2 /* DOWN */
  }
};
var MoveSelectionLeftShortcut = {
  id: MoveSelectionOperation.id,
  binding: 37 /* ARROW_LEFT */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 3 /* LEFT */
  }
};
var MoveSelectionRightShortcut = {
  id: MoveSelectionOperation.id,
  binding: 39 /* ARROW_RIGHT */ | 1024 /* SHIFT */,
  preconditions: whenDocAndEditorFocused,
  staticParameters: {
    direction: 1 /* RIGHT */
  }
};
var SelectAllShortcut = {
  id: DocSelectAllCommand.id,
  binding: 65 /* A */ | 4096 /* CTRL_COMMAND */,
  preconditions: (contextService) => contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && (contextService.getContextValue(FOCUSING_DOC) || contextService.getContextValue(EDITOR_ACTIVATED))
};

// ../packages/docs-ui/src/docs-ui-plugin.ts
var UniverDocsUIPlugin = class extends Plugin {
  // static override type = UniverInstanceType.UNIVER_DOC;
  constructor(_config = defaultPluginConfig5, _injector, _renderManagerSrv, _commandService, _logService, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._renderManagerSrv = _renderManagerSrv;
    this._commandService = _commandService;
    this._logService = _logService;
    this._configService = _configService;
    const { menu, ...rest } = merge_default(
      {},
      defaultPluginConfig5,
      this._config
    );
    if (menu) {
      this._configService.setConfig("menu", menu, { merge: true });
    }
    this._configService.setConfig(DOCS_UI_PLUGIN_CONFIG_KEY, rest);
    this._initDependencies(_injector);
    this._initializeShortcut();
    this._initCommand();
  }
  onReady() {
    this._initRenderBasics();
    this._markDocAsFocused();
    touchDependencies(this._injector, [
      [DocStateChangeManagerService],
      [DocsRenderService]
    ]);
  }
  onRendered() {
    this._initUI();
    this._initRenderModules();
    touchDependencies(this._injector, [
      [DocAutoFormatController],
      [DocMoveCursorController],
      [DocParagraphSettingController],
      [DocTableController],
      // FIXME: LifecycleStages.Rendered must be used, otherwise the menu cannot be added to the DOM, but the sheet ui
      // plugin can be added in LifecycleStages.Ready
      [DocUIController],
      [FloatMenuController]
    ]);
  }
  _initCommand() {
    [
      DeleteLeftCommand,
      DeleteRightCommand,
      SetInlineFormatBoldCommand,
      SetInlineFormatItalicCommand,
      SetInlineFormatUnderlineCommand,
      SetInlineFormatStrikethroughCommand,
      SetInlineFormatSubscriptCommand,
      SetInlineFormatSuperscriptCommand,
      SetInlineFormatFontSizeCommand,
      SetInlineFormatFontFamilyCommand,
      SetInlineFormatTextColorCommand,
      ResetInlineFormatTextBackgroundColorCommand,
      SetInlineFormatTextBackgroundColorCommand,
      SetInlineFormatCommand,
      BreakLineCommand,
      InsertCommand,
      DeleteCommand,
      DeleteCustomBlockCommand,
      UpdateCommand,
      MergeTwoParagraphCommand,
      RemoveHorizontalLineCommand,
      SetDocZoomRatioOperation,
      OrderListCommand,
      BulletListCommand,
      ListOperationCommand,
      AlignLeftCommand,
      AlignCenterCommand,
      AlignRightCommand,
      AlignOperationCommand,
      AlignJustifyCommand,
      HorizontalLineCommand,
      CreateDocTableCommand,
      DocTableInsertRowCommand,
      DocTableInsertRowAboveCommand,
      DocTableInsertRowBellowCommand,
      DocTableInsertColumnCommand,
      DocTableInsertColumnLeftCommand,
      DocTableInsertColumnRightCommand,
      DocTableDeleteRowsCommand,
      DocTableDeleteColumnsCommand,
      DocTableDeleteTableCommand,
      CloseHeaderFooterCommand,
      DocTableTabCommand,
      TabCommand,
      AfterSpaceCommand,
      EnterCommand,
      ChangeListNestingLevelCommand,
      ChangeListTypeCommand,
      CheckListCommand,
      ToggleCheckListCommand,
      QuickListCommand,
      IMEInputCommand,
      SwitchDocModeCommand,
      DocParagraphSettingCommand,
      InnerPasteCommand,
      CutContentCommand,
      ReplaceContentCommand,
      ReplaceSnapshotCommand,
      CoverContentCommand,
      SetDocZoomRatioCommand,
      DocSelectAllCommand,
      DocParagraphSettingPanelOperation,
      MoveCursorOperation,
      MoveSelectionOperation,
      ReplaceTextRunsCommand,
      ReplaceSelectionCommand,
      InsertCustomRangeCommand
    ].forEach((e) => {
      this._commandService.registerCommand(e);
    });
    [DocCopyCommand, DocCutCommand, DocPasteCommand].forEach((command) => this.disposeWithMe(this._commandService.registerMultipleCommand(command)));
  }
  _initializeShortcut() {
    [
      MoveCursorUpShortcut,
      MoveCursorDownShortcut,
      MoveCursorRightShortcut,
      MoveCursorLeftShortcut,
      MoveSelectionUpShortcut,
      MoveSelectionDownShortcut,
      MoveSelectionLeftShortcut,
      MoveSelectionRightShortcut,
      SelectAllShortcut,
      DeleteLeftShortcut,
      DeleteRightShortcut,
      BreakLineShortcut,
      ShiftTabShortCut
    ].forEach((shortcut) => {
      this._injector.get(IShortcutService).registerShortcut(shortcut);
    });
  }
  _initDependencies(injector) {
    const dependencies = mergeOverrideWithDependencies([
      [DocClipboardController],
      [DocEditorBridgeController],
      [DocUIController],
      [DocAutoFormatController],
      [DocTableController],
      [DocMoveCursorController],
      [AppUIController],
      [DocParagraphSettingController],
      [IEditorService, { useClass: EditorService }],
      [IRangeSelectorService, { useClass: RangeSelectorService }],
      [IDocClipboardService, { useClass: DocClipboardService }],
      [DocCanvasPopManagerService],
      [DocsRenderService],
      [DocStateChangeManagerService],
      [DocAutoFormatService],
      [DocMenuStyleService],
      [FloatMenuController]
    ], this._config.override);
    dependencies.forEach((d) => injector.add(d));
  }
  _markDocAsFocused() {
    const currentService = this._injector.get(IUniverInstanceService);
    const editorService = this._injector.get(IEditorService);
    try {
      const doc = currentService.getCurrentUnitForType(O.UNIVER_DOC);
      if (!doc) return;
      const id = doc.getUnitId();
      if (!editorService.isEditor(id)) {
        currentService.focusUnit(doc.getUnitId());
      }
    } catch (err) {
      this._logService.warn(err);
    }
  }
  _initUI() {
    this._injector.get(AppUIController);
  }
  _initRenderBasics() {
    [
      [DocSkeletonManagerService],
      [DocSelectionRenderService],
      [DocInterceptorService],
      [DocPageLayoutService],
      [DocIMEInputManagerService],
      [DocRenderController],
      [DocZoomRenderController]
    ].forEach((m) => {
      this._renderManagerSrv.registerRenderModule(O.UNIVER_DOC, m);
    });
  }
  _initRenderModules() {
    [
      [DocEventManagerService],
      [DocBackScrollRenderController],
      [DocSelectionRenderController],
      [DocHeaderFooterController],
      [DocResizeRenderController],
      [DocContextMenuRenderController],
      [DocChecklistRenderController],
      [DocClipboardController],
      [DocInputController],
      [DocIMEInputController],
      [DocEditorBridgeController]
    ].forEach((m) => {
      this._renderManagerSrv.registerRenderModule(O.UNIVER_DOC, m);
    });
  }
};
__publicField(UniverDocsUIPlugin, "pluginName", DOC_UI_PLUGIN_NAME);
UniverDocsUIPlugin = __decorateClass([
  DependentOn(UniverRenderEnginePlugin),
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IRenderManagerService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, ILogService),
  __decorateParam(5, IConfigService)
], UniverDocsUIPlugin);

// ../packages/docs-ui/src/basics/custom-decoration-factory.ts
function addCustomDecorationFactory(param) {
  const { unitId, ranges, id, type: type2, segmentId } = param;
  const doMutation = {
    id: RichTextEditingMutation.id,
    params: {
      unitId,
      actions: [],
      textRanges: void 0,
      // noHistory: true,
      segmentId
    }
  };
  const jsonX = JSONX.getInstance();
  const textX = BuildTextUtils.customDecoration.add({ ranges, id, type: type2 });
  doMutation.params.actions = jsonX.editOp(textX.serialize());
  return doMutation;
}
function addCustomDecorationBySelectionFactory(accessor, param) {
  const { segmentId, id, type: type2, unitId: propUnitId } = param;
  const docSelectionManagerService = accessor.get(DocSelectionManagerService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const documentDataModel = propUnitId ? univerInstanceService.getUnit(propUnitId, O.UNIVER_DOC) : univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
  if (!documentDataModel) {
    return false;
  }
  const unitId = documentDataModel.getUnitId();
  const selections = docSelectionManagerService.getTextRanges({ unitId, subUnitId: unitId });
  if (!selections) {
    return false;
  }
  const body = documentDataModel.getBody();
  if (!body) {
    return false;
  }
  const doMutation = addCustomDecorationFactory(
    {
      unitId,
      ranges: selections,
      id,
      type: type2,
      segmentId
    }
  );
  return doMutation;
}
function deleteCustomDecorationFactory(accessor, params) {
  const { unitId, id, segmentId } = params;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const documentDataModel = univerInstanceService.getUnit(unitId);
  if (!documentDataModel) {
    return false;
  }
  const doMutation = {
    id: RichTextEditingMutation.id,
    params: {
      unitId,
      actions: [],
      textRanges: void 0,
      // noHistory: true,
      segmentId
    }
  };
  const textX = BuildTextUtils.customDecoration.delete({ id, segmentId, documentDataModel });
  if (!textX) {
    return false;
  }
  const jsonX = JSONX.getInstance();
  doMutation.params.actions = jsonX.editOp(textX.serialize());
  return doMutation;
}

// ../packages/docs-ui/src/basics/transform-position.ts
function docDrawingPositionToTransform(position) {
  return {
    left: position.positionH.posOffset,
    top: position.positionV.posOffset,
    width: position.size.width,
    height: position.size.height
  };
}

// ../packages/docs-ui/src/views/rich-text-editor/hooks/use-keyboard-event.ts
var import_react46 = __toESM(require_react());
function useKeyboardEvent(isNeed, config, editor) {
  const commandService = useDependency(ICommandService);
  const shortcutService = useDependency(IShortcutService);
  const key = (0, import_react46.useMemo)(() => generateRandomId(4), []);
  (0, import_react46.useEffect)(() => {
    if (!editor || !isNeed || !config) {
      return;
    }
    const editorId = editor.getEditorId();
    const operationId = `sheet.operation.editor-${editorId}-keyboard-${key}`;
    const d = new DisposableCollection();
    d.add(commandService.registerCommand({
      id: operationId,
      type: 1 /* OPERATION */,
      handler(_event, params) {
        const { keyCode, metaKey } = params;
        config.handler(keyCode, metaKey);
      }
    }));
    config.keyCodes.map((keyCode) => {
      return {
        id: operationId,
        binding: keyCode.metaKey ? keyCode.keyCode | keyCode.metaKey : keyCode.keyCode,
        preconditions: () => true,
        priority: 901,
        staticParameters: {
          eventType: 4 /* Keyboard */,
          keyCode: keyCode.keyCode,
          metaKey: keyCode.metaKey
        }
      };
    }).forEach((item) => {
      d.add(shortcutService.registerShortcut(item));
    });
    return () => {
      d.dispose();
    };
  }, [commandService, config, editor, isNeed, key, shortcutService]);
}

// ../packages/docs-ui/src/views/rich-text-editor/hooks/use-resize.ts
var import_react47 = __toESM(require_react());
var useResize = (editor, isSingle = true, autoScrollbar, autoScroll) => {
  const resize = (0, import_react47.useCallback)(() => {
    if (editor) {
      const { scene, mainComponent } = editor.render;
      const docSkeletonManagerService = editor.render.with(DocSkeletonManagerService);
      const { width, height } = editor.getBoundingClientRect();
      docSkeletonManagerService.getViewModel().getDataModel().updateDocumentDataPageSize(isSingle ? Infinity : width, Infinity);
      scene.transformByState({
        width,
        height
      });
      mainComponent == null ? void 0 : mainComponent.resize(width, height);
    }
  }, [editor, isSingle]);
  const checkScrollBar = (0, import_react47.useMemo)(() => {
    return debounce_default(() => {
      var _a, _b;
      if (!autoScrollbar) return;
      if (!editor || !autoScrollbar) {
        return;
      }
      const docSkeletonManagerService = editor.render.with(DocSkeletonManagerService);
      const skeleton = docSkeletonManagerService.getSkeleton();
      const { scene, mainComponent } = editor.render;
      const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
      const { actualWidth, actualHeight } = skeleton.getActualSize();
      const { width, height } = editor.getBoundingClientRect();
      let scrollBar = viewportMain == null ? void 0 : viewportMain.getScrollBar();
      const contentWidth = Math.max(actualWidth, width);
      const contentHeight = Math.max(actualHeight, height);
      scene.transformByState({
        width: contentWidth,
        height: contentHeight
      });
      mainComponent == null ? void 0 : mainComponent.resize(contentWidth, contentHeight);
      if (!isSingle) {
        if (actualHeight > height) {
          if (scrollBar == null) {
            if (viewportMain) {
              scrollBar = new ScrollBar(viewportMain, {
                enableHorizontal: false,
                enableVertical: true,
                barSize: 8,
                minThumbSizeV: 8
              });
            }
          } else {
            viewportMain == null ? void 0 : viewportMain.resetCanvasSizeAndUpdateScroll();
          }
          autoScroll && (viewportMain == null ? void 0 : viewportMain.scrollToBarPos({ x: 0, y: Infinity }));
        } else {
          scrollBar = null;
          viewportMain == null ? void 0 : viewportMain.scrollToBarPos({ x: 0, y: 0 });
          (_a = viewportMain == null ? void 0 : viewportMain.getScrollBar()) == null ? void 0 : _a.dispose();
        }
      } else {
        if (actualWidth > width) {
          if (scrollBar == null) {
            viewportMain && new ScrollBar(viewportMain, {
              barSize: 8,
              enableVertical: false,
              enableHorizontal: true,
              minThumbSizeV: 8
            });
          } else {
            viewportMain == null ? void 0 : viewportMain.resetCanvasSizeAndUpdateScroll();
          }
          autoScroll && (viewportMain == null ? void 0 : viewportMain.scrollToBarPos({ x: Infinity, y: 0 }));
        } else {
          scrollBar = null;
          viewportMain == null ? void 0 : viewportMain.scrollToBarPos({ x: 0, y: 0 });
          (_b = viewportMain == null ? void 0 : viewportMain.getScrollBar()) == null ? void 0 : _b.dispose();
        }
      }
    }, 30);
  }, [editor, autoScrollbar, isSingle, autoScroll]);
  (0, import_react47.useEffect)(() => {
    if (!autoScrollbar) return;
    if (editor) {
      const time = setTimeout(() => {
        resize();
        checkScrollBar();
      }, 500);
      return () => {
        clearTimeout(time);
      };
    }
  }, [editor, autoScrollbar, resize, checkScrollBar]);
  (0, import_react47.useEffect)(() => {
    if (!autoScrollbar) return;
    if (editor) {
      const d = editor.input$.subscribe(() => {
        checkScrollBar();
      });
      return () => {
        d.unsubscribe();
      };
    }
  }, [editor, autoScrollbar, checkScrollBar]);
  return { resize, checkScrollBar };
};

// ../packages/docs-ui/src/views/rich-text-editor/index.tsx
var import_react51 = __toESM(require_react());

// ../packages/docs-ui/src/views/rich-text-editor/hooks/use-editor.ts
var import_react48 = __toESM(require_react());
function useEditor(opts) {
  const { editorId, initialValue, container, autoFocus: _autoFocus, isSingle } = opts;
  const autoFocus = (0, import_react48.useMemo)(() => _autoFocus != null ? _autoFocus : false, []);
  const [editor, setEditor] = (0, import_react48.useState)();
  const editorService = useDependency(IEditorService);
  (0, import_react48.useLayoutEffect)(() => {
    var _a, _b;
    if (container.current) {
      const initialDoc = typeof initialValue === "string" ? void 0 : Tools.deepClone(initialValue);
      const snapshot = {
        body: {
          dataStream: typeof initialValue === "string" ? `${initialValue}\r
` : "\r\n",
          textRuns: [],
          customBlocks: [],
          customDecorations: [],
          customRanges: [],
          paragraphs: [{
            startIndex: 0
          }]
        },
        ...initialDoc,
        documentStyle: {
          ...initialDoc == null ? void 0 : initialDoc.documentStyle,
          pageSize: {
            width: !isSingle ? container.current.clientWidth : Infinity,
            height: Infinity
          }
        },
        id: editorId
      };
      const dispose = editorService.register(
        {
          autofocus: true,
          editorUnitId: editorId,
          initialSnapshot: snapshot
        },
        container.current
      );
      const editor2 = editorService.getEditor(editorId);
      setEditor(editor2);
      if (autoFocus) {
        editor2.focus();
        const end = ((_b = (_a = snapshot.body) == null ? void 0 : _a.dataStream.length) != null ? _b : 2) - 2;
        editor2.setSelectionRanges([{ startOffset: end, endOffset: end }]);
      }
      return () => {
        dispose == null ? void 0 : dispose.dispose();
      };
    }
  }, []);
  return editor;
}

// ../packages/docs-ui/src/views/rich-text-editor/hooks/use-left-and-right-arrow.ts
var import_react49 = __toESM(require_react());
var useLeftAndRightArrow = (isNeed, selectingMode, editor, onMoveInEditor) => {
  const commandService = useDependency(ICommandService);
  const shortcutService = useDependency(IShortcutService);
  const selectingModeRef = (0, import_react49.useRef)(selectingMode);
  selectingModeRef.current = selectingMode;
  const onMoveInEditorRef = (0, import_react49.useRef)(onMoveInEditor);
  onMoveInEditorRef.current = onMoveInEditor;
  (0, import_react49.useEffect)(() => {
    if (!editor || !isNeed) {
      return;
    }
    const editorId = editor.getEditorId();
    const operationId = `sheet.formula-embedding-editor.${editorId}`;
    const d = new DisposableCollection();
    const handleMoveInEditor = (keycode, metaKey) => {
      if (onMoveInEditorRef.current) {
        onMoveInEditorRef.current(keycode, metaKey);
        return;
      }
      let direction = 3 /* LEFT */;
      if (keycode === 40 /* ARROW_DOWN */) {
        direction = 2 /* DOWN */;
      } else if (keycode === 38 /* ARROW_UP */) {
        direction = 0 /* UP */;
      } else if (keycode === 39 /* ARROW_RIGHT */) {
        direction = 1 /* RIGHT */;
      }
      if (metaKey === 1024 /* SHIFT */) {
        commandService.executeCommand(MoveSelectionOperation.id, {
          direction
        });
      } else {
        commandService.executeCommand(MoveCursorOperation.id, {
          direction
        });
      }
    };
    d.add(commandService.registerCommand({
      id: operationId,
      type: 1 /* OPERATION */,
      handler(_event, params) {
        const { keyCode } = params;
        handleMoveInEditor(keyCode);
      }
    }));
    const keyCodes = [
      { keyCode: 40 /* ARROW_DOWN */ },
      { keyCode: 37 /* ARROW_LEFT */ },
      { keyCode: 39 /* ARROW_RIGHT */ },
      { keyCode: 38 /* ARROW_UP */ },
      { keyCode: 40 /* ARROW_DOWN */, metaKey: 1024 /* SHIFT */ },
      { keyCode: 37 /* ARROW_LEFT */, metaKey: 1024 /* SHIFT */ },
      { keyCode: 39 /* ARROW_RIGHT */, metaKey: 1024 /* SHIFT */ },
      { keyCode: 38 /* ARROW_UP */, metaKey: 1024 /* SHIFT */ },
      { keyCode: 40 /* ARROW_DOWN */, metaKey: 4096 /* CTRL_COMMAND */ },
      { keyCode: 37 /* ARROW_LEFT */, metaKey: 4096 /* CTRL_COMMAND */ },
      { keyCode: 39 /* ARROW_RIGHT */, metaKey: 4096 /* CTRL_COMMAND */ },
      { keyCode: 38 /* ARROW_UP */, metaKey: 4096 /* CTRL_COMMAND */ },
      { keyCode: 40 /* ARROW_DOWN */, metaKey: 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */ },
      { keyCode: 37 /* ARROW_LEFT */, metaKey: 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */ },
      { keyCode: 39 /* ARROW_RIGHT */, metaKey: 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */ },
      { keyCode: 38 /* ARROW_UP */, metaKey: 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */ }
    ];
    keyCodes.map(({ keyCode, metaKey }) => {
      return {
        id: operationId,
        binding: metaKey ? keyCode | metaKey : keyCode,
        preconditions: () => true,
        priority: 900,
        staticParameters: {
          eventType: 4 /* Keyboard */,
          keyCode
        }
      };
    }).forEach((item) => {
      d.add(shortcutService.registerShortcut(item));
    });
    return () => {
      d.dispose();
    };
  }, [commandService, editor, isNeed, shortcutService]);
};

// ../packages/docs-ui/src/views/rich-text-editor/hooks/use-on-change.ts
var import_react50 = __toESM(require_react());
function useOnChange(editor, onChange) {
  const commandService = useDependency(ICommandService);
  (0, import_react50.useEffect)(() => {
    if (!editor) return;
    const dispose = commandService.onCommandExecuted((command) => {
      var _a, _b;
      if (command.id === RichTextEditingMutation.id) {
        const params = command.params;
        if (params.unitId !== editor.getEditorId()) return;
        const data2 = editor.getDocumentData();
        onChange(data2, getPlainText((_b = (_a = data2.body) == null ? void 0 : _a.dataStream) != null ? _b : ""));
      }
    });
    return () => {
      dispose.dispose();
    };
  }, [editor, onChange, commandService]);
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/docs-ui/src/views/rich-text-editor/index.module.less
var index_module_default15 = {
  "richTextEditorActive": "univer-rich-text-editor-active",
  "richTextEditorWrap": "univer-rich-text-editor-wrap",
  "richTextEditorText": "univer-rich-text-editor-text",
  "richTextEditorErrorWrap": "univer-rich-text-editor-error-wrap",
  "richTextEditorPlaceholder": "univer-rich-text-editor-placeholder"
};

// ../packages/docs-ui/src/views/rich-text-editor/index.tsx
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var RichTextEditor = (props) => {
  var _a;
  const {
    className,
    autoFocus,
    onFocusChange: _onFocusChange,
    initialValue,
    onClickOutside: _onClickOutside,
    keyboardEventConfig,
    moveCursor = true,
    style,
    isSingle,
    editorId: propsEditorId,
    onHeightChange,
    onChange: _onChange,
    defaultHeight = 32,
    maxHeight = 32,
    icon,
    editorRef
  } = props;
  const editorService = useDependency(IEditorService);
  const onFocusChange = useEvent(_onFocusChange);
  const onClickOutside = useEvent(_onClickOutside);
  const [height, setHeight] = (0, import_react51.useState)(defaultHeight);
  const formulaEditorContainerRef = import_react51.default.useRef(null);
  const editorId = (0, import_react51.useMemo)(() => propsEditorId != null ? propsEditorId : createInternalEditorID(`RICH_TEXT_EDITOR-${generateRandomId(4)}`), [propsEditorId]);
  const editor = useEditor({
    editorId,
    initialValue,
    container: formulaEditorContainerRef,
    autoFocus,
    isSingle
  });
  const renderManagerService = useDependency(IRenderManagerService);
  const renderer = renderManagerService.getRenderById(editorId);
  const docSelectionRenderService = renderer == null ? void 0 : renderer.with(DocSelectionRenderService);
  const selections = useObservable(docSelectionRenderService == null ? void 0 : docSelectionRenderService.textSelectionInner$);
  const isFocusing = Boolean(((_a = docSelectionRenderService == null ? void 0 : docSelectionRenderService.isFocusing) != null ? _a : false) && (selections == null ? void 0 : selections.textRanges.some((r) => r.collapsed)));
  const sheetEmbeddingRef = import_react51.default.useRef(null);
  const [showPlaceholder, setShowPlaceholder] = (0, import_react51.useState)(() => {
    var _a2, _b;
    return !BuildTextUtils.transform.getPlainText((_b = (_a2 = editor == null ? void 0 : editor.getDocumentData().body) == null ? void 0 : _a2.dataStream) != null ? _b : "");
  });
  const { checkScrollBar } = useResize(editor, isSingle, true, true);
  (0, import_react51.useLayoutEffect)(() => {
    if (!editorRef || !editor) return;
    if (typeof editorRef === "function") {
      editorRef(editor);
      return;
    }
    editorRef.current = editor;
  }, [editor]);
  const onChange = useEvent((data2) => {
    var _a2, _b;
    const docSkeleton = renderer == null ? void 0 : renderer.with(DocSkeletonManagerService);
    const size = docSkeleton == null ? void 0 : docSkeleton.getSkeleton().getActualSize();
    if (size) {
      onHeightChange == null ? void 0 : onHeightChange(size.actualHeight);
      setHeight(Math.max(defaultHeight, Math.min(size.actualHeight + 10, maxHeight)));
    }
    _onChange == null ? void 0 : _onChange(data2, getPlainText((_b = (_a2 = data2.body) == null ? void 0 : _a2.dataStream) != null ? _b : ""));
    checkScrollBar();
  });
  (0, import_react51.useEffect)(() => {
    var _a2, _b;
    setShowPlaceholder(!BuildTextUtils.transform.getPlainText((_b = (_a2 = editor == null ? void 0 : editor.getDocumentData().body) == null ? void 0 : _a2.dataStream) != null ? _b : ""));
    const sub = editor == null ? void 0 : editor.selectionChange$.subscribe(() => {
      var _a3, _b2;
      setShowPlaceholder(!BuildTextUtils.transform.getPlainText((_b2 = (_a3 = editor == null ? void 0 : editor.getDocumentData().body) == null ? void 0 : _a3.dataStream) != null ? _b2 : ""));
    });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [editor]);
  useObservable(editor == null ? void 0 : editor.blur$);
  useObservable(editor == null ? void 0 : editor.focus$);
  (0, import_react51.useEffect)(() => {
    var _a2, _b;
    const data2 = editor == null ? void 0 : editor.getDocumentData();
    onFocusChange == null ? void 0 : onFocusChange(isFocusing, getPlainText((_b = (_a2 = data2 == null ? void 0 : data2.body) == null ? void 0 : _a2.dataStream) != null ? _b : ""));
  }, [isFocusing, onFocusChange]);
  (0, import_react51.useEffect)(() => {
    const handleClickOutside = (event) => {
      var _a2, _b;
      if (editorService.getFocusId() !== editorId) return;
      const id = (_b = (_a2 = event.target) == null ? void 0 : _a2.dataset) == null ? void 0 : _b.editorid;
      if (id === editorId) return;
      if (sheetEmbeddingRef.current && !sheetEmbeddingRef.current.contains(event.target)) {
        onClickOutside == null ? void 0 : onClickOutside();
      }
    };
    const timer = setTimeout(() => {
      document.addEventListener("click", handleClickOutside);
    }, 100);
    return () => {
      document.removeEventListener("click", handleClickOutside);
      clearTimeout(timer);
    };
  }, [editor, editorId, editorService, onClickOutside]);
  useLeftAndRightArrow(isFocusing && moveCursor, false, editor);
  useKeyboardEvent(isFocusing, keyboardEventConfig, editor);
  useOnChange(editor, onChange);
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("div", { className: clsx(index_module_default15.richTextEditor, className), style, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(
    "div",
    {
      className: clsx(index_module_default15.richTextEditorWrap, {
        [index_module_default15.richTextEditorActive]: isFocusing
      }),
      style: { height },
      ref: sheetEmbeddingRef,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
          "div",
          {
            className: index_module_default15.richTextEditorText,
            ref: formulaEditorContainerRef,
            onMouseUp: () => editor == null ? void 0 : editor.focus()
          }
        ),
        icon,
        !showPlaceholder ? null : /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("div", { className: index_module_default15.richTextEditorPlaceholder, children: props.placeholder })
      ]
    }
  ) });
};

export {
  ComponentManager,
  ZIndexManager,
  getMenuHiddenObservable,
  connectInjector,
  useInjector,
  useDependency,
  useObservable,
  CustomLabel,
  FontFamily,
  FontFamilyItem,
  FONT_FAMILY_LIST,
  FontSize,
  FONT_SIZE_LIST,
  useEvent,
  useScrollYOverContainer,
  Slider,
  useUpdateEffect,
  RectPopup,
  ILayoutService,
  DesktopLayoutService,
  MenuManagerPosition,
  RibbonPosition,
  RibbonStartGroup,
  IMenuManagerService,
  MenuManagerService,
  Menu2 as Menu,
  ProgressBar,
  UNI_DISABLE_CHANGING_FOCUS_KEY,
  UI_PLUGIN_CONFIG_KEY,
  IMessageService,
  ErrorController,
  ShortcutPanelService,
  ILeftSidebarService,
  ISidebarService,
  menuSchema,
  CopyCommand,
  CutCommand,
  PasteCommand,
  SheetPasteShortKeyCommandName,
  KeyCode,
  IPlatformService,
  PlatformService,
  IShortcutService,
  ShortcutService,
  SharedController,
  ShortcutPanelController,
  IUIController,
  FIX_ONE_PIXEL_BLUR_OFFSET,
  DRAWING_OBJECT_LAYER_INDEX,
  FontCache,
  getColor,
  requestNewFrame,
  cancelRequestFrame,
  degToRad,
  isObject,
  precisionTo,
  fixLineWidthByScale,
  getFontStyleString,
  hasCJKText,
  pxToNum,
  ptToPixel,
  Vector2,
  Transform,
  getGroupState,
  transformObjectOutOfGroup,
  convertTextRotation,
  Canvas,
  SpreadsheetExtensionRegistry,
  SpreadsheetColumnHeader,
  sheetContentViewportKeys,
  SHEET_EXTENSION_PREFIX,
  SheetExtension,
  Liquid,
  DocumentViewModel,
  DocumentSkeleton,
  DEFAULT_PADDING_DATA,
  RENDER_RAW_FORMULA_KEY,
  SpreadsheetSkeleton,
  convertTransformToOffsetX,
  convertTransformToOffsetY,
  getDocsSkeletonPageSize,
  SpreadsheetRowHeader,
  Shape,
  CheckboxShape,
  Rect,
  DashedRect,
  Image2 as Image,
  RegularPolygon,
  RichText,
  ScrollBar,
  Documents,
  Spreadsheet,
  Layer,
  WatermarkLayer,
  UNIVER_WATERMARK_STORAGE_KEY,
  UNIVER_WATERMARK_LAYER_INDEX,
  SceneViewer,
  Slide,
  Group,
  ScrollTimer,
  Scene,
  IRenderManagerService,
  getCurrentTypeOfRenderer,
  withCurrentTypeOfRenderer,
  IRenderingEngine,
  UniverRenderEnginePlugin,
  Viewport,
  BuiltInUIPart,
  IUIPartsService,
  UIPartsService,
  CanvasFloatDomService,
  FloatDom,
  ICanvasPopupService,
  CanvasPopupService,
  CanvasPopup,
  ComponentContainer,
  useComponentsOfPart,
  ToolbarItem,
  IContextMenuService,
  ContextMenuService,
  DesktopContextMenu,
  IGlobalZoneService,
  GlobalZone,
  IZenZoneService,
  INotificationService,
  IBeforeCloseService,
  DesktopBeforeCloseService,
  supportClipboardAPI,
  PLAIN_TEXT_CLIPBOARD_MIME_TYPE,
  HTML_CLIPBOARD_MIME_TYPE,
  FILE_PNG_CLIPBOARD_MIME_TYPE,
  FILE__JPEG_CLIPBOARD_MIME_TYPE,
  FILE__BMP_CLIPBOARD_MIME_TYPE,
  FILE__WEBP_CLIPBOARD_MIME_TYPE,
  imageMimeTypeSet,
  IClipboardInterfaceService,
  BrowserClipboardService,
  IConfirmService,
  DesktopConfirmService,
  IDialogService,
  DesktopDialogService,
  DesktopGlobalZoneService,
  DesktopLocalStorageService,
  DesktopMessageService,
  DesktopNotificationService,
  DesktopSidebarService,
  DesktopZenZoneService,
  UniverMobileUIPlugin,
  DesktopLocalFileService,
  ILocalFileService,
  useSidebarClick,
  UNIVER_UI_PLUGIN_NAME,
  DISABLE_AUTO_FOCUS_KEY,
  UniverUIPlugin,
  textTrim,
  DEFAULT_BACKGROUND_COLOR_RGBA,
  DEFAULT_BACKGROUND_COLOR_RGB,
  handleStringToStyle,
  DRAWING_IMAGE_WIDTH_LIMIT,
  DRAWING_IMAGE_HEIGHT_LIMIT,
  DRAWING_IMAGE_COUNT_LIMIT,
  DRAWING_IMAGE_ALLOW_SIZE,
  DRAWING_IMAGE_ALLOW_IMAGE_LIST,
  UnitDrawingService,
  getDrawingShapeKeyByDrawingSearch,
  getImageSize,
  IDrawingManagerService,
  SetDrawingSelectedOperation,
  UniverDrawingPlugin,
  SetTextSelectionsOperation,
  DocSelectionManagerService,
  DocSkeletonManagerService,
  RichTextEditingMutation,
  UniverDocsPlugin,
  DOC_INTERCEPTOR_POINT,
  DocInterceptorService,
  addCustomRangeBySelectionFactory,
  deleteCustomRangeFactory,
  replaceSelectionFactory,
  DOCS_COMPONENT_MAIN_LAYER_INDEX,
  getDocObject,
  addCustomDecorationBySelectionFactory,
  deleteCustomDecorationFactory,
  docDrawingPositionToTransform,
  useKeyboardEvent,
  useResize,
  getRichTextEditPath2 as getRichTextEditPath,
  ReplaceSnapshotCommand,
  CoverContentCommand,
  ReplaceTextRunsCommand,
  getOneTextSelectionRange,
  NodePositionConvertToCursor,
  TEXT_RANGE_LAYER_INDEX,
  getAnchorBounding,
  getLineBounding,
  getCanvasOffsetByEngine,
  DocSelectionRenderService,
  IEditorService,
  MoveCursorOperation,
  MoveSelectionOperation,
  RichTextEditor,
  whenDocAndEditorFocused,
  SetInlineFormatBoldCommand,
  SetInlineFormatItalicCommand,
  SetInlineFormatUnderlineCommand,
  SetInlineFormatStrikethroughCommand,
  SetInlineFormatSubscriptCommand,
  SetInlineFormatSuperscriptCommand,
  SetInlineFormatFontSizeCommand,
  SetInlineFormatFontFamilyCommand,
  SetInlineFormatTextColorCommand,
  SetInlineFormatTextBackgroundColorCommand,
  SetInlineFormatCommand,
  BulletListCommand,
  OrderListCommand,
  SetDocZoomRatioOperation,
  getCustomBlockIdsInSelections,
  CutContentCommand,
  InsertCommand,
  DeleteCommand,
  DeleteLeftCommand,
  BreakLineCommand,
  HorizontalLineCommand,
  DocCreateTableOperation,
  menuSchema2,
  DocUIController,
  DocBackScrollRenderController,
  DocRenderController,
  IMEInputCommand,
  calcDocRangePositions,
  DocCanvasPopManagerService,
  DOC_VERTICAL_PADDING,
  DocEventManagerService,
  IRangeSelectorService,
  UniverDocsUIPlugin
};
/*! Bundled license information:

localforage/dist/localforage.js:
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)

opentype.js/dist/opentype.module.js:
  (*! https://mths.be/codepointat v0.2.0 by @mathias *)
*/
//# sourceMappingURL=chunk-DOZPYWOG.js.map
