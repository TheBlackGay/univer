import {
  BreakLineCommand,
  ComponentContainer,
  ComponentManager,
  CopyCommand,
  CoverContentCommand,
  CutCommand,
  DEFAULT_BACKGROUND_COLOR_RGB,
  DEFAULT_BACKGROUND_COLOR_RGBA,
  DEFAULT_PADDING_DATA,
  DISABLE_AUTO_FOCUS_KEY,
  DOCS_COMPONENT_MAIN_LAYER_INDEX,
  DOC_VERTICAL_PADDING,
  DashedRect,
  DeleteLeftCommand,
  DocSelectionManagerService,
  DocSelectionRenderService,
  DocSkeletonManagerService,
  FILE_PNG_CLIPBOARD_MIME_TYPE,
  FILE__BMP_CLIPBOARD_MIME_TYPE,
  FILE__JPEG_CLIPBOARD_MIME_TYPE,
  FILE__WEBP_CLIPBOARD_MIME_TYPE,
  FIX_ONE_PIXEL_BLUR_OFFSET,
  FONT_FAMILY_LIST,
  FONT_SIZE_LIST,
  FontFamily,
  FontFamilyItem,
  FontSize,
  Group,
  HTML_CLIPBOARD_MIME_TYPE,
  ICanvasPopupService,
  IClipboardInterfaceService,
  IConfirmService,
  IContextMenuService,
  IDialogService,
  IEditorService,
  ILayoutService,
  IMEInputCommand,
  IMenuManagerService,
  IMessageService,
  INotificationService,
  IPlatformService,
  IRangeSelectorService,
  IRenderManagerService,
  IShortcutService,
  ISidebarService,
  IUIPartsService,
  IZenZoneService,
  InsertCommand,
  Layer,
  Menu,
  MoveCursorOperation,
  MoveSelectionOperation,
  NodePositionConvertToCursor,
  PLAIN_TEXT_CLIPBOARD_MIME_TYPE,
  PasteCommand,
  RENDER_RAW_FORMULA_KEY,
  Rect,
  RegularPolygon,
  ReplaceSnapshotCommand,
  RichTextEditingMutation,
  SHEET_EXTENSION_PREFIX,
  ScrollBar,
  ScrollTimer,
  SetInlineFormatBoldCommand,
  SetInlineFormatCommand,
  SetInlineFormatFontFamilyCommand,
  SetInlineFormatFontSizeCommand,
  SetInlineFormatItalicCommand,
  SetInlineFormatStrikethroughCommand,
  SetInlineFormatSubscriptCommand,
  SetInlineFormatSuperscriptCommand,
  SetInlineFormatTextColorCommand,
  SetInlineFormatUnderlineCommand,
  SetTextSelectionsOperation,
  Shape,
  SheetExtension,
  SheetPasteShortKeyCommandName,
  Slider,
  Spreadsheet,
  SpreadsheetColumnHeader,
  SpreadsheetRowHeader,
  SpreadsheetSkeleton,
  ToolbarItem,
  UI_PLUGIN_CONFIG_KEY,
  UniverMobileUIPlugin,
  Vector2,
  Viewport,
  cancelRequestFrame,
  connectInjector,
  convertTextRotation,
  convertTransformToOffsetX,
  convertTransformToOffsetY,
  fixLineWidthByScale,
  getCanvasOffsetByEngine,
  getCurrentTypeOfRenderer,
  getLineBounding,
  getMenuHiddenObservable,
  handleStringToStyle,
  hasCJKText,
  imageMimeTypeSet,
  precisionTo,
  ptToPixel,
  requestNewFrame,
  textTrim,
  useComponentsOfPart,
  useDependency,
  useEvent,
  useObservable,
  useSidebarClick,
  withCurrentTypeOfRenderer
} from "./chunk-DOZPYWOG.js";
import {
  Avatar,
  Button,
  ColorPicker,
  Confirm,
  Dropdown,
  DropdownLegacy,
  DropdownMenu,
  FormLayout,
  Input,
  InputNumber,
  Radio,
  RadioGroup,
  Select,
  Separator,
  Switch,
  Tooltip,
  autofill_default,
  check_mark_single_default,
  close_single_default,
  clsx,
  convert_single_default,
  delete_single_default,
  dropdown_single_default,
  error_single_default,
  eyelash_single_default,
  fx_single_default,
  hide_gridlines_default,
  increase_single_default,
  lock_single_default,
  more_down_single_default,
  more_single_default,
  paint_bucket_default,
  paste_special_default,
  protect_single_default,
  require_jsx_runtime,
  require_react,
  warning_single_default,
  write_single_default
} from "./chunk-22LKBS37.js";
import {
  AddMergeRedoSelectionsOperationFactory,
  AddMergeUndoMutationFactory,
  AddMergeUndoSelectionsOperationFactory,
  AddRangeProtectionCommand,
  AddRangeProtectionMutation,
  AddWorksheetMergeAllCommand,
  AddWorksheetMergeCommand,
  AddWorksheetMergeHorizontalCommand,
  AddWorksheetMergeMutation,
  AddWorksheetMergeVerticalCommand,
  AddWorksheetProtectionCommand,
  BEFORE_CELL_EDIT,
  BehaviorSubject,
  BorderStyleManagerService,
  COMMAND_LISTENER_SKELETON_CHANGE,
  COMMAND_LISTENER_VALUE_CHANGE,
  CancelFrozenCommand,
  ClearSelectionAllCommand,
  ClearSelectionContentCommand,
  ClearSelectionFormatCommand,
  ColorKit,
  CopySheetCommand,
  D,
  DEFAULT_EMPTY_DOCUMENT_VALUE,
  DEFAULT_STYLES,
  DEFAULT_WORKSHEET_COLUMN_WIDTH,
  DEFAULT_WORKSHEET_COLUMN_WIDTH_KEY,
  DEFAULT_WORKSHEET_ROW_HEIGHT,
  DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
  DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
  DeleteRangeMoveLeftCommand,
  DeleteRangeMoveUpCommand,
  DeleteRangeProtectionCommand,
  DeleteRangeProtectionMutation,
  DeleteWorksheetProtectionCommand,
  DeltaColumnWidthCommand,
  DeltaRowHeightCommand,
  DependentOn,
  Disposable,
  DisposableCollection,
  EDITOR_ACTIVATED,
  EMPTY,
  ErrorService,
  FOCUSING_COMMON_DRAWINGS,
  FOCUSING_EDITOR_BUT_HIDDEN,
  FOCUSING_EDITOR_INPUT_FORMULA,
  FOCUSING_EDITOR_STANDALONE,
  FOCUSING_FX_BAR_EDITOR,
  FOCUSING_SHEET,
  FOCUSING_UNIVER_EDITOR,
  G,
  IAuthzIoService,
  ICommandService,
  IConfigService,
  IContextService,
  IDefinedNamesService,
  IExclusiveRangeService,
  IFunctionService,
  ILogService,
  INTERCEPTOR_POINT,
  INumfmtService,
  IPermissionService,
  IRefSelectionsService,
  IUndoRedoService,
  IUniverInstanceService,
  Inject,
  Injector,
  InsertColBeforeCommand,
  InsertColCommand,
  InsertColMutation,
  InsertDefinedNameCommand,
  InsertMultiColsLeftCommand,
  InsertMultiColsRightCommand,
  InsertMultiRowsAboveCommand,
  InsertMultiRowsAfterCommand,
  InsertRangeMoveDownCommand,
  InsertRangeMoveRightCommand,
  InsertRowBeforeCommand,
  InsertRowCommand,
  InsertRowMutation,
  InsertSheetCommand,
  InsertSheetMutation,
  InterceptorManager,
  LRUMap,
  LexerTreeBuilder,
  LocaleService,
  MAX_CELL_PER_SHEET_KEY,
  MERGE_CELL_INTERCEPTOR_CHECK,
  MergeCellController,
  MoveColsCommand,
  MoveColsMutation,
  MoveRangeCommand,
  MoveRangeMutation,
  MoveRowsCommand,
  MoveRowsMutation,
  NilCommand,
  NullValueObject,
  O,
  ObjectMatrix,
  Observable,
  Optional,
  Plugin,
  Quantity,
  REF_SELECTIONS_ENABLED,
  Range,
  RangeProtectionCache,
  RangeProtectionPermissionEditPoint,
  RangeProtectionPermissionViewPoint,
  RangeProtectionRuleModel,
  Rectangle,
  RefRangeService,
  RefSelectionsService,
  RemoveColCommand,
  RemoveColMutation,
  RemoveDefinedNameCommand,
  RemoveMergeUndoMutationFactory,
  RemoveRowCommand,
  RemoveRowMutation,
  RemoveSheetCommand,
  RemoveSheetMutation,
  RemoveWorksheetMergeCommand,
  RemoveWorksheetMergeMutation,
  ReorderRangeCommand,
  ResetBackgroundColorCommand,
  ResetTextColorCommand,
  RxDisposable,
  S,
  SCOPE_WORKBOOK_VALUE_DEFINED_NAME,
  SELECTIONS_ENABLED,
  SELECTION_CONTROL_BORDER_BUFFER_COLOR,
  SELECTION_CONTROL_BORDER_BUFFER_WIDTH,
  ScrollToCellOperation,
  SetBackgroundColorCommand,
  SetBoldCommand,
  SetBorderBasicCommand,
  SetColHiddenCommand,
  SetColHiddenMutation,
  SetColVisibleMutation,
  SetColWidthCommand,
  SetDefinedNameCommand,
  SetFontFamilyCommand,
  SetFontSizeCommand,
  SetFormulaCalculationNotificationMutation,
  SetFrozenCommand,
  SetFrozenMutation,
  SetFrozenMutationFactory,
  SetHorizontalTextAlignCommand,
  SetItalicCommand,
  SetProtectionCommand,
  SetRangeValuesCommand,
  SetRangeValuesMutation,
  SetRangeValuesUndoMutationFactory,
  SetRowHeightCommand,
  SetRowHiddenCommand,
  SetRowHiddenMutation,
  SetRowVisibleMutation,
  SetSelectedColsVisibleCommand,
  SetSelectedRowsVisibleCommand,
  SetSelectionsOperation,
  SetSpecificColsVisibleCommand,
  SetSpecificRowsVisibleCommand,
  SetStrikeThroughCommand,
  SetStyleCommand,
  SetTabColorCommand,
  SetTabColorMutation,
  SetTextColorCommand,
  SetTextRotationCommand,
  SetTextWrapCommand,
  SetUnderlineCommand,
  SetVerticalTextAlignCommand,
  SetWorksheetActivateCommand,
  SetWorksheetActiveOperation,
  SetWorksheetColWidthMutation,
  SetWorksheetHideCommand,
  SetWorksheetHideMutation,
  SetWorksheetNameCommand,
  SetWorksheetNameMutation,
  SetWorksheetOrderCommand,
  SetWorksheetOrderMutation,
  SetWorksheetPermissionPointsCommand,
  SetWorksheetRowAutoHeightMutation,
  SetWorksheetRowAutoHeightMutationFactory,
  SetWorksheetRowHeightMutation,
  SetWorksheetRowIsAutoHeightCommand,
  SetWorksheetRowIsAutoHeightMutation,
  SetWorksheetShowCommand,
  SheetInterceptorService,
  SheetPermissionCheckController,
  SheetPermissionInitController,
  SheetSkeletonService,
  SheetsSelectionsService,
  Subject,
  Subscription,
  ThemeService,
  ToggleCellCheckboxCommand,
  ToggleGridlinesCommand,
  ToggleGridlinesMutation,
  Tools,
  UndoCommandId,
  UniverSheetsPlugin,
  UserManagerService,
  Workbook,
  WorkbookCopyPermission,
  WorkbookCreateProtectPermission,
  WorkbookCreateSheetPermission,
  WorkbookDeleteSheetPermission,
  WorkbookEditablePermission,
  WorkbookHideSheetPermission,
  WorkbookManageCollaboratorPermission,
  WorkbookRenameSheetPermission,
  WorksheetCopyPermission,
  WorksheetDeleteColumnPermission,
  WorksheetDeleteProtectionPermission,
  WorksheetDeleteRowPermission,
  WorksheetEditPermission,
  WorksheetInsertColumnPermission,
  WorksheetInsertRowPermission,
  WorksheetManageCollaboratorPermission,
  WorksheetProtectionPointModel,
  WorksheetProtectionRuleModel,
  WorksheetSetCellStylePermission,
  WorksheetSetCellValuePermission,
  WorksheetSetColumnStylePermission,
  WorksheetSetRowStylePermission,
  WorksheetViewPermission,
  a,
  adjustRangeOnMutation,
  alignToMergedCellsBorders,
  baseProtectionActions,
  cellToRange,
  combineLatest,
  combineLatestWith,
  composeStyles,
  convertBodyToHtml,
  convertCellToRange,
  convertSelectionDataToRange,
  createIdentifier,
  createInterceptorKey,
  debounceTime,
  debounce_default,
  deserializeRangeWithSheet,
  distinctUntilChanged,
  expandToContinuousRange,
  extractPureTextFromCell,
  filter,
  finalize,
  fromEventSubject,
  generateNullCellValue,
  generateRandomId,
  getAddMergeMutationRangeByType,
  getAllWorksheetPermissionPoint,
  getCellAtRowCol,
  getPrimaryForRange,
  getReverseDirection,
  getSelectionsService,
  getSheetCommandTarget,
  handleStyleToString,
  isFormulaId,
  isFormulaString,
  isNotNullOrUndefined,
  isRealNum,
  isReferenceStringWithEffectiveColumn,
  isReferenceStrings,
  isTextFormat,
  isValidRange,
  map,
  merge,
  mergeOverrideWithDependencies,
  merge_default,
  nameCharacterCheck,
  numfmt,
  of,
  rangeToDiscreteRange,
  registerDependencies,
  sequenceExecute,
  serializeRange,
  serializeRangeWithSheet,
  setEndForRange,
  skipParseTagNames,
  sortRules,
  splitIntoGrid,
  startWith,
  switchMap,
  takeUntil,
  throttleTime,
  toDisposable,
  touchDependencies,
  withLatestFrom
} from "./chunk-33NDYU5R.js";
import {
  __decorateClass,
  __decorateParam,
  __publicField,
  __toESM
} from "./chunk-NSSCU2QI.js";

// ../packages/sheets-ui/src/common/utils.ts
function getUserListEqual(userList1, userList2) {
  if (userList1.length !== userList2.length) return false;
  const sorted1 = userList1.sort((a2, b) => a2.id.localeCompare(b.id));
  const sorted2 = userList2.sort((a2, b) => a2.id.localeCompare(b.id));
  return sorted1.every((user, index) => {
    var _a, _b;
    return ((_a = user.subject) == null ? void 0 : _a.userID) === ((_b = sorted2[index].subject) == null ? void 0 : _b.userID) && user.role === sorted2[index].role;
  });
}
function checkCellContentInRanges(worksheet, ranges) {
  return ranges.some((range) => checkCellContentInRange(worksheet, range));
}
function checkCellContentInRange(worksheet, range) {
  const { startRow, startColumn, endColumn, endRow } = range;
  const cellMatrix = worksheet.getMatrixWithMergedCells(startRow, startColumn, endRow, endColumn);
  let someCellGoingToBeRemoved = false;
  cellMatrix.forValue((row, col, cellData) => {
    if (cellData && (row !== startRow || col !== startColumn) && worksheet.cellHasValue(cellData)) {
      someCellGoingToBeRemoved = true;
      return false;
    }
  });
  return someCellGoingToBeRemoved;
}
function getClearContentMutationParamsForRanges(accessor, unitId, worksheet, ranges) {
  const undos = [];
  const redos = [];
  const subUnitId = worksheet.getSheetId();
  ranges.forEach((range) => {
    const redoMatrix = getClearContentMutationParamForRange(worksheet, range);
    const redoMutationParams = {
      unitId,
      subUnitId,
      cellValue: redoMatrix.getData()
    };
    const undoMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      redoMutationParams
    );
    undos.push({ id: SetRangeValuesMutation.id, params: undoMutationParams });
    redos.push({ id: SetRangeValuesMutation.id, params: redoMutationParams });
  });
  return {
    undos,
    redos
  };
}
function getClearContentMutationParamForRange(worksheet, range) {
  const { startRow, startColumn, endColumn, endRow } = range;
  const cellMatrix = worksheet.getMatrixWithMergedCells(startRow, startColumn, endRow, endColumn, "intercepted" /* Intercepted */);
  const redoMatrix = new ObjectMatrix();
  let leftTopCellValue = null;
  cellMatrix.forValue((row, col, cellData) => {
    var _a, _b, _c, _d;
    if (cellData && row >= startRow && col >= startColumn) {
      if (!leftTopCellValue && worksheet.cellHasValue(cellData) && (cellData.v !== "" || ((_d = (_c = (_b = (_a = cellData.p) == null ? void 0 : _a.body) == null ? void 0 : _b.dataStream) == null ? void 0 : _c.length) != null ? _d : 0) > 2)) {
        leftTopCellValue = cellData;
      }
      redoMatrix.setValue(row, col, null);
    }
  });
  redoMatrix.setValue(startRow, startColumn, leftTopCellValue);
  return redoMatrix;
}
function getCellIndexByOffsetWithMerge(offsetX, offsetY, scene, skeleton) {
  const activeViewport = scene.getActiveViewportByCoord(
    Vector2.FromArray([offsetX, offsetY])
  );
  if (!activeViewport) {
    return;
  }
  const { scaleX, scaleY } = scene.getAncestorScale();
  const scrollXY = {
    x: activeViewport.viewportScrollX,
    y: activeViewport.viewportScrollY
  };
  const cellIndex = skeleton.getCellIndexByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
  const mergeCell = skeleton.worksheet.getMergedCell(cellIndex.row, cellIndex.column);
  const params = {
    actualRow: mergeCell ? mergeCell.startRow : cellIndex.row,
    actualCol: mergeCell ? mergeCell.startColumn : cellIndex.column,
    mergeCell,
    row: cellIndex.row,
    col: cellIndex.column
  };
  return params;
}
function getViewportByCell(row, column, scene, worksheet) {
  const freeze = worksheet.getFreeze();
  if (!freeze || freeze.startRow <= 0 && freeze.startColumn <= 0) {
    return scene.getViewport("viewMain" /* VIEW_MAIN */);
  }
  if (row >= freeze.startRow && column >= freeze.startColumn) {
    return scene.getViewport("viewMain" /* VIEW_MAIN */);
  }
  if (row < freeze.startRow && column < freeze.startColumn) {
    return scene.getViewport("viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */);
  }
  if (row < freeze.startRow && column >= freeze.startColumn) {
    return scene.getViewport("viewMainTop" /* VIEW_MAIN_TOP */);
  }
  if (row >= freeze.startRow && column < freeze.startColumn) {
    return scene.getViewport("viewMainLeft" /* VIEW_MAIN_LEFT */);
  }
}
function transformBound2OffsetBound(originBound, scene, skeleton, worksheet) {
  const topLeft = transformPosition2Offset(originBound.left, originBound.top, scene, skeleton, worksheet);
  const bottomRight = transformPosition2Offset(originBound.right, originBound.bottom, scene, skeleton, worksheet);
  return {
    left: topLeft.x,
    top: topLeft.y,
    right: bottomRight.x,
    bottom: bottomRight.y
  };
}
function transformPosition2Offset(x, y, scene, skeleton, worksheet) {
  const { scaleX, scaleY } = scene.getAncestorScale();
  const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
  if (!viewMain) {
    return {
      x,
      y
    };
  }
  const freeze = worksheet.getFreeze();
  const { startColumn, startRow, xSplit, ySplit } = freeze;
  const startSheetView = skeleton.getNoMergeCellWithCoordByIndex(startRow - ySplit, startColumn - xSplit, false);
  const endSheetView = skeleton.getNoMergeCellWithCoordByIndex(startRow, startColumn, false);
  const { rowHeaderWidth, columnHeaderHeight } = skeleton;
  const freezeWidth = endSheetView.startX - startSheetView.startX;
  const freezeHeight = endSheetView.startY - startSheetView.startY;
  const { top, left, viewportScrollX, viewportScrollY } = viewMain;
  let offsetX;
  if (x > left) {
    offsetX = (x - viewportScrollX) * scaleX;
  } else {
    offsetX = (freezeWidth + rowHeaderWidth - (left - x)) * scaleX;
  }
  let offsetY;
  if (y > top) {
    offsetY = (y - viewportScrollY) * scaleY;
  } else {
    offsetY = (freezeHeight + columnHeaderHeight - (top - y)) * scaleX;
  }
  return {
    x: offsetX,
    y: offsetY
  };
}
function getCellRealRange(workbook, worksheet, skeleton, row, col) {
  let actualRow = row;
  let actualCol = col;
  skeleton.overflowCache.forValue((r, c, range) => {
    if (range.startRow <= actualRow && range.endRow >= actualRow && range.startColumn <= actualCol && range.endColumn >= actualCol) {
      actualCol = c;
      actualRow = r;
    }
  });
  const actualCell = skeleton.getCellWithCoordByIndex(actualRow, actualCol);
  const location = {
    unitId: workbook.getUnitId(),
    subUnitId: worksheet.getSheetId(),
    workbook,
    worksheet,
    row: actualCell.actualRow,
    col: actualCell.actualColumn
  };
  return location;
}
function getHoverCellPosition(currentRender, workbook, worksheet, skeletonParam, offsetX, offsetY) {
  const { scene } = currentRender;
  const unitId = workbook.getUnitId();
  const { skeleton, sheetId } = skeletonParam;
  const cellIndex = getCellIndexByOffsetWithMerge(offsetX, offsetY, scene, skeleton);
  if (!cellIndex) {
    return null;
  }
  let { actualCol, actualRow } = cellIndex;
  const originLocation = {
    unitId,
    subUnitId: sheetId,
    workbook,
    worksheet,
    row: actualRow,
    col: actualCol
  };
  skeleton.overflowCache.forValue((r, c, range) => {
    if (range.startRow <= actualRow && range.endRow >= actualRow && range.startColumn <= actualCol && range.endColumn >= actualCol) {
      actualCol = c;
      actualRow = r;
    }
  });
  const actualCell = skeleton.getCellWithCoordByIndex(actualRow, actualCol);
  const location = getCellRealRange(workbook, worksheet, skeleton, actualRow, actualCol);
  let anchorCell;
  if (actualCell.mergeInfo) {
    anchorCell = actualCell.mergeInfo;
  } else {
    anchorCell = {
      startRow: location.row,
      endRow: location.row,
      startColumn: location.col,
      endColumn: location.col
    };
  }
  const activeViewport = scene.getActiveViewportByCoord(
    Vector2.FromArray([offsetX, offsetY])
  );
  if (!activeViewport) {
    return;
  }
  const { scaleX, scaleY } = scene.getAncestorScale();
  const scrollXY = {
    x: activeViewport.viewportScrollX,
    y: activeViewport.viewportScrollY
  };
  const position = {
    startX: (skeleton.getOffsetByColumn(anchorCell.startColumn - 1) - scrollXY.x) * scaleX,
    endX: (skeleton.getOffsetByColumn(anchorCell.endColumn) - scrollXY.x) * scaleX,
    startY: (skeleton.getOffsetByRow(anchorCell.startRow - 1) - scrollXY.y) * scaleY,
    endY: (skeleton.getOffsetByRow(anchorCell.endRow) - scrollXY.y) * scaleY
  };
  return {
    position,
    location: originLocation,
    overflowLocation: location
  };
}

// ../packages/sheets-ui/src/commands/commands/utils/selection-utils.ts
function findNextRange(startRange, direction, worksheet, boundary, isFindNext = true, nextStep = 1, isGoBack = true) {
  let destRange = { ...startRange };
  if (boundary == null) {
    boundary = {
      startRow: 0,
      endRow: worksheet.getRowCount() - 1,
      startColumn: 0,
      endColumn: worksheet.getColumnCount() - 1
    };
  }
  let next;
  switch (direction) {
    case 0 /* UP */:
      next = startRange.startRow - nextStep;
      while (next > -1 && !worksheet.getRowVisible(next)) {
        next -= 1;
      }
      if (next >= boundary.startRow) {
        destRange.startRow = next;
        destRange.endRow = next;
      } else if (isGoBack) {
        destRange.startRow = boundary.endRow;
        destRange.endRow = boundary.endRow;
        if (isFindNext) {
          destRange = findNextRange(destRange, 3 /* LEFT */, worksheet, boundary, false);
        }
      }
      break;
    case 2 /* DOWN */:
      next = startRange.endRow + nextStep;
      while (next < worksheet.getRowCount() && !worksheet.getRowVisible(next)) {
        next += 1;
      }
      if (next <= boundary.endRow) {
        destRange.startRow = next;
        destRange.endRow = next;
      } else if (isGoBack) {
        destRange.startRow = boundary.startRow;
        destRange.endRow = boundary.startRow;
        if (isFindNext) {
          destRange = findNextRange(destRange, 1 /* RIGHT */, worksheet, boundary, false);
        }
      }
      break;
    case 3 /* LEFT */:
      next = startRange.startColumn - nextStep;
      while (next > -1 && !worksheet.getColVisible(next)) {
        next -= 1;
      }
      if (next >= boundary.startColumn) {
        destRange.startColumn = next;
        destRange.endColumn = next;
      } else if (isGoBack) {
        destRange.startColumn = boundary.endColumn;
        destRange.endColumn = boundary.endColumn;
        if (isFindNext) {
          destRange = findNextRange(destRange, 0 /* UP */, worksheet, boundary, false);
        }
      }
      break;
    case 1 /* RIGHT */:
      next = startRange.endColumn + nextStep;
      while (next < worksheet.getColumnCount() && !worksheet.getColVisible(next)) {
        next += 1;
      }
      if (next <= boundary.endColumn) {
        destRange.startColumn = next;
        destRange.endColumn = next;
      } else if (isGoBack) {
        destRange.startColumn = boundary.startColumn;
        destRange.endColumn = boundary.startColumn;
        if (isFindNext) {
          destRange = findNextRange(destRange, 2 /* DOWN */, worksheet, boundary, false);
        }
      }
      break;
    default:
      break;
  }
  return destRange;
}
function findNextGapRange(startRange, direction, worksheet) {
  const destRange = { ...startRange };
  const { startRow, startColumn, endRow, endColumn } = getEdgeOfRange(startRange, direction, worksheet);
  let currentPositionHasValue = rangeHasValue(worksheet, startRow, startColumn, endRow, endColumn).hasValue;
  let firstMove = true;
  let shouldContinue = true;
  while (shouldContinue) {
    if (0 /* UP */ === direction) {
      let next = destRange.startRow - 1;
      while (next > -1 && !worksheet.getRowVisible(next)) {
        next -= 1;
      }
      if (next === -1) {
        shouldContinue = false;
        break;
      }
      const { hasValue: nextRangeHasValue, matrix } = rangeHasValue(
        worksheet,
        next,
        destRange.startColumn,
        next,
        destRange.endColumn
      );
      if (currentPositionHasValue && !nextRangeHasValue && !firstMove) {
        shouldContinue = false;
        break;
      } else {
        if (matrix.getLength() !== 0) {
          let min = next;
          matrix.forValue((row) => {
            min = Math.min(row, min);
          });
          destRange.startRow = min;
        } else {
          destRange.startRow = next;
        }
        destRange.endRow = destRange.startRow;
        if (!currentPositionHasValue && nextRangeHasValue) {
          shouldContinue = false;
          break;
        }
        currentPositionHasValue = nextRangeHasValue;
        firstMove = false;
      }
    }
    if (2 /* DOWN */ === direction) {
      let next = destRange.endRow + 1;
      while (next < worksheet.getRowCount() && !worksheet.getRowVisible(next)) {
        next += 1;
      }
      if (next === worksheet.getRowCount()) {
        shouldContinue = false;
        break;
      }
      const { hasValue: nextRangeHasValue, matrix } = rangeHasValue(
        worksheet,
        next,
        destRange.startColumn,
        next,
        destRange.endColumn
      );
      if (currentPositionHasValue && !nextRangeHasValue && !firstMove) {
        shouldContinue = false;
        break;
      } else {
        if (matrix.getLength() !== 0) {
          let max = next;
          matrix.forValue((row, _, value) => {
            max = Math.max(row + (value.rowSpan || 1) - 1, max);
          });
          destRange.endRow = max;
        } else {
          destRange.endRow = next;
        }
        destRange.startRow = destRange.endRow;
        if (!currentPositionHasValue && nextRangeHasValue) {
          shouldContinue = false;
          break;
        }
        currentPositionHasValue = nextRangeHasValue;
        firstMove = false;
      }
    }
    if (3 /* LEFT */ === direction) {
      let next = destRange.startColumn - 1;
      while (next > -1 && !worksheet.getColVisible(next)) {
        next -= 1;
      }
      if (next === -1) {
        shouldContinue = false;
        break;
      }
      const { hasValue: nextRangeHasValue, matrix } = rangeHasValue(
        worksheet,
        destRange.startRow,
        next,
        destRange.endRow,
        next
      );
      if (currentPositionHasValue && !nextRangeHasValue && !firstMove) {
        shouldContinue = false;
        break;
      } else {
        if (matrix.getLength() !== 0) {
          let min = next;
          matrix.forValue((_, col) => {
            min = Math.min(col, min);
          });
          destRange.startColumn = min;
        } else {
          destRange.startColumn = next;
        }
        destRange.endColumn = destRange.startColumn;
        if (!currentPositionHasValue && nextRangeHasValue) {
          shouldContinue = false;
          break;
        }
        currentPositionHasValue = nextRangeHasValue;
        firstMove = false;
      }
    }
    if (1 /* RIGHT */ === direction) {
      let next = destRange.endColumn + 1;
      while (next < worksheet.getColumnCount() && !worksheet.getColVisible(next)) {
        next += 1;
      }
      if (next === worksheet.getColumnCount()) {
        shouldContinue = false;
        break;
      }
      const { hasValue: nextRangeHasValue, matrix } = rangeHasValue(
        worksheet,
        destRange.startRow,
        next,
        destRange.endRow,
        next
      );
      if (currentPositionHasValue && !nextRangeHasValue && !firstMove) {
        shouldContinue = false;
        break;
      } else {
        if (matrix.getLength() !== 0) {
          let max = next;
          matrix.forValue((_, col, value) => {
            max = Math.max(col + (value.colSpan || 1) - 1, max);
          });
          destRange.endColumn = max;
        } else {
          destRange.endColumn = next;
        }
        destRange.startColumn = destRange.endColumn;
        if (!currentPositionHasValue && nextRangeHasValue) {
          shouldContinue = false;
          break;
        }
        currentPositionHasValue = nextRangeHasValue;
        firstMove = false;
      }
    }
  }
  return alignToMergedCellsBorders(destRange, worksheet, true);
}
function findNextRangeExpand(startRange, direction, worksheet) {
  return findNextRange(startRange, direction, worksheet, void 0, false, 1, false);
}
function expandToNextGapRange(startRange, direction, worksheet) {
  const next = findNextGapRange(startRange, direction, worksheet);
  return alignToMergedCellsBorders(Rectangle.union(next, startRange), worksheet, true);
}
function expandToNextCell(startRange, direction, worksheet) {
  const next = findNextRangeExpand(startRange, direction, worksheet);
  const destRange = {
    startRow: Math.min(startRange.startRow, next.startRow),
    startColumn: Math.min(startRange.startColumn, next.startColumn),
    endRow: Math.max(startRange.endRow, next.endRow),
    endColumn: Math.max(startRange.endColumn, next.endColumn)
  };
  return alignToMergedCellsBorders(Rectangle.union(startRange, destRange), worksheet);
}
function shrinkToNextGapRange(startRange, anchorRange, direction, worksheet) {
  const reversedDirection = getReverseDirection(direction);
  const nextGap = findNextGapRange(getEdgeOfRange(startRange, reversedDirection, worksheet), direction, worksheet);
  if (direction === 0 /* UP */ && nextGap.startRow <= startRange.startRow) {
    return alignToMergedCellsBorders(
      { ...anchorRange, startColumn: startRange.startColumn, endColumn: startRange.endColumn },
      worksheet,
      true
    );
  }
  if (direction === 2 /* DOWN */ && nextGap.endRow >= startRange.endRow) {
    return alignToMergedCellsBorders(
      { ...anchorRange, startColumn: startRange.startColumn, endColumn: startRange.endColumn },
      worksheet,
      true
    );
  }
  if (direction === 3 /* LEFT */ && nextGap.startColumn <= startRange.startColumn) {
    return alignToMergedCellsBorders(
      { ...anchorRange, startRow: startRange.startRow, endRow: startRange.endRow },
      worksheet,
      true
    );
  }
  if (direction === 1 /* RIGHT */ && nextGap.endColumn >= startRange.endColumn) {
    return alignToMergedCellsBorders(
      { ...anchorRange, startRow: startRange.startRow, endRow: startRange.endRow },
      worksheet,
      true
    );
  }
  return Rectangle.union(Rectangle.clone(anchorRange), nextGap);
}
function shrinkToNextCell(startRange, direction, worksheet) {
  const reversedDirection = getReverseDirection(direction);
  const shrinkFromEdge = getEdgeOfRange(startRange, reversedDirection, worksheet);
  const otherEdge = getEdgeOfRange(startRange, direction, worksheet);
  const next = findNextRangeExpand(shrinkFromEdge, direction, worksheet);
  return alignToMergedCellsBorders(Rectangle.union(otherEdge, next), worksheet, false);
}
function expandToWholeSheet(worksheet) {
  return {
    startRow: 0,
    startColumn: 0,
    endRow: worksheet.getRowCount() - 1,
    endColumn: worksheet.getColumnCount() - 1,
    rangeType: 3 /* ALL */
  };
}
function getEdgeOfRange(startRange, direction, worksheet) {
  let destRange;
  switch (direction) {
    case 0 /* UP */:
      destRange = {
        startRow: startRange.startRow,
        startColumn: startRange.startColumn,
        endRow: startRange.startRow,
        endColumn: startRange.endColumn,
        rangeType: 0 /* NORMAL */
      };
      break;
    case 2 /* DOWN */:
      destRange = {
        startRow: startRange.endRow,
        startColumn: startRange.startColumn,
        endRow: startRange.endRow,
        endColumn: startRange.endColumn,
        rangeType: 0 /* NORMAL */
      };
      break;
    case 3 /* LEFT */:
      destRange = {
        startRow: startRange.startRow,
        startColumn: startRange.startColumn,
        endRow: startRange.endRow,
        endColumn: startRange.startColumn,
        rangeType: 0 /* NORMAL */
      };
      break;
    case 1 /* RIGHT */:
      destRange = {
        startRow: startRange.startRow,
        startColumn: startRange.endColumn,
        endRow: startRange.endRow,
        endColumn: startRange.endColumn,
        rangeType: 0 /* NORMAL */
      };
      break;
    default:
      throw new Error("Invalid direction");
  }
  return alignToMergedCellsBorders(destRange, worksheet, false);
}
function rangeHasValue(worksheet, row, col, rowEnd, colEnd) {
  let hasValue = false;
  const matrix = worksheet.getMatrixWithMergedCells(row, col, rowEnd, colEnd).forValue((_, __, value) => {
    if (cellHasValue(value)) {
      hasValue = true;
      return false;
    }
  });
  return {
    hasValue,
    matrix
  };
}
function getStartRange(range, primary, direction) {
  const ret = Rectangle.clone(range);
  if (primary == null) {
    return ret;
  }
  switch (direction) {
    case 0 /* UP */:
    case 2 /* DOWN */:
      ret.startColumn = ret.endColumn = primary.actualColumn;
      break;
    case 3 /* LEFT */:
    case 1 /* RIGHT */:
      ret.startRow = ret.endRow = primary.actualRow;
      break;
  }
  return ret;
}
function checkIfShrink(selection, direction, worksheet) {
  var _a, _b, _c, _d;
  const { primary, range } = selection;
  const startRange = Rectangle.clone(range);
  switch (direction) {
    case 0 /* UP */:
    case 2 /* DOWN */:
      startRange.startRow = (_a = primary == null ? void 0 : primary.startRow) != null ? _a : range.startRow;
      startRange.endRow = (_b = primary == null ? void 0 : primary.endRow) != null ? _b : range.startRow;
      break;
    case 3 /* LEFT */:
    case 1 /* RIGHT */:
      startRange.startColumn = (_c = primary == null ? void 0 : primary.startColumn) != null ? _c : range.startColumn;
      startRange.endColumn = (_d = primary == null ? void 0 : primary.endColumn) != null ? _d : range.startColumn;
      break;
  }
  const anchorRange = getEdgeOfRange(startRange, direction, worksheet);
  switch (direction) {
    case 2 /* DOWN */:
      return range.startRow < anchorRange.startRow;
    case 0 /* UP */:
      return range.endRow > anchorRange.endRow;
    case 3 /* LEFT */:
      return anchorRange.endColumn < range.endColumn;
    case 1 /* RIGHT */:
      return anchorRange.startColumn > range.startColumn;
  }
}
function isAllRowsCovered(allRowRanges, ranges) {
  let start = allRowRanges[0].startRow;
  let end = allRowRanges[0].endRow;
  allRowRanges.forEach((range) => {
    const { startRow, endRow } = range;
    start = Math.min(start, startRow);
    end = Math.max(end, endRow);
  });
  const covered = new Array(end - start + 1).fill(false);
  ranges.forEach((range) => {
    const { startRow, endRow } = range;
    for (let i = Math.max(startRow, start); i <= Math.min(endRow, end); i++) {
      covered[i - start] = true;
    }
  });
  return allRowRanges.every((range) => {
    const { startRow, endRow } = range;
    for (let i = startRow; i <= endRow; i++) {
      if (!covered[i - start]) {
        return false;
      }
    }
    return true;
  });
}
function isAllColumnsCovered(allColumnRanges, ranges) {
  let start = allColumnRanges[0].startColumn;
  let end = allColumnRanges[0].endColumn;
  allColumnRanges.forEach((range) => {
    const { startColumn, endColumn } = range;
    start = Math.min(start, startColumn);
    end = Math.max(end, endColumn);
  });
  const covered = new Array(end - start + 1).fill(false);
  ranges.forEach((range) => {
    const { startColumn, endColumn } = range;
    for (let i = Math.max(startColumn, start); i <= Math.min(endColumn, end); i++) {
      covered[i - start] = true;
    }
  });
  return allColumnRanges.every((range) => {
    const { startColumn, endColumn } = range;
    for (let i = startColumn; i <= endColumn; i++) {
      if (!covered[i - start]) {
        return false;
      }
    }
    return true;
  });
}
function getMergeableSelectionsByType(type, selections) {
  if (!selections) return null;
  if (type === "mergeAll" /* MergeAll */) {
    return selections.filter((selection) => {
      if (selection.startRow === selection.endRow && selection.startColumn === selection.endColumn) {
        return false;
      }
      return true;
    });
  } else if (type === "mergeVertical" /* MergeVertical */) {
    return selections.filter((selection) => {
      if (selection.startRow === selection.endRow) {
        return false;
      }
      return true;
    });
  } else if (type === "mergeHorizontal" /* MergeHorizontal */) {
    return selections.filter((selection) => {
      if (selection.startColumn === selection.endColumn) {
        return false;
      }
      return true;
    });
  }
  return selections;
}
function cellHasValue(cell) {
  return cell.v !== void 0 && cell.v !== null && cell.v !== "" || cell.p !== void 0;
}

// ../packages/sheets-ui/src/commands/commands/add-worksheet-merge.command.ts
var AddWorksheetMergeCommand2 = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge",
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const confirmService = accessor.get(IConfirmService);
    const localeService = accessor.get(LocaleService);
    const unitId = params.unitId;
    const subUnitId = params.subUnitId;
    const selections = params.selections;
    const ranges = getAddMergeMutationRangeByType(selections, params.value);
    const worksheet = univerInstanceService.getUniverSheetInstance(unitId).getSheetBySheetId(subUnitId);
    const redoMutations = [];
    const undoMutations = [];
    const willClearSomeCell = checkCellContentInRanges(worksheet, ranges);
    if (willClearSomeCell && !params.defaultMerge) {
      const result2 = await confirmService.confirm({
        id: "merge.confirm.add-worksheet-merge",
        title: {
          title: "merge.confirm.title"
        },
        cancelText: localeService.t("merge.confirm.cancel"),
        confirmText: localeService.t("merge.confirm.confirm")
      });
      if (!result2) {
        return false;
      }
    }
    const removeMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: Tools.deepClone(ranges)
    };
    const addMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: Tools.deepClone(ranges)
    };
    const undoRemoveMergeMutationParams = RemoveMergeUndoMutationFactory(accessor, removeMergeMutationParams);
    const undoMutationParams = AddMergeUndoMutationFactory(accessor, addMergeMutationParams);
    if (undoRemoveMergeMutationParams.ranges.length > 0) {
      redoMutations.push({ id: RemoveWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams });
    }
    redoMutations.push({ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams });
    undoMutations.push({ id: RemoveWorksheetMergeMutation.id, params: undoMutationParams });
    if (undoRemoveMergeMutationParams.ranges.length > 0) {
      undoMutations.push({ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams });
    }
    if (willClearSomeCell) {
      const data = getClearContentMutationParamsForRanges(accessor, unitId, worksheet, ranges);
      redoMutations.unshift(...data.redos);
      undoMutations.push(...data.undos);
    }
    const addMergeRedoSelectionsMutation = AddMergeRedoSelectionsOperationFactory(accessor, params, ranges);
    addMergeRedoSelectionsMutation && redoMutations.push(addMergeRedoSelectionsMutation);
    const addMergeUndoSelectionsMutation = AddMergeUndoSelectionsOperationFactory(accessor, params);
    addMergeUndoSelectionsMutation && undoMutations.push(addMergeUndoSelectionsMutation);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const interceptor = sheetInterceptorService.onCommandExecute({
      id: AddWorksheetMergeCommand2.id,
      params: { unitId, subUnitId, ranges }
    });
    redoMutations.push(...interceptor.redos);
    undoMutations.push(...interceptor.undos);
    const result = sequenceExecute(redoMutations, commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations,
        redoMutations
      });
      return true;
    }
    return false;
  }
};
var AddWorksheetMergeAllCommand2 = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge-all",
  handler: async (accessor) => {
    var _a;
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range);
    const mergeableSelections = getMergeableSelectionsByType("mergeAll" /* MergeAll */, selections);
    if (!(mergeableSelections == null ? void 0 : mergeableSelections.length)) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const workSheet = workbook.getActiveSheet();
    if (!workSheet) return false;
    const unitId = workbook.getUnitId();
    const subUnitId = workSheet.getSheetId();
    return commandService.executeCommand(AddWorksheetMergeCommand2.id, {
      selections: mergeableSelections,
      unitId,
      subUnitId
    });
  }
};
var AddWorksheetMergeVerticalCommand2 = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge-vertical",
  handler: async (accessor) => {
    var _a;
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range);
    const mergeableSelections = getMergeableSelectionsByType("mergeVertical" /* MergeVertical */, selections);
    if (!(mergeableSelections == null ? void 0 : mergeableSelections.length)) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const workSheet = workbook.getActiveSheet();
    if (!workSheet) return false;
    const unitId = workbook.getUnitId();
    const subUnitId = workSheet.getSheetId();
    return commandService.executeCommand(AddWorksheetMergeCommand2.id, {
      value: 0 /* COLUMNS */,
      selections: mergeableSelections,
      unitId,
      subUnitId
    });
  }
};
var AddWorksheetMergeHorizontalCommand2 = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge-horizontal",
  handler: async (accessor) => {
    var _a;
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range);
    const mergeableSelections = getMergeableSelectionsByType("mergeHorizontal" /* MergeHorizontal */, selections);
    if (!(mergeableSelections == null ? void 0 : mergeableSelections.length)) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const workSheet = workbook.getActiveSheet();
    if (!workSheet) return false;
    const unitId = workbook.getUnitId();
    const subUnitId = workSheet.getSheetId();
    return commandService.executeCommand(AddWorksheetMergeCommand2.id, {
      value: 1 /* ROWS */,
      selections: mergeableSelections,
      unitId,
      subUnitId
    });
  }
};

// ../packages/sheets-ui/src/common/keys.ts
var SHEET_ZOOM_RANGE = [10, 400];
var RANGE_SELECTOR_COMPONENT_KEY = "RANGE_SELECTOR_COMPONENT_KEY";
var EMBEDDING_FORMULA_EDITOR_COMPONENT_KEY = "EMBEDDING_FORMULA_EDITOR_COMPONENT_KEY";
var SHEET_COMPONENT_MAIN_LAYER_INDEX = 0;
var SHEET_COMPONENT_SELECTION_LAYER_INDEX = 1;
var SHEET_COMPONENT_HEADER_LAYER_INDEX = 10;
var SHEET_COMPONENT_HEADER_SELECTION_LAYER_INDEX = 11;
var SHEET_COMPONENT_UNHIDE_LAYER_INDEX = 12;

// ../packages/sheets-ui/src/commands/commands/headersize-changed.command.ts
var SetRowHeaderWidthCommand = {
  id: "sheet.command.set-row-header-width",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    if (!params) {
      return false;
    }
    const renderManagerSrv = accessor.get(IRenderManagerService);
    if (!renderManagerSrv) {
      return false;
    }
    const { unitId, subUnitId, size } = params;
    const render = renderManagerSrv.getRenderById(unitId);
    if (render) {
      const skm = renderManagerSrv.getRenderById(unitId).with(SheetSkeletonManagerService);
      skm.setRowHeaderSize(render, subUnitId, size);
      const { components } = render;
      const renderComponent = components.get("__SpreadsheetRowHeader__" /* ROW */);
      if (renderComponent) {
        renderComponent.setCustomHeader({ headerStyle: { size } });
      }
    }
    return true;
  }
};
var SetColumnHeaderHeightCommand = {
  id: "sheet.command.set-col-header-height",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    if (!params) {
      return false;
    }
    const renderManagerSrv = accessor.get(IRenderManagerService);
    if (!renderManagerSrv) {
      return false;
    }
    const { unitId, subUnitId, size } = params;
    const render = renderManagerSrv.getRenderById(unitId);
    if (render) {
      const skm = renderManagerSrv.getRenderById(unitId).with(SheetSkeletonManagerService);
      skm.setColumnHeaderSize(render, subUnitId, size);
      const { components } = render;
      const renderComponent = components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
      if (renderComponent) {
        renderComponent.setCustomHeader({ headerStyle: { size } });
      }
    }
    return true;
  }
};

// ../packages/sheets-ui/src/services/selection/const.ts
var RANGE_MOVE_PERMISSION_CHECK = createInterceptorKey("rangeMovePermissionCheck");
var RANGE_FILL_PERMISSION_CHECK = createInterceptorKey("rangeFillPermissionCheck");
function genNormalSelectionStyle(themeService) {
  const styleSheet = themeService.getCurrentTheme();
  const fill = new ColorKit(styleSheet.primaryColor).setAlpha(0.07).toRgbString();
  return {
    strokeWidth: 1,
    stroke: styleSheet.primaryColor,
    fill,
    // widgets: { tl: true, tc: true, tr: true, ml: true, mr: true, bl: true, bc: true, br: true },
    widgets: {},
    widgetSize: 6,
    widgetStrokeWidth: 1,
    widgetStroke: styleSheet.colorWhite,
    autofillSize: 6,
    autofillStrokeWidth: 1,
    autofillStroke: styleSheet.colorWhite,
    rowHeaderFill: fill,
    rowHeaderStroke: styleSheet.primaryColor,
    rowHeaderStrokeWidth: 1,
    columnHeaderFill: fill,
    columnHeaderStroke: styleSheet.primaryColor,
    columnHeaderStrokeWidth: 1,
    expandCornerSize: 40
  };
}

// ../packages/sheets-ui/src/services/selection/selection-render-model.ts
var SelectionRenderModel = class {
  constructor() {
    __publicField(this, "_startColumn", -1);
    __publicField(this, "_startRow", -1);
    __publicField(this, "_endColumn", -1);
    __publicField(this, "_endRow", -1);
    __publicField(this, "_startX", 0);
    __publicField(this, "_startY", 0);
    __publicField(this, "_endX", 0);
    __publicField(this, "_endY", 0);
    /**
     * The highlight cell of a selection. aka: current cell
     */
    __publicField(this, "_primary");
    __publicField(this, "_rangeType", 0 /* NORMAL */);
  }
  get startColumn() {
    return this._startColumn;
  }
  get startRow() {
    return this._startRow;
  }
  get endColumn() {
    return this._endColumn;
  }
  get endRow() {
    return this._endRow;
  }
  get startX() {
    return this._startX;
  }
  get startY() {
    return this._startY;
  }
  get endX() {
    return this._endX;
  }
  get endY() {
    return this._endY;
  }
  get currentCell() {
    return this._primary;
  }
  get rangeType() {
    return this._rangeType;
  }
  /**
   * @deprecated, Duplicate with `Rectangle`
   */
  isEqual(rangeWithCoord) {
    const { startColumn, startRow, endColumn, endRow } = this;
    const {
      startColumn: newStartColumn,
      startRow: newStartRow,
      endColumn: newEndColumn,
      endRow: newEndRow
    } = rangeWithCoord;
    if (startColumn === newStartColumn && startRow === newStartRow && endColumn === newEndColumn && endRow === newEndRow) {
      return true;
    }
    return false;
  }
  highlightToSelection() {
    if (!this._primary) return;
    return convertCellToRange(this._primary);
  }
  getRange() {
    return {
      startColumn: this._startColumn,
      startRow: this._startRow,
      endColumn: this._endColumn,
      endRow: this._endRow,
      startX: this._startX,
      startY: this._startY,
      endX: this._endX,
      endY: this._endY,
      rangeType: this.rangeType
    };
  }
  getCell() {
    return this._primary;
  }
  getRangeType() {
    return this._rangeType;
  }
  setRangeType(rangeType) {
    this._rangeType = rangeType;
  }
  getValue() {
    return {
      rangeWithCoord: this.getRange(),
      primaryWithCoord: this._primary
    };
  }
  setValue(newSelectionRange, currentCell) {
    const {
      startColumn,
      startRow,
      endColumn,
      endRow,
      startX,
      startY,
      endX,
      endY,
      rangeType
    } = newSelectionRange;
    this._startColumn = startColumn;
    this._startRow = startRow;
    this._endColumn = endColumn;
    this._endRow = endRow;
    this._startX = startX;
    this._startY = startY;
    this._endX = endX;
    this._endY = endY;
    if (rangeType !== void 0) {
      this._rangeType = rangeType;
    }
    if (currentCell !== void 0) {
      this.setCurrentCell(currentCell);
    }
  }
  /**
   * Set primary cell.
   * @TODO lumixraku there are 3 concepts for same thing, primary and current and highlight
   * highlight is best. primary sometimes means the actual cell(actual means ignore merge)
   * @param currentCell
   */
  setCurrentCell(currentCell) {
    this._primary = currentCell;
  }
  clearCurrentCell() {
    this._primary = null;
  }
};

// ../packages/sheets-ui/src/services/selection/util.ts
function attachRangeWithCoord(skeleton, range) {
  const { startRow, startColumn, endRow, endColumn, rangeType } = range;
  const _startRow = endRow < startRow ? endRow : startRow;
  const _endRow = endRow < startRow ? startRow : endRow;
  const _startColumn = endColumn < startColumn ? endColumn : startColumn;
  const _endColumn = endColumn < startColumn ? startColumn : endColumn;
  const startCell = skeleton.getNoMergeCellWithCoordByIndex(_startRow, _startColumn);
  const endCell = skeleton.getNoMergeCellWithCoordByIndex(_endRow, _endColumn);
  return {
    startRow,
    startColumn,
    endRow,
    endColumn,
    rangeType,
    startY: (startCell == null ? void 0 : startCell.startY) || 0,
    endY: (endCell == null ? void 0 : endCell.endY) || 0,
    startX: (startCell == null ? void 0 : startCell.startX) || 0,
    endX: (endCell == null ? void 0 : endCell.endX) || 0
  };
}
function attachSelectionWithCoord(selection, skeleton) {
  const { range, primary, style } = selection;
  const rangeWithCoord = attachRangeWithCoord(skeleton, range);
  const primaryWithCoord = primary ? attachPrimaryWithCoord(skeleton, primary) : primary;
  return {
    rangeWithCoord,
    primaryWithCoord,
    style
  };
}
function attachPrimaryWithCoord(skeleton, primary) {
  const { actualRow, actualColumn, isMerged, isMergedMainCell, startRow, startColumn, endRow, endColumn } = primary;
  const cellPosition = skeleton.getNoMergeCellWithCoordByIndex(actualRow, actualColumn);
  const startCell = skeleton.getNoMergeCellWithCoordByIndex(startRow, startColumn);
  const endCell = skeleton.getNoMergeCellWithCoordByIndex(endRow, endColumn);
  return {
    actualRow,
    actualColumn,
    isMerged,
    isMergedMainCell,
    startX: cellPosition.startX,
    startY: cellPosition.startY,
    endX: cellPosition.endX,
    endY: cellPosition.endY,
    mergeInfo: {
      startRow,
      startColumn,
      endRow,
      endColumn,
      startY: (startCell == null ? void 0 : startCell.startY) || 0,
      endY: (endCell == null ? void 0 : endCell.endY) || 0,
      startX: (startCell == null ? void 0 : startCell.startX) || 0,
      endX: (endCell == null ? void 0 : endCell.endX) || 0
    }
  };
}

// ../packages/sheets-ui/src/services/selection/selection-shape-extension.ts
var HELPER_SELECTION_TEMP_NAME = "__SpreadsheetHelperSelectionTempRect";
var SELECTION_CONTROL_DELETING_LIGHTEN = 35;
var SelectionShapeExtension = class {
  constructor(_control, options) {
    this._control = _control;
    __publicField(this, "_startOffsetX", 0);
    __publicField(this, "_startOffsetY", 0);
    __publicField(this, "_relativeSelectionPositionRow", 0);
    __publicField(this, "_relativeSelectionPositionColumn", 0);
    __publicField(this, "_relativeSelectionRowLength", 0);
    __publicField(this, "_relativeSelectionColumnLength", 0);
    __publicField(this, "_scenePointerMoveSub");
    __publicField(this, "_scenePointerUpSub");
    /**
     * The shadow selection under cursor when move whole selection control(for moving normal selection)
     */
    __publicField(this, "_helperSelection");
    __publicField(this, "_scrollTimer");
    __publicField(this, "_activeViewport");
    __publicField(this, "_targetSelection", {
      startY: 0,
      endY: 0,
      startX: 0,
      endX: 0,
      startRow: -1,
      endRow: -1,
      startColumn: -1,
      endColumn: -1
    });
    __publicField(this, "_isInMergeState", false);
    __publicField(this, "_fillControlColors", []);
    __publicField(this, "_skeleton");
    __publicField(this, "_scene");
    __publicField(this, "_themeService");
    __publicField(this, "_injector");
    __publicField(this, "_selectionHooks");
    this._skeleton = options.skeleton;
    this._scene = options.scene;
    this._themeService = options.themeService;
    this._injector = options.injector;
    this._selectionHooks = options.selectionHooks;
    this._initialControl();
    this._initialWidget();
    this._initialAutoFill();
    this._control.dispose$.subscribe(() => {
      this.dispose();
    });
  }
  get isHelperSelection() {
    return this._control.isHelperSelection;
  }
  dispose() {
    var _a, _b;
    (_a = this._scrollTimer) == null ? void 0 : _a.dispose();
    this._fillControlColors = [];
    this._clearObserverEvent();
    (_b = this._helperSelection) == null ? void 0 : _b.dispose();
  }
  _getFreeze() {
    var _a, _b;
    const freeze = (_b = (_a = withCurrentTypeOfRenderer(
      O.UNIVER_SHEET,
      SheetSkeletonManagerService,
      this._injector.get(IUniverInstanceService),
      this._injector.get(IRenderManagerService)
    )) == null ? void 0 : _a.getCurrentParam()) == null ? void 0 : _b.skeleton.getWorksheetConfig().freeze;
    return freeze;
  }
  _isSelectionInViewport(selection, viewport) {
    const freeze = this._getFreeze() || {
      startRow: -1,
      startColumn: -1,
      xSplit: 0,
      ySplit: 0
    };
    switch (viewport.viewportKey) {
      case "viewMain" /* VIEW_MAIN */:
        return selection.endRow >= freeze.startRow && selection.endColumn >= freeze.startColumn;
      case "viewMainTop" /* VIEW_MAIN_TOP */:
      case "viewColumnRight" /* VIEW_COLUMN_RIGHT */:
        return selection.endColumn >= freeze.startColumn && selection.startRow < freeze.startRow;
      case "viewMainLeft" /* VIEW_MAIN_LEFT */:
      case "viewRowBottom" /* VIEW_ROW_BOTTOM */:
        return selection.endRow >= freeze.startRow && selection.startColumn < freeze.startColumn;
      case "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */:
      case "viewColumnLeft" /* VIEW_COLUMN_LEFT */:
      case "viewRowTop" /* VIEW_ROW_TOP */:
      case "viewLeftTop" /* VIEW_LEFT_TOP */:
        return selection.startRow < freeze.startRow && selection.startColumn < freeze.startColumn;
      default:
        break;
    }
  }
  _clearObserverEvent() {
    var _a, _b;
    (_a = this._scenePointerMoveSub) == null ? void 0 : _a.unsubscribe();
    (_b = this._scenePointerUpSub) == null ? void 0 : _b.unsubscribe();
    this._scenePointerMoveSub = null;
    this._scenePointerUpSub = null;
  }
  _initialControl() {
    const { leftControl, rightControl, topControl, bottomControl } = this._control;
    [leftControl, rightControl, topControl, bottomControl].forEach((control) => {
      control.onPointerEnter$.subscribeEvent(() => {
        var _a;
        const permissionCheck = (_a = this._injector.get(ISheetSelectionRenderService, Quantity.OPTIONAL)) == null ? void 0 : _a.interceptor.fetchThroughInterceptors(RANGE_MOVE_PERMISSION_CHECK)(false, null);
        if (permissionCheck === false) {
          return;
        }
        control.setCursor("move" /* MOVE */);
      });
      control.onPointerLeave$.subscribeEvent(() => {
        control.resetCursor();
      });
      control.onPointerDown$.subscribeEvent(this._controlPointerDownHandler.bind(this));
    });
  }
  /**
   * Move the whole selection control after cursor turn into move state.
   * NOT same as widgetMoving, that's for 8 control points.
   * @param moveOffsetX
   * @param moveOffsetY
   */
  _controlMoving(moveOffsetX, moveOffsetY) {
    var _a;
    const scene = this._scene;
    const scrollXY = scene.getScrollXYInfoByViewport(Vector2.FromArray([moveOffsetX, moveOffsetY]));
    const { scaleX, scaleY } = scene.getAncestorScale();
    const actualCellIndex = this._skeleton.getCellIndexByOffset(
      moveOffsetX,
      moveOffsetY,
      scaleX,
      scaleY,
      scrollXY
    );
    const { row, column } = actualCellIndex;
    const maxRow = this._skeleton.getRowCount() - 1;
    const maxColumn = this._skeleton.getColumnCount() - 1;
    let startRow = Math.max(0, row + this._relativeSelectionPositionRow);
    let endRow = startRow + this._relativeSelectionRowLength;
    if (endRow > maxRow) {
      endRow = maxRow;
      if (endRow - startRow < this._relativeSelectionRowLength) {
        startRow = endRow - this._relativeSelectionRowLength;
      }
    }
    let startColumn = Math.max(0, column + this._relativeSelectionPositionColumn);
    let endColumn = startColumn + this._relativeSelectionColumnLength;
    if (endColumn > maxColumn) {
      endColumn = maxColumn;
      if (endColumn - startColumn < this._relativeSelectionColumnLength) {
        startColumn = endColumn - this._relativeSelectionColumnLength;
      }
    }
    const primaryCell = this._skeleton.worksheet.getCellInfoInMergeData(startRow, startColumn);
    const selection = {
      range: { startRow, endRow, startColumn, endColumn },
      primary: primaryCell,
      style: null
    };
    const selectionWithCoord = attachSelectionWithCoord(selection, this._skeleton);
    const startCell = this._skeleton.getNoMergeCellWithCoordByIndex(startRow, startColumn);
    const endCell = this._skeleton.getNoMergeCellWithCoordByIndex(endRow, endColumn);
    const startY = (startCell == null ? void 0 : startCell.startY) || 0;
    const endY = (endCell == null ? void 0 : endCell.endY) || 0;
    const startX = (startCell == null ? void 0 : startCell.startX) || 0;
    const endX = (endCell == null ? void 0 : endCell.endX) || 0;
    (_a = this._helperSelection) == null ? void 0 : _a.transformByState({
      left: startX,
      top: startY,
      width: endX - startX,
      height: endY - startY
    });
    this._targetSelection = { ...selectionWithCoord.rangeWithCoord };
    this._control.selectionMoving$.next(selectionWithCoord.rangeWithCoord);
  }
  /**
   * Drag move whole selectionControl when cursor turns to crosshair. Not for dragging 8 control points.
   * @param evt
   */
  _controlPointerDownHandler(evt) {
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const scene = this._scene;
    const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    const { x: newEvtOffsetX, y: newEvtOffsetY } = relativeCoords;
    const scrollXY = scene.getScrollXYInfoByViewport(relativeCoords);
    const { scaleX, scaleY } = scene.getAncestorScale();
    const actualSelection = this._skeleton.getCellIndexByOffset(
      newEvtOffsetX,
      newEvtOffsetY,
      scaleX,
      scaleY,
      scrollXY
    );
    this._startOffsetX = newEvtOffsetX;
    this._startOffsetY = newEvtOffsetY;
    const { row, column } = actualSelection;
    const {
      startRow: originStartRow,
      startColumn: originStartColumn,
      endRow: originEndRow,
      endColumn: originEndColumn
    } = this._control.model;
    let fixRow = 0;
    let fixColumn = 0;
    if (row < originStartRow) {
      fixRow -= 1;
    } else if (row > originEndRow) {
      fixRow += 1;
    }
    if (column < originStartColumn) {
      fixColumn -= 1;
    } else if (column > originEndColumn) {
      fixColumn += 1;
    }
    this._relativeSelectionPositionRow = originStartRow - row + fixRow;
    this._relativeSelectionPositionColumn = originStartColumn - column + fixColumn;
    this._relativeSelectionRowLength = originEndRow - originStartRow;
    this._relativeSelectionColumnLength = originEndColumn - originStartColumn;
    const style = this._control.currentStyle;
    const scale = this._getScale();
    if (this.isHelperSelection) {
      this._helperSelection = new Rect(HELPER_SELECTION_TEMP_NAME, {
        stroke: style.stroke,
        strokeWidth: style.strokeWidth / scale
      });
      scene.addObject(this._helperSelection);
    }
    const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const scrollTimer = ScrollTimer.create(scene);
    this._scrollTimer = scrollTimer;
    scrollTimer.startScroll(newEvtOffsetX, newEvtOffsetY, viewMain);
    scene.disableObjectsEvent();
    this._scenePointerMoveSub = scene.onPointerMove$.subscribeEvent((moveEvt) => {
      var _a;
      const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
      const permissionCheck = (_a = this._injector.get(ISheetSelectionRenderService, Quantity.OPTIONAL)) == null ? void 0 : _a.interceptor.fetchThroughInterceptors(RANGE_MOVE_PERMISSION_CHECK)(false, null);
      if (permissionCheck === false) {
        return;
      }
      const { x: newMoveOffsetX, y: newMoveOffsetY } = scene.getCoordRelativeToViewport(
        Vector2.FromArray([moveOffsetX, moveOffsetY])
      );
      this._controlMoving(newMoveOffsetX, newMoveOffsetY);
      scene.setCursor("move" /* MOVE */);
      scrollTimer.scrolling(newMoveOffsetX, newMoveOffsetY, () => {
        this._controlMoving(newMoveOffsetX, newMoveOffsetY);
      });
    });
    this._scenePointerUpSub = scene.onPointerUp$.subscribeEvent(() => {
      var _a, _b, _c, _d;
      (_a = this._helperSelection) == null ? void 0 : _a.dispose();
      const scene2 = this._scene;
      scene2.resetCursor();
      this._clearObserverEvent();
      scene2.enableObjectsEvent();
      (_b = this._scrollTimer) == null ? void 0 : _b.dispose();
      this._control.selectionMoveEnd$.next(this._targetSelection);
      (_d = (_c = this._selectionHooks).selectionMoveEnd) == null ? void 0 : _d.call(_c);
    });
  }
  _initialWidget() {
    const {
      topLeftWidget,
      topCenterWidget,
      topRightWidget,
      middleLeftWidget,
      middleRightWidget,
      bottomLeftWidget,
      bottomCenterWidget,
      bottomRightWidget
    } = this._control;
    const cursors = [
      "nw-resize" /* NORTH_WEST_RESIZE */,
      "n-resize" /* NORTH_RESIZE */,
      "ne-resize" /* NORTH_EAST_RESIZE */,
      "w-resize" /* WEST_RESIZE */,
      "e-resize" /* EAST_RESIZE */,
      "sw-resize" /* SOUTH_WEST_RESIZE */,
      "s-resize" /* SOUTH_RESIZE */,
      "se-resize" /* SOUTH_EAST_RESIZE */
    ];
    [
      topLeftWidget,
      topCenterWidget,
      topRightWidget,
      middleLeftWidget,
      middleRightWidget,
      bottomLeftWidget,
      bottomCenterWidget,
      bottomRightWidget
    ].forEach((control, index) => {
      control.onPointerEnter$.subscribeEvent(() => {
        control.setCursor(cursors[index]);
      });
      control.onPointerLeave$.subscribeEvent(() => {
        control.resetCursor();
      });
      control.onPointerDown$.subscribeEvent((evt) => {
        this._widgetPointerDownEvent(evt, cursors[index]);
      });
    });
  }
  /**
   * Pointer down Events for 8 control point.
   * @param evt
   * @param cursor
   */
  _widgetPointerDownEvent(evt, cursor) {
    const scene = this._scene;
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    const { x: newEvtOffsetX, y: newEvtOffsetY } = relativeCoords;
    this._startOffsetX = evtOffsetX;
    this._startOffsetY = evtOffsetY;
    const {
      startRow: originStartRow,
      startColumn: originStartColumn,
      endRow: originEndRow,
      endColumn: originEndColumn
    } = this._control.model;
    const startRow = Math.min(originStartRow, originEndRow);
    const startColumn = Math.min(originStartColumn, originEndColumn);
    const endRow = Math.max(originStartRow, originEndRow);
    const endColumn = Math.max(originStartColumn, originEndColumn);
    this._relativeSelectionPositionRow = startRow;
    this._relativeSelectionPositionColumn = startColumn;
    this._relativeSelectionRowLength = endRow - startRow;
    this._relativeSelectionColumnLength = endColumn - startColumn;
    if (cursor === "nw-resize" /* NORTH_WEST_RESIZE */) {
      this._relativeSelectionPositionRow = endRow;
      this._relativeSelectionPositionColumn = endColumn;
    } else if (cursor === "n-resize" /* NORTH_RESIZE */) {
      this._relativeSelectionPositionRow = endRow;
    } else if (cursor === "ne-resize" /* NORTH_EAST_RESIZE */) {
      this._relativeSelectionPositionRow = endRow;
    } else if (cursor === "w-resize" /* WEST_RESIZE */) {
      this._relativeSelectionPositionColumn = endColumn;
    } else if (cursor === "sw-resize" /* SOUTH_WEST_RESIZE */) {
      this._relativeSelectionPositionColumn = endColumn;
    } else if (cursor === "s-resize" /* SOUTH_RESIZE */) {
      this._relativeSelectionPositionRow = startRow;
    }
    const scrollTimer = ScrollTimer.create(scene);
    const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    scrollTimer.startScroll(newEvtOffsetX, newEvtOffsetY, viewMain);
    this._scrollTimer = scrollTimer;
    scene.disableObjectsEvent();
    this._scenePointerMoveSub = scene.onPointerMove$.subscribeEvent((moveEvt) => {
      const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
      const { x: newMoveOffsetX, y: newMoveOffsetY } = scene.getCoordRelativeToViewport(
        Vector2.FromArray([moveOffsetX, moveOffsetY])
      );
      this._widgetMoving(newMoveOffsetX, newMoveOffsetY, cursor);
      scene.setCursor(cursor);
      scrollTimer.scrolling(newMoveOffsetX, newMoveOffsetY, () => {
        this._widgetMoving(newMoveOffsetX, newMoveOffsetY, cursor);
      });
    });
    this._scenePointerUpSub = scene.onPointerUp$.subscribeEvent(() => {
      var _a, _b, _c;
      const scene2 = this._scene;
      scene2.resetCursor();
      this._clearObserverEvent();
      scene2.enableObjectsEvent();
      (_a = this._scrollTimer) == null ? void 0 : _a.dispose();
      this._control.selectionScaled$.next(this._targetSelection);
      (_c = (_b = this._selectionHooks).selectionMoveEnd) == null ? void 0 : _c.call(_b);
    });
  }
  /**
   * Pointer move Events for 8 control point.
   * @param moveOffsetX
   * @param moveOffsetY
   * @param cursor
   */
  _widgetMoving(moveOffsetX, moveOffsetY, cursor) {
    const scene = this._scene;
    const scrollXY = scene.getScrollXYInfoByViewport(Vector2.FromArray([this._startOffsetX, this._startOffsetY]));
    const { scaleX, scaleY } = scene.getAncestorScale();
    const moveActualSelection = this._skeleton.getCellIndexByOffset(
      moveOffsetX,
      moveOffsetY,
      scaleX,
      scaleY,
      scrollXY
    );
    const { row, column } = moveActualSelection;
    let startRow = this._relativeSelectionPositionRow;
    let startColumn = this._relativeSelectionPositionColumn;
    let endRow = row;
    let endColumn = column;
    if (cursor === "nw-resize" /* NORTH_WEST_RESIZE */) {
      startRow = row;
      startColumn = column;
      endRow = this._relativeSelectionPositionRow;
      endColumn = this._relativeSelectionPositionColumn;
    } else if (cursor === "n-resize" /* NORTH_RESIZE */) {
      startRow = row;
      startColumn = this._relativeSelectionPositionColumn;
      endRow = this._relativeSelectionPositionRow;
      endColumn = this._relativeSelectionPositionColumn + this._relativeSelectionColumnLength;
    } else if (cursor === "ne-resize" /* NORTH_EAST_RESIZE */) {
      startRow = row;
      startColumn = this._relativeSelectionPositionColumn;
      endRow = this._relativeSelectionPositionRow;
      endColumn = column;
    } else if (cursor === "w-resize" /* WEST_RESIZE */) {
      startRow = this._relativeSelectionPositionRow;
      startColumn = column;
      endRow = this._relativeSelectionPositionRow + this._relativeSelectionRowLength;
      endColumn = this._relativeSelectionPositionColumn;
    } else if (cursor === "e-resize" /* EAST_RESIZE */) {
      endRow = this._relativeSelectionPositionRow + this._relativeSelectionRowLength;
    } else if (cursor === "sw-resize" /* SOUTH_WEST_RESIZE */) {
      startRow = this._relativeSelectionPositionRow;
      startColumn = column;
      endRow = row;
      endColumn = this._relativeSelectionPositionColumn;
    } else if (cursor === "s-resize" /* SOUTH_RESIZE */) {
      startRow = this._relativeSelectionPositionRow;
      startColumn = this._relativeSelectionPositionColumn;
      endRow = row;
      endColumn = this._relativeSelectionPositionColumn + this._relativeSelectionColumnLength;
    }
    const range = this._swapPositions(startRow, startColumn, endRow, endColumn);
    const primaryCell = this._skeleton.getCellWithMergeInfoByIndex(startRow, startColumn);
    const selectionWithStyle = { range, primary: primaryCell, style: null };
    const selectionRangeWithCoord = attachSelectionWithCoord(selectionWithStyle, this._skeleton);
    this._targetSelection = { ...selectionRangeWithCoord.rangeWithCoord };
    this._control.updateRangeBySelectionWithCoord(selectionRangeWithCoord);
    this._control.selectionScaling$.next(this._targetSelection);
  }
  _initialAutoFill() {
    const { fillControl } = this._control;
    fillControl.onPointerEnter$.subscribeEvent((evt) => {
      const permissionCheck = this._injector.get(ISheetSelectionRenderService).interceptor.fetchThroughInterceptors(RANGE_FILL_PERMISSION_CHECK)(false, { x: evt.offsetX, y: evt.offsetY, skeleton: this._skeleton, scene: this._scene });
      if (!permissionCheck) {
        return;
      }
      fillControl.setCursor("crosshair" /* CROSSHAIR */);
    });
    fillControl.onPointerLeave$.subscribeEvent(() => {
      fillControl.resetCursor();
    });
    fillControl.onPointerDown$.subscribeEvent(this._autoFillForPointerdown.bind(this));
  }
  // eslint-disable-next-line complexity
  _autoFillMoving(moveOffsetX, moveOffsetY) {
    var _a, _b, _c;
    const scene = this._scene;
    const scrollXY = scene.getViewportScrollXY(this._activeViewport);
    const { scaleX, scaleY } = scene.getAncestorScale();
    const moveActualSelection = this._skeleton.getCellIndexByOffset(
      moveOffsetX,
      moveOffsetY,
      scaleX,
      scaleY,
      scrollXY
    );
    const { row, column } = moveActualSelection;
    const moveRelativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([moveOffsetX, moveOffsetY]));
    const maxRow = this._skeleton.getRowCount() - 1;
    const maxColumn = this._skeleton.getColumnCount() - 1;
    let startRow = this._relativeSelectionPositionRow;
    let startColumn = this._relativeSelectionPositionColumn;
    let endRow = this._relativeSelectionPositionRow + this._relativeSelectionRowLength;
    let endColumn = this._relativeSelectionPositionColumn + this._relativeSelectionColumnLength;
    let isLighten = false;
    let isRowDropping = true;
    if ((column < startColumn || column > endColumn) && row >= startRow && row <= endRow) {
      const rulerValue = this._fillRuler(
        column,
        startColumn,
        endColumn,
        this._relativeSelectionColumnLength,
        maxColumn
      );
      startColumn = rulerValue.startRowOrColumn;
      endColumn = rulerValue.endRowOrColumn;
      isLighten = rulerValue.isLighten;
      isRowDropping = false;
    } else if ((row < startRow || row > endRow) && column >= startColumn && column <= endColumn) {
      const rulerValue = this._fillRuler(row, startRow, endRow, this._relativeSelectionRowLength, maxRow);
      startRow = rulerValue.startRowOrColumn;
      endRow = rulerValue.endRowOrColumn;
      isLighten = rulerValue.isLighten;
    } else if (Math.abs(this._startOffsetX - moveRelativeCoords.x - scrollXY.x) / 2 > Math.abs(this._startOffsetY - moveRelativeCoords.y - scrollXY.y)) {
      const rulerValue = this._fillRuler(
        column,
        startColumn,
        endColumn,
        this._relativeSelectionColumnLength,
        maxColumn
      );
      startColumn = rulerValue.startRowOrColumn;
      endColumn = rulerValue.endRowOrColumn;
      isLighten = rulerValue.isLighten;
      isRowDropping = false;
    } else {
      const rulerValue = this._fillRuler(row, startRow, endRow, this._relativeSelectionRowLength, maxRow);
      startRow = rulerValue.startRowOrColumn;
      endRow = rulerValue.endRowOrColumn;
      isLighten = rulerValue.isLighten;
    }
    const startCell = this._skeleton.getNoMergeCellWithCoordByIndex(startRow, startColumn);
    const endCell = this._skeleton.getNoMergeCellWithCoordByIndex(endRow, endColumn);
    const startY = (startCell == null ? void 0 : startCell.startY) || 0;
    const endY = (endCell == null ? void 0 : endCell.endY) || 0;
    const startX = (startCell == null ? void 0 : startCell.startX) || 0;
    const endX = (endCell == null ? void 0 : endCell.endX) || 0;
    if (isLighten) {
      this._controlHandler((o, index) => {
        const newColor = new ColorKit(this._fillControlColors[index]).lighten(SELECTION_CONTROL_DELETING_LIGHTEN).toRgbString();
        o.setProps({
          fill: newColor
        });
      });
    } else {
      this._controlHandler((o, index) => {
        o.setProps({
          fill: this._fillControlColors[index]
        });
      });
    }
    const SELECTION_CONTROL_BORDER_BUFFER_WIDTH_SCALE = SELECTION_CONTROL_BORDER_BUFFER_WIDTH / this._getScale();
    if (startRow === endRow && isRowDropping === true || startColumn === endColumn && isRowDropping === false) {
      (_a = this._helperSelection) == null ? void 0 : _a.hide();
    } else {
      (_b = this._helperSelection) == null ? void 0 : _b.transformByState({
        left: startX - SELECTION_CONTROL_BORDER_BUFFER_WIDTH_SCALE / 2,
        top: startY - SELECTION_CONTROL_BORDER_BUFFER_WIDTH_SCALE / 2,
        width: endX - startX,
        height: endY - startY
      });
      (_c = this._helperSelection) == null ? void 0 : _c.show();
    }
    this._targetSelection = {
      startY,
      endY,
      startX,
      endX,
      startRow,
      endRow,
      startColumn,
      endColumn
    };
    this._control.selectionFilling$.next(this._targetSelection);
  }
  _autoFillForPointerdown(evt) {
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const scene = this._scene;
    const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    const { x: newEvtOffsetX, y: newEvtOffsetY } = relativeCoords;
    this._startOffsetX = newEvtOffsetX;
    this._startOffsetY = newEvtOffsetY;
    const {
      startRow: originStartRow,
      startColumn: originStartColumn,
      endRow: originEndRow,
      endColumn: originEndColumn
    } = this._control.model;
    this._isInMergeState = this._hasMergeInRange(originStartRow, originStartColumn, originEndRow, originEndColumn);
    this._relativeSelectionPositionRow = originStartRow;
    this._relativeSelectionPositionColumn = originStartColumn;
    this._relativeSelectionRowLength = originEndRow - originStartRow;
    this._relativeSelectionColumnLength = originEndColumn - originStartColumn;
    const style = this._control.currentStyle;
    let stroke = style == null ? void 0 : style.stroke;
    let strokeWidth = style == null ? void 0 : style.strokeWidth;
    const defaultStyle = genNormalSelectionStyle(this._themeService);
    if (stroke == null) {
      stroke = defaultStyle.stroke;
    }
    if (strokeWidth == null) {
      strokeWidth = defaultStyle.strokeWidth;
    }
    const scale = this._getScale();
    strokeWidth /= scale;
    const SELECTION_CONTROL_BORDER_BUFFER_WIDTH_SCALE = SELECTION_CONTROL_BORDER_BUFFER_WIDTH / scale;
    const darkenColor = new ColorKit(stroke).darken(2).toRgbString();
    if (this.isHelperSelection) {
      this._helperSelection = new Rect(HELPER_SELECTION_TEMP_NAME, {
        stroke: darkenColor,
        strokeWidth: strokeWidth + SELECTION_CONTROL_BORDER_BUFFER_WIDTH_SCALE / 2
      });
      scene.addObject(this._helperSelection);
    }
    this._activeViewport = scene.getActiveViewportByCoord(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const scrollTimer = ScrollTimer.create(
      scene,
      this._activeViewport.viewportKey === "viewMain" /* VIEW_MAIN */ ? 3 /* ALL */ : 0 /* NONE */
    );
    scrollTimer.startScroll(newEvtOffsetX, newEvtOffsetY, viewportMain);
    this._scrollTimer = scrollTimer;
    scene.disableObjectsEvent();
    this._controlHandler((o) => {
      this._fillControlColors.push(o.fill);
    });
    this._scenePointerMoveSub = scene.onPointerMove$.subscribeEvent((moveEvt) => {
      var _a;
      const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
      const currentViewport = scene.getActiveViewportByCoord(Vector2.FromArray([moveOffsetX, moveOffsetY]));
      const permissionCheck = this._injector.get(ISheetSelectionRenderService).interceptor.fetchThroughInterceptors(RANGE_FILL_PERMISSION_CHECK)(false, { x: evt.offsetX, y: evt.offsetY, skeleton: this._skeleton, scene: this._scene });
      if (!permissionCheck) {
        return;
      }
      const { x: newMoveOffsetX, y: newMoveOffsetY } = scene.getCoordRelativeToViewport(
        Vector2.FromArray([moveOffsetX, moveOffsetY])
      );
      this._autoFillMoving(newMoveOffsetX, newMoveOffsetY);
      scene.setCursor("crosshair" /* CROSSHAIR */);
      const newSelection = this._targetSelection;
      if (viewportMain && currentViewport && ((_a = this._activeViewport) == null ? void 0 : _a.viewportKey) !== (currentViewport == null ? void 0 : currentViewport.viewportKey)) {
        let movingRange;
        if (newSelection.startRow !== originStartRow) {
          scrollTimer.scrollTimerType = 2 /* Y */;
          movingRange = {
            ...newSelection,
            endRow: newSelection.startRow
          };
        } else if (newSelection.endRow !== originEndRow) {
          scrollTimer.scrollTimerType = 2 /* Y */;
          movingRange = {
            ...newSelection,
            startRow: newSelection.endRow
          };
        } else if (newSelection.startColumn !== originStartColumn) {
          scrollTimer.scrollTimerType = 1 /* X */;
          movingRange = {
            ...newSelection,
            endColumn: newSelection.startColumn
          };
        } else {
          scrollTimer.scrollTimerType = 1 /* X */;
          movingRange = {
            ...newSelection,
            startColumn: newSelection.endColumn
          };
        }
        if (this._isSelectionInViewport(movingRange, currentViewport)) {
          viewportMain.scrollToBarPos({
            x: scrollTimer.scrollTimerType === 1 /* X */ ? 0 : void 0,
            y: scrollTimer.scrollTimerType === 2 /* Y */ ? 0 : void 0
          });
          this._activeViewport = currentViewport;
        }
      }
      scrollTimer.scrolling(newMoveOffsetX, newMoveOffsetY, () => {
        this._autoFillMoving(newMoveOffsetX, newMoveOffsetY);
      });
    });
    this._scenePointerUpSub = scene.onPointerUp$.subscribeEvent(() => {
      var _a, _b;
      (_a = this._helperSelection) == null ? void 0 : _a.dispose();
      const scene2 = this._scene;
      scene2.resetCursor();
      this._clearObserverEvent();
      scene2.enableObjectsEvent();
      (_b = this._scrollTimer) == null ? void 0 : _b.dispose();
      this._control.refreshSelectionFilled(this._targetSelection);
      this._isInMergeState = false;
      this._controlHandler((o, index) => {
        o.setProps({
          fill: this._fillControlColors[index]
        });
      });
      this._fillControlColors = [];
    });
  }
  _hasMergeInRange(startRow, startColumn, endRow, endColumn) {
    return this._skeleton.worksheet.getMergedCellRange(startRow, startColumn, endRow, endColumn).length > 0;
  }
  /**
   * Make sure startRow < endRow and startColumn < endColumn
   *
   * @param startRow
   * @param startColumn
   * @param endRow
   * @param endColumn
   * @returns {IRange} range
   */
  _swapPositions(startRow, startColumn, endRow, endColumn) {
    const finalStartRow = Math.min(startRow, endRow);
    const finalStartColumn = Math.min(startColumn, endColumn);
    const finalEndRow = Math.max(startRow, endRow);
    const finalEndColumn = Math.max(startColumn, endColumn);
    return {
      startRow: finalStartRow,
      startColumn: finalStartColumn,
      endRow: finalEndRow,
      endColumn: finalEndColumn
    };
  }
  _controlHandler(func) {
    const {
      leftControl,
      rightControl,
      topControl,
      bottomControl,
      backgroundControlTop,
      backgroundControlMiddleLeft,
      backgroundControlMiddleRight,
      backgroundControlBottom,
      fillControl
    } = this._control;
    const objects = [
      leftControl,
      rightControl,
      topControl,
      bottomControl,
      backgroundControlTop,
      backgroundControlMiddleLeft,
      backgroundControlMiddleRight,
      backgroundControlBottom,
      fillControl
    ];
    for (let i = 0, len = objects.length; i < len; i++) {
      const object = objects[i];
      func(object, i);
    }
  }
  _fillRuler(rowOrColumn, startRowOrColumn, endRowOrColumn, rowOrColumnLength, maxRowOrColumn) {
    let isLighten = false;
    if (rowOrColumn < startRowOrColumn) {
      if (this._isInMergeState && rowOrColumn < startRowOrColumn) {
        const current = startRowOrColumn - rowOrColumn;
        const rangeRowCount = rowOrColumnLength + 1;
        const step = Math.ceil(current / rangeRowCount);
        let newStartRow = startRowOrColumn - step * rangeRowCount;
        if (newStartRow < 0) {
          newStartRow = startRowOrColumn - (step - 1) * rangeRowCount;
        }
        startRowOrColumn = newStartRow;
      } else {
        startRowOrColumn = rowOrColumn;
      }
    } else if (rowOrColumn >= startRowOrColumn && rowOrColumn <= endRowOrColumn) {
      isLighten = true;
      if (!this._isInMergeState) {
        endRowOrColumn = rowOrColumn;
      }
    } else {
      if (this._isInMergeState && rowOrColumn > endRowOrColumn) {
        const current = rowOrColumn - endRowOrColumn;
        const rangeRowCount = rowOrColumnLength + 1;
        const step = Math.ceil(current / rangeRowCount);
        let newEndRow = endRowOrColumn + step * rangeRowCount;
        if (newEndRow > maxRowOrColumn) {
          newEndRow = endRowOrColumn + (step - 1) * rangeRowCount;
        }
        endRowOrColumn = newEndRow;
      } else {
        endRowOrColumn = rowOrColumn;
      }
    }
    return {
      rowOrColumn,
      startRowOrColumn,
      endRowOrColumn,
      isLighten
    };
  }
  _getScale() {
    const { scaleX, scaleY } = this._scene.getAncestorScale();
    return Math.max(scaleX, scaleY);
  }
};

// ../packages/sheets-ui/src/services/selection/selection-control.ts
var SELECTION_TITLE_HIGHLIGHT_ALPHA = 0.3;
var SelectionControl = class extends Disposable {
  constructor(_scene, _zIndex, _themeService, options) {
    var _a, _b, _c, _d;
    super();
    this._scene = _scene;
    this._zIndex = _zIndex;
    this._themeService = _themeService;
    __publicField(this, "_isHelperSelection", true);
    /**
     * For ref selections, there is no auto fill.
     */
    __publicField(this, "_enableAutoFill", true);
    /**
     * Only normal selections with primary cell has auto fill.
     * This works for multiple normal selections. Only last selection has primary cell and auto fill.
     */
    __publicField(this, "_showAutoFill", false);
    /**
     * If rowHeader & col Header would be highlighted with selection.
     */
    __publicField(this, "_highlightHeader", true);
    __publicField(this, "_selectionRenderModel");
    __publicField(this, "_leftBorder");
    __publicField(this, "_rightBorder");
    __publicField(this, "_topBorder");
    __publicField(this, "_bottomBorder");
    __publicField(this, "_backgroundControlTop");
    __publicField(this, "_backgroundControlBottom");
    __publicField(this, "_backgroundControlMiddleLeft");
    __publicField(this, "_backgroundControlMiddleRight");
    __publicField(this, "_autoFillControl");
    __publicField(this, "_selectionShapeGroup");
    __publicField(this, "_rowHeaderBackground");
    __publicField(this, "_rowHeaderBorder");
    __publicField(this, "_rowHeaderGroup");
    __publicField(this, "_columnHeaderBackground");
    __publicField(this, "_columnHeaderBorder");
    __publicField(this, "_columnHeaderGroup");
    __publicField(this, "_dashedRect");
    // for ref selection
    __publicField(this, "_topLeftWidget");
    __publicField(this, "_topCenterWidget");
    __publicField(this, "_topRightWidget");
    __publicField(this, "_middleLeftWidget");
    __publicField(this, "_middleRightWidget");
    __publicField(this, "_bottomLeftWidget");
    __publicField(this, "_bottomCenterWidget");
    __publicField(this, "_bottomRightWidget");
    // why three style prop? what's diff between _selectionStyle & _currentStyle?
    // protected _selectionStyle: Nullable<ISelectionStyle>;
    __publicField(this, "_defaultStyle");
    __publicField(this, "_currentStyle");
    __publicField(this, "_rowHeaderWidth", 0);
    __publicField(this, "_columnHeaderHeight", 0);
    __publicField(this, "_widgetRects", []);
    __publicField(this, "_controlExtension");
    __publicField(this, "_dispose$", new BehaviorSubject(this));
    __publicField(this, "dispose$", this._dispose$.asObservable());
    /**
     * eventSource: selectionShapeExtension selectionMoving$.next,
     * Observer: prompt.controller
     */
    __publicField(this, "selectionMoving$", new Subject());
    __publicField(this, "selectionMoveEnd$", new Subject());
    __publicField(this, "selectionScaling$", new Subject());
    __publicField(this, "selectionScaled$", new Subject());
    __publicField(this, "selectionFilling$", new Subject());
    __publicField(this, "_selectionFilled$", new Subject());
    __publicField(this, "selectionFilled$", this._selectionFilled$.asObservable());
    __publicField(this, "_antLineOffset", 0);
    __publicField(this, "_antRequestNewFrame", -1);
    this._enableAutoFill = (_a = options == null ? void 0 : options.enableAutoFill) != null ? _a : true;
    this._highlightHeader = (_b = options == null ? void 0 : options.highlightHeader) != null ? _b : true;
    this._rowHeaderWidth = (_c = options == null ? void 0 : options.rowHeaderWidth) != null ? _c : 0;
    this._columnHeaderHeight = (_d = options == null ? void 0 : options.columnHeaderHeight) != null ? _d : 0;
    this._initializeSheetBody();
    this._initialHeader();
  }
  _initializeSheetBody() {
    this._defaultStyle = genNormalSelectionStyle(this._themeService);
    this._currentStyle = genNormalSelectionStyle(this._themeService);
    this._selectionRenderModel = new SelectionRenderModel();
    const zIndex = this._zIndex;
    this._leftBorder = new Rect("__SpreadsheetSelectionShapeLeftControl__" /* left */ + zIndex, {
      zIndex
    });
    this._rightBorder = new Rect("__SpreadsheetSelectionShapeRightControl__" /* right */ + zIndex, {
      zIndex
    });
    this._topBorder = new Rect("__SpreadsheetSelectionTopControl__" /* top */ + zIndex, {
      zIndex
    });
    this._bottomBorder = new Rect("__SpreadsheetSelectionBottomControl__" /* bottom */ + zIndex, {
      zIndex
    });
    this._backgroundControlTop = new Rect("__SpreadsheetSelectionBackgroundControlTop__" /* backgroundTop */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._backgroundControlBottom = new Rect("__SpreadsheetSelectionBackgroundControlBottom__" /* backgroundBottom */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._backgroundControlMiddleLeft = new Rect("__SpreadsheetSelectionBackgroundControlMiddleLeft__" /* backgroundMiddleLeft */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._backgroundControlMiddleRight = new Rect("__SpreadsheetSelectionBackgroundControlMiddleRight__" /* backgroundMiddleRight */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._autoFillControl = new Rect("__SpreadsheetSelectionFillControl__" /* fill */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._autoFillControl.hide();
    this._dashedRect = new DashedRect("__SpreadsheetDragDashControl__" /* dash */ + zIndex, {
      zIndex: zIndex + 2,
      evented: false,
      stroke: "#fff"
    });
    const shapes = [
      this._autoFillControl,
      this._leftBorder,
      this._rightBorder,
      this._topBorder,
      this._bottomBorder,
      this._backgroundControlTop,
      this._backgroundControlMiddleLeft,
      this._backgroundControlMiddleRight,
      this._backgroundControlBottom,
      this._dashedRect
    ];
    this._widgetRects = this._initialWidget();
    this._selectionShapeGroup = new Group("__SpreadsheetSelectionShape__" /* Selection */ + zIndex, ...shapes, ...this._widgetRects);
    this._selectionShapeGroup.hide();
    this._selectionShapeGroup.evented = false;
    this._selectionShapeGroup.zIndex = zIndex;
    const scene = this.getScene();
    scene.addObject(this._selectionShapeGroup, SHEET_COMPONENT_SELECTION_LAYER_INDEX);
    this.disposeWithMe(
      toDisposable(
        scene.onTransformChange$.subscribeEvent((state) => {
          if (state.type !== 2 /* scale */) {
            return;
          }
          this._updateLayoutOfSelectionControl(this._currentStyle);
          this._updateControlCoord();
        })
      )
    );
  }
  _initialHeader() {
    const zIndex = this._zIndex;
    this._rowHeaderBackground = new Rect("__SpreadSheetSelectionRowHeaderBackground__" /* rowHeaderBackground */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._rowHeaderBorder = new Rect("__SpreadSheetSelectionRowHeaderBorder__" /* rowHeaderBorder */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._rowHeaderGroup = new Group(
      "__SpreadSheetSelectionRowHeaderGroup__" /* rowHeaderGroup */ + zIndex,
      this._rowHeaderBackground,
      this._rowHeaderBorder
    );
    this._rowHeaderGroup.hide();
    this._rowHeaderGroup.evented = false;
    this._rowHeaderGroup.zIndex = zIndex;
    this._columnHeaderBackground = new Rect("__SpreadSheetSelectionColumnHeaderBackground__" /* columnHeaderBackground */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._columnHeaderBorder = new Rect("__SpreadSheetSelectionColumnHeaderBorder__" /* columnHeaderBorder */ + zIndex, {
      zIndex: zIndex - 1,
      evented: false
    });
    this._columnHeaderGroup = new Group(
      "__SpreadSheetSelectionColumnHeaderGroup__" /* columnHeaderGroup */ + zIndex,
      this._columnHeaderBackground,
      this._columnHeaderBorder
    );
    this._columnHeaderGroup.hide();
    this._columnHeaderGroup.evented = false;
    this._columnHeaderGroup.zIndex = zIndex;
    const scene = this.getScene();
    scene.addObjects([this._rowHeaderGroup, this._columnHeaderGroup], SHEET_COMPONENT_HEADER_SELECTION_LAYER_INDEX);
  }
  _initialWidget() {
    const zIndex = this._zIndex;
    this._topLeftWidget = new Rect("__SpreadSheetSelectionTopLeftWidget__" /* topLeftWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._topCenterWidget = new Rect("__SpreadSheetSelectionTopCenterWidget__" /* topCenterWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._topRightWidget = new Rect("__SpreadSheetSelectionTopRightWidget__" /* topRightWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._middleLeftWidget = new Rect("__SpreadSheetSelectionMiddleLeftWidget__" /* middleLeftWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._middleRightWidget = new Rect("__SpreadSheetSelectionMiddleRightWidget__" /* middleRightWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._bottomLeftWidget = new Rect("__SpreadSheetSelectionBottomLeftWidget__" /* bottomLeftWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._bottomCenterWidget = new Rect("__SpreadSheetSelectionBottomCenterWidget__" /* bottomCenterWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    this._bottomRightWidget = new Rect("__SpreadSheetSelectionBottomRightWidget__" /* bottomRightWidget */ + zIndex, {
      zIndex: zIndex + 1
    });
    return [
      this._topLeftWidget,
      this._topCenterWidget,
      this._topRightWidget,
      this._middleLeftWidget,
      this._middleRightWidget,
      this._bottomLeftWidget,
      this._bottomCenterWidget,
      this._bottomRightWidget
    ];
  }
  get zIndex() {
    return this._zIndex;
  }
  get leftControl() {
    return this._leftBorder;
  }
  get rightControl() {
    return this._rightBorder;
  }
  get topControl() {
    return this._topBorder;
  }
  get bottomControl() {
    return this._bottomBorder;
  }
  get fillControl() {
    return this._autoFillControl;
  }
  get backgroundControlTop() {
    return this._backgroundControlTop;
  }
  get backgroundControlBottom() {
    return this._backgroundControlBottom;
  }
  get backgroundControlMiddleLeft() {
    return this._backgroundControlMiddleLeft;
  }
  get backgroundControlMiddleRight() {
    return this._backgroundControlMiddleRight;
  }
  get selectionShape() {
    return this._selectionShapeGroup;
  }
  get columnHeaderGroup() {
    return this._columnHeaderGroup;
  }
  get rowHeaderGroup() {
    return this._rowHeaderGroup;
  }
  get selectionShapeGroup() {
    return this._selectionShapeGroup;
  }
  // That's so bad! _selectionModel is protected! But I don't want to expose it to the outside world
  get model() {
    return this._selectionRenderModel;
  }
  get topLeftWidget() {
    return this._topLeftWidget;
  }
  get topCenterWidget() {
    return this._topCenterWidget;
  }
  get topRightWidget() {
    return this._topRightWidget;
  }
  get middleLeftWidget() {
    return this._middleLeftWidget;
  }
  get middleRightWidget() {
    return this._middleRightWidget;
  }
  get bottomLeftWidget() {
    return this._bottomLeftWidget;
  }
  get bottomCenterWidget() {
    return this._bottomCenterWidget;
  }
  get bottomRightWidget() {
    return this._bottomRightWidget;
  }
  get themeService() {
    return this._themeService;
  }
  get selectionModel() {
    return this._selectionRenderModel;
  }
  set selectionModel(model) {
    this._selectionRenderModel = model;
  }
  // get defaultStyle(): ISelectionStyle {
  //     return this._defaultStyle;
  // }
  // set defaultStyle(style: ISelectionStyle) {
  //     this._defaultStyle = style;
  // }
  get currentStyle() {
    return this._currentStyle;
  }
  set currentStyle(style) {
    this._currentStyle = style;
  }
  get dashedRect() {
    return this._dashedRect;
  }
  get isHelperSelection() {
    return this._isHelperSelection;
  }
  get rowHeaderWidth() {
    return this._rowHeaderWidth;
  }
  set rowHeaderWidth(width) {
    this._rowHeaderWidth = width;
  }
  get columnHeaderHeight() {
    return this._columnHeaderHeight;
  }
  set columnHeaderHeight(height) {
    this._columnHeaderHeight = height;
  }
  setControlExtension(options) {
    this._controlExtension = new SelectionShapeExtension(this, options);
  }
  setEvent(state) {
    this.leftControl.evented = state;
    this.rightControl.evented = state;
    this.topControl.evented = state;
    this.bottomControl.evented = state;
  }
  refreshSelectionFilled(val) {
    this._selectionFilled$.next(val);
  }
  /**
   * Update Control Style And Position of SelectionControl
   * @param selectionStyle
   */
  _updateLayoutOfSelectionControl(selectionStyle) {
    if (selectionStyle) {
      this.currentStyle = Object.assign({}, this._defaultStyle, selectionStyle);
    }
    const currentStyle = this.currentStyle;
    const {
      stroke,
      widgets,
      autofillStroke: AutofillStroke,
      strokeDash,
      isAnimationDash
    } = currentStyle;
    let autofillSize = currentStyle.autofillSize;
    let strokeWidth = currentStyle.strokeWidth;
    let autofillStrokeWidth = currentStyle.autofillStrokeWidth;
    const scale = this._getScale();
    const leftAdjustWidth = (strokeWidth + SELECTION_CONTROL_BORDER_BUFFER_WIDTH) / 2 / scale;
    strokeWidth /= scale;
    autofillSize /= scale;
    autofillStrokeWidth /= scale < 1 ? 1 : scale;
    const borderBuffer = SELECTION_CONTROL_BORDER_BUFFER_WIDTH / scale;
    const fixOnePixelBlurOffset = FIX_ONE_PIXEL_BLUR_OFFSET / scale;
    const { startX, startY, endX, endY } = this._selectionRenderModel;
    this.leftControl.transformByState({
      height: endY - startY,
      left: -leftAdjustWidth + fixOnePixelBlurOffset,
      width: strokeWidth,
      strokeWidth: borderBuffer,
      top: -borderBuffer / 2 + fixOnePixelBlurOffset
    });
    this.leftControl.setProps({
      fill: stroke,
      stroke: SELECTION_CONTROL_BORDER_BUFFER_COLOR
    });
    this.rightControl.transformByState({
      height: endY - startY,
      left: endX - startX - leftAdjustWidth + fixOnePixelBlurOffset,
      width: strokeWidth,
      strokeWidth: borderBuffer,
      top: -borderBuffer / 2 + fixOnePixelBlurOffset
    });
    this.rightControl.setProps({
      fill: stroke,
      stroke: SELECTION_CONTROL_BORDER_BUFFER_COLOR
    });
    this.topControl.transformByState({
      width: endX - startX + strokeWidth,
      top: -leftAdjustWidth + fixOnePixelBlurOffset,
      left: -leftAdjustWidth + fixOnePixelBlurOffset,
      height: strokeWidth,
      strokeWidth: borderBuffer
    });
    this.topControl.setProps({
      fill: stroke,
      stroke: SELECTION_CONTROL_BORDER_BUFFER_COLOR
    });
    this.bottomControl.transformByState({
      width: endX - startX + strokeWidth,
      top: endY - startY - leftAdjustWidth + fixOnePixelBlurOffset,
      height: strokeWidth,
      left: -leftAdjustWidth + fixOnePixelBlurOffset,
      strokeWidth: borderBuffer
    });
    this.bottomControl.setProps({
      fill: stroke,
      stroke: SELECTION_CONTROL_BORDER_BUFFER_COLOR
    });
    if (strokeDash === null || strokeDash === void 0) {
      this.dashedRect.hide();
      this._stopAntLineAnimation();
    } else {
      const dashRectBorderWidth = currentStyle.strokeWidth * 2 / scale;
      this.dashedRect.transformByState({
        height: endY - startY,
        width: endX - startX,
        strokeWidth: dashRectBorderWidth,
        left: -dashRectBorderWidth / 2 + fixOnePixelBlurOffset,
        top: -dashRectBorderWidth / 2 + fixOnePixelBlurOffset
      });
      this.dashedRect.setProps({
        strokeDashArray: [0, strokeDash / scale]
      });
      this._stopAntLineAnimation();
      if (isAnimationDash !== false) {
        this._startAntLineAnimation();
      }
      this.dashedRect.show();
    }
    this._showAutoFill = this._showAutoFill && this._enableAutoFill;
    if (this._showAutoFill && !this._hasWidgets(widgets)) {
      const fillProps = {
        fill: stroke,
        stroke: AutofillStroke,
        strokeScaleEnabled: false
      };
      const sizeState = {
        width: autofillSize - autofillStrokeWidth,
        height: autofillSize - autofillStrokeWidth,
        left: endX - startX - autofillSize / 2 + autofillStrokeWidth / 2 - fixOnePixelBlurOffset,
        top: endY - startY - autofillSize / 2 + autofillStrokeWidth / 2 - fixOnePixelBlurOffset,
        strokeWidth: autofillStrokeWidth
      };
      this._autoFillControl.setProps(fillProps);
      this._autoFillControl.transformByState(sizeState);
      this._autoFillControl.show();
    } else {
      this._autoFillControl.hide();
    }
    this._updateBackgroundControl(currentStyle);
    this._updateHeaderBackground(currentStyle);
    this._updateWidgets(currentStyle);
  }
  /**
   * update selection control coordination by curr selection model
   */
  _updateControlCoord() {
    const { startX, startY } = this._selectionRenderModel;
    this.selectionShapeGroup.show();
    this.selectionShapeGroup.translate(startX, startY);
    this.selectionShapeGroup.makeDirtyNoDebounce(true);
  }
  updateStyle(style) {
    this._updateLayoutOfSelectionControl(style);
    this._updateControlCoord();
  }
  /**
   * Update range and primary range.
   *
   * highlight cell would update if primaryWithCoord has value.
   * highlight cell would be cleared if primaryWithCoord is null.
   * highlight would keep prev value if primaryWithCoord is undefined.
   * @param rangeWithCoord
   * @param primaryWithCoord
   */
  updateRange(rangeWithCoord, primaryWithCoord) {
    this._selectionRenderModel.setValue(rangeWithCoord, primaryWithCoord);
    this._showAutoFill = primaryWithCoord !== null;
    this._updateLayoutOfSelectionControl();
    this._updateControlCoord();
  }
  /**
   * Update range and primary range and style.
   * @param selectionWthCoord
   */
  updateRangeBySelectionWithCoord(selectionWthCoord, sk) {
    if (sk) {
      this._rowHeaderWidth = sk.rowHeaderWidth;
      this._columnHeaderHeight = sk.columnHeaderHeight;
    }
    this._selectionRenderModel.setValue(selectionWthCoord.rangeWithCoord, selectionWthCoord.primaryWithCoord);
    this._showAutoFill = selectionWthCoord.primaryWithCoord !== null;
    this._updateLayoutOfSelectionControl(selectionWthCoord.style);
    this._updateControlCoord();
  }
  /**
   * Update selection model with new range & primary cell(aka: highlight/current), also update row/col selection size & style.
   *
   * @deprecated  use `updateRangeBySelectionWithCoord` and `updateStyle` to do same thing.
   *
   * @param newSelectionRange
   * @param rowHeaderWidth
   * @param columnHeaderHeight
   * @param style
   * @param primaryCell primary cell
   */
  update(newSelectionRange, rowHeaderWidth = 0, columnHeaderHeight = 0, style, primaryCell) {
    this._rowHeaderWidth = rowHeaderWidth;
    this._columnHeaderHeight = columnHeaderHeight;
    this.updateRangeBySelectionWithCoord({
      rangeWithCoord: newSelectionRange,
      primaryWithCoord: primaryCell,
      style
    });
    if (style) {
      this.updateStyle(style);
    }
  }
  /**
   * Update primary range.
   * highlight cell would update if primary cell has value.
   * highlight cell would be cleared if primary cell is null.
   * highlight would keep prev value if primary cell is undefined.
   *
   * @param primaryCell model.current (aka: highlight)
   */
  // @TODO lumixraku there are 3 concepts for same thing, primary and current and highlight
  // highlight is best. primary sometimes means the actual cell(actual means ignore merge)
  updateCurrCell(primaryCell) {
    this._showAutoFill = primaryCell !== null;
    this._selectionRenderModel.setCurrentCell(primaryCell);
  }
  clearHighlight() {
    this._showAutoFill = false;
    this._selectionRenderModel.clearCurrentCell();
    this._updateLayoutOfSelectionControl(this._currentStyle);
  }
  getScene() {
    return this._scene;
  }
  // eslint-disable-next-line complexity
  dispose() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    (_a = this._leftBorder) == null ? void 0 : _a.dispose();
    (_b = this._rightBorder) == null ? void 0 : _b.dispose();
    (_c = this._topBorder) == null ? void 0 : _c.dispose();
    (_d = this._bottomBorder) == null ? void 0 : _d.dispose();
    (_e = this._backgroundControlTop) == null ? void 0 : _e.dispose();
    (_f = this._backgroundControlMiddleLeft) == null ? void 0 : _f.dispose();
    (_g = this._backgroundControlMiddleRight) == null ? void 0 : _g.dispose();
    (_h = this._backgroundControlBottom) == null ? void 0 : _h.dispose();
    this._autoFillControl.dispose();
    (_i = this._selectionShapeGroup) == null ? void 0 : _i.dispose();
    (_j = this._rowHeaderBackground) == null ? void 0 : _j.dispose();
    (_k = this._rowHeaderBorder) == null ? void 0 : _k.dispose();
    (_l = this._rowHeaderGroup) == null ? void 0 : _l.dispose();
    (_m = this._rowHeaderBackground) == null ? void 0 : _m.dispose();
    (_n = this._columnHeaderBackground) == null ? void 0 : _n.dispose();
    (_o = this._columnHeaderBorder) == null ? void 0 : _o.dispose();
    (_p = this._columnHeaderGroup) == null ? void 0 : _p.dispose();
    (_q = this._topLeftWidget) == null ? void 0 : _q.dispose();
    (_r = this._topCenterWidget) == null ? void 0 : _r.dispose();
    (_s = this._topRightWidget) == null ? void 0 : _s.dispose();
    (_t = this._middleLeftWidget) == null ? void 0 : _t.dispose();
    (_u = this._middleRightWidget) == null ? void 0 : _u.dispose();
    (_v = this._bottomLeftWidget) == null ? void 0 : _v.dispose();
    (_w = this._bottomCenterWidget) == null ? void 0 : _w.dispose();
    (_x = this._bottomRightWidget) == null ? void 0 : _x.dispose();
    (_y = this._controlExtension) == null ? void 0 : _y.dispose();
    super.dispose();
    this._dispose$.next(this);
    this._dispose$.complete();
  }
  /**
   * Get the cell information of the current selection, considering the case of merging cells
   */
  getCurrentCellInfo() {
    const currentCell = this.model.currentCell;
    if (currentCell) {
      let currentRangeData;
      if (currentCell.isMerged) {
        const mergeInfo = currentCell.mergeInfo;
        currentRangeData = {
          startRow: mergeInfo.startRow,
          endRow: mergeInfo.endRow,
          startColumn: mergeInfo.startColumn,
          endColumn: mergeInfo.endColumn,
          startX: mergeInfo.startX,
          endX: mergeInfo.endX,
          startY: mergeInfo.startY,
          endY: mergeInfo.endY
        };
      } else {
        const { actualRow, actualColumn, startX, endX, startY, endY } = currentCell;
        currentRangeData = {
          startRow: actualRow,
          endRow: actualRow,
          startColumn: actualColumn,
          endColumn: actualColumn,
          startX,
          endX,
          startY,
          endY
        };
      }
      return currentRangeData;
    }
  }
  getValue() {
    return {
      ...this._selectionRenderModel.getValue(),
      style: this._currentStyle
    };
  }
  getRange() {
    return this._selectionRenderModel.getValue().rangeWithCoord;
  }
  enableHelperSelection() {
    this._isHelperSelection = true;
  }
  disableHelperSelection() {
    this._isHelperSelection = false;
  }
  _updateHeaderBackground(style) {
    const { startX, startY, endX, endY, rangeType } = this._selectionRenderModel;
    const defaultStyle = this._currentStyle;
    const scale = this._getScale();
    const {
      stroke,
      rowHeaderFill = defaultStyle.rowHeaderFill,
      rowHeaderStroke = defaultStyle.rowHeaderStroke,
      columnHeaderFill = defaultStyle.columnHeaderFill,
      columnHeaderStroke = defaultStyle.columnHeaderStroke
    } = style;
    let {
      rowHeaderStrokeWidth = defaultStyle.rowHeaderStrokeWidth,
      columnHeaderStrokeWidth = defaultStyle.columnHeaderStrokeWidth
    } = style;
    rowHeaderStrokeWidth /= scale;
    columnHeaderStrokeWidth /= scale;
    const rowHeaderWidth = this._rowHeaderWidth;
    const columnHeaderHeight = this._columnHeaderHeight;
    if (this._highlightHeader && columnHeaderHeight > 0) {
      let highlightTitleColor = columnHeaderFill;
      if (rangeType === 2 /* COLUMN */) {
        highlightTitleColor = new ColorKit(stroke).setAlpha(SELECTION_TITLE_HIGHLIGHT_ALPHA).toString();
      }
      this._columnHeaderBackground.setProps({
        fill: highlightTitleColor
      });
      this._columnHeaderBackground.resize(endX - startX, columnHeaderHeight);
      this._columnHeaderBorder.setProps({
        fill: columnHeaderStroke
      });
      this._columnHeaderBorder.transformByState({
        width: endX - startX,
        height: columnHeaderStrokeWidth,
        top: columnHeaderHeight - columnHeaderStrokeWidth + 1 / scale
        // + 1 / scale: Avoid appearing thicker due to the adjacency of the first row cells.
      });
      this._columnHeaderGroup.show();
      this._columnHeaderGroup.translate(startX, 0);
    } else {
      this._columnHeaderGroup.hide();
    }
    this._columnHeaderGroup.makeDirty(true);
    if (this._highlightHeader && rowHeaderWidth > 0) {
      let highlightTitleColor = rowHeaderFill;
      if (rangeType === 1 /* ROW */) {
        highlightTitleColor = new ColorKit(stroke).setAlpha(SELECTION_TITLE_HIGHLIGHT_ALPHA).toString();
      }
      this._rowHeaderBackground.setProps({
        fill: highlightTitleColor
      });
      this._rowHeaderBackground.resize(rowHeaderWidth, endY - startY);
      this._rowHeaderBorder.setProps({
        fill: rowHeaderStroke
      });
      this._rowHeaderBorder.transformByState({
        width: rowHeaderStrokeWidth,
        height: endY - startY,
        left: rowHeaderWidth - rowHeaderStrokeWidth + 1 / scale
      });
      this._rowHeaderGroup.show();
      this._rowHeaderGroup.translate(0, startY);
    } else {
      this._rowHeaderGroup.hide();
    }
    this._rowHeaderGroup.makeDirty(true);
  }
  _updateBackgroundControl(style) {
    const { startX, startY, endX, endY } = this._selectionRenderModel;
    const scale = this._getScale();
    const { fill = style.fill } = style;
    let { strokeWidth } = style;
    strokeWidth /= scale;
    const highlightSelection = this._selectionRenderModel.highlightToSelection();
    if (!highlightSelection) {
      this._backgroundControlTop.resize(endX - startX, endY - startY);
      this._backgroundControlTop.setProps({ fill });
      this._backgroundControlBottom.resize(0, 0);
      this._backgroundControlMiddleLeft.resize(0, 0);
      this._backgroundControlMiddleRight.resize(0, 0);
      return;
    }
    const { startX: h_startX, startY: h_startY, endX: h_endX, endY: h_endY } = highlightSelection;
    const strokeOffset = strokeWidth / 2;
    const topConfig = {
      left: -strokeOffset,
      top: -strokeOffset,
      width: endX - startX + strokeOffset * 2,
      height: h_startY - startY + strokeOffset
    };
    if (topConfig.height < 0) {
      topConfig.width = 0;
      topConfig.height = 0;
    }
    this._backgroundControlTop.transformByState(topConfig);
    const middleLeftConfig = {
      left: -strokeOffset,
      top: h_startY - startY,
      width: h_startX - startX + strokeOffset,
      height: h_endY - h_startY
    };
    if (middleLeftConfig.width < 0) {
      middleLeftConfig.width = 0;
      middleLeftConfig.height = 0;
    }
    this._backgroundControlMiddleLeft.transformByState(middleLeftConfig);
    const middleRightConfig = {
      left: h_endX - startX - strokeOffset,
      top: h_startY - startY,
      width: endX - h_endX + strokeOffset * 2,
      height: h_endY - h_startY
    };
    if (middleRightConfig.width < 0) {
      middleRightConfig.width = 0;
      middleRightConfig.height = 0;
    }
    this._backgroundControlMiddleRight.transformByState(middleRightConfig);
    const middleBottomConfig = {
      left: -strokeOffset,
      top: h_endY - startY,
      width: endX - startX + strokeOffset * 2,
      height: endY - h_endY + strokeOffset
    };
    if (middleBottomConfig.height < 0) {
      middleBottomConfig.width = 0;
      middleBottomConfig.height = 0;
    }
    this._backgroundControlBottom.transformByState(middleBottomConfig);
    this._backgroundControlTop.setProps({ fill });
    this._backgroundControlMiddleLeft.setProps({ fill });
    this._backgroundControlMiddleRight.setProps({ fill });
    this._backgroundControlBottom.setProps({ fill });
  }
  _updateWidgets(style) {
    const { startX, startY, endX, endY } = this._selectionRenderModel;
    const { stroke = style.stroke, widgets = style.widgets, widgetStroke = style.widgetStroke } = style;
    const scale = this._getScale();
    let { widgetSize, widgetStrokeWidth } = style;
    widgetSize /= scale;
    widgetStrokeWidth /= scale;
    const position = { left: -widgetSize / 2 + widgetStrokeWidth / 2, center: (endX - startX) / 2 - widgetSize / 2 + widgetStrokeWidth / 2, right: endX - startX - widgetSize / 2 + widgetStrokeWidth / 2, top: -widgetSize / 2, middle: (endY - startY) / 2 - widgetSize / 2, bottom: endY - startY - widgetSize / 2 + widgetStrokeWidth / 2 };
    const size = widgetSize - widgetStrokeWidth;
    this._widgetRects.forEach((widget) => {
      widget.setProps({ fill: stroke, stroke: widgetStroke });
    });
    if (widgets.tl === true) {
      this._topLeftWidget.transformByState({ height: size, width: size, left: position.left, top: position.top, strokeWidth: widgetStrokeWidth });
      this._topLeftWidget.show();
    } else {
      this._topLeftWidget.hide();
    }
    if (widgets.tc === true) {
      this._topCenterWidget.transformByState({ height: size, width: size, left: position.center, top: position.top, strokeWidth: widgetStrokeWidth });
      this._topCenterWidget.show();
    } else {
      this._topCenterWidget.hide();
    }
    if (widgets.tr === true) {
      this._topRightWidget.transformByState({ height: size, width: size, left: position.right, top: position.top, strokeWidth: widgetStrokeWidth });
      this._topRightWidget.show();
    } else {
      this._topRightWidget.hide();
    }
    if (widgets.ml === true) {
      this._middleLeftWidget.transformByState({ height: size, width: size, left: position.left, top: position.middle, strokeWidth: widgetStrokeWidth });
      this._middleLeftWidget.show();
    } else {
      this._middleLeftWidget.hide();
    }
    if (widgets.mr === true) {
      this._middleRightWidget.transformByState({ height: size, width: size, left: position.right, top: position.middle, strokeWidth: widgetStrokeWidth });
      this._middleRightWidget.show();
    } else {
      this._middleRightWidget.hide();
    }
    if (widgets.bl === true) {
      this._bottomLeftWidget.transformByState({ height: size, width: size, left: position.left, top: position.bottom, strokeWidth: widgetStrokeWidth });
      this._bottomLeftWidget.show();
    } else {
      this._bottomLeftWidget.hide();
    }
    if (widgets.bc === true) {
      this._bottomCenterWidget.transformByState({ height: size, width: size, left: position.center, top: position.bottom, strokeWidth: widgetStrokeWidth });
      this._bottomCenterWidget.show();
    } else {
      this._bottomCenterWidget.hide();
    }
    if (widgets.br === true) {
      this._bottomRightWidget.transformByState({ height: size, width: size, left: position.right, top: position.bottom, strokeWidth: widgetStrokeWidth });
      this._bottomRightWidget.show();
    } else {
      this._bottomRightWidget.hide();
    }
  }
  _hasWidgets(widgets) {
    if (widgets == null) {
      return false;
    }
    const keys = Object.keys(widgets);
    if (keys.length === 0) {
      return false;
    }
    for (const key of keys) {
      if (widgets[key] === true) {
        return true;
      }
    }
    return false;
  }
  _getScale() {
    const { scaleX, scaleY } = this._scene.getAncestorScale();
    return Math.max(scaleX, scaleY);
  }
  _stopAntLineAnimation() {
    this._antLineOffset = 0;
    cancelRequestFrame(this._antRequestNewFrame);
  }
  _startAntLineAnimation() {
    const scale = this._getScale();
    this._antLineOffset += 0.6 / scale;
    if (this._antLineOffset > 160 / scale) {
      this._antLineOffset = 0;
    }
    this.dashedRect.setProps({
      strokeDashOffset: -this._antLineOffset
    });
    this._antRequestNewFrame = requestNewFrame(() => {
      this._startAntLineAnimation();
    });
  }
};

// ../packages/sheets-ui/src/services/selection/selection-layer.ts
var SelectionLayer = class extends Layer {
  render(ctx, isMaxLayer = false) {
    const startTime = Tools.now();
    super.render(ctx, isMaxLayer);
    this._afterRender(startTime);
    return this;
  }
  _afterRender(startTime) {
    const engine = this.scene.getEngine();
    engine.renderFrameTimeMetric$.next(["selectionLayer", Tools.now() - startTime]);
  }
};

// ../packages/sheets-ui/src/services/selection/base-selection-render.service.ts
var ISheetSelectionRenderService = createIdentifier("univer.sheet.selection-render-service");
var BaseSelectionRenderService = class extends Disposable {
  constructor(_injector, _themeService, _shortcutService, _sheetSkeletonManagerService, contextService) {
    super();
    this._injector = _injector;
    this._themeService = _themeService;
    this._shortcutService = _shortcutService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this.contextService = contextService;
    __publicField(this, "_downObserver");
    __publicField(this, "_scenePointerMoveSub");
    __publicField(this, "_scenePointerUpSub");
    __publicField(this, "_controlFillConfig$", new BehaviorSubject(null));
    __publicField(this, "controlFillConfig$", this._controlFillConfig$.asObservable());
    __publicField(this, "_selectionControls", []);
    // sheetID:Controls
    __publicField(this, "_startRangeWhenPointerDown", {
      startY: 0,
      endY: 0,
      startX: 0,
      endX: 0,
      startRow: -1,
      endRow: -1,
      startColumn: -1,
      endColumn: -1
    });
    __publicField(this, "_activeControlIndex", -1);
    /**
     * the posX of viewport when the pointer down
     */
    __publicField(this, "_startViewportPosX", 0);
    /**
     * the posY of viewport when the pointer down
     */
    __publicField(this, "_startViewportPosY", 0);
    __publicField(this, "_scrollTimer");
    __publicField(this, "_cancelDownSubscription");
    __publicField(this, "_cancelUpSubscription");
    __publicField(this, "_skeleton");
    /**
     * From renderContext.
     */
    __publicField(this, "_scene");
    // The type of selector determines the type of data range and the highlighting style of the title bar, now it always true. In future, this could be configurable by user.
    __publicField(this, "_highlightHeader", true);
    // protected _shouldDetectMergedCells: boolean = true;
    __publicField(this, "_rangeType", 0 /* NORMAL */);
    // The style of the selection area, including dashed lines, color, thickness, autofill, other points for modifying the range of the selection area, title highlighting, and so on, can all be customized.
    __publicField(this, "_selectionStyle");
    // #region ref range selection
    // we put the properties here for simplicity
    // Used in the formula selection feature, a new selection string is added by drawing a box with the mouse.
    __publicField(this, "_remainLastEnabled", false);
    __publicField(this, "_skipLastEnabled", false);
    __publicField(this, "_singleSelectionEnabled", false);
    // #endregion
    /**
     * Mainly emit by pointerup in spreadsheet. (pointerup is handled in _onPointerdown)
     */
    __publicField(this, "_selectionMoveEnd$", new BehaviorSubject([]));
    /**
     * Pointerup in spreadsheet
     */
    __publicField(this, "selectionMoveEnd$", this._selectionMoveEnd$.asObservable());
    /**
     * Mainly emit by pointermove in spreadsheet
     */
    __publicField(this, "_selectionMoving$", new Subject());
    /**
     * Pointermove in spreadsheet
     */
    __publicField(this, "selectionMoving$", this._selectionMoving$.asObservable());
    __publicField(this, "_selectionMoveStart$", new Subject());
    __publicField(this, "selectionMoveStart$", this._selectionMoveStart$.asObservable());
    __publicField(this, "_selectionMoving", false);
    __publicField(this, "_selectionTheme");
    __publicField(this, "_activeViewport");
    __publicField(this, "interceptor", new InterceptorManager({ RANGE_MOVE_PERMISSION_CHECK, RANGE_FILL_PERMISSION_CHECK }));
    __publicField(this, "_escapeShortcutDisposable", null);
    this._initSelectionThemeFromThemeService();
    this._initMoving();
  }
  get selectionMoving() {
    return this._selectionMoving;
  }
  /**
   * If true, the selector will respond to the range of merged cells and automatically extend the selected range. If false, it will ignore the merged cells.
   */
  get _shouldDetectMergedCells() {
    return this._rangeType === 0 /* NORMAL */;
  }
  _initMoving() {
    this.disposeWithMe(this._selectionMoving$.subscribe(() => {
      this._selectionMoving = true;
    }));
    this.disposeWithMe(this._selectionMoveEnd$.subscribe(() => {
      this._selectionMoving = false;
    }));
  }
  _setSelectionStyle(style) {
    this._selectionStyle = style;
  }
  /**
   * Reset this._selectionStyle to default normal selection style
   */
  // protected _resetSelectionStyle(): void {
  //     this._setSelectionStyle(genNormalSelectionStyle(this._themeService));
  // }
  /** @deprecated This should not be provided by the selection render service. */
  getViewPort() {
    return this._activeViewport;
  }
  setSingleSelectionEnabled(enabled = false) {
    this._singleSelectionEnabled = enabled;
  }
  newSelectionControl(scene, skeleton, selection) {
    const zIndex = this.getSelectionControls().length;
    const { rowHeaderWidth, columnHeaderHeight } = skeleton;
    const control = new SelectionControl(scene, zIndex, this._selectionTheme, {
      highlightHeader: this._highlightHeader,
      rowHeaderWidth,
      columnHeaderHeight
    });
    this._selectionControls.push(control);
    const selectionWithCoord = attachSelectionWithCoord(selection, skeleton);
    control.updateRangeBySelectionWithCoord(selectionWithCoord, skeleton);
    control.setControlExtension({
      skeleton,
      scene,
      themeService: this._selectionTheme,
      injector: this._injector,
      selectionHooks: {
        selectionMoveEnd: () => {
          this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
        }
      }
    });
    return control;
  }
  /**
   * Update the corresponding selectionControl based on selectionsData from WorkbookSelectionModel
   * selectionData[i] --> selectionControls[i]
   * @param selectionsWithStyleList {ISelectionWithStyle[]} selectionsData from WorkbookSelectionModel
   */
  resetSelectionsByModelData(selectionsWithStyleList) {
    const allSelectionControls = this.getSelectionControls();
    const skeleton = this._skeleton;
    if (!allSelectionControls || !skeleton) {
      return;
    }
    for (let i = 0, len = selectionsWithStyleList.length; i < len; i++) {
      const selectionWithStyle = selectionsWithStyleList[i];
      const selectionWithCoord = attachSelectionWithCoord(selectionWithStyle, this._skeleton);
      const control = allSelectionControls[i];
      if (control) {
        control.updateRangeBySelectionWithCoord(selectionWithCoord, skeleton);
      } else {
        if (this.isSelectionEnabled()) {
          this.newSelectionControl(this._scene, skeleton, selectionWithStyle);
        }
      }
    }
    if (selectionsWithStyleList.length < allSelectionControls.length) {
      const controlsToDestroy = allSelectionControls.splice(selectionsWithStyleList.length);
      controlsToDestroy.forEach((control) => control.dispose());
    }
  }
  refreshSelectionMoveStart() {
    this._selectionMoveStart$.next(this.getSelectionDataWithStyle());
  }
  refreshSelectionMoveEnd() {
    this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
  }
  _initSelectionThemeFromThemeService() {
    const currTheme = this._themeService.getCurrentTheme();
    this._selectionTheme = new ThemeService();
    this._selectionTheme.setTheme(currTheme);
  }
  setSelectionTheme(prop) {
    this._selectionTheme.setTheme(prop);
  }
  _changeRuntime(skeleton, scene, viewport) {
    this._skeleton = skeleton;
    this._scene = scene;
    this._activeViewport = viewport || (scene == null ? void 0 : scene.getViewports()[0]);
    if (!scene.findLayerByZIndex(SHEET_COMPONENT_SELECTION_LAYER_INDEX)) {
      scene.addLayer(new SelectionLayer(scene, [], SHEET_COMPONENT_SELECTION_LAYER_INDEX));
    }
  }
  getSkeleton() {
    return this._skeleton;
  }
  /**
   * Generate selectionData from this._selectionControls.model .
   * @returns {ISelectionWithCoord[]} {range, primary, style}[]
   */
  getSelectionDataWithStyle() {
    const selectionControls = this._selectionControls;
    const [unitId, sheetId] = this._skeleton.getLocation();
    return selectionControls.map((control) => {
      const v = control.getValue();
      v.rangeWithCoord.sheetId = sheetId;
      v.rangeWithCoord.unitId = unitId;
      return v;
    });
  }
  /**
   * @TODO lumixraku DO NOT expose private props.
   */
  getSelectionControls() {
    return this._selectionControls;
  }
  /**
   * Add a selection in spreadsheet, create a new SelectionControl and then update this control by range derives from selection.
   * @param {ISelectionWithCoord} selectionWithStyle
   */
  _addSelectionControlByModelData(selectionWithStyle) {
    var _a;
    const skeleton = this._skeleton;
    const style = (_a = selectionWithStyle.style) != null ? _a : genNormalSelectionStyle(this._selectionTheme);
    const scene = this._scene;
    selectionWithStyle.style = style;
    const control = this.newSelectionControl(scene, skeleton, selectionWithStyle);
    return control;
  }
  _clearAllSelectionControls() {
    const allSelectionControls = this._selectionControls;
    for (const control of allSelectionControls) {
      control.dispose();
    }
    this._selectionControls.length = 0;
  }
  _getFreeze() {
    var _a;
    const freeze = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton.getWorksheetConfig().freeze;
    return freeze;
  }
  _getViewportByCell(row, column) {
    if (row === void 0 || column === void 0) {
      return null;
    }
    const freeze = this._getFreeze();
    if (!freeze || freeze.startRow <= 0 && freeze.startColumn <= 0) {
      return this._scene.getViewport("viewMain" /* VIEW_MAIN */);
    }
    if (row > freeze.startRow && column > freeze.startColumn) {
      return this._scene.getViewport("viewMain" /* VIEW_MAIN */);
    }
    if (row <= freeze.startRow && column <= freeze.startColumn) {
      return this._scene.getViewport("viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */);
    }
    if (row <= freeze.startRow && column > freeze.startColumn) {
      return this._scene.getViewport("viewMainTop" /* VIEW_MAIN_TOP */);
    }
    if (row > freeze.startRow && column <= freeze.startColumn) {
      return this._scene.getViewport("viewMainLeft" /* VIEW_MAIN_LEFT */);
    }
  }
  /**
   * Returns the selected range in the active sheet, or null if there is no active range. If multiple ranges are selected this method returns only the last selected range.
   */
  getActiveRange() {
    const controls = this.getSelectionControls();
    const model = controls && controls[controls.length - 1].model;
    return model && {
      startRow: model.startRow,
      startColumn: model.startColumn,
      endRow: model.endRow,
      endColumn: model.endColumn
    };
  }
  setActiveSelectionIndex(index) {
    this._activeControlIndex = index;
  }
  resetActiveSelectionIndex() {
    this._activeControlIndex = -1;
  }
  /**
   * get active(actually last) selection control
   * @returns T extends SelectionControl
   */
  getActiveSelectionControl() {
    const controls = this.getSelectionControls();
    if (controls) {
      if (this._activeControlIndex < 0) {
        return controls[controls.length - 1];
      }
      return controls[this._activeControlIndex];
    }
  }
  endSelection() {
    var _a;
    this._clearUpdatingListeners();
    this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
    (_a = this._escapeShortcutDisposable) == null ? void 0 : _a.dispose();
    this._escapeShortcutDisposable = null;
  }
  /**
   * Clear existed selections by workbookSelections.selectionMoveEnd$
   */
  _reset() {
    var _a;
    this._clearAllSelectionControls();
    (_a = this._downObserver) == null ? void 0 : _a.unsubscribe();
    this._downObserver = null;
  }
  /**
   * Init pointer move listener in each pointer down, unbind in each pointer up.
   * Both cell selections and row-column selections are supported by this method.
   * @param viewportMain
   * @param activeSelectionControl
   * @param rangeType
   * @param scrollTimerType
   * @param moveStartPosX
   * @param moveStartPosY
   */
  _setupPointerMoveListener(viewportMain, activeSelectionControl, rangeType, scrollTimerType = 3 /* ALL */, moveStartPosX, moveStartPosY) {
    var _a, _b;
    let xCrossTime = 0;
    let yCrossTime = 0;
    let lastX = moveStartPosX;
    let lastY = moveStartPosY;
    this._scrollTimer = ScrollTimer.create(this._scene, scrollTimerType);
    this._scrollTimer.startScroll((_a = viewportMain == null ? void 0 : viewportMain.left) != null ? _a : 0, (_b = viewportMain == null ? void 0 : viewportMain.top) != null ? _b : 0, viewportMain);
    const scene = this._scene;
    const startViewport = scene.getActiveViewportByCoord(Vector2.FromArray([moveStartPosX, moveStartPosY]));
    this._scenePointerMoveSub = scene.onPointerMove$.subscribeEvent((moveEvt) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i;
      const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
      const { x: newMoveOffsetX, y: newMoveOffsetY } = scene.getCoordRelativeToViewport(Vector2.FromArray([moveOffsetX, moveOffsetY]));
      this._movingHandler(newMoveOffsetX, newMoveOffsetY, activeSelectionControl, rangeType);
      let scrollOffsetX = newMoveOffsetX;
      let scrollOffsetY = newMoveOffsetY;
      const currentSelection = this.getActiveSelectionControl();
      const freeze = this._getFreeze();
      const selection = currentSelection == null ? void 0 : currentSelection.model;
      const endViewport = (_a2 = scene.getActiveViewportByCoord(Vector2.FromArray([moveOffsetX, moveOffsetY]))) != null ? _a2 : this._getViewportByCell(selection == null ? void 0 : selection.endRow, selection == null ? void 0 : selection.endColumn);
      const isCrossableViewports = () => {
        if (!startViewport || !endViewport || !viewportMain) {
          return false;
        }
        const crossableViewports = ["viewMain" /* VIEW_MAIN */, "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */, "viewMainTop" /* VIEW_MAIN_TOP */, "viewMainLeft" /* VIEW_MAIN_LEFT */];
        return crossableViewports.includes(startViewport.viewportKey) && crossableViewports.includes(endViewport.viewportKey);
      };
      if (isCrossableViewports()) {
        if (!startViewport || !endViewport || !viewportMain) {
          return false;
        }
        const isCrossingX = lastX < viewportMain.left && newMoveOffsetX > viewportMain.left || lastX > viewportMain.left && newMoveOffsetX < viewportMain.left;
        const isCrossingY = lastY < viewportMain.top && newMoveOffsetY > viewportMain.top || lastY > viewportMain.top && newMoveOffsetY < viewportMain.top;
        if (isCrossingX) {
          xCrossTime += 1;
        }
        if (isCrossingY) {
          yCrossTime += 1;
        }
        const startKey = startViewport.viewportKey;
        const endKey = endViewport.viewportKey;
        if (startKey === "viewRowTop" /* VIEW_ROW_TOP */) {
          if (moveOffsetY < viewportMain.top && ((_b2 = selection == null ? void 0 : selection.endRow) != null ? _b2 : 0) < ((_c = freeze == null ? void 0 : freeze.startRow) != null ? _c : 0)) {
            scrollOffsetY = viewportMain.top;
          } else if (isCrossingY && yCrossTime % 2 === 1) {
            viewportMain.scrollToViewportPos({
              viewportScrollY: 0
            });
          }
        } else if (startKey === "viewColumnLeft" /* VIEW_COLUMN_LEFT */) {
          if (moveOffsetX < viewportMain.left && ((_d = selection == null ? void 0 : selection.endColumn) != null ? _d : 0) < ((_e = freeze == null ? void 0 : freeze.startColumn) != null ? _e : 0)) {
            scrollOffsetX = viewportMain.left;
          } else if (isCrossingX && xCrossTime % 2 === 1) {
            viewportMain.scrollToViewportPos({
              viewportScrollX: 0
            });
          }
        } else if (startKey === endKey) {
          let disableX = false;
          let disableY = false;
          if (startKey === "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */) {
            disableX = true;
            disableY = true;
          } else if (startKey === "viewMainTop" /* VIEW_MAIN_TOP */) {
            disableY = true;
          } else if (startKey === "viewMainLeft" /* VIEW_MAIN_LEFT */) {
            disableX = true;
          }
          if (((_f = selection == null ? void 0 : selection.endRow) != null ? _f : 0) > ((_g = freeze == null ? void 0 : freeze.startRow) != null ? _g : 0)) {
            disableY = false;
          }
          if (((_h = selection == null ? void 0 : selection.endColumn) != null ? _h : 0) > ((_i = freeze == null ? void 0 : freeze.startColumn) != null ? _i : 0)) {
            disableX = false;
          }
          if (disableX) {
            scrollOffsetX = viewportMain.left;
          }
          if (disableY) {
            scrollOffsetY = viewportMain.top;
          }
        } else {
          const startXY = {
            x: startViewport.scrollX,
            y: startViewport.scrollY
          };
          const endXY = {
            x: endViewport.scrollX,
            y: endViewport.scrollY
          };
          const shouldResetX = startXY.x !== endXY.x && isCrossingX && xCrossTime % 2 === 1;
          const shouldResetY = startXY.y !== endXY.y && isCrossingY && yCrossTime % 2 === 1;
          if (shouldResetX || shouldResetY) {
            viewportMain.scrollToBarPos({
              x: shouldResetX ? startXY.x : void 0,
              y: shouldResetY ? startXY.y : void 0
            });
            if (!shouldResetX) {
              scrollOffsetX = viewportMain.left;
            }
            if (!shouldResetY) {
              scrollOffsetY = viewportMain.top;
            }
          }
          if (startKey === "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */ && endKey === "viewMainLeft" /* VIEW_MAIN_LEFT */ || endKey === "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */ && startKey === "viewMainLeft" /* VIEW_MAIN_LEFT */) {
            scrollOffsetX = viewportMain.left;
          }
          if (startKey === "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */ && endKey === "viewMainTop" /* VIEW_MAIN_TOP */ || endKey === "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */ && startKey === "viewMainTop" /* VIEW_MAIN_TOP */) {
            scrollOffsetY = viewportMain.top;
          }
        }
        lastX = newMoveOffsetX;
        lastY = newMoveOffsetY;
      }
      this._scrollTimer.scrolling(scrollOffsetX, scrollOffsetY, () => {
        this._movingHandler(newMoveOffsetX, newMoveOffsetY, activeSelectionControl, rangeType);
      });
    });
  }
  /** @deprecated Use the function `attachSelectionWithCoord` instead`. */
  attachSelectionWithCoord(selectionWithStyle) {
    return attachSelectionWithCoord(selectionWithStyle, this._skeleton);
  }
  /** @deprecated Use the function `attachPrimaryWithCoord` instead`. */
  attachPrimaryWithCoord(primary) {
    return attachPrimaryWithCoord(this._skeleton, primary);
  }
  /**
   * @deprecated Please use `getCellWithCoordByOffset` instead.
   */
  getSelectionCellByPosition(x, y) {
    return this.getCellWithCoordByOffset(x, y);
  }
  getCellWithCoordByOffset(x, y, skeletonParam) {
    const scene = this._scene;
    const skeleton = skeletonParam != null ? skeletonParam : this._skeleton;
    const scrollXY = scene.getViewportScrollXY(scene.getViewport("viewMain" /* VIEW_MAIN */));
    const { scaleX, scaleY } = scene.getAncestorScale();
    return skeleton.getCellWithCoordByOffset(x, y, scaleX, scaleY, scrollXY);
  }
  /**
   * When mousedown and mouseup need to go to the coordination and undo stack, when mousemove does not need to go to the coordination and undo stack
   */
  _movingHandler(offsetX, offsetY, activeSelectionControl, rangeType) {
    var _a, _b, _c, _d, _e;
    const skeleton = this._skeleton;
    const scene = this._scene;
    const [unitId, sheetId] = skeleton.getLocation();
    const currSelectionRange = {
      startRow: (_a = activeSelectionControl == null ? void 0 : activeSelectionControl.model.startRow) != null ? _a : -1,
      endRow: (_b = activeSelectionControl == null ? void 0 : activeSelectionControl.model.endRow) != null ? _b : -1,
      startColumn: (_c = activeSelectionControl == null ? void 0 : activeSelectionControl.model.startColumn) != null ? _c : -1,
      endColumn: (_d = activeSelectionControl == null ? void 0 : activeSelectionControl.model.endColumn) != null ? _d : -1,
      unitId,
      sheetId
    };
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const targetViewport = (_e = this._getViewportByCell(currSelectionRange.endRow, currSelectionRange.endColumn)) != null ? _e : viewportMain;
    const scrollXY = scene.getScrollXYInfoByViewport(
      Vector2.FromArray([this._startViewportPosX, this._startViewportPosY]),
      targetViewport
    );
    const { scaleX, scaleY } = scene.getAncestorScale();
    if (rangeType === 1 /* ROW */) {
      offsetX = Number.POSITIVE_INFINITY;
    } else if (rangeType === 2 /* COLUMN */) {
      offsetY = Number.POSITIVE_INFINITY;
    }
    const currCell = this._skeleton.getCellByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
    if (!currCell) {
      return;
    }
    let newSelectionRange = {
      startRow: Math.min(currCell.startRow, this._startRangeWhenPointerDown.startRow),
      startColumn: Math.min(currCell.startColumn, this._startRangeWhenPointerDown.startColumn),
      endRow: Math.max(currCell.endRow, this._startRangeWhenPointerDown.endRow),
      endColumn: Math.max(currCell.endColumn, this._startRangeWhenPointerDown.endColumn)
    };
    if (this._shouldDetectMergedCells) {
      newSelectionRange = skeleton.expandRangeByMerge(newSelectionRange);
    }
    const newSelection = { range: newSelectionRange, primary: void 0, style: null };
    const newSelectionRangeWithCoord = attachSelectionWithCoord(newSelection, skeleton);
    newSelectionRangeWithCoord.rangeWithCoord.unitId = unitId;
    newSelectionRangeWithCoord.rangeWithCoord.sheetId = sheetId;
    newSelectionRangeWithCoord.rangeWithCoord.rangeType = rangeType;
    const rangeChanged = currSelectionRange.startRow !== newSelectionRange.startRow || currSelectionRange.startColumn !== newSelectionRange.startColumn || currSelectionRange.endRow !== newSelectionRange.endRow || currSelectionRange.endColumn !== newSelectionRange.endColumn;
    if (activeSelectionControl != null && rangeChanged) {
      activeSelectionControl.updateRangeBySelectionWithCoord(newSelectionRangeWithCoord);
      this._selectionMoving$.next(this.getSelectionDataWithStyle());
    }
  }
  _clearUpdatingListeners() {
    var _a, _b, _c, _d, _e;
    const scene = this._scene;
    scene.enableObjectsEvent();
    (_a = this._scenePointerMoveSub) == null ? void 0 : _a.unsubscribe();
    this._scenePointerMoveSub = null;
    (_b = this._scenePointerUpSub) == null ? void 0 : _b.unsubscribe();
    this._scenePointerUpSub = null;
    (_c = this._cancelDownSubscription) == null ? void 0 : _c.unsubscribe();
    this._cancelDownSubscription = null;
    (_d = this._cancelUpSubscription) == null ? void 0 : _d.unsubscribe();
    this._cancelUpSubscription = null;
    (_e = this._scrollTimer) == null ? void 0 : _e.dispose();
  }
  _addEndingListeners() {
    var _a, _b, _c;
    const scene = this._scene;
    const mainScene = (_a = scene.getEngine()) == null ? void 0 : _a.activeScene;
    if (!mainScene || mainScene === scene) {
      return;
    }
    (_b = this._cancelDownSubscription) == null ? void 0 : _b.unsubscribe();
    this._cancelDownSubscription = null;
    (_c = this._cancelUpSubscription) == null ? void 0 : _c.unsubscribe();
    this._cancelUpSubscription = null;
    this._cancelDownSubscription = mainScene.onPointerDown$.subscribeEvent(() => this._clearUpdatingListeners());
    this._cancelUpSubscription = mainScene.onPointerUp$.subscribeEvent(() => this._clearUpdatingListeners());
  }
  /**
   * Get visible selection range & coord by offset on viewport. Nearly same as skeleton.getCellWithCoordByOffset
   * Returning selection is only one cell. primary and range are same cell.
   *
   * visible selection range means getCellWithCoordByOffset needs first matched row/col in rowHeightAccumulation & colWidthAccumulation.
   * Original name: _getCellRangeByCursorPosition
   *
   * @param offsetX position X in viewport.
   * @param offsetY
   * @param scaleX
   * @param scaleY
   * @param scrollXY
   * @returns {Nullable<ISelectionWithCoord>} selection range with coord.
   */
  _getSelectionWithCoordByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY) {
    const skeleton = this._skeleton;
    if (skeleton == null) return null;
    if (this._shouldDetectMergedCells) {
      const primaryWithCoord2 = skeleton == null ? void 0 : skeleton.getCellWithCoordByOffset(
        offsetX,
        offsetY,
        scaleX,
        scaleY,
        scrollXY,
        { firstMatch: true }
      );
      if (!primaryWithCoord2) return;
      const rangeWithCoord2 = convertCellToRange(primaryWithCoord2);
      return {
        primaryWithCoord: primaryWithCoord2,
        rangeWithCoord: rangeWithCoord2
      };
    }
    const { row, column } = skeleton.getCellIndexByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
    const startCell = skeleton.getNoMergeCellWithCoordByIndex(row, column);
    const { startX, startY, endX, endY } = startCell;
    const rangeWithCoord = {
      startY,
      endY,
      startX,
      endX,
      startRow: row,
      endRow: row,
      startColumn: column,
      endColumn: column
    };
    const primaryWithCoord = {
      mergeInfo: rangeWithCoord,
      actualRow: row,
      actualColumn: column,
      isMerged: false,
      isMergedMainCell: false,
      startY,
      endY,
      startX,
      endX
    };
    return {
      primaryWithCoord,
      rangeWithCoord
    };
  }
  _checkClearPreviousControls(evt) {
    const curControls = this.getSelectionControls();
    if (curControls.length === 0) return;
    if (!evt.ctrlKey && !evt.shiftKey && !this._remainLastEnabled || this._singleSelectionEnabled && !evt.shiftKey) {
      this._clearAllSelectionControls();
    }
  }
  _makeSelectionByTwoCells(currentCell, startSelectionRange, skeleton, rangeType, activeControl) {
    const { actualRow, actualColumn, mergeInfo: actualMergeInfo } = currentCell;
    this._startRangeWhenPointerDown = { ...currentCell.mergeInfo };
    const newStartRow = Math.min(actualRow, startSelectionRange.startRow, actualMergeInfo.startRow);
    const newEndRow = Math.max(actualRow, startSelectionRange.endRow, actualMergeInfo.endRow);
    const newStartColumn = Math.min(actualColumn, startSelectionRange.startColumn, actualMergeInfo.startColumn);
    const newEndColumn = Math.max(actualColumn, startSelectionRange.endColumn, actualMergeInfo.endColumn);
    const range = skeleton.expandRangeByMerge({
      startRow: newStartRow,
      startColumn: newStartColumn,
      endRow: newEndRow,
      endColumn: newEndColumn
    });
    const selectionWithStyle = {
      range,
      primary: null,
      style: null
    };
    const selectionWithCoord = attachSelectionWithCoord(selectionWithStyle, skeleton);
    activeControl.updateRangeBySelectionWithCoord(selectionWithCoord);
  }
  isSelectionEnabled() {
    return this.contextService.getContextValue(SELECTIONS_ENABLED);
  }
  isSelectionDisabled() {
    return this.contextService.getContextValue(SELECTIONS_ENABLED) === false;
  }
  inRefSelectionMode() {
    return this.contextService.getContextValue(REF_SELECTIONS_ENABLED);
  }
};
function selectionDataForSelectAll(skeleton) {
  return {
    range: {
      startRow: 0,
      startColumn: 0,
      endRow: skeleton.getRowCount() - 1,
      endColumn: skeleton.getColumnCount() - 1,
      rangeType: 3 /* ALL */
    },
    primary: getTopLeftSelectionOfCurrSheet(skeleton).primary,
    style: null
  };
}
function getTopLeftSelectionOfCurrSheet(skeleton) {
  return genSelectionByRange(skeleton, {
    startRow: 0,
    startColumn: 0,
    endRow: 0,
    endColumn: 0
  });
}
function genSelectionByRange(skeleton, range) {
  const topLeftCell = skeleton.worksheet.getCellInfoInMergeData(range.startRow, range.startColumn);
  const bottomRightCell = skeleton.worksheet.getCellInfoInMergeData(range.endRow, range.endColumn);
  const rs = {
    range: {
      startRow: topLeftCell.startRow,
      startColumn: topLeftCell.startColumn,
      endRow: bottomRightCell.endRow,
      endColumn: bottomRightCell.endColumn,
      rangeType: 0 /* NORMAL */
    },
    primary: {
      actualRow: topLeftCell.startRow,
      actualColumn: topLeftCell.startColumn,
      startRow: topLeftCell.startRow,
      startColumn: topLeftCell.startColumn,
      endRow: topLeftCell.endRow,
      endColumn: topLeftCell.endColumn,
      isMerged: topLeftCell.isMerged,
      isMergedMainCell: topLeftCell.isMergedMainCell
    },
    style: null
  };
  return rs;
}

// ../packages/sheets-ui/src/services/sheet-skeleton-manager.service.ts
var SheetSkeletonManagerService = class extends Disposable {
  constructor(_context, _injector, _sheetSkService) {
    super();
    this._context = _context;
    this._injector = _injector;
    this._sheetSkService = _sheetSkService;
    __publicField(this, "_sheetId", "");
    // @TODO lumixraku, why need this?  How about put dirty & sheetId & unitId in skeleton itself?
    __publicField(this, "_sheetSkeletonParamStore", /* @__PURE__ */ new Map());
    __publicField(this, "_currentSkeleton$", new BehaviorSubject(null));
    __publicField(this, "currentSkeleton$", this._currentSkeleton$.asObservable());
    /**
     * CurrentSkeletonBefore for pre-triggered logic during registration
     */
    __publicField(this, "_currentSkeletonBefore$", new BehaviorSubject(null));
    __publicField(this, "currentSkeletonBefore$", this._currentSkeletonBefore$.asObservable());
    this.disposeWithMe(() => {
      this._currentSkeletonBefore$.complete();
      this._currentSkeleton$.complete();
      this._sheetSkeletonParamStore.forEach((sk) => this.disposeSkeleton(sk.sheetId));
      this._sheetSkeletonParamStore.clear();
    });
    this._initRemoveSheet();
  }
  _initRemoveSheet() {
    this.disposeWithMe(this._context.unit.sheetDisposed$.subscribe((sheet) => {
      this.disposeSkeleton(sheet.getSheetId());
    }));
  }
  getCurrentSkeleton() {
    var _a;
    return (_a = this.getCurrentParam()) == null ? void 0 : _a.skeleton;
  }
  /**
   * @deprecated use `getCurrentSkeleton` instead.
   */
  getCurrent() {
    return this.getCurrentParam();
  }
  /**
   * get ISheetSkeletonManagerParam from _currentSkeletonSearchParam
   * @returns
   */
  getCurrentParam() {
    return this._getSkeletonParam(this._sheetId);
  }
  /**
   * Get skeleton by sheetId
   * @param sheetId
   */
  getSkeleton(sheetId) {
    return this._getSkeleton(sheetId);
  }
  /**
   * Get SkeletonParam by sheetId
   * @param sheetId
   */
  getSkeletonParam(sheetId) {
    return this._getSkeletonParam(sheetId);
  }
  /**
   * @deprecated use `getSkeleton` instead.
   */
  getWorksheetSkeleton(sheetId) {
    return this.getSkeletonParam(sheetId);
  }
  // why ?? what does unitId for ??? no need unitId, this service is registered in render unit already.
  getUnitSkeleton(unitId, sheetId) {
    const param = this._getSkeletonParam(sheetId);
    if (param != null) {
      param.unitId = unitId;
    }
    return param;
  }
  /**
   * Command in COMMAND_LISTENER_SKELETON_CHANGE would cause setCurrent, see @packages/sheets-ui/src/controllers/render-controllers/sheet.render-controller.ts
   * @param searchParam
   */
  setCurrent(searchParam) {
    this._setCurrent(searchParam.sheetId);
  }
  setSkeletonParam(sheetId, skp) {
    this._sheetSkService.setSkeleton(skp.unitId, sheetId, skp.skeleton);
    this._sheetSkeletonParamStore.set(sheetId, skp);
  }
  _setCurrent(sheetId) {
    this._sheetId = sheetId;
    const skParam = this._getSkeletonParam(sheetId);
    const unitId = this._context.unitId;
    if (skParam != null) {
      this.reCalculate(skParam);
    } else {
      const workbook = this._context.unit;
      const worksheet = workbook.getSheetBySheetId(sheetId);
      if (worksheet == null) {
        return;
      }
      const scene = this._context.scene;
      const skeleton = this._buildSkeleton(worksheet, scene);
      this.setSkeletonParam(sheetId, {
        unitId,
        sheetId,
        skeleton,
        dirty: false
      });
    }
    const sheetSkeletonManagerParam = this._getSkeletonParam(sheetId);
    this._currentSkeletonBefore$.next(sheetSkeletonManagerParam);
    this._currentSkeleton$.next(sheetSkeletonManagerParam);
  }
  // @TODO why need this function? How about caller get skeleton and call sk.calculate()?
  reCalculate(param) {
    if (!param) {
      param = this.getCurrentParam();
    }
    if (param == null) {
      return;
    }
    if (param.dirty) {
      param.skeleton.makeDirty(true);
      param.dirty = false;
    }
    param.skeleton.calculate();
  }
  /**
   * Make param dirty, if param is dirty, then the skeleton will be makeDirty in _reCalculate()
   * @param searchParm
   * @param state
   */
  makeDirty(searchParm, state = true) {
    const param = this._getSkeletonParam(searchParm.sheetId);
    if (param == null) {
      return;
    }
    param.dirty = state;
  }
  /**
   * @deprecated Use function `ensureSkeleton` instead.
   * @param searchParam
   */
  getOrCreateSkeleton(searchParam) {
    return this.ensureSkeleton(searchParam.sheetId);
  }
  ensureSkeleton(sheetId) {
    const skeleton = this._getSkeletonParam(sheetId);
    if (skeleton) {
      return skeleton.skeleton;
    }
    const workbook = this._context.unit;
    const worksheet = workbook.getSheetBySheetId(sheetId);
    if (!worksheet) {
      return;
    }
    const newSkeleton = this._buildSkeleton(worksheet);
    this.setSkeletonParam(sheetId, {
      unitId: this._context.unitId,
      sheetId,
      skeleton: newSkeleton,
      dirty: false
    });
    return newSkeleton;
  }
  disposeSkeleton(sheetId) {
    const skParam = this.getSkeletonParam(sheetId);
    if (skParam) {
      skParam.skeleton.dispose();
      this._sheetSkeletonParamStore.delete(sheetId);
      this._sheetSkService.deleteSkeleton(skParam.unitId, sheetId);
    }
  }
  /** @deprecated Use function `attachRangeWithCoord` instead.  */
  attachRangeWithCoord(range) {
    const skeleton = this.getCurrentSkeleton();
    if (!skeleton) return null;
    return attachRangeWithCoord(skeleton, range);
  }
  _getSkeletonParam(sheetId) {
    const item = this._sheetSkeletonParamStore.get(sheetId);
    return item;
  }
  _getSkeleton(sheetId) {
    const param = this._getSkeletonParam(sheetId);
    return param ? param.skeleton : null;
  }
  _buildSkeleton(worksheet, _scene) {
    const spreadsheetSkeleton = this._injector.createInstance(
      SpreadsheetSkeleton,
      worksheet,
      this._context.unit.getStyles()
    );
    return spreadsheetSkeleton;
  }
  setColumnHeaderSize(render, sheetId, size) {
    var _a;
    if (!render) return;
    const skeleton = (_a = this.getWorksheetSkeleton(sheetId)) == null ? void 0 : _a.skeleton;
    if (!skeleton) return;
    skeleton.columnHeaderHeight = size;
    render.scene.getViewports()[0].top = size;
    render.scene.getViewport("viewColumnRight" /* VIEW_COLUMN_RIGHT */).setViewportSize({
      height: size
    });
    render.scene.getViewport("viewColumnLeft" /* VIEW_COLUMN_LEFT */).setViewportSize({
      height: size
    });
    render.scene.getViewport("viewRowBottom" /* VIEW_ROW_BOTTOM */).setViewportSize({
      top: size
    });
    render.scene.getViewport("viewRowTop" /* VIEW_ROW_TOP */).setViewportSize({
      top: size
    });
    render.scene.getViewport("viewLeftTop" /* VIEW_LEFT_TOP */).setViewportSize({
      height: size
    });
    const selectionService = render == null ? void 0 : render.with(SheetsSelectionsService);
    const selectionRenderService = render == null ? void 0 : render.with(ISheetSelectionRenderService);
    const currSelections = selectionService.getCurrentSelections();
    selectionRenderService.resetSelectionsByModelData(currSelections);
    const sheetSkeletonManagerParam = this.getUnitSkeleton(render.unitId, sheetId);
    if (sheetSkeletonManagerParam) {
      sheetSkeletonManagerParam.commandId = SetColumnHeaderHeightCommand.id;
      this._currentSkeleton$.next(sheetSkeletonManagerParam);
    }
  }
  setRowHeaderSize(render, sheetId, size) {
    var _a;
    const skeleton = (_a = this.getWorksheetSkeleton(sheetId)) == null ? void 0 : _a.skeleton;
    if (!render) return;
    if (!skeleton) return;
    skeleton.rowHeaderWidth = size;
    const originWidth = render.scene.getViewport("viewLeftTop" /* VIEW_LEFT_TOP */).width || 46;
    const deltaX = size - originWidth;
    const originLeftOfViewMain = render.scene.getViewports()[0].left;
    render.scene.getViewports()[0].left = originLeftOfViewMain + deltaX;
    render.scene.getViewport("viewRowBottom" /* VIEW_ROW_BOTTOM */).setViewportSize({
      width: size
    });
    render.scene.getViewport("viewRowTop" /* VIEW_ROW_TOP */).setViewportSize({
      width: size
    });
    render.scene.getViewport("viewColumnLeft" /* VIEW_COLUMN_LEFT */).setViewportSize({
      left: size
    });
    const prevLeft = render.scene.getViewport("viewColumnRight" /* VIEW_COLUMN_RIGHT */).left || 0;
    render.scene.getViewport("viewColumnRight" /* VIEW_COLUMN_RIGHT */).setViewportSize({
      left: prevLeft + deltaX
    });
    render.scene.getViewport("viewLeftTop" /* VIEW_LEFT_TOP */).setViewportSize({
      width: size
    });
    const selectionService = render == null ? void 0 : render.with(SheetsSelectionsService);
    const selectionRenderService = render == null ? void 0 : render.with(ISheetSelectionRenderService);
    const currSelections = selectionService.getCurrentSelections();
    selectionRenderService.resetSelectionsByModelData(currSelections);
    const sheetSkeletonManagerParam = this.getCurrent();
    if (sheetSkeletonManagerParam) {
      sheetSkeletonManagerParam.commandId = SetRowHeaderWidthCommand.id;
      this._currentSkeleton$.next(sheetSkeletonManagerParam);
    }
  }
};
SheetSkeletonManagerService = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, Inject(SheetSkeletonService))
], SheetSkeletonManagerService);

// ../packages/sheets-ui/src/controllers/config.schema.ts
var SHEETS_UI_PLUGIN_CONFIG_KEY = "sheets-ui.config";
var configSymbol = Symbol(SHEETS_UI_PLUGIN_CONFIG_KEY);
var defaultPluginConfig = {
  formulaBar: true,
  statusBarStatistic: true,
  maxAutoHeightCount: 1e3
};

// ../packages/sheets-ui/src/controllers/auto-height.controller.ts
var AFFECT_LAYOUT_STYLES = ["ff", "fs", "tr", "tb"];
var AutoHeightController = class extends Disposable {
  constructor(_renderManagerService, _sheetInterceptorService, _selectionManagerService, _univerInstanceService, _configService) {
    super();
    this._renderManagerService = _renderManagerService;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._selectionManagerService = _selectionManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._configService = _configService;
    this._initialize();
  }
  _getRangesScope(ranges) {
    let start;
    let end;
    for (const { startRow, endRow } of ranges) {
      start = start === void 0 ? startRow : Math.min(start, startRow);
      end = end === void 0 ? endRow : Math.max(end, endRow);
    }
    return end - start + 1;
  }
  getUndoRedoParamsOfAutoHeight(ranges, subUnitIdParam) {
    var _a;
    const { _univerInstanceService: univerInstanceService, _configService: configService } = this;
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const unitId = workbook.getUnitId();
    let worksheet = workbook.getActiveSheet();
    let subUnitId = worksheet.getSheetId();
    if (subUnitIdParam) {
      const target = getSheetCommandTarget(univerInstanceService, { unitId, subUnitId: subUnitIdParam });
      if (target) {
        worksheet = target.worksheet;
        subUnitId = worksheet.getSheetId();
      }
    }
    const sheetSkeletonService = this._renderManagerService.getRenderById(unitId).with(SheetSkeletonManagerService);
    const skeleton = sheetSkeletonService.ensureSkeleton(subUnitId);
    if (!skeleton) {
      return {
        redos: [],
        undos: []
      };
    }
    ;
    const config = configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY);
    let rangeList = ranges;
    if (!Array.isArray(ranges)) {
      if (ranges && ranges.startRow !== void 0 && ranges.startRow !== void 0) {
        rangeList = [ranges];
      } else {
        rangeList = [];
      }
    }
    const count = this._getRangesScope(rangeList);
    const maxLimit = (_a = config == null ? void 0 : config.maxAutoHeightCount) != null ? _a : 1e3;
    if (maxLimit < count) {
      return {
        redos: [],
        undos: []
      };
    }
    const rowsAutoHeightInfo = skeleton.calculateAutoHeightInRange(ranges);
    const redoParams = {
      subUnitId,
      unitId,
      rowsAutoHeightInfo
    };
    const undoParams = SetWorksheetRowAutoHeightMutationFactory(redoParams, worksheet);
    return {
      undos: [
        {
          id: SetWorksheetRowAutoHeightMutation.id,
          params: undoParams
        }
      ],
      redos: [
        {
          id: SetWorksheetRowAutoHeightMutation.id,
          params: redoParams
        }
      ]
    };
  }
  // eslint-disable-next-line max-lines-per-function
  _initialize() {
    const { _sheetInterceptorService: sheetInterceptorService, _selectionManagerService: selectionManagerService } = this;
    this.disposeWithMe(sheetInterceptorService.interceptCommand({
      getMutations: (command) => {
        if (command.id === SetRangeValuesCommand.id) {
          const params = command.params;
          return this.getUndoRedoParamsOfAutoHeight(params.range, params.subUnitId);
        }
        return {
          redos: [],
          undos: []
        };
      }
    }));
    this.disposeWithMe(sheetInterceptorService.interceptCommand({
      getMutations: (command) => {
        if (command.id !== SetWorksheetRowIsAutoHeightCommand.id) {
          return {
            redos: [],
            undos: []
          };
        }
        return this.getUndoRedoParamsOfAutoHeight(command.params.ranges, command.params.subUnitId);
      }
    }));
    this.disposeWithMe(sheetInterceptorService.interceptCommand({
      getMutations: (command) => {
        var _a, _b;
        if (command.id !== SetStyleCommand.id) {
          return {
            redos: [],
            undos: []
          };
        }
        if (!AFFECT_LAYOUT_STYLES.includes((_a = command.params) == null ? void 0 : _a.style.type)) {
          return {
            redos: [],
            undos: []
          };
        }
        const selections = (_b = selectionManagerService.getCurrentSelections()) == null ? void 0 : _b.map((s) => s.range);
        if (!(selections == null ? void 0 : selections.length)) {
          return {
            redos: [],
            undos: []
          };
        }
        return this.getUndoRedoParamsOfAutoHeight(selections, command.params.subUnitId);
      }
    }));
    this.disposeWithMe(sheetInterceptorService.interceptAfterCommand({
      getMutations: (command) => {
        if (command.id === MoveRangeCommand.id) {
          const params = command.params;
          return this.getUndoRedoParamsOfAutoHeight([params.fromRange, params.toRange]);
        }
        if (command.id === ReorderRangeCommand.id) {
          const params = command.params;
          return this.getUndoRedoParamsOfAutoHeight([params.range]);
        }
        return {
          redos: [],
          undos: []
        };
      }
    }));
  }
};
AutoHeightController = __decorateClass([
  __decorateParam(0, IRenderManagerService),
  __decorateParam(1, Inject(SheetInterceptorService)),
  __decorateParam(2, Inject(SheetsSelectionsService)),
  __decorateParam(3, Inject(IUniverInstanceService)),
  __decorateParam(4, IConfigService)
], AutoHeightController);

// ../packages/sheets-ui/src/controllers/utils/range-tools.ts
function discreteRangeToRange(discreteRange) {
  const { rows, cols } = discreteRange;
  return {
    startRow: rows[0],
    endRow: rows[rows.length - 1],
    startColumn: cols[0],
    endColumn: cols[cols.length - 1]
  };
}
function virtualizeDiscreteRanges(ranges) {
  let totalRows = [];
  let totalCols = [];
  const totalRanges = [];
  ranges.forEach((r) => {
    totalRows = totalRows.concat(r.rows);
    totalCols = totalCols.concat(r.cols);
  });
  totalRows = Array.from(new Set(totalRows)).sort((a2, b) => a2 - b);
  totalCols = Array.from(new Set(totalCols)).sort((a2, b) => a2 - b);
  ranges.forEach((r) => {
    totalRanges.push({
      startRow: totalRows.findIndex((row) => row === r.rows[0]),
      endRow: totalRows.findIndex((row) => row === r.rows[r.rows.length - 1]),
      startColumn: totalCols.findIndex((col) => col === r.cols[0]),
      endColumn: totalCols.findIndex((col) => col === r.cols[r.cols.length - 1])
    });
  });
  return {
    ranges: totalRanges,
    mapFunc: (row, col) => ({
      row: totalRows[row],
      col: totalCols[col]
    })
  };
}
function generateNullCellValueRowCol(range) {
  const cellValue = new ObjectMatrix();
  range.forEach((r) => {
    const { rows, cols } = r;
    rows.forEach((i) => {
      cols.forEach((j) => {
        cellValue.setValue(i, j, {
          v: null,
          p: null,
          f: null,
          si: null,
          custom: null
        });
      });
    });
  });
  return cellValue.getData();
}

// ../packages/sheets-ui/src/services/auto-fill/tools.ts
var chnNumChar = { \u96F6: 0, \u4E00: 1, \u4E8C: 2, \u4E09: 3, \u56DB: 4, \u4E94: 5, \u516D: 6, \u4E03: 7, \u516B: 8, \u4E5D: 9 };
var chnNumChar2 = ["\u96F6", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D"];
var chnUnitSection = ["", "\u4E07", "\u4EBF", "\u4E07\u4EBF", "\u4EBF\u4EBF"];
var chnUnitChar = ["", "\u5341", "\u767E", "\u5343"];
var chnNameValue = {
  \u5341: { value: 10, secUnit: false },
  \u767E: { value: 100, secUnit: false },
  \u5343: { value: 1e3, secUnit: false },
  \u4E07: { value: 1e4, secUnit: true },
  \u4EBF: { value: 1e8, secUnit: true }
};
function chineseToNumber(chnStr) {
  if (!chnStr) {
    return 0;
  }
  let rtn = 0;
  let section = 0;
  let number = 0;
  let secUnit = false;
  const str = chnStr.split("");
  for (let i = 0; i < str.length; i++) {
    const num = chnNumChar[str[i]];
    if (typeof num !== "undefined") {
      number = num;
      if (i === str.length - 1) {
        section += number;
      }
    } else {
      const obj = chnNameValue[str[i]];
      const unit = obj.value;
      secUnit = obj.secUnit;
      if (secUnit) {
        section = (section + number) * unit;
        rtn += section;
        section = 0;
      } else {
        section += number * unit;
      }
      number = 0;
    }
  }
  return rtn + section;
}
function sectionToChinese(section) {
  let strIns = "";
  let chnStr = "";
  let unitPos = 0;
  let zero = true;
  while (section > 0) {
    const v = section % 10;
    if (v === 0) {
      if (!zero) {
        zero = true;
        chnStr = chnNumChar2[v] + chnStr;
      }
    } else {
      zero = false;
      strIns = chnNumChar2[v];
      strIns += chnUnitChar[unitPos];
      chnStr = strIns + chnStr;
    }
    unitPos++;
    section = Math.floor(section / 10);
  }
  return chnStr;
}
function numberToChinese(num) {
  let unitPos = 0;
  let strIns = "";
  let chnStr = "";
  let needZero = false;
  if (num === 0) {
    return chnNumChar2[0];
  }
  while (num > 0) {
    const section = num % 1e4;
    if (needZero) {
      chnStr = chnNumChar2[0] + chnStr;
    }
    strIns = sectionToChinese(section);
    strIns += section !== 0 ? chnUnitSection[unitPos] : chnUnitSection[0];
    chnStr = strIns + chnStr;
    needZero = section < 1e3 && section > 0;
    num = Math.floor(num / 1e4);
    unitPos++;
  }
  return chnStr;
}
function isChnNumber(txt) {
  if (!txt) {
    return false;
  }
  let isChnNumber2 = true;
  if (txt) {
    if (txt.length === 1) {
      if (txt === "\u65E5" || txt in chnNumChar) {
        isChnNumber2 = true;
      } else {
        isChnNumber2 = false;
      }
    } else {
      const str = txt.split("");
      for (let i = 0; i < str.length; i++) {
        if (!(str[i] in chnNumChar || str[i] in chnNameValue)) {
          isChnNumber2 = false;
          break;
        }
      }
    }
  }
  return isChnNumber2;
}
function matchExtendNumber(txt) {
  if (!txt) {
    return {
      isExtendNumber: false
    };
  }
  const reg = /0|([1-9]+[0-9]*)/g;
  const isExtendNumber = reg.test(txt);
  if (isExtendNumber) {
    const match = txt.match(reg);
    if (match && match.length > 0) {
      const matchTxt = match[match.length - 1];
      const matchIndex = txt.lastIndexOf(matchTxt);
      const beforeTxt = txt.substr(0, matchIndex);
      const afterTxt = txt.substr(matchIndex + matchTxt.length);
      return {
        isExtendNumber: true,
        matchTxt: Number(matchTxt),
        beforeTxt,
        afterTxt
      };
    }
    return {
      isExtendNumber: false
    };
  }
  return {
    isExtendNumber
  };
}
function isChnWeek2(txt) {
  let isChnWeek22;
  if (txt.length === 2) {
    if (txt === "\u5468\u4E00" || txt === "\u5468\u4E8C" || txt === "\u5468\u4E09" || txt === "\u5468\u56DB" || txt === "\u5468\u4E94" || txt === "\u5468\u516D" || txt === "\u5468\u65E5") {
      isChnWeek22 = true;
    } else {
      isChnWeek22 = false;
    }
  } else {
    isChnWeek22 = false;
  }
  return isChnWeek22;
}
function isChnWeek3(txt) {
  let isChnWeek32;
  if (txt.length === 3) {
    if (txt === "\u661F\u671F\u4E00" || txt === "\u661F\u671F\u4E8C" || txt === "\u661F\u671F\u4E09" || txt === "\u661F\u671F\u56DB" || txt === "\u661F\u671F\u4E94" || txt === "\u661F\u671F\u516D" || txt === "\u661F\u671F\u65E5") {
      isChnWeek32 = true;
    } else {
      isChnWeek32 = false;
    }
  } else {
    isChnWeek32 = false;
  }
  return isChnWeek32;
}
function getLenS(indexArr, rsd) {
  let s = 0;
  for (let j = 0; j < indexArr.length; j++) {
    if (indexArr[j] < rsd) {
      s++;
    } else {
      break;
    }
  }
  return s;
}
function isEqualDiff(arr) {
  let diff = true;
  const step = arr[1] - arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] - arr[i - 1] !== step) {
      diff = false;
      break;
    }
  }
  return diff;
}
function getDataIndex(csLen, asLen, indexArr) {
  const obj = [];
  const num = Math.floor(asLen / csLen);
  const rsd = asLen % csLen;
  let sum = 0;
  if (num > 0) {
    for (let i = 0; i < num; i++) {
      for (let j = 0; j < indexArr.length; j++) {
        obj[indexArr[j] + i * csLen] = sum;
        sum++;
      }
    }
    for (let a2 = 0; a2 < indexArr.length; a2++) {
      if (indexArr[a2] < rsd) {
        obj[indexArr[a2] + csLen * num] = sum;
        sum++;
      } else {
        break;
      }
    }
  } else {
    for (let a2 = 0; a2 < indexArr.length; a2++) {
      if (indexArr[a2] < rsd) {
        obj[indexArr[a2]] = sum;
        sum++;
      } else {
        break;
      }
    }
  }
  return obj;
}
function fillCopy(data, len) {
  const applyData = [];
  for (let i = 1; i <= len; i++) {
    const index = (i - 1) % data.length;
    const d = Tools.deepClone(data[index]);
    removeCellCustom(d);
    applyData.push({
      v: null,
      s: null,
      p: null,
      f: null,
      si: null,
      t: null,
      ...d
    });
  }
  return applyData;
}
function fillCopyStyles(data, len) {
  var _a;
  const applyData = [];
  for (let i = 1; i <= len; i++) {
    const index = (i - 1) % data.length;
    const d = { s: (_a = data[index]) == null ? void 0 : _a.s };
    applyData.push(d);
  }
  return applyData;
}
function isEqualRatio(arr) {
  let ratio = true;
  const step = arr[1] / arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] / arr[i - 1] !== step) {
      ratio = false;
      break;
    }
  }
  return ratio;
}
function getXArr(len) {
  const xArr = [];
  for (let i = 1; i <= len; i++) {
    xArr.push(i);
  }
  return xArr;
}
function fillSeries(data, len, direction) {
  var _a, _b, _c, _d;
  const applyData = [];
  const dataNumArr = [];
  for (let j = 0; j < data.length; j++) {
    dataNumArr.push(Number((_a = data[j]) == null ? void 0 : _a.v));
  }
  if (data.length > 2 && isEqualRatio(dataNumArr)) {
    for (let i = 1; i <= len; i++) {
      const index = (i - 1) % data.length;
      const d = Tools.deepClone(data[index]);
      removeCellCustom(d);
      const num = Number((_b = data[data.length - 1]) == null ? void 0 : _b.v) * (Number((_c = data[1]) == null ? void 0 : _c.v) / Number((_d = data[0]) == null ? void 0 : _d.v)) ** i;
      if (d) {
        if (needsUpdateCellValue(d)) {
          d.v = num;
        }
        applyData.push(d);
      }
    }
  } else {
    const xArr = getXArr(data.length);
    for (let i = 1; i <= len; i++) {
      const index = (i - 1) % data.length;
      const d = Tools.deepClone(data[index]);
      removeCellCustom(d);
      const forward = direction === 2 /* DOWN */ || direction === 1 /* RIGHT */;
      const y = forecast(data.length + i, dataNumArr, xArr, forward);
      if (d) {
        if (needsUpdateCellValue(d)) {
          d.v = y;
        }
        applyData.push(d);
      }
    }
  }
  return applyData;
}
function forecast(x, yArr, xArr, forward = true) {
  function getAverage(arr) {
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
      sum += arr[i];
    }
    return sum / arr.length;
  }
  const ax = getAverage(xArr);
  const ay = getAverage(yArr);
  let sum_d = 0;
  let sum_n = 0;
  for (let j = 0; j < xArr.length; j++) {
    sum_d += (xArr[j] - ax) * (yArr[j] - ay);
    sum_n += (xArr[j] - ax) * (xArr[j] - ax);
  }
  let b;
  if (sum_n === 0) {
    b = forward ? 1 : -1;
  } else {
    b = sum_d / sum_n;
  }
  const a2 = ay - b * ax;
  return Math.round((a2 + b * x) * 1e5) / 1e5;
}
function fillExtendNumber(data, len, step) {
  var _a;
  const applyData = [];
  const reg = /0|([1-9]+[0-9]*)/g;
  for (let i = 1; i <= len; i++) {
    const index = (i - 1) % data.length;
    const d = Tools.deepClone(data[index]);
    removeCellCustom(d);
    const last = `${(_a = data[data.length - 1]) == null ? void 0 : _a.v}`;
    const match = last == null ? void 0 : last.match(reg);
    const lastTxt = match == null ? void 0 : match[match.length - 1];
    const num = Math.abs(Number(lastTxt) + step * i);
    if (!last || !lastTxt) continue;
    const lastIndex = last.lastIndexOf(lastTxt);
    const valueTxt = last.substr(0, lastIndex) + num.toString() + last.substr(lastIndex + lastTxt.length);
    if (d) {
      d.v = valueTxt;
      applyData.push(d);
    }
  }
  return applyData;
}
function fillChnWeek(data, len, step, weekType = 0) {
  var _a, _b;
  const keywordMap = [
    ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
    ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"],
    ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
  ];
  if (weekType >= keywordMap.length) return [];
  const keyword = keywordMap[weekType];
  const applyData = [];
  for (let i = 1; i <= len; i++) {
    const index = (i - 1) % data.length;
    const d = Tools.deepClone(data[index]);
    removeCellCustom(d);
    let num = 0;
    if (((_a = data[data.length - 1]) == null ? void 0 : _a.v) === keyword[0]) {
      num = 7 + step * i;
    } else {
      const last = `${(_b = data[data.length - 1]) == null ? void 0 : _b.v}`;
      if (last) {
        const txt = last.substr(last.length - 1, 1);
        num = chineseToNumber(txt) + step * i;
      }
    }
    if (num < 0) {
      num = Math.ceil(Math.abs(num) / 7) * 7 + num;
    }
    const rsd = num % 7;
    if (d) {
      d.v = keyword[rsd];
      applyData.push(d);
    }
  }
  return applyData;
}
function fillChnNumber(data, len, step) {
  var _a;
  const applyData = [];
  for (let i = 1; i <= len; i++) {
    const index = (i - 1) % data.length;
    const d = Tools.deepClone(data[index]);
    removeCellCustom(d);
    const formattedValue = `${(_a = data[data.length - 1]) == null ? void 0 : _a.v}`;
    const num = chineseToNumber(formattedValue) + step * i;
    let txt;
    if (num <= 0) {
      txt = "\u96F6";
    } else {
      txt = numberToChinese(num);
    }
    if (d) {
      d.v = txt;
      applyData.push(d);
    }
  }
  return applyData;
}
var LOOP_SERIES = {
  enWeek1: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  enWeek2: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  enMonth1: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  enMonth2: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  chnMonth1: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"],
  chnMonth2: ["\u6B63\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u814A\u6708"],
  chHour1: ["\u5B50", "\u4E11", "\u5BC5", "\u536F", "\u8FB0", "\u5DF3", "\u5348", "\u672A", "\u7533", "\u9149", "\u620C", "\u4EA5"],
  chHour2: ["\u5B50\u65F6", "\u4E11\u65F6", "\u5BC5\u65F6", "\u536F\u65F6", "\u8FB0\u65F6", "\u5DF3\u65F6", "\u5348\u65F6", "\u672A\u65F6", "\u7533\u65F6", "\u9149\u65F6", "\u620C\u65F6", "\u4EA5\u65F6"],
  chYear1: ["\u7532", "\u4E59", "\u4E19", "\u4E01", "\u620A", "\u5DF1", "\u5E9A", "\u8F9B", "\u58EC", "\u7678"],
  chSeason1: ["\u6625", "\u590F", "\u79CB", "\u51AC"],
  chSeason2: ["\u6625\u5B63", "\u590F\u5B63", "\u79CB\u5B63", "\u51AC\u5B63"]
};
function isLoopSeries(txt) {
  let isLoopSeries2 = false;
  Object.keys(LOOP_SERIES).forEach((key) => {
    if (LOOP_SERIES[key].includes(txt)) {
      isLoopSeries2 = true;
    }
  });
  return isLoopSeries2;
}
function getLoopSeriesInfo(txt) {
  let name = "";
  const series = [];
  Object.keys(LOOP_SERIES).forEach((key) => {
    if (LOOP_SERIES[key].includes(txt)) {
      name = key;
      series.push(...LOOP_SERIES[key]);
    }
  });
  return { name, series };
}
function fillLoopSeries(data, len, step, series) {
  var _a;
  const seriesLen = series.length;
  const applyData = [];
  for (let i = 1; i <= len; i++) {
    const index = (i - 1) % data.length;
    const d = Tools.deepClone(data[index]);
    removeCellCustom(d);
    const last = `${(_a = data[data.length - 1]) == null ? void 0 : _a.v}`;
    let num = series.indexOf(last) + step * i;
    if (num < 0) {
      num += Math.abs(step) * seriesLen;
    }
    const rsd = num % seriesLen;
    if (d) {
      d.v = series[rsd];
      applyData.push(d);
    }
  }
  return applyData;
}
function getAutoFillRepeatRange(sourceRange, targetRange) {
  const repeats = [];
  let direction;
  if (targetRange.startRow < sourceRange.startRow) {
    direction = 0 /* UP */;
  } else if (targetRange.endRow > sourceRange.endRow) {
    direction = 2 /* DOWN */;
  } else if (targetRange.startColumn < sourceRange.startColumn) {
    direction = 3 /* LEFT */;
  } else if (targetRange.endColumn > sourceRange.endColumn) {
    direction = 1 /* RIGHT */;
  } else {
    return [];
  }
  if (direction === 2 /* DOWN */ || direction === 0 /* UP */) {
    const sourceLength = sourceRange.endRow - sourceRange.startRow + 1;
    const targetLength = targetRange.endRow - targetRange.startRow + 1;
    const mod = Math.floor(targetLength / sourceLength);
    const rest = targetLength % sourceLength;
    const relativeRange = {
      startRow: 0,
      startColumn: 0,
      endRow: sourceRange.endRow - sourceRange.startRow,
      endColumn: sourceRange.endColumn - sourceRange.startColumn
    };
    if (direction === 2 /* DOWN */) {
      for (let i = 0; i < mod; i++) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow + (i + 1) * sourceLength,
            col: sourceRange.startColumn
          },
          relativeRange
        });
      }
      if (rest > 0) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow + (mod + 1) * sourceLength,
            col: sourceRange.startColumn
          },
          relativeRange: {
            startRow: 0,
            startColumn: 0,
            endRow: rest - 1,
            endColumn: sourceRange.endColumn - sourceRange.startColumn
          }
        });
      }
    } else {
      for (let i = 0; i < mod; i++) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow - (i + 1) * sourceLength,
            col: sourceRange.startColumn
          },
          relativeRange
        });
      }
      if (rest > 0) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow - (mod + 1) * sourceLength,
            col: sourceRange.startColumn
          },
          relativeRange: {
            startRow: sourceLength - rest,
            endRow: sourceLength - 1,
            startColumn: 0,
            endColumn: sourceRange.endColumn - sourceRange.startColumn
          }
        });
      }
    }
  }
  if (direction === 1 /* RIGHT */ || direction === 3 /* LEFT */) {
    const sourceLength = sourceRange.endColumn - sourceRange.startColumn + 1;
    const targetLength = targetRange.endColumn - targetRange.startColumn + 1;
    const mod = Math.floor(targetLength / sourceLength);
    const rest = targetLength % sourceLength;
    const relativeRange = {
      startRow: 0,
      startColumn: 0,
      endRow: sourceRange.endRow - sourceRange.startRow,
      endColumn: sourceRange.endColumn - sourceRange.startColumn
    };
    if (direction === 1 /* RIGHT */) {
      for (let i = 0; i < mod; i++) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow,
            col: sourceRange.startColumn + (i + 1) * sourceLength
          },
          relativeRange
        });
      }
      if (rest > 0) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow,
            col: sourceRange.startColumn + (mod + 1) * sourceLength
          },
          relativeRange: {
            startRow: 0,
            startColumn: 0,
            endRow: sourceRange.endRow - sourceRange.startRow,
            endColumn: rest - 1
          }
        });
      }
    } else {
      for (let i = 0; i < mod; i++) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow,
            col: sourceRange.startColumn - (i + 1) * sourceLength
          },
          relativeRange
        });
      }
      if (rest > 0) {
        repeats.push({
          repeatStartCell: {
            row: sourceRange.startRow,
            col: sourceRange.startColumn - (mod + 1) * sourceLength
          },
          relativeRange: {
            startRow: 0,
            startColumn: sourceLength - rest,
            endRow: sourceRange.endRow - sourceRange.startRow,
            endColumn: sourceLength - 1
          }
        });
      }
    }
  }
  return repeats;
}
function needsUpdateCellValue(cell) {
  if (isFormulaString(cell.f) || isFormulaId(cell.si)) {
    return false;
  }
  if (cell.t === 3 /* BOOLEAN */) {
    return false;
  }
  return true;
}
function removeCellCustom(cell) {
  if (cell && "custom" in cell) {
    delete cell.custom;
  }
}

// ../packages/sheets-ui/src/services/auto-fill/rules.ts
var dateRule = {
  type: "date" /* DATE */,
  priority: 1100,
  match: (cellData, accessor) => {
    var _a;
    if ((cellData == null ? void 0 : cellData.f) || (cellData == null ? void 0 : cellData.si)) {
      return false;
    }
    if ((typeof (cellData == null ? void 0 : cellData.v) === "number" || (cellData == null ? void 0 : cellData.t) === 2 /* NUMBER */) && cellData.s) {
      if (typeof cellData.s === "string") {
        const workbook = accessor.get(IUniverInstanceService).getFocusedUnit();
        const style = workbook.getStyles().get(cellData.s);
        const pattern = (_a = style == null ? void 0 : style.n) == null ? void 0 : _a.pattern;
        if (pattern) {
          return numfmt.getInfo(pattern).isDate;
        }
      } else if (cellData.s.n && numfmt.getInfo(cellData.s.n.pattern).isDate) {
        return true;
      }
    }
    return false;
  },
  isContinue: (prev, cur) => {
    if (prev.type === "date" /* DATE */) {
      return true;
    }
    return false;
  },
  applyFunctions: {
    ["SERIES" /* SERIES */]: (dataWithIndex, len, direction) => {
      const { data } = dataWithIndex;
      if (direction === 3 /* LEFT */ || direction === 0 /* UP */) {
        data.reverse();
        return fillSeries(data, len, direction).reverse();
      }
      return fillSeries(data, len, direction);
    }
  }
};
var numberRule = {
  type: "number" /* NUMBER */,
  priority: 1e3,
  match: (cellData) => typeof (cellData == null ? void 0 : cellData.v) === "number" || (cellData == null ? void 0 : cellData.t) === 2 /* NUMBER */,
  isContinue: (prev, cur) => {
    if (prev.type === "number" /* NUMBER */) {
      return true;
    }
    return false;
  },
  applyFunctions: {
    ["SERIES" /* SERIES */]: (dataWithIndex, len, direction) => {
      const { data } = dataWithIndex;
      if (direction === 3 /* LEFT */ || direction === 0 /* UP */) {
        data.reverse();
        return fillSeries(data, len, direction).reverse();
      }
      return fillSeries(data, len, direction);
    }
  }
};
var otherRule = {
  type: "other" /* OTHER */,
  priority: 0,
  match: () => true,
  isContinue: (prev, cur) => {
    if (prev.type === "other" /* OTHER */) {
      return true;
    }
    return false;
  }
};
var extendNumberRule = {
  type: "extendNumber" /* EXTEND_NUMBER */,
  priority: 900,
  match: (cellData) => matchExtendNumber(`${cellData == null ? void 0 : cellData.v}` || "").isExtendNumber,
  isContinue: (prev, cur) => {
    var _a;
    if (prev.type === "extendNumber" /* EXTEND_NUMBER */) {
      const { beforeTxt, afterTxt } = matchExtendNumber(`${(_a = prev.cellData) == null ? void 0 : _a.v}` || "");
      const { beforeTxt: curBeforeTxt, afterTxt: curAfterTxt } = matchExtendNumber(`${cur == null ? void 0 : cur.v}` || "");
      if (beforeTxt === curBeforeTxt && afterTxt === curAfterTxt) {
        return true;
      }
    }
    return false;
  },
  applyFunctions: {
    ["SERIES" /* SERIES */]: (dataWithIndex, len, direction) => {
      var _a;
      const { data } = dataWithIndex;
      const isReverse = direction === 0 /* UP */ || direction === 3 /* LEFT */;
      let step;
      if (data.length === 1) {
        step = isReverse ? -1 : 1;
        return reverseIfNeed(fillExtendNumber(data, len, step), isReverse);
      }
      const dataNumArr = [];
      for (let i = 0; i < data.length; i++) {
        const txt = `${(_a = data[i]) == null ? void 0 : _a.v}`;
        txt && dataNumArr.push(Number(matchExtendNumber(txt).matchTxt));
      }
      if (isReverse) {
        data.reverse();
        dataNumArr.reverse();
      }
      if (isEqualDiff(dataNumArr)) {
        step = dataNumArr[1] - dataNumArr[0];
        return reverseIfNeed(fillExtendNumber(data, len, step), isReverse);
      }
      return fillCopy(data, len);
    }
  }
};
var chnNumberRule = {
  type: "chnNumber" /* CHN_NUMBER */,
  priority: 830,
  match: (cellData) => {
    if (isChnNumber(`${cellData == null ? void 0 : cellData.v}` || "")) {
      return true;
    }
    return false;
  },
  isContinue: (prev, cur) => {
    if (prev.type === "chnNumber" /* CHN_NUMBER */) {
      return true;
    }
    return false;
  },
  applyFunctions: {
    ["SERIES" /* SERIES */]: (dataWithIndex, len, direction) => {
      var _a, _b, _c;
      const { data } = dataWithIndex;
      const isReverse = direction === 3 /* LEFT */ || direction === 0 /* UP */;
      if (data.length === 1) {
        const formattedValue = `${(_a = data[0]) == null ? void 0 : _a.v}`;
        let step;
        if (!isReverse) {
          step = 1;
        } else {
          step = -1;
        }
        if (formattedValue && (formattedValue === "\u65E5" || chineseToNumber(formattedValue) < 7)) {
          return reverseIfNeed(fillChnWeek(data, len, step), isReverse);
        }
        return reverseIfNeed(fillChnNumber(data, len, step), isReverse);
      }
      let hasWeek = false;
      for (let i = 0; i < data.length; i++) {
        const formattedValue = (_b = data[i]) == null ? void 0 : _b.v;
        if (formattedValue === "\u65E5") {
          hasWeek = true;
          break;
        }
      }
      const dataNumArr = [];
      let weekIndex = 0;
      for (let i = 0; i < data.length; i++) {
        const formattedValue = `${(_c = data[i]) == null ? void 0 : _c.v}`;
        if (formattedValue === "\u65E5") {
          if (i === 0) {
            dataNumArr.push(0);
          } else {
            weekIndex++;
            dataNumArr.push(weekIndex * 7);
          }
        } else if (hasWeek && chineseToNumber(formattedValue) > 0 && chineseToNumber(formattedValue) < 7) {
          dataNumArr.push(chineseToNumber(formattedValue) + weekIndex * 7);
        } else {
          dataNumArr.push(chineseToNumber(formattedValue));
        }
      }
      if (isReverse) {
        data.reverse();
        dataNumArr.reverse();
      }
      if (isEqualDiff(dataNumArr)) {
        if (hasWeek || dataNumArr[dataNumArr.length - 1] < 6 && dataNumArr[0] > 0 || dataNumArr[0] < 6 && dataNumArr[dataNumArr.length - 1] > 0) {
          const step2 = dataNumArr[1] - dataNumArr[0];
          return reverseIfNeed(fillChnWeek(data, len, step2), isReverse);
        }
        const step = dataNumArr[1] - dataNumArr[0];
        return reverseIfNeed(fillChnNumber(data, len, step), isReverse);
      }
      return fillCopy(data, len);
    }
  }
};
var chnWeek2Rule = {
  type: "chnWeek2" /* CHN_WEEK2 */,
  priority: 820,
  match: (cellData) => {
    if (isChnWeek2(`${cellData == null ? void 0 : cellData.v}` || "")) {
      return true;
    }
    return false;
  },
  isContinue: (prev, cur) => prev.type === "chnWeek2" /* CHN_WEEK2 */,
  applyFunctions: {
    ["SERIES" /* SERIES */]: (dataWithIndex, len, direction) => {
      var _a;
      const { data } = dataWithIndex;
      const isReverse = direction === 3 /* LEFT */ || direction === 0 /* UP */;
      if (data.length === 1) {
        let step;
        if (!isReverse) {
          step = 1;
        } else {
          step = -1;
        }
        return reverseIfNeed(fillChnWeek(data, len, step, 1), isReverse);
      }
      const dataNumArr = [];
      let weekIndex = 0;
      for (let i = 0; i < data.length; i++) {
        const formattedValue = `${(_a = data[i]) == null ? void 0 : _a.v}`;
        const lastTxt = formattedValue == null ? void 0 : formattedValue.substr(formattedValue.length - 1, 1);
        if (formattedValue === "\u5468\u65E5") {
          if (i === 0) {
            dataNumArr.push(0);
          } else {
            weekIndex++;
            dataNumArr.push(weekIndex * 7);
          }
        } else {
          dataNumArr.push(chineseToNumber(lastTxt) + weekIndex * 7);
        }
      }
      if (isReverse) {
        data.reverse();
        dataNumArr.reverse();
      }
      if (isEqualDiff(dataNumArr)) {
        const step = dataNumArr[1] - dataNumArr[0];
        return reverseIfNeed(fillChnWeek(data, len, step, 1), isReverse);
      }
      return fillCopy(data, len);
    }
  }
};
var chnWeek3Rule = {
  type: "chnWeek3" /* CHN_WEEK3 */,
  priority: 810,
  match: (cellData) => isChnWeek3(`${cellData == null ? void 0 : cellData.v}` || ""),
  isContinue: (prev, cur) => prev.type === "chnWeek3" /* CHN_WEEK3 */,
  applyFunctions: {
    ["SERIES" /* SERIES */]: (dataWithIndex, len, direction) => {
      var _a;
      const { data } = dataWithIndex;
      const isReverse = direction === 3 /* LEFT */ || direction === 0 /* UP */;
      if (data.length === 1) {
        let step;
        if (!isReverse) {
          step = 1;
        } else {
          step = -1;
        }
        return reverseIfNeed(fillChnWeek(data, len, step, 2), isReverse);
      }
      const dataNumArr = [];
      let weekIndex = 0;
      for (let i = 0; i < data.length; i++) {
        const formattedValue = `${(_a = data[i]) == null ? void 0 : _a.v}`;
        if (formattedValue) {
          const lastTxt = formattedValue.substr(formattedValue.length - 1, 1);
          if (formattedValue === "\u661F\u671F\u65E5") {
            if (i === 0) {
              dataNumArr.push(0);
            } else {
              weekIndex++;
              dataNumArr.push(weekIndex * 7);
            }
          } else {
            dataNumArr.push(chineseToNumber(lastTxt) + weekIndex * 7);
          }
        }
      }
      if (isReverse) {
        data.reverse();
        dataNumArr.reverse();
      }
      if (isEqualDiff(dataNumArr)) {
        const step = dataNumArr[1] - dataNumArr[0];
        return reverseIfNeed(fillChnWeek(data, len, step, 2), isReverse);
      }
      return fillCopy(data, len);
    }
  }
};
var loopSeriesRule = {
  type: "loopSeries" /* LOOP_SERIES */,
  priority: 800,
  match: (cellData) => isLoopSeries(`${cellData == null ? void 0 : cellData.v}` || ""),
  isContinue: (prev, cur) => {
    var _a;
    if (prev.type === "loopSeries" /* LOOP_SERIES */) {
      return getLoopSeriesInfo(`${(_a = prev.cellData) == null ? void 0 : _a.v}` || "").name === getLoopSeriesInfo(`${cur == null ? void 0 : cur.v}` || "").name;
    }
    return false;
  },
  applyFunctions: {
    ["SERIES" /* SERIES */]: (dataWithIndex, len, direction) => {
      var _a, _b;
      const { data } = dataWithIndex;
      const isReverse = direction === 3 /* LEFT */ || direction === 0 /* UP */;
      const { series } = getLoopSeriesInfo(`${(_a = data[0]) == null ? void 0 : _a.v}` || "");
      if (data.length === 1) {
        let step;
        if (!isReverse) {
          step = 1;
        } else {
          step = -1;
        }
        return reverseIfNeed(fillLoopSeries(data, len, step, series), isReverse);
      }
      const dataNumArr = [];
      let cycleIndex = 0;
      for (let i = 0; i < data.length; i++) {
        const formattedValue = `${(_b = data[i]) == null ? void 0 : _b.v}`;
        if (formattedValue) {
          if (formattedValue === series[0]) {
            if (i === 0) {
              dataNumArr.push(0);
            } else {
              cycleIndex++;
              dataNumArr.push(cycleIndex * series.length);
            }
          } else {
            dataNumArr.push(series.indexOf(formattedValue) + cycleIndex * 7);
          }
        }
      }
      if (isReverse) {
        data.reverse();
        dataNumArr.reverse();
      }
      if (isEqualDiff(dataNumArr)) {
        const step = dataNumArr[1] - dataNumArr[0];
        return reverseIfNeed(fillLoopSeries(data, len, step, series), isReverse);
      }
      return fillCopy(data, len);
    }
  }
};
function reverseIfNeed(data, reverse) {
  return reverse ? data.reverse() : data;
}

// ../packages/sheets-ui/src/services/auto-fill/auto-fill.service.ts
var AutoFillService = class extends Disposable {
  constructor(_commandService, _undoRedoService, _renderManagerService, _univerInstanceService, _selectionManagerService, _injector) {
    super();
    this._commandService = _commandService;
    this._undoRedoService = _undoRedoService;
    this._renderManagerService = _renderManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._selectionManagerService = _selectionManagerService;
    this._injector = _injector;
    __publicField(this, "_rules", []);
    __publicField(this, "_hooks", []);
    __publicField(this, "_applyType$", new BehaviorSubject("SERIES" /* SERIES */));
    __publicField(this, "_isFillingStyle", true);
    __publicField(this, "_prevUndos", []);
    __publicField(this, "_autoFillLocation$", new BehaviorSubject(null));
    __publicField(this, "autoFillLocation$", this._autoFillLocation$.asObservable());
    __publicField(this, "_showMenu$", new BehaviorSubject(false));
    __publicField(this, "showMenu$", this._showMenu$.asObservable());
    __publicField(this, "_direction", 2 /* DOWN */);
    __publicField(this, "applyType$", this._applyType$.asObservable());
    __publicField(this, "_menu$", new BehaviorSubject([
      {
        label: "autoFill.copy",
        value: "COPY" /* COPY */,
        disable: false
      },
      {
        label: "autoFill.series",
        value: "SERIES" /* SERIES */,
        disable: false
      },
      {
        label: "autoFill.formatOnly",
        value: "ONLY_FORMAT" /* ONLY_FORMAT */,
        disable: false
      },
      {
        label: "autoFill.noFormat",
        value: "NO_FORMAT" /* NO_FORMAT */,
        disable: false
      }
    ]));
    __publicField(this, "menu$", this._menu$.asObservable());
    this._init();
  }
  _init() {
    this._rules = [
      dateRule,
      numberRule,
      extendNumberRule,
      chnNumberRule,
      chnWeek2Rule,
      chnWeek3Rule,
      loopSeriesRule,
      otherRule
    ].sort((a2, b) => b.priority - a2.priority);
    this._isFillingStyle = true;
  }
  _getOneByPriority(items) {
    if (items.length <= 0) {
      return [];
    }
    const maxPriority = items.reduce((maxItem, currentItem) => {
      return (currentItem.priority || 0) > (maxItem.priority || 0) ? currentItem : maxItem;
    }, items[0]);
    return [maxPriority];
  }
  // a cache to undo commands of last apply-type
  _initPrevUndo() {
    this._prevUndos = [];
  }
  // eslint-disable-next-line max-lines-per-function
  async triggerAutoFill(unitId, subUnitId, source, selection) {
    var _a;
    if (source.startColumn === selection.startColumn && source.startRow === selection.startRow && source.endColumn === selection.endColumn && source.endRow === selection.endRow) {
      return false;
    }
    if (selection.endColumn < source.endColumn && selection.endColumn > source.startColumn) {
      return this._commandService.executeCommand(AutoClearContentCommand.id, {
        clearRange: {
          startRow: selection.startRow,
          endRow: selection.endRow,
          startColumn: selection.endColumn + 1,
          endColumn: source.endColumn
        },
        selectionRange: selection
      });
    }
    if (selection.endRow < source.endRow && selection.endRow > source.startRow) {
      return this._commandService.executeCommand(AutoClearContentCommand.id, {
        clearRange: {
          startRow: selection.endRow + 1,
          endRow: source.endRow,
          startColumn: selection.startColumn,
          endColumn: selection.endColumn
        },
        selectionRange: selection
      });
    }
    const target = {
      startRow: selection.startRow,
      endRow: selection.endRow,
      startColumn: selection.startColumn,
      endColumn: selection.endColumn
    };
    let direction = null;
    if (selection.startRow < source.startRow) {
      direction = 0 /* UP */;
      target.endRow = source.startRow - 1;
    } else if (selection.endRow > source.endRow) {
      direction = 2 /* DOWN */;
      target.startRow = source.endRow + 1;
    } else if (selection.startColumn < source.startColumn) {
      direction = 3 /* LEFT */;
      target.endColumn = source.startColumn - 1;
    } else if (selection.endColumn > source.endColumn) {
      direction = 1 /* RIGHT */;
      target.startColumn = source.endColumn + 1;
    } else {
      return false;
    }
    this.direction = direction;
    const autoFillSource = this._injector.invoke((accessor) => rangeToDiscreteRange(source, accessor));
    const autoFillTarget = this._injector.invoke((accessor) => rangeToDiscreteRange(target, accessor));
    if (!autoFillSource || !autoFillTarget) {
      return false;
    }
    this.autoFillLocation = {
      source: autoFillSource,
      target: autoFillTarget,
      unitId,
      subUnitId
    };
    const preferTypes = [];
    const activeHooks = this.getActiveHooks();
    activeHooks.forEach((hook) => {
      var _a2;
      const type = (_a2 = hook == null ? void 0 : hook.onBeforeFillData) == null ? void 0 : _a2.call(hook, { source: autoFillSource, target: autoFillTarget, unitId, subUnitId }, direction);
      if (type) {
        preferTypes.unshift(type);
      }
    });
    this._initPrevUndo();
    for (let i = 0; i < preferTypes.length; i++) {
      const menuItem = this.menu.find((m) => m.value === preferTypes[i]);
      if (menuItem && !menuItem.disable) {
        return this.fillData(preferTypes[i]);
      }
    }
    const first = (_a = this.menu.find((m) => m.disable === false)) == null ? void 0 : _a.value;
    if (first) {
      return this.fillData(first);
    }
    return false;
  }
  addHook(hook) {
    if (this._hooks.find((h) => h.id === hook.id)) {
      throw new Error(`Add hook failed, hook id '${hook.id}' already exist!`);
    }
    if (hook.priority === void 0) {
      hook.priority = 0;
    }
    if (hook.type === void 0) {
      hook.type = "APPEND" /* Append */;
    }
    this._hooks.push(hook);
    return toDisposable(() => {
      const index = this._hooks.findIndex((item) => item === hook);
      if (index > -1) {
        this._hooks.splice(index, 1);
      }
    });
  }
  registerRule(rule) {
    if (this._rules.find((r) => r.type === rule.type)) {
      throw new Error(`Registry rule failed, type '${rule.type}' already exist!`);
    }
    const index = this._rules.findIndex((r) => r.priority < rule.priority);
    this._rules.splice(index === -1 ? this._rules.length : index, 0, rule);
  }
  getRules() {
    return this._rules;
  }
  getAllHooks() {
    return this._hooks;
  }
  getActiveHooks() {
    const { source, target, unitId, subUnitId } = this.autoFillLocation || {};
    if (!source || !target || !unitId || !subUnitId) {
      return [];
    }
    const enabledHooks = this._hooks.filter(
      (h) => {
        var _a;
        return !((_a = h.disable) == null ? void 0 : _a.call(h, { source, target, unitId, subUnitId }, this._direction, this.applyType)) === true;
      }
    );
    const onlyHooks = enabledHooks.filter((h) => h.type === "ONLY" /* Only */);
    if (onlyHooks.length > 0) {
      return this._getOneByPriority(onlyHooks);
    }
    const defaultHooks = this._getOneByPriority(enabledHooks.filter((h) => h.type === "DEFAULT" /* Default */));
    const appendHooks = enabledHooks.filter((h) => h.type === "APPEND" /* Append */) || [];
    return [...defaultHooks, ...appendHooks];
  }
  get applyType() {
    return this._applyType$.getValue();
  }
  set applyType(type) {
    this._applyType$.next(type);
  }
  get menu() {
    return this._menu$.getValue();
  }
  get direction() {
    return this._direction;
  }
  set direction(direction) {
    this._direction = direction;
  }
  isFillingStyle() {
    return this._isFillingStyle;
  }
  setFillingStyle(isFillingStyle) {
    this._isFillingStyle = isFillingStyle;
  }
  get autoFillLocation() {
    return this._autoFillLocation$.getValue();
  }
  set autoFillLocation(location) {
    this._autoFillLocation$.next(location);
  }
  setDisableApplyType(type, disable) {
    this._menu$.next(
      this._menu$.getValue().map((item) => {
        if (item.value === type) {
          return {
            ...item,
            disable
          };
        }
        return item;
      })
    );
  }
  setShowMenu(show) {
    this._showMenu$.next(show);
  }
  // eslint-disable-next-line max-lines-per-function
  fillData(applyType) {
    var _a, _b, _c;
    this.applyType = applyType;
    const { source, target, unitId = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getUnitId(), subUnitId = (_a = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getActiveSheet()) == null ? void 0 : _a.getSheetId() } = this.autoFillLocation || {};
    if (!source || !target || !unitId || !subUnitId) {
      return false;
    }
    const direction = this.direction;
    if (this._prevUndos.length > 0) {
      this._prevUndos.forEach((undo) => {
        this._commandService.syncExecuteCommand(undo.id, undo.params);
      });
    }
    this._prevUndos = [];
    const selection = Rectangle.union(discreteRangeToRange(source), discreteRangeToRange(target));
    const activeHooks = this.getActiveHooks();
    const workbook = this._univerInstanceService.getUnit(unitId, O.UNIVER_SHEET);
    this._commandService.syncExecuteCommand(SetSelectionsOperation.id, {
      selections: [
        {
          primary: { ...(_c = (_b = this._selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _b.primary) != null ? _c : selection },
          range: {
            ...selection,
            rangeType: 0 /* NORMAL */
          }
        }
      ],
      unitId,
      subUnitId
    });
    const undos = [];
    const redos = [];
    activeHooks.forEach((hook) => {
      var _a2;
      const { undos: hookUndos, redos: hookRedos } = ((_a2 = hook.onFillData) == null ? void 0 : _a2.call(hook, { source, target, unitId, subUnitId }, direction, applyType)) || {};
      if (hookUndos) {
        undos.push(...hookUndos);
      }
      if (hookRedos) {
        redos.push(...hookRedos);
      }
    });
    const result = redos.every((m) => this._commandService.syncExecuteCommand(m.id, m.params));
    const autoHeightRanges = [];
    if (applyType !== "NO_FORMAT" /* NO_FORMAT */) {
      redos.forEach((m) => {
        if (m.id === SetRangeValuesMutation.id) {
          const { cellValue } = m.params;
          const matrix = new ObjectMatrix(cellValue);
          matrix.forValue((row, col, value) => {
            const style = Object.keys(workbook.getStyles().get(value == null ? void 0 : value.s) || {});
            if ((value == null ? void 0 : value.p) || style.length && AFFECT_LAYOUT_STYLES.some((s) => style.includes(s))) {
              autoHeightRanges.push({ startRow: row, endRow: row, startColumn: col, endColumn: col });
            }
          });
        }
      });
    }
    const autoHeightUndoRedos = this._getAutoHeightUndoRedos(unitId, subUnitId, autoHeightRanges);
    const autoHeightResult = autoHeightUndoRedos.redos.every((m) => this._commandService.syncExecuteCommand(m.id, m.params));
    if (autoHeightResult) {
      undos.push(...autoHeightUndoRedos.undos);
      redos.push(...autoHeightUndoRedos.redos);
    }
    if (result) {
      this._prevUndos = undos;
      this._undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos,
        redoMutations: redos
      });
    }
    activeHooks.forEach((hook) => {
      var _a2;
      (_a2 = hook.onAfterFillData) == null ? void 0 : _a2.call(hook, { source, target, unitId, subUnitId }, direction, applyType);
    });
    this.setShowMenu(true);
    return true;
  }
  _getAutoHeightUndoRedos(unitId, subUnitId, ranges) {
    var _a, _b;
    const sheetSkeletonService = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(SheetSkeletonManagerService);
    const skeleton = (_b = sheetSkeletonService == null ? void 0 : sheetSkeletonService.getCurrentParam()) == null ? void 0 : _b.skeleton;
    if (!skeleton) return { redos: [], undos: [] };
    const rowsAutoHeightInfo = skeleton.calculateAutoHeightInRange(ranges);
    const redoParams = { subUnitId, unitId, rowsAutoHeightInfo };
    const worksheet = skeleton.worksheet;
    const undoParams = SetWorksheetRowAutoHeightMutationFactory(redoParams, worksheet);
    return {
      undos: [{ id: SetWorksheetRowAutoHeightMutation.id, params: undoParams }],
      redos: [{ id: SetWorksheetRowAutoHeightMutation.id, params: redoParams }]
    };
  }
};
AutoFillService = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IUndoRedoService),
  __decorateParam(2, IRenderManagerService),
  __decorateParam(3, Inject(IUniverInstanceService)),
  __decorateParam(4, Inject(SheetsSelectionsService)),
  __decorateParam(5, Inject(Injector))
], AutoFillService);
var IAutoFillService = createIdentifier("univer.auto-fill-service");

// ../packages/sheets-ui/src/commands/commands/auto-fill.command.ts
var AutoFillCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.auto-fill",
  handler: async (accessor, params) => {
    const autoFillService = accessor.get(IAutoFillService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const { sourceRange, targetRange } = params;
    const commandTarget = getSheetCommandTarget(univerInstanceService);
    if (!commandTarget) return false;
    const { subUnitId, unitId } = commandTarget;
    return autoFillService.triggerAutoFill(unitId, subUnitId, sourceRange, targetRange);
  }
};
var AutoClearContentCommand = {
  id: "sheet.command.auto-clear-content",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    const { clearRange, selectionRange } = params;
    const clearMutationParams = {
      subUnitId,
      unitId,
      cellValue: generateNullCellValue([clearRange])
    };
    const undoClearMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      clearMutationParams
    );
    const { startColumn, startRow } = selectionRange;
    const param = {
      selections: [
        {
          primary: {
            startColumn,
            startRow,
            endColumn: startColumn,
            endRow: startRow,
            actualRow: startRow,
            actualColumn: startColumn,
            isMerged: false,
            isMergedMainCell: false
          },
          range: {
            ...selectionRange
          }
        }
      ],
      unitId,
      subUnitId
    };
    commandService.executeCommand(SetSelectionsOperation.id, param);
    const result = commandService.syncExecuteCommand(SetRangeValuesMutation.id, clearMutationParams);
    if (result) {
      const afterInterceptors = sheetInterceptorService.afterCommandExecute({
        id: SetRangeValuesMutation.id,
        params: clearMutationParams
      });
      sequenceExecute(afterInterceptors.redos, commandService);
      undoRedoService.pushUndoRedo({
        // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
        // Hooks can be used to hook the code of external controllers to add new actions.
        unitID: unitId,
        undoMutations: [{ id: SetRangeValuesMutation.id, params: undoClearMutationParams }, ...afterInterceptors.undos],
        redoMutations: [{ id: SetRangeValuesMutation.id, params: clearMutationParams }, ...afterInterceptors.redos]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets-ui/src/commands/commands/delete-range-move-left-confirm.command.ts
var DeleteRangeMoveLeftConfirmCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delete-range-move-left-confirm",
  handler: async (accessor) => {
    const confirmService = accessor.get(IConfirmService);
    const commandService = accessor.get(ICommandService);
    const localeService = accessor.get(LocaleService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selection = selectionManagerService.getCurrentSelections();
    if (!selection) {
      return false;
    }
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    let range = selection[0].range;
    if (!range) {
      return false;
    }
    range = { ...range, endColumn: worksheet.getColumnCount() - 1 };
    const getRowLength = (range2) => range2.endRow - range2.startRow;
    const mergeData = worksheet.getMergeData().find((mergeRange) => {
      const interSectedRange = Rectangle.getIntersects(mergeRange, range);
      return interSectedRange ? getRowLength(mergeRange) > getRowLength(interSectedRange) : false;
    });
    if (!mergeData) {
      return commandService.executeCommand(DeleteRangeMoveLeftCommand.id);
    }
    const result = await confirmService.confirm({
      id: DeleteRangeMoveLeftConfirmCommand.id,
      title: { title: localeService.t("merge.confirm.waring") },
      children: { title: localeService.t("merge.confirm.dismantleMergeCellWaring") },
      cancelText: localeService.t("button.cancel"),
      confirmText: localeService.t("button.confirm")
    });
    if (result) {
      return commandService.executeCommand(DeleteRangeMoveLeftCommand.id);
    }
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/delete-range-move-up-confirm.command.ts
var DeleteRangeMoveUpConfirmCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delete-range-move-up-confirm",
  handler: async (accessor) => {
    const confirmService = accessor.get(IConfirmService);
    const commandService = accessor.get(ICommandService);
    const localeService = accessor.get(LocaleService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selection = selectionManagerService.getCurrentSelections();
    if (!selection) return false;
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    let range = selection[0].range;
    if (!range) return false;
    range = { ...range, endRow: worksheet.getRowCount() - 1 };
    for (let i = range.startRow; i <= range.endRow; i++) {
      if (worksheet.getRowFiltered(i)) {
        const result2 = await confirmService.confirm({
          id: DeleteRangeMoveUpConfirmCommand.id,
          title: { title: localeService.t("filter.confirm.error") },
          children: { title: localeService.t("filter.confirm.notAllowedToInsertRange") },
          confirmText: localeService.t("button.confirm")
        });
        if (result2) {
          return false;
        }
      }
    }
    const getColLength = (range2) => range2.endColumn - range2.startColumn;
    const mergeData = worksheet.getMergeData().find((mergeRange) => {
      const interSectedRange = Rectangle.getIntersects(mergeRange, range);
      return interSectedRange ? getColLength(mergeRange) > getColLength(interSectedRange) : false;
    });
    if (!mergeData) {
      return commandService.executeCommand(DeleteRangeMoveUpCommand.id);
    }
    const result = await confirmService.confirm({
      id: DeleteRangeMoveUpConfirmCommand.id,
      title: { title: localeService.t("merge.confirm.waring") },
      children: { title: localeService.t("merge.confirm.dismantleMergeCellWaring") },
      cancelText: localeService.t("button.cancel"),
      confirmText: localeService.t("button.confirm")
    });
    if (result) {
      return commandService.executeCommand(DeleteRangeMoveUpCommand.id);
    }
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/hide-row-col-confirm.command.ts
var HideRowConfirmCommand = {
  id: "sheet.command.hide-row-confirm",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    var _a;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const ranges = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range);
    if (!(ranges == null ? void 0 : ranges.length)) return false;
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    const allRowRanges = worksheet.getVisibleRows();
    if (isAllRowsCovered(allRowRanges, ranges)) {
      const confirmService = accessor.get(IConfirmService);
      const localeService = accessor.get(LocaleService);
      await confirmService.confirm({
        id: "sheet.confirm.hide-row",
        title: {
          title: localeService.t("info.problem")
        },
        children: { title: localeService.t("rightClick.hideAllRowsAlert") },
        cancelText: localeService.t("button.cancel"),
        confirmText: localeService.t("button.confirm")
      });
      return false;
    }
    await commandService.executeCommand(SetRowHiddenCommand.id);
    return true;
  }
};
var HideColConfirmCommand = {
  id: "sheet.command.hide-col-confirm",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    var _a;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const ranges = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range);
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    const allColumnRanges = worksheet.getVisibleCols();
    if (isAllColumnsCovered(allColumnRanges, ranges)) {
      const confirmService = accessor.get(IConfirmService);
      const localeService = accessor.get(LocaleService);
      await confirmService.confirm({
        id: "sheet.confirm.hide-col",
        title: {
          title: localeService.t("info.problem")
        },
        children: { title: localeService.t("rightClick.hideAllColumnsAlert") },
        cancelText: localeService.t("button.cancel"),
        confirmText: localeService.t("button.confirm")
      });
      return false;
    }
    await commandService.executeCommand(SetColHiddenCommand.id);
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/inline-format.command.ts
var SetRangeBoldCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-bold",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatBoldCommand.id);
    }
    return commandService.executeCommand(SetBoldCommand.id);
  }
};
var SetRangeItalicCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-italic",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatItalicCommand.id);
    }
    return commandService.executeCommand(SetItalicCommand.id);
  }
};
var SetRangeUnderlineCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-underline",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatUnderlineCommand.id);
    }
    return commandService.executeCommand(SetUnderlineCommand.id);
  }
};
var SetRangeStrickThroughCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-stroke",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatStrikethroughCommand.id);
    }
    return commandService.executeCommand(SetStrikeThroughCommand.id);
  }
};
var SetRangeSubscriptCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-subscript",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatSubscriptCommand.id);
    }
    return false;
  }
};
var SetRangeSuperscriptCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-superscript",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatSuperscriptCommand.id);
    }
    return false;
  }
};
var SetRangeFontSizeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-fontsize",
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatFontSizeCommand.id, params);
    }
    return commandService.executeCommand(SetFontSizeCommand.id, params);
  }
};
var SetRangeFontFamilyCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-font-family",
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatFontFamilyCommand.id, params);
    }
    return commandService.executeCommand(SetFontFamilyCommand.id, params);
  }
};
var SetRangeTextColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-text-color",
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatTextColorCommand.id, params);
    }
    return commandService.executeCommand(SetTextColorCommand.id, params);
  }
};
var ResetRangeTextColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.reset-range-text-color",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    const contextService = accessor.get(IContextService);
    const isCellEditorFocus = contextService.getContextValue(EDITOR_ACTIVATED);
    const themeService = accessor.get(ThemeService);
    if (isCellEditorFocus) {
      return commandService.executeCommand(SetInlineFormatTextColorCommand.id, { value: null });
    }
    return commandService.executeCommand(SetTextColorCommand.id, { value: themeService.getCurrentTheme().textColor });
  }
};

// ../packages/sheets-ui/src/commands/commands/insert-range-move-down-confirm.command.ts
var InsertRangeMoveDownConfirmCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-range-move-down-confirm",
  handler: async (accessor) => {
    const confirmService = accessor.get(IConfirmService);
    const commandService = accessor.get(ICommandService);
    const localeService = accessor.get(LocaleService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selection = selectionManagerService.getCurrentSelections();
    if (!selection) {
      return false;
    }
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    let range = selection[0].range;
    if (!range) {
      return false;
    }
    range = { ...range, endRow: worksheet.getRowCount() - 1 };
    for (let i = range.startRow; i <= range.endRow; i++) {
      if (worksheet.getRowFiltered(i)) {
        const result2 = await confirmService.confirm({
          id: InsertRangeMoveDownConfirmCommand.id,
          title: { title: localeService.t("filter.confirm.error") },
          children: { title: localeService.t("filter.confirm.notAllowedToInsertRange") },
          confirmText: localeService.t("button.confirm")
        });
        if (result2) {
          return false;
        }
      }
    }
    const getColLength = (range2) => range2.endColumn - range2.startColumn;
    const mergeData = worksheet.getMergeData().find((mergeRange) => {
      const interSectedRange = Rectangle.getIntersects(mergeRange, range);
      return interSectedRange ? getColLength(mergeRange) > getColLength(interSectedRange) : false;
    });
    if (!mergeData) {
      return commandService.executeCommand(InsertRangeMoveDownCommand.id);
    }
    const result = await confirmService.confirm({
      id: InsertRangeMoveDownConfirmCommand.id,
      title: { title: localeService.t("merge.confirm.waring") },
      children: { title: localeService.t("merge.confirm.dismantleMergeCellWaring") },
      cancelText: localeService.t("button.cancel"),
      confirmText: localeService.t("button.confirm")
    });
    if (result) {
      return commandService.executeCommand(InsertRangeMoveDownCommand.id);
    }
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/insert-range-move-right-confirm.command.ts
var InsertRangeMoveRightConfirmCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-range-move-right-confirm",
  handler: async (accessor) => {
    const confirmService = accessor.get(IConfirmService);
    const commandService = accessor.get(ICommandService);
    const localeService = accessor.get(LocaleService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selection = selectionManagerService.getCurrentSelections();
    if (!selection) {
      return false;
    }
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    let range = selection[0].range;
    if (!range) {
      return false;
    }
    range = { ...range, endColumn: worksheet.getColumnCount() - 1 };
    const getRowLength = (range2) => range2.endRow - range2.startRow;
    const mergeData = worksheet.getMergeData().find((mergeRange) => {
      const interSectedRange = Rectangle.getIntersects(mergeRange, range);
      return interSectedRange ? getRowLength(mergeRange) > getRowLength(interSectedRange) : false;
    });
    if (!mergeData) {
      return commandService.executeCommand(InsertRangeMoveRightCommand.id);
    }
    const result = await confirmService.confirm({
      id: InsertRangeMoveRightConfirmCommand.id,
      title: { title: localeService.t("merge.confirm.waring") },
      children: { title: localeService.t("merge.confirm.dismantleMergeCellWaring") },
      cancelText: localeService.t("button.cancel"),
      confirmText: localeService.t("button.confirm")
    });
    if (result) {
      return commandService.executeCommand(InsertRangeMoveRightCommand.id);
    }
    return true;
  }
};

// ../packages/sheets-ui/src/consts/permission.ts
var UNIVER_SHEET_PERMISSION_PANEL = "UNIVER_SHEET_PERMISSION_PANEL";
var UNIVER_SHEET_PERMISSION_USER_PART = "UNIVER_SHEET_PERMISSION_USER_PART";
var UNIVER_SHEET_PERMISSION_BACKGROUND = "UNIVER_SHEET_PERMISSION_BACKGROUND";
var UNIVER_SHEET_PERMISSION_USER_DIALOG = "UNIVER_SHEET_PERMISSION_USER_DIALOG";
var UNIVER_SHEET_PERMISSION_DIALOG = "UNIVER_SHEET_PERMISSION_DIALOG";
var UNIVER_SHEET_PERMISSION_USER_DIALOG_ID = "UNIVER_SHEET_PERMISSION_USER_DIALOG_ID";
var UNIVER_SHEET_PERMISSION_DIALOG_ID = "UNIVER_SHEET_PERMISSION_DIALOG_ID";
var subUnitPermissionTypeMap = {
  [D.Copy]: "Copy",
  [D.SetCellStyle]: "SetCellStyle",
  [D.SetCellValue]: "SetCellValue",
  [D.SetRowStyle]: "SetRowStyle",
  [D.SetColumnStyle]: "SetColumnStyle",
  [D.InsertRow]: "InsertRow",
  [D.InsertColumn]: "InsertColumn",
  [D.InsertHyperlink]: "InsertHyperlink",
  [D.DeleteRow]: "DeleteRow",
  [D.DeleteColumn]: "DeleteColumn",
  [D.Sort]: "Sort",
  [D.Filter]: "Filter",
  [D.PivotTable]: "PivotTable",
  [D.EditExtraObject]: "EditExtraObject"
};
var defaultWorksheetUnitActionList = [
  D.Copy,
  D.SetCellStyle,
  D.SetCellValue,
  D.SetRowStyle,
  D.SetColumnStyle,
  D.InsertRow,
  D.InsertColumn,
  D.InsertHyperlink,
  D.DeleteRow,
  D.DeleteColumn,
  D.Sort,
  D.Filter,
  D.PivotTable,
  D.EditExtraObject,
  D.View
];
var permissionMenuIconKey = "sheet-permission-menu-icon";
var permissionDeleteIconKey = "sheet-permission-delete-icon";
var permissionEditIconKey = "sheet-permission-edit-icon";
var permissionCheckIconKey = "sheet-permission-check-icon";
var permissionLockIconKey = "sheet-permission-lock-icon";

// ../packages/sheets-ui/src/services/permission/sheet-permission-panel.model.ts
var DEFAULT_RANGE_RULE = {
  unitId: "",
  subUnitId: "",
  permissionId: "",
  unitType: a.SelectRange,
  id: "",
  ranges: [],
  viewState: "othersCanView" /* OthersCanView */,
  editState: "onlyMe" /* OnlyMe */
};
var SheetPermissionPanelModel = class {
  constructor() {
    __publicField(this, "_rule", DEFAULT_RANGE_RULE);
    __publicField(this, "_visible", false);
  }
  setVisible(v) {
    this._visible = v;
  }
  getVisible() {
    return this._visible;
  }
  reset() {
    this.setVisible(false);
  }
};

// ../packages/sheets-ui/src/services/permission/sheet-permission-user-list.service.ts
var SheetPermissionUserManagerService = class {
  constructor() {
    __publicField(this, "_userList", []);
    __publicField(this, "_userList$", new BehaviorSubject(this._userList));
    __publicField(this, "userList$", this._userList$.asObservable());
    __publicField(this, "_oldCollaboratorList", []);
    __publicField(this, "_selectUserList", []);
    __publicField(this, "_selectUserList$", new BehaviorSubject(this._selectUserList));
    __publicField(this, "selectUserList$", this._selectUserList$.asObservable());
  }
  get userList() {
    return this._userList;
  }
  // Set all editable users of this unit
  setCanEditUserList(userList) {
    this._userList = userList;
    this._userList$.next(userList);
  }
  reset() {
    this._userList = [];
    this._oldCollaboratorList = [];
    this._selectUserList = [];
    this._selectUserList$.next([]);
  }
  get oldCollaboratorList() {
    return this._oldCollaboratorList;
  }
  setOldCollaboratorList(userList) {
    this._oldCollaboratorList = userList;
  }
  get selectUserList() {
    return this._selectUserList;
  }
  // The results of the user dialog selection panel should be rendered in the permission panel
  setSelectUserList(userList) {
    this._selectUserList = userList;
    this._selectUserList$.next(userList);
  }
};

// ../packages/sheets-ui/src/commands/operations/sheet-permission-open-panel.operation.ts
var SheetPermissionOpenPanelOperation = {
  type: 1 /* OPERATION */,
  id: "sheet-permission.operation.openPanel",
  async handler(accessor, _params = {}) {
    const sidebarService = accessor.get(ISidebarService);
    const sheetPermissionPanelModel = accessor.get(SheetPermissionPanelModel);
    const sheetPermissionUserManagerService = accessor.get(SheetPermissionUserManagerService);
    const { showDetail = true, fromSheetBar = false, rule, oldRule } = _params;
    const sidebarProps = {
      header: { title: "permission.panel.title" },
      children: {
        label: UNIVER_SHEET_PERMISSION_PANEL,
        showDetail,
        fromSheetBar,
        rule,
        oldRule
      },
      width: 330,
      onClose: () => {
        sheetPermissionPanelModel.reset();
        sheetPermissionUserManagerService.reset();
      }
    };
    sheetPermissionPanelModel.setVisible(true);
    sidebarService.open(sidebarProps);
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/range-protection.command.ts
var AddRangeProtectionFromToolbarCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-range-protection-from-toolbar",
  async handler(accessor) {
    const commandService = accessor.get(ICommandService);
    await commandService.executeCommand(SheetPermissionOpenPanelOperation.id, { showDetail: true });
    return true;
  }
};
var AddRangeProtectionFromContextMenuCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-range-protection-from-context-menu",
  async handler(accessor) {
    const commandService = accessor.get(ICommandService);
    await commandService.executeCommand(SheetPermissionOpenPanelOperation.id, { showDetail: true });
    return true;
  }
};
var ViewSheetPermissionFromContextMenuCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.view-sheet-permission-from-context-menu",
  async handler(accessor) {
    const commandService = accessor.get(ICommandService);
    await commandService.executeCommand(SheetPermissionOpenPanelOperation.id, { showDetail: false });
    return true;
  }
};
var AddRangeProtectionFromSheetBarCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-range-protection-from-sheet-bar",
  async handler(accessor) {
    const commandService = accessor.get(ICommandService);
    await commandService.executeCommand(SheetPermissionOpenPanelOperation.id, { fromSheetBar: true, showDetail: true });
    return true;
  }
};
var ViewSheetPermissionFromSheetBarCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.view-sheet-permission-from-sheet-bar",
  async handler(accessor) {
    const commandService = accessor.get(ICommandService);
    await commandService.executeCommand(SheetPermissionOpenPanelOperation.id, { showDetail: false });
    return true;
  }
};
var DeleteRangeProtectionFromContextMenuCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delete-range-protection-from-context-menu",
  async handler(accessor) {
    var _a;
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const worksheetRuleModel = accessor.get(WorksheetProtectionRuleModel);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    const worksheetRule = worksheetRuleModel.getRule(unitId, subUnitId);
    if (worksheetRule == null ? void 0 : worksheetRule.permissionId) {
      return commandService.executeCommand(DeleteWorksheetProtectionCommand.id, { unitId, subUnitId, rule: worksheetRule });
    } else {
      const selectRange = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
      if (!selectRange) {
        return false;
      }
      const sheetPermissionRuleModal = accessor.get(RangeProtectionRuleModel);
      const subRuleList = sheetPermissionRuleModal.getSubunitRuleList(unitId, subUnitId);
      const rule = subRuleList.find((item) => {
        return item.ranges.some((range) => Rectangle.intersects(range, selectRange));
      });
      if (rule) {
        const redoMutationParam = {
          unitId,
          subUnitId,
          ruleIds: [rule.id]
        };
        const result = await commandService.executeCommand(DeleteRangeProtectionMutation.id, redoMutationParam);
        if (result) {
          undoRedoService.pushUndoRedo({
            unitID: unitId,
            redoMutations: [{ id: DeleteRangeProtectionMutation.id, params: redoMutationParam }],
            undoMutations: [{ id: AddRangeProtectionMutation.id, params: { unitId, subUnitId, rules: [rule] } }]
          });
        }
        return true;
      } else {
        return false;
      }
    }
  }
};
var SetRangeProtectionFromContextMenuCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-range-protection-from-context-menu",
  async handler(accessor) {
    var _a;
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const worksheetRuleModel = accessor.get(WorksheetProtectionRuleModel);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    const worksheetRule = worksheetRuleModel.getRule(unitId, subUnitId);
    if (worksheetRule == null ? void 0 : worksheetRule.permissionId) {
      const oldRule = {
        ...worksheetRule,
        unitId,
        subUnitId,
        ranges: []
      };
      await commandService.executeCommand(SheetPermissionOpenPanelOperation.id, { showDetail: true, rule: Tools.deepClone(oldRule), oldRule: Tools.deepClone(oldRule) });
      return true;
    } else {
      const selectRange = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
      if (!selectRange) {
        return false;
      }
      const sheetPermissionRuleModal = accessor.get(RangeProtectionRuleModel);
      const subRuleList = sheetPermissionRuleModal.getSubunitRuleList(unitId, subUnitId);
      const rule = subRuleList.find((item) => {
        var _a2;
        return (_a2 = item == null ? void 0 : item.ranges) == null ? void 0 : _a2.some((range) => Rectangle.intersects(range, selectRange));
      });
      if (rule) {
        const oldRule = {
          ...rule,
          unitId,
          subUnitId
        };
        await commandService.executeCommand(SheetPermissionOpenPanelOperation.id, { showDetail: true, rule: Tools.deepClone(oldRule), oldRule: Tools.deepClone(oldRule) });
        return true;
      } else {
        return false;
      }
    }
  }
};

// ../packages/sheets-ui/src/commands/commands/refill.command.ts
var RefillCommand = {
  id: "sheet.command.refill",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const autoFillService = accessor.get(IAutoFillService);
    return autoFillService.fillData(params.type);
  }
};

// ../packages/sheets-ui/src/commands/commands/remove-row-col-confirm.command.ts
var RemoveRowConfirmCommand = {
  id: "sheet.command.remove-row-confirm",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    var _a;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    let range = params == null ? void 0 : params.range;
    if (!range) {
      range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
    }
    if (!range) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    const allRowRanges = worksheet.getVisibleRows();
    if (isAllRowsCovered(allRowRanges, [range])) {
      const confirmService = accessor.get(IConfirmService);
      const localeService = accessor.get(LocaleService);
      await confirmService.confirm({
        id: "sheet.confirm.remove-row",
        title: {
          title: localeService.t("info.problem")
        },
        children: { title: localeService.t("rightClick.deleteAllRowsAlert") },
        cancelText: localeService.t("button.cancel"),
        confirmText: localeService.t("button.confirm")
      });
      return false;
    }
    await commandService.executeCommand(RemoveRowCommand.id, { range });
    return true;
  }
};
var RemoveColConfirmCommand = {
  id: "sheet.command.remove-col-confirm",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    var _a;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    let range = params == null ? void 0 : params.range;
    if (!range) {
      range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
    }
    if (!range) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    const allColumnRanges = worksheet.getVisibleCols();
    if (isAllColumnsCovered(allColumnRanges, [range])) {
      const confirmService = accessor.get(IConfirmService);
      const localeService = accessor.get(LocaleService);
      await confirmService.confirm({
        id: "sheet.confirm.remove-col",
        title: {
          title: localeService.t("info.problem")
        },
        children: { title: localeService.t("rightClick.deleteAllColumnsAlert") },
        cancelText: localeService.t("button.cancel"),
        confirmText: localeService.t("button.confirm")
      });
      return false;
    }
    await commandService.executeCommand(RemoveColCommand.id, { range });
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/remove-sheet-confirm.command.ts
var RemoveSheetConfirmCommand = {
  id: "sheet.command.remove-sheet-confirm",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const { subUnitId } = params;
    const confirmService = accessor.get(IConfirmService);
    const commandService = accessor.get(ICommandService);
    const localeService = accessor.get(LocaleService);
    const result = await confirmService.confirm({
      id: "sheet.confirm.remove-sheet",
      title: {
        title: localeService.t("sheetConfig.deleteSheet")
      },
      children: { title: localeService.t("sheetConfig.deleteSheetContent") },
      cancelText: localeService.t("button.cancel"),
      confirmText: localeService.t("button.confirm")
    });
    if (result) {
      await commandService.executeCommand(RemoveSheetCommand.id, { subUnitId });
      return true;
    }
    return false;
  }
};

// ../packages/sheets-ui/src/services/mark-selection/mark-selection.service.ts
var DEFAULT_Z_INDEX = 1e4 /* MARK_SELECTION */;
var IMarkSelectionService = createIdentifier("univer.mark-selection-service");
var MarkSelectionService = class extends Disposable {
  constructor(_currentService, _renderManagerService, _themeService) {
    super();
    this._currentService = _currentService;
    this._renderManagerService = _renderManagerService;
    this._themeService = _themeService;
    __publicField(this, "_shapeMap", /* @__PURE__ */ new Map());
  }
  addShape(selection, exits = [], zIndex = DEFAULT_Z_INDEX) {
    var _a;
    const workbook = this._currentService.getCurrentUnitForType(O.UNIVER_SHEET);
    const subUnitId = (_a = workbook.getActiveSheet()) == null ? void 0 : _a.getSheetId();
    if (!subUnitId) return null;
    const id = Tools.generateRandomId();
    const markSelectionInfo = {
      selection,
      subUnitId,
      unitId: workbook.getUnitId(),
      zIndex,
      control: null,
      exits
    };
    this._shapeMap.set(id, markSelectionInfo);
    this.refreshShapes();
    return id;
  }
  addShapeWithNoFresh(selection, exits = [], zIndex = DEFAULT_Z_INDEX) {
    var _a;
    const workbook = this._currentService.getCurrentUnitForType(O.UNIVER_SHEET);
    const subUnitId = (_a = workbook.getActiveSheet()) == null ? void 0 : _a.getSheetId();
    if (!subUnitId) return null;
    const id = Tools.generateRandomId();
    this._shapeMap.set(id, {
      selection,
      subUnitId,
      unitId: workbook.getUnitId(),
      zIndex,
      control: null,
      exits
    });
    return id;
  }
  refreshShapes() {
    var _a;
    const currentSheet = this._currentService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!currentSheet) return;
    const currentUnitId = currentSheet.getUnitId();
    const currentSubUnitId = (_a = currentSheet.getActiveSheet()) == null ? void 0 : _a.getSheetId();
    this._shapeMap.forEach((shape) => {
      const { unitId, subUnitId, selection, control: oldControl, zIndex } = shape;
      oldControl == null ? void 0 : oldControl.dispose();
      if (unitId !== currentUnitId || subUnitId !== currentSubUnitId) {
        return;
      }
      const renderUnit = this._renderManagerService.getRenderById(unitId);
      if (!renderUnit) return;
      const skeleton = renderUnit.with(SheetSkeletonManagerService).getCurrentSkeleton();
      if (!skeleton) return;
      const { scene } = renderUnit;
      const { rowHeaderWidth, columnHeaderHeight } = skeleton;
      const control = new SelectionControl(scene, zIndex, this._themeService, {
        enableAutoFill: false,
        highlightHeader: false,
        rowHeaderWidth,
        columnHeaderHeight
      });
      const selectionWithCoord = attachSelectionWithCoord(selection, skeleton);
      control.updateRangeBySelectionWithCoord(selectionWithCoord);
      shape.control = control;
    });
  }
  getShapeMap() {
    return this._shapeMap;
  }
  removeShape(id) {
    const shapeInfo = this._shapeMap.get(id);
    if (!shapeInfo) return;
    const { control } = shapeInfo;
    control == null ? void 0 : control.dispose();
    this._shapeMap.delete(id);
  }
  removeAllShapes() {
    for (const shape of this._shapeMap.values()) {
      const { control } = shape;
      control == null ? void 0 : control.dispose();
    }
    this._shapeMap.clear();
  }
};
MarkSelectionService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, Inject(ThemeService))
], MarkSelectionService);

// ../packages/sheets-ui/src/services/utils/selection-util.ts
function createCopyPasteSelectionStyle(themeService) {
  return {
    strokeWidth: 1.5,
    stroke: themeService.getCurrentTheme().primaryColor,
    fill: "rgba(178, 178, 178, 0.10)",
    widgets: {},
    strokeDash: 8
  };
}

// ../packages/sheets-ui/src/services/format-painter/format-painter.service.ts
var IFormatPainterService = createIdentifier("univer.format-painter-service");
var FormatPainterService = class extends Disposable {
  constructor(_selectionManagerService, _themeService, _markSelectionService, _logService, _commandService, _undoRedoService) {
    super();
    this._selectionManagerService = _selectionManagerService;
    this._themeService = _themeService;
    this._markSelectionService = _markSelectionService;
    this._logService = _logService;
    this._commandService = _commandService;
    this._undoRedoService = _undoRedoService;
    __publicField(this, "status$");
    __publicField(this, "_selectionFormat");
    __publicField(this, "_markId", null);
    __publicField(this, "_status$");
    __publicField(this, "_defaultHook", null);
    __publicField(this, "_extendHooks", []);
    this._status$ = new BehaviorSubject(0 /* OFF */);
    this.status$ = this._status$.asObservable();
    this._selectionFormat = { styles: new ObjectMatrix(), merges: [] };
  }
  addHook(hook) {
    var _a, _b, _c;
    if (hook.isDefaultHook && ((_a = hook.priority) != null ? _a : 0) > ((_c = (_b = this._defaultHook) == null ? void 0 : _b.priority) != null ? _c : -1)) {
      this._defaultHook = hook;
    } else {
      this._extendHooks.push(hook);
      this._extendHooks.sort((a2, b) => (a2.priority || 0) - (b.priority || 0));
    }
  }
  getHooks() {
    return this._defaultHook ? [this._defaultHook, ...this._extendHooks] : this._extendHooks;
  }
  setStatus(status) {
    this._updateRangeMark(status);
    this._status$.next(status);
    const hooks = this.getHooks();
    hooks.forEach((hook) => {
      if (hook.onStatusChange !== void 0) {
        hook.onStatusChange(status);
      }
    });
  }
  getStatus() {
    return this._status$.getValue();
  }
  setSelectionFormat(format) {
    this._selectionFormat = format;
  }
  getSelectionFormat() {
    return this._selectionFormat;
  }
  applyFormatPainter(unitId, subUnitId, range) {
    const hooks = this.getHooks();
    const redoMutationsInfo = [];
    const undoMutationsInfo = [];
    hooks.forEach((h) => {
      if (h.onApply !== void 0) {
        const applyReturn = h.onApply(
          unitId,
          subUnitId,
          range,
          this._selectionFormat
        );
        if (applyReturn) {
          redoMutationsInfo.push(...applyReturn.redos);
          undoMutationsInfo.push(...applyReturn.undos);
        }
      }
    });
    for (const beforeHook of hooks) {
      if (beforeHook.onBeforeApply !== void 0) {
        const result2 = beforeHook.onBeforeApply({
          unitId,
          subUnitId,
          range,
          redoMutationsInfo,
          format: this._selectionFormat,
          undoMutationsInfo
        });
        if (!result2) {
          return false;
        }
      }
    }
    this._logService.log("[FormatPainterService]", "apply mutations", {
      undoMutationsInfo,
      redoMutationsInfo
    });
    const result = redoMutationsInfo.every((m) => this._commandService.executeCommand(m.id, m.params));
    if (result) {
      this._undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undoMutationsInfo,
        redoMutations: redoMutationsInfo
      });
    }
    return result;
  }
  _updateRangeMark(status) {
    this._markSelectionService.removeAllShapes();
    if (status !== 0 /* OFF */) {
      const selection = this._selectionManagerService.getCurrentLastSelection();
      if (selection) {
        const style = createCopyPasteSelectionStyle(this._themeService);
        if (status === 2 /* INFINITE */) {
          this._markId = this._markSelectionService.addShape({ ...selection, style });
        } else {
          this._markId = this._markSelectionService.addShape({ ...selection, style }, [
            SetRangeValuesMutation.id
          ]);
        }
      }
    }
  }
};
FormatPainterService = __decorateClass([
  __decorateParam(0, Inject(SheetsSelectionsService)),
  __decorateParam(1, Inject(ThemeService)),
  __decorateParam(2, IMarkSelectionService),
  __decorateParam(3, ILogService),
  __decorateParam(4, ICommandService),
  __decorateParam(5, IUndoRedoService)
], FormatPainterService);

// ../packages/sheets-ui/src/commands/operations/set-format-painter.operation.ts
var SetFormatPainterOperation = {
  id: "sheet.operation.set-format-painter",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const formatPainterService = accessor.get(IFormatPainterService);
    formatPainterService.setStatus(params.status);
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/set-format-painter.command.ts
var SetInfiniteFormatPainterCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-infinite-format-painter",
  handler: async (accessor) => {
    const formatPainterService = accessor.get(IFormatPainterService);
    const status = formatPainterService.getStatus();
    let newStatus;
    if (status !== 0 /* OFF */) {
      newStatus = 0 /* OFF */;
    } else {
      newStatus = 2 /* INFINITE */;
    }
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SetFormatPainterOperation.id, { status: newStatus });
  }
};
var SetOnceFormatPainterCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-once-format-painter",
  handler: async (accessor) => {
    const formatPainterService = accessor.get(IFormatPainterService);
    const status = formatPainterService.getStatus();
    let newStatus;
    if (status !== 0 /* OFF */) {
      newStatus = 0 /* OFF */;
    } else {
      newStatus = 1 /* ONCE */;
    }
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SetFormatPainterOperation.id, { status: newStatus });
  }
};
var ApplyFormatPainterCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.apply-format-painter",
  handler: async (accessor, params) => {
    const formatPainterService = accessor.get(IFormatPainterService);
    return formatPainterService.applyFormatPainter(params.unitId, params.subUnitId, params.range);
  }
};

// ../packages/sheets-ui/src/services/scroll-manager.service.ts
var SheetScrollManagerService = class {
  constructor(_context, _sheetSkeletonManagerService) {
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    /**
     * a map holds all scroll info for each sheet(valid value)
     */
    __publicField(this, "_scrollStateMap", /* @__PURE__ */ new Map());
    /**
     * a subject for current sheet scrollInfo, no limit by viewport.
     */
    __publicField(this, "_rawScrollInfo$", new BehaviorSubject(null));
    /**
     * a subject for current sheet scrollInfo ( events, ex wheel event and point events add deltaXY to rawScrollInfo$)
     */
    __publicField(this, "rawScrollInfo$", this._rawScrollInfo$.asObservable());
    /**
     * a subject for current valid scrollInfo, viewport@_scrollCore would limit rawScrollInfo$ exclude negative value or over max value.
     * use this subject not rawScrollInfo$ when get scrolling state of viewport.
     * The value of this subject is the same as the value of onScrollAfter$
     *
     */
    __publicField(this, "validViewportScrollInfo$", new BehaviorSubject(null));
    /**
     * a subject for current valid scrollInfo, viewport@_scrollCore would limit rawScrollInfo$ exclude negative value or over max value.
     * use this subject not rawScrollInfo$ when get scrolling state of viewport.
     */
    __publicField(this, "_searchParamForScroll", null);
  }
  dispose() {
    this._rawScrollInfo$.complete();
  }
  calcViewportScrollFromRowColOffset(scrollInfo) {
    if (!scrollInfo) {
      return {
        viewportScrollX: 0,
        viewportScrollY: 0
      };
    }
    let { sheetViewStartColumn, sheetViewStartRow, offsetX, offsetY } = scrollInfo;
    sheetViewStartRow = sheetViewStartRow || 0;
    offsetY = offsetY || 0;
    const skeleton = this._sheetSkeletonManagerService.getCurrentSkeleton();
    const rowAcc = (skeleton == null ? void 0 : skeleton.rowHeightAccumulation[sheetViewStartRow - 1]) || 0;
    const colAcc = (skeleton == null ? void 0 : skeleton.columnWidthAccumulation[sheetViewStartColumn - 1]) || 0;
    const viewportScrollX = colAcc + offsetX;
    const viewportScrollY = rowAcc + offsetY;
    return {
      viewportScrollX,
      viewportScrollY
    };
  }
  setSearchParam(param) {
    this._searchParamForScroll = param;
  }
  getScrollStateByParam(param) {
    return this._getCurrentScroll(param);
  }
  getCurrentScrollState() {
    return this._getCurrentScroll(this._searchParamForScroll);
  }
  setValidScrollState(param) {
    this._setScrollState(param);
  }
  /**
   * emit raw scrollInfo by SetScrollOperation, call by ScrollCommand.id.
   * raw scrollInfo means not handled by limit scroll method.
   * @param param
   */
  emitRawScrollParam(param) {
    this._emitRawScroll(param);
  }
  /**
   * Set _scrollStateMap
   * @param scroll
   */
  setValidScrollStateToCurrSheet(scroll) {
    if (this._searchParamForScroll == null) {
      return;
    }
    this._setScrollState({
      ...this._searchParamForScroll,
      ...scroll
    });
    const sheetId = this._searchParamForScroll.sheetId;
    const sheetSkeleton = this._sheetSkeletonManagerService.getSkeleton(sheetId);
    if (sheetSkeleton) {
      sheetSkeleton.setScroll(scroll.viewportScrollX, scroll.viewportScrollY);
    }
  }
  clear() {
    if (this._searchParamForScroll == null) {
      return;
    }
    this._clearByParamAndNotify(this._searchParamForScroll);
  }
  /**
   * scroll
   * @param scrollInfo
   */
  _setScrollState(scrollInfo) {
    const { unitId, sheetId, sheetViewStartColumn, sheetViewStartRow, offsetX, offsetY } = scrollInfo;
    if (!this._scrollStateMap.has(unitId)) {
      this._scrollStateMap.set(unitId, /* @__PURE__ */ new Map());
    }
    const worksheetScrollInfoMap = this._scrollStateMap.get(unitId);
    const newScrollInfo = {
      sheetViewStartRow,
      sheetViewStartColumn,
      offsetX,
      offsetY
    };
    worksheetScrollInfoMap.set(sheetId, newScrollInfo);
  }
  _clearByParamAndNotify(param) {
    this._setScrollState({
      ...param,
      sheetViewStartRow: 0,
      sheetViewStartColumn: 0,
      offsetX: 0,
      offsetY: 0
    });
    this._emitRawScroll({
      sheetViewStartRow: 0,
      sheetViewStartColumn: 0,
      offsetX: 0,
      offsetY: 0
    });
  }
  _getCurrentScroll(param) {
    var _a;
    const emptyState = {
      sheetViewStartRow: 0,
      sheetViewStartColumn: 0,
      offsetX: 0,
      offsetY: 0
    };
    if (param == null) {
      return emptyState;
    }
    const { unitId, sheetId } = param;
    const currScrollState = (_a = this._scrollStateMap.get(unitId)) == null ? void 0 : _a.get(sheetId);
    return currScrollState || emptyState;
  }
  _emitRawScroll(param) {
    this._rawScrollInfo$.next(param);
  }
};
SheetScrollManagerService = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService))
], SheetScrollManagerService);

// ../packages/sheets-ui/src/commands/commands/set-frozen.command.ts
var SetSelectionFrozenCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-selection-frozen",
  handler: async (accessor, params) => {
    const { type } = params || {};
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = selectionManagerService.getCurrentSelections();
    if (!selections) {
      return false;
    }
    const currentSelection = selections[(selections == null ? void 0 : selections.length) - 1];
    const { range } = currentSelection;
    const renderManagerSrv = accessor.get(IRenderManagerService);
    const scrollManagerService = renderManagerSrv.getRenderById(unitId).with(SheetScrollManagerService);
    const { sheetViewStartRow = 0, sheetViewStartColumn = 0 } = scrollManagerService.getCurrentScrollState() || {};
    let startRow;
    let startColumn;
    let freezedRowCount;
    let freezedColCount;
    const { startRow: selectRow, startColumn: selectColumn, rangeType } = range;
    if (rangeType === 1 /* ROW */ || type === 1 /* Row */) {
      startRow = selectRow;
      freezedRowCount = selectRow - sheetViewStartRow;
      startColumn = -1;
      freezedColCount = 0;
    } else if (rangeType === 2 /* COLUMN */ || type === 2 /* Column */) {
      startRow = -1;
      freezedRowCount = 0;
      startColumn = selectColumn;
      freezedColCount = selectColumn - sheetViewStartColumn;
    } else if (rangeType === 0 /* NORMAL */) {
      startRow = selectRow;
      freezedRowCount = selectRow - sheetViewStartRow;
      startColumn = selectColumn;
      freezedColCount = selectColumn - sheetViewStartColumn;
    } else {
      return false;
    }
    const redoMutationParams = {
      unitId,
      subUnitId,
      startRow,
      startColumn,
      xSplit: startColumn > 0 ? Math.max(1, freezedColCount) : freezedColCount,
      ySplit: startRow > 0 ? Math.max(1, freezedRowCount) : freezedRowCount
    };
    const undoMutationParams = SetFrozenMutationFactory(accessor, redoMutationParams);
    const result = commandService.syncExecuteCommand(SetFrozenMutation.id, redoMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetFrozenMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetFrozenMutation.id, params: redoMutationParams }]
      });
      return true;
    }
    return true;
  }
};
var SetRowFrozenCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-row-frozen",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    commandService.executeCommand(SetSelectionFrozenCommand.id, {
      type: 1 /* Row */
    });
    return true;
  }
};
var SetColumnFrozenCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-col-frozen",
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    commandService.executeCommand(SetSelectionFrozenCommand.id, {
      type: 2 /* Column */
    });
    return true;
  }
};

// ../packages/sheets-ui/src/services/select-all/select-all.service.ts
var SelectAllService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "rangesStack", []);
    __publicField(this, "selectedRangeWorksheet", "");
  }
};

// ../packages/sheets-ui/src/services/shortcut-experience.service.ts
var ShortcutExperienceService = class {
  constructor(_univerInstanceService, _localeService) {
    this._univerInstanceService = _univerInstanceService;
    this._localeService = _localeService;
    __publicField(this, "_current", null);
    __publicField(this, "_shortcutParam", []);
  }
  dispose() {
    this._shortcutParam = [];
  }
  getCurrentBySearch(searchParm) {
    return this._getCurrentBySearch(searchParm);
  }
  getCurrent() {
    return this._getCurrentBySearch(this._current);
  }
  addOrUpdate(insertParam) {
    const param = this._getCurrentBySearch({
      unitId: insertParam.unitId,
      sheetId: insertParam.sheetId,
      keycode: insertParam.keycode
    });
    if (param != null) {
      const index = this._shortcutParam.indexOf(param);
      this._shortcutParam.splice(index, 1);
    }
    this._shortcutParam.push(insertParam);
    return param;
  }
  remove(searchParm) {
    if (searchParm == null) {
      return;
    }
    const param = this._getCurrentBySearch(searchParm);
    if (param == null) {
      return;
    }
    const index = this._shortcutParam.indexOf(param);
    return this._shortcutParam.splice(index, 1)[0];
  }
  _getCurrentBySearch(searchParm) {
    if (searchParm == null) {
      return;
    }
    const item = this._shortcutParam.find(
      (param) => param.unitId === searchParm.unitId && param.sheetId === searchParm.sheetId && param.keycode === searchParm.keycode
    );
    return item;
  }
};
ShortcutExperienceService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, Inject(LocaleService))
], ShortcutExperienceService);

// ../packages/sheets-ui/src/commands/commands/set-selection.command.ts
var MoveSelectionCommand = {
  id: "sheet.command.move-selection",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { workbook, worksheet } = target;
    const selection = getSelectionsService(accessor, params.fromCurrentSelection).getCurrentLastSelection();
    if (!selection) {
      return false;
    }
    const { direction, jumpOver, extra } = params;
    const { range, primary } = selection;
    const startRange = getStartRange(range, primary, direction);
    const next = jumpOver === 1 /* moveGap */ ? findNextGapRange(startRange, direction, worksheet) : findNextRange(startRange, direction, worksheet);
    const destRange = getCellAtRowCol(next.startRow, next.startColumn, worksheet);
    if (Rectangle.equals(destRange, startRange)) {
      return false;
    }
    const unitId = workbook.getUnitId();
    accessor.get(ShortcutExperienceService).remove({
      unitId,
      sheetId: worksheet.getSheetId(),
      keycode: 9 /* TAB */
    });
    const selections = [
      {
        range: Rectangle.clone(destRange),
        primary: {
          startRow: destRange.startRow,
          startColumn: destRange.startColumn,
          endRow: destRange.endRow,
          endColumn: destRange.endColumn,
          actualRow: next.startRow,
          actualColumn: next.startColumn,
          isMerged: destRange.isMerged,
          isMergedMainCell: destRange.startRow === next.startRow && destRange.startColumn === next.startColumn
        }
      }
    ];
    const rs = accessor.get(ICommandService).executeCommand(SetSelectionsOperation.id, {
      unitId: workbook.getUnitId(),
      subUnitId: worksheet.getSheetId(),
      selections,
      type: 2 /* MOVE_END */,
      extra,
      reveal: true
    });
    return rs;
  }
};
var MoveSelectionEnterAndTabCommand = {
  id: "sheet.command.move-selection-enter-tab",
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function, complexity
  handler: (accessor, params) => {
    var _a;
    if (!params) {
      return false;
    }
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { workbook, worksheet } = target;
    const selectionsService = getSelectionsService(accessor);
    const { direction, keycode } = params;
    const isReverse = direction === 3 /* LEFT */ || direction === 0 /* UP */;
    const selections = selectionsService.getCurrentSelections().concat();
    const currentSelectionIndex = selections.findIndex((s) => s.primary);
    const selection = selections[currentSelectionIndex];
    if (!selection) {
      return false;
    }
    const delta = isReverse ? -1 : 1;
    const nextSelection = currentSelectionIndex + delta !== selections.length ? selections[currentSelectionIndex + delta] : selections[0];
    const nextSelectionIndex = selections.findIndex((s) => s === nextSelection);
    const unitId = workbook.getUnitId();
    const sheetId = worksheet.getSheetId();
    if (!selection) {
      return false;
    }
    const { range } = selection;
    const primary = selection.primary;
    let startRange = getStartRange(range, primary, direction);
    const shortcutExperienceService = accessor.get(ShortcutExperienceService);
    const shortcutExperienceParam = shortcutExperienceService.getCurrentBySearch({
      unitId,
      sheetId,
      keycode: 9 /* TAB */
    });
    let resultRange;
    const { startRow, endRow, startColumn, endColumn } = range;
    const isLastCell = isReverse ? primary.startRow === startRow && primary.startColumn === startColumn : primary.endRow === endRow && primary.endColumn === endColumn;
    if (!Rectangle.equals(range, primary)) {
      shortcutExperienceService.remove({
        unitId,
        sheetId,
        keycode: 9 /* TAB */
      });
      const newPrimary = Tools.deepClone(primary);
      const next = isLastCell ? nextSelection.range : findNextRange(
        {
          startRow: newPrimary.startRow,
          startColumn: newPrimary.startColumn,
          endRow: newPrimary.endRow,
          endColumn: newPrimary.endColumn
        },
        direction,
        worksheet,
        {
          startRow,
          endRow,
          startColumn,
          endColumn
        }
      );
      const useLeftTopAsDest = isLastCell && isReverse;
      const destRange = useLeftTopAsDest ? getCellAtRowCol(next.endRow, next.endColumn, worksheet) : getCellAtRowCol(next.startRow, next.startColumn, worksheet);
      resultRange = {
        range: isLastCell ? nextSelection.range : Rectangle.clone(range),
        primary: {
          startRow: destRange.startRow,
          startColumn: destRange.startColumn,
          endRow: destRange.endRow,
          endColumn: destRange.endColumn,
          actualRow: useLeftTopAsDest ? destRange.startRow : next.startRow,
          actualColumn: useLeftTopAsDest ? destRange.startColumn : next.startColumn,
          isMerged: destRange.isMerged,
          isMergedMainCell: destRange.startRow === next.startRow && destRange.startColumn === next.startColumn
        },
        style: isLastCell ? nextSelection.style : selection.style
      };
    } else {
      if (keycode === 9 /* TAB */) {
        if (shortcutExperienceParam == null) {
          shortcutExperienceService.addOrUpdate({
            unitId,
            sheetId,
            keycode: 9 /* TAB */,
            selection
          });
        }
      } else {
        const selectionRemain = shortcutExperienceParam == null ? void 0 : shortcutExperienceParam.selection;
        if (selectionRemain != null) {
          const { range: range2, primary: primary2 } = selectionRemain;
          startRange = getStartRange(range2, primary2, direction);
        }
        shortcutExperienceService.remove({
          unitId,
          sheetId,
          keycode: 9 /* TAB */
        });
      }
      const next = findNextRange(startRange, direction, worksheet);
      const destRange = getCellAtRowCol(next.startRow, next.startColumn, worksheet);
      if (Rectangle.equals(destRange, startRange)) {
        return false;
      }
      resultRange = {
        range: Rectangle.clone(destRange),
        primary: {
          startRow: destRange.startRow,
          startColumn: destRange.startColumn,
          endRow: destRange.endRow,
          endColumn: destRange.endColumn,
          actualRow: next.startRow,
          actualColumn: next.startColumn,
          isMerged: destRange.isMerged,
          isMergedMainCell: destRange.startRow === next.startRow && destRange.startColumn === next.startColumn
        }
      };
    }
    if (isLastCell) {
      selections[currentSelectionIndex].primary = null;
      selections[nextSelectionIndex] = resultRange;
      selectionsService.setSelections(unitId, sheetId, [], 2 /* MOVE_END */);
    } else {
      selections[currentSelectionIndex] = resultRange;
    }
    const rs = accessor.get(ICommandService).executeCommand(SetSelectionsOperation.id, {
      unitId,
      subUnitId: sheetId,
      type: 2 /* MOVE_END */,
      selections,
      reveal: true,
      extra: params.extra
    });
    const renderManagerService = accessor.get(IRenderManagerService);
    const selectionService = (_a = renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(ISheetSelectionRenderService);
    selectionService == null ? void 0 : selectionService.refreshSelectionMoveEnd();
    return rs;
  }
};
var ExpandSelectionCommand = {
  id: "sheet.command.expand-selection",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const selection = getSelectionsService(accessor).getCurrentLastSelection();
    if (!selection) return false;
    const { range: startRange, primary } = selection;
    const { jumpOver, direction, extra } = params;
    const isShrink = checkIfShrink(selection, direction, worksheet);
    const destRange = !isShrink ? jumpOver === 1 /* moveGap */ ? expandToNextGapRange(startRange, direction, worksheet) : expandToNextCell(startRange, direction, worksheet) : jumpOver === 1 /* moveGap */ ? shrinkToNextGapRange(
      startRange,
      { ...Rectangle.clone(primary), rangeType: 0 /* NORMAL */ },
      direction,
      worksheet
    ) : shrinkToNextCell(startRange, direction, worksheet);
    destRange.rangeType = selection.range.rangeType;
    if (Rectangle.equals(destRange, startRange)) {
      return false;
    }
    return accessor.get(ICommandService).syncExecuteCommand(SetSelectionsOperation.id, {
      unitId,
      subUnitId,
      type: 2 /* MOVE_END */,
      selections: [
        {
          range: destRange,
          primary
          // this remains unchanged
        }
      ],
      extra,
      reveal: true
    });
  }
};
var SelectAllCommand = {
  id: "sheet.command.select-all",
  type: 0 /* COMMAND */,
  handler: async (accessor, params = { expandToGapFirst: true, loop: false }) => {
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const selection = getSelectionsService(accessor).getCurrentLastSelection();
    if (!selection) return false;
    const selectAllService = accessor.get(SelectAllService);
    const { worksheet, unitId, subUnitId } = target;
    const id = `${unitId}|${subUnitId}`;
    if (id !== selectAllService.selectedRangeWorksheet) {
      selectAllService.rangesStack = [];
      selectAllService.selectedRangeWorksheet = id;
    }
    const maxRow = worksheet.getMaxRows();
    const maxCol = worksheet.getMaxColumns();
    const { expandToGapFirst, loop } = params;
    const { range, primary } = selection;
    const isWholeSheetSelected = range.endColumn === maxCol - 1 && range.endRow === maxRow - 1 && range.startRow === 0 && range.startColumn === 0;
    if (!selectAllService.rangesStack.some((s) => Rectangle.equals(s, range))) {
      selectAllService.rangesStack = [];
      selectAllService.rangesStack.push(range);
    }
    let destRange;
    if (isWholeSheetSelected) {
      if (loop) {
        const currentSelectionIndex = selectAllService.rangesStack.findIndex((s) => Rectangle.equals(s, range));
        if (currentSelectionIndex !== selectAllService.rangesStack.length - 1) {
          return false;
        }
        destRange = selectAllService.rangesStack[0];
      } else {
        return false;
      }
    } else if (expandToGapFirst) {
      destRange = expandToContinuousRange(range, { left: true, right: true, up: true, down: true }, worksheet);
      if (Rectangle.equals(destRange, range)) {
        destRange = expandToWholeSheet(worksheet);
      }
    } else {
      destRange = expandToWholeSheet(worksheet);
    }
    if (!selectAllService.rangesStack.some((s) => Rectangle.equals(s, destRange))) {
      selectAllService.rangesStack.push(destRange);
    }
    return accessor.get(ICommandService).executeCommand(SetSelectionsOperation.id, {
      unitId,
      subUnitId,
      reveal: true,
      selections: [
        {
          range: destRange,
          primary
          // this remains unchanged
        }
      ]
    });
  }
};

// ../packages/sheets-ui/src/controllers/utils/component-tools.ts
function isRenderManagerService(renderManagerService) {
  return typeof renderManagerService.isMainScene === "undefined";
}
function getSheetObject(univerInstanceService, renderManagerService) {
  const workbook = univerInstanceService instanceof Workbook ? univerInstanceService : univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  if (!workbook) return null;
  const unitId = workbook.getUnitId();
  let components, mainComponent, scene, engine;
  if (isRenderManagerService(renderManagerService)) {
    const currentRender = renderManagerService.getRenderById(unitId);
    if (currentRender == null) return null;
    components = currentRender.components;
    components = currentRender.components;
    mainComponent = currentRender.mainComponent;
    scene = currentRender.scene;
    engine = currentRender.engine;
  } else {
    components = renderManagerService.components;
    mainComponent = renderManagerService.mainComponent;
    scene = renderManagerService.scene;
    engine = renderManagerService.engine;
  }
  if (!components || !mainComponent) return null;
  const spreadsheet = mainComponent;
  const spreadsheetRowHeader = components.get("__SpreadsheetRowHeader__" /* ROW */);
  const spreadsheetColumnHeader = components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
  const spreadsheetLeftTopPlaceholder = components.get("__SpreadsheetLeftTopPlaceholder__" /* LEFT_TOP */);
  return {
    spreadsheet,
    spreadsheetRowHeader,
    spreadsheetColumnHeader,
    spreadsheetLeftTopPlaceholder,
    scene,
    engine
  };
}
function getCoordByCell(row, col, scene, skeleton) {
  const { startX, startY, endX, endY } = skeleton.getCellWithCoordByIndex(row, col);
  return { startX, startY, endX, endY };
}
function getCoordByOffset(evtOffsetX, evtOffsetY, scene, skeleton, viewport, closeFirst) {
  const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
  const { x: newEvtOffsetX, y: newEvtOffsetY } = relativeCoords;
  const scrollXY = scene.getScrollXYInfoByViewport(relativeCoords, viewport);
  const { scaleX, scaleY } = scene.getAncestorScale();
  const moveActualSelection = skeleton.getCellIndexByOffset(
    newEvtOffsetX,
    newEvtOffsetY,
    scaleX,
    scaleY,
    scrollXY,
    { closeFirst }
  );
  const { row, column } = moveActualSelection;
  const startCell = skeleton.getNoMergeCellWithCoordByIndex(row, column);
  const { startX, startY, endX, endY } = startCell;
  return {
    startX,
    startY,
    endX,
    endY,
    row,
    column
  };
}
function getTransformCoord(evtOffsetX, evtOffsetY, scene, skeleton) {
  const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
  const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
  const scrollXY = scene.getScrollXYInfoByViewport(relativeCoords, viewMain);
  const { scaleX, scaleY } = scene.getAncestorScale();
  const { x: scrollX, y: scrollY } = scrollXY;
  const offsetX = evtOffsetX / scaleX + scrollX;
  const offsetY = evtOffsetY / scaleY + scrollY;
  return { x: offsetX, y: offsetY };
}

// ../packages/sheets-ui/src/controllers/render-controllers/scroll.render-controller.ts
var SHEET_NAVIGATION_COMMANDS = [MoveSelectionCommand.id, MoveSelectionEnterAndTabCommand.id];
var MOUSE_WHEEL_SPEED_SMOOTHING_FACTOR = 3;
var SheetsScrollRenderController = class extends Disposable {
  constructor(_context, _injector, _sheetSkeletonManagerService, _contextService, _commandService, _renderManagerService, _scrollManagerService) {
    super();
    this._context = _context;
    this._injector = _injector;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._contextService = _contextService;
    this._commandService = _commandService;
    this._renderManagerService = _renderManagerService;
    this._scrollManagerService = _scrollManagerService;
    this._initCommandListener();
    this._wheelEventListener();
    this._scrollBarEventListener();
    this._initSkeletonListener();
  }
  _wheelEventListener() {
    const { scene } = this._context;
    if (!scene) return;
    const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (!viewMain) return;
    this.disposeWithMe(
      scene.onMouseWheel$.subscribeEvent((evt, state) => {
        if (evt.ctrlKey || !this._contextService.getContextValue(FOCUSING_SHEET)) {
          return;
        }
        let offsetX = 0;
        let offsetY = 0;
        offsetX = evt.deltaX;
        if (evt.shiftKey) {
          offsetX = (evt.deltaY || evt.deltaX) * MOUSE_WHEEL_SPEED_SMOOTHING_FACTOR;
        } else {
          offsetY = evt.deltaY;
        }
        this._commandService.executeCommand(SetScrollRelativeCommand.id, { offsetX, offsetY });
        this._context.scene.makeDirty(true);
        const isLimitedStore = viewMain.limitedScroll(viewMain.scrollX + offsetX, viewMain.scrollY + offsetY);
        if (isLimitedStore && !isLimitedStore.isLimitedX && !isLimitedStore.isLimitedY) {
          evt.preventDefault();
          if (scene.getParent().classType === "SceneViewer" /* SCENE_VIEWER */) {
            state.stopPropagation();
          }
        }
        if (viewMain.isWheelPreventDefaultX && viewMain.isWheelPreventDefaultY) {
          evt.preventDefault();
        }
      })
    );
  }
  // eslint-disable-next-line max-lines-per-function
  _scrollBarEventListener() {
    const { scene } = this._context;
    if (scene == null) return;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (!viewportMain) return;
    this.disposeWithMe(
      toDisposable(
        this._scrollManagerService.rawScrollInfo$.subscribe((rawScrollInfo) => {
          var _a;
          const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
          if (!skeleton) return;
          if (rawScrollInfo == null) {
            viewportMain.scrollToViewportPos({
              viewportScrollX: 0,
              viewportScrollY: 0
            });
            return;
          }
          const { sheetViewStartRow, sheetViewStartColumn, offsetX, offsetY } = rawScrollInfo;
          const { startX, startY } = skeleton.getCellWithCoordByIndex(
            sheetViewStartRow,
            sheetViewStartColumn,
            false
          );
          const viewportScrollX = startX + offsetX;
          const viewportScrollY = startY + offsetY;
          viewportMain.scrollToViewportPos({ viewportScrollX, viewportScrollY });
        })
      )
    );
    this.disposeWithMe(
      // set scrollInfo, the event is triggered in viewport@_scrollToScrollbarPos
      viewportMain.onScrollAfter$.subscribeEvent((scrollAfterParam) => {
        var _a;
        const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
        if (skeleton == null || scrollAfterParam.isTrigger === false) {
          return;
        }
        const sheetObject = this._getSheetObject();
        if (skeleton == null || sheetObject == null) {
          return;
        }
        const { viewportScrollX, viewportScrollY, scrollX, scrollY } = scrollAfterParam;
        const { row, column, rowOffset, columnOffset } = skeleton.getOffsetRelativeToRowCol(
          viewportScrollX,
          viewportScrollY
        );
        const scrollInfo = {
          sheetViewStartRow: row,
          sheetViewStartColumn: column,
          offsetX: columnOffset,
          offsetY: rowOffset,
          viewportScrollX,
          viewportScrollY,
          scrollX,
          scrollY
        };
        this._scrollManagerService.setValidScrollStateToCurrSheet(scrollInfo);
        this._scrollManagerService.validViewportScrollInfo$.next({
          ...scrollInfo,
          viewportScrollX,
          viewportScrollY,
          scrollX,
          scrollY
        });
      })
    );
    this.disposeWithMe(
      // get scrollByBar event from viewport and exec ScrollCommand.id.
      viewportMain.onScrollByBar$.subscribeEvent((param) => {
        var _a;
        const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
        if (skeleton == null || param.isTrigger === false) {
          return;
        }
        const sheetObject = this._getSheetObject();
        if (skeleton == null || sheetObject == null) {
          return;
        }
        const { viewportScrollX = 0, viewportScrollY = 0 } = param;
        const freeze = this._getFreeze();
        const { row, column, rowOffset, columnOffset } = skeleton.getOffsetRelativeToRowCol(
          viewportScrollX,
          viewportScrollY
        );
        this._commandService.executeCommand(ScrollCommand.id, {
          sheetViewStartRow: row,
          sheetViewStartColumn: column,
          offsetX: columnOffset,
          offsetY: rowOffset
        });
      })
    );
  }
  _initSkeletonListener() {
    this.disposeWithMe(toDisposable(
      this._sheetSkeletonManagerService.currentSkeletonBefore$.subscribe((param) => {
        if (param == null) {
          return;
        }
        const scrollParam = { unitId: param.unitId, sheetId: param.sheetId };
        this._scrollManagerService.setSearchParam(scrollParam);
        const sheetObject = this._getSheetObject();
        if (!sheetObject) return;
        const currScrollInfo = this._scrollManagerService.getScrollStateByParam(scrollParam);
        const { viewportScrollX, viewportScrollY } = this._scrollManagerService.calcViewportScrollFromRowColOffset(currScrollInfo);
        if (currScrollInfo) {
          this._updateViewportScroll(viewportScrollX, viewportScrollY);
        }
      })
    ));
  }
  _updateViewportScroll(viewportScrollX = 0, viewportScrollY = 0) {
    const sheetObject = this._getSheetObject();
    if (!sheetObject) return;
    const scene = sheetObject.scene;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const viewColRight = scene.getViewport("viewColumnRight" /* VIEW_COLUMN_RIGHT */);
    const viewRowBottom = scene.getViewport("viewRowBottom" /* VIEW_ROW_BOTTOM */);
    const viewportMainLeft = scene.getViewport("viewMainLeft" /* VIEW_MAIN_LEFT */);
    const viewportMainTop = scene.getViewport("viewMainTop" /* VIEW_MAIN_TOP */);
    if (viewportMain) {
      viewportMain.viewportScrollX = viewportScrollX;
      viewportMain.viewportScrollY = viewportScrollY;
    }
    if (viewRowBottom) {
      viewRowBottom.viewportScrollY = viewportScrollY;
    }
    if (viewColRight) {
      viewColRight.viewportScrollX = viewportScrollX;
    }
    if (viewportMainLeft) {
      viewportMainLeft.viewportScrollY = viewportScrollY;
    }
    if (viewportMainTop) {
      viewportMainTop.viewportScrollX = viewportScrollX;
    }
  }
  scrollToRange(range, forceTop, forceLeft) {
    let { endRow, endColumn, startColumn, startRow } = range;
    const bounding = this._getViewportBounding();
    if (range.rangeType === 1 /* ROW */) {
      startColumn = 0;
      endColumn = 0;
    } else if (range.rangeType === 2 /* COLUMN */) {
      startRow = 0;
      endRow = 0;
    }
    if (bounding && !forceTop && !forceLeft) {
      const row = bounding.startRow > endRow ? startRow : endRow;
      const col = bounding.startColumn > endColumn ? startColumn : endColumn;
      return this._scrollToCell(row, col);
    } else {
      return this._scrollToCell(startRow, startColumn, forceTop, forceLeft);
    }
  }
  /**
   * Scroll spreadsheet(viewMain) to cell position. Based on the limitations of viewport and the number of rows and columns, you can only scroll to the maximum scrollable range.
   *
   * if column A ~ B is frozen. set second param to 0 would make viewMain start at column C.
   * set second param to 2 would make viewMain start at column E.
   * @param {number} row - Cell row
   * @param {number} column - Cell column
   * @returns {boolean} - true if scroll is successful
   */
  scrollToCell(row, column) {
    const worksheet = this._context.unit.getActiveSheet();
    const {
      ySplit: freezeYSplit,
      xSplit: freezeXSplit
    } = worksheet.getFreeze();
    return this._commandService.syncExecuteCommand(ScrollCommand.id, {
      sheetViewStartRow: row - freezeYSplit,
      sheetViewStartColumn: column - freezeXSplit,
      offsetX: 0,
      offsetY: 0
    });
  }
  _initCommandListener() {
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      switch (command.id) {
        case SetSelectionsOperation.id:
          {
            const p = command.params;
            if (p.unitId === this._context.unitId && p.reveal) {
              this._scrollToSelection();
            }
          }
          break;
        case ScrollToCellOperation.id:
          {
            const p = command.params;
            if (p.unitId === this._context.unitId) {
              const rangeParam = p.range;
              this.scrollToRange(rangeParam);
            }
          }
          break;
        case ExpandSelectionCommand.id:
          {
            const expandParam = command.params;
            this._scrollToSelectionForExpand(expandParam);
          }
          break;
        default:
          break;
      }
    }));
  }
  _scrollToSelectionForExpand(param) {
    setTimeout(() => {
      const selection = this._getSelectionsService().getCurrentLastSelection();
      if (selection == null) {
        return;
      }
      const { startRow, startColumn, endRow, endColumn } = selection.range;
      const bounds = this._getViewportBounding();
      if (bounds == null) {
        return;
      }
      const { startRow: viewportStartRow, startColumn: viewportStartColumn, endRow: viewportEndRow, endColumn: viewportEndColumn } = bounds;
      let row = 0;
      let column = 0;
      if (startRow > viewportStartRow) {
        row = endRow;
      } else if (endRow < viewportEndRow) {
        row = startRow;
      } else {
        row = viewportStartRow;
      }
      if (startColumn > viewportStartColumn) {
        column = endColumn;
      } else if (endColumn < viewportEndColumn) {
        column = startColumn;
      } else {
        column = viewportStartColumn;
      }
      if (param.direction === 2 /* DOWN */) {
        row = endRow;
      } else if (param.direction === 0 /* UP */) {
        row = startRow;
      } else if (param.direction === 1 /* RIGHT */) {
        column = endColumn;
      } else if (param.direction === 3 /* LEFT */) {
        column = startColumn;
      }
      this._scrollToCell(row, column);
    }, 0);
  }
  _getFreeze() {
    var _a;
    const snapshot = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton.getWorksheetConfig();
    if (snapshot == null) {
      return;
    }
    return snapshot.freeze;
  }
  _updateSceneSize(param) {
    var _a;
    if (param == null) {
      return;
    }
    const { unitId } = this._context;
    const { skeleton } = param;
    const scene = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.scene;
    if (skeleton == null || scene == null) {
      return;
    }
    const { rowTotalHeight, columnTotalWidth, rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop } = skeleton;
    const workbook = this._context.unit;
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return;
    scene == null ? void 0 : scene.transformByState({
      width: rowHeaderWidthAndMarginLeft + columnTotalWidth,
      height: columnHeaderHeightAndMarginTop + rowTotalHeight
    });
  }
  _getSheetObject() {
    return getSheetObject(this._context.unit, this._context);
  }
  _scrollToSelectionByDirection(range) {
    const bounds = this._getViewportBounding();
    if (bounds == null) {
      return false;
    }
    const {
      startRow: viewportStartRow,
      startColumn: viewportStartColumn,
      endRow: viewportEndRow,
      endColumn: viewportEndColumn
    } = bounds;
    let row = 0;
    let column = 0;
    const { startRow, startColumn, endRow, endColumn } = range;
    if (startRow >= viewportStartRow) {
      row = endRow;
    }
    if (endRow <= viewportEndRow) {
      row = startRow;
    }
    if (startColumn >= viewportStartColumn) {
      column = endColumn;
    }
    if (endColumn <= viewportEndColumn) {
      column = startColumn;
    }
    this._scrollToCell(row, column);
  }
  _scrollToSelection(targetIsActualRowAndColumn = true) {
    var _a;
    const selection = this._getSelectionsService().getCurrentLastSelection();
    if (!selection) return;
    const { startRow, startColumn, actualRow, actualColumn } = (_a = selection.primary) != null ? _a : selection.range;
    const selectionStartRow = targetIsActualRowAndColumn ? actualRow != null ? actualRow : startRow : startRow;
    const selectionStartColumn = targetIsActualRowAndColumn ? actualColumn != null ? actualColumn : startColumn : startColumn;
    this._scrollToCell(selectionStartRow, selectionStartColumn);
  }
  _getSelectionsService() {
    return getSelectionsService(this._injector);
  }
  _getViewportBounding() {
    var _a, _b;
    const scene = (_a = this._getSheetObject()) == null ? void 0 : _a.scene;
    if (scene == null) {
      return;
    }
    const viewport = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (viewport == null) {
      return;
    }
    const skeleton = (_b = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _b.skeleton;
    if (skeleton == null) {
      return;
    }
    const vpInfo = viewport.calcViewportInfo();
    return skeleton.getRangeByViewBound(vpInfo.viewBound);
  }
  // For arrow key to active cell cause scrolling.
  // eslint-disable-next-line max-lines-per-function, complexity
  _scrollToCell(row, column, forceTop = false, forceLeft = false) {
    var _a, _b, _c;
    const { rowHeightAccumulation, columnWidthAccumulation } = (_a = this._sheetSkeletonManagerService.getCurrentSkeleton()) != null ? _a : {};
    if (rowHeightAccumulation == null || columnWidthAccumulation == null) return false;
    const scene = (_b = this._getSheetObject()) == null ? void 0 : _b.scene;
    if (scene == null) return false;
    const viewport = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (viewport == null) return false;
    const skeleton = (_c = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _c.skeleton;
    if (skeleton == null) return false;
    const worksheet = this._context.unit.getActiveSheet();
    if (!worksheet) return false;
    row = Tools.clamp(row, 0, rowHeightAccumulation.length - 1);
    column = Tools.clamp(column, 0, columnWidthAccumulation.length - 1);
    const {
      startColumn: scrollableStartCol,
      startRow: scrollableStartRow,
      ySplit: freezedRowCount,
      xSplit: freezedColCount
    } = worksheet.getFreeze();
    const bounds = this._getViewportBounding();
    if (bounds == null) return false;
    const {
      startRow: viewMainStartRow,
      startColumn: viewMainStartColumn,
      endRow: viewMainEndRow,
      endColumn: viewMainEndColumn
    } = bounds;
    let startSheetViewRow;
    let startSheetViewColumn;
    if (row >= scrollableStartRow && column >= scrollableStartCol - freezedRowCount) {
      if (row <= viewMainStartRow) {
        startSheetViewRow = row;
        forceTop = true;
      }
      if (row >= viewMainEndRow) {
        const minRowAccumulation = rowHeightAccumulation[row] - viewport.height;
        for (let r = viewMainStartRow; r <= row; r++) {
          startSheetViewRow = r + 1;
          if (rowHeightAccumulation[r] >= minRowAccumulation) {
            break;
          }
        }
      }
    }
    if (column >= scrollableStartCol && row >= scrollableStartRow - freezedRowCount) {
      if (column <= viewMainStartColumn) {
        startSheetViewColumn = column;
        forceLeft = true;
      }
      if (column >= viewMainEndColumn) {
        const minColumnAccumulation = columnWidthAccumulation[column] - viewport.width;
        for (let c = viewMainStartColumn; c <= column; c++) {
          startSheetViewColumn = c + 1;
          if (columnWidthAccumulation[c] >= minColumnAccumulation) {
            break;
          }
        }
      }
    }
    if (startSheetViewRow === void 0 && startSheetViewColumn === void 0) return false;
    let { offsetX, offsetY, sheetViewStartRow: preSheetViewStartRow, sheetViewStartColumn: preSheetViewStartColumn } = this._scrollManagerService.getCurrentScrollState() || {};
    startSheetViewRow = startSheetViewRow ? Math.min(startSheetViewRow, row) : preSheetViewStartRow + freezedRowCount;
    ;
    startSheetViewColumn = startSheetViewColumn ? Math.min(startSheetViewColumn, column) : preSheetViewStartColumn + freezedColCount;
    if (forceLeft) {
      offsetX = 0;
      startSheetViewColumn = column;
      const hiddenColumns = skeleton.getHiddenColumnsInRange({ startColumn: startSheetViewColumn - freezedColCount, endColumn: startSheetViewColumn });
      startSheetViewColumn = startSheetViewColumn - hiddenColumns.length;
    }
    if (forceTop) {
      offsetY = 0;
      startSheetViewRow = row;
      const hiddenRows = skeleton.getHiddenRowsInRange({ startRow: startSheetViewRow - freezedRowCount, endRow: startSheetViewRow });
      startSheetViewRow = startSheetViewRow - hiddenRows.length;
    }
    return this._commandService.syncExecuteCommand(ScrollCommand.id, {
      // sheetViewStartRow & offsetX should never be undefined, it's rendering, there should always be a value!
      // sheetViewStartRow: forceTop ? Math.max(0, row - freezeYSplit) : ((startSheetViewRow ?? 0) - freezeYSplit),
      // sheetViewStartColumn: forceLeft ? Math.max(0, column - freezeXSplit) : ((startSheetViewColumn ?? 0) - freezeXSplit),
      // offsetX: startSheetViewColumn === undefined ? offsetX : 0,
      // offsetY: startSheetViewRow === undefined ? offsetY : 0,
      sheetViewStartRow: Math.max(0, startSheetViewRow - freezedRowCount),
      sheetViewStartColumn: Math.max(0, startSheetViewColumn - freezedColCount),
      offsetX,
      offsetY
    });
  }
};
SheetsScrollRenderController = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, Inject(SheetSkeletonManagerService)),
  __decorateParam(3, IContextService),
  __decorateParam(4, ICommandService),
  __decorateParam(5, IRenderManagerService),
  __decorateParam(6, Inject(SheetScrollManagerService))
], SheetsScrollRenderController);

// ../packages/sheets-ui/src/commands/operations/scroll.operation.ts
var SetScrollOperation = {
  id: "sheet.operation.set-scroll",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const { unitId, sheetId, offsetX, offsetY, sheetViewStartColumn, sheetViewStartRow } = params;
    const renderManagerService = accessor.get(IRenderManagerService);
    const scrollManagerService = renderManagerService.getRenderById(unitId).with(SheetScrollManagerService);
    scrollManagerService.emitRawScrollParam({
      unitId,
      sheetId,
      offsetX,
      offsetY,
      sheetViewStartRow,
      sheetViewStartColumn
    });
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/set-scroll.command.ts
var SetScrollRelativeCommand = {
  id: "sheet.command.set-scroll-relative",
  type: 0 /* COMMAND */,
  // offsetXY derived from mouse wheel event
  // this._commandService.executeCommand(SetScrollRelativeCommand.id, { offsetY });
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const renderManagerSrv = accessor.get(IRenderManagerService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    const scrollManagerService = renderManagerSrv.getRenderById(unitId).with(SheetScrollManagerService);
    const currentScroll = scrollManagerService.getCurrentScrollState();
    const { offsetX = 0, offsetY = 0 } = params || {};
    const {
      sheetViewStartRow = 0,
      sheetViewStartColumn = 0,
      offsetX: currentOffsetX = 0,
      offsetY: currentOffsetY = 0
    } = currentScroll || {};
    return commandService.executeCommand(SetScrollOperation.id, {
      unitId,
      sheetId: subUnitId,
      // why + ySplit? receiver - ySplit in scroll.operation.ts
      // sheetViewStartRow: sheetViewStartRow + ySplit,
      // sheetViewStartColumn: sheetViewStartColumn + xSplit,
      sheetViewStartRow,
      sheetViewStartColumn,
      offsetX: currentOffsetX + offsetX,
      // currentOffsetX + offsetX may be negative or over max
      offsetY: currentOffsetY + offsetY
    });
  }
};
var ScrollCommand = {
  id: "sheet.command.scroll-view",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const renderManagerSrv = accessor.get(IRenderManagerService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { workbook, worksheet, unitId } = target;
    const scrollManagerService = renderManagerSrv.getRenderById(unitId).with(SheetScrollManagerService);
    const currentScroll = scrollManagerService.getCurrentScrollState();
    if (!worksheet) {
      return false;
    }
    const { sheetViewStartRow, sheetViewStartColumn, offsetX, offsetY } = params;
    const {
      sheetViewStartColumn: currentColumn,
      sheetViewStartRow: currentRow,
      offsetX: currentOffsetX,
      offsetY: currentOffsetY
    } = currentScroll || {};
    const { xSplit, ySplit } = target.worksheet.getConfig().freeze;
    const commandService = accessor.get(ICommandService);
    return commandService.syncExecuteCommand(SetScrollOperation.id, {
      unitId: workbook.getUnitId(),
      sheetId: worksheet.getSheetId(),
      // why + ySplit? receiver - ySplit in scroll.operation.ts
      // sheetViewStartRow: sheetViewStartRow + ySplit,
      // sheetViewStartColumn: sheetViewStartColumn + xSplit,
      sheetViewStartRow: sheetViewStartRow != null ? sheetViewStartRow : currentRow != null ? currentRow : 0 + ySplit,
      sheetViewStartColumn: sheetViewStartColumn != null ? sheetViewStartColumn : currentColumn != null ? currentColumn : 0 + xSplit,
      offsetX: offsetX != null ? offsetX : currentOffsetX,
      offsetY: offsetY != null ? offsetY : currentOffsetY
    });
  }
};
var ScrollToCellCommand = {
  id: "sheet.command.scroll-to-cell",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const instanceService = accessor.get(IUniverInstanceService);
    const renderManagerService = accessor.get(IRenderManagerService);
    const scrollController = renderManagerService.getRenderById(instanceService.getCurrentUnitForType(O.UNIVER_SHEET).getUnitId()).with(SheetsScrollRenderController);
    return scrollController.scrollToRange(params.range, params.forceTop, params.forceLeft);
  }
};
var ResetScrollCommand = {
  id: "sheet.command.scroll-view-reset",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { subUnitId, unitId } = target;
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SetScrollOperation.id, {
      unitId,
      sheetId: subUnitId,
      sheetViewStartRow: 0,
      sheetViewStartColumn: 0
    });
  }
};

// ../packages/sheets-ui/src/controllers/auto-width.controller.ts
var createAutoColWidthUndoMutationsByRedos = (params, worksheet) => {
  const { unitId, subUnitId, ranges } = params;
  const colWidthObj = {};
  const manager = worksheet.getColumnManager();
  for (let i = 0; i < ranges.length; i++) {
    const range = ranges[i];
    for (let j = range.startColumn; j < range.endColumn + 1; j++) {
      const col = manager.getColumnOrCreate(j);
      colWidthObj[j] = col.w;
    }
  }
  return {
    unitId,
    subUnitId,
    ranges,
    colWidth: colWidthObj
  };
};
var AutoWidthController = class extends Disposable {
  constructor(_renderManagerService, _univerInstanceService) {
    super();
    this._renderManagerService = _renderManagerService;
    this._univerInstanceService = _univerInstanceService;
  }
  getUndoRedoParamsOfColWidth(params) {
    const defaultValue = { redos: [], undos: [] };
    const { _univerInstanceService: univerInstanceService } = this;
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return defaultValue;
    const { unitId, subUnitId, worksheet } = target;
    const sheetSkeletonService = this._renderManagerService.getRenderById(unitId).with(SheetSkeletonManagerService);
    if (!sheetSkeletonService.getCurrentParam()) return defaultValue;
    const { skeleton } = sheetSkeletonService.getCurrentParam();
    const colsAutoWidthInfo = skeleton.calculateAutoWidthInRange(params.ranges);
    const colWidthObject = {};
    for (const { col, width } of colsAutoWidthInfo) {
      colWidthObject[col] = width;
    }
    const redoParams = {
      subUnitId,
      unitId,
      ranges: params.ranges,
      colWidth: colWidthObject
    };
    const undoParams = createAutoColWidthUndoMutationsByRedos(redoParams, worksheet);
    return {
      undos: [
        {
          id: SetWorksheetColWidthMutation.id,
          params: undoParams
        }
      ],
      redos: [
        {
          id: SetWorksheetColWidthMutation.id,
          params: redoParams
        }
      ]
    };
  }
};
AutoWidthController = __decorateClass([
  __decorateParam(0, IRenderManagerService),
  __decorateParam(1, Inject(IUniverInstanceService))
], AutoWidthController);

// ../packages/sheets-ui/src/commands/commands/set-worksheet-auto-col-width.command.ts
var SetWorksheetColAutoWidthCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-col-auto-width",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    let ranges = [];
    if (params == null ? void 0 : params.ranges) {
      ranges = [...params.ranges];
    } else {
      const selections = selectionManagerService.getCurrentSelections();
      for (let i = 0; i < selections.length; i++) {
        ranges.push(selections[i].range);
      }
    }
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const redoMutationParams = {
      unitId,
      subUnitId,
      ranges
    };
    const { redos, undos } = accessor.get(AutoWidthController).getUndoRedoParamsOfColWidth(redoMutationParams);
    const result = sequenceExecute([...redos], commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [...undos],
        redoMutations: [...redos]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets-ui/src/services/editor-bridge.service.ts
var EditorBridgeService = class extends Disposable {
  constructor(_sheetInterceptorService, _renderManagerService, _themeService, _univerInstanceService, _editorService, _refSelectionsService, _contextService) {
    super();
    this._sheetInterceptorService = _sheetInterceptorService;
    this._renderManagerService = _renderManagerService;
    this._themeService = _themeService;
    this._univerInstanceService = _univerInstanceService;
    this._editorService = _editorService;
    this._refSelectionsService = _refSelectionsService;
    this._contextService = _contextService;
    __publicField(this, "_editorUnitId", DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
    __publicField(this, "_editorIsDirty", false);
    __publicField(this, "_isDisabled", false);
    __publicField(this, "_visible", {
      visible: false,
      eventType: 3 /* Dblclick */,
      unitId: ""
    });
    __publicField(this, "_currentEditCell", null);
    __publicField(this, "_currentEditCellState", null);
    __publicField(this, "_currentEditCellLayout", null);
    // TODO: @weird94 this should split into to subjects, documentDataModel & position
    __publicField(this, "_currentEditCellState$", new BehaviorSubject(null));
    __publicField(this, "currentEditCellState$", this._currentEditCellState$.asObservable());
    __publicField(this, "_currentEditCellLayout$", new BehaviorSubject(null));
    __publicField(this, "currentEditCellLayout$", this._currentEditCellLayout$.asObservable());
    __publicField(this, "currentEditCell$", this._currentEditCellState$.pipe(
      switchMap((editCellState) => this._currentEditCellLayout$.pipe(map((layout) => editCellState && layout ? { ...editCellState, ...layout } : null)))
    ));
    __publicField(this, "_visible$", new BehaviorSubject(this._visible));
    __publicField(this, "visible$", this._visible$.asObservable());
    __publicField(this, "_afterVisible$", new BehaviorSubject(this._visible));
    __publicField(this, "afterVisible$", this._afterVisible$.asObservable());
    __publicField(this, "_forceKeepVisible$", new BehaviorSubject(false));
    __publicField(this, "forceKeepVisible$", this._forceKeepVisible$.asObservable());
    this.disposeWithMe(toDisposable(() => {
      this._currentEditCellState$.complete();
      this._currentEditCell = null;
    }));
    this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET).subscribe((unit) => {
      var _a;
      if (unit.getUnitId() === ((_a = this._currentEditCellState) == null ? void 0 : _a.unitId)) {
        this._clearCurrentEditCellState();
      }
    });
  }
  refreshEditCellState() {
    const editCellState = this.getLatestEditCellState();
    if (!editCellState) {
      this._currentEditCellState = null;
      this._currentEditCellLayout = null;
      this._currentEditCellState$.next(null);
      this._currentEditCellLayout$.next(null);
      return;
    }
    const { position, scaleX, scaleY, canvasOffset, ...rest } = editCellState;
    this._currentEditCellState = rest;
    this._currentEditCellLayout = { position, scaleX, scaleY, canvasOffset };
    this._currentEditCellState$.next(this._currentEditCellState);
    this._currentEditCellLayout$.next(this._currentEditCellLayout);
  }
  refreshEditCellPosition(resetSizeOnly) {
    var _a;
    const currentEditCell = this._currentEditCell;
    if (currentEditCell == null) {
      return;
    }
    const currentSheet = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!currentSheet) return;
    const ru = this._renderManagerService.getRenderUnitById(currentSheet.getUnitId());
    if (!ru) return;
    const skeleton = (_a = ru.with(SheetSkeletonManagerService).getSkeletonParam(currentEditCell.sheetId)) == null ? void 0 : _a.skeleton;
    const selectionRenderService = ru.with(ISheetSelectionRenderService);
    if (!skeleton) return;
    if (!this._currentEditCellState) return;
    const { primary, unitId, sheetId, scene, engine } = currentEditCell;
    const primaryWithCoord = attachPrimaryWithCoord(skeleton, primary);
    if (primaryWithCoord == null) {
      return;
    }
    const actualRangeWithCoord = convertCellToRange(primaryWithCoord);
    const canvasOffset = getCanvasOffsetByEngine(engine);
    let { startX, startY, endX, endY } = actualRangeWithCoord;
    const { scaleX, scaleY } = scene.getAncestorScale();
    const scrollXY = scene.getViewportScrollXY(selectionRenderService.getViewPort());
    startX = convertTransformToOffsetX(startX, scaleX, scrollXY);
    startY = convertTransformToOffsetY(startY, scaleY, scrollXY);
    endX = convertTransformToOffsetX(endX, scaleX, scrollXY);
    endY = convertTransformToOffsetY(endY, scaleY, scrollXY);
    if (resetSizeOnly && this._currentEditCellLayout) {
      endX = endX - startX + this._currentEditCellLayout.position.startX;
      endY = endY - startY + this._currentEditCellLayout.position.startY;
      startX = this._currentEditCellLayout.position.startX;
      startY = this._currentEditCellLayout.position.startY;
    }
    this._currentEditCellLayout = {
      position: {
        startX,
        startY,
        endX,
        endY
      },
      canvasOffset,
      scaleX,
      scaleY
    };
    this._currentEditCellLayout$.next(this._currentEditCellLayout);
  }
  setEditCell(param) {
    this._currentEditCell = param;
    if (!this._editorService.getFocusEditor()) {
      this._editorService.focus(DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
      this._contextService.setContextValue(EDITOR_ACTIVATED, false);
      this._contextService.setContextValue(FOCUSING_EDITOR_STANDALONE, false);
    }
    const editCellState = this.getLatestEditCellState();
    if (!editCellState) {
      this._currentEditCellState = editCellState;
      this._currentEditCellLayout = editCellState;
      this._currentEditCellState$.next(editCellState);
      this._currentEditCellLayout$.next(editCellState);
      return;
    }
    const { position, canvasOffset, scaleX, scaleY, ...rest } = editCellState;
    this._currentEditCellState = rest;
    this._currentEditCellLayout = { position, canvasOffset, scaleX, scaleY };
    this._currentEditCellState$.next(this._currentEditCellState);
    this._currentEditCellLayout$.next(this._currentEditCellLayout);
  }
  _clearCurrentEditCellState() {
    this._currentEditCellState = null;
    this._currentEditCellState$.next(null);
    this._currentEditCellLayout = null;
    this._currentEditCellLayout$.next(null);
  }
  getEditCellState() {
    if (this._currentEditCellState == null || this._currentEditCellLayout == null) {
      return null;
    }
    return { ...this._currentEditCellState, ...this._currentEditCellLayout };
  }
  getEditCellLayout() {
    return this._currentEditCellLayout;
  }
  getEditLocation() {
    return this._currentEditCellState;
  }
  updateEditLocation(row, column) {
    if (this._currentEditCellState) {
      this._currentEditCellState = {
        ...this._currentEditCellState,
        row,
        column
      };
    }
  }
  // eslint-disable-next-line max-lines-per-function
  getLatestEditCellState() {
    var _a, _b, _c;
    const currentEditCell = this._currentEditCell;
    if (currentEditCell == null) return;
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return;
    const ru = this._renderManagerService.getRenderUnitById(workbook.getUnitId());
    if (!ru) return;
    const skeleton = ru.with(SheetSkeletonManagerService).getCurrentSkeleton();
    const selectionRenderService = ru.with(ISheetSelectionRenderService);
    if (!skeleton) return;
    const { primary, unitId, sheetId, scene, engine } = currentEditCell;
    const { startRow, startColumn } = primary;
    const primaryWithCoord = attachPrimaryWithCoord(skeleton, primary);
    if (primaryWithCoord == null) return;
    const actualRangeWithCoord = convertCellToRange(primaryWithCoord);
    const canvasOffset = getCanvasOffsetByEngine(engine);
    let { startX, startY, endX, endY } = actualRangeWithCoord;
    const { scaleX, scaleY } = scene.getAncestorScale();
    const scrollXY = scene.getViewportScrollXY(selectionRenderService.getViewPort());
    startX = convertTransformToOffsetX(startX, scaleX, scrollXY);
    startY = convertTransformToOffsetY(startY, scaleY, scrollXY);
    endX = convertTransformToOffsetX(endX, scaleX, scrollXY);
    endY = convertTransformToOffsetY(endY, scaleY, scrollXY);
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return;
    const location = {
      workbook,
      worksheet,
      unitId: workbook.getUnitId(),
      subUnitId: worksheet.getSheetId(),
      row: startRow,
      col: startColumn,
      origin: worksheet.getCellRaw(startRow, startColumn)
    };
    let documentLayoutObject;
    const cell = this._sheetInterceptorService.writeCellInterceptor.fetchThroughInterceptors(BEFORE_CELL_EDIT)(
      worksheet.getCell(startRow, startColumn),
      location
    );
    documentLayoutObject = cell && skeleton.getCellDocumentModelWithFormula(cell);
    const renderConfig = (_a = documentLayoutObject == null ? void 0 : documentLayoutObject.documentModel) == null ? void 0 : _a.documentStyle.renderConfig;
    if (renderConfig != null) {
      renderConfig.cellValueType = 1 /* STRING */;
    }
    if (!documentLayoutObject || documentLayoutObject.documentModel == null) {
      const blankModel = skeleton.getBlankCellDocumentModel(cell);
      if (documentLayoutObject != null) {
        const { verticalAlign, horizontalAlign, wrapStrategy, textRotation, fill } = documentLayoutObject;
        const { centerAngle, vertexAngle } = convertTextRotation(textRotation);
        blankModel.documentModel.documentStyle.renderConfig = {
          ...renderConfig,
          verticalAlign,
          horizontalAlign,
          wrapStrategy,
          background: { rgb: fill },
          centerAngle,
          vertexAngle
        };
      }
      documentLayoutObject = blankModel;
    }
    documentLayoutObject.fill = documentLayoutObject.fill || "#fff";
    (_b = documentLayoutObject.documentModel) == null ? void 0 : _b.setZoomRatio(Math.max(scaleX, scaleY));
    if ((cell == null ? void 0 : cell.isInArrayFormulaRange) === true) {
      const body = (_c = documentLayoutObject.documentModel) == null ? void 0 : _c.getBody();
      if (body) {
        body.textRuns = [
          {
            st: 0,
            ed: body.dataStream.length - 2,
            ts: {
              cl: {
                rgb: this._themeService.getCurrentTheme().textColorSecondary
              }
            }
          }
        ];
      }
    }
    return {
      position: {
        startX,
        startY,
        endX,
        endY
      },
      scaleX,
      scaleY,
      canvasOffset,
      row: startRow,
      column: startColumn,
      unitId,
      sheetId,
      documentLayoutObject,
      editorUnitId: this._editorUnitId,
      isInArrayFormulaRange: cell == null ? void 0 : cell.isInArrayFormulaRange
    };
  }
  getCurrentEditorId() {
    return this._editorUnitId;
  }
  changeVisible(param) {
    this._visible = param;
    if (param.visible) {
      this._editorIsDirty = false;
    }
    this._visible$.next(this._visible);
    this._afterVisible$.next(this._visible);
  }
  isVisible() {
    return this._visible;
  }
  enableForceKeepVisible() {
    this._forceKeepVisible$.next(true);
  }
  disableForceKeepVisible() {
    this._forceKeepVisible$.next(false);
  }
  isForceKeepVisible() {
    return this._forceKeepVisible$.getValue();
  }
  changeEditorDirty(dirtyStatus) {
    this._editorIsDirty = dirtyStatus;
  }
  getEditorDirty() {
    return this._editorIsDirty;
  }
};
EditorBridgeService = __decorateClass([
  __decorateParam(0, Inject(SheetInterceptorService)),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, Inject(ThemeService)),
  __decorateParam(3, IUniverInstanceService),
  __decorateParam(4, IEditorService),
  __decorateParam(5, IRefSelectionsService),
  __decorateParam(6, IContextService)
], EditorBridgeService);
var IEditorBridgeService = createIdentifier("univer.sheet-editor-bridge.service");

// ../packages/sheets-ui/src/controllers/render-controllers/zoom.render-controller.ts
var SheetsZoomRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _commandService, _contextService, _editorBridgeService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._commandService = _commandService;
    this._contextService = _contextService;
    this._editorBridgeService = _editorBridgeService;
    __publicField(this, "_zoom");
    this._initSkeletonListener();
    this._initZoomEventListener();
  }
  updateZoom(worksheetId, zoomRatio) {
    const worksheet = this._context.unit.getSheetBySheetId(worksheetId);
    if (!worksheet) return false;
    worksheet.getConfig().zoomRatio = zoomRatio;
    if (worksheet === this._context.unit.getActiveSheet()) {
      this._updateViewZoom(zoomRatio);
    }
    return true;
  }
  _initZoomEventListener() {
    const scene = this._getSheetObject().scene;
    this.disposeWithMe(
      // hold ctrl & mousewheel ---> zoom
      scene.onMouseWheel$.subscribeEvent((e) => {
        if (!e.ctrlKey || !this._contextService.getContextValue(FOCUSING_SHEET)) {
          return;
        }
        if (this._editorBridgeService) {
          const state = this._editorBridgeService.isVisible();
          if ((state.unitId === this._context.unitId || state.unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) && state.visible) {
            return;
          }
        }
        const deltaFactor = Math.abs(e.deltaX);
        let ratioDelta = deltaFactor < 40 ? 0.2 : deltaFactor < 80 ? 0.4 : 0.2;
        ratioDelta *= e.deltaY > 0 ? -1 : 1;
        if (scene.scaleX < 1) {
          ratioDelta /= 2;
        }
        const workbook = this._context.unit;
        const sheet = workbook.getActiveSheet();
        if (!sheet) return;
        const currentRatio = sheet.getZoomRatio();
        let nextRatio = +Number.parseFloat(`${currentRatio + ratioDelta}`).toFixed(1);
        nextRatio = nextRatio >= 4 ? 4 : nextRatio <= 0.1 ? 0.1 : nextRatio;
        this._commandService.executeCommand(SetZoomRatioCommand.id, {
          zoomRatio: Math.round(nextRatio * 10) / 10,
          unitId: workbook.getUnitId(),
          subUnitId: sheet.getSheetId()
        });
        e.preventDefault();
      })
    );
  }
  _initSkeletonListener() {
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((param) => {
      if (param == null) {
        return;
      }
      const workbook = this._context.unit;
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) return;
      const zoomRatio = worksheet.getZoomRatio() || 1;
      if (this._zoom !== zoomRatio) {
        this._updateViewZoom(zoomRatio);
      }
      this._zoom = zoomRatio;
    }));
  }
  /**
   * Triggered when zoom and switch sheet.
   * @param zoomRatio
   */
  _updateViewZoom(zoomRatio) {
    const sheetObject = this._getSheetObject();
    sheetObject == null ? void 0 : sheetObject.scene.scale(zoomRatio, zoomRatio);
    sheetObject == null ? void 0 : sheetObject.spreadsheet.makeForceDirty();
  }
  _getSheetObject() {
    return getSheetObject(this._context.unit, this._context);
  }
};
SheetsZoomRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, ICommandService),
  __decorateParam(3, IContextService),
  __decorateParam(4, Optional(IEditorBridgeService))
], SheetsZoomRenderController);

// ../packages/sheets-ui/src/commands/operations/set-zoom-ratio.operation.ts
var SetZoomRatioOperation = {
  id: "sheet.operation.set-zoom-ratio",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    const renderManagerService = accessor.get(IRenderManagerService);
    const renderUnit = renderManagerService.getRenderById(params.unitId);
    if (!renderUnit) return false;
    return renderUnit.with(SheetsZoomRenderController).updateZoom(params.subUnitId, params.zoomRatio);
  }
};

// ../packages/sheets-ui/src/commands/commands/set-zoom-ratio.command.ts
var ChangeZoomRatioCommand = {
  id: "sheet.command.change-zoom-ratio",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, subUnitId, unitId } = target;
    const { delta, reset } = params;
    let zoom = reset ? 100 : Math.round((worksheet.getConfig().zoomRatio + delta) * 100);
    zoom = Math.max(SHEET_ZOOM_RANGE[0], zoom);
    zoom = Math.min(SHEET_ZOOM_RANGE[1], zoom);
    const zoomRatio = zoom / 100;
    const editorBridgeService = accessor.get(IEditorBridgeService);
    const state = editorBridgeService.isVisible();
    if ((state.unitId === unitId || state.unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) && state.visible) return false;
    return accessor.get(ICommandService).executeCommand(SetZoomRatioOperation.id, {
      unitId,
      subUnitId,
      zoomRatio
    });
  }
};
var SetZoomRatioCommand = {
  id: "sheet.command.set-zoom-ratio",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const { unitId, subUnitId, zoomRatio } = params;
    const editorBridgeService = accessor.get(IEditorBridgeService);
    const state = editorBridgeService.isVisible();
    if ((state.unitId === unitId || state.unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) && state.visible) return false;
    return accessor.get(ICommandService).executeCommand(SetZoomRatioOperation.id, {
      unitId,
      subUnitId,
      zoomRatio
    });
  }
};

// ../packages/sheets-ui/src/services/sheet-bar/sheet-bar.service.ts
var ISheetBarService = createIdentifier("univer.sheetbar-service");
var SheetBarService = class extends Disposable {
  constructor() {
    super();
    __publicField(this, "renameId$");
    __publicField(this, "removeId$");
    __publicField(this, "scroll$");
    __publicField(this, "scrollX$");
    __publicField(this, "addSheet$");
    __publicField(this, "_renameId$");
    __publicField(this, "_removeId$");
    __publicField(this, "_scroll$");
    __publicField(this, "_scrollX$");
    __publicField(this, "_addSheet$");
    __publicField(this, "_currentHandler", null);
    this._renameId$ = new Subject();
    this.renameId$ = this._renameId$.asObservable();
    this._removeId$ = new Subject();
    this.removeId$ = this._removeId$.asObservable();
    this._scroll$ = new Subject();
    this.scroll$ = this._scroll$.asObservable();
    this._scrollX$ = new Subject();
    this.scrollX$ = this._scrollX$.asObservable();
    this._addSheet$ = new Subject();
    this.addSheet$ = this._addSheet$.asObservable();
  }
  setRenameId(renameId) {
    this._renameId$.next(renameId);
  }
  setRemoveId(removeId) {
    this._removeId$.next(removeId);
  }
  setScroll(state) {
    this._scroll$.next(state);
  }
  setScrollX(x) {
    this._scrollX$.next(x);
  }
  setAddSheet(index) {
    this._addSheet$.next(index);
  }
  triggerSheetBarMenu() {
    var _a;
    (_a = this._currentHandler) == null ? void 0 : _a.handleSheetBarMenu();
  }
  registerSheetBarMenuHandler(handler) {
    if (this._currentHandler) {
      throw new Error("There is already a context menu handler!");
    }
    this._currentHandler = handler;
    return toDisposable(() => {
      this._currentHandler = null;
    });
  }
};

// ../packages/sheets-ui/src/commands/commands/unhide.command.ts
var ShowMenuListCommand = {
  id: "ui-sheet.command.show-menu-list",
  type: 1 /* OPERATION */,
  handler: async (accessor) => {
    const sheetBarService = accessor.get(ISheetBarService);
    sheetBarService.triggerSheetBarMenu();
    return true;
  }
};

// ../packages/sheets-ui/src/commands/commands/worksheet-protection.command.ts
var DeleteWorksheetProtectionFormSheetBarCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delete-worksheet-protection-from-sheet-bar",
  async handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
    const unitId = workbook.getUnitId();
    if (!worksheet) {
      return false;
    }
    const subUnitId = worksheet.getSheetId();
    const rule = worksheetProtectionRuleModel.getRule(unitId, subUnitId);
    const result = await commandService.executeCommand(DeleteWorksheetProtectionCommand.id, {
      unitId,
      subUnitId
    });
    if (result) {
      const redoMutations = [{ id: DeleteWorksheetProtectionCommand.id, params: { unitId, subUnitId } }];
      const undoMutations = [{ id: AddWorksheetProtectionCommand.id, params: { unitId, rule } }];
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        redoMutations,
        undoMutations
      });
    }
    return true;
  }
};
var ChangeSheetProtectionFromSheetBarCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.change-sheet-protection-from-sheet-bar",
  async handler(accessor) {
    const commandService = accessor.get(ICommandService);
    await commandService.executeCommand("sheet-permission.operation.openDialog");
    return true;
  }
};

// ../packages/sheets-ui/src/commands/operations/activate-cell-edit.operation.ts
var SetActivateCellEditOperation = {
  id: "sheet.operation.set-activate-cell-edit",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    const editorBridgeService = accessor.get(IEditorBridgeService);
    editorBridgeService.setEditCell(params);
    return true;
  }
};

// ../packages/sheets-ui/src/commands/operations/cell-edit.operation.ts
var SetCellEditVisibleOperation = {
  id: "sheet.operation.set-cell-edit-visible",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const { unitId } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) {
      return false;
    }
    const editorBridgeService = accessor.get(IEditorBridgeService);
    editorBridgeService.changeVisible({
      ...params,
      unitId: unitId != null ? unitId : workbook.getUnitId()
    });
    return true;
  }
};
var SetCellEditVisibleWithF2Operation = {
  id: "sheet.operation.set-cell-edit-visible-f2",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) {
      return false;
    }
    commandService.syncExecuteCommand(SetCellEditVisibleOperation.id, {
      ...params,
      unitId: workbook.getUnitId()
    });
    return true;
  }
};
var SetCellEditVisibleArrowOperation = {
  id: "sheet.operation.set-cell-edit-visible-arrow",
  type: 1 /* OPERATION */,
  handler: () => true
};

// ../packages/sheets-ui/src/commands/operations/rename-sheet.operation.ts
var RenameSheetOperation = {
  id: "sheet.operation.rename-sheet",
  type: 1 /* OPERATION */,
  handler: async (accessor, params) => {
    const sheetBarService = accessor.get(ISheetBarService);
    if (params) {
      sheetBarService.setRenameId(params.subUnitId);
    }
    return true;
  }
};

// ../packages/sheets-ui/src/commands/operations/scroll-to-range.operation.ts
var ScrollToRangeOperation = {
  id: "sheet.operation.scroll-to-range",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const instanceService = accessor.get(IUniverInstanceService);
    const renderManagerService = accessor.get(IRenderManagerService);
    const scrollController = renderManagerService.getRenderById(instanceService.getCurrentUnitForType(O.UNIVER_SHEET).getUnitId()).with(SheetsScrollRenderController);
    return scrollController.scrollToRange(params.range, params.forceTop, params.forceLeft);
  }
};

// ../packages/sheets-ui/src/commands/operations/sheet-permission-open-dialog.operation.ts
var SheetPermissionOpenDialogOperation = {
  type: 1 /* OPERATION */,
  id: "sheet-permission.operation.openDialog",
  async handler(accessor, _params) {
    const dialogService = accessor.get(IDialogService);
    dialogService.close("DESKTOP_FIND_REPLACE_DIALOG");
    dialogService.open({
      id: UNIVER_SHEET_PERMISSION_DIALOG_ID,
      title: { title: "permission.dialog.allowedPermissionType" },
      children: { label: UNIVER_SHEET_PERMISSION_DIALOG },
      width: 393,
      destroyOnClose: true,
      onClose: () => dialogService.close(UNIVER_SHEET_PERMISSION_DIALOG_ID)
    });
    return true;
  }
};

// ../packages/sheets-ui/src/views/defined-name/component-name.ts
var DEFINED_NAME_CONTAINER = "DefinedNameContainer";

// ../packages/sheets-ui/src/commands/operations/sidebar-defined-name.operation.ts
var SidebarDefinedNameOperation = {
  id: "sidebar.operation.defined-name",
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const sidebarService = accessor.get(ISidebarService);
    const editorService = accessor.get(IEditorService);
    const localeService = accessor.get(LocaleService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { unitId } = target;
    switch (params.value) {
      case "open":
        sidebarService.open({
          id: DEFINED_NAME_CONTAINER,
          header: { title: localeService.t("definedName.featureTitle") },
          children: { label: DEFINED_NAME_CONTAINER },
          onClose: () => {
          },
          width: 333
        });
        break;
      case "close":
      default:
        sidebarService.close();
        break;
    }
    return true;
  }
};

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderDashDot.tsx
var import_jsx_runtime = __toESM(require_jsx_runtime());
var BorderDashDot = () => /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("svg", { width: "120", height: "2", viewBox: "0 0 120 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M0.98999 1.08218H-0.0100098V0.0821838H0.98999V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M5.78992 1.08218H2.78992V0.0821838H5.78992V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M7.58984 1.08218H8.58984V0.0821838H7.58984V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M14.9152 1.08218H13.9152V0.0821838H14.9152V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M16.7151 1.08218H19.7151V0.0821838H16.7151V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M22.515 1.08218H21.515V0.0821838H22.515V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M27.8405 1.08218H28.8405V0.0821838H27.8405V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M33.6404 1.08218H30.6404V0.0821838H33.6404V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M35.4403 1.08218H36.4403V0.0821838H35.4403V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M42.7657 1.08218H41.7657V0.0821838H42.7657V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M44.5657 1.08218H47.5657V0.0821838H44.5657V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M50.3656 1.08218H49.3656V0.0821838H50.3656V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M55.691 1.08218H56.691V0.0821838H55.691V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M61.491 1.08218H58.491V0.0821838H61.491V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M63.2909 1.08218H64.2909V0.0821838H63.2909V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M70.6163 1.08218H69.6163V0.0821838H70.6163V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M72.4163 1.08218H75.4163V0.0821838H72.4163V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M78.2162 1.08218H77.2162V0.0821838H78.2162V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M83.5416 1.08218H84.5416V0.0821838H83.5416V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M89.3416 1.08218H86.3416V0.0821838H89.3416V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M91.1415 1.08218H92.1415V0.0821838H91.1415V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M98.4669 1.08218H97.4669V0.0821838H98.4669V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M100.267 1.08218H103.267V0.0821838H100.267V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M106.067 1.08218H105.067V0.0821838H106.067V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M111.392 1.08218H112.392V0.0821838H111.392V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M117.192 1.08218H114.192V0.0821838H117.192V1.08218Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", { d: "M118.992 1.08218H119.992V0.0821838H118.992V1.08218Z", fill: "black" })
] });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderDashDotDot.tsx
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var BorderDashDotDot = () => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("svg", { width: "120", height: "2", viewBox: "0 0 120 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M-0.0100098 1.15771H0.98999V0.157715H-0.0100098V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M2.78992 1.15771H5.78992V0.157715H2.78992V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M8.58984 1.15771H7.58984V0.157715H8.58984V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M10.3899 1.15771H11.3899V0.157715H10.3899V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M19.0903 1.15771H18.0903V0.157715H19.0903V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M20.8903 1.15771H23.8903V0.157715H20.8903V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M26.6902 1.15771H25.6902V0.157715H26.6902V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M28.4902 1.15771H29.4902V0.157715H28.4902V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M37.1907 1.15771H36.1907V0.157715H37.1907V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M38.9906 1.15771H41.9906V0.157715H38.9906V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M44.7905 1.15771H43.7905V0.157715H44.7905V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M46.5906 1.15771H47.5906V0.157715H46.5906V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M55.291 1.15771H54.291V0.157715H55.291V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M57.0909 1.15771H60.0909V0.157715H57.0909V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M62.8909 1.15771H61.8909V0.157715H62.8909V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M64.6909 1.15771H65.6909V0.157715H64.6909V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M73.3914 1.15771H72.3914V0.157715H73.3914V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M75.1913 1.15771H78.1913V0.157715H75.1913V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M80.9912 1.15771H79.9912V0.157715H80.9912V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M82.7913 1.15771H83.7913V0.157715H82.7913V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M91.4917 1.15771H90.4917V0.157715H91.4917V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M93.2916 1.15771H96.2916V0.157715H93.2916V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M99.0916 1.15771H98.0916V0.157715H99.0916V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M100.892 1.15771H101.892V0.157715H100.892V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M109.592 1.15771H108.592V0.157715H109.592V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M111.392 1.15771H114.392V0.157715H111.392V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M117.192 1.15771H116.192V0.157715H117.192V1.15771Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { d: "M118.992 1.15771H119.992V0.157715H118.992V1.15771Z", fill: "black" })
] });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderDashed.tsx
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var BorderDashed = () => /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("svg", { width: "120", height: "2", viewBox: "0 0 120 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M-0.00842285 1.22449H2.99158V0.224487H-0.00842285V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M6.14941 1.22449H9.14941V0.224487H6.14941V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M15.3073 1.22449H12.3073V0.224487H15.3073V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M18.4651 1.22449H21.4651V0.224487H18.4651V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M27.6229 1.22449H24.6229V0.224487H27.6229V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M30.7808 1.22449H33.7808V0.224487H30.7808V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M39.9386 1.22449H36.9386V0.224487H39.9386V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M43.0964 1.22449H46.0964V0.224487H43.0964V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M52.2543 1.22449H49.2543V0.224487H52.2543V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M55.4121 1.22449H58.4121V0.224487H55.4121V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M64.5699 1.22449H61.5699V0.224487H64.5699V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M67.7278 1.22449H70.7278V0.224487H67.7278V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M76.8856 1.22449H73.8856V0.224487H76.8856V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M80.0435 1.22449H83.0435V0.224487H80.0435V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M89.2013 1.22449H86.2013V0.224487H89.2013V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M92.3591 1.22449H95.3591V0.224487H92.3591V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M101.517 1.22449H98.517V0.224487H101.517V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M104.675 1.22449H107.675V0.224487H104.675V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M113.833 1.22449H110.833V0.224487H113.833V1.22449Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", { d: "M116.99 1.22449H119.99V0.224487H116.99V1.22449Z", fill: "black" })
] });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderHair.tsx
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var BorderHair = () => /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("svg", { width: "120", height: "2", viewBox: "0 0 120 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M-0.00976562 1.65707H0.990234V0.657074H-0.00976562V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M2.32361 1.65707H3.32361V0.657074H2.32361V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M5.65698 1.65707H4.65698V0.657074H5.65698V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M6.99036 1.65707H7.99036V0.657074H6.99036V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M10.3237 1.65707H9.32373V0.657074H10.3237V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M11.6571 1.65707H12.6571V0.657074H11.6571V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M14.9905 1.65707H13.9905V0.657074H14.9905V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M16.3239 1.65707H17.3239V0.657074H16.3239V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M19.6572 1.65707H18.6572V0.657074H19.6572V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M20.9906 1.65707H21.9906V0.657074H20.9906V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M24.324 1.65707H23.324V0.657074H24.324V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M25.6573 1.65707H26.6573V0.657074H25.6573V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M28.9907 1.65707H27.9907V0.657074H28.9907V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M30.3241 1.65707H31.3241V0.657074H30.3241V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M33.6575 1.65707H32.6575V0.657074H33.6575V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M34.9908 1.65707H35.9908V0.657074H34.9908V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M38.3242 1.65707H37.3242V0.657074H38.3242V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M39.6576 1.65707H40.6576V0.657074H39.6576V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M42.991 1.65707H41.991V0.657074H42.991V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M44.3243 1.65707H45.3243V0.657074H44.3243V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M47.6577 1.65707H46.6577V0.657074H47.6577V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M48.9911 1.65707H49.9911V0.657074H48.9911V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M52.3245 1.65707H51.3245V0.657074H52.3245V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M53.6578 1.65707H54.6578V0.657074H53.6578V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M56.9912 1.65707H55.9912V0.657074H56.9912V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M58.3246 1.65707H59.3246V0.657074H58.3246V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M61.658 1.65707H60.658V0.657074H61.658V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M62.9913 1.65707H63.9913V0.657074H62.9913V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M66.3247 1.65707H65.3247V0.657074H66.3247V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M67.6581 1.65707H68.6581V0.657074H67.6581V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M70.9915 1.65707H69.9915V0.657074H70.9915V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M72.3248 1.65707H73.3248V0.657074H72.3248V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M75.6582 1.65707H74.6582V0.657074H75.6582V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M76.9916 1.65707H77.9916V0.657074H76.9916V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M80.325 1.65707H79.325V0.657074H80.325V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M81.6583 1.65707H82.6583V0.657074H81.6583V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M84.9917 1.65707H83.9917V0.657074H84.9917V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M86.3251 1.65707H87.3251V0.657074H86.3251V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M89.6584 1.65707H88.6584V0.657074H89.6584V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M90.9918 1.65707H91.9918V0.657074H90.9918V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M94.3252 1.65707H93.3252V0.657074H94.3252V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M95.6586 1.65707H96.6586V0.657074H95.6586V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M98.9919 1.65707H97.9919V0.657074H98.9919V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M100.325 1.65707H101.325V0.657074H100.325V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M103.659 1.65707H102.659V0.657074H103.659V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M104.992 1.65707H105.992V0.657074H104.992V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M108.325 1.65707H107.325V0.657074H108.325V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M109.659 1.65707H110.659V0.657074H109.659V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M112.992 1.65707H111.992V0.657074H112.992V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M114.325 1.65707H115.325V0.657074H114.325V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M117.659 1.65707H116.659V0.657074H117.659V1.65707Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: "M118.992 1.65707H119.992V0.657074H118.992V1.65707Z", fill: "black" })
] });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderMedium.tsx
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var BorderMedium = () => /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("svg", { width: "120", height: "3", viewBox: "0 0 120 3", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M119.991 2.42035H-0.0090332V0.420349H119.991V2.42035Z",
    fill: "black"
  }
) });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderMediumDashDot.tsx
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var BorderMediumDashDot = () => /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)("svg", { width: "120", height: "3", viewBox: "0 0 120 3", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M-0.0100098 2.47614H1.98999V0.476135H-0.0100098V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M3.99014 2.47614H9.99014V0.476135H3.99014V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M13.9901 2.47614H11.9901V0.476135H13.9901V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M21.1904 2.47614H23.1904V0.476135H21.1904V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M31.1906 2.47614H25.1906V0.476135H31.1906V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M33.1906 2.47614H35.1906V0.476135H33.1906V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M44.3909 2.47614H42.3909V0.476135H44.3909V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M46.391 2.47614H52.391V0.476135H46.391V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M56.391 2.47614H54.391V0.476135H56.391V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M63.5913 2.47614H65.5913V0.476135H63.5913V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M73.5915 2.47614H67.5915V0.476135H73.5915V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M75.5915 2.47614H77.5915V0.476135H75.5915V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M86.7917 2.47614H84.7917V0.476135H86.7917V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M88.7919 2.47614H94.7919V0.476135H88.7919V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M98.7919 2.47614H96.7919V0.476135H98.7919V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M105.992 2.47614H107.992V0.476135H105.992V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M115.992 2.47614H109.992V0.476135H115.992V2.47614Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", { d: "M117.992 2.47614H119.992V0.476135H117.992V2.47614Z", fill: "black" })
] });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderMediumDashDotDot.tsx
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var BorderMediumDashDotDot = () => /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("svg", { width: "120", height: "2", viewBox: "0 0 120 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M-0.0100098 2.00415H1.98999V0.00415039H-0.0100098V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M3.99014 2.00415H9.99014V0.00415039H3.99014V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M13.9901 2.00415H11.9901V0.00415039H13.9901V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M15.9901 2.00415H17.9901V0.00415039H15.9901V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M27.4905 2.00415H25.4905V0.00415039H27.4905V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M29.4906 2.00415H35.4906V0.00415039H29.4906V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M39.4906 2.00415H37.4906V0.00415039H39.4906V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M41.4906 2.00415H43.4906V0.00415039H41.4906V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M52.991 2.00415H50.991V0.00415039H52.991V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M54.9911 2.00415H60.9911V0.00415039H54.9911V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M64.9911 2.00415H62.9911V0.00415039H64.9911V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M66.9911 2.00415H68.9911V0.00415039H66.9911V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M78.4915 2.00415H76.4915V0.00415039H78.4915V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M80.4916 2.00415H86.4916V0.00415039H80.4916V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M90.4916 2.00415H88.4916V0.00415039H90.4916V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M92.4916 2.00415H94.4916V0.00415039H92.4916V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M103.992 2.00415H101.992V0.00415039H103.992V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M105.992 2.00415H111.992V0.00415039H105.992V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M115.992 2.00415H113.992V0.00415039H115.992V2.00415Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", { d: "M117.992 2.00415H119.992V0.00415039H117.992V2.00415Z", fill: "black" })
] });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderMediumDashed.tsx
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var BorderMediumDashed = () => /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)("svg", { width: "118", height: "3", viewBox: "0 0 118 3", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M-0.00854492 2.94815H1.99146V0.948151H-0.00854492V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M6.09668 2.94815H8.09668V0.948151H6.09668V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M14.2019 2.94815H12.2019V0.948151H14.2019V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M18.3071 2.94815H20.3071V0.948151H18.3071V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M26.4124 2.94815H24.4124V0.948151H26.4124V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M30.5176 2.94815H32.5176V0.948151H30.5176V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M38.6228 2.94815H36.6228V0.948151H38.6228V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M42.728 2.94815H44.728V0.948151H42.728V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M50.8333 2.94815H48.8333V0.948151H50.8333V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M54.9385 2.94815H56.9385V0.948151H54.9385V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M63.0437 2.94815H61.0437V0.948151H63.0437V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M67.1489 2.94815H69.1489V0.948151H67.1489V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M75.2542 2.94815H73.2542V0.948151H75.2542V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M79.3594 2.94815H81.3594V0.948151H79.3594V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M87.4645 2.94815H85.4645V0.948151H87.4645V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M91.5697 2.94815H93.5697V0.948151H91.5697V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M99.6749 2.94815H97.6749V0.948151H99.6749V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M103.78 2.94815H105.78V0.948151H103.78V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M111.885 2.94815H109.885V0.948151H111.885V2.94815Z", fill: "black" }),
  /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: "M115.991 2.94815H117.991V0.948151H115.991V2.94815Z", fill: "black" })
] });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderThick.tsx
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var BorderThick = () => /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("svg", { width: "120", height: "4", viewBox: "0 0 120 4", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M119.991 3.86215H-0.0090332V0.862152H119.991V3.86215Z",
    fill: "black"
  }
) });

// ../packages/sheets-ui/src/components/border-panel/border-line/icons/BorderThin.tsx
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var BorderThin = () => /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("svg", { width: "120", height: "2", viewBox: "0 0 120 2", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
  "path",
  {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M119.991 1.15668H-0.0090332V0.156677H119.991V1.15668Z",
    fill: "black"
  }
) });

// ../packages/sheets-ui/src/components/border-panel/border-line/BorderLine.tsx
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
function BorderLine(props) {
  const { type = 1 /* THIN */ } = props;
  switch (type) {
    case 5 /* DASH_DOT */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderDashDot, {});
    case 6 /* DASH_DOT_DOT */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderDashDotDot, {});
    case 4 /* DASHED */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderDashed, {});
    case 2 /* HAIR */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderHair, {});
    case 8 /* MEDIUM */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderMedium, {});
    case 10 /* MEDIUM_DASH_DOT */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderMediumDashDot, {});
    case 11 /* MEDIUM_DASH_DOT_DOT */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderMediumDashDotDot, {});
    case 9 /* MEDIUM_DASHED */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderMediumDashed, {});
    case 13 /* THICK */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderThick, {});
    case 1 /* THIN */:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderThin, {});
    default:
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BorderThin, {});
  }
}

// ../packages/sheets-ui/src/components/const.ts
var COMPONENT_PREFIX = "UI_PLUGIN_SHEETS";

// ../packages/sheets-ui/src/components/border-panel/interface.ts
var BORDER_PANEL_COMPONENT = `${COMPONENT_PREFIX}_BORDER_PANEL_COMPONENT`;
var BORDER_LINE_CHILDREN = [
  {
    label: "borderLine.borderTop",
    icon: "UpBorder",
    value: "top"
  },
  {
    label: "borderLine.borderBottom",
    icon: "DownBorder",
    value: "bottom"
  },
  {
    label: "borderLine.borderLeft",
    icon: "LeftBorder",
    value: "left"
  },
  {
    label: "borderLine.borderRight",
    icon: "RightBorder",
    value: "right"
  },
  {
    label: "borderLine.borderNone",
    icon: "NoBorderSingle",
    value: "none"
  },
  {
    label: "borderLine.borderAll",
    icon: "AllBorderSingle",
    value: "all"
  },
  {
    label: "borderLine.borderOutside",
    icon: "OuterBorder",
    value: "outside"
  },
  {
    label: "borderLine.borderInside",
    icon: "InnerBorder",
    value: "inside"
  },
  {
    label: "borderLine.borderHorizontal",
    icon: "HorizontalBorder",
    value: "horizontal"
  },
  {
    label: "borderLine.borderVertical",
    icon: "VerticalBorder",
    value: "vertical"
  },
  {
    label: "borderLine.borderTlbr",
    icon: "BackSlashSingle",
    value: "tlbr"
  },
  {
    label: "borderLine.borderTlbcTlmr",
    icon: "LeftDoubleDiagonalSingle",
    value: "tlbc_tlmr"
  },
  {
    label: "borderLine.borderTlbrTlbcTlmr",
    icon: "LeftTridiagonalSingle",
    value: "tlbr_tlbc_tlmr"
  },
  {
    label: "borderLine.borderBlTr",
    icon: "SlashSingle",
    value: "bltr"
  },
  {
    label: "borderLine.borderMltrBctr",
    icon: "RightDoubleDiagonalSingle",
    value: "mltr_bctr"
  }
];

// ../packages/sheets-ui/src/components/border-panel/BorderPanel.tsx
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var BORDER_SIZE_CHILDREN = [
  {
    label: 1 /* THIN */,
    value: 1 /* THIN */
  },
  {
    label: 2 /* HAIR */,
    value: 2 /* HAIR */
  },
  {
    label: 3 /* DOTTED */,
    value: 3 /* DOTTED */
  },
  {
    label: 4 /* DASHED */,
    value: 4 /* DASHED */
  },
  {
    label: 5 /* DASH_DOT */,
    value: 5 /* DASH_DOT */
  },
  {
    label: 6 /* DASH_DOT_DOT */,
    value: 6 /* DASH_DOT_DOT */
  },
  {
    label: 8 /* MEDIUM */,
    value: 8 /* MEDIUM */
  },
  {
    label: 9 /* MEDIUM_DASHED */,
    value: 9 /* MEDIUM_DASHED */
  },
  {
    label: 10 /* MEDIUM_DASH_DOT */,
    value: 10 /* MEDIUM_DASH_DOT */
  },
  {
    label: 11 /* MEDIUM_DASH_DOT_DOT */,
    value: 11 /* MEDIUM_DASH_DOT_DOT */
  },
  {
    label: 13 /* THICK */,
    value: 13 /* THICK */
  }
];
function BorderPanel(props) {
  var _a;
  const componentManager = useDependency(ComponentManager);
  const borderStyleManagerService = useDependency(BorderStyleManagerService);
  const { onChange, value } = props;
  function handleClick(v, type) {
    onChange == null ? void 0 : onChange({
      ...value,
      [type]: v
    });
  }
  function renderIcon(icon) {
    const Icon = componentManager.get(icon);
    return Icon && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Icon, { extend: { colorChannel1: "#2c53f1" } });
  }
  return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("section", { className: "univer-box-border univer-grid univer-gap-2 univer-p-1.5", children: [
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "univer-box-border univer-grid univer-grid-cols-5 univer-gap-2", children: BORDER_LINE_CHILDREN.map((item) => /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
      "a",
      {
        className: clsx(`
                          univer-flex univer-size-6 univer-cursor-pointer univer-items-center univer-justify-center
                          univer-justify-self-center univer-rounded
                          hover:univer-bg-gray-100
                        `, {
          "univer-bg-gray-200": borderStyleManagerService.getBorderInfo().type === item.value
        }),
        onClick: (e) => {
          e.stopPropagation();
          handleClick(item.value, "type");
        },
        children: renderIcon(item.icon)
      },
      item.value
    )) }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(Separator, {}),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { className: "univer-flex univer-items-center univer-gap-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
        Dropdown,
        {
          overlay: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "univer-rounded-lg univer-p-4", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(ColorPicker, { onChange: (value2) => handleClick(value2, "color") }) }),
          children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
            "button",
            {
              className: `
                              univer-flex univer-cursor-pointer univer-items-center univer-gap-2 univer-rounded
                              univer-border-none univer-bg-transparent univer-p-1
                              hover:univer-bg-gray-100
                            `,
              type: "button",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(paint_bucket_default, { extend: { colorChannel1: (_a = value == null ? void 0 : value.color) != null ? _a : "rgb(var(--primary-color))" } }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(more_down_single_default, { className: "univer-text-gray-400" })
              ]
            }
          )
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
        Dropdown,
        {
          overlay: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("section", { className: "univer-rounded-lg univer-p-1.5", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("ul", { className: "univer-m-0 univer-grid univer-list-none univer-gap-1 univer-p-0", children: BORDER_SIZE_CHILDREN.map((item) => /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(
            "li",
            {
              className: `
                                              univer-flex univer-cursor-pointer univer-items-center
                                              univer-justify-center univer-rounded univer-px-1 univer-py-2
                                              hover:univer-bg-gray-100
                                            `,
              onClick: () => handleClick(item.value, "style"),
              children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(BorderLine, { type: item.value })
            },
            item.value
          )) }) }),
          children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(
            "button",
            {
              className: `
                              univer-flex univer-cursor-pointer univer-items-center univer-gap-2 univer-rounded
                              univer-border-none univer-bg-transparent univer-p-1
                              hover:univer-bg-gray-100
                            `,
              type: "button",
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(BorderLine, { type: 1 /* THIN */ }),
                /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(more_down_single_default, { className: "univer-text-gray-400" })
              ]
            }
          )
        }
      ) })
    ] })
  ] });
}

// ../packages/sheets-ui/src/components/color-picker/interface.ts
var COLOR_PICKER_COMPONENT = `${COMPONENT_PREFIX}_COLOR_PICKER_COMPONENT`;

// ../packages/sheets-ui/src/components/font-family/interface.ts
var FONT_FAMILY_COMPONENT = `${COMPONENT_PREFIX}_FONT_FAMILY_COMPONENT`;
var FONT_FAMILY_ITEM_COMPONENT = `${COMPONENT_PREFIX}_FONT_FAMILY_ITEM_COMPONENT`;

// ../packages/sheets-ui/src/components/font-size/interface.ts
var FONT_SIZE_COMPONENT = `${COMPONENT_PREFIX}_FONT_SIZE_COMPONENT`;

// ../packages/sheets-ui/src/components/menu-item-input/interface.ts
var MENU_ITEM_INPUT_COMPONENT = `${COMPONENT_PREFIX}_MENU_ITEM_INPUT_COMPONENT`;

// ../packages/sheets-ui/src/components/menu-item-input/MenuItemInput.tsx
var import_react = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/components/menu-item-input/index.module.less
var index_module_default = {
  "sheetsUiContextMenuInput": "univer-sheets-ui-context-menu-input",
  "sheetsUiContextMenuInputContainer": "univer-sheets-ui-context-menu-input-container",
  "sheetsUiContextMenuInputNumber": "univer-sheets-ui-context-menu-input-number"
};

// ../packages/sheets-ui/src/components/menu-item-input/MenuItemInput.tsx
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var MenuItemInput = (props) => {
  const { prefix, suffix, value, onChange, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER } = props;
  const localeService = useDependency(LocaleService);
  const contextMenuService = useDependency(IContextMenuService);
  const [inputValue, setInputValue] = (0, import_react.useState)();
  const handleChange = (value2) => {
    var _a;
    setInputValue(value2 == null ? void 0 : value2.toString());
    onChange((_a = value2 == null ? void 0 : value2.toString()) != null ? _a : "");
  };
  (0, import_react.useEffect)(() => {
    if (!contextMenuService.visible) {
      setInputValue(value);
    }
  }, [contextMenuService.visible]);
  (0, import_react.useEffect)(() => {
    setInputValue(value);
  }, [value]);
  function handleKeyDown(e) {
    if (e.key === "Backspace") {
      e.stopPropagation();
    }
  }
  return /* @__PURE__ */ (0, import_jsx_runtime13.jsxs)("div", { className: index_module_default.sheetsUiContextMenuInput, children: [
    localeService.t(prefix),
    /* @__PURE__ */ (0, import_jsx_runtime13.jsx)("span", { className: index_module_default.sheetsUiContextMenuInputContainer, onClick: (e) => e.stopPropagation(), children: /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(
      InputNumber,
      {
        className: index_module_default.sheetsUiContextMenuInputNumber,
        value: Number(inputValue),
        precision: 0,
        onKeyDown: handleKeyDown,
        onChange: handleChange,
        min,
        max
      }
    ) }),
    localeService.t(suffix)
  ] });
};

// ../packages/sheets-ui/src/views/defined-name/DefinedNameContainer.tsx
var import_react3 = __toESM(require_react());

// ../packages/sheets-ui/src/views/defined-name/DefinedNameInput.tsx
var import_react2 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/defined-name/index.module.less
var index_module_default2 = {
  "definedNameOverlay": "univer-defined-name-overlay",
  "definedNameOverlayContainer": "univer-defined-name-overlay-container",
  "definedNameOverlayItem": "univer-defined-name-overlay-item",
  "definedNameOverlayItemName": "univer-defined-name-overlay-item-name",
  "definedNameOverlayItemNameForSheet": "univer-defined-name-overlay-item-name-for-sheet",
  "definedNameOverlayItemFormula": "univer-defined-name-overlay-item-formula",
  "definedNameOverlayManager": "univer-defined-name-overlay-manager",
  "definedNameOverlayManagerTitle": "univer-defined-name-overlay-manager-title",
  "definedNameOverlayManagerContent": "univer-defined-name-overlay-manager-content",
  "definedNameContainer": "univer-defined-name-container",
  "definedNameContainerScroll": "univer-defined-name-container-scroll",
  "definedNameContainerAddButton": "univer-defined-name-container-addButton",
  "definedNameContainerAddButtonText": "univer-defined-name-container-addButton-text",
  "definedNameContainerItem": "univer-defined-name-container-item",
  "definedNameContainerItemName": "univer-defined-name-container-item-name",
  "definedNameContainerItemNameForSheet": "univer-defined-name-container-item-name-for-sheet",
  "definedNameContainerItemFormulaOrRefString": "univer-defined-name-container-item-formula-or-refString",
  "definedNameContainerItemUpdate": "univer-defined-name-container-item-update",
  "definedNameContainerItemDelete": "univer-defined-name-container-item-delete",
  "definedNameContainerItemShow": "univer-defined-name-container-item-show",
  "definedNameInput": "univer-defined-name-input",
  "definedNameInputFormulaSelectorTextWrap": "univer-defined-name-input-formula-selector-text-wrap",
  "definedNameInputTextEditorContainer": "univer-defined-name-input-text-editor-container",
  "definedNameInputValidation": "univer-defined-name-input-validation",
  "definedNameInputDisable": "univer-defined-name-input-disable"
};

// ../packages/sheets-ui/src/views/defined-name/DefinedNameInput.tsx
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var widthStyle = {
  width: "100%"
};
var DefinedNameInput = (props) => {
  const {
    inputId,
    state = false,
    type = "range",
    confirm,
    cancel,
    name,
    formulaOrRefString,
    comment = "",
    localSheetId = SCOPE_WORKBOOK_VALUE_DEFINED_NAME,
    hidden = false,
    // excel
    id
  } = props;
  const univerInstanceService = useDependency(IUniverInstanceService);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const localeService = useDependency(LocaleService);
  const definedNamesService = useDependency(IDefinedNamesService);
  const functionService = useDependency(IFunctionService);
  const lexerTreeBuilder = useDependency(LexerTreeBuilder);
  const componentManager = useDependency(ComponentManager);
  const RangeSelector = (0, import_react2.useMemo)(() => componentManager.get(RANGE_SELECTOR_COMPONENT_KEY), []);
  const FormulaEditor = (0, import_react2.useMemo)(() => componentManager.get(EMBEDDING_FORMULA_EDITOR_COMPONENT_KEY), []);
  if (workbook == null) {
    return;
  }
  const unitId = (0, import_react2.useMemo)(() => workbook.getUnitId(), []);
  const subUnitId = (0, import_react2.useMemo)(() => workbook.getActiveSheet().getSheetId(), []);
  const [nameValue, setNameValue] = (0, import_react2.useState)(name);
  const [formulaOrRefStringValue, setFormulaOrRefStringValue] = (0, import_react2.useState)(formulaOrRefString);
  const [commentValue, setCommentValue] = (0, import_react2.useState)(comment);
  const [localSheetIdValue, setLocalSheetIdValue] = (0, import_react2.useState)(localSheetId);
  const [validString, setValidString] = (0, import_react2.useState)("");
  const [typeValue, setTypeValue] = (0, import_react2.useState)(type);
  const [validFormulaOrRange, setValidFormulaOrRange] = (0, import_react2.useState)(true);
  const options = [{
    label: localeService.t("definedName.scopeWorkbook"),
    value: SCOPE_WORKBOOK_VALUE_DEFINED_NAME
  }];
  const isFormula = (token) => {
    return !isReferenceStrings(token);
  };
  (0, import_react2.useEffect)(() => {
    setValidFormulaOrRange(true);
    setNameValue(name);
    setCommentValue(comment);
    setLocalSheetIdValue(localSheetId);
    let formulaOrRefStringCache = formulaOrRefString;
    if (formulaOrRefString.substring(0, 1) === "=" /* EQUALS */) {
      setTypeValue("formula");
    } else if (isFormula(formulaOrRefString)) {
      setTypeValue("formula");
      formulaOrRefStringCache = "=" /* EQUALS */ + formulaOrRefString;
    } else {
      setTypeValue("range");
    }
    setFormulaOrRefStringValue(formulaOrRefStringCache);
    setValidString("");
  }, [state]);
  workbook.getSheetOrders().forEach((sheetId) => {
    const sheet = workbook.getSheetBySheetId(sheetId);
    options.push({
      label: (sheet == null ? void 0 : sheet.getName()) || "",
      value: sheetId
    });
  });
  const rangeSelectorChange = (rangesText) => {
    setFormulaOrRefStringValue(rangesText);
  };
  const formulaEditorChange = (value) => {
    setFormulaOrRefStringValue(value || "");
  };
  const confirmChange = () => {
    if (nameValue.length === 0) {
      setValidString(localeService.t("definedName.nameEmpty"));
      return;
    }
    if (definedNamesService.getValueByName(unitId, nameValue) != null && (id == null || id.length === 0)) {
      setValidString(localeService.t("definedName.nameDuplicate"));
      return;
    }
    if (!Tools.isValidParameter(nameValue) || isReferenceStringWithEffectiveColumn(nameValue) || !Tools.isStartValidPosition(nameValue) && !hasCJKText(nameValue.substring(0, 1))) {
      setValidString(localeService.t("definedName.nameInvalid"));
      return;
    }
    const sheetNames = workbook.getSheetOrders().map((sheetId) => {
      var _a;
      return ((_a = workbook.getSheetBySheetId(sheetId)) == null ? void 0 : _a.getName()) || "";
    });
    if (sheetNames.includes(nameValue)) {
      setValidString(localeService.t("definedName.nameSheetConflict"));
      return;
    }
    if (formulaOrRefStringValue.length === 0) {
      setValidString(localeService.t("definedName.formulaOrRefStringEmpty"));
      return;
    }
    if (!validFormulaOrRange) {
      setValidString(localeService.t("definedName.formulaOrRefStringInvalid"));
      return;
    }
    if (functionService.hasExecutor(nameValue.toUpperCase())) {
      setValidString(localeService.t("definedName.nameConflict"));
      return;
    }
    const currentSheetName = workbook.getActiveSheet().getName();
    confirm && confirm({
      id: id || "",
      name: nameValue,
      formulaOrRefString: lexerTreeBuilder.convertRefersToAbsolute(formulaOrRefStringValue, 3 /* ALL */, 3 /* ALL */, currentSheetName),
      comment: commentValue,
      localSheetId: localSheetIdValue
    });
  };
  const typeValueChange = (value) => {
    const type2 = value;
    if (type2 === "formula") {
      if (formulaOrRefString[0] === "=" /* EQUALS */) {
        setFormulaOrRefStringValue(formulaOrRefString);
      } else {
        setFormulaOrRefStringValue(`${"=" /* EQUALS */}`);
      }
    } else {
      if (formulaOrRefString[0] === "=" /* EQUALS */) {
        setFormulaOrRefStringValue("");
      } else {
        setFormulaOrRefStringValue(formulaOrRefString);
      }
    }
    setTypeValue(type2);
  };
  const formulaEditorActionsRef = (0, import_react2.useRef)({});
  const [isFocusFormulaEditor, isFocusFormulaEditorSet] = (0, import_react2.useState)(false);
  useSidebarClick((e) => {
    var _a;
    const handleOutClick = (_a = formulaEditorActionsRef.current) == null ? void 0 : _a.handleOutClick;
    handleOutClick && handleOutClick(e, () => isFocusFormulaEditorSet(false));
  });
  return /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { className: index_module_default2.definedNameInput, style: { display: state ? "block" : "none" }, children: [
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Input, { placeholder: localeService.t("definedName.inputNamePlaceholder"), value: nameValue, allowClear: true, onChange: setNameValue, affixWrapperStyle: widthStyle }) }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)(RadioGroup, { value: typeValue, onChange: typeValueChange, children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Radio, { value: "range", children: localeService.t("definedName.ratioRange") }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Radio, { value: "formula", children: localeService.t("definedName.ratioFormula") })
    ] }) }),
    typeValue === "range" ? RangeSelector && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
      RangeSelector,
      {
        unitId,
        subUnitId,
        initialValue: formulaOrRefStringValue,
        onChange: (_, text) => rangeSelectorChange(text),
        supportAcrossSheet: true
      }
    ) : FormulaEditor && /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
      FormulaEditor,
      {
        initValue: formulaOrRefStringValue,
        unitId,
        subUnitId,
        isFocus: isFocusFormulaEditor,
        isSupportAcrossSheet: true,
        onChange: (v = "") => {
          const formula = v || "";
          formulaEditorChange(formula);
        },
        onVerify: (res) => {
          setValidFormulaOrRange(res);
        },
        onFocus: () => isFocusFormulaEditorSet(true),
        actions: formulaEditorActionsRef.current
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Select, { style: widthStyle, value: localSheetIdValue, options, onChange: setLocalSheetIdValue }) }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(Input, { affixWrapperStyle: widthStyle, placeholder: localeService.t("definedName.inputCommentPlaceholder"), value: commentValue, onChange: setCommentValue }) }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { style: { display: validString.length === 0 ? "none" : "flex" }, className: index_module_default2.definedNameInputValidation, children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("span", { children: validString }),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(error_single_default, {})
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime14.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        Button,
        {
          onClick: () => {
            cancel && cancel();
          },
          children: localeService.t("definedName.cancel")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        Button,
        {
          style: { marginLeft: 15 },
          type: "primary",
          onClick: confirmChange,
          children: localeService.t("definedName.confirm")
        }
      )
    ] })
  ] });
};

// ../packages/sheets-ui/src/views/defined-name/DefinedNameContainer.tsx
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var DefinedNameContainer = () => {
  const commandService = useDependency(ICommandService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const localeService = useDependency(LocaleService);
  const definedNamesService = useDependency(IDefinedNamesService);
  const selectionManagerService = useDependency(SheetsSelectionsService);
  if (workbook == null) {
    return;
  }
  const unitId = workbook.getUnitId();
  const getDefinedNameMap = () => {
    const definedNameMap = definedNamesService.getDefinedNameMap(unitId);
    if (definedNameMap) {
      return Array.from(Object.values(definedNameMap));
    }
    return [];
  };
  const [editState, setEditState] = (0, import_react3.useState)(false);
  const [definedNames, setDefinedNames] = (0, import_react3.useState)(getDefinedNameMap());
  const [editorKey, setEditorKey] = (0, import_react3.useState)(null);
  const [deleteConformKey, setDeleteConformKey] = (0, import_react3.useState)();
  (0, import_react3.useEffect)(() => {
    const definedNamesSubscription = definedNamesService.update$.subscribe(() => {
      setDefinedNames(getDefinedNameMap());
    });
    return () => {
      definedNamesSubscription.unsubscribe();
    };
  }, []);
  const insertConfirm = (param) => {
    const { name, formulaOrRefString, comment, localSheetId, hidden } = param;
    let id = param.id;
    if (id == null || id.length === 0) {
      id = Tools.generateRandomId(10);
      commandService.executeCommand(InsertDefinedNameCommand.id, { id, unitId, name, formulaOrRefString, comment, localSheetId, hidden });
    } else {
      const newDefinedName = { id, unitId, name, formulaOrRefString, comment, localSheetId, hidden };
      commandService.executeCommand(SetDefinedNameCommand.id, newDefinedName);
    }
    setEditState(false);
    setEditorKey(null);
  };
  const deleteDefinedName = (id) => {
    setDeleteConformKey(id);
  };
  function handleDeleteClose() {
    setDeleteConformKey(null);
  }
  function handleDeleteConfirm(id) {
    const item = definedNamesService.getValueById(unitId, id);
    commandService.executeCommand(RemoveDefinedNameCommand.id, { ...item, unitId });
    setDeleteConformKey(null);
  }
  const focusDefinedName = async (definedName) => {
    const { formulaOrRefString, id } = definedName;
    const worksheet = definedNamesService.getWorksheetByRef(unitId, formulaOrRefString);
    if (!worksheet) {
      return;
    }
    const isHidden = worksheet.isSheetHidden();
    if (isHidden) {
      await commandService.executeCommand(SetWorksheetShowCommand.id, { unitId, subUnitId: worksheet.getSheetId() });
    }
    definedNamesService.focusRange(unitId, id);
  };
  const getInsertDefinedName = () => {
    const count = definedNames.length + 1;
    const name = localeService.t("definedName.defaultName") + count;
    if (definedNamesService.getValueByName(unitId, name) == null) {
      return name;
    }
    let i = count + 1;
    while (true) {
      const newName = localeService.t("definedName.defaultName") + i;
      if (definedNamesService.getValueByName(unitId, newName) == null) {
        return newName;
      }
      i++;
    }
  };
  const getInertFormulaOrRefString = () => {
    var _a;
    const sheetName = (_a = workbook.getActiveSheet()) == null ? void 0 : _a.getName();
    if (!sheetName) {
      return "";
    }
    const selections = selectionManagerService.getCurrentSelections();
    if (selections == null) {
      return "";
    }
    const formulaOrRefs = selections.map((selection) => {
      return serializeRangeWithSheet(sheetName, selection.range);
    });
    return formulaOrRefs.join(",");
  };
  const closeInput = () => {
    setEditState(false);
    setEditorKey(null);
  };
  const openInsertCloseKeyEditor = () => {
    setEditState(true);
    setEditorKey(null);
  };
  const closeInsertOpenKeyEditor = (id) => {
    setEditState(false);
    setEditorKey(id);
  };
  const getSheetNameBySheetId = (sheetId) => {
    const sheet = workbook.getSheetBySheetId(sheetId);
    if (sheet == null) {
      return "";
    }
    return sheet.getName();
  };
  return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: index_module_default2.definedNameContainer, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: index_module_default2.definedNameContainerScroll, children: [
    /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { onClick: openInsertCloseKeyEditor, className: index_module_default2.definedNameContainerAddButton, style: { display: editState ? "none" : "flex" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(increase_single_default, {}),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { className: index_module_default2.definedNameContainerAddButtonText, children: localeService.t("definedName.addButton") })
      ] }),
      editState && /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(DefinedNameInput, { confirm: insertConfirm, cancel: closeInput, state: editState, inputId: "insertDefinedName", name: getInsertDefinedName(), formulaOrRefString: getInertFormulaOrRefString() })
    ] }, "insertDefinedName"),
    definedNames.map((definedName, index) => {
      return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { onClick: () => {
          focusDefinedName(definedName);
        }, className: index_module_default2.definedNameContainerItem, style: { display: definedName.id === editorKey ? "none" : "flex" }, children: [
          /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { title: definedName.comment, children: [
            /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)("div", { className: index_module_default2.definedNameContainerItemName, children: [
              definedName.name,
              /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("span", { className: index_module_default2.definedNameContainerItemNameForSheet, children: definedName.localSheetId === SCOPE_WORKBOOK_VALUE_DEFINED_NAME || definedName.localSheetId == null ? "" : getSheetNameBySheetId(definedName.localSheetId) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: index_module_default2.definedNameContainerItemFormulaOrRefString, children: definedName.formulaOrRefString })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { title: localeService.t("definedName.updateButton"), placement: "top", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: clsx(index_module_default2.definedNameContainerItemUpdate, index_module_default2.definedNameContainerItemShow), onClick: () => {
            closeInsertOpenKeyEditor(definedName.id);
          }, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(check_mark_single_default, {}) }) }),
          /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(Tooltip, { title: localeService.t("definedName.deleteButton"), placement: "top", children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)("div", { className: clsx(index_module_default2.definedNameContainerItemDelete, index_module_default2.definedNameContainerItemShow), onClick: () => {
            deleteDefinedName(definedName.id);
          }, children: /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(delete_single_default, {}) }) })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
          Confirm,
          {
            visible: deleteConformKey === definedName.id,
            onClose: handleDeleteClose,
            onConfirm: () => {
              handleDeleteConfirm(definedName.id);
            },
            children: localeService.t("definedName.deleteConfirmText")
          }
        ),
        definedName.id === editorKey && /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
          DefinedNameInput,
          {
            confirm: insertConfirm,
            cancel: closeInput,
            state: definedName.id === editorKey,
            id: definedName.id,
            inputId: definedName.id + index,
            name: definedName.name,
            formulaOrRefString: definedName.formulaOrRefString,
            comment: definedName.comment,
            localSheetId: definedName.localSheetId
          }
        )
      ] }, index);
    })
  ] }) });
};

// ../packages/sheets-ui/src/views/sheet-container/SheetContainer.tsx
var import_react18 = __toESM(require_react());

// ../packages/sheets-ui/src/components/hook.ts
var import_react4 = __toESM(require_react());
function useActiveWorkbook() {
  const univerInstanceService = useDependency(IUniverInstanceService);
  const workbook = useObservable(() => univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET), void 0, void 0, []);
  return workbook != null ? workbook : null;
}
function useWorkbooks() {
  const univerInstanceService = useDependency(IUniverInstanceService);
  return useObservable(() => {
    return merge([
      univerInstanceService.getTypeOfUnitAdded$(O.UNIVER_SHEET),
      univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET)
    ]).pipe(
      map(() => univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET)),
      startWith(univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET))
    );
  }, [], void 0, [univerInstanceService]);
}

// ../packages/sheets-ui/src/views/auto-fill-popup-menu/AutoFillPopupMenu.tsx
var import_react5 = __toESM(require_react());
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var useUpdate = () => {
  const [, setState] = (0, import_react5.useState)({});
  return (0, import_react5.useCallback)(() => setState((prevState) => !prevState), []);
};
var AutoFillPopupMenu = () => {
  const commandService = useDependency(ICommandService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const renderManagerService = useDependency(IRenderManagerService);
  const autoFillService = useDependency(IAutoFillService);
  const localeService = useDependency(LocaleService);
  const [menu, setMenu] = (0, import_react5.useState)([]);
  const [visible, setVisible] = (0, import_react5.useState)(false);
  const [anchor, setAnchor] = (0, import_react5.useState)({ row: -1, col: -1 });
  const [selected, setSelected] = (0, import_react5.useState)("SERIES" /* SERIES */);
  const [isHovered, setHovered] = (0, import_react5.useState)(false);
  const workbook = useActiveWorkbook();
  const { sheetSkeletonManagerService, selectionRenderService } = (0, import_react5.useMemo)(() => {
    if (workbook) {
      const ru = renderManagerService.getRenderById(workbook.getUnitId());
      return {
        sheetSkeletonManagerService: ru == null ? void 0 : ru.with(SheetSkeletonManagerService),
        selectionRenderService: ru == null ? void 0 : ru.with(ISheetSelectionRenderService)
      };
    }
    return { sheetSkeletonManagerService: null, selectionRenderService: null };
  }, [workbook, renderManagerService]);
  const handleMouseEnter = () => {
    setHovered(true);
  };
  const handleMouseLeave = () => {
    setHovered(false);
  };
  const forceUpdate = useUpdate();
  (0, import_react5.useEffect)(() => {
    const disposable = commandService.onCommandExecuted((command, options) => {
      if (command.id === SetScrollOperation.id) {
        forceUpdate();
      }
    });
    return disposable.dispose;
  }, [forceUpdate, commandService]);
  (0, import_react5.useEffect)(() => {
    const disposable = sheetSkeletonManagerService && toDisposable(
      sheetSkeletonManagerService.currentSkeleton$.subscribe((skeleton2) => {
        if (skeleton2) {
          forceUpdate();
        }
      })
    );
    return disposable == null ? void 0 : disposable.dispose;
  }, [sheetSkeletonManagerService, forceUpdate]);
  (0, import_react5.useEffect)(() => {
    const disposable = toDisposable(
      autoFillService.menu$.subscribe((menu2) => {
        setMenu(menu2.map((i) => ({ ...i, index: menu2.indexOf(i) })));
      })
    );
    return disposable.dispose;
  }, [autoFillService]);
  (0, import_react5.useEffect)(() => {
    const disposable = toDisposable(
      autoFillService.showMenu$.subscribe((show) => {
        const { source, target } = autoFillService.autoFillLocation || { source: null, target: null };
        if (show && source && target) {
          const lastRow = Math.max(source.rows[source.rows.length - 1], target.rows[target.rows.length - 1]);
          const lastCol = Math.max(source.cols[source.cols.length - 1], target.cols[target.cols.length - 1]);
          setAnchor({ row: lastRow, col: lastCol });
        } else {
          setAnchor({ row: -1, col: -1 });
        }
      })
    );
    return disposable.dispose;
  }, [autoFillService]);
  (0, import_react5.useEffect)(() => {
    const disposable = toDisposable(
      autoFillService.applyType$.subscribe((type) => {
        setSelected(type);
      })
    );
    return disposable.dispose;
  }, [autoFillService]);
  (0, import_react5.useEffect)(() => {
    function handleClose() {
      setVisible(false);
    }
    document.addEventListener("wheel", handleClose);
    return () => {
      document.removeEventListener("wheel", handleClose);
    };
  }, [visible]);
  if (anchor.col < 0 || anchor.row < 0) {
    return null;
  }
  const sheetObject = getSheetObject(univerInstanceService, renderManagerService);
  if (!sheetObject || !selectionRenderService) return null;
  const { scene } = sheetObject;
  const skeleton = sheetSkeletonManagerService == null ? void 0 : sheetSkeletonManagerService.getCurrentSkeleton();
  const viewport = selectionRenderService.getViewPort();
  const scaleX = scene == null ? void 0 : scene.scaleX;
  const scaleY = scene == null ? void 0 : scene.scaleY;
  const scrollXY = scene == null ? void 0 : scene.getViewportScrollXY(viewport);
  if (!scaleX || !scene || !scaleX || !scaleY || !scrollXY) return null;
  const x = (skeleton == null ? void 0 : skeleton.getNoMergeCellWithCoordByIndex(anchor.row, anchor.col).endX) || 0;
  const y = (skeleton == null ? void 0 : skeleton.getNoMergeCellWithCoordByIndex(anchor.row, anchor.col).endY) || 0;
  const relativeX = convertTransformToOffsetX(x, scaleX, scrollXY);
  const relativeY = convertTransformToOffsetY(y, scaleY, scrollXY);
  if (relativeX == null || relativeY == null) return null;
  const onVisibleChange = (visible2) => {
    setVisible(visible2);
  };
  const handleClick = (item) => {
    commandService.executeCommand(RefillCommand.id, { type: item.value });
    setVisible(false);
  };
  const showMore = visible || isHovered;
  const availableMenu = menu.filter((item) => !item.disable);
  return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", { className: "univer-absolute univer-inset-0 univer-z-10 univer-size-0", children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
    "div",
    {
      style: { left: `${relativeX + 2}px`, top: `${relativeY + 2}px`, position: "absolute" },
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        DropdownMenu,
        {
          align: "start",
          items: availableMenu.map((item) => ({
            type: "radio",
            value: selected,
            options: [{ label: localeService.t(item.label), value: item.value }],
            onSelect: () => handleClick(item)
          })),
          open: visible,
          onOpenChange: onVisibleChange,
          children: /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(
            "div",
            {
              className: clsx(`
                          univer-flex univer-items-center univer-gap-2 univer-rounded univer-border univer-border-solid
                          univer-border-gray-200 univer-p-1
                          hover:univer-bg-gray-100
                        `, {
                "univer-bg-gray-100": visible,
                "univer-bg-white": !visible
              }),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
                  autofill_default,
                  {
                    style: { color: "#35322B" },
                    extend: { colorChannel1: "rgb(var(--green-700, #409f11))" }
                  }
                ),
                showMore && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(more_down_single_default, { className: "univer-text-[10px] univer-text-gray-400" })
              ]
            }
          )
        }
      )
    }
  ) });
};

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/count-bar/index.module.less
var index_module_default3 = {
  "countBar": "univer-count-bar"
};

// ../packages/sheets-ui/src/views/count-bar/ZoomSlider.tsx
var import_react6 = __toESM(require_react());
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var ZOOM_MAP = [50, 75, 100, 125, 150, 175, 200, 400];
function ZoomSlider() {
  const commandService = useDependency(ICommandService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const workbook = useActiveWorkbook();
  const editorBridgeService = useDependency(IEditorBridgeService);
  const visible = useObservable(editorBridgeService.visible$);
  const getCurrentZoom = (0, import_react6.useCallback)(() => {
    if (!workbook) return 100;
    const worksheet = workbook.getActiveSheet();
    const currentZoom = worksheet && worksheet.getZoomRatio() * 100 || 100;
    return Math.round(currentZoom);
  }, [workbook]);
  const [zoom, setZoom] = (0, import_react6.useState)(() => getCurrentZoom());
  (0, import_react6.useEffect)(() => {
    setZoom(getCurrentZoom());
    const disposable = commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetZoomRatioOperation.id || commandInfo.id === SetWorksheetActiveOperation.id) {
        const currentZoom = getCurrentZoom();
        setZoom(currentZoom);
      }
    });
    return disposable.dispose;
  }, [commandService, getCurrentZoom]);
  function handleChange(value) {
    setZoom(value);
    const workbook2 = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook2 == null ? void 0 : workbook2.getActiveSheet();
    if (worksheet == null) {
      return;
    }
    const zoomRatio = value / 100;
    commandService.executeCommand(SetZoomRatioCommand.id, {
      unitId: workbook2.getUnitId(),
      subUnitId: worksheet.getSheetId(),
      zoomRatio
    });
  }
  const disabled = (visible == null ? void 0 : visible.visible) && (visible.unitId === (workbook == null ? void 0 : workbook.getUnitId()) || visible.unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY);
  return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
    Slider,
    {
      disabled,
      min: SHEET_ZOOM_RANGE[0],
      value: zoom,
      shortcuts: ZOOM_MAP,
      onChange: handleChange
    }
  );
}

// ../packages/sheets-ui/src/views/count-bar/CountBar.tsx
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
function CountBar(props) {
  return /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("section", { className: index_module_default3.countBar, children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(ZoomSlider, {}) });
}

// ../packages/sheets-ui/src/views/editor-container/EditorContainer.tsx
var import_react8 = __toESM(require_react());

// ../packages/sheets-ui/src/services/editor/cell-editor-manager.service.ts
var CellEditorManagerService = class {
  constructor() {
    __publicField(this, "_state", null);
    __publicField(this, "_rect", null);
    __publicField(this, "_state$", new BehaviorSubject(null));
    __publicField(this, "state$", this._state$.asObservable());
    __publicField(this, "_rect$", new BehaviorSubject(null));
    __publicField(this, "rect$", this._rect$.asObservable());
    __publicField(this, "_focus", false);
    __publicField(this, "_focus$", new BehaviorSubject(this._focus));
    __publicField(this, "focus$", this._focus$.asObservable());
  }
  dispose() {
    this._state$.complete();
    this._state = null;
    this._rect$.complete();
    this._rect = null;
  }
  setState(param) {
    this._state = param;
    this._refresh(param);
  }
  getRect() {
    return this._rect;
  }
  setRect(param) {
    this._rect = param;
    this._rect$.next(param);
  }
  getState() {
    return this._state;
  }
  setFocus(param = false) {
    this._focus = param;
    this._focus$.next(param);
  }
  _refresh(param) {
    this._state$.next(param);
  }
};
var ICellEditorManagerService = createIdentifier(
  "univer.sheet-cell-editor-manager.service"
);

// ../packages/sheets-ui/src/views/editor-container/hooks.ts
var import_react7 = __toESM(require_react());
function useKeyEventConfig(isRefSelecting, unitId) {
  const editorBridgeService = useDependency(IEditorBridgeService);
  const commandService = useDependency(ICommandService);
  const keyCodeConfig = (0, import_react7.useMemo)(() => ({
    keyCodes: [
      { keyCode: 13 /* ENTER */ },
      { keyCode: 27 /* ESC */ },
      { keyCode: 9 /* TAB */ }
    ],
    handler: (keycode) => {
      if (keycode === 13 /* ENTER */ || keycode === 27 /* ESC */ || keycode === 9 /* TAB */) {
        editorBridgeService.disableForceKeepVisible();
        commandService.executeCommand(SetCellEditVisibleOperation.id, {
          visible: false,
          eventType: 4 /* Keyboard */,
          keycode,
          unitId
        });
      }
    }
  }), [commandService, editorBridgeService, unitId]);
  return keyCodeConfig;
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/editor-container/index.module.less
var index_module_default4 = {
  "editorContainer": "univer-editor-container",
  "editorInput": "univer-editor-input",
  "sheetEmbeddingFormulaEditorWrap": "univer-sheet-embedding-formula-editor-wrap"
};

// ../packages/sheets-ui/src/views/editor-container/EditorContainer.tsx
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var HIDDEN_EDITOR_POSITION = -1e3;
var EDITOR_DEFAULT_POSITION = {
  width: 0,
  height: 0,
  top: HIDDEN_EDITOR_POSITION,
  left: HIDDEN_EDITOR_POSITION
};
var EditorContainer = () => {
  const [state, setState] = (0, import_react8.useState)({
    ...EDITOR_DEFAULT_POSITION
  });
  const cellEditorManagerService = useDependency(ICellEditorManagerService);
  const editorService = useDependency(IEditorService);
  const contextService = useDependency(IContextService);
  const componentManager = useDependency(ComponentManager);
  const editorBridgeService = useDependency(IEditorBridgeService);
  const visible = useObservable(editorBridgeService.visible$);
  const commandService = useDependency(ICommandService);
  const isRefSelecting = (0, import_react8.useRef)(0);
  const disableAutoFocus = useObservable(
    () => contextService.subscribeContextValue$(DISABLE_AUTO_FOCUS_KEY),
    false,
    void 0,
    [contextService, DISABLE_AUTO_FOCUS_KEY]
  );
  const FormulaEditor = componentManager.get(EMBEDDING_FORMULA_EDITOR_COMPONENT_KEY);
  const editState = editorBridgeService.getEditLocation();
  (0, import_react8.useEffect)(() => {
    const sub = cellEditorManagerService.state$.subscribe((param) => {
      if (param == null) {
        return;
      }
      const {
        startX = HIDDEN_EDITOR_POSITION,
        startY = HIDDEN_EDITOR_POSITION,
        endX = 0,
        endY = 0,
        show = false
      } = param;
      if (!show) {
        setState({
          ...EDITOR_DEFAULT_POSITION
        });
      } else {
        setState({
          width: endX - startX,
          height: endY - startY,
          left: startX,
          top: startY
        });
        const editor = editorService.getEditor(DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
        if (editor == null) {
          return;
        }
        const { left, top, width, height } = editor.getBoundingClientRect();
        cellEditorManagerService.setRect({ left, top, width, height });
      }
    });
    return () => {
      sub.unsubscribe();
    };
  }, []);
  (0, import_react8.useEffect)(() => {
    if (!disableAutoFocus) {
      cellEditorManagerService.setFocus(true);
    }
  }, [disableAutoFocus, state]);
  const handleClickSideBar = useEvent(() => {
    if (editorBridgeService.isVisible().visible) {
      commandService.executeCommand(SetCellEditVisibleOperation.id, {
        visible: false,
        eventType: 2 /* PointerUp */,
        unitId: editState == null ? void 0 : editState.unitId
      });
    }
  });
  useSidebarClick(handleClickSideBar);
  const keyCodeConfig = useKeyEventConfig(isRefSelecting, editState == null ? void 0 : editState.unitId);
  const onMoveInEditor = useEvent((keycode, metaKey) => {
    commandService.executeCommand(SetCellEditVisibleArrowOperation.id, {
      keycode,
      visible: false,
      eventType: 4 /* Keyboard */,
      isShift: metaKey === 1024 /* SHIFT */ || metaKey === (4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */),
      unitId: editState == null ? void 0 : editState.unitId
    });
  });
  return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
    "div",
    {
      className: index_module_default4.editorContainer,
      style: {
        left: state.left,
        top: state.top,
        width: state.width,
        height: state.height
      },
      children: FormulaEditor && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        FormulaEditor,
        {
          editorId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
          className: index_module_default4.editorInput,
          initValue: "",
          onChange: () => {
          },
          isFocus: visible == null ? void 0 : visible.visible,
          unitId: editState == null ? void 0 : editState.unitId,
          subUnitId: editState == null ? void 0 : editState.sheetId,
          keyboradEventConfig: keyCodeConfig,
          onMoveInEditor,
          isSupportAcrossSheet: true,
          resetSelectionOnBlur: false,
          isSingle: false,
          autoScrollbar: false,
          onFormulaSelectingChange: (isSelecting) => {
            isRefSelecting.current = isSelecting;
            if (isSelecting) {
              editorBridgeService.enableForceKeepVisible();
            } else {
              editorBridgeService.disableForceKeepVisible();
            }
          },
          disableSelectionOnClick: true,
          disableContextMenu: false
        }
      )
    }
  );
};

// ../packages/sheets-ui/src/views/formula-bar/FormulaBar.tsx
var import_react11 = __toESM(require_react());

// ../packages/sheets-ui/src/services/editor/formula-editor-manager.service.ts
var FormulaEditorManagerService = class {
  constructor() {
    __publicField(this, "_position", null);
    __publicField(this, "_position$", new BehaviorSubject(null));
    __publicField(this, "position$", this._position$.asObservable());
    __publicField(this, "_focus", false);
    __publicField(this, "_focus$", new BehaviorSubject(this._focus));
    __publicField(this, "focus$", this._focus$.asObservable());
    __publicField(this, "_fxBtnClick$", new Subject());
    __publicField(this, "fxBtnClick$", this._fxBtnClick$.asObservable());
    __publicField(this, "_foldBtnStatus$", new Subject());
    __publicField(this, "foldBtnStatus$", this._foldBtnStatus$.asObservable());
  }
  dispose() {
    this._position$.complete();
    this._focus$.complete();
    this._position = null;
    this._focus = false;
  }
  setPosition(param) {
    this._position = param;
    this._refresh(param);
  }
  getPosition() {
    return this._position;
  }
  setFocus(param = false) {
    this._focus = param;
    this._focus$.next(param);
  }
  handleFxBtnClick(params) {
    this._fxBtnClick$.next(params);
  }
  handleFoldBtnClick(params) {
    this._foldBtnStatus$.next(params);
  }
  _refresh(param) {
    this._position$.next(param);
  }
};
var IFormulaEditorManagerService = createIdentifier(
  "univer.sheet-formula-editor-manager.service"
);

// ../packages/sheets-ui/src/views/defined-name/DefinedName.tsx
var import_react10 = __toESM(require_react());

// ../packages/sheets-ui/src/views/defined-name/DefinedNameOverlay.tsx
var import_react9 = __toESM(require_react());
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
function DefinedNameOverlay(props) {
  const commandService = useDependency(ICommandService);
  const localeService = useDependency(LocaleService);
  const definedNamesService = useDependency(IDefinedNamesService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const sidebarService = useDependency(ISidebarService);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const unitId = workbook.getUnitId();
  const getDefinedNameMap = () => {
    const definedNameMap = definedNamesService.getDefinedNameMap(unitId);
    if (definedNameMap) {
      return Array.from(Object.values(definedNameMap));
    }
    return [];
  };
  const [definedNames, setDefinedNames] = (0, import_react9.useState)(getDefinedNameMap());
  (0, import_react9.useEffect)(() => {
    const definedNamesSubscription = definedNamesService.update$.subscribe(() => {
      setDefinedNames(getDefinedNameMap());
    });
    return () => {
      definedNamesSubscription.unsubscribe();
    };
  }, []);
  (0, import_react9.useEffect)(() => {
    const d = sidebarService.sidebarOptions$.subscribe((info) => {
      if (info.id === DEFINED_NAME_CONTAINER) {
        if (!info.visible) {
          setTimeout(() => {
            sidebarService.sidebarOptions$.next({ visible: false });
          });
        }
      }
    });
    return () => {
      d.unsubscribe();
    };
  }, []);
  const openSlider = () => {
    commandService.executeCommand(SidebarDefinedNameOperation.id, { value: "open" });
  };
  const focusDefinedName = async (definedName) => {
    const { formulaOrRefString, id } = definedName;
    const worksheet = definedNamesService.getWorksheetByRef(unitId, formulaOrRefString);
    if (!worksheet) {
      return;
    }
    const isHidden = worksheet.isSheetHidden();
    if (isHidden) {
      await commandService.executeCommand(SetWorksheetShowCommand.id, { unitId, subUnitId: worksheet.getSheetId() });
    }
    definedNamesService.focusRange(unitId, id);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)("div", { className: "univer-w-[300px]", children: [
    /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
      "ul",
      {
        className: `
                  univer-m-0 univer-max-h-[360px] univer-list-none univer-overflow-y-auto univer-p-0
                  univer-scrollbar-thin univer-scrollbar-track-transparent univer-scrollbar-thumb-gray-300
                  univer-scrollbar-w-[4px]
                `,
        children: definedNames.map((definedName, index) => {
          return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
            "li",
            {
              className: `
                              univer-cursor-pointer univer-px-2 univer-transition-colors univer-duration-200
                              dark:hover:univer-bg-gray-600
                              hover:univer-bg-gray-100
                            `,
              onClick: () => {
                focusDefinedName(definedName);
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(
                "div",
                {
                  className: `
                                  univer-flex univer-items-center univer-justify-between univer-gap-2 univer-border-0
                                  univer-border-b univer-border-solid univer-border-gray-200 univer-py-1
                                `,
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                      "div",
                      {
                        className: `
                                      univer-w-[50%] univer-flex-shrink-0 univer-overflow-hidden univer-text-ellipsis
                                      univer-whitespace-nowrap univer-text-sm univer-text-gray-600
                                    `,
                        title: definedName.name,
                        children: definedName.name
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
                      "div",
                      {
                        className: `
                                      univer-w-[50%] univer-flex-shrink-0 univer-overflow-hidden univer-text-ellipsis
                                      univer-whitespace-nowrap univer-text-xs univer-text-gray-400
                                    `,
                        title: definedName.formulaOrRefString,
                        children: definedName.formulaOrRefString
                      }
                    )
                  ]
                }
              )
            },
            index
          );
        })
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime20.jsxs)(
      "div",
      {
        className: `
                  univer-cursor-pointer univer-p-2 univer-transition-colors univer-duration-200
                  dark:hover:univer-bg-gray-600
                  hover:univer-bg-gray-100
                `,
        onClick: openSlider,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("div", { className: "univer-mb-2 univer-text-sm univer-font-semibold univer-text-gray-600", children: localeService.t("definedName.managerTitle") }),
          /* @__PURE__ */ (0, import_jsx_runtime20.jsx)("div", { className: "univer-text-xs univer-text-gray-400", children: localeService.t("definedName.managerDescription") })
        ]
      }
    )
  ] });
}

// ../packages/sheets-ui/src/views/defined-name/DefinedName.tsx
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
function DefinedName({ disable }) {
  const [rangeString, setRangeString] = (0, import_react10.useState)("");
  const definedNamesService = useDependency(IDefinedNamesService);
  (0, import_react10.useEffect)(() => {
    const subscription = definedNamesService.currentRange$.subscribe(() => {
      setRangeString(definedNamesService.getCurrentRangeForString());
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  function handleChangeSelection() {
  }
  return /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)(
    "div",
    {
      className: `
              univer-relative univer-box-border univer-flex univer-h-full univer-w-24 univer-border-r-gray-200
              univer-py-1.5 univer-transition-all
            `,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
          "input",
          {
            className: clsx(`
                  univer-box-border univer-h-full univer-w-full univer-appearance-none univer-border-0 univer-border-r
                  univer-border-r-gray-200 univer-px-1.5
                  focus:univer-outline-none
                `, {
              [index_module_default2.defineNameInputDisable]: disable
            }),
            type: "text",
            value: rangeString,
            onChange: handleChangeSelection
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
          Dropdown,
          {
            overlay: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("div", { className: "univer-z-[1001]", children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(DefinedNameOverlay, {}) }),
            children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
              "a",
              {
                className: clsx(`
                      univer-absolute univer-right-0 univer-top-0 univer-flex univer-h-full univer-cursor-pointer
                      univer-items-center univer-justify-center univer-px-1 univer-transition-colors univer-duration-200
                      hover:univer-bg-gray-100
                    `, {
                  "univer-cursor-not-allowed univer-text-gray-300 hover:univer-bg-transparent": disable
                }),
                children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(more_down_single_default, {})
              }
            )
          }
        )
      ]
    }
  );
}

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/formula-bar/index.module.less
var index_module_default5 = {
  "formulaBox": "univer-formula-box",
  "nameRanges": "univer-name-ranges",
  "formulaBar": "univer-formula-bar",
  "formulaIcon": "univer-formula-icon",
  "formulaIconDisable": "univer-formula-icon-disable",
  "formulaIconWrapper": "univer-formula-icon-wrapper",
  "iconContainer": "univer-icon-container",
  "iconContainerSuccess": "univer-icon-container-success",
  "formulaActive": "univer-formula-active",
  "iconContainerError": "univer-icon-container-error",
  "iconContainerFx": "univer-icon-container-fx",
  "formulaInput": "univer-formula-input",
  "formulaInputMask": "univer-formula-input-mask",
  "formulaContainer": "univer-formula-container",
  "sheetEmbeddingFormulaEditorWrap": "univer-sheet-embedding-formula-editor-wrap",
  "formulaContent": "univer-formula-content",
  "arrowContainer": "univer-arrow-container",
  "arrowContainerDisable": "univer-arrow-container-disable"
};

// ../packages/sheets-ui/src/views/formula-bar/FormulaBar.tsx
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
function FormulaBar(props) {
  var _a, _b, _c, _d;
  const { className } = props;
  const [iconStyle, setIconStyle] = (0, import_react11.useState)(index_module_default5.formulaGrey);
  const [arrowDirection, setArrowDirection] = (0, import_react11.useState)(0 /* Down */);
  const formulaEditorManagerService = useDependency(IFormulaEditorManagerService);
  const editorBridgeService = useDependency(IEditorBridgeService);
  const worksheetProtectionRuleModel = useDependency(WorksheetProtectionRuleModel);
  const rangeProtectionRuleModel = useDependency(RangeProtectionRuleModel);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const selectionManager = useDependency(SheetsSelectionsService);
  const permissionService = useDependency(IPermissionService);
  const rangeProtectionCache = useDependency(RangeProtectionCache);
  const commandService = useDependency(ICommandService);
  const [disableInfo, setDisableInfo] = (0, import_react11.useState)({
    editDisable: false,
    viewDisable: false
  });
  const [imageDisable, setImageDisable] = (0, import_react11.useState)(false);
  const currentWorkbook = useActiveWorkbook();
  const componentManager = useDependency(ComponentManager);
  const workbook = useObservable(() => univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET), void 0, void 0, []);
  const isRefSelecting = (0, import_react11.useRef)(0);
  const editState = useObservable(editorBridgeService.currentEditCellState$);
  const keyCodeConfig = useKeyEventConfig(isRefSelecting, (_a = editState == null ? void 0 : editState.unitId) != null ? _a : "");
  const FormulaEditor = componentManager.get(EMBEDDING_FORMULA_EDITOR_COMPONENT_KEY);
  const formulaAuxUIParts = useComponentsOfPart("formula-aux" /* FORMULA_AUX */);
  const contextService = useDependency(IContextService);
  useObservable((0, import_react11.useMemo)(() => contextService.subscribeContextValue$(FOCUSING_FX_BAR_EDITOR), [contextService]));
  const isFocusFxBar = contextService.getContextValue(FOCUSING_FX_BAR_EDITOR);
  const ref = (0, import_react11.useRef)(null);
  const editorService = useDependency(IEditorService);
  (0, import_react11.useLayoutEffect)(() => {
    const subscription = workbook.activeSheet$.pipe(
      switchMap((worksheet) => {
        if (!worksheet) {
          return EMPTY;
        }
        return merge(
          worksheetProtectionRuleModel.ruleChange$,
          rangeProtectionRuleModel.ruleChange$,
          selectionManager.selectionMoveEnd$,
          selectionManager.selectionSet$
        ).pipe(
          switchMap(() => {
            var _a2, _b2;
            const unitId = workbook.getUnitId();
            const subUnitId = worksheet.getSheetId();
            const range = (_a2 = selectionManager.getCurrentLastSelection()) == null ? void 0 : _a2.range;
            if (!range) return EMPTY;
            const primary = (_b2 = selectionManager.getCurrentLastSelection()) == null ? void 0 : _b2.primary;
            if (!primary) {
              return of(null);
            }
            return of({
              unitId,
              subUnitId,
              primary
            });
          })
        );
      })
    ).subscribe((cellInfo) => {
      var _a2, _b2, _c2, _d2, _e, _f;
      if (cellInfo) {
        const { unitId, subUnitId, primary } = cellInfo;
        if (worksheetProtectionRuleModel.getRule(unitId, subUnitId)) {
          const editDisable2 = !((_b2 = (_a2 = permissionService.getPermissionPoint(new WorksheetEditPermission(unitId, subUnitId).id)) == null ? void 0 : _a2.value) != null ? _b2 : true);
          const viewDisable2 = !((_d2 = (_c2 = permissionService.getPermissionPoint(new WorksheetViewPermission(unitId, subUnitId).id)) == null ? void 0 : _c2.value) != null ? _d2 : true);
          setDisableInfo({
            viewDisable: viewDisable2,
            editDisable: editDisable2
          });
          return;
        }
        const { actualRow, actualColumn } = primary;
        const cellInfoWithPermission = rangeProtectionCache.getCellInfo(unitId, subUnitId, actualRow, actualColumn);
        setDisableInfo({
          editDisable: !((_e = cellInfoWithPermission == null ? void 0 : cellInfoWithPermission[D.Edit]) != null ? _e : true),
          viewDisable: !((_f = cellInfoWithPermission == null ? void 0 : cellInfoWithPermission[D.View]) != null ? _f : true)
        });
      } else {
        setDisableInfo({
          viewDisable: false,
          editDisable: false
        });
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [workbook]);
  (0, import_react11.useEffect)(() => {
    const subscription = editorBridgeService.visible$.subscribe((visibleInfo) => {
      setIconStyle(visibleInfo.visible ? index_module_default5.formulaActive : index_module_default5.formulaGrey);
    });
    return () => subscription.unsubscribe();
  }, [editorBridgeService.visible$]);
  (0, import_react11.useEffect)(() => {
    const subscription = editorBridgeService.currentEditCellState$.subscribe((state) => {
      var _a2, _b2, _c2;
      if ((_c2 = (_b2 = (_a2 = state == null ? void 0 : state.documentLayoutObject.documentModel) == null ? void 0 : _a2.getBody()) == null ? void 0 : _b2.customBlocks) == null ? void 0 : _c2.length) {
        setImageDisable(true);
      } else {
        setImageDisable(false);
      }
    });
    return () => subscription.unsubscribe();
  }, [editorBridgeService.currentEditCellState$]);
  (0, import_react11.useEffect)(() => {
    const handleResize = () => {
      if (!ref.current) return;
      const editorRect = ref.current.getBoundingClientRect();
      formulaEditorManagerService.setPosition(editorRect);
    };
    if (ref.current) {
      handleResize();
      const a2 = new ResizeObserver(handleResize);
      a2.observe(ref.current);
      return () => a2.disconnect();
    }
  }, [formulaEditorManagerService]);
  function handleArrowClick() {
    setArrowDirection(arrowDirection === 0 /* Down */ ? 1 /* Up */ : 0 /* Down */);
    const ANIMATION_DURATION = 150;
    setTimeout(() => {
      formulaEditorManagerService.handleFoldBtnClick(arrowDirection === 1 /* Up */);
    }, ANIMATION_DURATION);
  }
  function handleCloseBtnClick() {
    var _a2;
    const visibleState = editorBridgeService.isVisible();
    if (visibleState.visible) {
      commandService.executeCommand(SetCellEditVisibleOperation.id, {
        visible: false,
        eventType: 4 /* Keyboard */,
        keycode: 27 /* ESC */,
        unitId: (_a2 = currentWorkbook == null ? void 0 : currentWorkbook.getUnitId()) != null ? _a2 : ""
      });
    }
  }
  function handleConfirmBtnClick() {
    var _a2;
    const visibleState = editorBridgeService.isVisible();
    if (visibleState.visible) {
      commandService.executeCommand(SetCellEditVisibleOperation.id, {
        visible: false,
        eventType: 1 /* PointerDown */,
        unitId: (_a2 = currentWorkbook == null ? void 0 : currentWorkbook.getUnitId()) != null ? _a2 : ""
      });
    }
  }
  function handlerFxBtnClick() {
    formulaEditorManagerService.handleFxBtnClick(true);
  }
  const { viewDisable, editDisable } = disableInfo;
  const disabled = editDisable || imageDisable;
  const shouldSkipFocus = (0, import_react11.useRef)(false);
  const handlePointerDown = () => {
    var _a2;
    try {
      const visibleState = editorBridgeService.isVisible();
      if (visibleState.visible === false) {
        commandService.syncExecuteCommand(
          SetCellEditVisibleOperation.id,
          {
            visible: true,
            eventType: 1 /* PointerDown */,
            unitId: (_a2 = currentWorkbook == null ? void 0 : currentWorkbook.getUnitId()) != null ? _a2 : ""
          }
        );
      }
      contextService.setContextValue(FOCUSING_FX_BAR_EDITOR, true);
    } catch (e) {
      shouldSkipFocus.current = true;
      throw e;
    }
  };
  const handlePointerUp = (e) => {
    if (shouldSkipFocus.current) {
      setTimeout(() => {
        editorService.blur(true);
      }, 30);
    }
    shouldSkipFocus.current = false;
  };
  const isCellImage = ((_d = (_c = (_b = editState == null ? void 0 : editState.documentLayoutObject.documentModel) == null ? void 0 : _b.getDrawingsOrder()) == null ? void 0 : _c.length) != null ? _d : 0) > 0;
  const hideEditor = isCellImage || viewDisable;
  return /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)(
    "div",
    {
      className: clsx(index_module_default5.formulaBox, className),
      style: {
        height: 0 /* Down */ === arrowDirection ? "28px" : "82px",
        pointerEvents: editDisable ? "none" : "auto"
      },
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: index_module_default5.nameRanges, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(DefinedName, { disable: editDisable }) }),
        /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: index_module_default5.formulaBar, children: [
          /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: clsx(index_module_default5.formulaIcon, { [index_module_default5.formulaIconDisable]: disabled }), children: /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: index_module_default5.formulaIconWrapper, children: [
            /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
              "span",
              {
                className: clsx(index_module_default5.iconContainer, index_module_default5.iconContainerError, iconStyle),
                onClick: handleCloseBtnClick,
                children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(close_single_default, {})
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
              "span",
              {
                className: clsx(index_module_default5.iconContainer, index_module_default5.iconContainerSuccess, iconStyle),
                onClick: handleConfirmBtnClick,
                children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(check_mark_single_default, {})
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("span", { className: clsx(index_module_default5.iconContainer, index_module_default5.iconContainerFx), onClick: handlerFxBtnClick, children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(fx_single_default, {}) })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("div", { className: index_module_default5.formulaContainer, children: [
            /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)(
              "div",
              {
                className: index_module_default5.formulaInput,
                onPointerDown: handlePointerDown,
                onPointerUp: handlePointerUp,
                ref,
                style: { pointerEvents: hideEditor ? "none" : "auto" },
                children: [
                  FormulaEditor && /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
                    FormulaEditor,
                    {
                      disableSelectionOnClick: true,
                      editorId: DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
                      initValue: "",
                      onChange: () => {
                      },
                      isFocus: isFocusFxBar,
                      className: index_module_default5.formulaContent,
                      unitId: editState == null ? void 0 : editState.unitId,
                      subUnitId: editState == null ? void 0 : editState.sheetId,
                      isSupportAcrossSheet: true,
                      resetSelectionOnBlur: false,
                      isSingle: false,
                      keyboradEventConfig: keyCodeConfig,
                      onFormulaSelectingChange: (isSelecting) => {
                        isRefSelecting.current = isSelecting;
                        if (isSelecting) {
                          editorBridgeService.enableForceKeepVisible();
                        } else {
                          editorBridgeService.disableForceKeepVisible();
                        }
                      },
                      autoScrollbar: false,
                      disableContextMenu: false
                    }
                  ),
                  hideEditor ? /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: index_module_default5.formulaInputMask }) : null
                ]
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("div", { className: clsx(index_module_default5.arrowContainer, { [index_module_default5.arrowContainerDisable]: editDisable }), onClick: handleArrowClick, children: arrowDirection === 0 /* Down */ ? /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(dropdown_single_default, {}) : /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(dropdown_single_default, { style: { transform: "rotateZ(180deg)" } }) })
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ComponentContainer, { components: formulaAuxUIParts }, "formula-aux")
      ]
    }
  );
}

// ../packages/sheets-ui/src/views/sheet-bar/SheetBar.tsx
var import_react16 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/sheet-bar/index.module.less
var index_module_default6 = {
  "sheetBar": "univer-sheet-bar",
  "sheetBarOptions": "univer-sheet-bar-options",
  "sheetBarOptionsDivider": "univer-sheet-bar-options-divider"
};

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/sheet-bar/sheet-bar-button/index.module.less
var index_module_default7 = {
  "sheetBarBtn": "univer-sheet-bar-btn"
};

// ../packages/sheets-ui/src/views/sheet-bar/sheet-bar-button/SheetBarButton.tsx
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
function SheetBarButton(props) {
  const { children, className, style, disabled = false, onClick, ...restProps } = props;
  const handleClick = (e) => {
    if (disabled) {
      e.preventDefault();
      return;
    }
    onClick && onClick(e);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(
    "button",
    {
      type: "button",
      className: index_module_default7.sheetBarBtn,
      style,
      disabled,
      onClick: handleClick,
      ...restProps,
      children
    }
  );
}

// ../packages/sheets-ui/src/views/sheet-bar/sheet-bar-menu/SheetBarMenu.tsx
var import_react12 = __toESM(require_react());
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
function SheetBarMenu() {
  const [menu, setMenu] = (0, import_react12.useState)([]);
  const [visible, setVisible] = (0, import_react12.useState)(false);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const commandService = useDependency(ICommandService);
  const sheetBarService = useDependency(ISheetBarService);
  const worksheetProtectionRuleModel = useDependency(WorksheetProtectionRuleModel);
  const workbook = useObservable(() => univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET), null, false, []);
  const handleClick = (item) => {
    const { sheetId } = item;
    if (!sheetId || !workbook) return;
    if (item.hidden) {
      commandService.executeCommand(SetWorksheetShowCommand.id, {
        unitId: workbook.getUnitId(),
        subUnitId: sheetId,
        value: sheetId
      });
    } else if (!item.selected) {
      commandService.executeCommand(SetWorksheetActivateCommand.id, {
        unitId: workbook.getUnitId(),
        subUnitId: sheetId
      });
    }
    setVisible(false);
  };
  const statusInit = (0, import_react12.useCallback)(() => {
    if (!workbook) return;
    const sheets = workbook.getSheets();
    const activeSheet = workbook.getActiveSheet();
    const worksheetMenuItems = sheets.map((sheet, index) => {
      return {
        label: sheet.getName(),
        index: `${index}`,
        sheetId: sheet.getSheetId(),
        hidden: sheet.isSheetHidden() === 1 /* TRUE */,
        selected: activeSheet === sheet
      };
    });
    setMenu(worksheetMenuItems);
  }, [workbook, worksheetProtectionRuleModel]);
  const setupStatusUpdate = (0, import_react12.useCallback)(() => commandService.onCommandExecuted((commandInfo) => {
    switch (commandInfo.id) {
      case SetWorksheetHideMutation.id:
      case RemoveSheetMutation.id:
      case SetWorksheetNameMutation.id:
      case InsertSheetMutation.id:
      case SetWorksheetOrderMutation.id:
      case SetWorksheetActiveOperation.id:
        statusInit();
        break;
      default:
        break;
    }
  }), [commandService, statusInit]);
  function handleSheetBarMenu() {
    setVisible(true);
  }
  const onVisibleChange = (visible2) => {
    setVisible(visible2);
  };
  (0, import_react12.useEffect)(() => {
    statusInit();
    const disposables = new DisposableCollection();
    disposables.add(setupStatusUpdate());
    disposables.add(sheetBarService.registerSheetBarMenuHandler({ handleSheetBarMenu }));
    return () => disposables.dispose();
  }, [setupStatusUpdate, sheetBarService, statusInit, workbook]);
  const items = (0, import_react12.useMemo)(() => menu.map((item) => ({
    type: "item",
    children: /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "univer-relative univer-box-border univer-pl-6", children: [
      (item.selected || item.hidden) && /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("span", { className: "univer-absolute univer-left-1 univer-top-0.5", children: [
        item.selected && /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(check_mark_single_default, { className: "univer-size-4 univer-text-primary-600" }),
        item.hidden && /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(eyelash_single_default, { className: "univer-size-4 univer-text-gray-400" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
        "span",
        {
          className: clsx({
            "univer-text-primary-600": item.selected
          }),
          children: item.label
        }
      )
    ] }),
    onSelect: () => {
      handleClick(item);
    }
  })), [menu]);
  return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
    DropdownMenu,
    {
      align: "start",
      items,
      open: visible,
      onOpenChange: onVisibleChange,
      children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(SheetBarButton, { children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(convert_single_default, {}) }) })
    }
  );
}

// ../packages/sheets-ui/src/views/sheet-bar/sheet-bar-tabs/SheetBarTabs.tsx
var import_react14 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/sheet-bar/sheet-bar-tabs/index.module.less
var index_module_default8 = {
  "slideTabBarContainer": "univer-slide-tab-bar-container",
  "slideTabBar": "univer-slide-tab-bar",
  "slideTabItem": "univer-slide-tab-item",
  "slideTabActive": "univer-slide-tab-active",
  "slideTabDiv": "univer-slide-tab-div",
  "slideTabDivEdit": "univer-slide-tab-div-edit",
  "slideTabItemDropdown": "univer-slide-tab-item-dropdown"
};

// ../packages/sheets-ui/src/views/sheet-bar/sheet-bar-tabs/SheetBarItem.tsx
var import_react13 = __toESM(require_react());
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
function SheetBarItem(props) {
  const { sheetId, label, color, selected } = props;
  const [currentSelected, setCurrentSelected] = (0, import_react13.useState)(selected);
  const themeService = useDependency(ThemeService);
  (0, import_react13.useEffect)(() => {
    setCurrentSelected(selected);
  }, [selected]);
  const getTextColor = (color2) => {
    const theme = themeService.getCurrentTheme();
    const darkTextColor = theme.textColor;
    const lightTextColor = theme.colorWhite;
    return new ColorKit(color2).isDark() ? lightTextColor : darkTextColor;
  };
  return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
    "div",
    {
      "data-id": sheetId,
      className: currentSelected ? `
                  ${index_module_default8.slideTabActive}
                  ${index_module_default8.slideTabItem}
                ` : index_module_default8.slideTabItem,
      style: {
        backgroundColor: !currentSelected && color ? color : "",
        color: !currentSelected && color ? getTextColor(color) : "",
        boxShadow: currentSelected && color ? `0px 0px 8px rgba(0, 0, 0, 0.08), inset 0px -2px 0px 0px ${color}` : ""
      },
      children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("div", { className: index_module_default8.slideTabDiv, children: label })
    },
    sheetId
  );
}

// ../packages/sheets-ui/src/views/sheet-bar/sheet-bar-tabs/utils/animate.ts
var Tween = {
  easeOutStrong(t, b, c, d) {
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  },
  backOut(t, b, c, d, s) {
    if (typeof s === "undefined") {
      s = 0.7;
    }
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  }
};
var CONFIG = {
  loop: false,
  begin: 0,
  end: 0,
  duration: 300,
  delay: 0,
  type: "easeOutStrong",
  receive(v) {
  },
  success(v) {
  },
  cancel(v) {
  },
  complete(v) {
  }
};
var Animate = class {
  constructor(config) {
    __publicField(this, "_config");
    __publicField(this, "_status", 0 /* Request */);
    __publicField(this, "_start", 0);
    __publicField(this, "_handle", 0);
    __publicField(this, "_delayHandle", null);
    this._config = {
      ...CONFIG,
      ...config
    };
    if (this._config.loop) {
      this._config.complete = () => {
      };
      this._config.success = () => {
        this.request();
      };
    }
  }
  static success(...animates) {
    let successNumber = 0;
    return new Promise((resolve) => {
      for (let i = 0; i < animates.length; i++) {
        const animate = animates[i];
        const config = animate._config;
        const success = config.success;
        const loop = config.loop;
        if (loop) {
          continue;
        }
        config.success = (v) => {
          successNumber++;
          if (success) {
            success.call(animate, v);
          }
          if (successNumber === animates.length) {
            resolve();
          }
        };
      }
    });
  }
  request() {
    if (this._config.delay === 0) {
      this._status = 0 /* Request */;
      this._start = Date.now();
      this._fakeHandle();
    } else {
      this._delayHandle && clearTimeout(this._delayHandle);
      this._delayHandle = setTimeout(() => {
        this._status = 0 /* Request */;
        this._start = Date.now();
        this._fakeHandle();
      }, this._config.delay);
    }
  }
  cancel() {
    this._status = 1 /* Cancel */;
    this._delayHandle && clearTimeout(this._delayHandle);
    cancelAnimationFrame(this._handle);
  }
  _fakeHandle() {
    let times = Date.now() - this._start;
    times = times >= this._config.duration ? this._config.duration : times;
    const val = Tween[this._config.type](
      times,
      this._config.begin,
      this._config.end - this._config.begin,
      this._config.duration,
      0.7
    );
    const fix = val.toFixed(2);
    this._config.receive(fix);
    if (this._status === 1 /* Cancel */) {
      this._config.cancel(fix);
      this._config.complete(fix);
      return;
    }
    if (times === this._config.duration) {
      this._config.success(fix);
      this._config.complete(fix);
      return;
    }
    this._handle = requestAnimationFrame(() => {
      this._fakeHandle();
    });
  }
};

// ../packages/sheets-ui/src/views/sheet-bar/sheet-bar-tabs/utils/slide-tab-bar.ts
var SlideTabItem = class _SlideTabItem {
  constructor(slideTabItem, slideTabBar) {
    __publicField(this, "_slideTabItem");
    __publicField(this, "_animate");
    __publicField(this, "_midline", 0);
    __publicField(this, "_translateX");
    __publicField(this, "_scrollbar");
    __publicField(this, "_slideTabBar");
    __publicField(this, "_editMode");
    __publicField(this, "_placeholder");
    this._slideTabItem = slideTabItem;
    this._animate = null;
    this._translateX = 0;
    this._editMode = false;
    this._slideTabBar = slideTabBar;
    this._placeholder = null;
    this._scrollbar = slideTabBar.getScrollbar();
    this.update();
  }
  static midline(item) {
    return item.getBoundingRect().x + item.getBoundingRect().width / 2;
  }
  static leftLine(item) {
    return item.getBoundingRect().x;
  }
  static rightLine(item) {
    return item.getBoundingRect().x + item.getBoundingRect().width;
  }
  static make(nodeList, slideTabBar) {
    const result = [];
    nodeList.forEach((item) => result.push(new _SlideTabItem(item, slideTabBar)));
    return result;
  }
  getSlideTabItem() {
    return this._slideTabItem;
  }
  getEditor() {
    return this._slideTabItem.querySelector("span");
  }
  focus() {
    var _a;
    (_a = this.getEditor()) == null ? void 0 : _a.focus();
  }
  selectAll() {
    const input = this.getEditor();
    input && SlideTabBar.keepSelectAll(input);
  }
  isEditMode() {
    return this._editMode;
  }
  classList() {
    return this._slideTabItem.classList;
  }
  translateX(x) {
    this._translateX = x;
    this._slideTabItem.style.transform = `translateX(${x}px)`;
    return this.getTranslateXDirection();
  }
  setEditor(callback) {
    if (!this._slideTabBar.getConfig().onNameChangeCheck()) {
      return;
    }
    let compositionFlag = true;
    if (this._editMode === false) {
      const input = this._slideTabItem.querySelector("span");
      const blurAction = (focusEvent) => {
        if (this.nameCheck()) return;
        this._editMode = false;
        if (input) {
          input.removeAttribute("contentEditable");
          input.removeEventListener("focusout", blurAction);
          input.removeEventListener("compositionstart", compositionstartAction);
          input.removeEventListener("compositionend", compositionendAction);
          input.removeEventListener("input", inputAction);
          input.removeEventListener("keydown", keydownAction);
          input.classList.remove(this._slideTabBar.getConfig().slideTabBarSpanEditClassName);
        }
        this._slideTabBar.removeListener();
        this._slideTabBar.updateItems();
        if (this._slideTabBar.getConfig().onChangeName) {
          const text = (input == null ? void 0 : input.innerText) || "";
          const id = this.getId();
          this._slideTabBar.getConfig().onChangeName(id, text);
        }
        if (callback) {
          callback(focusEvent);
        }
      };
      let keydownAction = (e) => {
        if (!input) return;
        e.stopPropagation();
        if (e.key === "Enter") {
          input.blur();
        }
      };
      const compositionstartAction = (e) => {
        compositionFlag = false;
      };
      const compositionendAction = (e) => {
        compositionFlag = true;
      };
      const inputAction = (e) => {
        if (!input) return;
        const maxLength = 31;
        setTimeout(() => {
          if (compositionFlag) {
            const text = input.innerText;
            if (text.length > maxLength) {
              input.innerText = text.substring(0, maxLength);
              SlideTabBar.keepLastIndex(input);
            }
          }
        }, 0);
      };
      if (input) {
        input.setAttribute("contentEditable", "true");
        input.addEventListener("focusout", blurAction);
        input.addEventListener("compositionstart", compositionstartAction);
        input.addEventListener("compositionend", compositionendAction);
        input.addEventListener("input", inputAction);
        input.addEventListener("keydown", keydownAction);
        input.classList.add(this._slideTabBar.getConfig().slideTabBarSpanEditClassName);
        this._editMode = true;
        SlideTabBar.keepSelectAll(input);
      }
    }
  }
  nameCheck() {
    const input = this._slideTabItem.querySelector("span");
    if (!input) return false;
    const text = input.innerText;
    const checkAlert = this._slideTabBar.getConfig().onNameCheckAlert(text);
    return checkAlert;
  }
  animate() {
    return {
      translateX: (x) => {
        if (this._translateX !== x) {
          if (this._animate) {
            this._animate.cancel();
            this._animate = null;
          }
          this._animate = new Animate({
            begin: this._translateX,
            end: x,
            receive: (val) => {
              this._slideTabItem.style.transform = `translateX(${val}px)`;
            }
          });
          this._translateX = x;
          this._animate.request();
        }
      },
      cancel: () => {
        if (this._animate) {
          this._animate.cancel();
          this._animate = null;
        }
      }
    };
  }
  after(other) {
    this._slideTabItem.after(other._slideTabItem || other);
  }
  update() {
    this._midline = _SlideTabItem.midline(this);
  }
  disableFixed() {
    if (this._placeholder) {
      const primeval = this._slideTabBar.primeval();
      this._slideTabItem.style.removeProperty("position");
      this._slideTabItem.style.removeProperty("left");
      this._slideTabItem.style.removeProperty("top");
      this._slideTabItem.style.removeProperty("width");
      this._slideTabItem.style.removeProperty("height");
      this._slideTabItem.style.removeProperty("background");
      this._slideTabItem.style.removeProperty("padding");
      this._slideTabItem.style.removeProperty("box-sizing");
      this._slideTabItem.style.removeProperty("font-size");
      this._slideTabItem.style.removeProperty("font-family");
      this._slideTabItem.style.removeProperty("font-weight");
      this._slideTabItem.style.removeProperty("color");
      this._slideTabItem.style.removeProperty("border-radius");
      this._placeholder.after(this._slideTabItem);
      primeval.removeChild(this._placeholder);
      this._placeholder = null;
    }
  }
  enableFixed() {
    const placeholder = document.createElement("div");
    const boundingRect = this.getBoundingRect();
    const computedStyles = getComputedStyle(this._slideTabItem);
    const innerSpan = this._slideTabItem.querySelector("span");
    this._placeholder = placeholder;
    this._placeholder.style.width = `${boundingRect.width}px`;
    this._placeholder.style.height = `${boundingRect.height}px`;
    this._placeholder.style.flexShrink = "0";
    this._placeholder.style.margin = computedStyles.margin;
    this._slideTabItem.style.background = computedStyles.background;
    if (innerSpan) {
      const innerPadding = getComputedStyle(innerSpan).padding;
      this._slideTabItem.style.padding = innerPadding;
    }
    this._slideTabItem.style.boxSizing = computedStyles.boxSizing;
    this._slideTabItem.style.fontSize = computedStyles.fontSize;
    this._slideTabItem.style.fontFamily = computedStyles.fontFamily;
    this._slideTabItem.style.fontWeight = computedStyles.fontWeight;
    this._slideTabItem.style.color = computedStyles.color;
    this._slideTabItem.style.borderRadius = computedStyles.borderRadius;
    this._slideTabItem.style.left = `${boundingRect.x - this.getScrollbar().getScrollX()}px`;
    this._slideTabItem.style.top = `${boundingRect.y}px`;
    this._slideTabItem.style.width = `${boundingRect.width}px`;
    this._slideTabItem.style.height = `${boundingRect.height}px`;
    this._slideTabItem.style.position = "fixed";
    this._slideTabItem.after(placeholder);
    document.body.appendChild(this._slideTabItem);
  }
  addEventListener(type, action, options) {
    this._slideTabItem.addEventListener(type, action, options);
  }
  removeEventListener(type, action, options) {
    this._slideTabItem.removeEventListener(type, action, options);
  }
  getScrollbar() {
    return this._scrollbar;
  }
  getMidLine() {
    return this._midline;
  }
  getBoundingRect() {
    const boundingClientRect = this._slideTabItem.getBoundingClientRect();
    boundingClientRect.x += this._scrollbar.getScrollX();
    return boundingClientRect;
  }
  getWidth() {
    return this.getBoundingRect().width;
  }
  getTranslateXDirection() {
    const midline = _SlideTabItem.midline(this);
    return midline > this._midline ? 1 : midline < this._midline ? -1 : 0;
  }
  equals(other) {
    return other && other._slideTabItem === this._slideTabItem;
  }
  getId() {
    return this._slideTabItem.dataset.id || "";
  }
};
var SlideScrollbar = class {
  constructor(slideTabBar) {
    __publicField(this, "_slideTabBar");
    __publicField(this, "_scrollX");
    const primeval = slideTabBar.primeval();
    this._scrollX = primeval.scrollLeft;
    this._slideTabBar = slideTabBar;
  }
  scrollX(x) {
    const primeval = this._slideTabBar.primeval();
    primeval.scrollLeft = x;
    this._scrollX = primeval.scrollLeft;
  }
  scrollRight() {
    const primeval = this._slideTabBar.primeval();
    primeval.scrollLeft = primeval.scrollWidth;
    this._scrollX = primeval.scrollLeft;
  }
  getScrollX() {
    return this._scrollX;
  }
};
var _SlideTabBar = class _SlideTabBar {
  // eslint-disable-next-line max-lines-per-function
  constructor(config) {
    // in milliseconds
    __publicField(this, "_activeTabItemIndex", 0);
    __publicField(this, "_slideTabBar");
    __publicField(this, "_slideTabItems", []);
    __publicField(this, "_config");
    __publicField(this, "_downActionX", 0);
    __publicField(this, "_moveActionX", 0);
    __publicField(this, "_compareIndex", 0);
    __publicField(this, "_activeTabItem", null);
    __publicField(this, "_moveAction");
    __publicField(this, "_upAction");
    __publicField(this, "_downAction");
    __publicField(this, "_wheelAction");
    __publicField(this, "_scrollIncremental", 0);
    __publicField(this, "_compareDirection", 0);
    __publicField(this, "_autoScrollTime", null);
    __publicField(this, "_slideScrollbar");
    __publicField(this, "_longPressTimer", null);
    /**
     * left border line
     */
    __publicField(this, "_leftBoundingLine", 0);
    /**
     * right border line
     */
    __publicField(this, "_rightBoundingLine", 0);
    /**
     * The distance required to move to the left border
     */
    __publicField(this, "_leftMoveX", 0);
    /**
     * The distance required to move to the right border
     */
    __publicField(this, "_rightMoveX", 0);
    var _a;
    if (config.slideTabBarContainer == null) {
      throw new Error("not found slide-tab-bar root element");
    }
    const slideTabBar = config.slideTabBarContainer.querySelector(
      `.${(_a = config.slideTabBarClassName) != null ? _a : "slide-tab-bar"}`
    );
    if (slideTabBar == null) {
      throw new Error("not found slide-tab-bar");
    }
    this._slideTabBar = slideTabBar;
    this._slideScrollbar = new SlideScrollbar(this);
    this._config = config;
    this._initConfig();
    let lastPageX = 0;
    let lastPageY = 0;
    let lastTime = 0;
    this._downAction = (downEvent) => {
      var _a2, _b, _c, _d, _e, _f;
      if ((_a2 = this._activeTabItem) == null ? void 0 : _a2.isEditMode()) {
        return;
      }
      if (this._longPressTimer) {
        clearTimeout(this._longPressTimer);
        this._longPressTimer = null;
      }
      const slideItemId = (_c = (_b = downEvent.target) == null ? void 0 : _b.closest(`.${config.slideTabBarItemClassName}`)) == null ? void 0 : _c.getAttribute("data-id");
      const slideItemIndex = this._slideTabItems.findIndex((item) => item.getId() === slideItemId);
      if (slideItemId == null || slideItemIndex === -1) return;
      if (this._activeTabItemIndex !== slideItemIndex) {
        (_d = this._activeTabItem) == null ? void 0 : _d.removeEventListener("pointermove", this._moveAction);
        (_e = this._activeTabItem) == null ? void 0 : _e.removeEventListener("pointerup", this._upAction);
        this.removeListener();
        this._config.onChangeTab(downEvent, slideItemId);
        return;
      }
      this._compareIndex = slideItemIndex;
      this._downActionX = downEvent.pageX;
      this._moveActionX = 0;
      this._scrollIncremental = 0;
      this._activeTabItem = this._slideTabItems[slideItemIndex];
      if (!this._activeTabItem) {
        console.error("Not found active slide-tab-item in sheet bar");
        return;
      }
      const activeSlideItemElement = this._activeTabItem.getSlideTabItem();
      activeSlideItemElement == null ? void 0 : activeSlideItemElement.setPointerCapture(downEvent.pointerId);
      (_f = this._activeTabItem) == null ? void 0 : _f.addEventListener("pointerup", this._upAction);
      const { x, width } = this._activeTabItem.getBoundingRect();
      const { x: containerX, width: containerWidth } = this.getBoundingRect();
      const scrollX = this._slideScrollbar.getScrollX();
      this._leftBoundingLine = this._downActionX - (x - scrollX);
      this._rightBoundingLine = x - scrollX + width - this._downActionX;
      this._leftMoveX = x - containerX - scrollX;
      this._rightMoveX = containerX + containerWidth - (x + width) + scrollX;
      if (downEvent.button === 2 || this._hasEditItem()) {
        return;
      }
      const { pageX, pageY } = downEvent;
      const current = Date.now();
      const diffTime = current - lastTime <= _SlideTabBar.DoubleClickDelay;
      const diffPageX = Math.abs(pageX - lastPageX) < 10;
      const diffPageY = Math.abs(pageY - lastPageY) < 10;
      if (diffTime && diffPageX && diffPageY) {
        this._activeTabItem.setEditor();
      }
      lastPageX = pageX;
      lastPageY = pageY;
      lastTime = current;
      this._longPressTimer = setTimeout(() => {
        var _a3, _b2, _c2;
        if (!activeSlideItemElement || ((_a3 = this._activeTabItem) == null ? void 0 : _a3.isEditMode())) return;
        (_b2 = this._activeTabItem) == null ? void 0 : _b2.enableFixed();
        this._startAutoScroll();
        activeSlideItemElement.setPointerCapture(downEvent.pointerId);
        activeSlideItemElement.style.cursor = "move";
        (_c2 = this._activeTabItem) == null ? void 0 : _c2.addEventListener("pointermove", this._moveAction);
      }, _SlideTabBar.LongPressDelay);
    };
    this._upAction = (upEvent) => {
      var _a2, _b, _c, _d;
      if ((_a2 = this._activeTabItem) == null ? void 0 : _a2.isEditMode()) {
        return;
      }
      if (this._longPressTimer) {
        clearTimeout(this._longPressTimer);
        this._longPressTimer = null;
      }
      if (!this._activeTabItem) return;
      const isFromScroll = this._autoScrollTime !== null;
      this._closeAutoScroll();
      this._activeTabItem.disableFixed();
      this.updateItems();
      const activeSlideItemElement = (_b = this._activeTabItem) == null ? void 0 : _b.getSlideTabItem();
      if (!activeSlideItemElement) return;
      activeSlideItemElement.style.cursor = "";
      activeSlideItemElement.releasePointerCapture(upEvent.pointerId);
      (_c = this._activeTabItem) == null ? void 0 : _c.removeEventListener("pointermove", this._moveAction);
      (_d = this._activeTabItem) == null ? void 0 : _d.removeEventListener("pointerup", this._upAction);
      if (this._config.onSlideEnd && this._activeTabItemIndex !== this._compareIndex && isFromScroll) {
        this.removeListener();
        this._config.onSlideEnd(upEvent, this._compareIndex || 0);
      }
      this._scrollIncremental = 0;
      this._downActionX = 0;
      this._moveActionX = 0;
      this._compareIndex = 0;
    };
    this._moveAction = (moveEvent) => {
      if (this._activeTabItem) {
        this._moveActionX = moveEvent.pageX - this._downActionX;
        if (this._moveActionX <= -this._leftMoveX) {
          this._moveActionX = -this._leftMoveX;
        } else if (this._moveActionX >= this._rightMoveX) {
          this._moveActionX = this._rightMoveX;
        }
        this._scrollIncremental = 0;
        this._scrollLeft(moveEvent);
        this._scrollRight(moveEvent);
      }
    };
    this._wheelAction = (wheelEvent) => {
      this.setScroll(wheelEvent.deltaY);
    };
    this.addListener();
  }
  static checkedSkipSlide(event) {
    let parent = event.target;
    while (parent != null && parent !== document.body) {
      if (parent.getAttribute("data-slide-skip")) {
        return true;
      }
      parent = parent.parentElement;
    }
    return false;
  }
  static keepLastIndex(inputHtml) {
    setTimeout(() => {
      const range = window.getSelection();
      if (range) {
        range.selectAllChildren(inputHtml);
        range.collapseToEnd();
      }
    });
  }
  static keepSelectAll(inputHtml) {
    setTimeout(() => {
      const selection = window.getSelection();
      if (!selection) return;
      const range = document.createRange();
      range.selectNodeContents(inputHtml);
      selection.removeAllRanges();
      selection.addRange(range);
    });
  }
  /**
   * The current instance is persistent, but some parameters need to be updated after refreshing
   * @param currentIndex
   */
  update(currentIndex) {
    this._config.currentIndex = currentIndex;
    this._initConfig();
    this.removeListener();
    this.addListener();
    this.scrollToItem(currentIndex);
  }
  primeval() {
    return this._slideTabBar;
  }
  updateItems() {
    for (let i = 0; i < this._slideTabItems.length; i++) {
      this._slideTabItems[i].animate().cancel();
      this._slideTabItems[i].translateX(0);
      this._slideTabItems[i].update();
    }
  }
  getScrollbar() {
    return this._slideScrollbar;
  }
  getConfig() {
    return this._config;
  }
  getBoundingRect() {
    return this._slideTabBar.getBoundingClientRect();
  }
  getSlideTabItems() {
    return this._slideTabItems;
  }
  getActiveItem() {
    return this._activeTabItem;
  }
  isLeftEnd() {
    return this._slideTabBar.scrollLeft === 0;
  }
  isRightEnd() {
    const parent = this._slideTabBar.parentElement;
    if (!parent) return false;
    return this._slideTabBar.scrollWidth - parent.clientWidth === this._slideTabBar.scrollLeft;
  }
  addListener() {
    this._slideTabBar.addEventListener("wheel", this._wheelAction);
    this._slideTabItems.forEach((item) => {
      item.addEventListener("pointerdown", this._downAction);
    });
  }
  removeListener() {
    this._slideTabBar.removeEventListener("wheel", this._wheelAction);
    this._slideTabItems.forEach((item) => {
      item.removeEventListener("pointerdown", this._downAction);
    });
  }
  setScroll(x) {
    this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + x);
    if (x > 0) {
      const left = this.calculateLeftScrollX();
      this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + left);
    } else if (x < 0) {
      const right = this.calculateRightScrollX();
      this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + right);
    }
    this._config.onScroll({
      leftEnd: this.isLeftEnd(),
      rightEnd: this.isRightEnd()
    });
  }
  flipPage(x) {
    if (x > 0) {
      const left = this.calculateLeftScrollX(true);
      this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + left);
    } else if (x < 0) {
      const right = this.calculateRightScrollX(true);
      this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + right);
    }
    this._config.onScroll({
      leftEnd: this.isLeftEnd(),
      rightEnd: this.isRightEnd()
    });
  }
  scrollToItem(index) {
    index = index != null ? index : this._config.currentIndex;
    if (index < 0 || index >= this._slideTabItems.length) {
      console.error("Index out of bounds");
      return;
    }
    const right = this.calculateTabItemScrollX(index);
    this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + right);
    this._config.onScroll({
      leftEnd: this.isLeftEnd(),
      rightEnd: this.isRightEnd()
    });
  }
  calculateLeftScrollX(shouldFlipPage) {
    let scrollX = 0;
    const padding = 4;
    this._slideTabItems.some((item) => {
      const containerRect = this._slideTabBar.getBoundingClientRect();
      const containerPosition = containerRect.left + containerRect.width;
      const itemReact = item.getSlideTabItem().getBoundingClientRect();
      const itemLeft = itemReact.left;
      const itemWidth = itemReact.width;
      if (itemLeft < containerPosition && itemLeft + itemWidth + padding * 2 > containerPosition) {
        scrollX = shouldFlipPage ? itemLeft - containerRect.left - padding : itemLeft + itemWidth - containerPosition + padding;
        return true;
      }
      return false;
    });
    return scrollX;
  }
  calculateRightScrollX(shouldFlipPage) {
    let scrollX = 0;
    const padding = 4;
    this._slideTabItems.some((item) => {
      const containerRect = this._slideTabBar.getBoundingClientRect();
      const containerPosition = containerRect.left;
      const itemReact = item.getSlideTabItem().getBoundingClientRect();
      const itemLeft = itemReact.left;
      const itemWidth = itemReact.width;
      if (itemLeft - padding * 2 < containerPosition && itemLeft + itemWidth > containerPosition) {
        scrollX = shouldFlipPage ? itemLeft + itemWidth - containerRect.left - containerRect.width + padding : itemLeft - containerPosition - padding;
        return true;
      }
      return false;
    });
    return scrollX;
  }
  calculateTabItemScrollX(index) {
    let scrollX = 0;
    const padding = 4;
    const containerRect = this._slideTabBar.getBoundingClientRect();
    const containerLeftPosition = containerRect.left;
    const containerRightPosition = containerRect.left + containerRect.width;
    const itemReact = this._slideTabItems[index].getSlideTabItem().getBoundingClientRect();
    const itemLeft = itemReact.left;
    const itemWidth = itemReact.width;
    if (itemLeft - padding * 2 < containerLeftPosition) {
      scrollX = itemLeft - containerLeftPosition - padding;
    }
    if (itemLeft + itemWidth + padding * 2 > containerRightPosition) {
      scrollX = itemLeft + itemWidth - containerRightPosition + padding;
    }
    return scrollX;
  }
  calculateActiveTabItemScrollX() {
    var _a;
    let scrollX = 0;
    const padding = 4;
    const containerRect = this._slideTabBar.getBoundingClientRect();
    const containerLeftPosition = containerRect.left;
    const containerRightPosition = containerRect.left + containerRect.width;
    const itemReact = (_a = this._activeTabItem) == null ? void 0 : _a.getSlideTabItem().getBoundingClientRect();
    if (!itemReact) return 0;
    const itemLeft = itemReact.left;
    const itemWidth = itemReact.width;
    if (itemLeft - padding * 2 < containerLeftPosition && itemLeft + itemWidth > containerLeftPosition) {
      scrollX = itemLeft - containerLeftPosition - padding;
    }
    if (itemLeft < containerRightPosition && itemLeft + itemWidth + padding * 2 > containerRightPosition) {
      scrollX = itemLeft + itemWidth - containerRightPosition + padding;
    }
    return scrollX;
  }
  destroy() {
    this.removeListener();
    this._downActionX = 0;
    this._moveActionX = 0;
    this._compareDirection = 0;
    this._compareIndex = 0;
    this._slideTabItems = [];
    this._activeTabItem = null;
  }
  _hasEditItem() {
    for (let index = 0; index < this._slideTabItems.length; index++) {
      const element = this._slideTabItems[index];
      if (element.isEditMode()) {
        return true;
      }
    }
    return false;
  }
  _autoScrollFrame() {
    if (this._activeTabItem) {
      this._compareDirection = this._activeTabItem.translateX(this._moveActionX);
      switch (this._compareDirection) {
        case 1: {
          this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + this._scrollIncremental);
          this._compareRight();
          break;
        }
        case 0: {
          this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + this._scrollIncremental);
          this._compareIndex = this._activeTabItemIndex;
          break;
        }
        case -1: {
          this._slideScrollbar.scrollX(this._slideScrollbar.getScrollX() + this._scrollIncremental);
          this._compareLeft();
          break;
        }
      }
    }
    this._autoScrollTime = requestAnimationFrame(() => {
      this._autoScrollFrame();
    });
  }
  _startAutoScroll() {
    if (this._autoScrollTime == null) {
      this._autoScrollFrame();
    }
  }
  _closeAutoScroll() {
    if (this._autoScrollTime) {
      cancelAnimationFrame(this._autoScrollTime);
    }
    this._autoScrollTime = null;
  }
  _scrollLeft(event) {
    const boundingRect = this.getBoundingRect();
    const x = event.pageX - boundingRect.x;
    if (x < this._leftBoundingLine) {
      this._scrollIncremental = -Math.min(Math.abs(x - this._leftBoundingLine) * 0.1, 50);
    }
  }
  _scrollRight(event) {
    const boundingRect = this.getBoundingRect();
    const x = event.pageX - boundingRect.x;
    if (x > boundingRect.width - this._rightBoundingLine) {
      this._scrollIncremental = Math.min(Math.abs(x - (boundingRect.width - this._rightBoundingLine)) * 0.1, 50);
    }
  }
  _sortedItems() {
    if (this._activeTabItem != null && this._activeTabItemIndex != null && this._compareIndex != null) {
      this._slideTabItems.splice(this._activeTabItemIndex, 1);
      this._slideTabItems.splice(this._compareIndex, 0, this._activeTabItem);
      if (this._config.slideTabBarItemAutoSort) {
        for (let i = 0; i < this._slideTabItems.length; i++) {
          const item = this._slideTabItems[i];
          const next = this._slideTabItems[i + 1];
          if (next) {
            item.after(next);
          }
        }
      }
    }
  }
  _compareLeft() {
    if (this._activeTabItem && this._activeTabItemIndex) {
      const splice = this._slideTabItems.findIndex((item) => item.equals(this._activeTabItem));
      const length = this._slideTabItems.length;
      const collect = [];
      for (let i = 0; i < splice; i++) {
        if (i >= splice) {
          break;
        }
        collect.push(this._slideTabItems[i]);
      }
      for (let i = splice + 1; i < length; i++) {
        this._slideTabItems[i].animate().translateX(0);
      }
      let notFound = true;
      for (let i = collect.length - 1; i >= 0; i--) {
        const item = collect[i];
        if (SlideTabItem.leftLine(this._activeTabItem) < item.getMidLine()) {
          item.animate().translateX(this._activeTabItem.getWidth());
          this._compareIndex = i;
          notFound = false;
        } else {
          item.animate().translateX(0);
          if (notFound) {
            this._compareIndex = this._activeTabItemIndex;
          }
        }
      }
    }
  }
  _compareRight() {
    if (this._activeTabItem) {
      const splice = this._slideTabItems.findIndex((item) => item.equals(this._activeTabItem));
      const length = this._slideTabItems.length;
      const collect = [];
      for (let i = splice + 1; i < length; i++) {
        collect.push(this._slideTabItems[i]);
      }
      for (let i = 0; i < splice; i++) {
        this._slideTabItems[i].animate().translateX(0);
      }
      let notFound = true;
      for (let i = 0; i < collect.length; i++) {
        const item = collect[i];
        if (SlideTabItem.rightLine(this._activeTabItem) > item.getMidLine()) {
          item.animate().translateX(-this._activeTabItem.getWidth());
          this._compareIndex = splice + i + 1;
          notFound = false;
        } else {
          item.animate().translateX(0);
          if (notFound) {
            this._compareIndex = this._activeTabItemIndex;
          }
        }
      }
    }
  }
  _initConfig() {
    var _a;
    const slideTabItems = this._slideTabBar.querySelectorAll(
      `.${(_a = this._config.slideTabBarItemClassName) != null ? _a : "slide-tab-item"}`
    );
    this._downActionX = 0;
    this._moveActionX = 0;
    this._compareDirection = 0;
    this._compareIndex = 0;
    this._slideTabItems = SlideTabItem.make(slideTabItems, this);
    this._activeTabItemIndex = this._config.currentIndex;
    this._activeTabItem = this._slideTabItems[this._activeTabItemIndex];
  }
};
/** Time in milliseconds to wait to raise long press events if button is still pressed */
__publicField(_SlideTabBar, "LongPressDelay", 500);
// in milliseconds
/** Time in milliseconds with two consecutive clicks will be considered as a double click */
__publicField(_SlideTabBar, "DoubleClickDelay", 300);
var SlideTabBar = _SlideTabBar;

// ../packages/sheets-ui/src/views/sheet-bar/sheet-bar-tabs/SheetBarTabs.tsx
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var import_react15 = __toESM(require_react());
function SheetBarTabs() {
  var _a;
  const [sheetList, setSheetList] = (0, import_react14.useState)([]);
  const [activeKey, setActiveKey] = (0, import_react14.useState)("");
  const [boxShadow, setBoxShadow] = (0, import_react14.useState)("");
  const [visible, setVisible] = (0, import_react14.useState)(false);
  const [offset, setOffset] = (0, import_react14.useState)([0, 0]);
  const slideTabBarRef = (0, import_react14.useRef)({ slideTabBar: null });
  const slideTabBarContainerRef = (0, import_react14.useRef)(null);
  const commandService = useDependency(ICommandService);
  const sheetBarService = useDependency(ISheetBarService);
  const localeService = useDependency(LocaleService);
  const confirmService = useDependency(IConfirmService);
  const configService = useDependency(IConfigService);
  const editorBridgeService = useDependency(IEditorBridgeService, Quantity.OPTIONAL);
  const worksheetProtectionRuleModel = useDependency(WorksheetProtectionRuleModel);
  const rangeProtectionRuleModel = useDependency(RangeProtectionRuleModel);
  const resetOrder = useObservable(worksheetProtectionRuleModel.resetOrder$);
  const workbook = useActiveWorkbook();
  const permissionService = useDependency(IPermissionService);
  const updateSheetItems = (0, import_react14.useCallback)(() => {
    var _a2;
    const currentSubUnitId = ((_a2 = workbook.getActiveSheet()) == null ? void 0 : _a2.getSheetId()) || "";
    setActiveKey(currentSubUnitId);
    const sheets = workbook.getSheets();
    const activeSheet = workbook.getActiveSheet();
    const sheetListItems = sheets.filter((sheet) => !sheet.isSheetHidden()).map((sheet, index) => {
      var _a3;
      const worksheetRule = worksheetProtectionRuleModel.getRule(workbook.getUnitId(), sheet.getSheetId());
      const hasSelectionRule = rangeProtectionRuleModel.getSubunitRuleList(workbook.getUnitId(), sheet.getSheetId()).length > 0;
      const hasProtect = (worksheetRule == null ? void 0 : worksheetRule.permissionId) || hasSelectionRule;
      const name = hasProtect ? /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)(import_jsx_runtime26.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(lock_single_default, {}),
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { children: sheet.getName() })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { children: sheet.getName() });
      return {
        sheetId: sheet.getSheetId(),
        label: name,
        index,
        selected: activeSheet === sheet,
        color: (_a3 = sheet.getTabColor()) != null ? _a3 : void 0
      };
    });
    setSheetList(sheetListItems);
    setActiveKey(currentSubUnitId);
  }, [rangeProtectionRuleModel, workbook, worksheetProtectionRuleModel]);
  (0, import_react14.useEffect)(() => {
    updateSheetItems();
    const { slideTabBar, disconnectResizeObserver } = setupSlideTabBarInit();
    const disposable = setupStatusUpdate();
    const subscribeList = [
      setupSubscribeScroll(),
      setupSubscribeScrollX(),
      setupSubscribeRenameId()
      // When adding a sheet, it no longer slides, which has been uniformly handled in setupSlideTabBarUpdate
    ];
    return () => {
      disposable.dispose();
      slideTabBar.destroy();
      subscribeList.forEach((subscribe) => subscribe.unsubscribe());
      disconnectResizeObserver && disconnectResizeObserver();
    };
  }, [resetOrder, workbook]);
  (0, import_react14.useEffect)(() => {
    if (sheetList.length > 0) {
      setupSlideTabBarUpdate();
    }
  }, [sheetList]);
  (0, import_react14.useEffect)(() => {
    const subscription = merge(
      worksheetProtectionRuleModel.ruleChange$,
      rangeProtectionRuleModel.ruleChange$
    ).subscribe(() => {
      updateSheetItems();
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [worksheetProtectionRuleModel, updateSheetItems]);
  const setupSlideTabBarInit = () => {
    const slideTabBar = new SlideTabBar({
      slideTabBarClassName: index_module_default8.slideTabBar,
      slideTabBarItemActiveClassName: index_module_default8.slideTabActive,
      slideTabBarItemClassName: index_module_default8.slideTabItem,
      slideTabBarSpanEditClassName: index_module_default8.slideTabDivEdit,
      slideTabBarItemAutoSort: true,
      slideTabBarContainer: slideTabBarContainerRef.current,
      currentIndex: 0,
      onChangeName: (subUnitId, worksheetName) => {
        commandService.executeCommand(SetWorksheetNameCommand.id, {
          subUnitId,
          name: worksheetName
        });
      },
      onSlideEnd: async (event, order) => {
        const res = await commandService.executeCommand(SetWorksheetOrderCommand.id, { order });
      },
      onChangeTab: (event, subUnitId) => {
        commandService.executeCommand(SetWorksheetActiveOperation.id, {
          subUnitId,
          unitId: workbook.getUnitId()
        }).then(() => {
          if (event.button === 2) {
            onVisibleChange(true);
          }
        });
      },
      onScroll: (state) => {
        sheetBarService.setScroll(state);
      },
      onNameCheckAlert: (text) => {
        return nameEmptyCheck(text) || sheetNameSpecCharCheck(text) || nameRepeatCheck(text);
      },
      onNameChangeCheck: () => {
        var _a2, _b, _c, _d;
        const unitId = workbook.getUnitId();
        const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
        if (!worksheet) {
          throw new Error("No active sheet found");
        }
        const subUnitId = worksheet.getSheetId();
        const worksheetRule = worksheetProtectionRuleModel.getRule(unitId, subUnitId);
        const selectionRule = rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).length > 0;
        if (worksheetRule || selectionRule) {
          return (_b = (_a2 = permissionService.getPermissionPoint(new WorkbookManageCollaboratorPermission(unitId).id)) == null ? void 0 : _a2.value) != null ? _b : false;
        } else {
          return (_d = (_c = permissionService.getPermissionPoint(new WorkbookRenameSheetPermission(unitId).id)) == null ? void 0 : _c.value) != null ? _d : false;
        }
      }
    });
    slideTabBarRef.current.slideTabBar = slideTabBar;
    const disconnectResizeObserver = resizeInit(slideTabBar);
    return { slideTabBar, disconnectResizeObserver };
  };
  const config = configService.getConfig(UI_PLUGIN_CONFIG_KEY);
  const showContextMenu = (_a = config == null ? void 0 : config.contextMenu) != null ? _a : true;
  const nameEmptyCheck = (name) => {
    if (name.trim() === "") {
      const id = "sheetNameEmptyAlert";
      confirmService.open({
        id,
        title: { title: localeService.t("sheetConfig.sheetNameErrorTitle") },
        children: { title: localeService.t("sheetConfig.sheetNameCannotIsEmptyError") },
        cancelText: localeService.t("button.cancel"),
        confirmText: localeService.t("button.confirm"),
        onClose() {
          focusTabEditor();
          confirmService.close(id);
        },
        onConfirm() {
          focusTabEditor();
          confirmService.close(id);
        }
      });
      return true;
    }
    return false;
  };
  const sheetNameSpecCharCheck = (name) => {
    if (!nameCharacterCheck(name)) {
      const id = "sheetNameSpecCharAlert";
      confirmService.open({
        id,
        title: { title: localeService.t("sheetConfig.sheetNameErrorTitle") },
        children: { title: localeService.t("sheetConfig.sheetNameSpecCharError") },
        cancelText: localeService.t("button.cancel"),
        confirmText: localeService.t("button.confirm"),
        onClose() {
          focusTabEditor();
          confirmService.close(id);
        },
        onConfirm() {
          focusTabEditor();
          confirmService.close(id);
        }
      });
      return true;
    }
    return false;
  };
  const nameRepeatCheck = (name) => {
    const worksheet = workbook.getActiveSheet();
    const currenSheetName = worksheet == null ? void 0 : worksheet.getName();
    if (currenSheetName === name) return false;
    const checked = workbook.checkSheetName(name);
    if (checked) {
      const id = "sheetNameRepeatAlert";
      confirmService.open({
        id,
        title: { title: localeService.t("sheetConfig.sheetNameErrorTitle") },
        children: { title: localeService.t("sheetConfig.sheetNameAlreadyExistsError") },
        cancelText: localeService.t("button.cancel"),
        confirmText: localeService.t("button.confirm"),
        onClose() {
          confirmService.close(id);
          focusTabEditor();
        },
        onConfirm() {
          confirmService.close(id);
          focusTabEditor();
        }
      });
    }
    return checked;
  };
  const focusTabEditor = () => {
    setTimeout(() => {
      var _a2;
      const activeSlideTab = (_a2 = slideTabBarRef.current.slideTabBar) == null ? void 0 : _a2.getActiveItem();
      if (activeSlideTab) {
        activeSlideTab.focus();
        activeSlideTab.selectAll();
      }
    }, 0);
  };
  const setTabEditor = () => {
    var _a2, _b;
    (_b = (_a2 = slideTabBarRef.current.slideTabBar) == null ? void 0 : _a2.getActiveItem()) == null ? void 0 : _b.setEditor();
  };
  const setupSlideTabBarUpdate = () => {
    var _a2;
    const currentIndex = sheetList.findIndex((item) => item.selected);
    (_a2 = slideTabBarRef.current.slideTabBar) == null ? void 0 : _a2.update(currentIndex);
  };
  const setupStatusUpdate = () => commandService.onCommandExecuted((commandInfo) => {
    switch (commandInfo.id) {
      case SetTabColorMutation.id:
      case SetWorksheetHideMutation.id:
      case RemoveSheetMutation.id:
      case SetWorksheetNameMutation.id:
      case InsertSheetMutation.id:
      case SetWorksheetOrderMutation.id:
      case SetWorksheetActiveOperation.id:
        updateSheetItems();
        break;
      default:
        break;
    }
  });
  const setupSubscribeScroll = () => sheetBarService.scroll$.subscribe((state) => {
    updateScrollButtonState(state);
  });
  const setupSubscribeScrollX = () => sheetBarService.scrollX$.subscribe((x) => {
    var _a2;
    (_a2 = slideTabBarRef.current.slideTabBar) == null ? void 0 : _a2.flipPage(x);
  });
  const setupSubscribeRenameId = () => sheetBarService.renameId$.subscribe(() => {
    setTabEditor();
  });
  const updateScrollButtonState = (state) => {
    const { leftEnd, rightEnd } = state;
    let boxShadow2 = "";
    if (leftEnd && rightEnd) {
      boxShadow2 = "";
    } else if (leftEnd && !rightEnd) {
      boxShadow2 = "inset -10px 0px 10px -10px rgba(0, 0, 0, 0.2)";
    } else if (!leftEnd && rightEnd) {
      boxShadow2 = "inset 10px 0px 10px -10px rgba(0, 0, 0, 0.2)";
    } else if (!leftEnd && !rightEnd) {
      boxShadow2 = "inset 10px 0px 10px -10px rgba(0, 0, 0, 0.2), inset -10px 0px 10px -10px rgba(0, 0, 0, 0.2)";
    }
    setBoxShadow(boxShadow2);
  };
  const buttonScroll = (slideTabBar) => {
    const scrollX = slideTabBar.calculateActiveTabItemScrollX();
    if (scrollX) {
      const scrollBar = slideTabBar.getScrollbar();
      scrollBar.scrollX(scrollBar.getScrollX() + scrollX);
    }
    sheetBarService.setScroll({
      leftEnd: slideTabBar.isLeftEnd(),
      rightEnd: slideTabBar.isRightEnd()
    });
  };
  const resizeInit = (slideTabBar) => {
    var _a2;
    const slideTabBarContainer = (_a2 = slideTabBarContainerRef.current) == null ? void 0 : _a2.querySelector(`.${index_module_default8.slideTabBar}`);
    if (!slideTabBarContainer) return;
    const observer = new ResizeObserver(() => {
      buttonScroll(slideTabBar);
    });
    observer.observe(slideTabBarContainer);
    return () => observer.disconnect();
  };
  const onVisibleChange = (visible2) => {
    var _a2, _b, _c, _d, _e;
    if (!showContextMenu) return;
    if (editorBridgeService == null ? void 0 : editorBridgeService.isForceKeepVisible()) {
      return;
    }
    if (visible2) {
      const { left: containerLeft } = (_b = (_a2 = slideTabBarContainerRef.current) == null ? void 0 : _a2.getBoundingClientRect()) != null ? _b : {};
      const { left: activeTabLeft } = (_e = (_d = (_c = slideTabBarRef.current.slideTabBar) == null ? void 0 : _c.getActiveItem()) == null ? void 0 : _d.getSlideTabItem().getBoundingClientRect()) != null ? _e : {};
      if (containerLeft !== void 0 && activeTabLeft !== void 0) {
        setOffset([activeTabLeft - containerLeft, 0]);
      }
    }
    setVisible(visible2);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
    DropdownLegacy,
    {
      className: index_module_default8.slideTabItemDropdown,
      visible,
      align: { offset },
      trigger: ["contextMenu"],
      overlay: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
        Menu,
        {
          menuType: "contextMenu.footerTabs" /* FOOTER_TABS */,
          onOptionSelect: (params) => {
            const { label: id, value, commandId } = params;
            commandService.executeCommand(commandId != null ? commandId : id, { value, subUnitId: activeKey });
            setVisible(false);
          }
        }
      ),
      onVisibleChange,
      children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
        "div",
        {
          className: index_module_default8.slideTabBarContainer,
          ref: slideTabBarContainerRef,
          onDragStart: (e) => e.preventDefault(),
          onContextMenu: (e) => e.preventDefault(),
          children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("div", { className: index_module_default8.slideTabBar, style: { boxShadow }, children: sheetList.map((item) => /* @__PURE__ */ (0, import_react15.createElement)(SheetBarItem, { ...item, key: item.sheetId, selected: activeKey === item.sheetId })) })
        }
      )
    }
  );
}

// ../packages/sheets-ui/src/views/sheet-bar/SheetBar.tsx
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var SCROLL_WIDTH = 100;
var SheetBar = () => {
  var _a, _b;
  const [leftScrollState, setLeftScrollState] = (0, import_react16.useState)(true);
  const [rightScrollState, setRightScrollState] = (0, import_react16.useState)(true);
  const commandService = useDependency(ICommandService);
  const sheetBarService = useDependency(ISheetBarService);
  const permissionService = useDependency(IPermissionService);
  const workbook = useActiveWorkbook();
  const unitId = workbook.getUnitId();
  const workbookEditablePermission = useObservable(permissionService.getPermissionPoint$((_a = new WorkbookEditablePermission(unitId)) == null ? void 0 : _a.id));
  const workbookCreateSheetPermission = useObservable(permissionService.getPermissionPoint$((_b = new WorkbookCreateSheetPermission(unitId)) == null ? void 0 : _b.id));
  (0, import_react16.useEffect)(() => {
    const subscription = sheetBarService.scroll$.subscribe((state) => {
      updateScrollButtonState(state);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
  const updateScrollButtonState = (state) => {
    const { leftEnd, rightEnd } = state;
    setLeftScrollState(leftEnd);
    setRightScrollState(rightEnd);
  };
  const addSheet = () => {
    commandService.executeCommand(InsertSheetCommand.id);
    setTimeout(() => {
      sheetBarService.setAddSheet(0);
    }, 0);
  };
  const handleScrollLeft = () => {
    sheetBarService.setScrollX(-SCROLL_WIDTH);
  };
  const handleScrollRight = () => {
    sheetBarService.setScrollX(SCROLL_WIDTH);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { className: clsx(index_module_default6.sheetBar, "univer-relative univer-flex univer-h-full univer-flex-1"), children: [
    /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("div", { className: index_module_default6.sheetBarOptions, children: [
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(SheetBarButton, { onClick: addSheet, disabled: !((workbookCreateSheetPermission == null ? void 0 : workbookCreateSheetPermission.value) && (workbookEditablePermission == null ? void 0 : workbookEditablePermission.value)), children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(increase_single_default, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(SheetBarMenu, {})
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(SheetBarTabs, {}),
    (!leftScrollState || !rightScrollState) && /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)(
      "div",
      {
        className: `
                      ${index_module_default6.sheetBarOptions}
                      ${index_module_default6.sheetBarOptionsDivider}
                    `,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(SheetBarButton, { disabled: leftScrollState, onClick: handleScrollLeft, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(more_single_default, { style: { transform: "rotateZ(180deg)" } }) }),
          /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(SheetBarButton, { disabled: rightScrollState, onClick: handleScrollRight, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(more_single_default, {}) })
        ]
      }
    )
  ] });
};

// ../packages/sheets-ui/src/views/status-bar/StatusBar.tsx
var import_react17 = __toESM(require_react());

// ../packages/sheets-ui/src/services/status-bar.service.ts
var StatusBarService = class {
  constructor() {
    __publicField(this, "_functions", [
      {
        func: "MAX" /* MAX */,
        filter: (status) => {
          var _a, _b, _c, _d;
          return ((_b = (_a = status.values.find((item) => item.func === "COUNTA" /* COUNTA */)) == null ? void 0 : _a.value) != null ? _b : 0) > 1 && ((_d = (_c = status.values.find((item) => item.func === "COUNT" /* COUNT */)) == null ? void 0 : _c.value) != null ? _d : 0) > 0;
        }
      },
      {
        func: "MIN" /* MIN */,
        filter: (status) => {
          var _a, _b, _c, _d;
          return ((_b = (_a = status.values.find((item) => item.func === "COUNTA" /* COUNTA */)) == null ? void 0 : _a.value) != null ? _b : 0) > 1 && ((_d = (_c = status.values.find((item) => item.func === "COUNT" /* COUNT */)) == null ? void 0 : _c.value) != null ? _d : 0) > 0;
        }
      },
      {
        func: "SUM" /* SUM */,
        filter: (status) => {
          var _a, _b, _c, _d;
          return ((_b = (_a = status.values.find((item) => item.func === "COUNTA" /* COUNTA */)) == null ? void 0 : _a.value) != null ? _b : 0) > 1 && ((_d = (_c = status.values.find((item) => item.func === "COUNT" /* COUNT */)) == null ? void 0 : _c.value) != null ? _d : 0) > 0;
        }
      },
      {
        func: "COUNTA" /* COUNTA */,
        filter: (status) => {
          var _a, _b;
          return ((_b = (_a = status.values.find((item) => item.func === "COUNTA" /* COUNTA */)) == null ? void 0 : _a.value) != null ? _b : 0) > 1;
        }
      },
      {
        func: "COUNT" /* COUNT */,
        filter: (status) => {
          var _a, _b, _c, _d;
          return ((_b = (_a = status.values.find((item) => item.func === "COUNTA" /* COUNTA */)) == null ? void 0 : _a.value) != null ? _b : 0) > 1 && ((_d = (_c = status.values.find((item) => item.func === "COUNT" /* COUNT */)) == null ? void 0 : _c.value) != null ? _d : 0) > 0;
        }
      },
      {
        func: "AVERAGE" /* AVERAGE */,
        filter: (status) => {
          var _a, _b, _c, _d;
          return ((_b = (_a = status.values.find((item) => item.func === "COUNTA" /* COUNTA */)) == null ? void 0 : _a.value) != null ? _b : 0) > 1 && ((_d = (_c = status.values.find((item) => item.func === "COUNT" /* COUNT */)) == null ? void 0 : _c.value) != null ? _d : 0) > 0;
        }
      }
    ]);
    __publicField(this, "_state$", new BehaviorSubject(null));
    __publicField(this, "state$", this._state$.asObservable());
  }
  dispose() {
    this._state$.complete();
  }
  setState(param) {
    var _a;
    const newState = {
      values: [],
      pattern: null
    };
    param == null ? void 0 : param.values.forEach((item) => {
      const func = this._functions.find((func2) => func2.func === item.func);
      if (func && (func.filter === void 0 || func.filter(param))) {
        newState.values.push(item);
      }
    });
    newState.pattern = (_a = param == null ? void 0 : param.pattern) != null ? _a : null;
    this._state$.next(newState);
  }
  getState() {
    return this._state$.getValue();
  }
  getFunctions() {
    return this._functions;
  }
  addFunctions(functions) {
    this._functions.push(...functions);
  }
};
var IStatusBarService = createIdentifier("univer.sheet-status-bar.service");

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/status-bar/index.module.less
var index_module_default9 = {
  "statusBar": "univer-status-bar",
  "singleMode": "univer-single-mode",
  "statusBarDiv": "univer-status-bar-div",
  "statisticListColumn": "univer-statistic-list-column",
  "statisticItem": "univer-statistic-item",
  "statisticPicker": "univer-statistic-picker",
  "statisticPickerItem": "univer-statistic-picker-item",
  "statisticMore": "univer-statistic-more"
};

// ../packages/sheets-ui/src/views/status-bar/CopyableStatisticItem.tsx
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var allowPatternFunctions = [
  "SUM" /* SUM */,
  "AVERAGE" /* AVERAGE */,
  "MIN" /* MIN */,
  "MAX" /* MAX */
];
var functionDisplayNames = {
  ["SUM" /* SUM */]: "statusbar.sum",
  ["AVERAGE" /* AVERAGE */]: "statusbar.average",
  ["MIN" /* MIN */]: "statusbar.min",
  ["MAX" /* MAX */]: "statusbar.max",
  ["COUNT" /* COUNT */]: "statusbar.count",
  ["COUNTA" /* COUNTA */]: "statusbar.countA",
  ["CONCATENATE" /* CONCATENATE */]: "concatenate"
};
var CopyableStatisticItem = (item) => {
  const localeService = useDependency(LocaleService);
  const messageService = useDependency(IMessageService);
  const clipboardService = useDependency(IClipboardInterfaceService);
  const formateValue = formatNumber(item);
  const copyToClipboard = async () => {
    await clipboardService.writeText(item.value.toString());
    messageService.show({
      type: "success" /* Success */,
      content: localeService.t("statusbar.copied")
    });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Tooltip, { title: localeService.t("statusbar.clickToCopy"), placement: "top", children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: index_module_default9.statisticItem, onClick: copyToClipboard, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("span", { children: `${localeService.t(
    (functionDisplayNames == null ? void 0 : functionDisplayNames[item.name]) || item.name
  )}: ${formateValue}` }) }, item.name) });
};
function formatNumber(item) {
  const { pattern, value: num } = item;
  if (typeof num !== "number") {
    return 0;
  }
  if (num >= 1e8) {
    return num.toExponential(2);
  }
  if (pattern && allowPatternFunctions.includes(item.name)) {
    return numfmt.format(pattern, num, { throws: false });
  }
  return num.toLocaleString();
}

// ../packages/sheets-ui/src/views/status-bar/StatusBar.tsx
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var SINGLE_MODE_WIDTH = 800;
var ROW_COUNT_THRESHOLD = 3;
var StatusBar = () => {
  var _a, _b;
  const configService = useDependency(IConfigService);
  const showStatistic = (_b = (_a = configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY)) == null ? void 0 : _a.statusBarStatistic) != null ? _b : true;
  const [isSingle, setIsSingle] = (0, import_react17.useState)(window.innerWidth < SINGLE_MODE_WIDTH);
  const statusBarService = useDependency(IStatusBarService);
  const items = statusBarService.getFunctions().map((item, index) => ({
    name: item.func,
    value: 0,
    show: true,
    disable: false,
    pattern: null
  }));
  const useStatistics = (initialItems, statusBarService2, isSingle2, showStatistic2) => {
    const [statistics, setStatistics] = (0, import_react17.useState)(initialItems);
    const [show2, setShow] = (0, import_react17.useState)(true);
    const filteredStatistics = (0, import_react17.useMemo)(() => statistics.filter((item) => item.show && !item.disable), [statistics]);
    const firstItem = (0, import_react17.useMemo)(() => filteredStatistics.find((item) => item.show && !item.disable), [filteredStatistics]);
    const showList2 = (0, import_react17.useMemo)(() => isSingle2 && firstItem ? [firstItem] : filteredStatistics, [isSingle2, firstItem, filteredStatistics]);
    const updateStatistics = (0, import_react17.useCallback)((state) => {
      const items2 = state == null ? void 0 : state.values;
      if (!(items2 == null ? void 0 : items2.length)) {
        setShow(false);
        return;
      }
      setShow(true);
      setStatistics(
        (prevStats) => prevStats.map((stat) => {
          var _a2, _b2, _c;
          return {
            ...stat,
            value: (_b2 = (_a2 = items2.find((i) => i.func === stat.name)) == null ? void 0 : _a2.value) != null ? _b2 : stat.value,
            disable: !items2.some((i) => i.func === stat.name),
            pattern: (_c = state == null ? void 0 : state.pattern) != null ? _c : null
          };
        })
      );
    }, []);
    (0, import_react17.useEffect)(() => {
      if (!showStatistic2) return;
      const subscription = statusBarService2.state$.subscribe(updateStatistics);
      return () => subscription.unsubscribe();
    }, [showStatistic2, statusBarService2, updateStatistics]);
    return {
      statistics,
      showList: showList2,
      show: show2
    };
  };
  const { showList, show } = useStatistics(
    items,
    statusBarService,
    isSingle,
    showStatistic
  );
  const handleResize = debounce_default(() => {
    const newSingleState = window.innerWidth < SINGLE_MODE_WIDTH;
    if (isSingle !== newSingleState) {
      setIsSingle(newSingleState);
    }
  }, 100);
  (0, import_react17.useEffect)(() => {
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, [isSingle]);
  const useStatisticLayout = (showList2, rowCountThreshold, CopyableStatisticItem2) => {
    if (!showStatistic) return null;
    const renderContent2 = import_react17.default.useMemo(() => {
      if (showList2.length > rowCountThreshold) {
        const doubleLineList = showList2.reduce((acc, _, index) => {
          if (index % 2 === 0) {
            acc.push(showList2.slice(index, index + 2));
          }
          return acc;
        }, []);
        return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(import_jsx_runtime29.Fragment, { children: doubleLineList.map((item, index) => /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
          "div",
          {
            className: index_module_default9.statisticListColumn,
            children: [
              item[0] && /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
                CopyableStatisticItem2,
                {
                  ...item[0]
                },
                item[0].name
              ),
              item[1] && /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
                CopyableStatisticItem2,
                {
                  ...item[1]
                },
                item[1].name
              )
            ]
          },
          `stat-col-${index}`
        )) });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(import_jsx_runtime29.Fragment, { children: showList2.map((item) => /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(
        CopyableStatisticItem2,
        {
          ...item
        },
        item.name
      )) });
    }, [showList2, rowCountThreshold, CopyableStatisticItem2]);
    return renderContent2;
  };
  const renderContent = useStatisticLayout(showList, ROW_COUNT_THRESHOLD, CopyableStatisticItem);
  return show && /* @__PURE__ */ (0, import_jsx_runtime29.jsxs)(
    "div",
    {
      className: clsx(index_module_default9.statusBar, {
        [index_module_default9.singleMode]: isSingle
      }),
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: "univer-flex", children: renderContent }),
        /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: index_module_default9.statusBarDiv })
      ]
    }
  );
};

// ../packages/sheets-ui/src/views/sheet-container/SheetContainer.tsx
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var SHEET_FOOTER_BAR_HEIGHT = 36;
function RenderSheetFooter() {
  const menuManagerService = useDependency(IMenuManagerService);
  const workbook = useActiveWorkbook();
  if (!workbook) return null;
  const footerMenus = menuManagerService.getMenuByPositionKey("contextMenu.footerMenu" /* FOOTER_MENU */);
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(
    "section",
    {
      className: `
              univer-box-border univer-flex univer-items-center univer-justify-between univer-bg-white univer-px-5
              univer-text-gray-900
              dark:univer-bg-gray-900 dark:univer-text-gray-200
            `,
      style: {
        height: SHEET_FOOTER_BAR_HEIGHT
      },
      "data-range-selector": true,
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(SheetBar, {}),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(StatusBar, {}),
        footerMenus.length && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: "univer-mr-2 univer-flex univer-gap-2", children: footerMenus.map((item) => {
          var _a;
          return (_a = item.children) == null ? void 0 : _a.map((child) => (child == null ? void 0 : child.item) && /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
            ToolbarItem,
            {
              ...child.item
            },
            child.key
          ));
        }) }),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(CountBar, {})
      ]
    }
  );
}
function RenderSheetHeader() {
  const hasWorkbook = useHasWorkbook();
  if (!hasWorkbook) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(FormulaBar, {});
}
function RenderSheetContent() {
  const hasWorkbook = useHasWorkbook();
  if (!hasWorkbook) return null;
  return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(EditorContainer, {}),
    /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(AutoFillPopupMenu, {})
  ] });
}
function useHasWorkbook() {
  const univerInstanceService = useDependency(IUniverInstanceService);
  const workbook = useObservable(() => univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET), null, false, []);
  const hasWorkbook = !!workbook;
  return (0, import_react18.useMemo)(
    () => univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).length > 0,
    [univerInstanceService, hasWorkbook]
  );
}

// ../packages/sheets-ui/src/controllers/shortcuts/utils.ts
function whenSheetFocused(contextService) {
  return contextService.getContextValue(FOCUSING_SHEET);
}
function whenSheetEditorFocused(contextService) {
  return contextService.getContextValue(FOCUSING_SHEET) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && !contextService.getContextValue(EDITOR_ACTIVATED) && !contextService.getContextValue(FOCUSING_COMMON_DRAWINGS);
}
function whenSheetEditorFocusedAndFxNotFocused(contextService) {
  return contextService.getContextValue(FOCUSING_SHEET) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && !contextService.getContextValue(EDITOR_ACTIVATED) && !contextService.getContextValue(FOCUSING_FX_BAR_EDITOR) && !contextService.getContextValue(FOCUSING_COMMON_DRAWINGS);
}
function whenSheetEditorActivated(contextService) {
  return contextService.getContextValue(FOCUSING_SHEET) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && contextService.getContextValue(EDITOR_ACTIVATED);
}
function whenEditorActivated(contextService) {
  return contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && contextService.getContextValue(EDITOR_ACTIVATED);
}
function whenFormulaEditorFocused(contextService) {
  return contextService.getContextValue(FOCUSING_FX_BAR_EDITOR) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR);
}
function whenFormulaEditorActivated(contextService) {
  return contextService.getContextValue(FOCUSING_SHEET) && contextService.getContextValue(EDITOR_ACTIVATED) && contextService.getContextValue(FOCUSING_EDITOR_INPUT_FORMULA) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR);
}
function whenEditorDidNotInputFormulaActivated(contextService) {
  return contextService.getContextValue(FOCUSING_SHEET) && contextService.getContextValue(FOCUSING_UNIVER_EDITOR) && contextService.getContextValue(EDITOR_ACTIVATED) && !contextService.getContextValue(FOCUSING_EDITOR_INPUT_FORMULA) && !contextService.getContextValue(FOCUSING_EDITOR_STANDALONE);
}

// ../packages/sheets-ui/src/services/clipboard/copy-content-cache.ts
var COPY_CONTENT_CACHE_LIMIT = 10;
var ID_LENGTH = 6;
function genId() {
  return Tools.generateRandomId(ID_LENGTH);
}
function extractId(html) {
  const match = html.match(/data-copy-id="([^\s]+)"/);
  if (match && match[1]) {
    return match[1];
  }
  return null;
}
var CopyContentCache = class {
  constructor() {
    __publicField(this, "_cache", new LRUMap(COPY_CONTENT_CACHE_LIMIT));
  }
  set(id, clipboardData) {
    this._cache.set(id, clipboardData);
  }
  get(id) {
    return this._cache.get(id);
  }
  del(id) {
    this._cache.delete(id);
  }
  clear() {
    this._cache.clear();
  }
  clearWithUnitId(unitId) {
    this._cache.forEach((value, key) => {
      if (value.unitId === unitId) {
        this._cache.delete(key);
      }
    });
  }
};
var copyContentCache = new CopyContentCache();

// ../packages/sheets-ui/src/services/clipboard/html-to-usm/parse-node-style.ts
function extractNodeStyle(node, predefinedStyles) {
  const styles = predefinedStyles != null ? predefinedStyles : node.style;
  const docStyles = {};
  const tagName = node.tagName.toLowerCase();
  switch (tagName) {
    case "b":
    case "em":
    case "strong": {
      docStyles.bl = 1 /* TRUE */;
      break;
    }
    case "s": {
      docStyles.st = {
        s: 1 /* TRUE */
      };
      break;
    }
    case "u": {
      docStyles.ul = {
        s: 1 /* TRUE */
      };
      break;
    }
    case "i": {
      docStyles.it = 1 /* TRUE */;
      break;
    }
    case "sub":
    case "sup": {
      docStyles.va = tagName === "sup" ? 3 /* SUPERSCRIPT */ : 2 /* SUBSCRIPT */;
      break;
    }
  }
  parseStyleByProperty(styles, docStyles);
  return docStyles;
}
function parseStyleByProperty(styles, docStyles) {
  if (styles instanceof CSSStyleDeclaration) {
    for (let i = 0; i < styles.length; i++) {
      const cssRule = styles[i];
      const cssValue = styles.getPropertyValue(cssRule);
      handleStyle(cssRule, cssValue, docStyles);
    }
  } else {
    for (const cssRule in styles) {
      const cssValue = styles[cssRule];
      handleStyle(cssRule, cssValue, docStyles);
    }
  }
}
function handleStyle(cssRule, cssValue, docStyles) {
  switch (cssRule) {
    case "font-family":
      docStyles.ff = cssValue;
      break;
    case "font-size": {
      const fontSize = Number.parseInt(cssValue);
      if (!Number.isNaN(fontSize)) {
        if (cssValue.endsWith("pt")) {
          docStyles.fs = fontSize;
        } else if (cssValue.endsWith("px")) {
          docStyles.fs = fontSize * 0.75;
        }
      }
      break;
    }
    case "font-style":
      if (cssValue === "italic") {
        docStyles.it = 1 /* TRUE */;
      }
      break;
    case "font-weight": {
      const MIDDLE_FONT_WEIGHT = 400;
      if (Number(cssValue) > MIDDLE_FONT_WEIGHT || cssValue === "bold") {
        docStyles.bl = 1 /* TRUE */;
      }
      break;
    }
    case "text-decoration": {
      if (/underline/.test(cssValue)) {
        docStyles.ul = { s: 1 /* TRUE */ };
      } else if (/overline/.test(cssValue)) {
        docStyles.ol = { s: 1 /* TRUE */ };
      } else if (/line-through/.test(cssValue)) {
        docStyles.st = { s: 1 /* TRUE */ };
      }
      break;
    }
    case "color": {
      try {
        const color = new ColorKit(cssValue);
        if (color.isValid) {
          docStyles.cl = {
            rgb: color.toRgbString()
          };
        }
      } catch (_e) {
      }
      break;
    }
    case "background-color": {
      const color = new ColorKit(cssValue);
      const bgColor = color.isValid ? color.toRgbString() : "";
      if (bgColor !== DEFAULT_BACKGROUND_COLOR_RGB && bgColor !== DEFAULT_BACKGROUND_COLOR_RGBA) {
        docStyles.bg = { rgb: bgColor };
      }
      break;
    }
    default:
      break;
  }
}

// ../packages/sheets-ui/src/services/clipboard/html-to-usm/utils.ts
function parseToDom(rawHtml) {
  const template = document.createElement("body");
  template.innerHTML = rawHtml;
  return template;
}
function getParagraphStyle(el) {
  const styles = el.style;
  const paragraphStyle = {};
  for (let i = 0; i < styles.length; i++) {
    const cssRule = styles[i];
    const cssValue = styles.getPropertyValue(cssRule);
    switch (cssRule) {
      case "margin-top": {
        const marginTopValue = Number.parseInt(cssValue);
        paragraphStyle.spaceAbove = { v: /pt/.test(cssValue) ? ptToPixel(marginTopValue) : marginTopValue };
        break;
      }
      case "margin-bottom": {
        const marginBottomValue = Number.parseInt(cssValue);
        paragraphStyle.spaceBelow = { v: /pt/.test(cssValue) ? ptToPixel(marginBottomValue) : marginBottomValue };
        break;
      }
      case "line-height": {
        const lineHeightValue = Number.parseFloat(cssValue);
        paragraphStyle.lineSpacing = lineHeightValue;
        break;
      }
      default: {
        break;
      }
    }
  }
  return Object.getOwnPropertyNames(paragraphStyle).length ? paragraphStyle : null;
}
function generateParagraphs(dataStream, prevParagraph) {
  const paragraphs = [];
  for (let i = 0, len = dataStream.length; i < len; i++) {
    const char = dataStream[i];
    if (char !== "\r" /* PARAGRAPH */) {
      continue;
    }
    paragraphs.push({
      startIndex: i
    });
  }
  if (prevParagraph) {
    for (const paragraph of paragraphs) {
      if (prevParagraph.bullet) {
        paragraph.bullet = Tools.deepClone(prevParagraph.bullet);
      }
      if (prevParagraph.paragraphStyle) {
        paragraph.paragraphStyle = Tools.deepClone(prevParagraph.paragraphStyle);
      }
    }
  }
  return paragraphs;
}
function convertToCellStyle(cell, dataStream, textRuns) {
  var _a, _b, _c;
  const dataStreamLength = dataStream.length;
  const textRunsLength = (_a = textRuns == null ? void 0 : textRuns.length) != null ? _a : 0;
  const canConvertToCellStyle = textRunsLength === 1 && textRuns[0].st === 0 && textRuns[0].ed === dataStreamLength;
  if (cell.p) {
    if (canConvertToCellStyle && ((_c = (_b = cell.p.body) == null ? void 0 : _b.textRuns) == null ? void 0 : _c.length)) {
      cell.p.body.textRuns = [];
      return {
        ...cell,
        s: textRuns[0].ts
      };
    } else {
      return cell;
    }
  } else {
    if (canConvertToCellStyle) {
      return {
        ...cell,
        s: textRuns[0].ts
      };
    } else {
      return cell;
    }
  }
  return cell;
}

// ../packages/sheets-ui/src/services/clipboard/html-to-usm/converter.ts
var sheetStyleRules = [
  // Rich Text Style Rules,
  "color",
  "background",
  "font-size",
  "text-align",
  "vertical-align",
  "font-weight",
  "font-style",
  "font-family",
  "text-decoration",
  "white-space",
  "word-wrap",
  // Border Style Rules,
  "border-left",
  "border-right",
  "border-top",
  "border-bottom",
  // Custom Style Rules, '--' needs to be used as a prefix.
  "--data-rotate"
];
function matchFilter(node, filter2) {
  const tagName = node.tagName.toLowerCase();
  if (typeof filter2 === "string") {
    return tagName === filter2;
  }
  if (Array.isArray(filter2)) {
    return filter2.some((name) => name === tagName);
  }
  return filter2(node);
}
var _HtmlToUSMService = class _HtmlToUSMService {
  constructor(props) {
    __publicField(this, "_styleMap", /* @__PURE__ */ new Map());
    __publicField(this, "_styleCache", /* @__PURE__ */ new Map());
    __publicField(this, "_styleRules", []);
    __publicField(this, "_afterProcessRules", []);
    __publicField(this, "_dom", null);
    __publicField(this, "_getCurrentSkeleton");
    this._getCurrentSkeleton = props.getCurrentSkeleton;
  }
  static use(plugin) {
    if (this._pluginList.includes(plugin)) {
      throw new Error(`Univer paste plugin ${plugin.name} already added`);
    }
    this._pluginList.push(plugin);
  }
  // eslint-disable-next-line max-lines-per-function
  convert(html) {
    const pastePlugin = _HtmlToUSMService._pluginList.find((plugin) => plugin.checkPasteType(html));
    if (pastePlugin) {
      this._styleRules = [...pastePlugin.stylesRules];
      this._afterProcessRules = [...pastePlugin.afterProcessRules];
    }
    const valueMatrix = new ObjectMatrix();
    this._dom = parseToDom(html);
    const style = this._dom.querySelector("style");
    if (style) {
      const shadowHost = document.createElement("div");
      const shadowRoot = shadowHost.attachShadow({ mode: "open" });
      document.body.appendChild(shadowHost);
      shadowRoot.appendChild(style);
      for (const rule of style.sheet.cssRules) {
        const cssRule = rule;
        const selectorText = cssRule.selectorText;
        const style2 = cssRule.style;
        this._styleMap.set(selectorText, style2);
      }
      style.remove();
      shadowHost.remove();
    }
    const newDocBody = {
      dataStream: "",
      textRuns: []
    };
    const rowProperties = [];
    const colProperties = [];
    const tableStrings = html.match(/<table\b[^>]*>([\s\S]*?)<\/table>/gi);
    const tables = [];
    this.process(null, this._dom.childNodes, newDocBody, tables);
    const { paragraphs, dataStream, textRuns, payloads, customRanges } = newDocBody;
    if (paragraphs) {
      const starts = paragraphs.map((p) => p.startIndex + 1);
      starts.unshift(0);
      for (let i = 0; i < starts.length; i++) {
        let cellDataStream;
        if (i === starts.length - 1) {
          cellDataStream = `${dataStream.substring(starts[i])}\r
`;
          if (cellDataStream === "\r\n") {
            continue;
          }
        } else {
          cellDataStream = `${dataStream.substring(starts[i], starts[i + 1] - 1)}\r
`;
        }
        const cellTextRuns = [];
        textRuns == null ? void 0 : textRuns.forEach((t) => {
          if (t.st >= starts[i] && t.ed <= starts[i + 1]) {
            cellTextRuns.push({
              st: t.st - starts[i],
              ed: t.ed - starts[i],
              ts: t.ts
            });
          }
        });
        const cellCustomRanges = [];
        customRanges == null ? void 0 : customRanges.forEach((c) => {
          if (c.startIndex >= starts[i] && c.endIndex <= starts[i + 1]) {
            cellCustomRanges.push({
              ...c,
              startIndex: c.startIndex - starts[i],
              endIndex: c.endIndex - starts[i]
            });
          }
        });
        const p = this._generateDocumentDataModelSnapshot({
          body: {
            dataStream: cellDataStream,
            textRuns: cellTextRuns,
            paragraphs: generateParagraphs(cellDataStream),
            customRanges: cellCustomRanges
          }
        });
        const isEmptyMatrix = Object.keys(valueMatrix.getMatrix()).length === 0;
        valueMatrix.setValue(isEmptyMatrix ? 0 : valueMatrix.getLength(), 0, {
          v: cellDataStream,
          p
        });
        rowProperties.push({});
      }
    } else {
      if (dataStream) {
        const singleDataStream = `${dataStream}\r
`;
        const singleDocBody = {
          dataStream: singleDataStream,
          textRuns,
          paragraphs: generateParagraphs(singleDataStream),
          payloads,
          customRanges
        };
        if (!(customRanges == null ? void 0 : customRanges.length)) {
          valueMatrix.setValue(0, 0, convertToCellStyle({ v: dataStream }, dataStream, textRuns));
        } else {
          const p = this._generateDocumentDataModelSnapshot({
            body: singleDocBody
          });
          valueMatrix.setValue(0, 0, convertToCellStyle({ v: dataStream, p }, dataStream, textRuns));
        }
        rowProperties.push({});
      }
    }
    if (tableStrings) {
      tableStrings.forEach((t, index) => {
        const curRow = valueMatrix.getDataRange().endRow + 1;
        const { cellMatrix, rowProperties: tableRowProp, colProperties: tableColProp } = this._parseTable(t, index);
        if (cellMatrix) {
          cellMatrix.forValue((row, col, value) => {
            valueMatrix.setValue(curRow + row, col, value);
          });
        }
        if (tableColProp) {
          colProperties.push(...tableColProp);
        }
        rowProperties.push(...tableRowProp);
      });
    }
    this.dispose();
    return {
      rowProperties,
      colProperties,
      cellMatrix: valueMatrix
    };
  }
  _getStyleBySelectorText(selectorText, cssText) {
    var _a;
    const css = (_a = this._styleMap.get(selectorText)) == null ? void 0 : _a.getPropertyValue(cssText);
    if (!css) {
      return "";
    }
    return css;
  }
  _getStyle(node, styleStr) {
    const recordStyle = turnToStyleObject(styleStr);
    const style = node.style;
    let newStyleStr = "";
    for (let l = 0; l < sheetStyleRules.length; l++) {
      const key = sheetStyleRules[l];
      if (key === "background") {
        let value2 = "";
        node.classList.forEach((className) => {
          value2 = this._getStyleBySelectorText(`.${className}`, "background-color") || this._getStyleBySelectorText(`.${className}`, key);
        });
        const bgColor = style.getPropertyValue("background-color") || value2 || this._getStyleBySelectorText(`#${node.id}`, "background-color") || this._getStyleBySelectorText(`#${node.id}`, key) || this._getStyleBySelectorText(node.nodeName.toLowerCase(), key) || this._getStyleBySelectorText(node.nodeName, "background-color") || recordStyle["background-color"] || "";
        bgColor && (newStyleStr += `background:${bgColor};`);
        continue;
      }
      if (key === "text-decoration") {
        let value2 = "";
        node.classList.forEach((className) => {
          value2 = this._getStyleBySelectorText(`.${className}`, "text-decoration-line") || this._getStyleBySelectorText(`.${className}`, key);
        });
        const textDecoration = style.getPropertyValue("text-decoration-line") || style.getPropertyValue("text-decoration") || value2 || this._getStyleBySelectorText(`#${node.id}`, "text-decoration-line") || this._getStyleBySelectorText(`#${node.id}`, key) || this._getStyleBySelectorText(node.nodeName.toLowerCase(), key) || this._getStyleBySelectorText(node.nodeName, "text-decoration-line") || recordStyle["text-decoration-line"] || "";
        textDecoration && (newStyleStr += `text-decoration:${textDecoration};`);
        continue;
      }
      let value = "";
      node.classList.forEach((className) => {
        value = this._getStyleBySelectorText(`.${className}`, key);
      });
      value = style.getPropertyValue(key) || this._getStyleBySelectorText(`#${node.id}`, key) || value || this._getStyleBySelectorText(node.nodeName.toLowerCase(), key) || recordStyle[key] || "";
      value && (newStyleStr += `${key}:${value};`);
    }
    return newStyleStr;
  }
  _parseTable(html, tableElIndex) {
    var _a, _b;
    const valueMatrix = new ObjectMatrix();
    const colProperties = (_a = parseColGroup(html)) != null ? _a : [];
    const { rowProperties = [] } = parseTableRows(html);
    const parsedCellMatrix = this._parseTableByHtml(this._dom, tableElIndex, (_b = this._getCurrentSkeleton()) == null ? void 0 : _b.skeleton);
    parsedCellMatrix && parsedCellMatrix.forValue((row, col, value) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
      let style = handleStringToStyle(void 0, value.style);
      if ((_d = (_c = (_b2 = (_a2 = value == null ? void 0 : value.richTextParma) == null ? void 0 : _a2.p) == null ? void 0 : _b2.body) == null ? void 0 : _c.textRuns) == null ? void 0 : _d.length) {
        const textLen = (_f = (_e = value == null ? void 0 : value.richTextParma) == null ? void 0 : _e.v) == null ? void 0 : _f.length;
        for (let i = 0; i < ((_j = (_i = (_h = (_g = value == null ? void 0 : value.richTextParma) == null ? void 0 : _g.p) == null ? void 0 : _h.body) == null ? void 0 : _i.textRuns) == null ? void 0 : _j.length); i++) {
          const textRunItem = (_m = (_l = (_k = value == null ? void 0 : value.richTextParma) == null ? void 0 : _k.p) == null ? void 0 : _l.body) == null ? void 0 : _m.textRuns[i];
          if (textRunItem.st === 0 && textRunItem.ed === textLen) {
            style = { ...textRunItem.ts, ...style };
            (_p = (_o = (_n = value == null ? void 0 : value.richTextParma) == null ? void 0 : _n.p) == null ? void 0 : _o.body) == null ? void 0 : _p.textRuns.splice(i, 1);
            i--;
          }
        }
        if (((_t = (_s = (_r = (_q = value == null ? void 0 : value.richTextParma) == null ? void 0 : _q.p) == null ? void 0 : _r.body) == null ? void 0 : _s.textRuns) == null ? void 0 : _t.length) === 0) {
          value.content = (_u = value == null ? void 0 : value.richTextParma) == null ? void 0 : _u.v;
          delete value.richTextParma;
        }
      }
      const cellValue = ((_x = (_w = (_v = value == null ? void 0 : value.richTextParma) == null ? void 0 : _v.p) == null ? void 0 : _w.body) == null ? void 0 : _x.textRuns) ? {
        v: value.richTextParma.v,
        p: value.richTextParma.p,
        s: style,
        rowSpan: value.rowSpan,
        colSpan: value.colSpan
      } : {
        v: value.content,
        s: style,
        rowSpan: value.rowSpan,
        colSpan: value.colSpan
      };
      valueMatrix.setValue(row, col, cellValue);
    });
    return {
      rowProperties,
      colProperties,
      cellMatrix: valueMatrix
    };
  }
  _parseTableByHtml(htmlElement, tableElIndex, skeleton) {
    var _a, _b;
    const cellMatrix = new ObjectMatrix();
    const tableEle = htmlElement.querySelectorAll("table")[tableElIndex];
    if (!tableEle) {
      return cellMatrix;
    }
    const tableStyle = this._getStyle(tableEle, "");
    const rows = tableEle == null ? void 0 : tableEle.querySelectorAll("tr");
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      const row = rows[rowIndex];
      const rowStyle = this._getStyle(row, tableStyle);
      const cells = row.querySelectorAll("td, th");
      let colSetValueIndex = 0;
      for (let colIndex = 0; colIndex < cells.length; ) {
        const cell = cells[colIndex];
        let cellStyle = "";
        const rowSpan = Number(cell.getAttribute("rowSpan")) || 1;
        const colSpan = Number(cell.getAttribute("colSpan")) || 1;
        cellStyle = this._getStyle(cell, rowStyle);
        if (rowIndex > 0) {
          const cellValueAbove = cellMatrix.getValue(rowIndex - 1, colSetValueIndex);
          if (((_a = cellValueAbove == null ? void 0 : cellValueAbove.style) == null ? void 0 : _a.includes("border-bottom")) && cellStyle.includes("border-top")) {
            const borderBottom = extractStyleProperty(cellValueAbove.style, "border-bottom");
            if (borderBottom && textTrim(borderBottom.substr(borderBottom.indexOf(":") + 1)) !== "none") {
              cellStyle = cellStyle.replace(/border-top:[^;]+;/, "");
            }
          }
        }
        if (colIndex > 0) {
          const cellValueLeft = cellMatrix.getValue(rowIndex, colSetValueIndex - 1);
          if (((_b = cellValueLeft == null ? void 0 : cellValueLeft.style) == null ? void 0 : _b.includes("border-right")) && cellStyle.includes("border-left")) {
            const borderRight = extractStyleProperty(cellValueLeft.style, "border-right");
            if (borderRight && textTrim(borderRight.substr(borderRight.indexOf(":") + 1)) !== "none") {
              cellStyle = cellStyle.replace(/border-left:[^;]+;/, "");
            }
          }
        }
        const { cellText, cellRichStyle } = this._getCellTextAndRichText(cell, cellStyle, skeleton);
        const cellValue = {
          rowSpan,
          colSpan,
          content: cellText,
          style: cellStyle,
          richTextParma: {
            p: cellRichStyle,
            v: cellText
          }
        };
        if (cellMatrix.getValue(rowIndex, colSetValueIndex)) {
          colSetValueIndex += 1;
          continue;
        } else {
          if (rowSpan > 1 || colSpan > 1) {
            setMergedCellStyle(cellMatrix, cellStyle, cellValue, { colSpan, rowSpan, rowIndex, colIndex, colSetValueIndex });
          } else {
            cellMatrix.setValue(rowIndex, colSetValueIndex, cellValue);
          }
          colSetValueIndex += colSpan;
          colIndex++;
        }
      }
    }
    return cellMatrix;
  }
  _parseCellHtml(parent, nodes, doc, styleCache = /* @__PURE__ */ new Map(), styleStr) {
    var _a;
    for (const node of nodes) {
      if (node.nodeType === Node.TEXT_NODE) {
        const text = (_a = node.nodeValue) == null ? void 0 : _a.replace(/[\r\n]/g, "");
        let style;
        if (parent && styleCache.has(parent)) {
          style = styleCache.get(parent);
        }
        doc.dataStream += text;
        if (style && Object.getOwnPropertyNames(style).length) {
          doc.textRuns.push({
            st: doc.dataStream.length - text.length,
            ed: doc.dataStream.length,
            ts: style
          });
        }
      } else if (node.nodeType === Node.COMMENT_NODE || node.nodeName === "STYLE") {
        continue;
      } else if (node.nodeName.toLowerCase() === "br") {
        if (!doc.paragraphs) {
          doc.paragraphs = [];
        }
        doc.paragraphs.push({ startIndex: doc.dataStream.length });
        doc.dataStream += "\r";
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const currentNodeStyle = this._getStyle(node, styleStr);
        const parentStyles = parent ? styleCache.get(parent) : {};
        const predefinedStyles = turnToStyleObject(currentNodeStyle);
        const nodeStyles = extractNodeStyle(node, predefinedStyles);
        styleCache.set(node, { ...parentStyles, ...nodeStyles });
        const { childNodes } = node;
        this._parseCellHtml(node, childNodes, doc, styleCache, currentNodeStyle);
      }
    }
  }
  _getCellTextAndRichText(cell, styleStr, skeleton) {
    var _a;
    let cellText = "";
    let cellRichStyle;
    const isRichText2 = /<[^>]+>/.test(cell.innerHTML);
    if (isRichText2 && skeleton) {
      const newDocBody = {
        dataStream: "",
        textRuns: []
      };
      this._parseCellHtml(null, cell.childNodes, newDocBody, void 0, styleStr);
      const documentModel = (_a = skeleton.getBlankCellDocumentModel()) == null ? void 0 : _a.documentModel;
      const p = documentModel == null ? void 0 : documentModel.getSnapshot();
      const singleDataStream = `${newDocBody.dataStream}\r
`;
      const documentData = {
        ...p,
        ...{
          body: {
            dataStream: singleDataStream,
            textRuns: newDocBody.textRuns,
            paragraphs: generateParagraphs(singleDataStream)
          }
        }
      };
      documentModel == null ? void 0 : documentModel.reset(documentData);
      cellRichStyle = documentModel == null ? void 0 : documentModel.getSnapshot();
      cellText = newDocBody.dataStream;
    } else {
      cellText = decodeHTMLEntities(cell.innerHTML.replace(/[\r\n]/g, ""));
    }
    return {
      cellText,
      cellRichStyle
    };
  }
  _generateDocumentDataModelSnapshot(snapshot) {
    var _a;
    const currentSkeleton = this._getCurrentSkeleton();
    if (currentSkeleton == null) {
      return null;
    }
    const { skeleton } = currentSkeleton;
    const documentModel = (_a = skeleton.getBlankCellDocumentModel()) == null ? void 0 : _a.documentModel;
    const p = documentModel == null ? void 0 : documentModel.getSnapshot();
    const documentData = { ...p, ...snapshot };
    documentModel == null ? void 0 : documentModel.reset(documentData);
    return documentModel == null ? void 0 : documentModel.getSnapshot();
  }
  process(parent, nodes, doc, tables) {
    var _a, _b, _c;
    for (const node of nodes) {
      if (node.nodeName.toLowerCase() === "table") {
        tables.push({
          index: ((_a = doc == null ? void 0 : doc.paragraphs) == null ? void 0 : _a.length) || 0
        });
      } else if (node.nodeType === Node.TEXT_NODE) {
        if (((_b = node.nodeValue) == null ? void 0 : _b.trim()) === "") {
          continue;
        }
        const text = (_c = node.nodeValue) == null ? void 0 : _c.replace(/[\r\n]/g, "");
        let style;
        if (parent && this._styleCache.has(parent)) {
          style = this._styleCache.get(parent);
        }
        const newDoc = {
          dataStream: "",
          textRuns: []
        };
        doc.dataStream += text;
        newDoc.dataStream += text;
        if (style && Object.getOwnPropertyNames(style).length) {
          doc.textRuns.push({
            st: doc.dataStream.length - text.length,
            ed: doc.dataStream.length,
            ts: style
          });
          newDoc.textRuns.push({
            st: doc.dataStream.length - text.length,
            ed: doc.dataStream.length,
            ts: style
          });
        }
      } else if (skipParseTagNames.includes(node.nodeName.toLowerCase())) {
        continue;
      } else if (node.nodeName.toLowerCase() === "br") {
        if (!doc.paragraphs) {
          doc.paragraphs = [];
        }
        doc.paragraphs.push({ startIndex: doc.dataStream.length });
        doc.dataStream += "\r";
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        if (node.nodeName === "STYLE") {
          continue;
        }
        const element = node;
        const linkStart = this._processBeforeLink(element, { body: doc });
        const parentStyles = parent ? this._styleCache.get(parent) : {};
        const styleRule = this._styleRules.find(({ filter: filter2 }) => matchFilter(node, filter2));
        const nodeStyles = styleRule ? styleRule.getStyle(node) : extractNodeStyle(node);
        this._styleCache.set(node, { ...parentStyles, ...nodeStyles });
        const { childNodes } = node;
        this.process(node, childNodes, doc, tables);
        const afterProcessRule = this._afterProcessRules.find(
          ({ filter: filter2 }) => matchFilter(node, filter2)
        );
        if (afterProcessRule) {
          afterProcessRule.handler(doc, node);
        }
        this._processAfterLink(element, { body: doc }, linkStart);
      }
    }
  }
  _processBeforeLink(node, doc) {
    const body = doc.body;
    return body.dataStream.length;
  }
  _processAfterLink(node, doc, start) {
    var _a, _b;
    const body = doc.body;
    const element = node;
    if (element.tagName.toUpperCase() === "A") {
      body.customRanges = (_a = body.customRanges) != null ? _a : [];
      body.customRanges.push({
        startIndex: start,
        endIndex: body.dataStream.length - 1,
        rangeId: (_b = element.dataset.rangeid) != null ? _b : generateRandomId(),
        rangeType: 0 /* HYPERLINK */,
        properties: { url: element.href }
      });
    }
  }
  dispose() {
    this._dom = null;
    this._styleCache.clear();
    this._styleMap.clear();
  }
};
__publicField(_HtmlToUSMService, "_pluginList", []);
var HtmlToUSMService = _HtmlToUSMService;
function parseTableRows(html) {
  const ROWS_REGEX = /<tr([\s\S]*?)>([\s\S]*?)<\/tr>/gi;
  const rowMatches = html.matchAll(ROWS_REGEX);
  if (!rowMatches) {
    return {
      rowProperties: [],
      rowCount: 0
    };
  }
  const rowMatchesAsArray = Array.from(rowMatches);
  const rowProperties = rowMatchesAsArray.map((rowMatch) => parseProperties(rowMatch[1])).map((properties) => {
    if (!properties.height) {
      const style = properties.style;
      const match = style && style.match(/height\s*:\s*(\d+(\.\d+)?)px/);
      properties.height = `${match ? Number.parseInt(match[1], 10) : DEFAULT_WORKSHEET_ROW_HEIGHT}`;
    }
    return properties;
  });
  return {
    rowProperties,
    rowCount: rowProperties.length
  };
}
function turnToStyleObject(styleStr) {
  const styleObj = {};
  const styleArr = styleStr.split(";");
  styleArr.forEach((style) => {
    const [key, value] = style.split(":");
    styleObj[key] = value;
  });
  return styleObj;
}
function parseProperties(propertyStr) {
  if (!propertyStr) {
    return {};
  }
  const property = {};
  const PROPERTY_REGEX = /([\w-]+)\s*=\s*(?:(['"])([^'"]*)\2|(\S+))/g;
  let match;
  while ((match = PROPERTY_REGEX.exec(propertyStr)) !== null) {
    const [, attributeName, , attributeValue1, attributeValue2] = match;
    const attributeValue = attributeValue1 !== void 0 ? attributeValue1 : attributeValue2;
    property[attributeName] = attributeValue;
  }
  return property;
}
function parseColGroup(raw) {
  const COLGROUP_TAG_REGEX = /<colgroup([\s\S]*?)>(.*?)<\/colgroup>/;
  const colgroupMatch = raw.match(COLGROUP_TAG_REGEX);
  const COL_TAG_REGEX = /<col([\s\S]*?)>/g;
  let colMatches;
  if (colgroupMatch == null ? void 0 : colgroupMatch[2]) {
    colMatches = colgroupMatch[2].matchAll(COL_TAG_REGEX);
  } else {
    colMatches = raw.matchAll(COL_TAG_REGEX);
  }
  if (!colMatches) {
    return null;
  }
  const colPropertiesWithSpan = Array.from(colMatches).map((colMatch) => parseProperties(colMatch[1]));
  const colProperties = [];
  colPropertiesWithSpan.forEach((propertiesWithSpan) => {
    const span = Number(propertiesWithSpan.span);
    if (span) {
      for (let i = 0; i < span; i++) {
        const propertiesWithoutSpan = { ...propertiesWithSpan };
        delete propertiesWithoutSpan.span;
        colProperties.push(propertiesWithoutSpan);
      }
    } else {
      colProperties.push(propertiesWithSpan);
    }
  });
  return colProperties;
}
function decodeHTMLEntities(input) {
  const entities = {
    "&lt;": "<",
    "&gt;": ">",
    "&amp;": "&",
    "&quot;": '"',
    "&#39;": "'",
    "&nbsp;": " "
  };
  return input.replace(/&lt;|&gt;|&amp;|&quot;|&#39;|&nbsp;|<br>/g, (match) => entities[match]);
}
function extractStyleProperty(styleString, propertyName) {
  if (!styleString || !propertyName) return null;
  const regex = new RegExp(`(${propertyName}\\s*:\\s*[^;]+);`, "i");
  const match = styleString.match(regex);
  if (match) {
    return match[1];
  }
  return null;
}
function setMergedCellStyle(cellMatrix, cellStyle, cellValue, indexParams) {
  const { rowSpan, colSpan, rowIndex, colSetValueIndex } = indexParams;
  for (let i = rowIndex; i < rowIndex + rowSpan; i++) {
    for (let j = colSetValueIndex; j < colSetValueIndex + colSpan; j++) {
      if (i === rowIndex && j === colSetValueIndex) {
        cellMatrix.setValue(i, j, { ...cellValue, style: cellStyle });
      } else {
        cellMatrix.setValue(i, j, { style: cellStyle });
      }
    }
  }
}

// ../packages/sheets-ui/src/services/clipboard/html-to-usm/paste-plugins/plugin-lark.ts
var LarkPastePlugin = {
  name: "univer-doc-paste-plugin-lark",
  checkPasteType(html) {
    return /lark-record-clipboard/i.test(html);
  },
  // TODO: @JOCS, support inline code copy from lark.
  stylesRules: [
    {
      filter: ["s"],
      getStyle(node) {
        const inlineStyle = extractNodeStyle(node);
        return {
          st: {
            s: 1 /* TRUE */
          },
          ...inlineStyle
        };
      }
    }
  ],
  afterProcessRules: [
    {
      filter(el) {
        return el.tagName === "DIV" && /ace-line/i.test(el.className);
      },
      handler(doc) {
        if (doc.paragraphs == null) {
          doc.paragraphs = [];
        }
        doc.paragraphs.push({
          startIndex: doc.dataStream.length
        });
        doc.dataStream += "\r";
      }
    }
  ]
};

// ../packages/sheets-ui/src/services/clipboard/html-to-usm/paste-plugins/plugin-univer.ts
var UniverPastePlugin = {
  name: "univer-doc-paste-plugin-univer",
  checkPasteType(html) {
    return /UniverNormal/i.test(html);
  },
  stylesRules: [],
  afterProcessRules: [
    {
      filter(el) {
        return el.tagName === "P" && /UniverNormal/i.test(el.className);
      },
      handler(doc, el) {
        if (doc.paragraphs == null) {
          doc.paragraphs = [];
        }
        const paragraph = {
          startIndex: doc.dataStream.length
        };
        const paragraphStyle = getParagraphStyle(el);
        if (paragraphStyle) {
          paragraph.paragraphStyle = paragraphStyle;
        }
        doc.paragraphs.push(paragraph);
        doc.dataStream += "\r";
      }
    }
  ]
};

// ../packages/sheets-ui/src/services/clipboard/html-to-usm/paste-plugins/plugin-word.ts
var WordPastePlugin = {
  name: "univer-doc-paste-plugin-word",
  checkPasteType(html) {
    return /word|mso/i.test(html);
  },
  stylesRules: [
    {
      filter: ["b"],
      getStyle(node) {
        const inlineStyle = extractNodeStyle(node);
        return { bl: 1 /* TRUE */, ...inlineStyle };
      }
    }
  ],
  afterProcessRules: [
    {
      filter(el) {
        return el.tagName === "P" && /mso/i.test(el.className);
      },
      handler(doc, el) {
        if (doc.paragraphs == null) {
          doc.paragraphs = [];
        }
        const paragraph = {
          startIndex: doc.dataStream.length
        };
        const paragraphStyle = getParagraphStyle(el);
        if (paragraphStyle) {
          paragraph.paragraphStyle = paragraphStyle;
        }
        doc.paragraphs.push(paragraph);
        doc.dataStream += "\r";
      }
    }
  ]
};

// ../packages/sheets-ui/src/services/clipboard/usm-to-html/convertor.ts
function getRowContent(row, cols, hooks, matrix, mergeSet) {
  const properties = hooks.map((hook) => {
    var _a;
    return (_a = hook.onCopyRow) == null ? void 0 : _a.call(hook, row);
  }).filter((v) => !!v);
  const mergedProperties = mergeProperties(properties);
  const str = zipClipboardPropertyItemToString(mergedProperties);
  const tds = cols.map((col) => {
    if (!mergeSet.has(`${row}-${col}`)) {
      const v = matrix.getValue(row, col);
      if ((v == null ? void 0 : v.rowSpan) && (v == null ? void 0 : v.colSpan)) {
        for (let i = row; i < row + v.rowSpan; i++) {
          for (let j = col; j < col + v.colSpan; j++) {
            mergeSet.add(`${i}-${j}`);
          }
        }
      }
      return getTDContent(row, col, hooks, matrix);
    }
    return null;
  }).filter((v) => !!v).join("");
  return `<tr${str}>${tds}</tr>`;
}
function getTDContent(row, col, hooks, matrix) {
  const v = matrix.getValue(row, col);
  const properties = hooks.map((hook) => {
    var _a;
    return (_a = hook.onCopyCellStyle) == null ? void 0 : _a.call(hook, row, col, v == null ? void 0 : v.rowSpan, v == null ? void 0 : v.colSpan);
  }).filter((v2) => !!v2);
  const mergedProperties = mergeProperties(properties);
  const str = zipClipboardPropertyItemToString(mergedProperties);
  const content = hooks.reduce((acc, hook) => {
    var _a;
    return acc || ((_a = hook.onCopyCellContent) == null ? void 0 : _a.call(hook, row, col)) || "";
  }, "");
  return `<td${str}>${content}</td>`;
}
function getColStyle(cols, hooks) {
  const str = cols.map((col) => {
    const properties = hooks.map((hook) => {
      var _a;
      return (_a = hook.onCopyColumn) == null ? void 0 : _a.call(hook, col);
    }).filter((v) => !!v);
    const mergedProperties = mergeProperties(properties);
    const str2 = zipClipboardPropertyItemToString(mergedProperties);
    return `<col ${str2} />`;
  }).join("");
  return `<colgroup>${str}</colgroup>`;
}
function mergeProperties(properties) {
  return properties.reduce((acc, cur) => {
    const keys = Object.keys(cur);
    keys.forEach((key) => {
      if (!acc[key]) {
        acc[key] = cur[key];
      } else {
        acc[key] += `;${cur[key]}`;
      }
    });
    return acc;
  }, {});
}
function zipClipboardPropertyItemToString(item) {
  return Object.keys(item).reduce((acc, cur) => `${acc} ${cur}="${item[cur]}"`, "");
}
var USMToHtmlService = class {
  convert(matrix, range, hooks) {
    const { cols, rows } = range;
    if (!cols.length) {
      return "";
    }
    const colStyles = getColStyle(cols, hooks);
    const rowContents = [];
    const mergeSet = /* @__PURE__ */ new Set();
    rows.forEach((row) => {
      rowContents.push(getRowContent(row, cols, hooks, matrix, mergeSet));
    });
    const html = `<google-sheets-html-origin><table xmlns="http://www.w3.org/1999/xhtml" cellspacing="0" cellpadding="0" dir="ltr" style="table-layout:fixed;font-size:10pt;font-family:Arial;width:0px;border-collapse:collapse;border:none">${colStyles}
<tbody>${rowContents.join("")}</tbody></table>`;
    return html;
  }
};

// ../packages/sheets-ui/src/services/clipboard/utils.ts
var getRepeatRange = (sourceRange, targetRange, isStrictMode = false) => {
  const getRowLength = (range) => range.endRow - range.startRow + 1;
  const getColLength = (range) => range.endColumn - range.startColumn + 1;
  const rowMod = getRowLength(targetRange) % getRowLength(sourceRange);
  const colMod = getColLength(targetRange) % getColLength(sourceRange);
  const repeatRelativeRange = {
    startRow: 0,
    endRow: getRowLength(sourceRange) - 1,
    startColumn: 0,
    endColumn: getColLength(sourceRange) - 1
  };
  const repeatRow = Math.floor(getRowLength(targetRange) / getRowLength(sourceRange));
  const repeatCol = Math.floor(getColLength(targetRange) / getColLength(sourceRange));
  const repeatList = [];
  if (!rowMod && !colMod) {
    for (let countRow = 1; countRow <= repeatRow; countRow++) {
      for (let countCol = 1; countCol <= repeatCol; countCol++) {
        const row = getRowLength(sourceRange) * (countRow - 1);
        const col = getColLength(sourceRange) * (countCol - 1);
        const startRange = {
          startRow: row + targetRange.startRow,
          endRow: row + targetRange.startRow,
          startColumn: col + targetRange.startColumn,
          endColumn: col + targetRange.startColumn
        };
        repeatList.push({ repeatRelativeRange, startRange });
      }
    }
  } else if (!rowMod && colMod && !isStrictMode) {
    for (let countRow = 1; countRow <= repeatRow; countRow++) {
      const row = getRowLength(sourceRange) * (countRow - 1);
      const col = 0;
      const startRange = {
        startRow: row + targetRange.startRow,
        endRow: row + targetRange.startRow,
        startColumn: col + targetRange.startColumn,
        endColumn: col + targetRange.startColumn
      };
      repeatList.push({ repeatRelativeRange, startRange });
    }
  } else if (rowMod && !colMod && !isStrictMode) {
    for (let countCol = 1; countCol <= repeatCol; countCol++) {
      const row = 0;
      const col = getColLength(sourceRange) * (countCol - 1);
      const startRange = {
        startRow: row + targetRange.startRow,
        endRow: row + targetRange.startRow,
        startColumn: col + targetRange.startColumn,
        endColumn: col + targetRange.startColumn
      };
      repeatList.push({ repeatRelativeRange, startRange });
    }
  } else {
    const startRange = {
      startRow: targetRange.startRow,
      endRow: targetRange.startRow,
      startColumn: targetRange.startColumn,
      endColumn: targetRange.startColumn
    };
    repeatList.push({ startRange, repeatRelativeRange });
  }
  return repeatList;
};
function htmlIsFromExcel(html) {
  if (!html) {
    return false;
  }
  const excelMarkers = [
    // Excel class names
    /<td[^>]*class=".*?xl.*?"[^>]*>/i,
    // Excel namespace
    /xmlns:x="urn:schemas-microsoft-com:office:excel"/i,
    // Excel ProgID
    /ProgId="Excel.Sheet"/i,
    // Office specific namespace
    /xmlns:o="urn:schemas-microsoft-com:office:office"/i,
    // Excel specific style markers
    /@mso-|mso-excel/i,
    // Excel workbook metadata
    /<x:ExcelWorkbook>/i
  ];
  return excelMarkers.some((marker) => marker.test(html));
}
function htmlContainsImage(html) {
  if (!html) {
    return false;
  }
  const base64ImageRegex = /<img[^>]*src\s*=\s*["']data:image\/[^;]+;base64,[^"']*["'][^>]*>/i;
  ;
  const images = html.match(base64ImageRegex) || [];
  return images.length > 0;
}
function mergeCellValues(...cellValues) {
  if (cellValues.length === 1) {
    return cellValues[0];
  }
  const newMatrix = new ObjectMatrix();
  cellValues.forEach((cellValue) => {
    if (cellValue) {
      const matrix = new ObjectMatrix(cellValue);
      matrix.forValue((row, col, value) => {
        newMatrix.setValue(row, col, { ...newMatrix.getValue(row, col), ...value });
      });
    }
  });
  return newMatrix.getMatrix();
}
function getRangeValuesMergeable(m1, m2) {
  return m1.id === m2.id && m1.params.unitId === m2.params.unitId && m1.params.subUnitId === m2.params.subUnitId;
}
function mergeSetRangeValues(mutations) {
  const newMutations = [];
  for (let i = 0; i < mutations.length; ) {
    let cursor = 1;
    if (mutations[i].id === SetRangeValuesMutation.id) {
      const current = mutations[i];
      const toMerge = [current];
      while (i + cursor < mutations.length && getRangeValuesMergeable(current, mutations[i + cursor])) {
        toMerge.push(mutations[i + cursor]);
        cursor += 1;
      }
      const merged = mergeCellValues(...toMerge.map((m) => m.params.cellValue || {}));
      newMutations.push({
        ...current,
        params: {
          ...current.params,
          cellValue: merged
        }
      });
    } else {
      newMutations.push(mutations[i]);
    }
    i += cursor;
  }
  return newMutations;
}
function rangeIntersectWithDiscreteRange(range, discrete) {
  const { startRow, endRow, startColumn, endColumn } = range;
  for (let i = startRow; i <= endRow; i++) {
    for (let j = startColumn; j <= endColumn; j++) {
      if (discrete.rows.includes(i) && discrete.cols.includes(j)) {
        return true;
      }
    }
  }
}
function discreteRangeContainsRange(discrete, range) {
  const { startRow, endRow, startColumn, endColumn } = range;
  for (let i = startRow; i <= endRow; i++) {
    if (!discrete.rows.includes(i)) {
      return false;
    }
  }
  for (let j = startColumn; j <= endColumn; j++) {
    if (!discrete.cols.includes(j)) {
      return false;
    }
  }
  return true;
}
function convertTextToTable(text) {
  const rows = text.trim().split("\n");
  let html = "<table>";
  rows.forEach((row) => {
    const columns = row.split("	");
    html += "<tr>";
    columns.forEach((column) => {
      html += `<td>${column}</td>`;
    });
    html += "</tr>";
  });
  html += "</table>";
  return html;
}

// ../packages/sheets-ui/src/services/clipboard/clipboard.service.ts
var PREDEFINED_HOOK_NAME = {
  DEFAULT_COPY: "default-copy",
  DEFAULT_PASTE: "default-paste",
  SPECIAL_PASTE_VALUE: "special-paste-value",
  SPECIAL_PASTE_FORMAT: "special-paste-format",
  SPECIAL_PASTE_COL_WIDTH: "special-paste-col-width",
  SPECIAL_PASTE_BESIDES_BORDER: "special-paste-besides-border",
  SPECIAL_PASTE_FORMULA: "special-paste-formula"
};
var IMAGE_MIME_TO_EXTENSION = {
  [FILE_PNG_CLIPBOARD_MIME_TYPE]: "png",
  [FILE__JPEG_CLIPBOARD_MIME_TYPE]: "jpg",
  [FILE__WEBP_CLIPBOARD_MIME_TYPE]: "webp",
  [FILE__BMP_CLIPBOARD_MIME_TYPE]: "bmp"
};
HtmlToUSMService.use(WordPastePlugin);
HtmlToUSMService.use(LarkPastePlugin);
HtmlToUSMService.use(UniverPastePlugin);
var ISheetClipboardService = createIdentifier("sheet.clipboard-service");
var SheetClipboardService = class extends Disposable {
  constructor(_logService, _univerInstanceService, _selectionManagerService, _clipboardInterfaceService, _undoRedoService, _commandService, _markSelectionService, _notificationService, _platformService, _renderManagerService, _themeService, _localeService, _errorService, _injector) {
    super();
    this._logService = _logService;
    this._univerInstanceService = _univerInstanceService;
    this._selectionManagerService = _selectionManagerService;
    this._clipboardInterfaceService = _clipboardInterfaceService;
    this._undoRedoService = _undoRedoService;
    this._commandService = _commandService;
    this._markSelectionService = _markSelectionService;
    this._notificationService = _notificationService;
    this._platformService = _platformService;
    this._renderManagerService = _renderManagerService;
    this._themeService = _themeService;
    this._localeService = _localeService;
    this._errorService = _errorService;
    this._injector = _injector;
    __publicField(this, "_clipboardHooks", []);
    __publicField(this, "_clipboardHooks$", new BehaviorSubject([]));
    __publicField(this, "clipboardHooks$", this._clipboardHooks$.asObservable());
    __publicField(this, "_htmlToUSM");
    __publicField(this, "_usmToHtml");
    __publicField(this, "_copyContentCache");
    __publicField(this, "_copyMarkId", null);
    // Record the parsed matrix and row and column attributes
    __publicField(this, "_pasteOptionsCache$", new BehaviorSubject(null));
    __publicField(this, "pasteOptionsCache$", this._pasteOptionsCache$.asObservable());
    //Control the visibility of the Paste Options menu
    __publicField(this, "_showMenu$", new BehaviorSubject(false));
    __publicField(this, "showMenu$", this._showMenu$.asObservable());
    this._htmlToUSM = new HtmlToUSMService({
      getCurrentSkeleton: () => {
        var _a;
        return (_a = withCurrentTypeOfRenderer(
          O.UNIVER_SHEET,
          SheetSkeletonManagerService,
          this._univerInstanceService,
          this._renderManagerService
        )) == null ? void 0 : _a.getCurrentParam();
      }
    });
    this._usmToHtml = new USMToHtmlService();
    this._copyContentCache = new CopyContentCache();
    this.disposeWithMe(this._htmlToUSM);
    this._initUnitDisposed();
  }
  setShowMenu(show) {
    this._showMenu$.next(show);
  }
  getPasteMenuVisible() {
    return this._showMenu$.getValue();
  }
  getPasteOptionsCache() {
    return this._pasteOptionsCache$.getValue();
  }
  copyContentCache() {
    return this._copyContentCache;
  }
  generateCopyContent(workbookId, worksheetId, range, copyType = "COPY" /* COPY */) {
    const hooks = this._clipboardHooks;
    hooks.forEach((h) => {
      var _a;
      return (_a = h.onBeforeCopy) == null ? void 0 : _a.call(h, workbookId, worksheetId, range, copyType);
    });
    const copyContent = this._generateCopyContent(workbookId, worksheetId, range, this._clipboardHooks);
    hooks.forEach((h) => {
      var _a;
      return (_a = h.onAfterCopy) == null ? void 0 : _a.call(h);
    });
    return copyContent;
  }
  async copy(copyType = "COPY" /* COPY */) {
    const selection = this._selectionManagerService.getCurrentLastSelection();
    if (!selection) {
      return false;
    }
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      return false;
    }
    const workbookId = workbook.getUnitId();
    const worksheetId = worksheet.getSheetId();
    const copyContent = this.generateCopyContent(workbookId, worksheetId, selection.range);
    if (!copyContent) {
      return false;
    }
    const { html, plain, matrixFragment, copyId, discreteRange } = copyContent;
    this._copyContentCache.set(copyId, {
      unitId: workbook.getUnitId(),
      subUnitId: worksheet.getSheetId(),
      range: discreteRange,
      matrix: matrixFragment,
      copyType
    });
    await this._clipboardInterfaceService.write(plain, html);
    this._markSelectionService.removeAllShapes();
    const style = createCopyPasteSelectionStyle(this._themeService);
    this._copyMarkId = this._markSelectionService.addShape({ ...selection, style });
    return true;
  }
  async cut() {
    return this.copy("CUT" /* CUT */);
  }
  async paste(item, pasteType = PREDEFINED_HOOK_NAME.DEFAULT_PASTE) {
    const types = item.types;
    const text = types.indexOf(PLAIN_TEXT_CLIPBOARD_MIME_TYPE) !== -1 ? await item.getType(PLAIN_TEXT_CLIPBOARD_MIME_TYPE).then((blob) => blob && blob.text()) : "";
    const html = types.indexOf(HTML_CLIPBOARD_MIME_TYPE) !== -1 ? await item.getType(HTML_CLIPBOARD_MIME_TYPE).then((blob) => blob && blob.text()) : "";
    const imageIndex = types.findIndex((type) => imageMimeTypeSet.has(type));
    const shouldUseHTMLPaste = imageIndex === -1 || !htmlContainsImage(html);
    if (html && shouldUseHTMLPaste) {
      if (this._platformService.isWindows && htmlIsFromExcel(html)) {
        this._notificationService.show({
          type: "warning",
          title: this._localeService.t("clipboard.shortCutNotify.title"),
          content: this._localeService.t("clipboard.shortCutNotify.useShortCutInstead")
        });
      }
      return this._pasteHTML(html, pasteType);
    }
    if (imageIndex !== -1) {
      const imageMimeType = types[imageIndex];
      const imageBlob = await item.getType(imageMimeType);
      if (imageBlob) {
        const imageExtension = IMAGE_MIME_TO_EXTENSION[imageMimeType];
        const file = new File(
          [imageBlob],
          `clipboard-image.${imageExtension}`,
          { type: imageMimeType }
        );
        return this._pasteFiles([file], pasteType);
      }
    }
    if (text) {
      return this._pastePlainText(text, pasteType);
    }
    this._logService.error("[SheetClipboardService]", "No valid data on clipboard");
    return false;
  }
  async legacyPaste(html, text, files) {
    const isFromExcel = htmlIsFromExcel(html != null ? html : "");
    if (files && !isFromExcel) {
      return this._pasteFiles(files, PREDEFINED_HOOK_NAME.DEFAULT_PASTE);
    } else if (html) {
      return this._pasteHTML(html, PREDEFINED_HOOK_NAME.DEFAULT_PASTE);
    } else if (text) {
      if (/[\n\t]/.test(text)) {
        return this._pasteHTML(convertTextToTable(text), PREDEFINED_HOOK_NAME.DEFAULT_PASTE);
      } else {
        return this._pastePlainText(text, PREDEFINED_HOOK_NAME.DEFAULT_PASTE);
      }
    } else {
      return this._pasteUnrecognized();
    }
  }
  rePasteWithPasteType(type) {
    const pasteOptionsCache = this._pasteOptionsCache$.getValue();
    if (!pasteOptionsCache) {
      return false;
    }
    const undoRedoService = this._injector.get(IUndoRedoService);
    const element = undoRedoService.pitchTopUndoElement();
    if (element) {
      const result = sequenceExecute(element.undoMutations, this._commandService);
      if (result) {
        undoRedoService.popUndoToRedo();
      }
    }
    const { cellMatrix, rowProperties = [], colProperties = [], source, target } = pasteOptionsCache;
    this._pasteUSM({
      cellMatrix,
      colProperties,
      rowProperties
    }, target, PREDEFINED_HOOK_NAME[type], source);
    return true;
  }
  updatePasteOptionsCache(cache) {
    this._pasteOptionsCache$.next(cache);
  }
  addClipboardHook(hook) {
    if (this._clipboardHooks.findIndex((h) => h.id === hook.id) !== -1) {
      this._logService.error("[SheetClipboardService]", "hook already exists", hook.id);
      return { dispose: () => {
      } };
    }
    const insertIndex = this._clipboardHooks.findIndex((existingHook) => {
      const existingHookPriority = existingHook.priority || 0;
      const hookPriority = hook.priority || 0;
      return hookPriority < existingHookPriority;
    });
    this._clipboardHooks.splice(insertIndex !== -1 ? insertIndex : this._clipboardHooks.length, 0, hook);
    this._notifyClipboardHook();
    return toDisposable(() => {
      const index = this._clipboardHooks.indexOf(hook);
      if (index > -1) {
        this._clipboardHooks.splice(index, 1);
        this._notifyClipboardHook();
      }
    });
  }
  getClipboardHooks() {
    return this._clipboardHooks;
  }
  _generateCopyContent(unitId, subUnitId, range, hooks) {
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    if (!workbook || !worksheet) {
      return null;
    }
    const filteredRows = hooks.reduce((acc, cur) => {
      var _a;
      const rows = (_a = cur.getFilteredOutRows) == null ? void 0 : _a.call(cur, range);
      rows == null ? void 0 : rows.forEach((r) => acc.add(r));
      return acc;
    }, /* @__PURE__ */ new Set());
    const { startColumn, startRow, endColumn, endRow } = range;
    const matrix = worksheet.getMatrixWithMergedCells(startRow, startColumn, endRow, endColumn, "both" /* Both */);
    const matrixFragment = new ObjectMatrix();
    let rowIndex = startRow;
    const plainMatrix = new ObjectMatrix();
    const discreteRange = { rows: [], cols: [] };
    for (let r = startRow; r <= endRow; r++) {
      if (filteredRows.has(r)) {
        continue;
      }
      discreteRange.rows.push(r);
      for (let c = startColumn; c <= endColumn; c++) {
        const cellData = matrix.getValue(r, c);
        if (cellData) {
          const newCellData = Tools.deepClone(cellData);
          plainMatrix.setValue(rowIndex - startRow, c - startColumn, {
            ...getEmptyCell(),
            ...newCellData
          });
          delete newCellData.displayV;
          matrixFragment.setValue(rowIndex - startRow, c - startColumn, {
            ...getEmptyCell(),
            ...newCellData
          });
        } else {
          plainMatrix.setValue(rowIndex - startRow, c - startColumn, getEmptyCell());
          matrixFragment.setValue(rowIndex - startRow, c - startColumn, getEmptyCell());
          matrix.setValue(r, c, getEmptyCell());
        }
      }
      rowIndex += 1;
    }
    for (let c = startColumn; c <= endColumn; c++) {
      discreteRange.cols.push(c);
    }
    let html = this._usmToHtml.convert(matrix, discreteRange, hooks);
    const plain = getMatrixPlainText(plainMatrix);
    const copyId = genId();
    html = html.replace(/(<[a-z]+)/, (_p0, p1) => `${p1} data-copy-id="${copyId}"`);
    return {
      copyId,
      plain,
      html,
      matrixFragment,
      discreteRange
    };
  }
  _notifyClipboardHook() {
    this._clipboardHooks$.next(this._clipboardHooks);
  }
  async _executePaste(generateMutations) {
    const target = this._getPastingTarget();
    if (!target.subUnitId || !target.selection) {
      return false;
    }
    const range = this._injector.invoke((accessor) => {
      return rangeToDiscreteRange(target.selection.range, accessor, target.unitId, target.subUnitId);
    });
    if (!range) {
      return false;
    }
    const { unitId, subUnitId } = target;
    const hooks = this._clipboardHooks;
    const enabledHooks = [];
    const disableCopying = hooks.some(
      (h) => {
        var _a;
        return enabledHooks.push(h) && ((_a = h.onBeforePaste) == null ? void 0 : _a.call(h, { unitId, subUnitId, range })) === false;
      }
    );
    if (disableCopying) {
      enabledHooks.forEach((h) => {
        var _a;
        return (_a = h.onAfterPaste) == null ? void 0 : _a.call(h, false);
      });
      return false;
    }
    const redoMutationsInfo = [];
    const undoMutationsInfo = [];
    enabledHooks.forEach((h) => {
      const contentReturn = generateMutations(h, {
        unitId,
        subUnitId,
        range
      });
      if (contentReturn) {
        redoMutationsInfo.push(...contentReturn.redos);
        undoMutationsInfo.push(...contentReturn.undos);
      }
    });
    const result = redoMutationsInfo.every((m) => this._commandService.executeCommand(m.id, m.params));
    if (result) {
      this._undoRedoService.pushUndoRedo({
        unitID: this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getUnitId(),
        undoMutations: undoMutationsInfo,
        redoMutations: redoMutationsInfo
      });
    }
    return result;
  }
  async _pasteFiles(files, pasteType) {
    return this._executePaste((h, payload) => {
      var _a;
      return (_a = h.onPasteFiles) == null ? void 0 : _a.call(h, payload, files, { pasteType });
    });
  }
  async _pastePlainText(text, pasteType) {
    return this._executePaste((h, payload) => {
      var _a;
      return (_a = h.onPastePlainText) == null ? void 0 : _a.call(h, payload, text, { pasteType });
    });
  }
  _pasteUnrecognized() {
    return this._executePaste((h, payload) => {
      var _a;
      return (_a = h.onPasteUnrecognized) == null ? void 0 : _a.call(h, payload);
    });
  }
  async _pasteHTML(html, pasteType) {
    const copyId = extractId(html);
    if (copyId && this._copyContentCache.get(copyId)) {
      return this._pasteInternal(copyId, pasteType);
    }
    return this._pasteExternal(html, pasteType);
  }
  async _pasteExternal(html, pasteType) {
    var _a;
    const { rowProperties, colProperties, cellMatrix } = this._htmlToUSM.convert(html);
    if (!cellMatrix) {
      return false;
    }
    const pasteTarget = this._getPastedRange(cellMatrix);
    if (!pasteTarget) {
      return false;
    }
    const worksheet = (_a = this._univerInstanceService.getUniverSheetInstance(pasteTarget.unitId)) == null ? void 0 : _a.getSheetBySheetId(pasteTarget.subUnitId);
    if (!worksheet) {
      return false;
    }
    const mergeData = worksheet == null ? void 0 : worksheet.getMergeData();
    if (mergeData.length) {
      const pastedRangeLapWithMergedCell = mergeData.some((m) => {
        return rangeIntersectWithDiscreteRange(m, pasteTarget.pastedRange) && !discreteRangeContainsRange(pasteTarget.pastedRange, m);
      });
      if (pastedRangeLapWithMergedCell) {
        this._errorService.emit(this._localeService.t("clipboard.paste.overlappingMergedCells"));
        return false;
      }
    }
    const res = this._pasteUSM(
      {
        rowProperties,
        colProperties,
        cellMatrix
      },
      pasteTarget,
      pasteType
    );
    return res;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  async _pasteInternal(copyId, pasteType) {
    var _a, _b;
    const cachedData = Tools.deepClone(this._copyContentCache.get(copyId));
    const { range, matrix: cellMatrix, unitId: copyUnitId, subUnitId: copySubUnitId } = cachedData || {};
    if (!cellMatrix || !cachedData || !range || !copyUnitId || !copySubUnitId) {
      return false;
    }
    if (!cellMatrix || !cachedData) {
      return false;
    }
    const styles = (_a = this._univerInstanceService.getUniverSheetInstance(copyUnitId)) == null ? void 0 : _a.getStyles();
    cellMatrix.forValue((row, col, value) => {
      if (typeof value.s === "string") {
        const newValue = Tools.deepClone(value);
        newValue.s = styles == null ? void 0 : styles.getStyleByCell(value);
        cellMatrix.setValue(row, col, newValue);
      }
      if (value.colSpan || value.rowSpan) {
        for (let rStart = 0; rStart < value.rowSpan; rStart++) {
          for (let cStart = 0; cStart < value.colSpan; cStart++) {
            if (rStart === 0 && cStart === 0) continue;
            const r = row + rStart;
            const c = col + cStart;
            cellMatrix.setValue(r, c, { s: styles == null ? void 0 : styles.getStyleByCell(value) });
          }
        }
      }
    });
    const pasteTarget = this._getPastedRange(cellMatrix);
    if (!pasteTarget) return false;
    const pasteToWorksheet = (_b = this._univerInstanceService.getUniverSheetInstance(pasteTarget.unitId)) == null ? void 0 : _b.getSheetBySheetId(pasteTarget.subUnitId);
    if (!pasteToWorksheet) {
      return false;
    }
    const mergeData = pasteToWorksheet == null ? void 0 : pasteToWorksheet.getMergeData();
    if (mergeData) {
      const pastedRangeLapWithMergedCell = mergeData.some((m) => {
        return rangeIntersectWithDiscreteRange(m, pasteTarget.pastedRange) && !discreteRangeContainsRange(pasteTarget.pastedRange, m);
      });
      if (pastedRangeLapWithMergedCell) {
        this._errorService.emit(this._localeService.t("clipboard.paste.overlappingMergedCells"));
        return false;
      }
    }
    const pasteFromWorkbook = this._univerInstanceService.getUnit(copyUnitId);
    if (!pasteFromWorkbook) return false;
    const pasteFromWorksheet = pasteFromWorkbook.getSheetBySheetId(copySubUnitId);
    if (!pasteFromWorksheet) return false;
    const colManager = pasteFromWorksheet.getColumnManager();
    const rowManager = pasteFromWorksheet.getRowManager();
    const defaultColumnWidth = pasteFromWorksheet.getConfig().defaultColumnWidth;
    const defaultRowHeight = pasteFromWorksheet.getConfig().defaultRowHeight;
    const colProperties = [];
    const rowProperties = [];
    range.cols.forEach((i) => {
      const column = colManager.getColumnOrCreate(i);
      colProperties.push({ width: `${column.w || defaultColumnWidth}` });
    });
    range.rows.forEach((j) => {
      const row = rowManager.getRowOrCreate(j);
      const { ah = defaultRowHeight, h = defaultRowHeight } = row;
      const height = Math.max(ah, h);
      rowProperties.push({ height: `${height}` });
    });
    if (cachedData.copyType === "CUT" /* CUT */) {
      const start = pasteTarget.pastedRange.rows[0];
      const end = range.rows[range.rows.length - 1] - range.rows[0] + start;
      pasteTarget.pastedRange.rows = Array.from(new Array(end + 1).keys()).slice(start);
    }
    const pasteRes = this._pasteUSM(
      {
        cellMatrix,
        colProperties,
        rowProperties
      },
      // paste data
      pasteTarget,
      pasteType,
      {
        range,
        // paste source
        unitId: cachedData.unitId,
        subUnitId: cachedData.subUnitId,
        copyType: cachedData.copyType,
        copyId
      }
    );
    if (cachedData.copyType === "CUT" /* CUT */) {
      this._copyContentCache.set(copyId, { ...cachedData, matrix: null });
      this._copyMarkId && this._markSelectionService.removeShape(this._copyMarkId);
      this._copyMarkId = null;
    }
    return pasteRes;
  }
  // eslint-disable-next-line max-lines-per-function
  _pasteUSM(data, target, pasteType, source) {
    const { rowProperties, colProperties, cellMatrix } = data;
    const { unitId, subUnitId, pastedRange } = target;
    const colCount = pastedRange.cols.length;
    const hooks = this._clipboardHooks;
    const enabledHooks = [];
    const disableCopying = hooks.some(
      (h) => {
        var _a;
        return enabledHooks.push(h) && ((_a = h.onBeforePaste) == null ? void 0 : _a.call(h, { unitId, subUnitId, range: pastedRange })) === false;
      }
    );
    if (disableCopying) {
      enabledHooks.forEach((h) => {
        var _a;
        return (_a = h.onAfterPaste) == null ? void 0 : _a.call(h, false);
      });
      return false;
    }
    if (!cellMatrix) return false;
    const pasteFrom = source ? {
      unitId: source.unitId,
      subUnitId: source.subUnitId,
      range: source.range
    } : null;
    const payload = {
      copyType: (source == null ? void 0 : source.copyType) || "COPY" /* COPY */,
      copyId: source == null ? void 0 : source.copyId,
      pasteType
    };
    let redoMutationsInfo = [];
    let undoMutationsInfo = [];
    const filteredHooks = enabledHooks.filter(
      (h) => !h.specialPasteInfo && h.id !== PREDEFINED_HOOK_NAME.DEFAULT_PASTE || pasteType === h.id
    );
    filteredHooks.forEach((h) => {
      var _a, _b, _c;
      if (rowProperties) {
        const rowReturn = (_a = h.onPasteRows) == null ? void 0 : _a.call(h, { range: pastedRange, unitId, subUnitId }, rowProperties, {
          pasteType
        });
        if (rowReturn) {
          redoMutationsInfo.push(...rowReturn.redos);
          undoMutationsInfo.push(...rowReturn.undos);
        }
      }
      const colReturn = (_b = h.onPasteColumns) == null ? void 0 : _b.call(
        h,
        { range: pastedRange, unitId, subUnitId },
        colProperties || new Array(colCount).map(() => ({})),
        { pasteType }
      );
      if (colReturn) {
        redoMutationsInfo.push(...colReturn.redos);
        undoMutationsInfo.push(...colReturn.undos);
      }
      const contentReturn = (_c = h.onPasteCells) == null ? void 0 : _c.call(
        h,
        pasteFrom,
        { range: pastedRange, unitId, subUnitId },
        cellMatrix,
        payload
      );
      if (contentReturn) {
        redoMutationsInfo.push(...contentReturn.redos);
        undoMutationsInfo.push(...contentReturn.undos);
      }
    });
    const setSelectionOperation = this._getSetSelectionOperation(unitId, subUnitId, pastedRange, cellMatrix, pasteType);
    if (setSelectionOperation) {
      redoMutationsInfo.push(setSelectionOperation);
    }
    redoMutationsInfo = mergeSetRangeValues(redoMutationsInfo);
    undoMutationsInfo = mergeSetRangeValues(undoMutationsInfo);
    undoMutationsInfo.push({ id: SetWorksheetActiveOperation.id, params: { unitId: target.unitId, subUnitId: target.subUnitId } });
    this._logService.log("[SheetClipboardService]", "pasting mutations", {
      undoMutationsInfo,
      redoMutationsInfo
    });
    const result = redoMutationsInfo.every((m) => this._commandService.syncExecuteCommand(m.id, m.params));
    if (result) {
      this._undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undoMutationsInfo,
        redoMutations: redoMutationsInfo
      });
      this.updatePasteOptionsCache({
        target: {
          pastedRange,
          unitId,
          subUnitId
        },
        cellMatrix,
        rowProperties,
        colProperties,
        pasteType,
        source
      });
      this.setShowMenu(true);
    }
    filteredHooks.forEach((h) => {
      var _a;
      return (_a = h.onAfterPaste) == null ? void 0 : _a.call(h, result);
    });
    return result;
  }
  _getSetSelectionOperation(unitId, subUnitId, range, cellMatrix, pasteType) {
    var _a;
    const worksheet = (_a = this._univerInstanceService.getUniverSheetInstance(unitId)) == null ? void 0 : _a.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return null;
    }
    const { rows, cols } = range;
    const startRow = rows[0];
    const startColumn = cols[0];
    const endRow = rows[rows.length - 1];
    const endColumn = cols[cols.length - 1];
    const primaryCell = {
      startRow,
      endRow: startRow,
      startColumn,
      endColumn: startColumn
    };
    const primary = getPrimaryForRange(primaryCell, worksheet);
    const mainCell = cellMatrix.getValue(0, 0);
    const rowSpan = (mainCell == null ? void 0 : mainCell.rowSpan) || 1;
    const colSpan = (mainCell == null ? void 0 : mainCell.colSpan) || 1;
    const shouldExpandPrimary = pasteType === PREDEFINED_HOOK_NAME.DEFAULT_PASTE || pasteType === PREDEFINED_HOOK_NAME.SPECIAL_PASTE_BESIDES_BORDER || pasteType === PREDEFINED_HOOK_NAME.SPECIAL_PASTE_FORMAT;
    if (shouldExpandPrimary && (rowSpan > 1 || colSpan > 1)) {
      const mergeRange = {
        startRow,
        endRow: startRow + rowSpan - 1,
        startColumn,
        endColumn: startColumn + colSpan - 1
      };
      primary.startRow = mergeRange.startRow;
      primary.endRow = mergeRange.endRow;
      primary.startColumn = mergeRange.startColumn;
      primary.endColumn = mergeRange.endColumn;
      primary.isMerged = true;
      primary.isMergedMainCell = true;
    }
    const setSelectionsParam = {
      unitId,
      subUnitId,
      selections: [{
        range: {
          startRow,
          endRow,
          startColumn,
          endColumn
        },
        primary,
        style: null
      }]
    };
    return {
      id: SetSelectionsOperation.id,
      params: setSelectionsParam
    };
  }
  _getPastingTarget() {
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    const selection = this._selectionManagerService.getCurrentLastSelection();
    return {
      unitId: workbook.getUnitId(),
      subUnitId: worksheet == null ? void 0 : worksheet.getSheetId(),
      selection
    };
  }
  /**
   * Handles copying one range to another range, obtained by the following rules
   *
   * [Content to be assigned] => [Target range]
   *
   * I. There are no merged cells in the upper left corner of the pasted area
   *
   * 1. 1 -> 1: 1 => 1
   * 2. N -> 1: N => N
   * 3. 1 -> N: N => N
   * 4. N1 -> N2:
   *     1) N1 <N2: If N2 is a multiple of N1 (X), N1 * X => N2; If not, N1 => N1 (refer to office excel, different from google sheet)
   *     2) N1> N2: N1 => N1
   *
   * The above four cases can be combined and processed as
   *
   * Case 1, 1/2/4-2 merged into N1 => N1
   * Case 2, 3/4-1 merge into N1 * X => N2 or Case 1
   *
   * In the end we only need to judge whether N2 is a multiple of N1
   *
   * II. The pasted area contains merged cells
   *
   * 1. If N2 is a multiple of N1,
   *   1) If N2 === N1, paste this area directly and the range remains unchanged.
   *   2) Otherwise, determine whether other cells are included
   *     1] If included, tile, the range remains unchanged
   *     2] If not included, determine whether the source data is a combined cell
   *       1} If yes, tile, the range remains unchanged
   *       2} If not, only the content will be pasted, the original style will be discarded, and the scope will remain unchanged.
   *
   * 2. If N2 is not a multiple of N1, determine whether the upper left corner cell (merged or non-merged or combined) is consistent with the size of the original data.
   *   1) If consistent, only paste this area;
   *   2) If inconsistent, then determine whether the pasted area contains other cells.
   *     1] If yes, pasting is not allowed and an error will pop up;
   *     2] If not, only the content will be pasted and the original style will be discarded.
   *
   * @param rowCount
   * @param colCount
   * @param cellMatrix
   * @param range
   */
  // eslint-disable-next-line max-lines-per-function, complexity
  _transformPastedData(rowCount, colCount, cellMatrix) {
    const target = this._getPastingTarget();
    const { selection, unitId, subUnitId } = target;
    if (!subUnitId || !selection) {
      return null;
    }
    const discreteRange = this._injector.invoke((accessor) => {
      return rangeToDiscreteRange(selection.range, accessor, unitId, subUnitId);
    });
    if (!discreteRange) {
      return null;
    }
    const { ranges: [vRange], mapFunc } = virtualizeDiscreteRanges([discreteRange]);
    const { startRow, startColumn, endRow, endColumn } = vRange;
    const destinationRows = endRow - startRow + 1;
    const destinationColumns = endColumn - startColumn + 1;
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
    if (!worksheet) {
      return null;
    }
    const mergeData = worksheet.getMergeData();
    const mergedCellsInRange = mergeData.filter(
      (rect) => discreteRange.rows.includes(rect.startRow) && discreteRange.cols.includes(rect.startColumn)
    );
    const mergedRange = mergedCellsInRange[0];
    let mergedRangeStartRow = 0;
    let mergedRangeStartColumn = 0;
    let mergedRangeEndRow = 0;
    let mergedRangeEndColumn = 0;
    if (mergedRange) {
      mergedRangeStartRow = mergedRange.startRow;
      mergedRangeStartColumn = mergedRange.startColumn;
      mergedRangeEndRow = mergedRange.endRow;
      mergedRangeEndColumn = mergedRange.endColumn;
    }
    if (destinationRows % rowCount === 0 && destinationColumns % colCount === 0) {
      if (mergedCellsInRange.length > 0 && (destinationRows !== rowCount || destinationColumns !== colCount)) {
        if (mergedRangeStartRow === discreteRange.rows[0] && mergedRangeStartColumn === discreteRange.cols[0] && mergedRangeEndRow === discreteRange.rows[destinationRows - 1] && mergedRangeEndColumn === discreteRange.cols[destinationColumns - 1]) {
          const isMultiple = isMultipleCells(cellMatrix);
          if (isMultiple) {
            for (let r = 0; r < destinationRows; r++) {
              for (let c = 0; c < destinationColumns; c++) {
                const cell = cellMatrix.getValue(r % rowCount, c % colCount);
                cell && cellMatrix.setValue(r, c, cell);
              }
            }
          } else {
            cellMatrix.forValue((row, col, cell) => {
              cell.s = null;
              delete cell.colSpan;
              delete cell.rowSpan;
            });
          }
        } else {
          for (let r = 0; r < destinationRows; r++) {
            for (let c = 0; c < destinationColumns; c++) {
              const cell = cellMatrix.getValue(r % rowCount, c % colCount);
              cell && cellMatrix.setValue(r, c, cell);
            }
          }
        }
      } else {
        for (let r = 0; r < destinationRows; r++) {
          for (let c = 0; c < destinationColumns; c++) {
            const cell = cellMatrix.getValue(r % rowCount, c % colCount);
            cell && cellMatrix.setValue(r, c, cell);
          }
        }
      }
    } else if (mergedCellsInRange.length > 0) {
      const { row: topRow, col: leftCol } = mapFunc(startRow, startColumn);
      const isMatch = this._topLeftCellsMatch(rowCount, colCount, {
        topRow,
        leftCol
      });
      if (isMatch) {
        const newDiscreteRange = this._expandOrShrinkRowsCols(unitId, subUnitId, discreteRange, colCount, rowCount);
        discreteRange.rows = newDiscreteRange.rows;
        discreteRange.cols = newDiscreteRange.cols;
      } else if (endRow > mergedRange.endRow || endColumn > mergedRange.endColumn) {
        return null;
      } else {
        cellMatrix.forValue((row, col, cell) => {
          cell.s = null;
          delete cell.colSpan;
          delete cell.rowSpan;
        });
      }
    } else {
      const newDiscreteRange = this._expandOrShrinkRowsCols(unitId, subUnitId, discreteRange, colCount, rowCount);
      discreteRange.rows = newDiscreteRange.rows;
      discreteRange.cols = newDiscreteRange.cols;
    }
    return {
      pastedRange: discreteRange,
      unitId,
      subUnitId
    };
  }
  _getPastedRange(cellMatrix) {
    var _a;
    const target = this._getPastingTarget();
    const { selection, unitId, subUnitId } = target;
    if (!subUnitId || !selection) {
      return null;
    }
    const discreteRange = this._injector.invoke((accessor) => {
      return rangeToDiscreteRange(selection.range, accessor, unitId, subUnitId);
    });
    if (!discreteRange) {
      return null;
    }
    const { startColumn, endColumn, startRow, endRow } = cellMatrix.getDataRange();
    const rowCount = endRow - startRow + 1;
    const colCount = endColumn - startColumn + 1;
    if (rowCount <= 0 || colCount <= 0) return null;
    const pasteSelectionRangeRowLen = discreteRange.rows.length;
    const pasteSelectionRangeColLen = discreteRange.cols.length;
    const worksheet = (_a = this._univerInstanceService.getUniverSheetInstance(unitId)) == null ? void 0 : _a.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return null;
    }
    const mergeData = worksheet == null ? void 0 : worksheet.getMergeData();
    if (pasteSelectionRangeRowLen % rowCount === 0 && pasteSelectionRangeColLen % colCount === 0) {
      const hasLapWithMerge = mergeData == null ? void 0 : mergeData.some((merge2) => rangeIntersectWithDiscreteRange(merge2, discreteRange));
      if (!hasLapWithMerge) {
        for (let r = 0; r < pasteSelectionRangeRowLen; r++) {
          for (let c = 0; c < pasteSelectionRangeColLen; c++) {
            const cell = cellMatrix.getValue(r % rowCount, c % colCount);
            cell && cellMatrix.setValue(r, c, cell);
          }
        }
        return {
          pastedRange: discreteRange,
          unitId,
          subUnitId
        };
      }
    }
    const newDiscreteRange = this._expandOrShrinkRowsCols(unitId, subUnitId, discreteRange, colCount, rowCount);
    discreteRange.rows = newDiscreteRange.rows;
    discreteRange.cols = newDiscreteRange.cols;
    return {
      pastedRange: discreteRange,
      unitId,
      subUnitId
    };
  }
  _expandOrShrinkRowsCols(unitId, subUnitId, range, colCount, rowCount) {
    const { rows, cols } = range;
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    let newRows;
    let newCols;
    if (rows.length >= rowCount) {
      newRows = rows.slice(0, rowCount);
    } else {
      newRows = rows.slice(0);
      let rowIndex = rows[rows.length - 1] + 1;
      while (newRows.length < rowCount) {
        if (!worksheet.getRowFiltered(rowIndex)) {
          newRows.push(rowIndex);
        }
        rowIndex++;
      }
    }
    if (cols.length >= colCount) {
      newCols = cols.slice(0, colCount);
    } else {
      newCols = cols.slice(0);
      let colIndex = cols[cols.length - 1] + 1;
      while (newCols.length < colCount) {
        newCols.push(colIndex);
        colIndex++;
      }
    }
    return {
      rows: newRows,
      cols: newCols
    };
  }
  /**
   * Determine whether the cells starting from the upper left corner of the range (merged or non-merged or combined) are consistent with the size of the original data
   * @param cellMatrix
   * @param range
   */
  _topLeftCellsMatch(rowCount, colCount, range) {
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
    if (!worksheet) {
      return false;
    }
    const { topRow, leftCol } = range;
    const isRowAcross = rowAcrossMergedCell(
      topRow + rowCount - 1,
      leftCol,
      leftCol + colCount - 1,
      worksheet
    );
    const isColAcross = columnAcrossMergedCell(
      leftCol + colCount - 1,
      topRow,
      topRow + rowCount - 1,
      worksheet
    );
    return !isRowAcross && !isColAcross;
  }
  removeMarkSelection() {
    if (this._copyMarkId) {
      this._markSelectionService.removeShape(this._copyMarkId);
      this._copyMarkId = null;
    }
  }
  _initUnitDisposed() {
    this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET).subscribe((workbook) => {
        if (workbook) {
          const copyCache = this.copyContentCache();
          copyCache.clearWithUnitId(workbook.getUnitId());
        }
      })
    );
  }
  disposePasteOptionsCache() {
    this.setShowMenu(false);
    this.updatePasteOptionsCache(null);
  }
};
SheetClipboardService = __decorateClass([
  __decorateParam(0, ILogService),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, Inject(SheetsSelectionsService)),
  __decorateParam(3, IClipboardInterfaceService),
  __decorateParam(4, IUndoRedoService),
  __decorateParam(5, ICommandService),
  __decorateParam(6, IMarkSelectionService),
  __decorateParam(7, INotificationService),
  __decorateParam(8, IPlatformService),
  __decorateParam(9, IRenderManagerService),
  __decorateParam(10, Inject(ThemeService)),
  __decorateParam(11, Inject(LocaleService)),
  __decorateParam(12, Inject(ErrorService)),
  __decorateParam(13, Inject(Injector))
], SheetClipboardService);
function getMatrixPlainText(matrix) {
  let plain = "";
  const matrixLength = matrix.getLength();
  matrix.forRow((row, cols) => {
    const arr = [];
    cols.forEach((col) => {
      const cell = matrix.getValue(row, col);
      if (cell) {
        const cellText = getCellTextForClipboard(cell);
        arr.push(cellText);
      }
    });
    plain += arr.join("	");
    if (row !== matrixLength - 1) {
      plain += "\n";
    }
  });
  return plain;
}
function getCellTextForClipboard(cell) {
  if (isNotNullOrUndefined(cell.displayV)) {
    return cell.displayV;
  }
  return extractPureTextFromCell(cell);
}
function rowAcrossMergedCell(row, startColumn, endColumn, worksheet) {
  return worksheet.getMergeData().some(
    (mergedCell) => mergedCell.startRow <= row && row < mergedCell.endRow && startColumn <= mergedCell.startColumn && mergedCell.startColumn <= endColumn
  );
}
function columnAcrossMergedCell(col, startRow, endRow, worksheet) {
  return worksheet.getMergeData().some(
    (mergedCell) => mergedCell.startColumn <= col && col < mergedCell.endColumn && startRow <= mergedCell.startRow && mergedCell.startRow <= endRow
  );
}
function isMultipleCells(cellMatrix) {
  let count = 0;
  cellMatrix.forValue((row, col, cell) => {
    if (cell) {
      count++;
    }
    if (count > 1) {
      return false;
    }
  });
  return count > 1;
}
function getEmptyCell() {
  return {
    p: null,
    v: null,
    s: null,
    f: null,
    si: null,
    t: null
  };
}

// ../packages/sheets-ui/src/commands/commands/clipboard.command.ts
var SHEET_CLIPBOARD_PRIORITY = 998;
var SheetCopyCommand = {
  id: CopyCommand.id,
  name: "sheet.command.copy",
  type: 0 /* COMMAND */,
  multi: true,
  priority: SHEET_CLIPBOARD_PRIORITY,
  preconditions: whenSheetFocused,
  handler: async (accessor) => {
    const sheetClipboardService = accessor.get(ISheetClipboardService);
    return sheetClipboardService.copy();
  }
};
var SheetCutCommand = {
  id: CutCommand.id,
  name: "sheet.command.cut",
  type: 0 /* COMMAND */,
  multi: true,
  priority: SHEET_CLIPBOARD_PRIORITY,
  preconditions: whenSheetFocused,
  handler: async (accessor) => {
    const sheetClipboardService = accessor.get(ISheetClipboardService);
    return sheetClipboardService.cut();
  }
};
var SheetPasteCommand = {
  id: PasteCommand.id,
  type: 0 /* COMMAND */,
  multi: true,
  name: "sheet.command.paste",
  priority: SHEET_CLIPBOARD_PRIORITY,
  preconditions: whenSheetFocused,
  handler: async (accessor, params) => {
    const clipboardInterfaceService = accessor.get(IClipboardInterfaceService);
    const clipboardItems = await clipboardInterfaceService.read();
    const sheetClipboardService = accessor.get(ISheetClipboardService);
    if (clipboardItems.length !== 0) {
      return sheetClipboardService.paste(clipboardItems[0], params == null ? void 0 : params.value);
    }
    return false;
  }
};
var SheetPasteShortKeyCommand = {
  id: SheetPasteShortKeyCommandName,
  type: 0 /* COMMAND */,
  handler: async (accessor, params) => {
    const clipboardService = accessor.get(ISheetClipboardService);
    const { htmlContent, textContent, files } = params;
    clipboardService.legacyPaste(htmlContent, textContent, files);
    return true;
  }
};
var SheetPasteValueCommand = {
  id: "sheet.command.paste-value",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SheetPasteCommand.id, { value: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_VALUE });
  }
};
var SheetPasteFormatCommand = {
  id: "sheet.command.paste-format",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SheetPasteCommand.id, {
      value: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_FORMAT
    });
  }
};
var SheetPasteColWidthCommand = {
  id: "sheet.command.paste-col-width",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SheetPasteCommand.id, {
      value: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_COL_WIDTH
    });
  }
};
var SheetPasteBesidesBorderCommand = {
  id: "sheet.command.paste-besides-border",
  type: 0 /* COMMAND */,
  handler: async (accessor) => {
    const commandService = accessor.get(ICommandService);
    return commandService.executeCommand(SheetPasteCommand.id, {
      value: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_BESIDES_BORDER
    });
  }
};
var SheetOptionalPasteCommand = {
  id: "sheet.command.optional-paste",
  type: 0 /* COMMAND */,
  handler: async (accessor, { type }) => {
    const clipboardService = accessor.get(ISheetClipboardService);
    return clipboardService.rePasteWithPasteType(type);
  }
};

// ../packages/sheets-ui/src/controllers/menu/menu-util.ts
function getActiveSheet$(univerInstanceService) {
  return univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).pipe(switchMap((workbook) => workbook ? workbook.activeSheet$.pipe(map((worksheet) => {
    if (!worksheet) return null;
    return { workbook, worksheet };
  })) : of(null)));
}
function deriveStateFromActiveSheet$(univerInstanceService, defaultValue, callback) {
  return getActiveSheet$(univerInstanceService).pipe(switchMap((active) => {
    if (!active) return of(defaultValue);
    return callback(active);
  }));
}
function getCurrentExclusiveRangeInterest$(accessor, disableGroupSet) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const exclusiveRangeService = accessor.get(IExclusiveRangeService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  return workbook$.pipe(
    switchMap((workbook) => {
      if (!workbook) {
        return of(false);
      }
      return combineLatest([selectionManagerService.selectionMoveEnd$, workbook.activeSheet$]).pipe(
        switchMap(([selections, worksheet]) => {
          if (!worksheet) {
            return of(false);
          }
          if (selections.length === 0) {
            return of(false);
          }
          const interestGroupIds = exclusiveRangeService.getInterestGroupId(selections);
          if (disableGroupSet) {
            const disableGroup = interestGroupIds.filter((groupId) => disableGroupSet.has(groupId));
            return of(disableGroup.length > 0);
          } else {
            return of(interestGroupIds.length > 0);
          }
        })
      );
    })
  );
}
function getObservableWithExclusiveRange$(accessor, observable$, disableGroupSet) {
  return combineLatest([observable$, getCurrentExclusiveRangeInterest$(accessor, disableGroupSet)]).pipe(
    map(([observable, exclusiveRangeDisable]) => observable || exclusiveRangeDisable)
  );
}
function getCurrentRangeDisable$(accessor, permissionTypes = {}, supportCellEdit = false) {
  var _a;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  const editorBridgeService = accessor.has(IEditorBridgeService) ? accessor.get(IEditorBridgeService) : null;
  const contextService = accessor.get(IContextService);
  const formulaEditorFocus$ = new BehaviorSubject(false);
  const editorVisible$ = (_a = editorBridgeService == null ? void 0 : editorBridgeService.visible$) != null ? _a : of(null);
  const subscription = contextService.subscribeContextValue$(FOCUSING_FX_BAR_EDITOR).subscribe((visible) => {
    formulaEditorFocus$.next(visible);
  });
  const observable = combineLatest([userManagerService.currentUser$, workbook$, editorVisible$, formulaEditorFocus$]).pipe(
    finalize(() => {
      subscription.unsubscribe();
      formulaEditorFocus$.complete();
    }),
    switchMap(([_, workbook, visible, formulaEditorFocus]) => {
      if (!workbook || (visible == null ? void 0 : visible.visible) && visible.unitId === workbook.getUnitId() && !supportCellEdit || formulaEditorFocus && !supportCellEdit) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          if (!worksheet) {
            return of(true);
          }
          const selectionManagerService = accessor.get(SheetsSelectionsService);
          const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const contextService2 = accessor.get(IContextService);
          const focusedOnDrawing$ = contextService2.subscribeContextValue$(FOCUSING_COMMON_DRAWINGS).pipe(startWith(false));
          return combineLatest([selectionManagerService.selectionMoveEnd$, focusedOnDrawing$]).pipe(
            switchMap(([selection, focusOnDrawings]) => {
              if (focusOnDrawings) {
                return of(true);
              }
              const unitId = workbook.getUnitId();
              const subUnitId = worksheet.getSheetId();
              const permissionService = accessor.get(IPermissionService);
              const { workbookTypes = [WorkbookEditablePermission], worksheetTypes, rangeTypes } = permissionTypes;
              const permissionIds = [];
              workbookTypes == null ? void 0 : workbookTypes.forEach((F) => {
                permissionIds.push(new F(unitId).id);
              });
              worksheetTypes == null ? void 0 : worksheetTypes.forEach((F) => {
                permissionIds.push(new F(unitId, subUnitId).id);
              });
              const worksheetRule = worksheetRuleModel.getRule(unitId, subUnitId);
              if (worksheetRule) {
                return permissionService.composePermission$(permissionIds).pipe(map((list) => {
                  return list.some((item) => item.value === false);
                }));
              }
              const selectionRanges = selection == null ? void 0 : selection.map((selection2) => selection2.range);
              const rules = rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
                return selectionRanges == null ? void 0 : selectionRanges.some((range) => {
                  return rule.ranges.some((ruleRange) => Rectangle.intersects(range, ruleRange));
                });
              });
              rangeTypes == null ? void 0 : rangeTypes.forEach((F) => {
                rules.forEach((rule) => {
                  permissionIds.push(new F(unitId, subUnitId, rule.permissionId).id);
                });
              });
              return permissionService.composePermission$(permissionIds).pipe(map((list) => {
                return list.some((item) => item.value === false);
              }));
            })
          );
        })
      );
    })
  );
  return observable;
}
function getBaseRangeMenuHidden$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
  const permissionService = accessor.get(IPermissionService);
  return merge(selectionManagerService.selectionMoveEnd$, permissionService.permissionPointUpdate$.pipe(debounceTime(100))).pipe(
    map(() => {
      var _a;
      const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
      if (!range) return true;
      const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
      const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
      if (!workbook || !worksheet) {
        return true;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const permissionIds = [new WorkbookEditablePermission(unitId).id, new WorksheetEditPermission(unitId, subUnitId).id];
      rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
        return rule.ranges.some((ruleRange) => Rectangle.intersects(range, ruleRange));
      }).forEach((rule) => {
        permissionIds.push(new RangeProtectionPermissionEditPoint(unitId, subUnitId, rule.permissionId).id);
      });
      return permissionService.composePermission(permissionIds).some((item) => item.value === false);
    })
  );
}
function getInsertBeforeMenuHidden$(accessor, type) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
  const permissionService = accessor.get(IPermissionService);
  return merge(selectionManagerService.selectionMoveEnd$, permissionService.permissionPointUpdate$.pipe(debounceTime(100))).pipe(
    map(() => {
      var _a;
      const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
      if (!range) return true;
      const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
      const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
      if (!workbook || !worksheet) {
        return true;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const permissionIds = [new WorkbookEditablePermission(unitId).id, new WorksheetEditPermission(unitId, subUnitId).id];
      rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
        if (type === "row") {
          return rule.ranges.some((ruleRange) => {
            return range.startRow > ruleRange.startRow && range.startRow <= ruleRange.endRow;
          });
        } else {
          return rule.ranges.some((ruleRange) => {
            return range.startColumn > ruleRange.startColumn && range.startColumn <= ruleRange.endColumn;
          });
        }
      }).forEach((rule) => {
        permissionIds.push(new RangeProtectionPermissionEditPoint(unitId, subUnitId, rule.permissionId).id);
      });
      return permissionService.composePermission(permissionIds).some((item) => item.value === false);
    })
  );
}
function getDeleteMenuHidden$(accessor, type) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
  const permissionService = accessor.get(IPermissionService);
  return merge(selectionManagerService.selectionMoveEnd$, permissionService.permissionPointUpdate$.pipe(debounceTime(100))).pipe(
    map(() => {
      var _a;
      const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
      if (!range) return true;
      const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
      const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
      if (!workbook || !worksheet) {
        return true;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const permissionIds = [new WorkbookEditablePermission(unitId).id, new WorksheetEditPermission(unitId, subUnitId).id];
      const rowColRangeExpand = Tools.deepClone(range);
      if (type === "row") {
        rowColRangeExpand.startColumn = 0;
        rowColRangeExpand.endColumn = worksheet.getColumnCount() - 1;
      } else {
        rowColRangeExpand.startRow = 0;
        rowColRangeExpand.endRow = worksheet.getRowCount() - 1;
      }
      rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
        return rule.ranges.some((ruleRange) => Rectangle.intersects(rowColRangeExpand, ruleRange));
      }).forEach((rule) => {
        permissionIds.push(new RangeProtectionPermissionEditPoint(unitId, subUnitId, rule.permissionId).id);
      });
      return permissionService.composePermission(permissionIds).some((item) => item.value === false);
    })
  );
}
function getCellMenuHidden$(accessor, type) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
  const permissionService = accessor.get(IPermissionService);
  return merge(selectionManagerService.selectionMoveEnd$, permissionService.permissionPointUpdate$.pipe(debounceTime(100))).pipe(
    map(() => {
      var _a;
      const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
      if (!range) return true;
      const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
      const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
      if (!workbook || !worksheet) {
        return true;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const permissionIds = [new WorkbookEditablePermission(unitId).id, new WorksheetEditPermission(unitId, subUnitId).id];
      const rowColRangeExpand = Tools.deepClone(range);
      if (type === "row") {
        rowColRangeExpand.endRow = worksheet.getRowCount() - 1;
      } else {
        rowColRangeExpand.endColumn = worksheet.getColumnCount() - 1;
      }
      rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
        return rule.ranges.some((ruleRange) => Rectangle.intersects(rowColRangeExpand, ruleRange));
      }).forEach((rule) => {
        permissionIds.push(new RangeProtectionPermissionEditPoint(unitId, subUnitId, rule.permissionId).id);
      });
      return permissionService.composePermission(permissionIds).some((item) => item.value === false);
    })
  );
}
function getWorkbookPermissionDisable$(accessor, workbookPermissionTypes) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const worksheetRuleModel = accessor.get(WorksheetProtectionRuleModel);
  const selectionRuleModel = accessor.get(RangeProtectionRuleModel);
  const permissionService = accessor.get(IPermissionService);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([userManagerService.currentUser$, workbook$]).pipe(
    switchMap(([_user, workbook]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((activeSheet) => {
          if (!activeSheet) {
            return of(true);
          }
          const unitId = workbook.getUnitId();
          const workbookPermissionIds = [];
          workbookPermissionTypes.forEach((F) => workbookPermissionIds.push(new F(unitId).id));
          const workbookPermission$ = permissionService.composePermission$(workbookPermissionIds).pipe(map((list) => list.every((item) => item.value === true)));
          return workbookPermission$.pipe(
            map((basePermission) => {
              if (!basePermission) {
                return true;
              }
              const subUnitId = activeSheet.getSheetId();
              const worksheetRule = worksheetRuleModel.getRule(unitId, subUnitId);
              const rangeRuleList = selectionRuleModel.getSubunitRuleList(unitId, subUnitId);
              if (worksheetRule || rangeRuleList.length) {
                return true;
              }
              return false;
            })
          );
        })
      );
    })
  );
}

// ../packages/sheets-ui/src/controllers/menu/border.menu.ts
function CellBorderSelectorMenuItemFactory(accessor) {
  const borderStyleManagerService = accessor.get(BorderStyleManagerService);
  const disabled$ = getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] });
  return {
    id: SetBorderBasicCommand.id,
    icon: new Observable((subscriber) => {
      const defaultIcon = "AllBorderSingle";
      const borderManager = accessor.get(BorderStyleManagerService);
      const disposable = accessor.get(ICommandService).onCommandExecuted((c) => {
        var _a;
        const id = c.id;
        if (id !== SetBorderBasicCommand.id) {
          return;
        }
        const { type } = borderManager.getBorderInfo();
        const item = BORDER_LINE_CHILDREN.find((item2) => item2.value === type);
        const icon = (_a = item == null ? void 0 : item.icon) != null ? _a : defaultIcon;
        subscriber.next(icon);
      });
      subscriber.next(defaultIcon);
      return disposable.dispose;
    }),
    tooltip: "toolbar.border.main",
    type: 2 /* BUTTON_SELECTOR */,
    slot: true,
    selections: [
      {
        label: {
          name: BORDER_PANEL_COMPONENT,
          hoverable: false,
          selectable: false
        },
        value$: borderStyleManagerService.borderInfo$
      }
    ],
    value$: borderStyleManagerService.borderInfo$,
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$
  };
}

// ../packages/sheets-ui/src/controllers/menu/clear.menu.ts
var CLEAR_SELECTION_MENU_ID = "sheet.menu.clear-selection";
function ClearSelectionMenuItemFactory(accessor) {
  return {
    id: CLEAR_SELECTION_MENU_ID,
    type: 3 /* SUBITEMS */,
    icon: "ClearFormat",
    title: "rightClick.clearSelection",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ClearSelectionContentMenuItemFactory(accessor) {
  return {
    id: ClearSelectionContentCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.clearContent",
    disabled$: getObservableWithExclusiveRange$(accessor, getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellValuePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ClearSelectionFormatMenuItemFactory(accessor) {
  return {
    id: ClearSelectionFormatCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.clearFormat",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ClearSelectionAllMenuItemFactory(accessor) {
  return {
    id: ClearSelectionAllCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.clearAll",
    disabled$: getObservableWithExclusiveRange$(accessor, getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellValuePermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}

// ../packages/sheets-ui/src/controllers/menu/delete.menu.ts
var DELETE_RANGE_MENU_ID = "sheet.menu.delete";
function DeleteRangeMenuItemFactory(accessor) {
  return {
    id: DELETE_RANGE_MENU_ID,
    type: 3 /* SUBITEMS */,
    title: "rightClick.delete",
    icon: "Reduce",
    hidden$: getObservableWithExclusiveRange$(accessor, getBaseRangeMenuHidden$(accessor)),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission] })
  };
}
function RemoveColMenuItemFactory(accessor) {
  return {
    id: RemoveColConfirmCommand.id,
    type: 0 /* BUTTON */,
    icon: "DeleteColumn",
    title: "rightClick.deleteSelectedColumn",
    hidden$: getObservableWithExclusiveRange$(accessor, getDeleteMenuHidden$(accessor, "col")),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetDeleteColumnPermission] })
  };
}
function RemoveRowMenuItemFactory(accessor) {
  return {
    id: RemoveRowConfirmCommand.id,
    type: 0 /* BUTTON */,
    icon: "DeleteRow",
    title: "rightClick.deleteSelectedRow",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetDeleteRowPermission] }),
    hidden$: getDeleteMenuHidden$(accessor, "row")
  };
}
function DeleteRangeMoveLeftMenuItemFactory(accessor) {
  return {
    id: DeleteRangeMoveLeftConfirmCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.moveLeft",
    icon: "DeleteCellShiftLeft",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getCellMenuHidden$(accessor, "col")
  };
}
function DeleteRangeMoveUpMenuItemFactory(accessor) {
  return {
    id: DeleteRangeMoveUpConfirmCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.moveUp",
    icon: "DeleteCellShiftUp",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getCellMenuHidden$(accessor, "row")
  };
}

// ../packages/sheets-ui/src/controllers/menu/gridlines.menu.ts
function ToggleGridlinesMenuFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const instanceService = accessor.get(IUniverInstanceService);
  return {
    id: ToggleGridlinesCommand.id,
    type: 0 /* BUTTON */,
    tooltip: "toolbar.toggleGridlines",
    icon: "HideGridlines",
    activated$: new Observable((observer) => {
      const getValue = () => {
        const workbook = instanceService.getCurrentUnitForType(O.UNIVER_SHEET);
        if (workbook) return workbook.getActiveSheet().getConfig().showGridlines === 1 /* TRUE */;
        return false;
      };
      const disposable = new DisposableCollection();
      disposable.add(commandService.onCommandExecuted((c) => {
        if (c.id === ToggleGridlinesMutation.id || c.id === SetWorksheetActiveOperation.id) {
          observer.next(getValue());
        }
      }));
      disposable.add(instanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).subscribe(() => {
        observer.next(getValue());
      }));
      observer.next(getValue());
      return () => disposable.dispose();
    }),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission] })
  };
}

// ../packages/sheets-ui/src/controllers/menu/insert.menu.ts
var CELL_INSERT_MENU_ID = "sheet.menu.cell-insert";
function CellInsertMenuItemFactory(accessor) {
  return {
    id: CELL_INSERT_MENU_ID,
    type: 3 /* SUBITEMS */,
    title: "rightClick.insert",
    icon: "Insert",
    hidden$: getObservableWithExclusiveRange$(accessor, getBaseRangeMenuHidden$(accessor)),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetInsertColumnPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
function InsertRowBeforeCellMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const defaultValue = 1;
  return {
    id: InsertRowBeforeCommand.id,
    type: 0 /* BUTTON */,
    icon: "InsertRowAbove",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.insertRowsAbove",
        min: 1,
        max: 1e3,
        suffix: "rightClick.insertRowsAboveSuffix"
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, () => new Observable((subscriber) => {
      function update() {
        var _a;
        const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
        let countSelectedRange = defaultValue;
        if (range) {
          countSelectedRange = (range == null ? void 0 : range.endRow) - (range == null ? void 0 : range.startRow) + 1;
        }
        subscriber.next(countSelectedRange);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetSelectionsOperation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetInsertRowPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getInsertBeforeMenuHidden$(accessor, "row")
  };
}
function InsertColLeftCellMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const defaultValue = 1;
  return {
    id: InsertColBeforeCommand.id,
    type: 0 /* BUTTON */,
    icon: "LeftInsertColumn",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.insertColsLeft",
        min: 1,
        max: 1e3,
        suffix: "rightClick.insertColsLeftSuffix"
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, () => new Observable((subscriber) => {
      function update() {
        var _a;
        const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
        let countSelectedRange = defaultValue;
        if (range) {
          countSelectedRange = (range == null ? void 0 : range.endColumn) - (range == null ? void 0 : range.startColumn) + 1;
        }
        subscriber.next(countSelectedRange);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetSelectionsOperation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetInsertColumnPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getInsertBeforeMenuHidden$(accessor, "col")
  };
}
function InsertRangeMoveRightMenuItemFactory(accessor) {
  return {
    id: InsertRangeMoveRightConfirmCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.moveRight",
    icon: "InsertCellShiftRight",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getCellMenuHidden$(accessor, "col")
  };
}
function InsertRangeMoveDownMenuItemFactory(accessor) {
  return {
    id: InsertRangeMoveDownConfirmCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.moveDown",
    icon: "InsertCellDown",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getCellMenuHidden$(accessor, "row")
  };
}
function InsertMultiRowsAfterHeaderMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const defaultValue = 1;
  return {
    id: InsertMultiRowsAfterCommand.id,
    type: 0 /* BUTTON */,
    icon: "InsertRowBelow",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.insertRowsAfter",
        min: 1,
        max: 1e3,
        suffix: "rightClick.insertRowsAfterSuffix"
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, () => new Observable((subscriber) => {
      function update() {
        var _a;
        const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
        let countSelectedRange = defaultValue;
        if (range) {
          countSelectedRange = (range == null ? void 0 : range.endRow) - (range == null ? void 0 : range.startRow) + 1;
        }
        subscriber.next(countSelectedRange);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetSelectionsOperation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetInsertRowPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getBaseRangeMenuHidden$(accessor)
  };
}
function InsertMultiRowsAboveHeaderMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const defaultValue = 1;
  return {
    id: InsertMultiRowsAboveCommand.id,
    type: 0 /* BUTTON */,
    icon: "InsertRowAbove",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.insertRowsAbove",
        min: 1,
        max: 1e3,
        suffix: "rightClick.insertRowsAboveSuffix"
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, () => new Observable((subscriber) => {
      function update() {
        var _a;
        const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
        let countSelectedRange = defaultValue;
        if (range) {
          countSelectedRange = (range == null ? void 0 : range.endRow) - (range == null ? void 0 : range.startRow) + 1;
        }
        subscriber.next(countSelectedRange);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetSelectionsOperation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetInsertRowPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getBaseRangeMenuHidden$(accessor)
  };
}
function InsertMultiColsLeftHeaderMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const defaultValue = 1;
  return {
    id: InsertMultiColsLeftCommand.id,
    type: 0 /* BUTTON */,
    icon: "LeftInsertColumn",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.insertColsLeft",
        min: 1,
        max: 1e3,
        suffix: "rightClick.insertColsLeftSuffix"
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, () => new Observable((subscriber) => {
      function update() {
        var _a;
        const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
        let countSelectedRange = defaultValue;
        if (range) {
          countSelectedRange = (range == null ? void 0 : range.endColumn) - (range == null ? void 0 : range.startColumn) + 1;
        }
        subscriber.next(countSelectedRange);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetSelectionsOperation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetInsertRowPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getBaseRangeMenuHidden$(accessor)
  };
}
function InsertMultiColsRightHeaderMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const defaultValue = 1;
  return {
    id: InsertMultiRowsAboveCommand.id,
    type: 0 /* BUTTON */,
    icon: "RightInsertColumn",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.insertColsRight",
        min: 1,
        max: 1e3,
        suffix: "rightClick.insertColsRightSuffix"
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, () => new Observable((subscriber) => {
      function update() {
        var _a;
        const range = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
        let countSelectedRange = defaultValue;
        if (range) {
          countSelectedRange = (range == null ? void 0 : range.endColumn) - (range == null ? void 0 : range.startColumn) + 1;
        }
        subscriber.next(countSelectedRange);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetSelectionsOperation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetInsertRowPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getBaseRangeMenuHidden$(accessor)
  };
}

// ../packages/sheets-ui/src/controllers/menu/menu.ts
function FormatPainterMenuItemFactory(accessor) {
  const formatPainterService = accessor.get(IFormatPainterService);
  return {
    id: SetOnceFormatPainterCommand.id,
    subId: SetInfiniteFormatPainterCommand.id,
    type: 0 /* BUTTON */,
    icon: "BrushSingle",
    title: "Format Painter",
    tooltip: "toolbar.formatPainter",
    activated$: new Observable((subscriber) => {
      let active = false;
      const status$ = formatPainterService.status$.subscribe((s) => {
        active = s !== 0 /* OFF */;
        subscriber.next(active);
      });
      subscriber.next(active);
      return () => {
        status$.unsubscribe();
      };
    }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetCopyPermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true)
  };
}
function BoldMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const contextService = accessor.get(IContextService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  return {
    id: SetRangeBoldCommand.id,
    type: 0 /* BUTTON */,
    icon: "BoldSingle",
    title: "Set bold",
    tooltip: "toolbar.bold",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true),
    activated$: deriveStateFromActiveSheet$(univerInstanceService, false, ({ worksheet }) => new Observable((subscriber) => {
      var _a;
      const disposable = commandService.onCommandExecuted((c) => {
        var _a2, _b;
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetActiveOperation.id) {
          const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
          let isBold2 = 0 /* NORMAL */;
          if (primary2 != null) {
            const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
            isBold2 = range == null ? void 0 : range.getFontWeight();
          }
          subscriber.next(isBold2 === 1 /* BOLD */);
        }
        if ((id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) && contextService.getContextValue(EDITOR_ACTIVATED) && contextService.getContextValue(FOCUSING_SHEET)) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            return;
          }
          const bl = (_b = textRun.ts) == null ? void 0 : _b.bl;
          subscriber.next(bl === 1 /* TRUE */);
        }
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      if (!worksheet) {
        subscriber.next(false);
        return;
      }
      let isBold = 0 /* NORMAL */;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        isBold = range == null ? void 0 : range.getFontWeight();
      }
      subscriber.next(isBold === 1 /* BOLD */);
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ItalicMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const contextService = accessor.get(IContextService);
  return {
    id: SetRangeItalicCommand.id,
    type: 0 /* BUTTON */,
    icon: "ItalicSingle",
    title: "Set italic",
    tooltip: "toolbar.italic",
    disabled$: getCurrentRangeDisable$(
      accessor,
      {
        workbookTypes: [WorkbookEditablePermission],
        worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission],
        rangeTypes: [RangeProtectionPermissionEditPoint]
      },
      true
    ),
    activated$: deriveStateFromActiveSheet$(univerInstanceService, false, ({ worksheet }) => new Observable((subscriber) => {
      var _a;
      const disposable = commandService.onCommandExecuted((c) => {
        var _a2, _b;
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetActiveOperation.id) {
          const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
          let isItalic2 = 0 /* NORMAL */;
          if (primary2 != null) {
            const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
            isItalic2 = range == null ? void 0 : range.getFontStyle();
          }
          subscriber.next(isItalic2 === 1 /* ITALIC */);
        }
        if ((id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) && contextService.getContextValue(EDITOR_ACTIVATED) && contextService.getContextValue(FOCUSING_SHEET)) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) return;
          const it = (_b = textRun.ts) == null ? void 0 : _b.it;
          subscriber.next(it === 1 /* TRUE */);
        }
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      let isItalic = 0 /* NORMAL */;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        isItalic = range == null ? void 0 : range.getFontStyle();
      }
      subscriber.next(isItalic === 1 /* ITALIC */);
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function UnderlineMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const contextService = accessor.get(IContextService);
  return {
    id: SetRangeUnderlineCommand.id,
    type: 0 /* BUTTON */,
    icon: "UnderlineSingle",
    title: "Set underline",
    tooltip: "toolbar.underline",
    activated$: deriveStateFromActiveSheet$(univerInstanceService, false, ({ worksheet }) => new Observable((subscriber) => {
      var _a;
      const disposable = commandService.onCommandExecuted((c) => {
        var _a2, _b;
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetActiveOperation.id) {
          const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
          let isUnderline2;
          if (primary2 != null) {
            const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
            isUnderline2 = range == null ? void 0 : range.getUnderline();
          }
          subscriber.next(!!(isUnderline2 && isUnderline2.s));
        }
        if ((id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) && contextService.getContextValue(EDITOR_ACTIVATED) && contextService.getContextValue(FOCUSING_SHEET)) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) return;
          const ul = (_b = textRun.ts) == null ? void 0 : _b.ul;
          subscriber.next((ul == null ? void 0 : ul.s) === 1 /* TRUE */);
        }
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      let isUnderline;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        isUnderline = range == null ? void 0 : range.getUnderline();
      }
      subscriber.next(!!(isUnderline && isUnderline.s));
      return disposable.dispose;
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function StrikeThroughMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const contextService = accessor.get(IContextService);
  return {
    id: SetRangeStrickThroughCommand.id,
    type: 0 /* BUTTON */,
    icon: "StrikethroughSingle",
    title: "Set strike through",
    tooltip: "toolbar.strikethrough",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true),
    activated$: deriveStateFromActiveSheet$(univerInstanceService, false, ({ worksheet }) => new Observable((subscriber) => {
      var _a;
      const disposable = commandService.onCommandExecuted((c) => {
        var _a2, _b;
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetActiveOperation.id) {
          const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
          let st2;
          if (primary2 != null) {
            const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
            st2 = range == null ? void 0 : range.getStrikeThrough();
          }
          subscriber.next(!!(st2 && st2.s));
        }
        if ((id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) && contextService.getContextValue(EDITOR_ACTIVATED) && contextService.getContextValue(FOCUSING_SHEET)) {
          const textRun = getFontStyleAtCursor(accessor);
          if (textRun == null) {
            return;
          }
          const st2 = (_b = textRun.ts) == null ? void 0 : _b.st;
          subscriber.next((st2 == null ? void 0 : st2.s) === 1 /* TRUE */);
        }
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      let st;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        st = range == null ? void 0 : range.getStrikeThrough();
      }
      subscriber.next(!!(st && st.s));
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function FontFamilySelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const defaultValue = DEFAULT_STYLES.ff;
  return {
    id: SetRangeFontFamilyCommand.id,
    tooltip: "toolbar.font",
    type: 1 /* SELECTOR */,
    label: FONT_FAMILY_COMPONENT,
    selections: FONT_FAMILY_LIST.map((item) => ({
      label: {
        name: FONT_FAMILY_ITEM_COMPONENT
      },
      value: item.value
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true),
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      const updateSheet = () => {
        var _a;
        let ff = defaultValue;
        const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
        if (primary != null) {
          const cell = worksheet.getCellStyle(primary.startRow, primary.startColumn);
          const defaultStyle = worksheet.getDefaultCellStyleInternal();
          const rowStyle = worksheet.getRowStyle(primary.startRow);
          const colStyle = worksheet.getColumnStyle(primary.startColumn);
          const style = composeStyles(defaultStyle, rowStyle, colStyle, cell);
          if (style.ff) {
            ff = style.ff;
          }
        }
        subscriber.next(ff);
      };
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetActiveOperation.id) {
          updateSheet();
        }
      });
      updateSheet();
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function FontSizeSelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const contextService = accessor.get(IContextService);
  const defaultValue = DEFAULT_STYLES.fs;
  const disabled$ = getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true);
  return {
    id: SetRangeFontSizeCommand.id,
    type: 1 /* SELECTOR */,
    tooltip: "toolbar.fontSize",
    label: {
      name: FONT_SIZE_COMPONENT,
      props: {
        min: 1,
        max: 400,
        disabled$
      }
    },
    selections: FONT_SIZE_LIST,
    disabled$,
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      const updateSheet = () => {
        var _a;
        let fs = defaultValue;
        const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
        if (primary != null) {
          const cell = worksheet.getCellStyle(primary.startRow, primary.startColumn);
          const defaultStyle = worksheet.getDefaultCellStyleInternal();
          const rowStyle = worksheet.getRowStyle(primary.startRow);
          const colStyle = worksheet.getColumnStyle(primary.startColumn);
          const style = composeStyles(defaultStyle, rowStyle, colStyle, cell);
          if (style.fs) {
            fs = style.fs;
          }
        }
        subscriber.next(fs);
      };
      const updateSheetEditor = () => {
        var _a, _b;
        const textRun = getFontStyleAtCursor(accessor);
        if (textRun != null) {
          const fs = (_b = (_a = textRun.ts) == null ? void 0 : _a.fs) != null ? _b : defaultValue;
          subscriber.next(fs);
        }
      };
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetActiveOperation.id) {
          updateSheet();
        }
        if ((id === SetTextSelectionsOperation.id || id === SetInlineFormatCommand.id) && contextService.getContextValue(EDITOR_ACTIVATED) && contextService.getContextValue(FOCUSING_SHEET)) {
          updateSheetEditor();
        }
      });
      updateSheet();
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ResetTextColorMenuItemFactory(accessor) {
  return {
    id: ResetRangeTextColorCommand.id,
    type: 0 /* BUTTON */,
    title: "toolbar.resetColor",
    icon: "NoColor",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function TextColorSelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const themeService = accessor.get(ThemeService);
  return {
    id: SetRangeTextColorCommand.id,
    icon: "FontColor",
    tooltip: "toolbar.textColor.main",
    type: 2 /* BUTTON_SELECTOR */,
    selections: [
      {
        label: {
          name: COLOR_PICKER_COMPONENT,
          hoverable: false,
          selectable: false
        }
      }
    ],
    value$: new Observable((subscriber) => {
      const defaultValue = themeService.getCurrentTheme().textColor;
      const disposable = commandService.onCommandExecuted((c) => {
        if (c.id === SetRangeTextColorCommand.id) {
          const color = c.params.value;
          subscriber.next(color != null ? color : defaultValue);
        }
      });
      subscriber.next(defaultValue);
      return disposable.dispose;
    }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }, true)
  };
}
function ResetBackgroundColorMenuItemFactory(accessor) {
  return {
    id: ResetBackgroundColorCommand.id,
    type: 0 /* BUTTON */,
    title: "toolbar.resetColor",
    icon: "NoColor",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
function BackgroundColorSelectorMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const themeService = accessor.get(ThemeService);
  return {
    id: SetBackgroundColorCommand.id,
    tooltip: "toolbar.fillColor.main",
    type: 2 /* BUTTON_SELECTOR */,
    icon: "PaintBucket",
    selections: [
      {
        label: {
          name: COLOR_PICKER_COMPONENT,
          hoverable: false,
          selectable: false
        }
      }
    ],
    value$: new Observable((subscriber) => {
      const defaultValue = themeService.getCurrentTheme().primaryColor;
      const disposable = commandService.onCommandExecuted((c) => {
        if (c.id === SetBackgroundColorCommand.id) {
          const color = c.params.value;
          subscriber.next(color != null ? color : defaultValue);
        }
      });
      subscriber.next(defaultValue);
      return disposable.dispose;
    }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
var HORIZONTAL_ALIGN_CHILDREN = [
  {
    label: "align.left",
    icon: "LeftJustifyingSingle",
    value: 1 /* LEFT */
  },
  {
    label: "align.center",
    icon: "HorizontallySingle",
    value: 2 /* CENTER */
  },
  {
    label: "align.right",
    icon: "RightJustifyingSingle",
    value: 3 /* RIGHT */
  }
];
function HorizontalAlignMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const defaultValue = 1 /* LEFT */;
  return {
    id: SetHorizontalTextAlignCommand.id,
    icon: HORIZONTAL_ALIGN_CHILDREN[0].icon,
    tooltip: "toolbar.horizontalAlignMode.main",
    type: 1 /* SELECTOR */,
    selections: HORIZONTAL_ALIGN_CHILDREN,
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      var _a;
      const disposable = accessor.get(ICommandService).onCommandExecuted((c) => {
        var _a2;
        const id = c.id;
        if (id !== SetHorizontalTextAlignCommand.id && id !== SetSelectionsOperation.id && id !== SetWorksheetActiveOperation.id) {
          return;
        }
        const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
        let ha2;
        if (primary2 != null) {
          const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
          ha2 = range == null ? void 0 : range.getHorizontalAlignment();
        }
        subscriber.next(ha2 != null ? ha2 : defaultValue);
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      let ha;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        ha = range == null ? void 0 : range.getHorizontalAlignment();
      }
      subscriber.next(ha != null ? ha : defaultValue);
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
var VERTICAL_ALIGN_CHILDREN = [
  {
    label: "align.top",
    icon: "AlignTopSingle",
    value: 1 /* TOP */
  },
  {
    label: "align.middle",
    icon: "VerticalCenterSingle",
    value: 2 /* MIDDLE */
  },
  {
    label: "align.bottom",
    icon: "AlignBottomSingle",
    value: 3 /* BOTTOM */
  }
];
function VerticalAlignMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const defaultValue = 3 /* BOTTOM */;
  return {
    id: SetVerticalTextAlignCommand.id,
    icon: VERTICAL_ALIGN_CHILDREN[2].icon,
    tooltip: "toolbar.verticalAlignMode.main",
    type: 1 /* SELECTOR */,
    selections: VERTICAL_ALIGN_CHILDREN,
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      var _a;
      const disposable = accessor.get(ICommandService).onCommandExecuted((c) => {
        var _a2;
        const id = c.id;
        if (id !== SetVerticalTextAlignCommand.id && id !== SetSelectionsOperation.id && id !== SetWorksheetActiveOperation.id) {
          return;
        }
        const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
        let va2;
        if (primary2 != null) {
          const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
          va2 = range == null ? void 0 : range.getVerticalAlignment();
        }
        subscriber.next(va2 != null ? va2 : defaultValue);
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      let va;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        va = range == null ? void 0 : range.getVerticalAlignment();
      }
      subscriber.next(va != null ? va : defaultValue);
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
var TEXT_WRAP_CHILDREN = [
  {
    label: "textWrap.overflow",
    icon: "OverflowSingle",
    value: 1 /* OVERFLOW */
  },
  {
    label: "textWrap.wrap",
    icon: "AutowrapSingle",
    value: 3 /* WRAP */
  },
  {
    label: "textWrap.clip",
    icon: "TruncationSingle",
    value: 2 /* CLIP */
  }
];
function WrapTextMenuItemFactory(accessor) {
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const defaultValue = 1 /* OVERFLOW */;
  return {
    id: SetTextWrapCommand.id,
    tooltip: "toolbar.textWrapMode.main",
    icon: TEXT_WRAP_CHILDREN[0].icon,
    type: 1 /* SELECTOR */,
    selections: TEXT_WRAP_CHILDREN,
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      var _a;
      const disposable = accessor.get(ICommandService).onCommandExecuted((c) => {
        var _a2;
        const id = c.id;
        if (id !== SetTextWrapCommand.id && id !== SetSelectionsOperation.id && id !== SetWorksheetActiveOperation.id) {
          return;
        }
        const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
        let ws2;
        if (primary2 != null) {
          const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
          ws2 = range == null ? void 0 : range.getWrapStrategy();
        }
        subscriber.next(ws2 != null ? ws2 : defaultValue);
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      let ws;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        ws = range == null ? void 0 : range.getWrapStrategy();
      }
      subscriber.next(ws != null ? ws : defaultValue);
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
var TEXT_ROTATE_CHILDREN = [
  {
    label: "textRotate.none",
    icon: "NoRotationSingle",
    value: 0
  },
  {
    label: "textRotate.angleUp",
    icon: "LeftRotationFortyFiveDegreesSingle",
    value: -45
  },
  {
    label: "textRotate.angleDown",
    icon: "RightRotationFortyFiveDegreesSingle",
    value: 45
  },
  {
    label: "textRotate.vertical",
    icon: "VerticalTextSingle",
    value: "v"
  },
  {
    label: "textRotate.rotationUp",
    icon: "LeftRotationNinetyDegreesSingle",
    value: -90
  },
  {
    label: "textRotate.rotationDown",
    icon: "RightRotationNinetyDegreesSingle",
    value: 90
  }
];
function TextRotateMenuItemFactory(accessor) {
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const defaultValue = 0;
  return {
    id: SetTextRotationCommand.id,
    tooltip: "toolbar.textRotateMode.main",
    icon: TEXT_ROTATE_CHILDREN[0].icon,
    type: 1 /* SELECTOR */,
    selections: TEXT_ROTATE_CHILDREN,
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      var _a, _b;
      const disposable = accessor.get(ICommandService).onCommandExecuted((c) => {
        var _a2, _b2;
        const id = c.id;
        if (id !== SetTextRotationCommand.id && id !== SetSelectionsOperation.id && id !== SetWorksheetActiveOperation.id) {
          return;
        }
        const primary2 = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.primary;
        let tr2;
        if (primary2 != null) {
          const range = worksheet.getRange(primary2.startRow, primary2.startColumn);
          tr2 = range == null ? void 0 : range.getTextRotation();
        }
        if ((tr2 == null ? void 0 : tr2.v) === 1 /* TRUE */) {
          subscriber.next("v");
        } else {
          subscriber.next((_b2 = tr2 && tr2.a) != null ? _b2 : defaultValue);
        }
      });
      const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
      let tr;
      if (primary != null) {
        const range = worksheet.getRange(primary.startRow, primary.startColumn);
        tr = range == null ? void 0 : range.getTextRotation();
      }
      if ((tr == null ? void 0 : tr.v) === 1 /* TRUE */) {
        subscriber.next("v");
      } else {
        subscriber.next((_b = tr && tr.a) != null ? _b : defaultValue);
      }
      return disposable.dispose;
    })),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
function menuClipboardDisabledObservable(injector) {
  const clipboardDisabled$ = new Observable((subscriber) => subscriber.next(!injector.get(IClipboardInterfaceService).supportClipboard));
  return clipboardDisabled$;
}
function CopyMenuItemFactory(accessor) {
  return {
    id: SheetCopyCommand.name,
    commandId: SheetCopyCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.copy",
    icon: "Copy",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookCopyPermission], worksheetTypes: [WorksheetCopyPermission], rangeTypes: [RangeProtectionPermissionViewPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function PasteMenuItemFactory(accessor) {
  return {
    id: SheetPasteCommand.name,
    commandId: SheetPasteCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.paste",
    icon: "PasteSpecial",
    disabled$: menuClipboardDisabledObservable(accessor).pipe(
      combineLatestWith(getCurrentRangeDisable$(accessor, { rangeTypes: [RangeProtectionPermissionEditPoint], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission, WorksheetSetCellValuePermission], workbookTypes: [WorkbookEditablePermission] })),
      map(([d1, d2]) => d1 || d2)
    ),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
var PASTE_SPECIAL_MENU_ID = "sheet.menu.paste-special";
function PasteSpacialMenuItemFactory(accessor) {
  return {
    id: PASTE_SPECIAL_MENU_ID,
    type: 3 /* SUBITEMS */,
    icon: "PasteSpecial",
    title: "rightClick.pasteSpecial",
    hidden$: getObservableWithExclusiveRange$(accessor, getMenuHiddenObservable(accessor, O.UNIVER_SHEET))
  };
}
function PasteValueMenuItemFactory(accessor) {
  return {
    id: SheetPasteValueCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.pasteValue",
    disabled$: menuClipboardDisabledObservable(accessor).pipe(
      combineLatestWith(getCurrentRangeDisable$(accessor, { rangeTypes: [RangeProtectionPermissionEditPoint], worksheetTypes: [WorksheetSetCellValuePermission, WorksheetEditPermission], workbookTypes: [WorkbookEditablePermission] })),
      map(([d1, d2]) => d1 || d2)
    ),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function PasteFormatMenuItemFactory(accessor) {
  return {
    id: SheetPasteFormatCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.pasteFormat",
    disabled$: menuClipboardDisabledObservable(accessor).pipe(
      combineLatestWith(getCurrentRangeDisable$(accessor, { rangeTypes: [RangeProtectionPermissionEditPoint], worksheetTypes: [WorksheetSetCellStylePermission, WorksheetEditPermission], workbookTypes: [WorkbookEditablePermission] })),
      map(([d1, d2]) => d1 || d2)
    ),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function PasteColWidthMenuItemFactory(accessor) {
  return {
    id: SheetPasteColWidthCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.pasteColWidth",
    disabled$: menuClipboardDisabledObservable(accessor).pipe(
      combineLatestWith(getCurrentRangeDisable$(accessor, { rangeTypes: [RangeProtectionPermissionEditPoint], worksheetTypes: [WorksheetSetColumnStylePermission, WorksheetEditPermission], workbookTypes: [WorkbookEditablePermission] })),
      map(([d1, d2]) => d1 || d2)
    )
  };
}
function PasteBesidesBorderMenuItemFactory(accessor) {
  return {
    id: SheetPasteBesidesBorderCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.pasteBesidesBorder",
    disabled$: menuClipboardDisabledObservable(accessor).pipe(
      combineLatestWith(getCurrentRangeDisable$(accessor, { rangeTypes: [RangeProtectionPermissionEditPoint], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellStylePermission, WorksheetSetCellValuePermission, WorksheetSetRowStylePermission, WorksheetSetColumnStylePermission], workbookTypes: [WorkbookEditablePermission] })),
      map(([d1, d2]) => d1 || d2)
    ),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function FitContentMenuItemFactory(accessor) {
  return {
    id: SetWorksheetRowIsAutoHeightCommand.id,
    type: 0 /* BUTTON */,
    icon: "AutoHeight",
    title: "rightClick.fitContent",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetSetRowStylePermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ColAutoWidthMenuItemFactory(accessor) {
  return {
    id: SetWorksheetColAutoWidthCommand.id,
    type: 0 /* BUTTON */,
    icon: "AutoWidth",
    title: "rightClick.fitContent",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetSetRowStylePermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
var SHEET_FROZEN_MENU_ID = "sheet.menu.sheet-frozen";
function SheetFrozenMenuItemFactory(accessor) {
  return {
    id: SHEET_FROZEN_MENU_ID,
    type: 3 /* SUBITEMS */,
    title: "rightClick.freeze",
    icon: "FreezeToSelectedSingle",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
var SHEET_FROZEN_HEADER_MENU_ID = "sheet.header-menu.sheet-frozen";
function SheetFrozenHeaderMenuItemFactory(accessor) {
  return {
    id: SHEET_FROZEN_HEADER_MENU_ID,
    type: 3 /* SUBITEMS */,
    title: "rightClick.freeze",
    icon: "FreezeToSelectedSingle",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function FrozenMenuItemFactory(accessor) {
  return {
    id: SetSelectionFrozenCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.freeze",
    icon: "FreezeToSelectedSingle",
    // disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function FrozenRowMenuItemFactory(accessor) {
  return {
    id: SetRowFrozenCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.freezeRow",
    icon: "FreezeRowSingle",
    // disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function FrozenColMenuItemFactory(accessor) {
  return {
    id: SetColumnFrozenCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.freezeCol",
    icon: "FreezeColumnSingle",
    // disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function CancelFrozenMenuItemFactory(accessor) {
  return {
    id: CancelFrozenCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.cancelFreeze",
    icon: "CancelFreezeSingle",
    // disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function HideRowMenuItemFactory(accessor) {
  return {
    id: HideRowConfirmCommand.id,
    type: 0 /* BUTTON */,
    icon: "Hide",
    title: "rightClick.hideSelectedRow",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetSetRowStylePermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function HideColMenuItemFactory(accessor) {
  return {
    id: HideColConfirmCommand.id,
    type: 0 /* BUTTON */,
    icon: "Hide",
    title: "rightClick.hideSelectedColumn",
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetColumnStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] }),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ShowRowMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const affectedCommands = [SetSelectionsOperation, SetRowHiddenMutation, SetRowVisibleMutation].map((c) => c.id);
  return {
    id: SetSelectedRowsVisibleCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.showHideRow",
    hidden$: deriveStateFromActiveSheet$(univerInstanceService, true, ({ worksheet }) => new Observable((subscriber) => {
      function hasHiddenRowsInSelections() {
        var _a;
        const rowRanges = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range).filter((r) => r.rangeType === 1 /* ROW */);
        return !!(rowRanges == null ? void 0 : rowRanges.some((range) => {
          for (let r = range.startRow; r <= range.endRow; r++) {
            if (!worksheet.getRowRawVisible(r)) return true;
          }
          return false;
        }));
      }
      const disposable = commandService.onCommandExecuted((command) => {
        if (affectedCommands.findIndex((c) => c === command.id) !== -1) subscriber.next(!hasHiddenRowsInSelections());
      });
      subscriber.next(!hasHiddenRowsInSelections());
      return () => disposable.dispose();
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetRowStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
function ShowColMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const commandService = accessor.get(ICommandService);
  const affectedCommands = [SetSelectionsOperation, SetColHiddenMutation, SetColVisibleMutation].map((c) => c.id);
  return {
    id: SetSelectedColsVisibleCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.showHideColumn",
    hidden$: deriveStateFromActiveSheet$(univerInstanceService, true, ({ worksheet }) => new Observable((subscriber) => {
      function hasHiddenColsInSelections() {
        var _a;
        const colRanges = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range).filter((r) => r.rangeType === 2 /* COLUMN */);
        if (!colRanges || colRanges.length === 0) return false;
        return !!colRanges.some((range) => {
          for (let r = range.startColumn; r <= range.endColumn; r++) {
            if (!worksheet.getColVisible(r)) return true;
          }
          return false;
        });
      }
      const disposable = commandService.onCommandExecuted((commandInfo) => {
        if (affectedCommands.findIndex((c) => c === commandInfo.id) !== -1) subscriber.next(!hasHiddenColsInSelections());
      });
      subscriber.next(!hasHiddenColsInSelections());
      return () => disposable.dispose();
    })),
    disabled$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetSetColumnStylePermission, WorksheetEditPermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
function SetRowHeightMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const defaultValue = 0;
  return {
    id: SetRowHeightCommand.id,
    type: 0 /* BUTTON */,
    icon: "AdjustHeight",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.rowHeight",
        suffix: "px",
        min: 2,
        max: 1e3
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      function update() {
        var _a;
        const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
        const rowHeight = primary ? worksheet.getRowHeight(primary.startRow) : defaultValue;
        subscriber.next(rowHeight);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetRowIsAutoHeightMutation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    hidden$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetRowStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
function SetColWidthMenuItemFactory(accessor) {
  const commandService = accessor.get(ICommandService);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const defaultValue = 0;
  return {
    id: SetColWidthCommand.id,
    type: 0 /* BUTTON */,
    icon: "AdjustWidth",
    label: {
      name: MENU_ITEM_INPUT_COMPONENT,
      props: {
        prefix: "rightClick.columnWidth",
        suffix: "px",
        min: 2,
        max: 1e3
      }
    },
    value$: deriveStateFromActiveSheet$(univerInstanceService, defaultValue, ({ worksheet }) => new Observable((subscriber) => {
      function update() {
        var _a;
        const primary = (_a = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.primary;
        let colWidth = defaultValue;
        if (primary != null) {
          colWidth = worksheet.getColumnWidth(primary.startColumn);
        }
        subscriber.next(colWidth);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === SetRangeValuesMutation.id || id === SetSelectionsOperation.id || id === SetWorksheetColWidthMutation.id) {
          return update();
        }
      });
      update();
      return disposable.dispose;
    })),
    hidden$: getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetColumnStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] })
  };
}
function getFontStyleAtCursor(accessor) {
  var _a;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const textSelectionService = accessor.get(DocSelectionManagerService);
  const editorDataModel = univerInstanceService.getUniverDocInstance(DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
  const activeTextRange = textSelectionService.getActiveTextRange();
  if (editorDataModel == null || activeTextRange == null) return null;
  const textRuns = (_a = editorDataModel.getBody()) == null ? void 0 : _a.textRuns;
  if (textRuns == null) return;
  const { startOffset } = activeTextRange;
  const textRun = textRuns.find(({ st, ed }) => startOffset >= st && startOffset <= ed);
  return textRun;
}

// ../packages/sheets-ui/src/controllers/utils/selections-tools.ts
function getSheetSelectionsDisabled$(accessor) {
  const selectionManagerService = accessor.get(SheetsSelectionsService);
  const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const mergeCellController = accessor.get(MergeCellController);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  return combineLatest([
    selectionManagerService.selectionMoveEnd$,
    workbook$.pipe(map((workbook) => {
      var _a;
      return (_a = workbook == null ? void 0 : workbook.getUnitId()) != null ? _a : "";
    })),
    workbook$.pipe(switchMap((workbook) => {
      var _a;
      return (_a = workbook == null ? void 0 : workbook.activeSheet$) != null ? _a : of(null);
    }))
  ]).pipe(
    map(([selection, unitId, sheet]) => {
      if (!sheet) return false;
      if (!selection || selection.length === 0) return false;
      const subUnitId = sheet.getSheetId();
      const selectionRanges = selection.map((sel) => sel.range);
      const disableResByInterceptor = mergeCellController.interceptor.fetchThroughInterceptors(MERGE_CELL_INTERCEPTOR_CHECK)(false, selectionRanges);
      if (disableResByInterceptor) {
        return true;
      }
      const subUnitRuleRange = rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).map((rule) => rule.ranges).flat();
      if (selection.length < 2) {
        const range = selection[0].range;
        const rangeIsOverlap = subUnitRuleRange.some((ruleRange) => {
          return Rectangle.intersects(ruleRange, range) && !Rectangle.contains(ruleRange, range);
        });
        return rangeIsOverlap;
      }
      for (let i = 0; i < selection.length; i++) {
        for (let j = i + 1; j < selection.length; j++) {
          if (Rectangle.intersects(selection[i].range, selection[j].range)) {
            return true;
          }
        }
      }
      return false;
    })
  );
}
function isThisRowSelected(selections, rowIndex) {
  return !!matchedSelectionByRowColIndex(selections, rowIndex, 1 /* ROW */);
}
function isThisColSelected(selections, colIndex) {
  return !!matchedSelectionByRowColIndex(selections, colIndex, 2 /* COLUMN */);
}
function matchedSelectionByRowColIndex(selections, indexOfRowCol, rowOrCol) {
  const matchSelectionData = selections.find((sel) => {
    const range = sel.range;
    const { startRow: startRowOfCurrSel, endRow: endRowOfCurrSel, startColumn: startColumnOfCurrSel, endColumn: endColumnOfCurrSel, rangeType: rangeTypeOfCurrSelection } = range;
    if (rangeTypeOfCurrSelection === 3 /* ALL */ || rangeTypeOfCurrSelection === 0 /* NORMAL */) return false;
    if (rangeTypeOfCurrSelection === rowOrCol) {
      if (rowOrCol === 2 /* COLUMN */ && startColumnOfCurrSel <= indexOfRowCol && indexOfRowCol <= endColumnOfCurrSel) {
        return true;
      }
      if (rowOrCol === 1 /* ROW */ && startRowOfCurrSel <= indexOfRowCol && indexOfRowCol <= endRowOfCurrSel) {
        return true;
      }
    }
    return false;
  });
  return matchSelectionData;
}

// ../packages/sheets-ui/src/controllers/menu/merge.menu.ts
function CellMergeMenuItemFactory(accessor) {
  const editDisabled$ = getCurrentRangeDisable$(accessor, { workbookTypes: [WorkbookEditablePermission], worksheetTypes: [WorksheetEditPermission, WorksheetSetCellValuePermission, WorksheetSetCellStylePermission], rangeTypes: [RangeProtectionPermissionEditPoint] });
  const selectionsHasCross$ = getSheetSelectionsDisabled$(accessor);
  return {
    id: AddWorksheetMergeCommand2.id,
    icon: "MergeAllSingle",
    tooltip: "toolbar.mergeCell.main",
    type: 3 /* SUBITEMS */,
    // selections: [...MERGE_CHILDREN],
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: editDisabled$.pipe(
      combineLatestWith(selectionsHasCross$),
      map(([disable, hasCross]) => disable || hasCross)
    )
  };
}
function CellMergeAllMenuItemFactory(accessor) {
  return {
    id: AddWorksheetMergeAllCommand2.id,
    type: 0 /* BUTTON */,
    title: "merge.all",
    icon: "MergeAllSingle",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function CellMergeVerticalMenuItemFactory(accessor) {
  return {
    id: AddWorksheetMergeVerticalCommand2.id,
    type: 0 /* BUTTON */,
    title: "merge.vertical",
    icon: "VerticalIntegrationSingle",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function CellMergeHorizontalMenuItemFactory(accessor) {
  return {
    id: AddWorksheetMergeHorizontalCommand2.id,
    type: 0 /* BUTTON */,
    title: "merge.horizontal",
    icon: "HorizontalMergeSingle",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function CellMergeCancelMenuItemFactory(accessor) {
  return {
    id: RemoveWorksheetMergeCommand.id,
    type: 0 /* BUTTON */,
    title: "merge.cancel",
    icon: "CancelMergeSingle",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}

// ../packages/sheets-ui/src/controllers/menu/permission-menu-util.ts
function getAddPermissionHidden$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([workbook$, userManagerService.currentUser$]).pipe(
    switchMap(([workbook, _]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          if (!worksheet) {
            return of(true);
          }
          const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const selectionManagerService = accessor.get(SheetsSelectionsService);
          return merge(
            selectionManagerService.selectionMoveEnd$,
            rangeProtectionRuleModel.ruleChange$,
            worksheetRuleModel.ruleChange$
          ).pipe(
            map(() => {
              const unitId = workbook.getUnitId();
              const subUnitId = worksheet.getSheetId();
              const subUnitRuleList = rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
              const selections = selectionManagerService.getCurrentSelections();
              const selectionsRanges = selections == null ? void 0 : selections.map((selection) => selection.range);
              const ruleRanges = subUnitRuleList.map((rule) => rule.ranges).flat();
              if (!selectionsRanges) {
                return false;
              }
              const worksheetRule = worksheetRuleModel.getRule(unitId, subUnitId);
              if (worksheetRule == null ? void 0 : worksheetRule.permissionId) {
                return true;
              }
              return selectionsRanges == null ? void 0 : selectionsRanges.some((selectionRange) => {
                return ruleRanges.some((ruleRange) => {
                  return Rectangle.intersects(selectionRange, ruleRange);
                });
              });
            })
          );
        })
      );
    })
  );
}
function getEditPermissionHidden$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const rangeRuleModel = accessor.get(RangeProtectionRuleModel);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([workbook$, userManagerService.currentUser$]).pipe(
    switchMap(([workbook, _]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          if (!worksheet) {
            return of(true);
          }
          const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const permissionService = accessor.get(IPermissionService);
          const selectionManagerService = accessor.get(SheetsSelectionsService);
          return merge(
            selectionManagerService.selectionMoveEnd$,
            rangeProtectionRuleModel.ruleChange$,
            worksheetRuleModel.ruleChange$
          ).pipe(
            map(() => {
              var _a, _b;
              const unitId = workbook.getUnitId();
              const subUnitId = worksheet.getSheetId();
              const subUnitRuleList = rangeRuleModel.getSubunitRuleList(unitId, subUnitId);
              const selectionRanges = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((selection) => selection.range);
              const ruleRanges = subUnitRuleList.map((rule) => rule.ranges).flat();
              if (!(selectionRanges == null ? void 0 : selectionRanges.length)) {
                return true;
              }
              if (selectionRanges.length > 1) {
                return true;
              }
              const selectionRange = selectionRanges[0];
              if ((selectionRange == null ? void 0 : selectionRange.rangeType) === 3 /* ALL */ || (selectionRange == null ? void 0 : selectionRange.rangeType) === 2 /* COLUMN */ || (selectionRange == null ? void 0 : selectionRange.rangeType) === 1 /* ROW */) {
                return true;
              }
              const worksheetRule = worksheetRuleModel.getRule(unitId, subUnitId);
              if (worksheetRule == null ? void 0 : worksheetRule.permissionId) {
                return ((_b = permissionService.getPermissionPoint(new WorksheetManageCollaboratorPermission(unitId, subUnitId).id)) == null ? void 0 : _b.value) === false;
              }
              const overlapRule = subUnitRuleList.filter((rule) => {
                return rule.ranges.some((range) => {
                  return Rectangle.intersects(range, selectionRange);
                });
              });
              if (overlapRule.length !== 1) {
                return true;
              }
              const { startRow, endRow, startColumn, endColumn } = selectionRange;
              const rangeProtectionCache = accessor.get(RangeProtectionCache);
              for (let i = startRow; i <= endRow; i++) {
                for (let j = startColumn; j <= endColumn; j++) {
                  const cellInfo = rangeProtectionCache.getCellInfo(unitId, subUnitId, i, j);
                  if (cellInfo) {
                    return cellInfo[D.ManageCollaborator] === false;
                  }
                }
              }
              return false;
            })
          );
        })
      );
    })
  );
}
function getPermissionDisableBase$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const permissionService = accessor.get(IPermissionService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([workbook$, userManagerService.currentUser$]).pipe(
    switchMap(([workbook, _]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          var _a;
          if (!worksheet) {
            return of(true);
          }
          const unitId = workbook.getUnitId();
          const selectionManagerService = accessor.get(SheetsSelectionsService);
          const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const permission$ = (_a = permissionService.composePermission$([new WorkbookEditablePermission(unitId).id]).pipe(map((permissions) => permissions.every((permission) => permission.value)))) != null ? _a : of(false);
          const ruleChange$ = merge(
            selectionProtectionRuleModel.ruleChange$,
            worksheetProtectionRuleModel.ruleChange$
          ).pipe(
            startWith(null)
          );
          return combineLatest([permission$, ruleChange$, selectionManagerService.selectionMoveEnd$]).pipe(
            map(([permission, _2, __]) => {
              if (!permission) {
                return true;
              }
              const selections = selectionManagerService.getCurrentSelections();
              const selectionRanges = selections == null ? void 0 : selections.map((selection) => selection.range);
              if (!(selectionRanges == null ? void 0 : selectionRanges.length)) {
                return false;
              }
              if (selectionRanges.length > 1) {
                return true;
              }
              return false;
            })
          );
        })
      );
    })
  );
}
function getAddPermissionDisableBase$(accessor) {
  var _a;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const permissionService = accessor.get(IPermissionService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  const editorBridgeService = accessor.has(IEditorBridgeService) ? accessor.get(IEditorBridgeService) : null;
  const contextService = accessor.get(IContextService);
  const formulaEditorFocus$ = contextService.subscribeContextValue$(FOCUSING_FX_BAR_EDITOR);
  const editorVisible$ = (_a = editorBridgeService == null ? void 0 : editorBridgeService.visible$) != null ? _a : of(null);
  return combineLatest([workbook$, userManagerService.currentUser$, editorVisible$, formulaEditorFocus$]).pipe(
    switchMap(([workbook, _, visible, formulaEditorFocus]) => {
      if (!workbook || (visible == null ? void 0 : visible.visible) && visible.unitId === workbook.getUnitId() || formulaEditorFocus) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          var _a2;
          if (!worksheet) {
            return of(true);
          }
          const contextService2 = accessor.get(IContextService);
          const focusingDrawing$ = contextService2.subscribeContextValue$(FOCUSING_COMMON_DRAWINGS).pipe(startWith(false));
          const unitId = workbook.getUnitId();
          const subUnitId = worksheet.getSheetId();
          const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const selectionManagerService = accessor.get(SheetsSelectionsService);
          const permission$ = (_a2 = permissionService.composePermission$([new WorkbookCreateProtectPermission(unitId).id]).pipe(map((permissions) => permissions.every((permission) => permission.value)))) != null ? _a2 : of(false);
          const ruleChange$ = merge(
            selectionProtectionRuleModel.ruleChange$,
            worksheetProtectionRuleModel.ruleChange$
          ).pipe(
            startWith(null)
          );
          return combineLatest([permission$, ruleChange$, selectionManagerService.selectionMoveEnd$, focusingDrawing$]).pipe(
            map(([permission, _2, __, focus]) => {
              if (!permission || focus) {
                return true;
              }
              const selections = selectionManagerService.getCurrentSelections();
              const selectionRanges = selections == null ? void 0 : selections.map((selection) => selection.range);
              if (!(selectionRanges == null ? void 0 : selectionRanges.length)) {
                return true;
              }
              const worksheetRule = worksheetProtectionRuleModel.getRule(unitId, subUnitId);
              if (worksheetRule == null ? void 0 : worksheetRule.permissionId) {
                return true;
              }
              const subunitRuleList = selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
              const hasLap = selectionRanges == null ? void 0 : selectionRanges.some((selectionRange) => {
                return subunitRuleList.some((rule) => {
                  return rule.ranges.some((ruleRange) => {
                    return Rectangle.intersects(selectionRange, ruleRange);
                  });
                });
              });
              return hasLap;
            })
          );
        })
      );
    })
  );
}
function getAddPermissionFromSheetBarDisable$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const permissionService = accessor.get(IPermissionService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([workbook$, userManagerService.currentUser$]).pipe(
    switchMap(([workbook, _]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          var _a;
          if (!worksheet) {
            return of(true);
          }
          const unitId = workbook.getUnitId();
          const subUnitId = worksheet.getSheetId();
          const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const permission$ = (_a = permissionService.composePermission$([new WorkbookCreateProtectPermission(unitId).id]).pipe(map((permissions) => permissions.every((permission) => permission.value)))) != null ? _a : of(false);
          const ruleChange$ = merge(
            selectionProtectionRuleModel.ruleChange$,
            worksheetProtectionRuleModel.ruleChange$
          ).pipe(
            startWith(null)
          );
          return combineLatest([permission$, ruleChange$]).pipe(
            map(([permission, _2]) => {
              var _a2;
              if (!permission) return true;
              const worksheetRule = worksheetProtectionRuleModel.getRule(unitId, subUnitId);
              if (worksheetRule == null ? void 0 : worksheetRule.permissionId) return true;
              const subUnitRuleList = (_a2 = selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId)) == null ? void 0 : _a2.filter((item) => item == null ? void 0 : item.permissionId);
              return subUnitRuleList.length > 0;
            })
          );
        })
      );
    })
  );
}
function getRemovePermissionFromSheetBarDisable$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const permissionService = accessor.get(IPermissionService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([workbook$, userManagerService.currentUser$]).pipe(
    switchMap(([workbook, _]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          if (!worksheet) {
            return of(true);
          }
          const unitId = workbook.getUnitId();
          const subUnitId = worksheet.getSheetId();
          const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
          return worksheetProtectionRuleModel.ruleChange$.pipe(startWith(null)).pipe(
            map(() => {
              var _a;
              const rule = worksheetProtectionRuleModel.getRule(unitId, subUnitId);
              if (rule) {
                return ((_a = permissionService.getPermissionPoint(new WorksheetDeleteProtectionPermission(unitId, subUnitId).id)) == null ? void 0 : _a.value) === false;
              }
              return true;
            })
          );
        })
      );
    })
  );
}
function getSetPermissionFromSheetBarDisable$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const permissionService = accessor.get(IPermissionService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([workbook$, userManagerService.currentUser$]).pipe(
    switchMap(([workbook, _]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          var _a;
          if (!worksheet) {
            return of(true);
          }
          const unitId = workbook.getUnitId();
          const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const permission$ = (_a = permissionService.composePermission$([new WorkbookCreateProtectPermission(unitId).id, new WorkbookManageCollaboratorPermission(unitId).id]).pipe(map((permissions) => permissions.every((permission) => permission.value)))) != null ? _a : of(false);
          const worksheetRuleChange$ = worksheetProtectionRuleModel.ruleChange$.pipe(startWith(null));
          const selectionRuleChange$ = selectionProtectionRuleModel.ruleChange$.pipe(startWith(null));
          return combineLatest([permission$, worksheetRuleChange$, selectionRuleChange$]).pipe(
            map(([permission, _2, __]) => {
              if (!permission) {
                return true;
              }
              const subUnitId = worksheet.getSheetId();
              const worksheetRule = worksheetProtectionRuleModel.getRule(unitId, subUnitId);
              const selectionRuleList = selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
              if (worksheetRule || selectionRuleList.length) {
                return false;
              }
              return true;
            })
          );
        })
      );
    })
  );
}
function getRemovePermissionDisable$(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const permissionService = accessor.get(IPermissionService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  return combineLatest([workbook$, userManagerService.currentUser$]).pipe(
    switchMap(([workbook, _]) => {
      if (!workbook) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          if (!worksheet) {
            return of(true);
          }
          const unitId = workbook.getUnitId();
          const subUnitId = worksheet.getSheetId();
          const sheetSelectionsService = accessor.get(SheetsSelectionsService);
          const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
          const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
          const changes$ = merge(
            selectionProtectionRuleModel.ruleChange$,
            worksheetProtectionRuleModel.ruleChange$,
            sheetSelectionsService.selectionMoveEnd$
          ).pipe(startWith(null));
          return combineLatest([changes$]).pipe(
            map(([_2]) => {
              var _a;
              const selections = accessor.get(SheetsSelectionsService).getCurrentSelections();
              const selectionRanges = selections == null ? void 0 : selections.map((selection) => selection.range);
              if (!(selectionRanges == null ? void 0 : selectionRanges.length) || selectionRanges.length > 1) {
                return true;
              }
              const selectionRange = selectionRanges[0];
              if ((selectionRange == null ? void 0 : selectionRange.rangeType) === 3 /* ALL */ || (selectionRange == null ? void 0 : selectionRange.rangeType) === 2 /* COLUMN */ || (selectionRange == null ? void 0 : selectionRange.rangeType) === 1 /* ROW */) {
                return true;
              }
              const worksheetRule = worksheetProtectionRuleModel.getRule(unitId, subUnitId);
              if (worksheetRule == null ? void 0 : worksheetRule.permissionId) {
                return ((_a = permissionService.getPermissionPoint(new WorksheetDeleteProtectionPermission(unitId, subUnitId).id)) == null ? void 0 : _a.value) === false;
              }
              const overlapRule = selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
                return rule.ranges.some((range) => {
                  return Rectangle.intersects(range, selectionRange);
                });
              });
              if (overlapRule.length !== 1) {
                return true;
              }
              const { startRow, endRow, startColumn, endColumn } = selectionRange;
              const rangeProtectionCache = accessor.get(RangeProtectionCache);
              for (let i = startRow; i <= endRow; i++) {
                for (let j = startColumn; j <= endColumn; j++) {
                  const cellInfo = rangeProtectionCache.getCellInfo(unitId, subUnitId, i, j);
                  if (cellInfo) {
                    return cellInfo[D.Delete] === false;
                  }
                }
              }
              return false;
            })
          );
        })
      );
    })
  );
}
function getViewPermissionDisable$(accessor) {
  var _a;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const permissionService = accessor.get(IPermissionService);
  const workbook$ = univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET);
  const userManagerService = accessor.get(UserManagerService);
  const editorBridgeService = accessor.has(IEditorBridgeService) ? accessor.get(IEditorBridgeService) : null;
  const contextService = accessor.get(IContextService);
  const formulaEditorFocus$ = contextService.subscribeContextValue$(FOCUSING_FX_BAR_EDITOR);
  const editorVisible$ = (_a = editorBridgeService == null ? void 0 : editorBridgeService.visible$) != null ? _a : of(null);
  return combineLatest([workbook$, userManagerService.currentUser$, editorVisible$, formulaEditorFocus$]).pipe(
    switchMap(([workbook, _, visible, formulaEditorFocus]) => {
      if (!workbook || (visible == null ? void 0 : visible.visible) && visible.unitId === workbook.getUnitId() || formulaEditorFocus) {
        return of(true);
      }
      return workbook.activeSheet$.pipe(
        switchMap((worksheet) => {
          var _a2, _b;
          if (!worksheet) {
            return of(true);
          }
          const unitId = workbook.getUnitId();
          const permission$ = (_b = (_a2 = permissionService.getPermissionPoint$(new WorkbookEditablePermission(unitId).id)) == null ? void 0 : _a2.pipe(map((e) => !!e.value))) != null ? _b : of(false);
          return permission$.pipe(
            map((permission) => !permission)
          );
        })
      );
    })
  );
}

// ../packages/sheets-ui/src/controllers/menu/permission.menu.ts
var SHEET_PERMISSION_CONTEXT_MENU_ID = "sheet.contextMenu.permission";
function sheetPermissionToolbarMenuFactory(accessor) {
  return {
    id: AddRangeProtectionFromToolbarCommand.id,
    type: 0 /* BUTTON */,
    icon: permissionMenuIconKey,
    tooltip: "permission.toolbarMenu",
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET),
    disabled$: getAddPermissionDisableBase$(accessor)
  };
}
function sheetPermissionContextMenuFactory(accessor) {
  return {
    id: SHEET_PERMISSION_CONTEXT_MENU_ID,
    type: 3 /* SUBITEMS */,
    title: "rightClick.protectRange",
    icon: permissionLockIconKey,
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function sheetPermissionAddProtectContextMenuFactory(accessor) {
  return {
    id: AddRangeProtectionFromContextMenuCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.turnOnProtectRange",
    hidden$: getAddPermissionHidden$(accessor),
    disabled$: getAddPermissionDisableBase$(accessor)
  };
}
function sheetPermissionEditProtectContextMenuFactory(accessor) {
  return {
    id: SetRangeProtectionFromContextMenuCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.editProtectRange",
    disabled$: getPermissionDisableBase$(accessor),
    hidden$: getEditPermissionHidden$(accessor)
  };
}
function sheetPermissionRemoveProtectContextMenuFactory(accessor) {
  return {
    id: DeleteRangeProtectionFromContextMenuCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.removeProtectRange",
    disabled$: getRemovePermissionDisable$(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function sheetPermissionViewAllProtectRuleContextMenuFactory(accessor) {
  return {
    id: ViewSheetPermissionFromContextMenuCommand.id,
    type: 0 /* BUTTON */,
    title: "rightClick.viewAllProtectArea",
    disabled$: getViewPermissionDisable$(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function sheetPermissionProtectSheetInSheetBarMenuFactory(accessor) {
  return {
    id: AddRangeProtectionFromSheetBarCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.addProtectSheet",
    disabled$: getAddPermissionFromSheetBarDisable$(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function sheetPermissionRemoveProtectionSheetBarMenuFactory(accessor) {
  return {
    id: DeleteWorksheetProtectionFormSheetBarCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.removeProtectSheet",
    disabled$: getRemovePermissionFromSheetBarDisable$(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function sheetPermissionChangeSheetPermissionSheetBarMenuFactory(accessor) {
  return {
    id: ChangeSheetProtectionFromSheetBarCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.changeSheetPermission",
    disabled$: getSetPermissionFromSheetBarDisable$(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function sheetPermissionViewAllProtectRuleSheetBarMenuFactory(accessor) {
  return {
    id: ViewSheetPermissionFromSheetBarCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.viewAllProtectArea",
    disabled$: getViewPermissionDisable$(accessor),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}

// ../packages/sheets-ui/src/controllers/menu/sheet.menu.ts
function DeleteSheetMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const commandService = accessor.get(ICommandService);
  const defaultDisable$ = new Observable((subscriber) => {
    const disposable = commandService.onCommandExecuted((c) => {
      const id = c.id;
      if (id === RemoveSheetMutation.id || id === InsertSheetMutation.id || id === SetWorksheetHideMutation.id) {
        disableFunction(univerInstanceService, subscriber);
      }
    });
    disableFunction(univerInstanceService, subscriber);
    return disposable.dispose;
  });
  const permissionDisable$ = getWorkbookPermissionDisable$(accessor, [WorkbookEditablePermission, WorkbookDeleteSheetPermission]);
  return {
    id: RemoveSheetConfirmCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.delete",
    disabled$: combineLatest([defaultDisable$, permissionDisable$]).pipe(
      map(([defaultDisabled, permissionDisabled]) => {
        return defaultDisabled || permissionDisabled;
      })
    ),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function CopySheetMenuItemFactory(accessor) {
  return {
    id: CopySheetCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.copy",
    disabled$: getWorkbookPermissionDisable$(accessor, [WorkbookEditablePermission, WorkbookCreateSheetPermission]),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function RenameSheetMenuItemFactory(accessor) {
  return {
    id: RenameSheetOperation.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.rename",
    disabled$: getWorkbookPermissionDisable$(accessor, [WorkbookEditablePermission, WorkbookRenameSheetPermission]),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ChangeColorSheetMenuItemFactory(accessor) {
  return {
    id: SetTabColorCommand.id,
    title: "sheetConfig.changeColor",
    type: 1 /* SELECTOR */,
    selections: [
      {
        label: {
          name: COLOR_PICKER_COMPONENT,
          hoverable: false
        }
      }
    ],
    hidden$: getWorkbookPermissionDisable$(accessor, [WorkbookEditablePermission])
  };
}
function HideSheetMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const commandService = accessor.get(ICommandService);
  return {
    id: SetWorksheetHideCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.hide",
    disabled$: new Observable((subscriber) => {
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === RemoveSheetMutation.id || id === InsertSheetMutation.id || id === SetWorksheetHideMutation.id) {
          disableFunction(univerInstanceService, subscriber);
        }
      });
      disableFunction(univerInstanceService, subscriber);
      return disposable.dispose;
    }).pipe(
      combineLatestWith(getWorkbookPermissionDisable$(accessor, [WorkbookEditablePermission, WorkbookHideSheetPermission])),
      map(([defaultDisabled, permissionDisabled]) => defaultDisabled || permissionDisabled)
    ),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function ShowMenuItemFactory(accessor) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const commandService = accessor.get(ICommandService);
  return {
    id: ShowMenuListCommand.id,
    type: 0 /* BUTTON */,
    title: "sheetConfig.unhide",
    disabled$: new Observable((subscriber) => {
      function disableFunction2() {
        const worksheets = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getWorksheets();
        const visibleSheets = Array.from(worksheets.values());
        subscriber.next(visibleSheets.length === 1);
      }
      const disposable = commandService.onCommandExecuted((c) => {
        const id = c.id;
        if (id === RemoveSheetMutation.id || id === InsertSheetMutation.id || id === SetWorksheetHideMutation.id) {
          disableFunction2();
        }
      });
      disableFunction2();
      return disposable.dispose;
    }).pipe(
      combineLatestWith(getWorkbookPermissionDisable$(accessor, [WorkbookEditablePermission, WorkbookHideSheetPermission])),
      map(([defaultDisabled, permissionDisabled]) => defaultDisabled || permissionDisabled)
    ),
    hidden$: getMenuHiddenObservable(accessor, O.UNIVER_SHEET)
  };
}
function disableFunction(univerInstanceService, subscriber) {
  const worksheets = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getWorksheets();
  const visibleSheets = Array.from(worksheets.values()).filter(
    (sheet) => sheet.getConfig().hidden === 0 /* FALSE */
  );
  subscriber.next(visibleSheets.length === 1);
}

// ../packages/sheets-ui/src/controllers/menu.schema.ts
var menuSchema = {
  ["ribbon.start.format" /* FORMAT */]: {
    [SetOnceFormatPainterCommand.id]: {
      order: 0,
      menuItemFactory: FormatPainterMenuItemFactory
    },
    [SetRangeBoldCommand.id]: {
      order: 1,
      menuItemFactory: BoldMenuItemFactory
    },
    [SetRangeItalicCommand.id]: {
      order: 2,
      menuItemFactory: ItalicMenuItemFactory
    },
    [SetRangeUnderlineCommand.id]: {
      order: 3,
      menuItemFactory: UnderlineMenuItemFactory
    },
    [SetRangeStrickThroughCommand.id]: {
      order: 4,
      menuItemFactory: StrikeThroughMenuItemFactory
    },
    [SetRangeFontFamilyCommand.id]: {
      order: 5,
      menuItemFactory: FontFamilySelectorMenuItemFactory
    },
    [SetRangeFontSizeCommand.id]: {
      order: 6,
      menuItemFactory: FontSizeSelectorMenuItemFactory
    },
    [SetRangeTextColorCommand.id]: {
      order: 7,
      menuItemFactory: TextColorSelectorMenuItemFactory,
      [ResetTextColorCommand.id]: {
        order: 0,
        menuItemFactory: ResetTextColorMenuItemFactory
      }
    },
    [SetBackgroundColorCommand.id]: {
      order: 9,
      menuItemFactory: BackgroundColorSelectorMenuItemFactory,
      [ResetBackgroundColorCommand.id]: {
        order: 0,
        menuItemFactory: ResetBackgroundColorMenuItemFactory
      }
    },
    [SetBorderBasicCommand.id]: {
      order: 10,
      menuItemFactory: CellBorderSelectorMenuItemFactory
    }
  },
  ["ribbon.start.layout" /* LAYOUT */]: {
    [AddWorksheetMergeCommand.id]: {
      order: 0,
      menuItemFactory: CellMergeMenuItemFactory,
      [AddWorksheetMergeAllCommand.id]: {
        order: 0,
        menuItemFactory: CellMergeAllMenuItemFactory
      },
      [AddWorksheetMergeVerticalCommand.id]: {
        order: 1,
        menuItemFactory: CellMergeVerticalMenuItemFactory
      },
      [AddWorksheetMergeHorizontalCommand.id]: {
        order: 2,
        menuItemFactory: CellMergeHorizontalMenuItemFactory
      },
      [RemoveWorksheetMergeCommand.id]: {
        order: 3,
        menuItemFactory: CellMergeCancelMenuItemFactory
      }
    },
    [SetHorizontalTextAlignCommand.id]: {
      order: 1,
      menuItemFactory: HorizontalAlignMenuItemFactory
    },
    [SetVerticalTextAlignCommand.id]: {
      order: 1,
      menuItemFactory: VerticalAlignMenuItemFactory
    },
    [SetTextWrapCommand.id]: {
      order: 2,
      menuItemFactory: WrapTextMenuItemFactory
    },
    [SetTextRotationCommand.id]: {
      order: 3,
      menuItemFactory: TextRotateMenuItemFactory
    }
  },
  ["ribbon.start.others" /* OTHERS */]: {
    [AddRangeProtectionFromToolbarCommand.id]: {
      order: 0,
      menuItemFactory: sheetPermissionToolbarMenuFactory
    }
  },
  ["contextMenu.mainArea" /* MAIN_AREA */]: {
    ["contextMenu.format" /* FORMAT */]: {
      [SheetCopyCommand.name]: {
        order: 0,
        menuItemFactory: CopyMenuItemFactory
      },
      // [SheetCutCommand.name]: {
      //     order: 1,
      //     menuItemFactory: CutMenuItemFactory,
      // },
      [SheetPasteCommand.name]: {
        order: 2,
        menuItemFactory: PasteMenuItemFactory
      },
      [PASTE_SPECIAL_MENU_ID]: {
        order: 3,
        menuItemFactory: PasteSpacialMenuItemFactory,
        [SheetPasteValueCommand.id]: {
          order: 0,
          menuItemFactory: PasteValueMenuItemFactory
        },
        [SheetPasteFormatCommand.id]: {
          order: 1,
          menuItemFactory: PasteFormatMenuItemFactory
        },
        [SheetPasteColWidthCommand.id]: {
          order: 2,
          menuItemFactory: PasteColWidthMenuItemFactory
        },
        [SheetPasteBesidesBorderCommand.id]: {
          order: 3,
          menuItemFactory: PasteBesidesBorderMenuItemFactory
        }
      },
      [CLEAR_SELECTION_MENU_ID]: {
        order: 4,
        menuItemFactory: ClearSelectionMenuItemFactory,
        [ClearSelectionContentCommand.id]: {
          order: 0,
          menuItemFactory: ClearSelectionContentMenuItemFactory
        },
        [ClearSelectionFormatCommand.id]: {
          order: 1,
          menuItemFactory: ClearSelectionFormatMenuItemFactory
        },
        [ClearSelectionAllCommand.id]: {
          order: 2,
          menuItemFactory: ClearSelectionAllMenuItemFactory
        }
      }
    },
    ["contextMenu.layout" /* LAYOUT */]: {
      order: 1,
      [CELL_INSERT_MENU_ID]: {
        order: 0,
        menuItemFactory: CellInsertMenuItemFactory,
        [InsertRowBeforeCommand.id]: {
          order: 0,
          menuItemFactory: InsertRowBeforeCellMenuItemFactory
        },
        [InsertColBeforeCommand.id]: {
          order: 1,
          menuItemFactory: InsertColLeftCellMenuItemFactory
        },
        [InsertRangeMoveRightConfirmCommand.id]: {
          order: 2,
          menuItemFactory: InsertRangeMoveRightMenuItemFactory
        },
        [InsertRangeMoveDownConfirmCommand.id]: {
          order: 3,
          menuItemFactory: InsertRangeMoveDownMenuItemFactory
        }
      },
      [DELETE_RANGE_MENU_ID]: {
        order: 0,
        menuItemFactory: DeleteRangeMenuItemFactory,
        [RemoveColConfirmCommand.id]: {
          order: 0,
          menuItemFactory: RemoveColMenuItemFactory
        },
        [RemoveRowConfirmCommand.id]: {
          order: 1,
          menuItemFactory: RemoveRowMenuItemFactory
        },
        [DeleteRangeMoveLeftConfirmCommand.id]: {
          order: 2,
          menuItemFactory: DeleteRangeMoveLeftMenuItemFactory
        },
        [DeleteRangeMoveUpConfirmCommand.id]: {
          order: 3,
          menuItemFactory: DeleteRangeMoveUpMenuItemFactory
        }
      },
      [SHEET_FROZEN_MENU_ID]: {
        order: 2,
        menuItemFactory: SheetFrozenMenuItemFactory,
        [SetSelectionFrozenCommand.id]: {
          order: 0,
          menuItemFactory: FrozenMenuItemFactory
        },
        [SetRowFrozenCommand.id]: {
          order: 1,
          menuItemFactory: FrozenRowMenuItemFactory
        },
        [SetColumnFrozenCommand.id]: {
          order: 2,
          menuItemFactory: FrozenColMenuItemFactory
        },
        [CancelFrozenCommand.id]: {
          order: 3,
          menuItemFactory: CancelFrozenMenuItemFactory
        }
      },
      [SHEET_PERMISSION_CONTEXT_MENU_ID]: {
        order: 3,
        menuItemFactory: sheetPermissionContextMenuFactory,
        [AddRangeProtectionFromContextMenuCommand.id]: {
          order: 0,
          menuItemFactory: sheetPermissionAddProtectContextMenuFactory
        },
        [SetRangeProtectionFromContextMenuCommand.id]: {
          order: 1,
          menuItemFactory: sheetPermissionEditProtectContextMenuFactory
        },
        [DeleteRangeProtectionFromContextMenuCommand.id]: {
          order: 2,
          menuItemFactory: sheetPermissionRemoveProtectContextMenuFactory
        },
        [ViewSheetPermissionFromContextMenuCommand.id]: {
          order: 3,
          menuItemFactory: sheetPermissionViewAllProtectRuleContextMenuFactory
        }
      }
    },
    ["contextMenu.data" /* DATA */]: {
      order: 2
    },
    ["contextMenu.others" /* OTHERS */]: {
      order: 3
    }
  },
  ["contextMenu.colHeader" /* COL_HEADER */]: {
    ["contextMenu.format" /* FORMAT */]: {
      [SheetCopyCommand.name]: {
        order: 0,
        menuItemFactory: CopyMenuItemFactory
      },
      // [SheetCutCommand.name]: {
      //     order: 1,
      //     menuItemFactory: CutMenuItemFactory,
      // },
      [SheetPasteCommand.name]: {
        order: 2,
        menuItemFactory: PasteMenuItemFactory
      },
      [PASTE_SPECIAL_MENU_ID]: {
        order: 3,
        menuItemFactory: PasteSpacialMenuItemFactory,
        [SheetPasteValueCommand.id]: {
          order: 0,
          menuItemFactory: PasteValueMenuItemFactory
        },
        [SheetPasteFormatCommand.id]: {
          order: 1,
          menuItemFactory: PasteFormatMenuItemFactory
        },
        [SheetPasteColWidthCommand.id]: {
          order: 2,
          menuItemFactory: PasteColWidthMenuItemFactory
        },
        [SheetPasteBesidesBorderCommand.id]: {
          order: 3,
          menuItemFactory: PasteBesidesBorderMenuItemFactory
        }
      },
      [CLEAR_SELECTION_MENU_ID]: {
        order: 4,
        menuItemFactory: ClearSelectionMenuItemFactory,
        [ClearSelectionContentCommand.id]: {
          order: 0,
          menuItemFactory: ClearSelectionContentMenuItemFactory
        },
        [ClearSelectionFormatCommand.id]: {
          order: 1,
          menuItemFactory: ClearSelectionFormatMenuItemFactory
        },
        [ClearSelectionAllCommand.id]: {
          order: 2,
          menuItemFactory: ClearSelectionAllMenuItemFactory
        }
      }
    },
    ["contextMenu.layout" /* LAYOUT */]: {
      order: 1,
      [InsertMultiColsLeftCommand.id]: {
        order: 0,
        menuItemFactory: InsertMultiColsLeftHeaderMenuItemFactory
      },
      [InsertMultiColsRightCommand.id]: {
        order: 0,
        menuItemFactory: InsertMultiColsRightHeaderMenuItemFactory
      },
      [HideColConfirmCommand.id]: {
        order: 1,
        menuItemFactory: HideColMenuItemFactory
      },
      [SetSelectedColsVisibleCommand.id]: {
        order: 2,
        menuItemFactory: ShowColMenuItemFactory
      },
      [RemoveColConfirmCommand.id]: {
        order: 2,
        menuItemFactory: RemoveColMenuItemFactory
      },
      [SetColWidthCommand.id]: {
        order: 3,
        menuItemFactory: SetColWidthMenuItemFactory
      },
      [SetWorksheetColAutoWidthCommand.id]: {
        order: 4,
        menuItemFactory: ColAutoWidthMenuItemFactory
      },
      [SHEET_FROZEN_HEADER_MENU_ID]: {
        order: 5,
        menuItemFactory: SheetFrozenHeaderMenuItemFactory,
        [SetSelectionFrozenCommand.id]: {
          order: 0,
          menuItemFactory: FrozenMenuItemFactory
        },
        [CancelFrozenCommand.id]: {
          order: 3,
          menuItemFactory: CancelFrozenMenuItemFactory
        }
      },
      [SHEET_PERMISSION_CONTEXT_MENU_ID]: {
        order: 6,
        menuItemFactory: sheetPermissionContextMenuFactory,
        [AddRangeProtectionFromContextMenuCommand.id]: {
          order: 0,
          menuItemFactory: sheetPermissionAddProtectContextMenuFactory
        },
        [SetRangeProtectionFromContextMenuCommand.id]: {
          order: 1,
          menuItemFactory: sheetPermissionEditProtectContextMenuFactory
        },
        [DeleteRangeProtectionFromContextMenuCommand.id]: {
          order: 2,
          menuItemFactory: sheetPermissionRemoveProtectContextMenuFactory
        },
        [ViewSheetPermissionFromContextMenuCommand.id]: {
          order: 3,
          menuItemFactory: sheetPermissionViewAllProtectRuleContextMenuFactory
        }
      }
    },
    ["contextMenu.data" /* DATA */]: {
      order: 2
    },
    ["contextMenu.others" /* OTHERS */]: {
      order: 3
    }
  },
  ["contextMenu.rowHeader" /* ROW_HEADER */]: {
    ["contextMenu.format" /* FORMAT */]: {
      [SheetCopyCommand.name]: {
        order: 0,
        menuItemFactory: CopyMenuItemFactory
      },
      // [SheetCutCommand.name]: {
      //     order: 1,
      //     menuItemFactory: CutMenuItemFactory,
      // },
      [SheetPasteCommand.name]: {
        order: 2,
        menuItemFactory: PasteMenuItemFactory
      },
      [PASTE_SPECIAL_MENU_ID]: {
        order: 3,
        menuItemFactory: PasteSpacialMenuItemFactory,
        [SheetPasteValueCommand.id]: {
          order: 0,
          menuItemFactory: PasteValueMenuItemFactory
        },
        [SheetPasteFormatCommand.id]: {
          order: 1,
          menuItemFactory: PasteFormatMenuItemFactory
        },
        [SheetPasteColWidthCommand.id]: {
          order: 2,
          menuItemFactory: PasteColWidthMenuItemFactory
        },
        [SheetPasteBesidesBorderCommand.id]: {
          order: 3,
          menuItemFactory: PasteBesidesBorderMenuItemFactory
        }
      },
      [CLEAR_SELECTION_MENU_ID]: {
        order: 4,
        menuItemFactory: ClearSelectionMenuItemFactory,
        [ClearSelectionContentCommand.id]: {
          order: 0,
          menuItemFactory: ClearSelectionContentMenuItemFactory
        },
        [ClearSelectionFormatCommand.id]: {
          order: 1,
          menuItemFactory: ClearSelectionFormatMenuItemFactory
        },
        [ClearSelectionAllCommand.id]: {
          order: 2,
          menuItemFactory: ClearSelectionAllMenuItemFactory
        }
      }
    },
    ["contextMenu.layout" /* LAYOUT */]: {
      order: 1,
      [InsertMultiRowsAboveCommand.id]: {
        order: 0,
        menuItemFactory: InsertMultiRowsAboveHeaderMenuItemFactory
      },
      [InsertMultiRowsAfterCommand.id]: {
        order: 1,
        menuItemFactory: InsertMultiRowsAfterHeaderMenuItemFactory
      },
      [RemoveRowConfirmCommand.id]: {
        order: 1,
        menuItemFactory: RemoveRowMenuItemFactory
      },
      [HideRowConfirmCommand.id]: {
        order: 2,
        menuItemFactory: HideRowMenuItemFactory
      },
      [SetSelectedRowsVisibleCommand.id]: {
        order: 2,
        menuItemFactory: ShowRowMenuItemFactory
      },
      [SetRowHeightCommand.id]: {
        order: 3,
        menuItemFactory: SetRowHeightMenuItemFactory
      },
      [SetWorksheetRowIsAutoHeightCommand.id]: {
        order: 4,
        menuItemFactory: FitContentMenuItemFactory
      },
      [SHEET_FROZEN_HEADER_MENU_ID]: {
        order: 5,
        menuItemFactory: SheetFrozenHeaderMenuItemFactory,
        [SetSelectionFrozenCommand.id]: {
          order: 0,
          menuItemFactory: FrozenMenuItemFactory
        },
        [CancelFrozenCommand.id]: {
          order: 3,
          menuItemFactory: CancelFrozenMenuItemFactory
        }
      },
      [SHEET_PERMISSION_CONTEXT_MENU_ID]: {
        order: 6,
        menuItemFactory: sheetPermissionContextMenuFactory,
        [AddRangeProtectionFromContextMenuCommand.id]: {
          order: 0,
          menuItemFactory: sheetPermissionAddProtectContextMenuFactory
        },
        [SetRangeProtectionFromContextMenuCommand.id]: {
          order: 1,
          menuItemFactory: sheetPermissionEditProtectContextMenuFactory
        },
        [DeleteRangeProtectionFromContextMenuCommand.id]: {
          order: 2,
          menuItemFactory: sheetPermissionRemoveProtectContextMenuFactory
        },
        [ViewSheetPermissionFromContextMenuCommand.id]: {
          order: 3,
          menuItemFactory: sheetPermissionViewAllProtectRuleContextMenuFactory
        }
      }
    },
    ["contextMenu.data" /* DATA */]: {
      order: 2
    },
    ["contextMenu.others" /* OTHERS */]: {
      order: 3
    }
  },
  ["contextMenu.footerTabs" /* FOOTER_TABS */]: {
    ["contextMenu.others" /* OTHERS */]: {
      order: 0,
      [RemoveSheetConfirmCommand.id]: {
        order: 0,
        menuItemFactory: DeleteSheetMenuItemFactory
      },
      [CopySheetCommand.id]: {
        order: 1,
        menuItemFactory: CopySheetMenuItemFactory
      },
      [RenameSheetOperation.id]: {
        order: 2,
        menuItemFactory: RenameSheetMenuItemFactory
      },
      [SetTabColorCommand.id]: {
        order: 3,
        menuItemFactory: ChangeColorSheetMenuItemFactory
      },
      [SetWorksheetHideCommand.id]: {
        order: 4,
        menuItemFactory: HideSheetMenuItemFactory
      },
      // [SetWorksheetShowCommand.id]: {
      //     order: 5,
      //     menuItemFactory: UnHideSheetMenuItemFactory,
      // },
      [ShowMenuListCommand.id]: {
        order: 6,
        menuItemFactory: ShowMenuItemFactory
      },
      [AddRangeProtectionFromSheetBarCommand.id]: {
        order: 7,
        menuItemFactory: sheetPermissionProtectSheetInSheetBarMenuFactory
      },
      [DeleteWorksheetProtectionFormSheetBarCommand.id]: {
        order: 8,
        menuItemFactory: sheetPermissionRemoveProtectionSheetBarMenuFactory
      },
      [ChangeSheetProtectionFromSheetBarCommand.id]: {
        order: 9,
        menuItemFactory: sheetPermissionChangeSheetPermissionSheetBarMenuFactory
      },
      [ViewSheetPermissionFromSheetBarCommand.id]: {
        order: 10,
        menuItemFactory: sheetPermissionViewAllProtectRuleSheetBarMenuFactory
      }
    }
  },
  ["contextMenu.footerMenu" /* FOOTER_MENU */]: {
    ["contextMenu.others" /* OTHERS */]: {
      [ToggleGridlinesCommand.id]: {
        order: 1,
        menuItemFactory: ToggleGridlinesMenuFactory
      }
    }
  }
};

// ../packages/sheets-ui/src/controllers/shortcuts/editor.shortcut.ts
var ARROW_SELECTION_KEYCODE_LIST = [
  40 /* ARROW_DOWN */,
  38 /* ARROW_UP */,
  37 /* ARROW_LEFT */,
  39 /* ARROW_RIGHT */
];
var MOVE_SELECTION_KEYCODE_LIST = [13 /* ENTER */, 9 /* TAB */, ...ARROW_SELECTION_KEYCODE_LIST];
function generateArrowSelectionShortCutItem() {
  const shortcutList = [];
  for (const keycode of ARROW_SELECTION_KEYCODE_LIST) {
    shortcutList.push({
      id: SetCellEditVisibleArrowOperation.id,
      binding: keycode,
      preconditions: (contextService) => whenEditorDidNotInputFormulaActivated(contextService),
      staticParameters: {
        visible: false,
        eventType: 4 /* Keyboard */,
        keycode,
        isShift: false
      }
    });
    shortcutList.push({
      id: SetCellEditVisibleArrowOperation.id,
      binding: keycode | 1024 /* SHIFT */,
      preconditions: (contextService) => whenEditorDidNotInputFormulaActivated(contextService),
      staticParameters: {
        visible: false,
        eventType: 4 /* Keyboard */,
        keycode,
        isShift: true
      }
    });
  }
  return shortcutList;
}
var StartEditWithF2Shortcut = {
  id: SetCellEditVisibleWithF2Operation.id,
  binding: 113 /* F2 */,
  description: "shortcut.sheet.start-editing",
  group: "4_sheet-edit",
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    visible: true,
    eventType: 4 /* Keyboard */,
    keycode: 113 /* F2 */
  }
};
var EditorCursorEnterShortcut = {
  id: SetCellEditVisibleOperation.id,
  binding: 13 /* ENTER */,
  description: "shortcut.sheet.toggle-editing",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenEditorDidNotInputFormulaActivated(contextService),
  staticParameters: {
    visible: false,
    eventType: 4 /* Keyboard */,
    keycode: 13 /* ENTER */
  }
};
var EditorCursorTabShortcut = {
  id: SetCellEditVisibleOperation.id,
  binding: 9 /* TAB */,
  preconditions: (contextService) => whenEditorDidNotInputFormulaActivated(contextService),
  staticParameters: {
    visible: false,
    eventType: 4 /* Keyboard */,
    keycode: 9 /* TAB */
  }
};
var EditorCursorEscShortcut = {
  id: SetCellEditVisibleOperation.id,
  binding: 27 /* ESC */,
  description: "shortcut.sheet.abort-editing",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenEditorDidNotInputFormulaActivated(contextService),
  staticParameters: {
    visible: false,
    eventType: 4 /* Keyboard */,
    keycode: 27 /* ESC */
  }
};
var EditorBreakLineShortcut = {
  id: BreakLineCommand.id,
  description: "shortcut.sheet.break-line",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenSheetEditorActivated(contextService),
  binding: 13 /* ENTER */ | 2048 /* ALT */
};
var EditorDeleteLeftShortcut = {
  id: DeleteLeftCommand.id,
  preconditions: (contextService) => whenEditorActivated(contextService) || whenFormulaEditorFocused(contextService),
  binding: 8 /* BACKSPACE */
};
var EditorDeleteLeftShortcutInActive = {
  id: SetCellEditVisibleOperation.id,
  description: "shortcut.sheet.delete-and-start-editing",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenSheetEditorFocused(contextService) && !whenFormulaEditorFocused(contextService),
  binding: 8 /* BACKSPACE */,
  staticParameters: {
    visible: true,
    eventType: 4 /* Keyboard */,
    keycode: 8 /* BACKSPACE */
  }
};

// ../packages/sheets-ui/src/controllers/shortcuts/operation.shortcut.ts
var SetRowHiddenShortcutItem = {
  id: SetRowHiddenCommand.id,
  // when focusing on any other input tag do not trigger this shortcut
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  binding: 57 /* Digit9 */ | 4096 /* CTRL_COMMAND */
};
var SetColHiddenShortcutItem = {
  id: SetColHiddenCommand.id,
  // when focusing on any other input tag do not trigger this shortcut
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  binding: 48 /* Digit0 */ | 4096 /* CTRL_COMMAND */ | 1024 /* SHIFT */
};

// ../packages/sheets-ui/src/controllers/shortcuts/selection.shortcut.ts
var MoveSelectionDownShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-below-cell",
  group: "3_sheet-view",
  binding: 40 /* ARROW_DOWN */,
  priority: 100,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 2 /* DOWN */
  }
};
var MoveSelectionUpShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-up-cell",
  group: "3_sheet-view",
  binding: 38 /* ARROW_UP */,
  priority: 100,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 0 /* UP */
  }
};
var MoveSelectionLeftShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-left-cell",
  group: "3_sheet-view",
  binding: 37 /* ARROW_LEFT */,
  priority: 100,
  preconditions: whenSheetEditorFocusedAndFxNotFocused,
  staticParameters: {
    direction: 3 /* LEFT */
  }
};
var MoveSelectionRightShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-right-cell",
  group: "3_sheet-view",
  binding: 39 /* ARROW_RIGHT */,
  priority: 100,
  preconditions: whenSheetEditorFocusedAndFxNotFocused,
  staticParameters: {
    direction: 1 /* RIGHT */
  }
};
var MoveSelectionTabShortcutItem = {
  id: MoveSelectionEnterAndTabCommand.id,
  description: "shortcut.sheet.select-next-cell",
  group: "3_sheet-view",
  binding: 9 /* TAB */,
  priority: 100,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 1 /* RIGHT */,
    keycode: 9 /* TAB */
  }
};
var MoveSelectionTabLeftShortcutItem = {
  id: MoveSelectionEnterAndTabCommand.id,
  description: "shortcut.sheet.select-previous-cell",
  group: "3_sheet-view",
  binding: 9 /* TAB */ | 1024 /* SHIFT */,
  priority: 100,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 3 /* LEFT */,
    keycode: 9 /* TAB */
  }
};
var MoveSelectionEnterShortcutItem = {
  id: MoveSelectionEnterAndTabCommand.id,
  description: "shortcut.sheet.select-below-cell",
  group: "3_sheet-view",
  binding: 13 /* ENTER */,
  priority: 100,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 2 /* DOWN */,
    keycode: 13 /* ENTER */
  }
};
var MoveSelectionEnterUpShortcutItem = {
  id: MoveSelectionEnterAndTabCommand.id,
  description: "shortcut.sheet.select-up-cell",
  group: "3_sheet-view",
  binding: 13 /* ENTER */ | 1024 /* SHIFT */,
  priority: 100,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 0 /* UP */,
    keycode: 13 /* ENTER */
  }
};
var MoveSelectionEndDownShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-below-value-cell",
  group: "3_sheet-view",
  binding: 40 /* ARROW_DOWN */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 2 /* DOWN */,
    jumpOver: 1 /* moveGap */
  }
};
var MoveSelectionEndUpShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-up-value-cell",
  group: "3_sheet-view",
  binding: 38 /* ARROW_UP */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 0 /* UP */,
    jumpOver: 1 /* moveGap */
  }
};
var MoveSelectionEndLeftShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-left-value-cell",
  group: "3_sheet-view",
  binding: 37 /* ARROW_LEFT */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 3 /* LEFT */,
    jumpOver: 1 /* moveGap */
  }
};
var MoveSelectionEndRightShortcutItem = {
  id: MoveSelectionCommand.id,
  description: "shortcut.sheet.select-right-value-cell",
  group: "3_sheet-view",
  binding: 39 /* ARROW_RIGHT */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 1 /* RIGHT */,
    jumpOver: 1 /* moveGap */
  }
};
var ExpandSelectionDownShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-down",
  group: "3_sheet-view",
  binding: 40 /* ARROW_DOWN */ | 1024 /* SHIFT */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 2 /* DOWN */
  }
};
var ExpandSelectionUpShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-up",
  group: "3_sheet-view",
  binding: 38 /* ARROW_UP */ | 1024 /* SHIFT */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 0 /* UP */
  }
};
var ExpandSelectionLeftShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-left",
  group: "3_sheet-view",
  binding: 37 /* ARROW_LEFT */ | 1024 /* SHIFT */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 3 /* LEFT */
  }
};
var ExpandSelectionRightShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-right",
  group: "3_sheet-view",
  binding: 39 /* ARROW_RIGHT */ | 1024 /* SHIFT */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 1 /* RIGHT */
  }
};
var ExpandSelectionEndDownShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-to-below-gap",
  group: "3_sheet-view",
  binding: 40 /* ARROW_DOWN */ | 1024 /* SHIFT */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 2 /* DOWN */,
    jumpOver: 1 /* moveGap */
  }
};
var ExpandSelectionEndUpShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-to-up-gap",
  group: "3_sheet-view",
  binding: 38 /* ARROW_UP */ | 1024 /* SHIFT */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 0 /* UP */,
    jumpOver: 1 /* moveGap */
  }
};
var ExpandSelectionEndLeftShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-to-left-gap",
  group: "3_sheet-view",
  binding: 37 /* ARROW_LEFT */ | 1024 /* SHIFT */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 3 /* LEFT */,
    jumpOver: 1 /* moveGap */
  }
};
var ExpandSelectionEndRightShortcutItem = {
  id: ExpandSelectionCommand.id,
  description: "shortcut.sheet.expand-selection-to-right-gap",
  group: "3_sheet-view",
  binding: 39 /* ARROW_RIGHT */ | 1024 /* SHIFT */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    direction: 1 /* RIGHT */,
    jumpOver: 1 /* moveGap */
  }
};
var SelectAllShortcutItem = {
  id: SelectAllCommand.id,
  description: "shortcut.sheet.select-all",
  group: "3_sheet-view",
  binding: 65 /* A */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  staticParameters: {
    expandToGapFirst: true,
    loop: true
  }
};

// ../packages/sheets-ui/src/controllers/shortcuts/style.shortcut.ts
var SetBoldShortcutItem = {
  id: SetRangeBoldCommand.id,
  description: "shortcut.sheet.set-bold",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  binding: 66 /* B */ | 4096 /* CTRL_COMMAND */
};
var SetItalicShortcutItem = {
  id: SetRangeItalicCommand.id,
  description: "shortcut.sheet.set-italic",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  binding: 73 /* I */ | 4096 /* CTRL_COMMAND */
};
var SetUnderlineShortcutItem = {
  id: SetRangeUnderlineCommand.id,
  description: "shortcut.sheet.set-underline",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  binding: 85 /* U */ | 4096 /* CTRL_COMMAND */
};
var SetStrikeThroughShortcutItem = {
  id: SetRangeStrickThroughCommand.id,
  description: "shortcut.sheet.set-strike-through",
  group: "4_sheet-edit",
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  binding: 88 /* X */ | 1024 /* SHIFT */ | 4096 /* CTRL_COMMAND */
};

// ../packages/sheets-ui/src/controllers/shortcuts/value.shortcut.ts
var ClearSelectionValueShortcutItem = {
  id: ClearSelectionContentCommand.id,
  // when focusing on any other input tag do not trigger this shortcut
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  binding: 46 /* DELETE */,
  mac: 8 /* BACKSPACE */
};
var ClearSelectionValueShortcutItemMac = {
  id: ClearSelectionContentCommand.id,
  // when focusing on any other input tag do not trigger this shortcut
  preconditions: (contextService) => whenSheetEditorFocused(contextService),
  mac: 46 /* DELETE */
};

// ../packages/sheets-ui/src/controllers/shortcuts/view.shortcut.ts
var ZoomInShortcutItem = {
  id: ChangeZoomRatioCommand.id,
  description: "shortcut.sheet.zoom-in",
  binding: 187 /* EQUAL */ | 4096 /* CTRL_COMMAND */,
  group: "3_sheet-view",
  preconditions: whenSheetEditorFocused,
  priority: 1,
  staticParameters: {
    delta: 0.2
  }
};
var PreventDefaultZoomInShortcutItem = {
  id: NilCommand.id,
  binding: 187 /* EQUAL */ | 4096 /* CTRL_COMMAND */
};
var ZoomOutShortcutItem = {
  id: ChangeZoomRatioCommand.id,
  description: "shortcut.sheet.zoom-out",
  binding: 189 /* MINUS */ | 4096 /* CTRL_COMMAND */,
  group: "3_sheet-view",
  preconditions: whenSheetEditorFocused,
  priority: 1,
  staticParameters: {
    delta: -0.2
  }
};
var PreventDefaultZoomOutShortcutItem = {
  id: NilCommand.id,
  binding: 189 /* MINUS */ | 4096 /* CTRL_COMMAND */
};
var ResetZoomShortcutItem = {
  id: ChangeZoomRatioCommand.id,
  description: "shortcut.sheet.reset-zoom",
  binding: 48 /* Digit0 */ | 4096 /* CTRL_COMMAND */,
  preconditions: whenSheetEditorFocused,
  group: "3_sheet-view",
  priority: 1,
  staticParameters: {
    reset: true
  }
};
var PreventDefaultResetZoomShortcutItem = {
  id: NilCommand.id,
  binding: 48 /* Digit0 */ | 4096 /* CTRL_COMMAND */
};

// ../packages/sheets-ui/src/controllers/sheet-ui.controller.ts
var SheetUIController = class extends Disposable {
  constructor(_injector, _componentManager, _layoutService, _commandService, _shortcutService, _menuManagerService, _uiPartsService, _configService) {
    super();
    this._injector = _injector;
    this._componentManager = _componentManager;
    this._layoutService = _layoutService;
    this._commandService = _commandService;
    this._shortcutService = _shortcutService;
    this._menuManagerService = _menuManagerService;
    this._uiPartsService = _uiPartsService;
    this._configService = _configService;
    this._init();
  }
  _init() {
    this._initComponents();
    this._initCommands();
    this._initMenus();
    this._initShortcuts();
    this._initWorkbenchParts();
    this._initFocusHandler();
  }
  _initComponents() {
    const componentManager = this._componentManager;
    this.disposeWithMe(componentManager.register(MENU_ITEM_INPUT_COMPONENT, MenuItemInput));
    this.disposeWithMe(componentManager.register(BORDER_PANEL_COMPONENT, BorderPanel));
    this.disposeWithMe(componentManager.register(COLOR_PICKER_COMPONENT, ColorPicker));
    this.disposeWithMe(componentManager.register(FONT_FAMILY_COMPONENT, FontFamily));
    this.disposeWithMe(componentManager.register(FONT_FAMILY_ITEM_COMPONENT, FontFamilyItem));
    this.disposeWithMe(componentManager.register(FONT_SIZE_COMPONENT, FontSize));
    this.disposeWithMe(componentManager.register(DEFINED_NAME_CONTAINER, DefinedNameContainer));
    this.disposeWithMe(componentManager.register("HideGridlines", hide_gridlines_default));
  }
  _initCommands() {
    [
      AddWorksheetMergeAllCommand2,
      AddWorksheetMergeCommand2,
      AddWorksheetMergeHorizontalCommand2,
      AddWorksheetMergeVerticalCommand2,
      ChangeZoomRatioCommand,
      ExpandSelectionCommand,
      MoveSelectionCommand,
      MoveSelectionEnterAndTabCommand,
      RenameSheetOperation,
      RemoveSheetConfirmCommand,
      RemoveRowConfirmCommand,
      RemoveColConfirmCommand,
      HideRowConfirmCommand,
      HideColConfirmCommand,
      ScrollCommand,
      ScrollToCellCommand,
      SelectAllCommand,
      SetActivateCellEditOperation,
      SetBoldCommand,
      SetCellEditVisibleArrowOperation,
      SetCellEditVisibleOperation,
      SetCellEditVisibleWithF2Operation,
      SetRangeBoldCommand,
      SetRangeItalicCommand,
      SetRangeUnderlineCommand,
      SetRangeStrickThroughCommand,
      SetRangeSubscriptCommand,
      SetRangeSuperscriptCommand,
      SetRangeFontSizeCommand,
      SetRangeFontFamilyCommand,
      SetRangeTextColorCommand,
      ResetRangeTextColorCommand,
      SetItalicCommand,
      SetStrikeThroughCommand,
      SetFontFamilyCommand,
      SetFontSizeCommand,
      SetFormatPainterOperation,
      SetInfiniteFormatPainterCommand,
      SetOnceFormatPainterCommand,
      ApplyFormatPainterCommand,
      SetScrollOperation,
      SetScrollRelativeCommand,
      SetSelectionFrozenCommand,
      SetRowFrozenCommand,
      SetColumnFrozenCommand,
      ScrollToRangeOperation,
      SetUnderlineCommand,
      SetZoomRatioCommand,
      SetZoomRatioOperation,
      ShowMenuListCommand,
      RefillCommand,
      InsertRangeMoveDownConfirmCommand,
      DeleteRangeMoveUpConfirmCommand,
      InsertRangeMoveRightConfirmCommand,
      DeleteRangeMoveLeftConfirmCommand,
      SidebarDefinedNameOperation,
      AutoFillCommand,
      AutoClearContentCommand,
      // permission
      SheetPermissionOpenPanelOperation,
      SheetPermissionOpenDialogOperation,
      AddRangeProtectionFromToolbarCommand,
      AddRangeProtectionFromContextMenuCommand,
      ViewSheetPermissionFromContextMenuCommand,
      AddRangeProtectionFromSheetBarCommand,
      ViewSheetPermissionFromSheetBarCommand,
      ChangeSheetProtectionFromSheetBarCommand,
      DeleteRangeProtectionFromContextMenuCommand,
      SetRangeProtectionFromContextMenuCommand,
      DeleteWorksheetProtectionFormSheetBarCommand,
      SetWorksheetColAutoWidthCommand,
      SetRowHeaderWidthCommand,
      SetColumnHeaderHeightCommand
    ].forEach((c) => {
      this.disposeWithMe(this._commandService.registerCommand(c));
    });
  }
  _initMenus() {
    this._menuManagerService.mergeMenu(menuSchema);
  }
  _initShortcuts() {
    [
      // selection shortcuts
      MoveSelectionDownShortcutItem,
      MoveSelectionUpShortcutItem,
      MoveSelectionLeftShortcutItem,
      MoveSelectionRightShortcutItem,
      MoveSelectionTabShortcutItem,
      MoveSelectionTabLeftShortcutItem,
      MoveSelectionEnterShortcutItem,
      MoveSelectionEnterUpShortcutItem,
      // MoveBackSelectionShortcutItem,
      MoveSelectionEndDownShortcutItem,
      MoveSelectionEndUpShortcutItem,
      MoveSelectionEndLeftShortcutItem,
      MoveSelectionEndRightShortcutItem,
      ExpandSelectionDownShortcutItem,
      ExpandSelectionUpShortcutItem,
      ExpandSelectionLeftShortcutItem,
      ExpandSelectionRightShortcutItem,
      ExpandSelectionEndDownShortcutItem,
      ExpandSelectionEndUpShortcutItem,
      ExpandSelectionEndLeftShortcutItem,
      ExpandSelectionEndRightShortcutItem,
      SelectAllShortcutItem,
      // view shortcuts
      ZoomInShortcutItem,
      ZoomOutShortcutItem,
      ResetZoomShortcutItem,
      PreventDefaultResetZoomShortcutItem,
      PreventDefaultZoomInShortcutItem,
      PreventDefaultZoomOutShortcutItem,
      // toggle cell style shortcuts
      SetBoldShortcutItem,
      SetItalicShortcutItem,
      SetUnderlineShortcutItem,
      SetStrikeThroughShortcutItem,
      // cell content editing shortcuts
      ClearSelectionValueShortcutItem,
      ClearSelectionValueShortcutItemMac,
      ...generateArrowSelectionShortCutItem(),
      EditorCursorEnterShortcut,
      StartEditWithF2Shortcut,
      EditorCursorTabShortcut,
      EditorBreakLineShortcut,
      EditorDeleteLeftShortcut,
      EditorDeleteLeftShortcutInActive,
      EditorCursorEscShortcut,
      // operation shortcuts
      SetRowHiddenShortcutItem,
      SetColHiddenShortcutItem
    ].forEach((item) => {
      this.disposeWithMe(this._shortcutService.registerShortcut(item));
    });
  }
  _initWorkbenchParts() {
    const uiController = this._uiPartsService;
    const injector = this._injector;
    const config = this._configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY);
    if ((config == null ? void 0 : config.formulaBar) !== false) {
      this.disposeWithMe(uiController.registerComponent("header" /* HEADER */, () => connectInjector(RenderSheetHeader, injector)));
    }
    this.disposeWithMe(uiController.registerComponent("footer" /* FOOTER */, () => connectInjector(RenderSheetFooter, injector)));
    this.disposeWithMe(uiController.registerComponent("content" /* CONTENT */, () => connectInjector(RenderSheetContent, injector)));
  }
  _initFocusHandler() {
    this.disposeWithMe(
      this._layoutService.registerFocusHandler(O.UNIVER_SHEET, (_unitId) => {
        const renderManagerService = this._injector.get(IRenderManagerService);
        const instanceService = this._injector.get(IUniverInstanceService);
        const currentEditorRender = getCurrentTypeOfRenderer(O.UNIVER_DOC, instanceService, renderManagerService);
        const docSelectionRenderService = currentEditorRender == null ? void 0 : currentEditorRender.with(DocSelectionRenderService);
        docSelectionRenderService == null ? void 0 : docSelectionRenderService.focus();
      })
    );
  }
};
SheetUIController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, Inject(ComponentManager)),
  __decorateParam(2, ILayoutService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, IShortcutService),
  __decorateParam(5, IMenuManagerService),
  __decorateParam(6, IUIPartsService),
  __decorateParam(7, IConfigService)
], SheetUIController);

// ../packages/sheets-ui/src/controllers/active-worksheet/active-worksheet.controller.ts
var ActiveWorksheetController = class extends Disposable {
  constructor(_commandService, _univerInstanceService) {
    super();
    this._commandService = _commandService;
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_previousSheetIndex", -1);
    this.disposeWithMe(this._commandService.beforeCommandExecuted((command) => {
      if (command.id === RemoveSheetMutation.id) {
        return this._beforeAdjustActiveSheetOnRemoveSheet(
          command
        );
      }
    }));
    this.disposeWithMe(this._commandService.onCommandExecuted((command, options) => {
      if (command.id === RemoveSheetMutation.id) {
        return this._adjustActiveSheetOnRemoveSheet(command);
      }
      if (command.id === SetWorksheetHideMutation.id && command.params.hidden) {
        return this._adjustActiveSheetOnHideSheet(command);
      }
      if (options == null ? void 0 : options.fromCollab) return false;
      if (command.id === InsertSheetMutation.id) {
        return this._adjustActiveSheetOnInsertSheet(command);
      }
      if (command.id === SetWorksheetHideMutation.id && !command.params.hidden) {
        return this._adjustActiveSheetOnShowSheet(command);
      }
      if (command.id === SetSelectionsOperation.id) {
        return this._adjustActiveSheetOnSelection(command);
      }
    }));
  }
  _adjustActiveSheetOnHideSheet(mutation) {
    var _a;
    const { unitId, subUnitId } = mutation.params;
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return;
    }
    const activeSheet = (_a = workbook.getActiveSheet()) == null ? void 0 : _a.getSheetId();
    if (activeSheet !== subUnitId) {
      return;
    }
    const activeIndex = workbook.getActiveSheetIndex();
    const nextId = findTheNextUnhiddenSheet(workbook, activeIndex);
    this._switchToNextSheet(unitId, nextId);
  }
  _beforeAdjustActiveSheetOnRemoveSheet(mutation) {
    const { unitId, subUnitId } = mutation.params;
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return;
    }
    const worksheet = workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return;
    }
    this._previousSheetIndex = workbook.getSheetIndex(worksheet);
  }
  _adjustActiveSheetOnRemoveSheet(mutation) {
    if (this._previousSheetIndex === -1) {
      return;
    }
    const { unitId } = mutation.params;
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return;
    }
    const activeSheet = workbook.getActiveSheet();
    if (activeSheet.getSheetId() === mutation.params.subUnitId) {
      const previousIndex = this._previousSheetIndex;
      const nextIndex = previousIndex >= 1 ? previousIndex - 1 : 0;
      const nextId = findTheNextUnhiddenSheet(workbook, nextIndex);
      this._switchToNextSheet(unitId, nextId);
    }
  }
  _adjustActiveSheetOnInsertSheet(mutation) {
    const { unitId, sheet } = mutation.params;
    this._switchToNextSheet(unitId, sheet.id);
  }
  _adjustActiveSheetOnShowSheet(mutation) {
    const { unitId, subUnitId } = mutation.params;
    this._switchToNextSheet(unitId, subUnitId);
  }
  _adjustActiveSheetOnSelection(operation) {
    var _a;
    const { unitId, subUnitId } = operation.params;
    if (subUnitId !== ((_a = this._univerInstanceService.getUnit(unitId)) == null ? void 0 : _a.getActiveSheet().getSheetId())) {
      this._switchToNextSheet(unitId, subUnitId);
    }
  }
  _switchToNextSheet(unitId, subUnitId) {
    this._commandService.executeCommand(SetWorksheetActiveOperation.id, {
      unitId,
      subUnitId
    });
  }
};
ActiveWorksheetController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IUniverInstanceService)
], ActiveWorksheetController);
function findTheNextUnhiddenSheet(workbook, startIndex) {
  const countOfSheets = workbook.getSheetSize();
  for (let i = startIndex; i > -1; i--) {
    const sheet = workbook.getSheetByIndex(i);
    if (!sheet.getConfig().hidden) {
      return sheet.getSheetId();
    }
  }
  for (let i = startIndex; i < countOfSheets; i++) {
    const sheet = workbook.getSheetByIndex(i);
    if (!sheet.getConfig().hidden) {
      return sheet.getSheetId();
    }
  }
  throw new Error(
    "[ActiveWorksheetController]: could not find the next unhidden sheet! Collaboration error perhaps."
  );
}

// ../packages/sheets-ui/src/services/canvas-pop-manager.service.ts
var SheetCanvasPopManagerService = class extends Disposable {
  constructor(_globalPopupManagerService, _renderManagerService, _univerInstanceService, _refRangeService, _commandService, _refSelectionsService, _selectionManagerService) {
    super();
    this._globalPopupManagerService = _globalPopupManagerService;
    this._renderManagerService = _renderManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._refRangeService = _refRangeService;
    this._commandService = _commandService;
    this._refSelectionsService = _refSelectionsService;
    this._selectionManagerService = _selectionManagerService;
    // the DrawingTypeEnum should refer from drawing package, here we just use type, so no need to import the drawing package
    __publicField(this, "_popupMenuFeatureMap", /* @__PURE__ */ new Map());
    __publicField(this, "_isSelectionMoving", false);
    this._initMoving();
  }
  _initMoving() {
    this.disposeWithMe(
      this._refSelectionsService.selectionMoving$.subscribe(() => {
        this._isSelectionMoving = true;
      })
    );
    this.disposeWithMe(
      this._refSelectionsService.selectionMoveEnd$.subscribe(() => {
        this._isSelectionMoving = false;
      })
    );
    this.disposeWithMe(
      this._selectionManagerService.selectionMoving$.subscribe(() => {
        this._isSelectionMoving = true;
      })
    );
    this.disposeWithMe(
      this._selectionManagerService.selectionMoveEnd$.subscribe(() => {
        this._isSelectionMoving = false;
      })
    );
  }
  /**
   * Register a feature menu callback for a specific drawing type.such as image, chart, etc.
   */
  registerFeatureMenu(type, getPopupMenuCallBack) {
    this._popupMenuFeatureMap.set(type, getPopupMenuCallBack);
  }
  /**
   * Get the feature menu by drawing type, the function should be called when a drawing element need trigger popup menu, so the unitId, subUnitId, drawingId should be provided.
   * @param {string} unitId the unit id
   * @param {string} subUnitId the sub unit id
   * @param {string} drawingId the drawing id
   * @param {DrawingTypeEnum} drawingType the feature type
   * @returns the feature menu if it exists, otherwise return undefined
   */
  getFeatureMenu(unitId, subUnitId, drawingId, drawingType) {
    const callback = this._popupMenuFeatureMap.get(drawingType);
    if (callback) {
      return callback(unitId, subUnitId, drawingId, drawingType);
    }
  }
  dispose() {
    super.dispose();
    this._popupMenuFeatureMap.clear();
  }
  _createHiddenRectObserver(params) {
    const { row, column, worksheet, skeleton, currentRender } = params;
    const calc = () => {
      var _a, _b;
      const freeze = worksheet.getFreeze();
      const { startRow: freezeStartRow, startColumn: freezeStartColumn, xSplit, ySplit } = freeze;
      const startRow = freezeStartRow - ySplit;
      const startColumn = freezeStartColumn - xSplit;
      const { rowHeightAccumulation, columnWidthAccumulation, rowHeaderWidth, columnHeaderHeight } = skeleton;
      const canvasFreezeWidth = rowHeaderWidth + (startColumn === -1 ? 0 : columnWidthAccumulation[startColumn + xSplit - 1] - ((_a = columnWidthAccumulation[startColumn - 1]) != null ? _a : 0));
      const canvasFreezeHeight = columnHeaderHeight + (startRow === -1 ? 0 : rowHeightAccumulation[startRow + ySplit - 1] - ((_b = rowHeightAccumulation[startRow]) != null ? _b : 0));
      const canvasElement = currentRender.engine.getCanvasElement();
      const canvasClientRect = canvasElement.getBoundingClientRect();
      const widthOfCanvas = pxToNum(canvasElement.style.width);
      const scaleAdjust = canvasClientRect.width / widthOfCanvas;
      const canvasScale = currentRender.scene.getAncestorScale().scaleX;
      const freezeWidth = canvasFreezeWidth * scaleAdjust * canvasScale;
      const freezeHeight = canvasFreezeHeight * scaleAdjust * canvasScale;
      const viewTopLeft = {
        left: -Infinity,
        top: -Infinity,
        right: canvasClientRect.left + freezeWidth,
        bottom: canvasClientRect.top + freezeHeight
      };
      const viewTopRight = {
        left: canvasClientRect.left + freezeWidth,
        top: -Infinity,
        right: Infinity,
        bottom: canvasClientRect.top + freezeHeight
      };
      const viewBottomLeft = {
        left: -Infinity,
        top: canvasClientRect.top + freezeHeight,
        right: canvasClientRect.left + freezeWidth,
        bottom: Infinity
      };
      const position = [];
      if (row < freezeStartRow) {
        position.push(viewTopLeft);
      }
      if (column < freezeStartColumn) {
        position.push(viewBottomLeft);
      }
      if (row < freezeStartRow && column < freezeStartColumn) {
        return [];
      } else if (row < freezeStartRow) {
        return [viewTopLeft];
      } else if (column < freezeStartColumn) {
        return [viewTopLeft];
      } else {
        return [viewTopLeft, viewTopRight, viewBottomLeft];
      }
    };
    const rects = calc();
    const rects$ = new BehaviorSubject(rects);
    const disposable = new DisposableCollection();
    disposable.add(this._commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetFrozenMutation.id) {
        const newRects = calc();
        rects$.next(newRects);
      }
    }));
    return {
      rects$,
      disposable
    };
  }
  // #region attach to object
  // Unlike _createCellPositionObserver, this bind to a certain position.
  _createPositionObserver(bound, currentRender, skeleton, worksheet) {
    const calc = () => {
      const { scene } = currentRender;
      const offsetBound = transformBound2OffsetBound(bound, scene, skeleton, worksheet);
      const canvasElement = currentRender.engine.getCanvasElement();
      const canvasClientRect = canvasElement.getBoundingClientRect();
      const widthOfCanvas = pxToNum(canvasElement.style.width);
      const scaleAdjust = canvasClientRect.width / widthOfCanvas;
      const position2 = {
        left: offsetBound.left * scaleAdjust + canvasClientRect.left,
        right: offsetBound.right * scaleAdjust + canvasClientRect.left,
        top: offsetBound.top * scaleAdjust + canvasClientRect.top,
        bottom: offsetBound.bottom * scaleAdjust + canvasClientRect.top
      };
      return position2;
    };
    const position = calc();
    const position$ = new BehaviorSubject(position);
    const disposable = new DisposableCollection();
    disposable.add(this._commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetScrollOperation.id || commandInfo.id === SetZoomRatioOperation.id) {
        position$.next(calc());
      }
    }));
    return {
      position,
      position$,
      disposable
    };
  }
  /**
   * attach a popup to canvas object
   * @param targetObject target canvas object
   * @param popup popup item
   * @returns disposable
   */
  attachPopupToObject(targetObject, popup) {
    var _a;
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    if (!worksheet || this._isSelectionMoving && !popup.showOnSelectionMoving) {
      return {
        dispose: () => {
        },
        canDispose: () => true
      };
    }
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    const skeleton = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(SheetSkeletonManagerService).ensureSkeleton(subUnitId);
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (!currentRender || !skeleton) {
      return {
        dispose: () => {
        },
        canDispose: () => true
      };
    }
    const { left, top, width, height } = targetObject;
    const bound = {
      left,
      right: left + width,
      top,
      bottom: top + height
    };
    const { position, position$, disposable } = this._createPositionObserver(bound, currentRender, skeleton, worksheet);
    const id = this._globalPopupManagerService.addPopup({
      ...popup,
      unitId,
      subUnitId,
      anchorRect: position,
      anchorRect$: position$,
      canvasElement: currentRender.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(id);
        position$.complete();
        disposable.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== id
    };
  }
  // #endregion
  // #region attach to position
  attachPopupByPosition(bound, popup, location) {
    var _a;
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      return null;
    }
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    if (unitId !== location.unitId || location.subUnitId !== subUnitId) {
      return null;
    }
    if (this._isSelectionMoving && !popup.showOnSelectionMoving) {
      return;
    }
    const skeleton = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(SheetSkeletonManagerService).getOrCreateSkeleton({
      sheetId: subUnitId
    });
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (!currentRender || !skeleton) {
      return null;
    }
    const { position, position$, disposable } = this._createPositionObserver(bound, currentRender, skeleton, worksheet);
    const { rects$, disposable: rectsObserverDisposable } = this._createHiddenRectObserver({
      row: location.row,
      column: location.col,
      worksheet,
      skeleton,
      currentRender
    });
    const id = this._globalPopupManagerService.addPopup({
      ...popup,
      unitId,
      subUnitId,
      anchorRect: position,
      anchorRect$: position$,
      hiddenRects$: rects$,
      canvasElement: currentRender.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(id);
        position$.complete();
        disposable.dispose();
        rectsObserverDisposable.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== id
    };
  }
  // #endregion
  // #region attach to absolute position
  attachPopupToAbsolutePosition(bound, popup, _unitId, _subUnitId) {
    var _a;
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      return null;
    }
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    if (_unitId && unitId !== _unitId || _subUnitId && _subUnitId !== subUnitId) {
      return null;
    }
    const skeleton = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(SheetSkeletonManagerService).ensureSkeleton(subUnitId);
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (!currentRender || !skeleton) {
      return null;
    }
    if (this._isSelectionMoving && !popup.showOnSelectionMoving) {
      return;
    }
    const position$ = new BehaviorSubject(bound);
    const id = this._globalPopupManagerService.addPopup({
      ...popup,
      unitId,
      subUnitId,
      anchorRect: bound,
      anchorRect$: position$.asObservable(),
      canvasElement: currentRender.engine.getCanvasElement()
    });
    return {
      dispose: () => {
        this._globalPopupManagerService.removePopup(id);
        position$.complete();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== id
    };
  }
  // #endregion
  // #region attach to cell
  /**
   * Bind popup to the right part of cell at(row, col).
   * This popup would move with the cell.
   * @param row
   * @param col
   * @param popup
   * @param _unitId
   * @param _subUnitId
   * @param viewport
   * @returns
   */
  attachPopupToCell(row, col, popup, _unitId, _subUnitId, viewport) {
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      return null;
    }
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    if (_unitId && unitId !== _unitId || _subUnitId && subUnitId !== _subUnitId) {
      return null;
    }
    const currentRender = this._renderManagerService.getRenderById(unitId);
    const skeleton = currentRender == null ? void 0 : currentRender.with(SheetSkeletonManagerService).ensureSkeleton(subUnitId);
    const sheetSelectionRenderService = currentRender == null ? void 0 : currentRender.with(ISheetSelectionRenderService);
    if (!currentRender || !skeleton || !sheetSelectionRenderService) {
      return null;
    }
    if (this._isSelectionMoving && !popup.showOnSelectionMoving) {
      return;
    }
    const activeViewport = viewport != null ? viewport : getViewportByCell(row, col, currentRender.scene, worksheet);
    if (!activeViewport) {
      return null;
    }
    const { position, position$, disposable: positionObserverDisposable, updateRowCol } = this._createCellPositionObserver(row, col, currentRender, skeleton, activeViewport);
    const { rects$, disposable: rectsObserverDisposable } = this._createHiddenRectObserver({
      row,
      column: col,
      worksheet,
      skeleton,
      currentRender
    });
    const id = this._globalPopupManagerService.addPopup({
      ...popup,
      unitId,
      subUnitId,
      anchorRect: position,
      anchorRect$: position$,
      canvasElement: currentRender.engine.getCanvasElement(),
      hiddenRects$: rects$
    });
    const disposableCollection = new DisposableCollection();
    disposableCollection.add(positionObserverDisposable);
    disposableCollection.add(toDisposable(() => {
      this._globalPopupManagerService.removePopup(id);
      position$.complete();
    }));
    disposableCollection.add(rectsObserverDisposable);
    const watchedRange = { startRow: row, endRow: row, startColumn: col, endColumn: col };
    disposableCollection.add(this._refRangeService.watchRange(unitId, subUnitId, watchedRange, (_, after) => {
      if (!after) {
        disposableCollection.dispose();
      } else {
        updateRowCol(after.startRow, after.startColumn);
      }
    }));
    return {
      dispose() {
        disposableCollection.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== id
    };
  }
  /**
   * attach Comp to floatDOM
   * @param range
   * @param popup
   * @param _unitId
   * @param _subUnitId
   * @param viewport
   * @param showOnSelectionMoving
   * @returns
   */
  attachRangePopup(range, popup, _unitId, _subUnitId, viewport, showOnSelectionMoving = false) {
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      return null;
    }
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    if (_unitId && unitId !== _unitId || _subUnitId && subUnitId !== _subUnitId) {
      return null;
    }
    const currentRender = this._renderManagerService.getRenderById(unitId);
    const skeleton = currentRender == null ? void 0 : currentRender.with(SheetSkeletonManagerService).getOrCreateSkeleton({
      sheetId: subUnitId
    });
    const sheetSelectionRenderService = currentRender == null ? void 0 : currentRender.with(ISheetSelectionRenderService);
    if (!currentRender || !skeleton || !sheetSelectionRenderService) {
      return null;
    }
    if (sheetSelectionRenderService.selectionMoving && !showOnSelectionMoving) {
      return;
    }
    const activeViewport = viewport != null ? viewport : getViewportByCell(range.startRow, range.startColumn, currentRender.scene, worksheet);
    if (!activeViewport) {
      return null;
    }
    const { position, position$, disposable: positionObserverDisposable, updateRowCol, topLeftPos$, rightBottomPos$ } = this._createRangePositionObserver(range, currentRender, skeleton, activeViewport);
    const { rects$, disposable: rectsObserverDisposable } = this._createHiddenRectObserver({
      row: range.startRow,
      column: range.startColumn,
      worksheet,
      skeleton,
      currentRender
    });
    const id = this._globalPopupManagerService.addPopup({
      ...popup,
      unitId,
      subUnitId,
      anchorRect: position,
      anchorRect$: position$,
      canvasElement: currentRender.engine.getCanvasElement(),
      hiddenRects$: rects$
    });
    const disposableCollection = new DisposableCollection();
    disposableCollection.add(positionObserverDisposable);
    disposableCollection.add(toDisposable(() => {
      this._globalPopupManagerService.removePopup(id);
      topLeftPos$.complete();
      rightBottomPos$.complete();
    }));
    disposableCollection.add(rectsObserverDisposable);
    const watchedRange = { ...range };
    disposableCollection.add(this._refRangeService.watchRange(unitId, subUnitId, watchedRange, (_, after) => {
      if (!after) {
        disposableCollection.dispose();
      } else {
        updateRowCol(after.startRow, after.startColumn);
      }
    }));
    return {
      dispose() {
        disposableCollection.dispose();
      },
      canDispose: () => this._globalPopupManagerService.activePopupId !== id
    };
  }
  /**
   *
   * @param initialRow
   * @param initialCol
   * @param currentRender
   * @param skeleton
   * @param activeViewport
   * @returns
   */
  _createCellPositionObserver(initialRow, initialCol, currentRender, skeleton, activeViewport) {
    let row = initialRow;
    let col = initialCol;
    const position = this._calcCellPositionByCell(row, col, currentRender, skeleton, activeViewport);
    const position$ = new BehaviorSubject(position);
    const updatePosition = () => position$.next(this._calcCellPositionByCell(row, col, currentRender, skeleton, activeViewport));
    const disposable = new DisposableCollection();
    disposable.add(currentRender.engine.clientRect$.subscribe(() => updatePosition()));
    disposable.add(this._commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetWorksheetRowAutoHeightMutation.id) {
        const params = commandInfo.params;
        if (params.rowsAutoHeightInfo.findIndex((item) => item.row === row) > -1) {
          updatePosition();
          return;
        }
      }
      if (COMMAND_LISTENER_SKELETON_CHANGE.indexOf(commandInfo.id) > -1 || commandInfo.id === SetScrollOperation.id || commandInfo.id === SetZoomRatioOperation.id) {
        updatePosition();
      }
    }));
    const updateRowCol = (newRow, newCol) => {
      row = newRow;
      col = newCol;
      updatePosition();
    };
    return {
      position$,
      disposable,
      position,
      updateRowCol
    };
  }
  // TODO @lumixraku to a normal function, not method.
  _calcCellPositionByCell(row, col, currentRender, skeleton, activeViewport) {
    const { scene, engine } = currentRender;
    const primaryWithCoord = skeleton.getCellWithCoordByIndex(row, col);
    const cellInfo = primaryWithCoord.isMergedMainCell ? primaryWithCoord.mergeInfo : primaryWithCoord;
    const { scaleX, scaleY } = scene.getAncestorScale();
    const scrollXY = {
      x: activeViewport.viewportScrollX,
      y: activeViewport.viewportScrollY
    };
    const canvasElement = engine.getCanvasElement();
    const canvasClientRect = canvasElement.getBoundingClientRect();
    const widthOfCanvas = pxToNum(canvasElement.style.width);
    const { top, left, width } = canvasClientRect;
    const scaleAdjust = width / widthOfCanvas;
    return {
      left: (cellInfo.startX - scrollXY.x) * scaleAdjust * scaleX + left,
      right: (cellInfo.endX - scrollXY.x) * scaleAdjust * scaleX + left,
      top: (cellInfo.startY - scrollXY.y) * scaleAdjust * scaleY + top,
      bottom: (cellInfo.endY - scrollXY.y) * scaleAdjust * scaleY + top
    };
  }
  // #endregion
  /**
   * Unlike _createCellPositionObserver, this accept a range not a single cell.
   * @param initialRow
   * @param initialCol
   * @param currentRender
   * @param skeleton
   * @param activeViewport
   */
  _createRangePositionObserver(range, currentRender, skeleton, activeViewport) {
    let { startRow, startColumn } = range;
    const topLeftCoord = this._calcCellPositionByCell(startRow, startColumn, currentRender, skeleton, activeViewport);
    const topLeftPos$ = new BehaviorSubject(topLeftCoord);
    const rightBottomCoord = this._calcCellPositionByCell(range.endRow, range.endColumn, currentRender, skeleton, activeViewport);
    const rightBottomPos$ = new BehaviorSubject(rightBottomCoord);
    const updatePosition = () => {
      const topLeftCoord2 = this._calcCellPositionByCell(startRow, startColumn, currentRender, skeleton, activeViewport);
      const rightBottomCoord2 = this._calcCellPositionByCell(range.endRow, range.endColumn, currentRender, skeleton, activeViewport);
      topLeftPos$.next(topLeftCoord2);
      rightBottomPos$.next(rightBottomCoord2);
    };
    const disposable = new DisposableCollection();
    disposable.add(currentRender.engine.clientRect$.subscribe(() => updatePosition()));
    disposable.add(this._commandService.onCommandExecuted((commandInfo) => {
      if (commandInfo.id === SetWorksheetRowAutoHeightMutation.id) {
        const params = commandInfo.params;
        if (params.rowsAutoHeightInfo.findIndex((item) => item.row === startRow) > -1) {
          updatePosition();
          return;
        }
      }
      if (COMMAND_LISTENER_SKELETON_CHANGE.indexOf(commandInfo.id) > -1 || commandInfo.id === SetScrollOperation.id || commandInfo.id === SetZoomRatioOperation.id) {
        updatePosition();
      }
    }));
    const updateRowCol = (newRow, newCol) => {
      startRow = newRow;
      startColumn = newCol;
      updatePosition();
    };
    const position$ = topLeftPos$.pipe(
      map((topLeft) => {
        const rightBottomCoord2 = this._calcCellPositionByCell(range.endRow, range.endColumn, currentRender, skeleton, activeViewport);
        return {
          top: topLeft.top,
          left: topLeft.left,
          right: rightBottomCoord2.right,
          bottom: rightBottomCoord2.bottom
        };
      })
    );
    const position = {
      top: topLeftCoord.top,
      left: topLeftCoord.left,
      right: rightBottomCoord.right,
      bottom: rightBottomCoord.bottom
    };
    return {
      position$,
      position,
      updateRowCol,
      topLeftPos$,
      rightBottomPos$,
      disposable
    };
  }
};
SheetCanvasPopManagerService = __decorateClass([
  __decorateParam(0, Inject(ICanvasPopupService)),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, IUniverInstanceService),
  __decorateParam(3, Inject(RefRangeService)),
  __decorateParam(4, ICommandService),
  __decorateParam(5, IRefSelectionsService),
  __decorateParam(6, Inject(SheetsSelectionsService))
], SheetCanvasPopManagerService);
function pxToNum(width) {
  return Number.parseInt(width.replace("px", ""));
}

// ../packages/sheets-ui/src/services/cell-alert-manager.service.ts
var CellAlertManagerService = class extends Disposable {
  constructor(_renderManagerService, _canvasPopManagerService) {
    super();
    this._renderManagerService = _renderManagerService;
    this._canvasPopManagerService = _canvasPopManagerService;
    __publicField(this, "_currentAlert$", new Subject());
    __publicField(this, "_currentAlert", /* @__PURE__ */ new Map());
    __publicField(this, "currentAlert$", this._currentAlert$.asObservable());
    this.disposeWithMe(() => {
      this._currentAlert$.complete();
    });
  }
  get currentAlert() {
    return this._currentAlert;
  }
  showAlert(alert) {
    let lastPopup = this._currentAlert.get(alert.key);
    if (lastPopup) {
      lastPopup.dispose.dispose();
    }
    ;
    if (lastPopup) {
      lastPopup.dispose.dispose();
    } else {
      lastPopup = {
        alert,
        dispose: {
          dispose() {
          }
        }
      };
      this._currentAlert.set(alert.key, lastPopup);
    }
    const { location } = alert;
    const { row, col, unitId } = location;
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (!currentRender) {
      return;
    }
    const disposable = this._canvasPopManagerService.attachPopupToCell(row, col, {
      componentKey: CELL_ALERT_KEY,
      direction: "horizontal",
      offset: [2, 0],
      extraProps: {
        alert
      }
    });
    if (disposable) {
      lastPopup.dispose = disposable;
    }
    this._currentAlert$.next(Array.from(this._currentAlert.entries()));
  }
  removeAlert(key) {
    const lastPopup = this._currentAlert.get(key);
    if (lastPopup) {
      this._currentAlert.delete(key);
      lastPopup == null ? void 0 : lastPopup.dispose.dispose();
      this._currentAlert$.next(Array.from(this._currentAlert.entries()));
    }
  }
  clearAlert() {
    this._currentAlert.forEach((alert) => {
      alert.dispose.dispose();
    });
    this._currentAlert.clear();
    this._currentAlert$.next(Array.from(this._currentAlert.entries()));
  }
};
CellAlertManagerService = __decorateClass([
  __decorateParam(0, IRenderManagerService),
  __decorateParam(1, Inject(SheetCanvasPopManagerService))
], CellAlertManagerService);

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/cell-alert/index.module.less
var index_module_default10 = {
  "cellAlert": "univer-cell-alert",
  "cellAlertTitle": "univer-cell-alert-title",
  "cellAlertIcon": "univer-cell-alert-icon",
  "cellAlertIconError": "univer-cell-alert-icon-error",
  "cellAlertIconInfo": "univer-cell-alert-icon-info",
  "cellAlertIconWarning": "univer-cell-alert-icon-warning",
  "cellAlertContent": "univer-cell-alert-content"
};

// ../packages/sheets-ui/src/views/cell-alert/CellAlertPopup.tsx
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
function CellAlert({ popup }) {
  var _a;
  const alert = (_a = popup.extraProps) == null ? void 0 : _a.alert;
  if (!alert) {
    return null;
  }
  const { type, title, message } = alert;
  const iconMap = {
    [2 /* ERROR */]: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(error_single_default, { className: clsx(index_module_default10.cellAlertIcon, index_module_default10.cellAlertIconError) }),
    [0 /* INFO */]: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(warning_single_default, { className: clsx(index_module_default10.cellAlertIcon, index_module_default10.cellAlertIconInfo) }),
    [1 /* WARNING */]: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(warning_single_default, { className: clsx(index_module_default10.cellAlertIcon, index_module_default10.cellAlertIconWarning) })
  };
  return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("div", { className: index_module_default10.cellAlert, children: [
    /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("div", { className: index_module_default10.cellAlertTitle, children: [
      type ? iconMap[type] : null,
      title
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: index_module_default10.cellAlertContent, children: message })
  ] });
}

// ../packages/sheets-ui/src/views/cell-alert/index.ts
var CELL_ALERT_KEY = "univer.sheet.cell-alert";

// ../packages/sheets-ui/src/controllers/cell-alert.controller.ts
var CellAlertRenderController = class extends Disposable {
  constructor(_context, _componentManager) {
    super();
    this._context = _context;
    this._componentManager = _componentManager;
    this._initComponent();
  }
  _initComponent() {
    this._componentManager.register(CELL_ALERT_KEY, CellAlert);
  }
};
CellAlertRenderController = __decorateClass([
  __decorateParam(1, Inject(ComponentManager))
], CellAlertRenderController);

// ../packages/sheets-ui/src/controllers/cell-custom-render.controller.ts
var CellCustomRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _renderManagerService, _permissionService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._renderManagerService = _renderManagerService;
    this._permissionService = _permissionService;
    __publicField(this, "_enterActiveRender");
    this._initEventBinding();
  }
  // eslint-disable-next-line max-lines-per-function
  _initEventBinding() {
    const disposableCollection = new DisposableCollection();
    const workbook = this._context.unit;
    const handleSkeletonChange = (skeletonParam) => {
      disposableCollection.dispose();
      if (!skeletonParam) {
        return;
      }
      const unitId = this._context.unitId;
      const { skeleton } = skeletonParam;
      const currentRender = this._renderManagerService.getRenderById(unitId);
      if (currentRender && currentRender.mainComponent) {
        const spreadsheet = currentRender.mainComponent;
        const getActiveRender = (evt) => {
          const { offsetX, offsetY } = evt;
          const scene = currentRender.scene;
          const worksheet = workbook.getActiveSheet();
          if (!worksheet) {
            return;
          }
          const activeViewport = scene.getActiveViewportByCoord(
            Vector2.FromArray([offsetX, offsetY])
          );
          if (!activeViewport) {
            return;
          }
          const { scaleX, scaleY } = scene.getAncestorScale();
          const scrollXY = {
            x: activeViewport.viewportScrollX,
            y: activeViewport.viewportScrollY
          };
          const cellPos = skeleton.getCellIndexByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
          const mergeCell = skeleton.worksheet.getMergedCell(cellPos.row, cellPos.column);
          const cellIndex = {
            actualRow: mergeCell ? mergeCell.startRow : cellPos.row,
            actualCol: mergeCell ? mergeCell.startColumn : cellPos.column,
            mergeCell,
            row: cellPos.row,
            col: cellPos.column
          };
          if (!cellIndex || !skeleton) {
            return;
          }
          const cellData = worksheet.getCell(cellIndex.actualRow, cellIndex.actualCol);
          if (!cellData) {
            return;
          }
          const renders = cellData.customRender;
          if (!(renders == null ? void 0 : renders.length)) {
            return;
          }
          const row = cellIndex.actualRow;
          const col = cellIndex.actualCol;
          const sortedRenders = renders.sort(sortRules);
          const subUnitId = worksheet.getSheetId();
          const info = {
            data: cellData,
            style: skeleton.getStyles().getStyleByCell(cellData),
            primaryWithCoord: skeleton.getCellWithCoordByIndex(cellIndex.actualRow, cellIndex.actualCol),
            unitId,
            subUnitId,
            row,
            col,
            workbook,
            worksheet
          };
          const position = {
            x: scrollXY.x + offsetX / scaleX,
            y: scrollXY.y + offsetY / scaleY
          };
          const activeRender = sortedRenders.find((render) => {
            var _a;
            return (_a = render.isHit) == null ? void 0 : _a.call(render, position, info);
          });
          if (!activeRender) {
            return;
          }
          return [activeRender, info];
        };
        const disposable = spreadsheet.onPointerDown$.subscribeEvent((evt) => {
          var _a, _b, _c, _d;
          const activeRenderInfo = getActiveRender(evt);
          if (activeRenderInfo) {
            const [activeRender, cellContext] = activeRenderInfo;
            const { row, col, worksheet, unitId: unitId2, subUnitId } = cellContext;
            const sheetEditable = (_a = this._permissionService.composePermission(
              [new WorkbookEditablePermission(unitId2).id, new WorksheetEditPermission(unitId2, subUnitId).id]
            )) == null ? void 0 : _a.every((permission2) => permission2.value);
            if (!sheetEditable) {
              return false;
            }
            const permission = (_c = (_b = worksheet.getCell(row, col)) == null ? void 0 : _b.selectionProtection) == null ? void 0 : _c[0];
            if ((permission == null ? void 0 : permission[D.Edit]) === false) {
              return false;
            }
            (_d = activeRender.onPointerDown) == null ? void 0 : _d.call(activeRender, cellContext, evt);
          }
        });
        const moveDisposable = fromEventSubject(spreadsheet.onPointerMove$).pipe(throttleTime(30)).subscribe((evt) => {
          var _a, _b, _c, _d, _e, _f;
          const activeRenderInfo = getActiveRender(evt);
          if (activeRenderInfo) {
            const [activeRender, cellContext] = activeRenderInfo;
            if (this._enterActiveRender) {
              if (this._enterActiveRender.render !== activeRender) {
                (_b = (_a = this._enterActiveRender.render).onPointerLeave) == null ? void 0 : _b.call(_a, this._enterActiveRender.cellContext, evt);
                this._enterActiveRender = {
                  render: activeRender,
                  cellContext
                };
                (_c = activeRender.onPointerEnter) == null ? void 0 : _c.call(activeRender, cellContext, evt);
              }
            } else {
              this._enterActiveRender = {
                render: activeRender,
                cellContext
              };
              (_d = activeRender.onPointerEnter) == null ? void 0 : _d.call(activeRender, cellContext, evt);
            }
          } else {
            if (this._enterActiveRender) {
              (_f = (_e = this._enterActiveRender.render).onPointerLeave) == null ? void 0 : _f.call(_e, this._enterActiveRender.cellContext, evt);
              this._enterActiveRender = null;
            }
          }
        });
        disposable && disposableCollection.add(disposable);
        moveDisposable && disposableCollection.add(moveDisposable);
      }
    };
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe(handleSkeletonChange));
    handleSkeletonChange(this._sheetSkeletonManagerService.getCurrentParam());
    this.disposeWithMe(disposableCollection);
  }
};
CellCustomRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, IRenderManagerService),
  __decorateParam(3, IPermissionService)
], CellCustomRenderController);

// ../packages/sheets-ui/src/views/clipboard/ClipboardPopupMenu.tsx
var import_react19 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/clipboard/index.module.less
var index_module_default11 = {
  "sheetPasteOptionsWrapper": "univer-sheet-paste-options-wrapper",
  "sheetPasteOptionsIconWrapper": "univer-sheet-paste-options-icon-wrapper",
  "sheetPasteOptionsMenu": "univer-sheet-paste-options-menu",
  "sheetPasteOptionsMenuItem": "univer-sheet-paste-options-menu-item",
  "sheetPasteOptionsMenuItemTitle": "univer-sheet-paste-options-menu-item-title",
  "sheetPasteOptionsMenuItemIcon": "univer-sheet-paste-options-menu-item-icon"
};

// ../packages/sheets-ui/src/views/clipboard/ClipboardPopupMenu.tsx
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var DEFAULT_PADDING = 2;
var SheetPasteOptions = [
  { value: "DEFAULT_PASTE", label: "rightClick.paste" },
  { value: "SPECIAL_PASTE_VALUE", label: "rightClick.pasteValue" },
  { value: "SPECIAL_PASTE_FORMAT", label: "rightClick.pasteFormat" },
  { value: "SPECIAL_PASTE_COL_WIDTH", label: "rightClick.pasteColWidth" },
  { value: "SPECIAL_PASTE_BESIDES_BORDER", label: "rightClick.pasteBesidesBorder" },
  { value: "SPECIAL_PASTE_FORMULA", label: "formula.operation.pasteFormula" }
];
var useMenuPosition = (range) => {
  var _a, _b, _c, _d, _e;
  const univerInstanceService = useDependency(IUniverInstanceService);
  const renderManagerService = useDependency(IRenderManagerService);
  const workbook = useActiveWorkbook();
  if (!range || !workbook) return null;
  const anchor = {
    startRow: range.rows[0],
    startCol: range.cols[0],
    endRow: range.rows[range.rows.length - 1],
    endCol: range.cols[range.cols.length - 1]
  };
  if (anchor.endRow < 0 || anchor.endCol < 0) {
    return null;
  }
  const ru = renderManagerService.getRenderById(workbook.getUnitId());
  const sheetSkeletonManagerService = ru == null ? void 0 : ru.with(SheetSkeletonManagerService);
  const selectionRenderService = ru == null ? void 0 : ru.with(ISheetSelectionRenderService);
  const sheetObject = getSheetObject(univerInstanceService, renderManagerService);
  if (!sheetObject || !selectionRenderService) return null;
  const { scene } = sheetObject;
  const skeleton = sheetSkeletonManagerService == null ? void 0 : sheetSkeletonManagerService.getCurrentSkeleton();
  const viewport = selectionRenderService.getViewPort();
  const scaleX = scene == null ? void 0 : scene.scaleX;
  const scaleY = scene == null ? void 0 : scene.scaleY;
  const scrollXY = scene == null ? void 0 : scene.getViewportScrollXY(viewport);
  const canvas = (_a = scene.getEngine()) == null ? void 0 : _a.getCanvas();
  if (!scaleX || !scene || !scaleX || !scaleY || !scrollXY) return null;
  const endPosition = skeleton == null ? void 0 : skeleton.getNoMergeCellPositionByIndex(anchor.endRow, anchor.endCol);
  const endX = (_b = endPosition == null ? void 0 : endPosition.endX) != null ? _b : 0;
  const endY = (_c = endPosition == null ? void 0 : endPosition.endY) != null ? _c : 0;
  const positionEndX = (_d = convertTransformToOffsetX(endX, scaleX, scrollXY)) != null ? _d : -9999;
  const positionEndY = (_e = convertTransformToOffsetY(endY, scaleY, scrollXY)) != null ? _e : -9999;
  const canvasWidth = canvas == null ? void 0 : canvas.getWidth();
  const canvasHeight = canvas == null ? void 0 : canvas.getHeight();
  if (!canvasWidth || !canvasHeight) return null;
  const XInSideView = positionEndX + 50 <= canvasWidth;
  const YInSideView = positionEndY + 50 <= canvasHeight;
  let positionX = positionEndX;
  let positionY = positionEndY;
  if (!XInSideView) {
    positionX = canvasWidth - 100;
  }
  if (!YInSideView) {
    positionY = canvasHeight - 100;
  }
  return {
    positionX,
    positionY
  };
};
var ClipboardPopupMenu = () => {
  const clipboardService = useDependency(ISheetClipboardService);
  const showMenu = useObservable(clipboardService.showMenu$, false);
  const pasteOptionsCache = useObservable(clipboardService.pasteOptionsCache$, null);
  const localeService = useDependency(LocaleService);
  const commandService = useDependency(ICommandService);
  const [menuHovered, setMenuHovered] = (0, import_react19.useState)(false);
  const [menuVisible, setMenuVisible] = (0, import_react19.useState)(false);
  const range = pasteOptionsCache == null ? void 0 : pasteOptionsCache.target.pastedRange;
  const relativePosition = useMenuPosition(range);
  if (!relativePosition || !showMenu) return null;
  if (relativePosition.positionX < 50 || relativePosition.positionY < 30) return null;
  const iconVisible = menuHovered || menuVisible;
  const handleClick = (type) => {
    setMenuVisible(false);
    commandService.executeCommand(SheetOptionalPasteCommand.id, { type });
  };
  return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
    "div",
    {
      className: index_module_default11.sheetPasteOptionsWrapper,
      style: {
        left: relativePosition.positionX + DEFAULT_PADDING,
        top: relativePosition.positionY + DEFAULT_PADDING
      },
      onMouseEnter: () => setMenuHovered(true),
      onMouseLeave: () => setMenuHovered(false),
      children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
        Dropdown,
        {
          overlay: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
            "div",
            {
              className: clsx(index_module_default11.sheetPasteOptionsMenu, `
                          univer-border univer-border-solid univer-border-gray-200 univer-opacity-100
                        `),
              children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("ul", { children: SheetPasteOptions.map((item) => {
                const itemType = PREDEFINED_HOOK_NAME[item.value];
                const selected = (pasteOptionsCache == null ? void 0 : pasteOptionsCache.pasteType) === itemType;
                return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(
                  "li",
                  {
                    className: clsx(index_module_default11.sheetPasteOptionsMenuItem, "hover:univer-bg-neutral-100"),
                    onClick: () => handleClick(item.value),
                    children: [
                      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("span", { children: selected && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(check_mark_single_default, { className: index_module_default11.sheetPasteOptionsMenuItemIcon, style: { color: "rgb(var(--green-700, #409f11))" } }) }),
                      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
                        "div",
                        {
                          className: clsx(index_module_default11.sheetPasteOptionsMenuItemTitle, `
                                              univer-text-gray-700
                                            `),
                          children: localeService.t(item.label)
                        }
                      )
                    ]
                  },
                  item.value
                );
              }) })
            }
          ),
          open: menuVisible,
          onOpenChange: setMenuVisible,
          children: /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(
            "div",
            {
              className: index_module_default11.sheetPasteOptionsIconWrapper,
              onClick: () => {
                setMenuVisible(!menuVisible);
              },
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
                  paste_special_default,
                  {
                    style: { color: "#35322B" },
                    extend: { colorChannel1: "rgb(var(--green-700))" }
                  }
                ),
                iconVisible && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(more_down_single_default, {})
              ]
            }
          )
        }
      )
    }
  );
};

// ../packages/sheets-ui/src/controllers/clipboard/const.ts
var RemovePasteMenuCommands = [
  SetCellEditVisibleOperation.id,
  SetRangeValuesCommand.id,
  SetZoomRatioOperation.id,
  MoveRangeMutation.id,
  RemoveRowMutation.id,
  RemoveColMutation.id,
  InsertRowMutation.id,
  InsertColMutation.id,
  MoveRowsMutation.id,
  MoveColsMutation.id,
  SetWorksheetColWidthMutation.id,
  SetWorksheetRowHeightMutation.id,
  SetSelectionsOperation.id,
  UndoCommandId
];

// ../packages/sheets-ui/src/basics/editor/get-editor-object.ts
function getEditorObject(unitId, renderManagerService) {
  if (unitId == null) {
    return;
  }
  const currentRender = renderManagerService.getRenderById(unitId);
  if (currentRender == null) {
    return;
  }
  const { mainComponent, scene, engine, components } = currentRender;
  const document2 = mainComponent;
  const docBackground = components.get("__Document_Render_Background__" /* BACKGROUND */);
  return {
    document: document2,
    docBackground,
    scene,
    engine
  };
}

// ../packages/sheets-ui/src/services/editor/cell-editor-resize.service.ts
var EDITOR_INPUT_SELF_EXTEND_GAP = 5;
var EDITOR_BORDER_SIZE = 2;
var SheetCellEditorResizeService = class extends Disposable {
  constructor(_context, _layoutService, _cellEditorManagerService, _editorBridgeService, _renderManagerService, _sheetSkeletonManagerService, _univerInstanceService) {
    super();
    this._context = _context;
    this._layoutService = _layoutService;
    this._cellEditorManagerService = _cellEditorManagerService;
    this._editorBridgeService = _editorBridgeService;
    this._renderManagerService = _renderManagerService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._univerInstanceService = _univerInstanceService;
  }
  // eslint-disable-next-line complexity
  fitTextSize(callback) {
    var _a, _b, _c, _d;
    const param = this._editorBridgeService.getEditCellState();
    if (!param) return;
    const { position, documentLayoutObject, canvasOffset, scaleX, scaleY } = param;
    const { startX, startY, endX, endY } = position;
    const documentDataModel = this._univerInstanceService.getUnit(DOCS_NORMAL_EDITOR_UNIT_ID_KEY, O.UNIVER_DOC);
    if (documentDataModel == null) {
      return;
    }
    const documentSkeleton = this._getEditorSkeleton();
    if (!documentSkeleton) return;
    const info = this._predictingSize(
      position,
      canvasOffset,
      documentSkeleton,
      documentLayoutObject,
      scaleX,
      scaleY
    );
    if (!info) return;
    let { actualWidth, actualHeight } = info;
    const { verticalAlign, horizontalAlign, paddingData, fill } = documentLayoutObject;
    actualWidth = actualWidth + ((_a = paddingData.l) != null ? _a : 0) + ((_b = paddingData.r) != null ? _b : 0);
    actualHeight = actualHeight + ((_c = paddingData.t) != null ? _c : 0) + ((_d = paddingData.b) != null ? _d : 0);
    let editorWidth = endX - startX;
    let editorHeight = endY - startY;
    if (editorWidth < actualWidth) {
      editorWidth = Math.ceil(actualWidth);
    }
    if (editorHeight < actualHeight) {
      editorHeight = Math.ceil(actualHeight);
    }
    let offsetTop = 0;
    if (verticalAlign === 2 /* MIDDLE */) {
      offsetTop = (editorHeight - actualHeight) / 2 / scaleY;
    } else if (verticalAlign === 1 /* TOP */) {
      offsetTop = paddingData.t || 0;
    } else {
      offsetTop = (editorHeight - actualHeight) / scaleY;
    }
    let offsetLeft = 0;
    if (horizontalAlign === 2 /* CENTER */) {
      offsetLeft = (editorWidth - actualWidth) / 2 / scaleX;
    } else if (horizontalAlign === 3 /* RIGHT */) {
      offsetLeft = (editorWidth - actualWidth) / scaleX;
    } else {
      offsetLeft = paddingData.l || 0;
    }
    offsetTop = offsetTop < (paddingData.t || 0) ? paddingData.t || 0 : offsetTop;
    offsetLeft = offsetLeft < (paddingData.l || 0) ? paddingData.l || 0 : offsetLeft;
    documentDataModel.updateDocumentDataMargin({
      t: offsetTop,
      l: offsetLeft
    });
    documentSkeleton.calculate();
    this._editAreaProcessing(
      editorWidth,
      editorHeight,
      position,
      canvasOffset,
      fill,
      scaleX,
      scaleY,
      horizontalAlign,
      callback
    );
  }
  /**
   * Mainly used to pre-calculate the width of the editor,
   * to determine whether it needs to be automatically widened.
   */
  _predictingSize(actualRangeWithCoord, canvasOffset, documentSkeleton, documentLayoutObject, scaleX = 1, scaleY = 1) {
    const { startX, endX } = actualRangeWithCoord;
    const { textRotation, wrapStrategy, paddingData } = documentLayoutObject;
    const documentDataModel = this._univerInstanceService.getUnit(DOCS_NORMAL_EDITOR_UNIT_ID_KEY, O.UNIVER_DOC);
    const { vertexAngle: angle } = convertTextRotation(textRotation);
    if (wrapStrategy === 3 /* WRAP */ && angle === 0) {
      documentDataModel == null ? void 0 : documentDataModel.updateDocumentDataPageSize(endX - startX);
      documentDataModel == null ? void 0 : documentDataModel.updateDocumentDataMargin({ l: paddingData.l, t: paddingData.t });
      documentSkeleton.calculate();
      const { actualWidth, actualHeight } = documentSkeleton.getActualSize();
      return {
        actualWidth: actualWidth * scaleX,
        actualHeight: actualHeight * scaleY
      };
    }
    const maxSize = this._getEditorMaxSize(actualRangeWithCoord, canvasOffset, documentLayoutObject.horizontalAlign);
    if (!maxSize) return;
    documentDataModel == null ? void 0 : documentDataModel.updateDocumentDataPageSize(maxSize.width / scaleX);
    documentSkeleton.calculate();
    const size = documentSkeleton.getActualSize();
    let editorWidth = endX - startX;
    if (editorWidth < size.actualWidth * scaleX + EDITOR_INPUT_SELF_EXTEND_GAP * scaleX) {
      editorWidth = size.actualWidth * scaleX + EDITOR_INPUT_SELF_EXTEND_GAP * scaleX;
    }
    documentDataModel == null ? void 0 : documentDataModel.updateDocumentDataPageSize(editorWidth / scaleX);
    documentDataModel == null ? void 0 : documentDataModel.updateDocumentRenderConfig({
      horizontalAlign: 0 /* UNSPECIFIED */,
      cellValueType: void 0
    });
    return {
      actualWidth: size.actualWidth * scaleX,
      actualHeight: size.actualHeight * scaleY
    };
  }
  _getEditorMaxSize(position, canvasOffset, horizontalAlign) {
    const editorObject = this._getEditorObject();
    if (editorObject == null) {
      return;
    }
    function pxToNum2(width2) {
      return Number.parseInt(width2.replace("px", ""));
    }
    const engine = this._context.engine;
    const canvasElement = engine.getCanvasElement();
    const canvasClientRect = canvasElement.getBoundingClientRect();
    const widthOfCanvas = pxToNum2(canvasElement.style.width);
    const { width } = canvasClientRect;
    const scaleAdjust = width / widthOfCanvas;
    const { startX, startY, endX } = position;
    const enginWidth = this._context.engine.width;
    const clientHeight = document.body.clientHeight - startY - SHEET_FOOTER_BAR_HEIGHT - canvasOffset.top - EDITOR_BORDER_SIZE * 2;
    let clientWidth = width - startX;
    if (horizontalAlign === 2 /* CENTER */) {
      const rightGap = enginWidth - endX;
      const leftGap = startX;
      clientWidth = endX - startX + Math.min(leftGap, rightGap) * 2;
    } else if (horizontalAlign === 3 /* RIGHT */) {
      clientWidth = endX;
    }
    return {
      height: clientHeight,
      width: clientWidth - EDITOR_BORDER_SIZE,
      scaleAdjust
    };
  }
  /**
   * Mainly used to calculate the volume of scenes and objects,
   * determine whether a scrollbar appears,
   * and calculate the editor's boundaries relative to the browser.
   */
  // eslint-disable-next-line max-lines-per-function
  _editAreaProcessing(editorWidth, editorHeight, actualRangeWithCoord, canvasOffset, fill, scaleX = 1, scaleY = 1, horizontalAlign, callback) {
    var _a;
    const editorObject = this._getEditorObject();
    if (editorObject == null) {
      return;
    }
    const engine = this._context.engine;
    const canvasElement = engine.getCanvasElement();
    let { startX, startY } = actualRangeWithCoord;
    const { document: documentComponent, scene: editorScene, engine: docEngine } = editorObject;
    const viewportMain = editorScene.getViewport("viewMain" /* VIEW_MAIN */);
    const info = this._getEditorMaxSize(actualRangeWithCoord, canvasOffset, horizontalAlign);
    const { height: clientHeight, width: clientWidth, scaleAdjust } = info;
    let physicHeight = editorHeight;
    let scrollBar = viewportMain == null ? void 0 : viewportMain.getScrollBar();
    if (physicHeight > clientHeight) {
      if (scrollBar == null) {
        viewportMain && new ScrollBar(viewportMain, { enableHorizontal: false, barSize: 8 });
      } else {
        viewportMain == null ? void 0 : viewportMain.resetCanvasSizeAndUpdateScroll();
      }
      viewportMain == null ? void 0 : viewportMain.scrollToViewportPos({
        viewportScrollY: physicHeight - clientHeight
      });
      physicHeight = clientHeight;
    } else {
      scrollBar = null;
      (_a = viewportMain == null ? void 0 : viewportMain.getScrollBar()) == null ? void 0 : _a.dispose();
    }
    editorWidth += (scrollBar == null ? void 0 : scrollBar.barSize) || 0;
    if (editorWidth > clientWidth) {
      editorWidth = clientWidth;
    }
    this._addBackground(editorScene, editorWidth / scaleX, editorHeight / scaleY, fill);
    const { scaleX: precisionScaleX, scaleY: precisionScaleY } = editorScene.getPrecisionScale();
    editorScene.transformByState({
      width: editorWidth * scaleAdjust / scaleX,
      height: editorHeight * scaleAdjust / scaleY,
      scaleX: scaleX * scaleAdjust,
      scaleY: scaleY * scaleAdjust
    });
    documentComponent.resize(editorWidth * scaleAdjust / scaleX, editorHeight * scaleAdjust / scaleY);
    setTimeout(() => {
      docEngine.resizeBySize(
        fixLineWidthByScale(editorWidth, precisionScaleX),
        fixLineWidthByScale(physicHeight, precisionScaleY)
      );
      callback == null ? void 0 : callback();
    }, 0);
    const contentBoundingRect = this._layoutService.getContentElement().getBoundingClientRect();
    const canvasBoundingRect = canvasElement.getBoundingClientRect();
    startX = startX * scaleAdjust + (canvasBoundingRect.left - contentBoundingRect.left);
    startY = startY * scaleAdjust + (canvasBoundingRect.top - contentBoundingRect.top);
    const cellWidth = actualRangeWithCoord.endX - actualRangeWithCoord.startX;
    if (horizontalAlign === 3 /* RIGHT */) {
      startX += (cellWidth - editorWidth) * scaleAdjust;
    } else if (horizontalAlign === 2 /* CENTER */) {
      startX += (cellWidth - editorWidth * scaleAdjust) / 2;
    }
    this._cellEditorManagerService.setState({
      startX,
      startY,
      endX: editorWidth * scaleAdjust + startX,
      endY: physicHeight * scaleAdjust + startY,
      show: true
    });
  }
  /**
   * Since the document does not support cell background color, an additional rect needs to be added.
   */
  _addBackground(scene, editorWidth, editorHeight, fill) {
    const fillRectKey = "_backgroundRectHelperColor_";
    const rect = scene.getObject(fillRectKey);
    if (rect == null && fill == null) {
      return;
    }
    if (rect == null) {
      scene.addObjects(
        [
          new Rect(fillRectKey, {
            width: editorWidth,
            height: editorHeight,
            fill,
            evented: false
          })
        ],
        DOCS_COMPONENT_MAIN_LAYER_INDEX
      );
    } else if (fill == null) {
      rect.dispose();
    } else {
      rect.setProps({
        fill
      });
      rect.transformByState({
        width: editorWidth,
        height: editorHeight
      });
    }
  }
  resizeCellEditor(callback) {
    var _a;
    const state = this._cellEditorManagerService.getState();
    if (!state) return;
    if (!this._editorBridgeService.isVisible().visible) return;
    this._editorBridgeService.refreshEditCellPosition(true);
    const editCellState = this._editorBridgeService.getEditCellState();
    if (!editCellState) return;
    const skeleton = (_a = this._sheetSkeletonManagerService.getSkeletonParam(editCellState.sheetId)) == null ? void 0 : _a.skeleton;
    if (!skeleton) return;
    const { row, column, scaleX, scaleY, position, canvasOffset, documentLayoutObject } = editCellState;
    const { horizontalAlign } = documentLayoutObject;
    const maxSize = this._getEditorMaxSize(position, canvasOffset, horizontalAlign);
    if (!maxSize) return;
    const { height: clientHeight, width: clientWidth, scaleAdjust } = maxSize;
    const cell = skeleton.getCellWithCoordByIndex(row, column);
    const height = Math.min((cell.mergeInfo.endY - cell.mergeInfo.startY) * scaleY, clientHeight) * scaleAdjust;
    const width = Math.min((cell.mergeInfo.endX - cell.mergeInfo.startX) * scaleX, clientWidth) * scaleAdjust;
    const currentHeight = state.endY - state.startY;
    const currentWidth = state.endX - state.startX;
    if (currentHeight !== height || currentWidth !== width) {
      this._editorBridgeService.refreshEditCellPosition(true);
      const docSkeleton = this._getEditorSkeleton();
      if (!docSkeleton) {
        return;
      }
      this.fitTextSize(callback);
    }
  }
  _getEditorObject() {
    return getEditorObject(this._editorBridgeService.getCurrentEditorId(), this._renderManagerService);
  }
  _getEditorSkeleton() {
    var _a;
    return (_a = this._renderManagerService.getRenderById(DOCS_NORMAL_EDITOR_UNIT_ID_KEY)) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
  }
};
SheetCellEditorResizeService = __decorateClass([
  __decorateParam(1, ILayoutService),
  __decorateParam(2, ICellEditorManagerService),
  __decorateParam(3, IEditorBridgeService),
  __decorateParam(4, IRenderManagerService),
  __decorateParam(5, Inject(SheetSkeletonManagerService)),
  __decorateParam(6, IUniverInstanceService)
], SheetCellEditorResizeService);

// ../packages/sheets-ui/src/controllers/utils/cell-tools.ts
function isForceString(str) {
  return str.startsWith("'");
}
function extractStringFromForceString(str) {
  return str.slice(1);
}

// ../packages/sheets-ui/src/controllers/utils/char-tools.ts
var fullWidthToHalfWidthMap = {
  "\uFF10": "0",
  "\uFF11": "1",
  "\uFF12": "2",
  "\uFF13": "3",
  "\uFF14": "4",
  "\uFF15": "5",
  "\uFF16": "6",
  "\uFF17": "7",
  "\uFF18": "8",
  "\uFF19": "9",
  \uFF21: "A",
  \uFF22: "B",
  \uFF23: "C",
  \uFF24: "D",
  \uFF25: "E",
  \uFF26: "F",
  \uFF27: "G",
  \uFF28: "H",
  \uFF29: "I",
  \uFF2A: "J",
  \uFF2B: "K",
  \uFF2C: "L",
  \uFF2D: "M",
  \uFF2E: "N",
  \uFF2F: "O",
  \uFF30: "P",
  \uFF31: "Q",
  \uFF32: "R",
  \uFF33: "S",
  \uFF34: "T",
  \uFF35: "U",
  \uFF36: "V",
  \uFF37: "W",
  \uFF38: "X",
  \uFF39: "Y",
  \uFF3A: "Z",
  \uFF41: "a",
  \uFF42: "b",
  \uFF43: "c",
  \uFF44: "d",
  \uFF45: "e",
  \uFF46: "f",
  \uFF47: "g",
  \uFF48: "h",
  \uFF49: "i",
  \uFF4A: "j",
  \uFF4B: "k",
  \uFF4C: "l",
  \uFF4D: "m",
  \uFF4E: "n",
  \uFF4F: "o",
  \uFF50: "p",
  \uFF51: "q",
  \uFF52: "r",
  \uFF53: "s",
  \uFF54: "t",
  \uFF55: "u",
  \uFF56: "v",
  \uFF57: "w",
  \uFF58: "x",
  \uFF59: "y",
  \uFF5A: "z",
  "\uFF05": "%",
  "\uFF0D": "-",
  "\uFF0E": ".",
  "\uFF1A": ":",
  "\uFF0F": "/",
  "\uFF0B": "+",
  "\uFF20": "@",
  "\uFF06": "&",
  "\uFF0A": "*",
  "\uFF03": "#",
  "\uFF1D": "=",
  "\uFF1E": ">",
  "\uFF1C": "<",
  "\uFF04": "$",
  "\uFF02": '"',
  "\uFF07": "'",
  "\uFF08": "(",
  "\uFF09": ")",
  "\u3000": " ",
  "\uFF0C": ",",
  "\uFF01": "!",
  "\uFF1F": "?",
  "\uFF1B": ";",
  "\uFF3B": "[",
  "\uFF3D": "]",
  "\uFF5B": "{",
  "\uFF5D": "}"
};
var booleanMap = {
  true: "TRUE",
  false: "FALSE"
};
function isCJKLocale(locale) {
  return ["zhCN" /* ZH_CN */, "zhTW" /* ZH_TW */].includes(locale);
}
function normalizeString(str, lexerTreeBuilder, currentLocale, functionService) {
  let normalStr = str;
  if (isCJKLocale(currentLocale)) {
    if (str.startsWith("\uFF07") || str.startsWith("'")) {
      return `'${str.slice(1)}`;
    }
    normalStr = handleQuotedParts(normalStr);
  }
  if (normalStr.startsWith("=")) {
    return normalizeFormulaString(str, normalStr, lexerTreeBuilder, functionService);
  }
  const lowerCaseStr = normalStr.toLowerCase();
  if (booleanMap[lowerCaseStr]) {
    return booleanMap[lowerCaseStr];
  }
  const parsedValue = numfmt.parseValue(normalStr);
  return parsedValue == null ? str : normalStr;
}
function handleQuotedParts(str) {
  const sheetNamePattern = /['"].*?['"]/g;
  const quotedParts = [];
  const parts = str.split(sheetNamePattern);
  str.replace(sheetNamePattern, (match) => {
    quotedParts.push(match);
    return "";
  });
  let normalStr = parts.join("").split("").map(toHalfWidth).join("");
  quotedParts.forEach((part, idx) => {
    normalStr = normalStr.slice(0, idx * 2) + part + normalStr.slice((idx + 1) * 2);
  });
  return normalStr;
}
function normalizeFormulaString(str, normalStr, lexerTreeBuilder, functionService) {
  const nodes = lexerTreeBuilder.sequenceNodesBuilder(normalStr);
  if (!nodes) return str;
  let _normalStr = normalStr;
  let totalOffset = 0;
  nodes.forEach((node, index) => {
    if (typeof node === "object") {
      const token = node.token;
      if (booleanMap[token.toLowerCase()]) {
        const startIndex = node.startIndex + totalOffset + 1;
        const endIndex = node.endIndex + totalOffset + 2;
        _normalStr = replaceString(token.toLocaleUpperCase(), _normalStr, startIndex, endIndex);
      } else if (node.nodeType === 3 /* FUNCTION */ && hasFunctionName(token, functionService, nodes, index) || node.nodeType === 4 /* REFERENCE */) {
        const sheetNameIndex = token.indexOf("!");
        if (sheetNameIndex > -1) {
          const refBody = token.substring(sheetNameIndex + 1);
          const startIndex = node.startIndex + totalOffset + (sheetNameIndex + 1) + 1;
          const endIndex = node.endIndex + totalOffset + 2;
          _normalStr = replaceString(refBody.toLocaleUpperCase(), _normalStr, startIndex, endIndex);
        } else {
          const startIndex = node.startIndex + totalOffset + 1;
          const endIndex = node.endIndex + totalOffset + 2;
          _normalStr = replaceString(token.toLocaleUpperCase(), _normalStr, startIndex, endIndex);
        }
      } else if (token.startsWith('"') && token.endsWith('"') || token.startsWith("'") && token.endsWith("'")) {
        const startIndex = node.startIndex + totalOffset + 2;
        const endIndex = node.endIndex + totalOffset + 1;
        _normalStr = replaceString(str.slice(startIndex, endIndex), _normalStr, startIndex, endIndex);
      } else if (node.nodeType !== 5 /* ARRAY */) {
        const parsedValue = numfmt.parseValue(token);
        if (parsedValue == null) {
          const startIndex = node.startIndex + totalOffset + 1;
          const endIndex = node.endIndex + totalOffset + 2;
          _normalStr = replaceString(str.slice(startIndex, endIndex), _normalStr, startIndex, endIndex);
        } else if (typeof parsedValue.v === "number" && (parsedValue.z === void 0 || !numfmt.isDate(parsedValue.z))) {
          const v = `${parsedValue.v}`;
          const startIndex = node.startIndex + totalOffset + 1;
          const endIndex = node.endIndex + totalOffset + 2;
          const { processedString, offset } = processNumberStringWithSpaces(token, v);
          _normalStr = replaceString(processedString, _normalStr, startIndex, endIndex);
          totalOffset += offset;
        }
      }
    }
  });
  return _normalStr;
}
function hasFunctionName(name, functionService, nodes, index) {
  const functionList = functionService.getDescriptions();
  if (nodes[index + 1] !== "(" /* OPEN_BRACKET */) {
    return false;
  }
  return functionList.get(removeLeadingAtSymbols(name).toLocaleUpperCase()) !== void 0;
}
function removeLeadingAtSymbols(str) {
  const regex = /^@+/;
  return str.replace(regex, "");
}
function toHalfWidth(char) {
  return fullWidthToHalfWidthMap[char] || char;
}
function replaceString(replacedString, normalStr, startIndex, endIndex) {
  return normalStr.substring(0, startIndex) + replacedString + normalStr.substring(endIndex);
}
function processNumberStringWithSpaces(token, numStr) {
  var _a, _b;
  const leadingSpaces = ((_a = token.match(/^\s*/)) == null ? void 0 : _a[0]) || "";
  const trailingSpaces = ((_b = token.match(/\s*$/)) == null ? void 0 : _b[0]) || "";
  const processedString = leadingSpaces + numStr + trailingSpaces;
  const offset = processedString.length - token.length;
  return { processedString, offset };
}

// ../packages/sheets-ui/src/controllers/editor/utils/is-range-selector.ts
var RANGE_SELECTOR_SYMBOLS = "range_selector";
var isRangeSelector = (unitId) => {
  return unitId.includes(RANGE_SELECTOR_SYMBOLS);
};

// ../packages/sheets-ui/src/controllers/editor/editing.render-controller.ts
var HIDDEN_EDITOR_POSITION2 = -1e3;
var EditingRenderController = class extends Disposable {
  constructor(_context, selectionManagerService, _undoRedoService, _contextService, _renderManagerService, _editorBridgeService, _cellEditorManagerService, _lexerTreeBuilder, _functionService, _textSelectionManagerService, _commandService, _localService, _editorService, _sheetCellEditorResizeService, _univerInstanceService, _sheetInterceptorService) {
    super();
    this._context = _context;
    this._undoRedoService = _undoRedoService;
    this._contextService = _contextService;
    this._renderManagerService = _renderManagerService;
    this._editorBridgeService = _editorBridgeService;
    this._cellEditorManagerService = _cellEditorManagerService;
    this._lexerTreeBuilder = _lexerTreeBuilder;
    this._functionService = _functionService;
    this._textSelectionManagerService = _textSelectionManagerService;
    this._commandService = _commandService;
    this._localService = _localService;
    this._editorService = _editorService;
    this._sheetCellEditorResizeService = _sheetCellEditorResizeService;
    this._univerInstanceService = _univerInstanceService;
    this._sheetInterceptorService = _sheetInterceptorService;
    /**
     * It is used to distinguish whether the user has actively moved the cursor in the editor, mainly through mouse clicks.
     */
    __publicField(this, "_cursorChange", 0 /* InitialState */);
    /** If the corresponding unit is active and prepared for editing. */
    __publicField(this, "_isUnitEditing", false);
    __publicField(this, "_workbookSelections");
    __publicField(this, "_d");
    __publicField(this, "_cursorTimeout");
    this._workbookSelections = selectionManagerService.getWorkbookSelections(this._context.unitId);
    this.disposeWithMe(this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).subscribe((workbook) => {
      if ((workbook == null ? void 0 : workbook.getUnitId()) === this._context.unitId) {
        this._d = this._init();
      } else {
        this._disposeCurrent();
        if (this._isUnitEditing) {
          this._handleEditorInvisible({
            visible: false,
            eventType: 4 /* Keyboard */,
            keycode: 27 /* ESC */,
            unitId: this._context.unitId
          });
          this._isUnitEditing = false;
        }
      }
    }));
    this._initEditorVisibilityListener();
  }
  dispose() {
    super.dispose();
    this._disposeCurrent();
  }
  _disposeCurrent() {
    var _a;
    (_a = this._d) == null ? void 0 : _a.dispose();
    this._d = null;
  }
  _init() {
    const d = new DisposableCollection();
    this._subscribeToCurrentCell(d);
    this._initialCursorSync(d);
    this._listenEditorFocus(d);
    this._commandExecutedListener(d);
    this._initSkeletonListener(d);
    d.add(() => {
      clearTimeout(this._cursorTimeout);
    });
    this._cursorTimeout = setTimeout(() => {
      this._cursorStateListener(d);
    }, 1e3);
    return d;
  }
  _initEditorVisibilityListener() {
    this.disposeWithMe(
      this._editorBridgeService.visible$.pipe(distinctUntilChanged((prev, curr) => prev.visible === curr.visible)).subscribe((param) => {
        if ((param.unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY || param.unitId === this._context.unitId) && param.visible) {
          this._isUnitEditing = true;
          this._handleEditorVisible(param);
        } else if (this._isUnitEditing) {
          this._handleEditorInvisible(param);
          this._isUnitEditing = false;
        }
      })
    );
  }
  _listenEditorFocus(d) {
    const renderConfig = this._getEditorObject();
    if (!renderConfig) return;
    d.add(renderConfig.document.onPointerDown$.subscribeEvent(() => {
      if (this._isUnitEditing && this._editorBridgeService.isVisible()) {
        const param = this._editorBridgeService.getEditCellState();
        const editorId = this._editorBridgeService.getCurrentEditorId();
        if (!param || !editorId) {
          return;
        }
        this._sheetCellEditorResizeService.fitTextSize();
      }
    }));
  }
  _initialCursorSync(d) {
    d.add(this._cellEditorManagerService.focus$.pipe(filter((f) => !!f)).subscribe(() => {
      var _a;
      const currentDoc = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_DOC);
      if (!currentDoc) return;
      const docSelectionRenderManager = (_a = this._renderManagerService.getRenderById(currentDoc == null ? void 0 : currentDoc.getUnitId())) == null ? void 0 : _a.with(DocSelectionRenderService);
      if (!docSelectionRenderManager) return;
      docSelectionRenderManager.sync();
    }));
  }
  _initSkeletonListener(d) {
    const commandList = new Set(COMMAND_LISTENER_SKELETON_CHANGE);
    commandList.delete(SetWorksheetActiveOperation.id);
    d.add(this._commandService.onCommandExecuted((commandInfo) => {
      if (!commandList.has(commandInfo.id)) {
        return;
      }
      switch (commandInfo.id) {
        case MoveRowsMutation.id:
        case MoveColsMutation.id:
        case RemoveColMutation.id:
        case RemoveRowMutation.id:
        case InsertColMutation.id:
        case InsertRowMutation.id: {
          const editLocation = this._editorBridgeService.getEditLocation();
          if (!editLocation) break;
          const currentRange = {
            startRow: editLocation.row,
            startColumn: editLocation.column,
            endRow: editLocation.row,
            endColumn: editLocation.column
          };
          const newRange = adjustRangeOnMutation(currentRange, commandInfo);
          if (!newRange) break;
          const newRow = newRange.startRow;
          const newColumn = newRange.startColumn;
          this._editorBridgeService.updateEditLocation(newRow, newColumn);
          break;
        }
      }
      this._sheetCellEditorResizeService.resizeCellEditor(() => {
        this._textSelectionManagerService.refreshSelection({
          unitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
          subUnitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY
        });
      });
    }));
  }
  /**
   * Should update current editing cell info when selection is changed.
   * @param d DisposableCollection
   */
  _subscribeToCurrentCell(d) {
    d.add(this._editorBridgeService.currentEditCellState$.subscribe((editCellState) => {
      var _a, _b;
      if (editCellState == null || this._editorBridgeService.isForceKeepVisible()) {
        return;
      }
      const state = this._editorBridgeService.getEditCellState();
      if (state == null) {
        return;
      }
      const { position, documentLayoutObject, scaleX, editorUnitId } = state;
      if (this._contextService.getContextValue(FOCUSING_EDITOR_STANDALONE)) {
        return;
      }
      const cellDocument = this._getDocumentDataModel();
      if (cellDocument == null) return;
      const { startX, endX } = position;
      const { textRotation, wrapStrategy, documentModel } = documentLayoutObject;
      const { vertexAngle: angle } = convertTextRotation(textRotation);
      if (wrapStrategy === 3 /* WRAP */ && angle === 0) {
        cellDocument.updateDocumentDataPageSize((endX - startX) / scaleX);
      }
      this._commandService.syncExecuteCommand(ReplaceSnapshotCommand.id, {
        unitId: editorUnitId,
        snapshot: documentModel.getSnapshot()
      });
      this._contextService.setContextValue(FOCUSING_EDITOR_BUT_HIDDEN, true);
      this._textSelectionManagerService.replaceDocRanges(
        [{
          startOffset: 0,
          endOffset: 0
        }],
        {
          unitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
          subUnitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY
        }
      );
      const cellSelectionRenderManager = (_a = this._renderManagerService.getRenderById(DOCS_NORMAL_EDITOR_UNIT_ID_KEY)) == null ? void 0 : _a.with(DocSelectionRenderService);
      const formulaSelectionRenderManager = (_b = this._renderManagerService.getRenderById(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY)) == null ? void 0 : _b.with(DocSelectionRenderService);
      if ((cellSelectionRenderManager == null ? void 0 : cellSelectionRenderManager.canFocusing) || (formulaSelectionRenderManager == null ? void 0 : formulaSelectionRenderManager.canFocusing)) {
        this._univerInstanceService.setCurrentUnitForType(DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
        cellSelectionRenderManager == null ? void 0 : cellSelectionRenderManager.activate(
          HIDDEN_EDITOR_POSITION2,
          HIDDEN_EDITOR_POSITION2,
          true
        );
      }
    }));
  }
  /**
   * Listen to document edits to refresh the size of the sheet editor, not for normal editor.
   */
  _commandExecutedListener(d) {
    d.add(this._commandService.onCommandExecuted((command) => {
      if (command.id === RichTextEditingMutation.id) {
        const params = command.params;
        const { unitId: commandUnitId } = params;
        if (!this._isCurrentSheetFocused() || isRangeSelector(commandUnitId)) {
          return;
        }
        this._editorBridgeService.changeEditorDirty(true);
        if (!this._editorBridgeService.isVisible().visible) {
          return;
        }
        if (commandUnitId === DOCS_NORMAL_EDITOR_UNIT_ID_KEY) {
          this._sheetCellEditorResizeService.fitTextSize();
        }
      }
    }));
    const closeEditorOperation = [SetCellEditVisibleArrowOperation.id];
    d.add(this._commandService.onCommandExecuted((command) => {
      if (closeEditorOperation.includes(command.id)) {
        const params = command.params;
        const { keycode, isShift } = params;
        if (keycode != null && (this._cursorChange === 2 /* CursorChange */ || this._contextService.getContextValue(FOCUSING_FX_BAR_EDITOR))) {
          this._moveInEditor(keycode, isShift);
          return;
        }
        this._commandService.syncExecuteCommand(SetCellEditVisibleOperation.id, params);
      }
      if (command.id === SetCellEditVisibleWithF2Operation.id) {
        this._cursorChange = 2 /* CursorChange */;
      }
    }));
  }
  // You can double-click on the cell or input content by keyboard to put the cell into the edit state.
  // eslint-disable-next-line complexity
  _handleEditorVisible(param) {
    var _a, _b, _c;
    const { eventType, keycode } = param;
    this._cursorChange = eventType === 1 /* PointerDown */ || eventType === 3 /* Dblclick */ ? 2 /* CursorChange */ : 1 /* StartEditor */;
    const editCellState = this._editorBridgeService.getEditLocation();
    if (editCellState == null) {
      return;
    }
    this._commandService.syncExecuteCommand(ScrollToRangeOperation.id, {
      range: {
        startRow: editCellState.row,
        startColumn: editCellState.column,
        endRow: editCellState.row,
        endColumn: editCellState.column
      }
    });
    this._editorBridgeService.refreshEditCellPosition(false);
    const { unitId, isInArrayFormulaRange = false } = editCellState;
    const editorObject = this._getEditorObject();
    if (editorObject == null) {
      return;
    }
    const { document: document2, scene } = editorObject;
    this._contextService.setContextValue(EDITOR_ACTIVATED, true);
    const documentDataModel = this._getDocumentDataModel();
    const skeleton = this._getEditorSkeleton(DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
    if (!skeleton || !documentDataModel) {
      return;
    }
    this._sheetCellEditorResizeService.fitTextSize(() => {
      const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
      viewMain == null ? void 0 : viewMain.scrollToViewportPos({
        viewportScrollX: Number.POSITIVE_INFINITY,
        viewportScrollY: Number.POSITIVE_INFINITY
      });
    });
    if (eventType === 4 /* Keyboard */ && keycode === 113 /* F2 */) {
      document2.makeDirty();
      this._textSelectionManagerService.replaceDocRanges([
        {
          startOffset: 0,
          endOffset: 0
        }
      ]);
      const endOffset = ((_b = (_a = documentDataModel.getBody()) == null ? void 0 : _a.dataStream.length) != null ? _b : 2) - 2;
      this._textSelectionManagerService.replaceDocRanges(
        [{
          startOffset: endOffset,
          endOffset
        }],
        {
          unitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
          subUnitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY
        }
      );
    } else if (
      // clear and edit
      eventType === 4 /* Keyboard */ || eventType === 3 /* Dblclick */ && isInArrayFormulaRange
    ) {
      this._emptyDocumentDataModel(documentDataModel.getSnapshot().documentStyle, !!isInArrayFormulaRange);
      document2.makeDirty();
      if (keycode === 8 /* BACKSPACE */ || eventType === 3 /* Dblclick */) {
        skeleton.calculate();
        this._editorBridgeService.changeEditorDirty(true);
      }
      this._textSelectionManagerService.replaceDocRanges(
        [{
          startOffset: 0,
          endOffset: 0
        }],
        {
          unitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY,
          subUnitId: DOCS_NORMAL_EDITOR_UNIT_ID_KEY
        }
      );
    } else if (eventType === 3 /* Dblclick */) {
      if (this._contextService.getContextValue(FOCUSING_EDITOR_INPUT_FORMULA)) {
        return;
      }
      const cursor = documentDataModel.getBody().dataStream.length - 2 || 0;
      this._textSelectionManagerService.replaceDocRanges([
        {
          startOffset: cursor,
          endOffset: cursor
        }
      ]);
    }
    (_c = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _c.scene.resetCursor();
  }
  async _handleEditorInvisible(param) {
    const editCellState = this._editorBridgeService.getEditCellState();
    const documentDataModel = this._univerInstanceService.getUnit(DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
    const snapshot = Tools.deepClone(documentDataModel == null ? void 0 : documentDataModel.getSnapshot());
    let { keycode } = param;
    this._cursorChange = 0 /* InitialState */;
    this._exitInput(param);
    if (editCellState == null) {
      return;
    }
    const editorIsDirty = this._editorBridgeService.getEditorDirty();
    if (editorIsDirty === false) {
      keycode = 27 /* ESC */;
    }
    const workbook = this._context.unit;
    const worksheet = workbook.getActiveSheet();
    const workbookId = this._context.unitId;
    const worksheetId = worksheet.getSheetId();
    const { unitId, sheetId } = editCellState;
    if (workbookId === unitId && sheetId !== worksheetId) {
      await this._commandService.executeCommand(SetWorksheetActivateCommand.id, {
        subUnitId: sheetId,
        unitId
      });
    }
    if (keycode === 27 /* ESC */) {
      if (this._editorBridgeService.isForceKeepVisible()) {
        this._editorBridgeService.disableForceKeepVisible();
      }
      const selections = this._workbookSelections.getCurrentSelections();
      if (selections) {
        this._contextService.setContextValue(REF_SELECTIONS_ENABLED, false);
        this._commandService.syncExecuteCommand(SetSelectionsOperation.id, {
          unitId: this._context.unit.getUnitId(),
          subUnitId: sheetId,
          selections
        });
      }
      return;
    }
    if (snapshot) {
      const res = await this._submitCellData(snapshot);
      if (res === false) {
        return;
      }
    }
    this._moveSelection(keycode);
  }
  _getEditorObject() {
    return getEditorObject(this._editorBridgeService.getCurrentEditorId(), this._renderManagerService);
  }
  submitCellData(documentDataModel) {
    return this._submitCellData(documentDataModel.getSnapshot());
  }
  async _submitCellData(snapshot) {
    const editCellState = this._editorBridgeService.getEditCellState();
    if (editCellState == null) {
      return true;
    }
    const { unitId, sheetId, row, column } = editCellState;
    const workbook = this._context.unit;
    let worksheet = workbook.getActiveSheet();
    const setRangeValueTargetSheet = workbook.getSheetBySheetId(sheetId);
    if (!setRangeValueTargetSheet) {
      return true;
    }
    worksheet = workbook.getActiveSheet();
    const cellData = getCellDataByInput(
      { ...worksheet.getCellRaw(row, column) || {} },
      snapshot,
      this._lexerTreeBuilder,
      this._localService,
      this._functionService,
      workbook.getStyles()
    );
    if (!cellData) {
      return true;
    }
    const finalCell = this._sheetInterceptorService.onWriteCell(workbook, worksheet, row, column, cellData);
    if (finalCell === worksheet.getCellRaw(row, column)) {
      return true;
    }
    const redoUndoId = generateRandomId(6);
    const res = this._commandService.syncExecuteCommand(SetRangeValuesCommand.id, {
      subUnitId: sheetId,
      unitId,
      range: {
        startRow: row,
        startColumn: column,
        endRow: row,
        endColumn: column
      },
      value: cellData,
      redoUndoId
    });
    if (res) {
      const isValid = await this._sheetInterceptorService.onValidateCell(workbook, worksheet, row, column);
      if (isValid === false) {
        this._undoRedoService.rollback(redoUndoId, unitId);
        return false;
      }
    }
    return true;
  }
  _exitInput(param) {
    var _a;
    this._contextService.setContextValue(FOCUSING_EDITOR_INPUT_FORMULA, false);
    this._contextService.setContextValue(EDITOR_ACTIVATED, false);
    this._contextService.setContextValue(FOCUSING_EDITOR_BUT_HIDDEN, false);
    this._contextService.setContextValue(FOCUSING_FX_BAR_EDITOR, false);
    this._cellEditorManagerService.setState({
      show: param.visible
    });
    const editorObject = this._getEditorObject();
    (_a = editorObject == null ? void 0 : editorObject.scene.getViewport("viewMain" /* VIEW_MAIN */)) == null ? void 0 : _a.scrollToViewportPos({
      viewportScrollX: 0,
      viewportScrollY: 0
    });
    const editorUnitId = this._editorBridgeService.getCurrentEditorId();
    if (editorUnitId == null || !this._editorService.isSheetEditor(editorUnitId)) {
      return;
    }
    this._undoRedoService.clearUndoRedo(editorUnitId);
    this._undoRedoService.clearUndoRedo(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY);
  }
  _moveSelection(keycode) {
    if (keycode == null || !MOVE_SELECTION_KEYCODE_LIST.includes(keycode)) {
      return;
    }
    let direction = 3 /* LEFT */;
    switch (keycode) {
      case 13 /* ENTER */:
        direction = 2 /* DOWN */;
        break;
      case 9 /* TAB */:
        direction = 1 /* RIGHT */;
        break;
      case 40 /* ARROW_DOWN */:
        direction = 2 /* DOWN */;
        break;
      case 38 /* ARROW_UP */:
        direction = 0 /* UP */;
        break;
      case 37 /* ARROW_LEFT */:
        direction = 3 /* LEFT */;
        break;
      case 39 /* ARROW_RIGHT */:
        direction = 1 /* RIGHT */;
        break;
    }
    if (keycode === 13 /* ENTER */ || keycode === 9 /* TAB */) {
      this._commandService.executeCommand(MoveSelectionEnterAndTabCommand.id, {
        keycode,
        direction
      });
    } else {
      this._commandService.executeCommand(MoveSelectionCommand.id, {
        direction
      });
    }
  }
  /**
   * The user's operations follow the sequence of opening the editor and then moving the cursor.
   * The logic here predicts the user's first cursor movement behavior based on this rule
   */
  _cursorStateListener(d) {
    const editorObject = this._getEditorObject();
    if (!(editorObject == null ? void 0 : editorObject.document)) return;
    const { document: documentComponent } = editorObject;
    d.add(toDisposable(documentComponent.onPointerDown$.subscribeEvent(() => {
      if (this._cursorChange === 1 /* StartEditor */) {
        this._cursorChange = 2 /* CursorChange */;
      }
    })));
  }
  // TODO: @JOCS, is it necessary to move these commands MoveSelectionOperation\MoveCursorOperation to shortcut? and use multi-commands?
  _moveInEditor(keycode, isShift) {
    let direction = 3 /* LEFT */;
    if (keycode === 40 /* ARROW_DOWN */) {
      direction = 2 /* DOWN */;
    } else if (keycode === 38 /* ARROW_UP */) {
      direction = 0 /* UP */;
    } else if (keycode === 39 /* ARROW_RIGHT */) {
      direction = 1 /* RIGHT */;
    }
    if (isShift) {
      this._commandService.executeCommand(MoveSelectionOperation.id, {
        direction
      });
    } else {
      this._commandService.executeCommand(MoveCursorOperation.id, {
        direction
      });
    }
  }
  _getDocumentDataModel() {
    return this._univerInstanceService.getUnit(DOCS_NORMAL_EDITOR_UNIT_ID_KEY, O.UNIVER_DOC);
  }
  // WTF: this is should not exist at all. It is because all editor instances reuse the singleton
  // "DocSelectionManagerService" and other modules. Which will be refactored soon in August, 2024.
  _isCurrentSheetFocused() {
    var _a;
    return ((_a = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : _a.getUnitId()) === this._context.unitId;
  }
  _getEditorSkeleton(editorId) {
    var _a;
    return (_a = this._renderManagerService.getRenderById(editorId)) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
  }
  _getEditorViewModel(editorId) {
    var _a;
    return (_a = this._renderManagerService.getRenderById(editorId)) == null ? void 0 : _a.with(DocSkeletonManagerService).getViewModel();
  }
  _emptyDocumentDataModel(documentStyle, removeStyle) {
    const empty = (documentDataModel2, resetDocumentStyle) => {
      const snapshot = Tools.deepClone(documentDataModel2.getSnapshot());
      const documentViewModel = this._getEditorViewModel(documentDataModel2.getUnitId());
      if (documentViewModel == null) {
        return;
      }
      emptyBody(snapshot.body, removeStyle);
      if (resetDocumentStyle) {
        snapshot.documentStyle = documentStyle;
      }
      snapshot.drawings = {};
      snapshot.drawingsOrder = [];
      documentDataModel2.reset(snapshot);
      documentViewModel.reset(documentDataModel2);
    };
    const documentDataModel = this._getDocumentDataModel();
    documentDataModel && empty(documentDataModel, true);
    const formulaDocument = this._univerInstanceService.getUnit(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY, O.UNIVER_DOC);
    formulaDocument && empty(formulaDocument);
  }
};
EditingRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetsSelectionsService)),
  __decorateParam(2, IUndoRedoService),
  __decorateParam(3, IContextService),
  __decorateParam(4, IRenderManagerService),
  __decorateParam(5, IEditorBridgeService),
  __decorateParam(6, ICellEditorManagerService),
  __decorateParam(7, Inject(LexerTreeBuilder)),
  __decorateParam(8, IFunctionService),
  __decorateParam(9, Inject(DocSelectionManagerService)),
  __decorateParam(10, ICommandService),
  __decorateParam(11, Inject(LocaleService)),
  __decorateParam(12, IEditorService),
  __decorateParam(13, Inject(SheetCellEditorResizeService)),
  __decorateParam(14, IUniverInstanceService),
  __decorateParam(15, Inject(SheetInterceptorService))
], EditingRenderController);
function getCellDataByInput(cellData, snapshot, lexerTreeBuilder, localeService, functionService, styles) {
  var _a, _b, _c;
  if ((snapshot == null ? void 0 : snapshot.body) == null) {
    return null;
  }
  const { body } = snapshot;
  cellData.t = void 0;
  const data = body.dataStream;
  const lastString = data.substring(data.length - 2, data.length);
  let newDataStream = lastString === DEFAULT_EMPTY_DOCUMENT_VALUE ? data.substring(0, data.length - 2) : data;
  const currentLocale = localeService.getCurrentLocale();
  newDataStream = normalizeString(newDataStream, lexerTreeBuilder, currentLocale, functionService);
  if ((_a = snapshot.drawingsOrder) == null ? void 0 : _a.length) {
    cellData.v = "";
    cellData.f = null;
    cellData.si = null;
    cellData.p = snapshot;
    cellData.t = 1 /* STRING */;
  } else if (cellData.s && isTextFormat((_c = (_b = styles == null ? void 0 : styles.get(cellData.s)) == null ? void 0 : _b.n) == null ? void 0 : _c.pattern)) {
    cellData.v = newDataStream;
    cellData.f = null;
    cellData.si = null;
    cellData.p = null;
    cellData.t = 1 /* STRING */;
    if (isRichText(body) && body.dataStream !== "\r\n") {
      cellData.p = snapshot;
    }
    const style = getCellStyleBySnapshot(snapshot);
    if (style) {
      cellData.s = style;
    }
  } else if (isFormulaString(newDataStream)) {
    if (cellData.f === newDataStream) {
      return null;
    }
    const bracketCount = lexerTreeBuilder.checkIfAddBracket(newDataStream);
    for (let i = 0; i < bracketCount; i++) {
      newDataStream += ")" /* CLOSE_BRACKET */;
    }
    cellData.f = newDataStream;
    cellData.si = null;
    cellData.v = null;
    cellData.p = null;
  } else if (isForceString(newDataStream)) {
    const v = extractStringFromForceString(newDataStream);
    cellData.v = v;
    cellData.f = null;
    cellData.si = null;
    cellData.p = null;
    cellData.t = 4 /* FORCE_STRING */;
  } else if (isRichText(body)) {
    if (body.dataStream === "\r\n") {
      cellData.v = "";
      cellData.f = null;
      cellData.si = null;
      cellData.p = null;
    } else {
      cellData.p = snapshot;
      cellData.v = null;
      cellData.f = null;
      cellData.si = null;
    }
  } else {
    if (newDataStream === "" && cellData.v == null && cellData.p == null) {
      return null;
    }
    cellData.v = newDataStream;
    cellData.f = null;
    cellData.si = null;
    cellData.p = null;
    const style = getCellStyleBySnapshot(snapshot);
    if (style) {
      cellData.s = style;
    }
  }
  return cellData;
}
function isRichText(body) {
  const { textRuns = [], paragraphs = [], customRanges, customBlocks = [] } = body;
  const bodyNoLineBreak = body.dataStream.replace(/(\r\n)+$/, "");
  const richTextStyle = ["va"];
  return (
    // This is because after editing, an inexplicable second paragraph style will appear \r\n
    textRuns.filter((ts) => ts.st < bodyNoLineBreak.length).some((textRun) => {
      var _a;
      const hasRichTextStyle = Boolean(textRun.ts && Object.keys(textRun.ts).some((property) => {
        return richTextStyle.includes(property);
      }));
      return hasRichTextStyle || Object.keys((_a = textRun.ts) != null ? _a : {}).length && textRun.ed - textRun.st < bodyNoLineBreak.length;
    }) || paragraphs.some((paragraph) => paragraph.bullet) || paragraphs.length >= 2 || Boolean(customRanges == null ? void 0 : customRanges.length) || customBlocks.length > 0
  );
}
function getCellStyleBySnapshot(snapshot) {
  const { body } = snapshot;
  if (!body) return null;
  const { textRuns = [] } = body;
  let style = {};
  const bodyNoLineBreak = body.dataStream.replace("\r\n", "");
  textRuns.forEach((textRun) => {
    const { st, ed, ts } = textRun;
    if (ed - st >= bodyNoLineBreak.length) {
      style = { ...style, ...ts };
    }
  });
  if (Object.keys(style).length) {
    return style;
  }
  return null;
}
function emptyBody(body, removeStyle = false) {
  body.dataStream = DEFAULT_EMPTY_DOCUMENT_VALUE;
  if (body.textRuns != null) {
    if (body.textRuns.length === 1 && !removeStyle) {
      body.textRuns[0].st = 0;
      body.textRuns[0].ed = 1;
    } else {
      body.textRuns = void 0;
    }
  }
  if (body.paragraphs != null) {
    body.paragraphs = [
      {
        startIndex: 0
      }
    ];
  }
  if (body.sectionBreaks != null) {
    body.sectionBreaks = void 0;
  }
  if (body.tables != null) {
    body.tables = void 0;
  }
  if (body.customRanges != null) {
    body.customRanges = void 0;
  }
  if (body.customBlocks != null) {
    body.customBlocks = void 0;
  }
}

// ../packages/sheets-ui/src/controllers/clipboard/utils.ts
function getDefaultOnPasteCellMutations(pasteFrom, pasteTo, data, payload, accessor) {
  const redoMutationsInfo = [];
  const undoMutationsInfo = [];
  if (payload.copyType === "CUT" /* CUT */) {
    const { undos, redos } = getMoveRangeMutations(pasteFrom, pasteTo, accessor);
    redoMutationsInfo.push(...redos);
    undoMutationsInfo.push(...undos);
  } else {
    const { undos: clearStyleUndos, redos: clearStyleRedos } = getClearCellStyleMutations(pasteTo, data, accessor);
    redoMutationsInfo.push(...clearStyleRedos);
    undoMutationsInfo.push(...clearStyleUndos);
    const { undos: clearValueUndos, redos: clearValueRedos } = getClearCellValueMutations(pasteTo, data, accessor);
    redoMutationsInfo.push(...clearValueRedos);
    undoMutationsInfo.push(...clearValueUndos);
    const { undos: setValuesUndos, redos: setValuesRedos } = getSetCellValueMutations(pasteTo, pasteFrom, data, accessor);
    redoMutationsInfo.push(...setValuesRedos);
    undoMutationsInfo.push(...setValuesUndos);
    const { undos: setStyleUndos, redos: setStyleRedos } = getSetCellStyleMutations(pasteTo, data, accessor, true);
    redoMutationsInfo.push(...setStyleRedos);
    undoMutationsInfo.push(...setStyleUndos);
    const { undos: clearMergeUndos, redos: clearMergeRedos } = getClearAndSetMergeMutations(
      pasteTo,
      data,
      accessor
    );
    redoMutationsInfo.push(...clearMergeRedos);
    undoMutationsInfo.push(...clearMergeUndos);
  }
  return {
    undos: undoMutationsInfo,
    redos: redoMutationsInfo
  };
}
function getMoveRangeMutations(from, to, accessor) {
  let redos = [];
  let undos = [];
  const { range: fromDiscreteRange, subUnitId: fromSubUnitId, unitId } = from;
  const { range: toDiscreteRange, subUnitId: toSubUnitId } = to;
  const toRange = toDiscreteRange ? discreteRangeToRange(toDiscreteRange) : null;
  const fromRange = fromDiscreteRange ? discreteRangeToRange(fromDiscreteRange) : null;
  if (fromRange && toRange) {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const workbook = univerInstanceService.getUniverSheetInstance(unitId);
    const fromWorksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(fromSubUnitId);
    const toWorksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(toSubUnitId);
    if (fromWorksheet && toWorksheet) {
      const fromCellValue = new ObjectMatrix();
      const newFromCellValue = new ObjectMatrix();
      const fromCellMatrix = fromWorksheet.getCellMatrix();
      const toCellMatrix = toWorksheet.getCellMatrix();
      Range.foreach(fromRange, (row, col) => {
        fromCellValue.setValue(row, col, Tools.deepClone(fromCellMatrix.getValue(row, col)));
        newFromCellValue.setValue(row, col, null);
      });
      const toCellValue = new ObjectMatrix();
      Range.foreach(toRange, (row, col) => {
        toCellValue.setValue(row, col, Tools.deepClone(toCellMatrix.getValue(row, col)));
      });
      const newToCellValue = new ObjectMatrix();
      Range.foreach(fromRange, (row, col) => {
        const cellRange = cellToRange(row, col);
        const relativeRange = Rectangle.getRelativeRange(cellRange, fromRange);
        const range = Rectangle.getPositionRange(relativeRange, toRange);
        newToCellValue.setValue(range.startRow, range.startColumn, fromCellMatrix.getValue(row, col));
      });
      const doMoveRangeMutation = {
        fromRange,
        toRange,
        from: {
          value: newFromCellValue.getMatrix(),
          subUnitId: fromSubUnitId
        },
        to: {
          value: newToCellValue.getMatrix(),
          subUnitId: toSubUnitId
        },
        unitId
      };
      const undoMoveRangeMutation = {
        fromRange: toRange,
        toRange: fromRange,
        from: {
          value: fromCellValue.getMatrix(),
          subUnitId: fromSubUnitId
        },
        to: {
          value: toCellValue.getMatrix(),
          subUnitId: toSubUnitId
        },
        unitId
      };
      const interceptorCommands = sheetInterceptorService.onCommandExecute({
        id: MoveRangeCommand.id,
        params: { toRange, fromRange }
      });
      const fromMergeData = fromWorksheet.getMergeData();
      const toMergeData = toWorksheet.getMergeData();
      const fromMergeRanges = fromMergeData.filter((item) => Rectangle.intersects(item, fromRange));
      const toMergeRanges = toMergeData.filter((item) => Rectangle.intersects(item, toRange));
      const willMoveToMergeRanges = fromMergeRanges.map((mergeRange) => Rectangle.getRelativeRange(mergeRange, fromRange)).map((relativeRange) => Rectangle.getPositionRange(relativeRange, toRange));
      const addMergeCellRanges = getAddMergeMutationRangeByType(willMoveToMergeRanges);
      const mergeRedos = [
        {
          id: RemoveWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId: fromSubUnitId,
            ranges: fromMergeRanges
          }
        },
        {
          id: RemoveWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId: fromSubUnitId,
            ranges: toMergeRanges
          }
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId: toSubUnitId,
            ranges: addMergeCellRanges
          }
        }
      ];
      const mergeUndos = [
        {
          id: RemoveWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId: toSubUnitId,
            ranges: addMergeCellRanges
          }
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId: toSubUnitId,
            ranges: toMergeRanges
          }
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId: fromSubUnitId,
            ranges: fromMergeRanges
          }
        }
      ];
      redos = [
        { id: MoveRangeMutation.id, params: doMoveRangeMutation },
        ...interceptorCommands.redos,
        ...mergeRedos,
        {
          id: SetSelectionsOperation.id,
          params: {
            unitId,
            subUnitId: toSubUnitId,
            selections: [{ range: toRange }],
            type: 2 /* MOVE_END */
          }
        }
      ];
      undos = [
        { id: MoveRangeMutation.id, params: undoMoveRangeMutation },
        ...interceptorCommands.undos,
        ...mergeUndos,
        {
          id: SetSelectionsOperation.id,
          params: {
            unitId,
            subUnitId: fromSubUnitId,
            type: 2 /* MOVE_END */,
            selections: [{ range: fromRange }]
          }
        }
      ];
    }
  }
  return {
    undos,
    redos
  };
}
function getSetCellValueMutations(pasteTo, pasteFrom, matrix, accessor) {
  const { unitId, subUnitId, range } = pasteTo;
  const redoMutationsInfo = [];
  const undoMutationsInfo = [];
  const { mapFunc } = virtualizeDiscreteRanges([range]);
  const valueMatrix = new ObjectMatrix();
  matrix.forValue((row, col, value) => {
    var _a;
    let originNumberValue;
    if (!value.p && value.v && !pasteFrom) {
      const content = String(value.v);
      const numfmtValue = numfmt.parseValue(content);
      if ((numfmtValue == null ? void 0 : numfmtValue.v) !== void 0 && typeof numfmtValue.v === "number") {
        originNumberValue = numfmtValue.v;
      }
    }
    const { row: realRow, col: realCol } = mapFunc(row, col);
    if (((_a = value.p) == null ? void 0 : _a.body) && isRichText(value.p.body)) {
      const newValue = Tools.deepClone({ p: value.p, v: originNumberValue != null ? originNumberValue : value.v });
      valueMatrix.setValue(realRow, realCol, newValue);
    } else {
      valueMatrix.setValue(realRow, realCol, Tools.deepClone({ v: originNumberValue != null ? originNumberValue : value.v, t: value.t }));
    }
  });
  const setValuesMutation = {
    unitId,
    subUnitId,
    cellValue: Tools.deepClone(valueMatrix.getMatrix())
  };
  redoMutationsInfo.push({
    id: SetRangeValuesMutation.id,
    params: setValuesMutation
  });
  const undoSetValuesMutation = SetRangeValuesUndoMutationFactory(
    accessor,
    setValuesMutation
  );
  undoMutationsInfo.push({
    id: SetRangeValuesMutation.id,
    params: undoSetValuesMutation
  });
  return {
    undos: undoMutationsInfo,
    redos: redoMutationsInfo
  };
}
function getSetCellStyleMutations(pasteTo, matrix, accessor, withRichFormat = false) {
  const redoMutationsInfo = [];
  const undoMutationsInfo = [];
  const { unitId, subUnitId, range } = pasteTo;
  const valueMatrix = new ObjectMatrix();
  const { mapFunc } = virtualizeDiscreteRanges([range]);
  matrix.forValue((row, col, value) => {
    var _a;
    const newValue = {
      s: Object.assign({}, {
        ...DEFAULT_STYLES,
        pd: DEFAULT_PADDING_DATA,
        bg: null,
        cl: null
      }, value.s)
    };
    const cellBd = newValue.s.bd;
    if (cellBd) {
      const isValid = Object.keys(cellBd).length > 0;
      if (!isValid) {
        newValue.s.bd = {
          b: null,
          l: null,
          r: null,
          t: null
        };
      }
    }
    const content = String(value.v);
    const numfmtValue = numfmt.parseValue(content);
    if (numfmtValue == null ? void 0 : numfmtValue.z) {
      if (!newValue.s) {
        newValue.s = {};
      }
      if (typeof newValue.s === "object") {
        if (!((_a = newValue.s) == null ? void 0 : _a.n)) {
          newValue.s.n = { pattern: numfmtValue.z };
        } else {
          newValue.s.n.pattern = numfmtValue.z;
        }
      }
    }
    const { row: actualRow, col: actualCol } = mapFunc(row, col);
    valueMatrix.setValue(actualRow, actualCol, newValue);
  });
  const setValuesMutation = {
    unitId,
    subUnitId,
    cellValue: Tools.deepClone(valueMatrix.getMatrix())
  };
  redoMutationsInfo.push({
    id: SetRangeValuesMutation.id,
    params: setValuesMutation
  });
  const undoSetValuesMutation = SetRangeValuesUndoMutationFactory(
    accessor,
    setValuesMutation
  );
  undoMutationsInfo.push({
    id: SetRangeValuesMutation.id,
    params: undoSetValuesMutation
  });
  return {
    undos: undoMutationsInfo,
    redos: redoMutationsInfo
  };
}
function getClearCellStyleMutations(pasteTo, matrix, accessor) {
  const redoMutationsInfo = [];
  const undoMutationsInfo = [];
  const clearStyleMatrix = new ObjectMatrix();
  const { unitId, subUnitId, range } = pasteTo;
  const { mapFunc } = virtualizeDiscreteRanges([range]);
  matrix.forEach((rowIndex, row) => {
    Object.keys(row).forEach((colIndexStr) => {
      const colIndex = Number(colIndexStr);
      const { row: actualRow, col: actualCol } = mapFunc(rowIndex, colIndex);
      clearStyleMatrix.setValue(actualRow, actualCol, { s: null });
    });
  });
  if (clearStyleMatrix.getLength() > 0) {
    const clearMutation = {
      subUnitId,
      unitId,
      cellValue: Tools.deepClone(clearStyleMatrix.getMatrix())
    };
    redoMutationsInfo.push({
      id: SetRangeValuesMutation.id,
      params: clearMutation
    });
    const undoClearMutation = SetRangeValuesUndoMutationFactory(
      accessor,
      clearMutation
    );
    undoMutationsInfo.push({
      id: SetRangeValuesMutation.id,
      params: undoClearMutation
    });
  }
  return { undos: undoMutationsInfo, redos: redoMutationsInfo };
}
function getClearCellValueMutations(pasteTo, matrix, accessor) {
  const redoMutationsInfo = [];
  const undoMutationsInfo = [];
  const clearValueMatrix = new ObjectMatrix();
  const { unitId, subUnitId, range } = pasteTo;
  const { mapFunc } = virtualizeDiscreteRanges([range]);
  matrix.forValue((row, col, _value) => {
    const { row: actualRow, col: actualCol } = mapFunc(row, col);
    clearValueMatrix.setValue(actualRow, actualCol, { v: null, p: null });
  });
  if (clearValueMatrix.getLength() > 0) {
    const clearMutation = {
      subUnitId,
      unitId,
      cellValue: Tools.deepClone(clearValueMatrix.getMatrix())
    };
    redoMutationsInfo.push({
      id: SetRangeValuesMutation.id,
      params: clearMutation
    });
    const undoClearMutation = SetRangeValuesUndoMutationFactory(
      accessor,
      clearMutation
    );
    undoMutationsInfo.push({
      id: SetRangeValuesMutation.id,
      params: undoClearMutation
    });
  }
  return { undos: undoMutationsInfo, redos: redoMutationsInfo };
}
function getClearAndSetMergeMutations(pasteTo, matrix, accessor) {
  const redoMutationsInfo = [];
  const undoMutationsInfo = [];
  const { unitId, subUnitId, range } = pasteTo;
  const { startColumn, startRow, endColumn, endRow } = discreteRangeToRange(range);
  const hasMerge = false;
  const mergeRangeData = [];
  matrix.forValue((row, col, value) => {
    if (value.rowSpan && value.rowSpan > 1) {
      const colSpan = value.colSpan || 1;
      const mergeRange = {
        startRow: startRow + row,
        endRow: startRow + row + value.rowSpan - 1,
        startColumn: startColumn + col,
        endColumn: startColumn + col + colSpan - 1
      };
      mergeRangeData.push(mergeRange);
    } else if (value.colSpan && value.colSpan > 1) {
      const rowSpan = value.rowSpan || 1;
      const mergeRange = {
        startRow: startRow + row,
        endRow: startRow + row + rowSpan - 1,
        startColumn: startColumn + col,
        endColumn: startColumn + col + value.colSpan - 1
      };
      mergeRangeData.push(mergeRange);
    }
  });
  const currentService = accessor.get(IUniverInstanceService);
  const workbook = currentService.getUniverSheetInstance(unitId);
  const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
  if (workbook && worksheet) {
    const mergeData = worksheet.getMergeData();
    const mergedCellsInRange = mergeData.filter(
      (rect) => Rectangle.intersects({ startRow, startColumn, endRow, endColumn }, rect)
    );
    const removeMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: mergedCellsInRange
    };
    redoMutationsInfo.push({
      id: RemoveWorksheetMergeMutation.id,
      params: removeMergeMutationParams
    });
    const undoRemoveMergeMutationParams = RemoveMergeUndoMutationFactory(
      accessor,
      removeMergeMutationParams
    );
    undoMutationsInfo.push({
      id: AddWorksheetMergeMutation.id,
      params: undoRemoveMergeMutationParams
    });
  }
  const addMergeMutationParams = {
    unitId,
    subUnitId,
    ranges: mergeRangeData
  };
  if (mergeRangeData.length > 0) {
    redoMutationsInfo.push({
      id: AddWorksheetMergeMutation.id,
      params: addMergeMutationParams
    });
  }
  const undoAddMergeMutation = AddMergeUndoMutationFactory(
    accessor,
    addMergeMutationParams
  );
  if (mergeRangeData.length > 0) {
    undoMutationsInfo.push({
      id: RemoveWorksheetMergeMutation.id,
      params: undoAddMergeMutation
    });
  }
  return { undos: undoMutationsInfo, redos: redoMutationsInfo };
}
function generateBody(text) {
  if (!text.includes("\r") && Tools.isLegalUrl(text)) {
    const id = generateRandomId();
    const urlText = `${text}`;
    const range = {
      startIndex: 0,
      endIndex: urlText.length - 1,
      rangeId: id,
      rangeType: 0 /* HYPERLINK */,
      properties: {
        url: text
      }
    };
    return {
      dataStream: `${urlText}\r
`,
      paragraphs: [{
        startIndex: urlText.length
      }],
      customRanges: [range]
    };
  }
  let dataStream = text.replace(/(\r\n|\n)/g, "\r");
  if (!dataStream.endsWith("\r\n")) {
    dataStream += "\r\n";
  }
  const paragraphs = [];
  for (let i = 0; i < dataStream.length; i++) {
    if (dataStream[i] === "\r") {
      paragraphs.push({ startIndex: i });
    }
  }
  return {
    dataStream,
    paragraphs,
    sectionBreaks: [{ startIndex: dataStream.indexOf("\n") }]
  };
}

// ../packages/sheets-ui/src/controllers/clipboard/clipboard.controller.ts
var shouldRemoveShapeIds = [
  InsertColMutation.id,
  InsertRowMutation.id,
  RemoveColMutation.id,
  RemoveRowMutation.id,
  MoveRangeMutation.id,
  MoveRowsMutation.id,
  MoveColsMutation.id
];
var SheetClipboardController = class extends RxDisposable {
  constructor(_injector, _instanceService, _renderManagerService, _commandService, _contextService, _configService, _sheetClipboardService, _messageService, _localService, _uiPartsService) {
    super();
    this._injector = _injector;
    this._instanceService = _instanceService;
    this._renderManagerService = _renderManagerService;
    this._commandService = _commandService;
    this._contextService = _contextService;
    this._configService = _configService;
    this._sheetClipboardService = _sheetClipboardService;
    this._messageService = _messageService;
    this._localService = _localService;
    this._uiPartsService = _uiPartsService;
    __publicField(this, "_refreshOptionalPaste$", new Subject());
    __publicField(this, "refreshOptionalPaste$", this._refreshOptionalPaste$.asObservable());
    this._init();
    this._initCommandListener();
    this._initUIComponents();
    this._pasteWithDoc();
  }
  refreshOptionalPaste() {
    this._refreshOptionalPaste$.next(Math.random());
  }
  _pasteWithDoc() {
    var _a;
    const sheetPasteShortKeyFn = (docSelectionRenderService2) => {
      docSelectionRenderService2.onPaste$.pipe(takeUntil(this.dispose$)).subscribe((config) => {
        var _a2, _b;
        if (!whenSheetEditorFocused(this._contextService)) {
          return;
        }
        config.event.preventDefault();
        const clipboardEvent = config.event;
        const htmlContent = (_a2 = clipboardEvent.clipboardData) == null ? void 0 : _a2.getData("text/html");
        const textContent = (_b = clipboardEvent.clipboardData) == null ? void 0 : _b.getData("text/plain");
        const files = this._resolveClipboardFiles(clipboardEvent.clipboardData);
        this._commandService.executeCommand(SheetPasteShortKeyCommand.id, { htmlContent, textContent, files });
      });
    };
    let docSelectionRenderService = (_a = this._renderManagerService.getRenderById(DOCS_NORMAL_EDITOR_UNIT_ID_KEY)) == null ? void 0 : _a.with(DocSelectionRenderService);
    if (docSelectionRenderService) {
      sheetPasteShortKeyFn(docSelectionRenderService);
    }
    this._renderManagerService.created$.subscribe((renderer) => {
      var _a2;
      if (renderer.unitId === DOCS_NORMAL_EDITOR_UNIT_ID_KEY) {
        docSelectionRenderService = (_a2 = this._renderManagerService.getRenderById(DOCS_NORMAL_EDITOR_UNIT_ID_KEY)) == null ? void 0 : _a2.with(DocSelectionRenderService);
        if (docSelectionRenderService) {
          sheetPasteShortKeyFn(docSelectionRenderService);
        }
      }
    });
  }
  _resolveClipboardFiles(clipboardData) {
    if (!clipboardData) {
      return;
    }
    const files = Array.from(clipboardData.items).map((item) => item.kind === "file" ? item.getAsFile() : void 0).filter(Boolean);
    return files.length > 0 ? files : void 0;
  }
  _init() {
    [SheetCopyCommand, SheetCutCommand, SheetPasteCommand].forEach(
      (command) => this.disposeWithMe(this._commandService.registerMultipleCommand(command))
    );
    [
      SheetPasteValueCommand,
      SheetPasteFormatCommand,
      SheetPasteColWidthCommand,
      SheetPasteBesidesBorderCommand,
      SheetPasteShortKeyCommand,
      SheetOptionalPasteCommand
    ].forEach((command) => this.disposeWithMe(this._commandService.registerCommand(command)));
    this.disposeWithMe(this._sheetClipboardService.addClipboardHook(this._initCopyingHooks()));
    this.disposeWithMe(this._sheetClipboardService.addClipboardHook(this._initPastingHook()));
    const disposables = this._initSpecialPasteHooks().map(
      (hook) => this._sheetClipboardService.addClipboardHook(hook)
    );
    this.disposeWithMe({ dispose: () => disposables.forEach((d) => d.dispose()) });
  }
  // eslint-disable-next-line max-lines-per-function
  _initCopyingHooks() {
    const self = this;
    let currentSheet = null;
    return {
      id: PREDEFINED_HOOK_NAME.DEFAULT_COPY,
      isDefaultHook: true,
      onBeforeCopy(unitId, subUnitId) {
        currentSheet = self._getWorksheet(unitId, subUnitId);
      },
      onCopyCellContent(row, col) {
        var _a, _b, _c, _d;
        const cell = currentSheet.getCell(row, col);
        if (((_b = (_a = cell == null ? void 0 : cell.p) == null ? void 0 : _a.body) == null ? void 0 : _b.paragraphs) || ((_d = (_c = cell == null ? void 0 : cell.p) == null ? void 0 : _c.body) == null ? void 0 : _d.textRuns)) {
          return convertBodyToHtml(cell.p.body);
        }
        const content = cell ? extractPureTextFromCell(cell) : "";
        return content;
      },
      onCopyCellStyle: (row, col, rowSpan, colSpan) => {
        const properties = {};
        if (rowSpan || colSpan) {
          properties.rowspan = `${rowSpan || 1}`;
          properties.colspan = `${colSpan || 1}`;
        }
        const range = currentSheet.getRange(row, col);
        const mergedCellByRowCol = currentSheet.getMergedCell(row, col);
        const textStyle = range.getTextStyle();
        let style = "";
        if (textStyle) {
          style = handleStyleToString(textStyle);
        }
        if (mergedCellByRowCol) {
          const endRow = mergedCellByRowCol.endRow;
          const endColumn = mergedCellByRowCol.endColumn;
          const lastRange = currentSheet.getRange(endRow, endColumn);
          const lastTextStyle = lastRange.getTextStyle();
          if (lastTextStyle) {
            const lastStyle = handleStyleToString(lastTextStyle);
            if (style) {
              style += lastStyle ? `;${lastStyle}` : "";
            } else {
              style = lastStyle;
            }
          }
        }
        if (style) {
          properties.style = style;
        }
        return Object.keys(properties).length ? properties : null;
      },
      onCopyColumn(col) {
        const sheet = currentSheet;
        const width = sheet.getColumnWidth(col);
        return {
          width: `${width}`
        };
      },
      onCopyRow(row) {
        const sheet = currentSheet;
        const height = sheet.getRowHeight(row);
        return {
          style: `height: ${height}px;`
        };
      },
      onAfterCopy() {
        currentSheet = null;
      },
      getFilteredOutRows(range) {
        var _a;
        const { startRow, endRow } = range;
        const worksheet = (_a = self._instanceService.getCurrentUnitForType(O.UNIVER_SHEET)) == null ? void 0 : _a.getActiveSheet();
        const res = [];
        if (!worksheet) {
          return res;
        }
        for (let r = startRow; r <= endRow; r++) {
          if (worksheet.getRowFiltered(r)) {
            res.push(r);
          }
        }
        return res;
      }
    };
  }
  // eslint-disable-next-line max-lines-per-function
  _initPastingHook() {
    const self = this;
    let unitId = null;
    let subUnitId = null;
    let currentSheet = null;
    return {
      id: PREDEFINED_HOOK_NAME.DEFAULT_PASTE,
      isDefaultHook: true,
      onBeforePaste({ unitId: unitId_, subUnitId: subUnitId_, range }) {
        currentSheet = self._getWorksheet(unitId_, subUnitId_);
        unitId = unitId_;
        subUnitId = subUnitId_;
        const maxConfig = self._configService.getConfig(MAX_CELL_PER_SHEET_KEY);
        const endRow = range.rows[range.rows.length - 1];
        const endColumn = range.cols[range.cols.length - 1];
        if (maxConfig && endRow * endColumn > maxConfig) {
          self._messageService.show({
            type: "error" /* Error */,
            content: self._localService.t("clipboard.paste.exceedMaxCells")
          });
          return false;
        }
        return true;
      },
      // eslint-disable-next-line max-lines-per-function
      onPasteRows(pasteTo, rowProperties) {
        const { range } = pasteTo;
        const redoMutations = [];
        const undoMutations = [];
        const maxRow = currentSheet.getMaxRows();
        const rowCount = maxRow - 1;
        const addingRowsCount = range.rows[range.rows.length - 1] - rowCount;
        const existingRowsCount = rowProperties.length - addingRowsCount;
        const rowManager = currentSheet.getRowManager();
        if (addingRowsCount > 0) {
          const rowInfo = {};
          rowProperties.slice(existingRowsCount).forEach((property, index) => {
            const { height: PropertyHeight } = property || {};
            if (PropertyHeight) {
              rowInfo[index] = {
                h: Number.parseFloat(PropertyHeight),
                hd: 0 /* FALSE */
              };
            }
          });
          const addRowRange = {
            startColumn: range.cols[0],
            endColumn: range.cols[range.cols.length - 1],
            endRow: range.rows[range.rows.length - 1],
            startRow: maxRow
          };
          const addRowMutation = {
            unitId,
            subUnitId,
            range: addRowRange,
            rowInfo
          };
          redoMutations.push({
            id: InsertRowMutation.id,
            params: addRowMutation
          });
          undoMutations.push({
            id: RemoveRowMutation.id,
            params: {
              unitId,
              subUnitId,
              range: addRowRange
            }
          });
        }
        const rowHeight = {};
        const originRowHeight = {};
        rowProperties.slice(0, existingRowsCount).forEach((property, index) => {
          var _a, _b;
          const { height: propertyHeight } = property;
          if (propertyHeight) {
            const rowConfigBeforePaste = rowManager.getRow(range.rows[0] + index);
            const willSetHeight = Number.parseFloat(propertyHeight);
            if (rowConfigBeforePaste) {
              const { h = DEFAULT_WORKSHEET_ROW_HEIGHT, ah = 0 } = rowConfigBeforePaste;
              const nowRowHeight = Math.max(h, ah);
              if (willSetHeight > nowRowHeight) {
                rowHeight[index + range.rows[0]] = willSetHeight;
                originRowHeight[index + range.rows[0]] = nowRowHeight;
              } else {
                rowHeight[index + range.rows[0]] = nowRowHeight;
                originRowHeight[index + range.rows[0]] = nowRowHeight;
              }
            } else {
              rowHeight[index + range.rows[0]] = willSetHeight;
              originRowHeight[index + range.rows[0]] = (_b = (_a = rowManager.getRow(range.rows[0] + index)) == null ? void 0 : _a.h) != null ? _b : DEFAULT_WORKSHEET_ROW_HEIGHT;
            }
          }
        });
        if (Object.keys(rowHeight).length) {
          const setRowPropertyMutation = {
            unitId,
            subUnitId,
            ranges: [{
              startRow: range.rows[0],
              endRow: Math.min(range.rows[range.rows.length - 1], maxRow),
              startColumn: range.cols[0],
              endColumn: range.cols[range.cols.length - 1]
            }],
            rowHeight
          };
          redoMutations.push({
            id: SetWorksheetRowHeightMutation.id,
            params: setRowPropertyMutation
          });
          undoMutations.push({
            id: SetWorksheetRowHeightMutation.id,
            params: {
              ...setRowPropertyMutation,
              rowHeight: originRowHeight
            }
          });
        }
        return {
          redos: redoMutations,
          undos: undoMutations
        };
      },
      // eslint-disable-next-line max-lines-per-function
      onPasteColumns(pasteTo, colProperties, pasteType) {
        var _a;
        const { range } = pasteTo;
        const redoMutations = [];
        const undoMutations = [];
        const maxColumn = currentSheet.getMaxColumns();
        const colCount = maxColumn - 1;
        const addingColsCount = range.cols[range.cols.length - 1] - colCount;
        const existingColsCount = colProperties.length - addingColsCount;
        const defaultColumnWidth = (_a = self._configService.getConfig(DEFAULT_WORKSHEET_COLUMN_WIDTH_KEY)) != null ? _a : DEFAULT_WORKSHEET_COLUMN_WIDTH;
        const pasteToCols = range.cols;
        const startColumn = pasteToCols[0];
        if (addingColsCount > 0) {
          const addColRange = {
            startRow: range.rows[0],
            endRow: range.rows[range.rows.length - 1],
            endColumn: range.cols[range.cols.length - 1],
            startColumn: maxColumn
          };
          const addColMutation = {
            unitId,
            subUnitId,
            range: addColRange,
            colInfo: colProperties.slice(existingColsCount).map((property, index) => ({
              w: property.width ? Math.max(+property.width, currentSheet.getColumnWidth(pasteToCols[index])) : defaultColumnWidth,
              hd: 0 /* FALSE */
            }))
          };
          redoMutations.push({
            id: InsertColMutation.id,
            params: addColMutation
          });
          undoMutations.push({
            id: RemoveColMutation.id,
            params: {
              unitId,
              subUnitId,
              range: addColRange
            }
          });
        }
        const targetSetColPropertyParams = {
          unitId,
          subUnitId,
          ranges: [{
            startRow: range.rows[0],
            endRow: range.rows[range.rows.length - 1],
            startColumn: range.cols[0],
            endColumn: Math.min(range.cols[range.cols.length - 1], maxColumn)
          }]
        };
        if (colProperties.length > 0) {
          const setColPropertyMutation = {
            ...targetSetColPropertyParams,
            colWidth: colProperties.slice(0, existingColsCount).reduce((p, c, index) => {
              var _a2;
              p[index + startColumn] = c.width ? Math.max(+c.width, (_a2 = currentSheet.getColumnWidth(pasteToCols[index])) != null ? _a2 : defaultColumnWidth) : defaultColumnWidth;
              return p;
            }, {})
          };
          const undoSetColPropertyParams = {
            ...targetSetColPropertyParams,
            colWidth: colProperties.slice(0, existingColsCount).reduce((p, c, index) => {
              var _a2;
              p[index + startColumn] = (_a2 = currentSheet.getColumnWidth(pasteToCols[index])) != null ? _a2 : defaultColumnWidth;
              return p;
            }, {})
          };
          redoMutations.push({
            id: SetWorksheetColWidthMutation.id,
            params: setColPropertyMutation
          });
          undoMutations.push({
            id: SetWorksheetColWidthMutation.id,
            params: undoSetColPropertyParams
          });
        }
        return {
          redos: redoMutations,
          undos: undoMutations
        };
      },
      onPastePlainText(pasteTo, text, payload) {
        return self._onPastePlainText(pasteTo, text, payload);
      },
      onPasteCells(pasteFrom, pasteTo, data, payload) {
        return self._onPasteCells(pasteFrom, pasteTo, data, payload);
      },
      onAfterPaste(success) {
        currentSheet = null;
      }
    };
  }
  _generateDocumentDataModelSnapshot(snapshot) {
    var _a, _b;
    const currentSkeleton = (_a = withCurrentTypeOfRenderer(
      O.UNIVER_SHEET,
      SheetSkeletonManagerService,
      this._instanceService,
      this._renderManagerService
    )) == null ? void 0 : _a.getCurrentParam();
    if (currentSkeleton == null) {
      return null;
    }
    const { skeleton } = currentSkeleton;
    const documentModel = (_b = skeleton.getBlankCellDocumentModel()) == null ? void 0 : _b.documentModel;
    const p = documentModel == null ? void 0 : documentModel.getSnapshot();
    const documentData = { ...p, ...snapshot };
    documentModel == null ? void 0 : documentModel.reset(documentData);
    return documentModel == null ? void 0 : documentModel.getSnapshot();
  }
  _onPastePlainText(pasteTo, text, payload) {
    const { range, unitId, subUnitId } = pasteTo;
    let cellValue;
    if (/\r|\n/.test(text) || Tools.isLegalUrl(text)) {
      const body = generateBody(text);
      const p = this._generateDocumentDataModelSnapshot({ body });
      cellValue = {
        [range.rows[0]]: {
          [range.cols[0]]: {
            p
          }
        }
      };
    } else {
      if (isFormulaString(text)) {
        cellValue = {
          [range.rows[0]]: {
            [range.cols[0]]: {
              f: text
            }
          }
        };
      } else {
        cellValue = {
          [range.rows[0]]: {
            [range.cols[0]]: {
              v: text
            }
          }
        };
      }
    }
    const setRangeValuesParams = {
      unitId,
      subUnitId,
      cellValue
    };
    return {
      redos: [
        {
          id: SetRangeValuesMutation.id,
          params: setRangeValuesParams
        }
      ],
      undos: [
        {
          id: SetRangeValuesMutation.id,
          params: SetRangeValuesUndoMutationFactory(this._injector, setRangeValuesParams)
        }
      ]
    };
  }
  _onPasteCells(pasteFrom, pasteTo, data, payload) {
    return this._injector.invoke((accessor) => {
      return getDefaultOnPasteCellMutations(pasteFrom, pasteTo, data, payload, accessor);
    });
  }
  // eslint-disable-next-line max-lines-per-function
  _initSpecialPasteHooks() {
    const self = this;
    const specialPasteValueHook = {
      id: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_VALUE,
      specialPasteInfo: {
        label: "specialPaste.value"
      },
      onPasteCells: (pasteFrom, pasteTo, data) => {
        return this._injector.invoke((accessor) => {
          return getSetCellValueMutations(pasteTo, pasteFrom, data, accessor);
        });
      }
    };
    const specialPasteFormatHook = {
      id: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_FORMAT,
      specialPasteInfo: {
        label: "specialPaste.format"
      },
      onPasteCells: (pasteFrom, pasteTo, matrix) => {
        const redoMutationsInfo = [];
        const undoMutationsInfo = [];
        const { undos: styleUndos, redos: styleRedos } = this._injector.invoke((accessor) => {
          return getClearCellStyleMutations(pasteTo, matrix, accessor);
        });
        redoMutationsInfo.push(...styleRedos);
        undoMutationsInfo.push(...styleUndos);
        const { undos: mergeUndos, redos: mergeRedos } = this._injector.invoke((accessor) => {
          return getClearAndSetMergeMutations(
            pasteTo,
            matrix,
            accessor
          );
        });
        redoMutationsInfo.push(...mergeRedos);
        undoMutationsInfo.push(...mergeUndos);
        const { undos: setStyleUndos, redos: setStyleRedos } = this._injector.invoke((accessor) => {
          return getSetCellStyleMutations(
            pasteTo,
            matrix,
            accessor
          );
        });
        redoMutationsInfo.push(...setStyleRedos);
        undoMutationsInfo.push(...setStyleUndos);
        return {
          undos: undoMutationsInfo,
          redos: redoMutationsInfo
        };
      }
    };
    const specialPasteColWidthHook = {
      id: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_COL_WIDTH,
      specialPasteInfo: {
        label: "specialPaste.colWidth"
      },
      onPasteCells() {
        return {
          undos: [],
          redos: []
        };
      },
      onPasteColumns(pasteTo, colProperties, payload) {
        var _a, _b;
        const workbook = self._instanceService.getCurrentUnitForType(O.UNIVER_SHEET);
        const unitId = workbook.getUnitId();
        const subUnitId = (_a = workbook.getActiveSheet()) == null ? void 0 : _a.getSheetId();
        if (!unitId || !subUnitId) {
          throw new Error("Cannot find unitId or subUnitId");
        }
        const redoMutations = [];
        const undoMutations = [];
        const currentSheet = self._getWorksheet(unitId, subUnitId);
        const { range } = pasteTo;
        const pasteToCols = range.cols;
        const startColumn = pasteToCols[0];
        const maxColumn = currentSheet.getMaxColumns();
        const addingColsCount = range.cols[range.cols.length - 1] - maxColumn;
        const existingColsCount = colProperties.length - addingColsCount;
        const defaultColumnWidth = (_b = self._configService.getConfig(DEFAULT_WORKSHEET_COLUMN_WIDTH_KEY)) != null ? _b : DEFAULT_WORKSHEET_COLUMN_WIDTH;
        const setColPropertyMutation = {
          unitId,
          subUnitId,
          ranges: [{
            startRow: range.rows[0],
            endRow: Math.min(range.cols[range.cols.length - 1], maxColumn),
            startColumn: range.cols[0],
            endColumn: range.cols[range.cols.length - 1]
          }],
          colWidth: colProperties.slice(0, existingColsCount).reduce((p, c, index) => {
            var _a2;
            p[index + startColumn] = c.width ? Math.max(+c.width, (_a2 = currentSheet.getColumnWidth(pasteToCols[index])) != null ? _a2 : defaultColumnWidth) : defaultColumnWidth;
            return p;
          }, {})
        };
        const undoSetColPropertyMutation = {
          unitId,
          subUnitId,
          ranges: [{
            startRow: range.rows[0],
            endRow: Math.min(range.cols[range.cols.length - 1], maxColumn),
            startColumn: range.cols[0],
            endColumn: range.cols[range.cols.length - 1]
          }],
          colWidth: colProperties.slice(0, existingColsCount).reduce((p, c, index) => {
            var _a2;
            p[index + startColumn] = (_a2 = currentSheet.getColumnWidth(pasteToCols[index])) != null ? _a2 : defaultColumnWidth;
            return p;
          }, {})
        };
        redoMutations.push({
          id: SetWorksheetColWidthMutation.id,
          params: setColPropertyMutation
        });
        undoMutations.push({
          id: SetWorksheetColWidthMutation.id,
          params: undoSetColPropertyMutation
        });
        return {
          redos: redoMutations,
          undos: undoMutations
        };
      }
    };
    const specialPasteBesidesBorder = {
      id: PREDEFINED_HOOK_NAME.SPECIAL_PASTE_BESIDES_BORDER,
      specialPasteInfo: {
        label: "specialPaste.besidesBorder"
      },
      onPasteCells: (pasteFrom, pasteTo, matrix, payload) => {
        const workbook = self._instanceService.getCurrentUnitForType(O.UNIVER_SHEET);
        const redoMutationsInfo = [];
        const undoMutationsInfo = [];
        const { range, unitId, subUnitId } = pasteTo;
        const valueMatrix = new ObjectMatrix();
        matrix.forValue((row, col, value) => {
          const style = value.s;
          if (typeof style === "object") {
            const newValue = Tools.deepClone(value);
            if (newValue.s) {
              newValue.s = {
                ...style,
                bd: null
              };
            }
            valueMatrix.setValue(range.rows[row], range.cols[col], newValue);
          }
        });
        const setValuesMutation = {
          unitId,
          subUnitId,
          cellValue: valueMatrix.getData()
        };
        redoMutationsInfo.push({
          id: SetRangeValuesMutation.id,
          params: setValuesMutation
        });
        const undoSetValuesMutation = this._injector.invoke(
          SetRangeValuesUndoMutationFactory,
          setValuesMutation
        );
        undoMutationsInfo.push({
          id: SetRangeValuesMutation.id,
          params: undoSetValuesMutation
        });
        const { undos, redos } = this._injector.invoke((accessor) => {
          return getClearAndSetMergeMutations(pasteTo, matrix, accessor);
        });
        undoMutationsInfo.push(...undos);
        redoMutationsInfo.push(...redos);
        return {
          redos: redoMutationsInfo,
          undos: undoMutationsInfo
        };
      }
    };
    return [specialPasteValueHook, specialPasteFormatHook, specialPasteColWidthHook, specialPasteBesidesBorder];
  }
  _getWorksheet(unitId, subUnitId) {
    var _a;
    const worksheet = (_a = this._instanceService.getUniverSheetInstance(unitId)) == null ? void 0 : _a.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      throw new Error(
        `[SheetClipboardController]: cannot find a worksheet with unitId ${unitId} and subUnitId ${subUnitId}.`
      );
    }
    return worksheet;
  }
  _initCommandListener() {
    var _a;
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === AddWorksheetMergeCommand2.id) {
          this._sheetClipboardService.removeMarkSelection();
        } else if (shouldRemoveShapeIds.includes(command.id)) {
          this._sheetClipboardService.removeMarkSelection();
        }
      })
    );
    const sheetsUIConfig = this._configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY);
    if ((_a = sheetsUIConfig == null ? void 0 : sheetsUIConfig.clipboardConfig) == null ? void 0 : _a.hidePasteOptions) {
      return;
    }
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (RemovePasteMenuCommands.includes(command.id)) {
          this._sheetClipboardService.disposePasteOptionsCache();
        }
      })
    );
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === SetScrollOperation.id) {
          if (!this._sheetClipboardService.getPasteMenuVisible()) {
            return;
          }
          const params = command.params;
          const scrollUnitId = params.unitId;
          const pasteOptionsCache = this._sheetClipboardService.getPasteOptionsCache();
          const menuUnitId = pasteOptionsCache == null ? void 0 : pasteOptionsCache.target.unitId;
          if (scrollUnitId === menuUnitId) {
            this._refreshOptionalPaste$.next(Math.random());
          }
        }
      })
    );
  }
  _initUIComponents() {
    var _a;
    const sheetsUIConfig = this._configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY);
    if ((_a = sheetsUIConfig == null ? void 0 : sheetsUIConfig.clipboardConfig) == null ? void 0 : _a.hidePasteOptions) {
      return;
    }
    this.disposeWithMe(
      this._uiPartsService.registerComponent("content" /* CONTENT */, () => connectInjector(ClipboardPopupMenu, this._injector))
    );
  }
};
SheetClipboardController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IRenderManagerService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, IContextService),
  __decorateParam(5, IConfigService),
  __decorateParam(6, ISheetClipboardService),
  __decorateParam(7, IMessageService),
  __decorateParam(8, Inject(LocaleService)),
  __decorateParam(9, IUIPartsService)
], SheetClipboardController);

// ../packages/sheets-ui/src/services/drag-manager.service.ts
var DragManagerService = class extends Disposable {
  constructor(_univerInstanceService, _renderManagerService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_currentCell$", new Subject());
    __publicField(this, "currentCell$", this._currentCell$.asObservable().pipe(distinctUntilChanged(
      (pre, aft) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return ((_a = pre == null ? void 0 : pre.location) == null ? void 0 : _a.unitId) === ((_b = aft == null ? void 0 : aft.location) == null ? void 0 : _b.unitId) && ((_c = pre == null ? void 0 : pre.location) == null ? void 0 : _c.subUnitId) === ((_d = aft == null ? void 0 : aft.location) == null ? void 0 : _d.subUnitId) && ((_e = pre == null ? void 0 : pre.location) == null ? void 0 : _e.row) === ((_f = aft == null ? void 0 : aft.location) == null ? void 0 : _f.row) && ((_g = pre == null ? void 0 : pre.location) == null ? void 0 : _g.col) === ((_h = aft == null ? void 0 : aft.location) == null ? void 0 : _h.col);
      }
    )));
    __publicField(this, "_endCell$", new Subject());
    __publicField(this, "endCell$", this._endCell$.asObservable());
    this._initCellDisposableListener();
  }
  dispose() {
    super.dispose();
    this._currentCell$.complete();
    this._endCell$.complete();
  }
  _initCellDisposableListener() {
    this.disposeWithMe(this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).subscribe((workbook) => {
      if (!workbook) {
        this._currentCell$.next(null);
        this._endCell$.next(null);
      }
    }));
  }
  _calcActiveCell(offsetX, offsetY) {
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) {
      return null;
    }
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return;
    const currentRender = this._renderManagerService.getRenderById(workbook.getUnitId());
    if (!currentRender) return;
    const skeletonParam = currentRender.with(SheetSkeletonManagerService).getCurrentParam();
    const scrollManagerService = currentRender.with(SheetScrollManagerService);
    const scrollInfo = scrollManagerService.getCurrentScrollState();
    if (!skeletonParam || !scrollInfo || !currentRender) return;
    return getHoverCellPosition(currentRender, workbook, worksheet, skeletonParam, offsetX, offsetY);
  }
  onDragOver(evt) {
    const { offsetX, offsetY, dataTransfer } = evt;
    const activeCell = this._calcActiveCell(offsetX, offsetY);
    if (!activeCell) {
      this._currentCell$.next(null);
      return;
    }
    const { location, position } = activeCell;
    this._currentCell$.next({
      location,
      position,
      dataTransfer
    });
  }
  onDrop(evt) {
    const { offsetX, offsetY, dataTransfer } = evt;
    const activeCell = this._calcActiveCell(offsetX, offsetY);
    if (!activeCell) {
      this._endCell$.next(null);
      return;
    }
    const { location, position } = activeCell;
    this._endCell$.next({
      location,
      position,
      dataTransfer
    });
  }
};
DragManagerService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService)
], DragManagerService);

// ../packages/sheets-ui/src/controllers/drag-render.controller.ts
var DragRenderController = class extends Disposable {
  constructor(_context, _renderManagerService, _dragManagerService, _sheetSkeletonManagerService) {
    super();
    this._context = _context;
    this._renderManagerService = _renderManagerService;
    this._dragManagerService = _dragManagerService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._initDragEvent();
  }
  _initDragEvent() {
    const disposeSet = new DisposableCollection();
    const handleSkeletonChange = (skeletonParam) => {
      disposeSet.dispose();
      if (!skeletonParam) {
        return;
      }
      const { scene } = this._context;
      const dragOverSub = scene.onDragOver$.subscribeEvent((evt) => {
        this._dragManagerService.onDragOver(evt);
      });
      const dropSub = scene.onDrop$.subscribeEvent((evt) => {
        this._dragManagerService.onDrop(evt);
      });
      disposeSet.add({
        dispose() {
          dragOverSub.unsubscribe();
          dropSub.unsubscribe();
        }
      });
    };
    handleSkeletonChange(this._sheetSkeletonManagerService.getCurrentParam());
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((skeletonParam) => {
      handleSkeletonChange(skeletonParam);
    }));
  }
};
DragRenderController = __decorateClass([
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, Inject(DragManagerService)),
  __decorateParam(3, Inject(SheetSkeletonManagerService))
], DragRenderController);

// ../packages/sheets-ui/src/services/utils/doc-skeleton-util.ts
var calcDocRangePositions = (range, skeleton) => {
  var _a, _b, _c, _d, _e;
  const pageIndex = -1;
  const startPosition = skeleton.findNodePositionByCharIndex(range.startOffset, true, range.segmentId, pageIndex);
  const skeletonData = skeleton.getSkeletonData();
  let end = range.endOffset;
  if (range.segmentId) {
    const root = (_e = Array.from((_b = (_a = skeletonData == null ? void 0 : skeletonData.skeFooters.get(range.segmentId)) == null ? void 0 : _a.values()) != null ? _b : [])[0]) != null ? _e : Array.from((_d = (_c = skeletonData == null ? void 0 : skeletonData.skeHeaders.get(range.segmentId)) == null ? void 0 : _c.values()) != null ? _d : [])[0];
    if (root) {
      end = Math.min(root.ed, end);
    }
  }
  const endPosition = skeleton.findNodePositionByCharIndex(end, true, range.segmentId, pageIndex);
  if (!endPosition || !startPosition) {
    return;
  }
  const documentOffsetConfig = {
    docsLeft: 0,
    docsTop: 0,
    pageMarginLeft: 0,
    pageMarginTop: 0
  };
  const convertor = new NodePositionConvertToCursor(documentOffsetConfig, skeleton);
  const { borderBoxPointGroup } = convertor.getRangePointData(startPosition, endPosition);
  const bounds = getLineBounding(borderBoxPointGroup);
  return bounds.map((rect) => ({
    top: rect.top,
    bottom: rect.bottom,
    left: rect.left,
    right: rect.right
  }));
};
var calcDocGlyphPosition = (glyph, skeleton, pageIndex = -1) => {
  const start = skeleton.findPositionByGlyph(glyph, pageIndex);
  if (!start) {
    return;
  }
  const startPosition = { ...start, isBack: true };
  const documentOffsetConfig = {
    docsLeft: 0,
    docsTop: 0,
    pageMarginLeft: 0,
    pageMarginTop: 0
  };
  const convertor = new NodePositionConvertToCursor(documentOffsetConfig, skeleton);
  const { borderBoxPointGroup } = convertor.getRangePointData(startPosition, startPosition);
  const bounds = getLineBounding(borderBoxPointGroup);
  const rect = bounds[0];
  return {
    top: rect.top,
    bottom: rect.bottom,
    left: rect.left,
    right: rect.right
  };
};
var calcLinkPosition = (skeleton, range, paddingLeft = 0, paddingTop = 0) => {
  const rects = calcDocRangePositions({ startOffset: range.startIndex, endOffset: range.endIndex + 1, collapsed: false }, skeleton);
  if (rects) {
    return {
      rects: rects.map((rect) => ({
        top: rect.top + paddingTop,
        bottom: rect.bottom + paddingTop,
        left: rect.left + paddingLeft,
        right: rect.right + paddingLeft
      })),
      range
    };
  }
};
var calcBulletPosition = (skeleton, paragraph, paddingLeft = 0, paddingTop = 0) => {
  var _a, _b, _c;
  const node = skeleton.findNodeByCharIndex(paragraph.startIndex);
  const divide = node == null ? void 0 : node.parent;
  const line = divide == null ? void 0 : divide.parent;
  const column = line == null ? void 0 : line.parent;
  const targetLine = column == null ? void 0 : column.lines.find((l) => l.paragraphStart && l.paragraphIndex === paragraph.startIndex);
  const bulletNode = (_c = (_b = (_a = targetLine == null ? void 0 : targetLine.divides) == null ? void 0 : _a[0]) == null ? void 0 : _b.glyphGroup) == null ? void 0 : _c[0];
  if (!bulletNode) {
    return;
  }
  if (!bulletNode) {
    return;
  }
  const rect = calcDocGlyphPosition(bulletNode, skeleton);
  if (!rect) {
    return;
  }
  return {
    rect: {
      top: rect.top + paddingTop,
      bottom: rect.bottom + paddingTop,
      left: rect.left + paddingLeft,
      right: rect.right + paddingLeft
    },
    segmentId: void 0,
    segmentPageIndex: -1,
    paragraph
  };
};
var calculateDocSkeletonRects = (docSkeleton, paddingLeft = 0, paddingTop = 0) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const docModel = docSkeleton.getViewModel().getDataModel();
  const hyperLinks = (_c = (_b = (_a = docModel.getBody()) == null ? void 0 : _a.customRanges) == null ? void 0 : _b.filter((range) => range.rangeType === 0 /* HYPERLINK */)) != null ? _c : [];
  const checkLists = (_f = (_e = (_d = docModel.getBody()) == null ? void 0 : _d.paragraphs) == null ? void 0 : _e.filter((p) => {
    var _a2;
    return ((_a2 = p.bullet) == null ? void 0 : _a2.listType.indexOf("CHECK_LIST" /* CHECK_LIST */)) === 0;
  })) != null ? _f : [];
  const drawings = (_g = docSkeleton.getSkeletonData()) == null ? void 0 : _g.pages[0].skeDrawings;
  return {
    links: hyperLinks.map((link) => calcLinkPosition(docSkeleton, link, paddingLeft, paddingTop)).filter(Boolean),
    checkLists: checkLists.map((list) => calcBulletPosition(docSkeleton, list, paddingLeft, paddingTop)).filter(Boolean),
    drawings: drawings ? Array.from(drawings.keys()).map((key) => ({
      drawingId: key,
      rect: {
        top: drawings.get(key).aTop,
        bottom: drawings.get(key).aTop + drawings.get(key).width,
        left: drawings.get(key).aLeft,
        right: drawings.get(key).aLeft + drawings.get(key).height
      }
    })) : []
  };
};
function calcPadding(cell, font, isNum) {
  var _a, _b, _c, _d, _e, _f;
  const height = (_c = (_b = (_a = font.documentSkeleton) == null ? void 0 : _a.getSkeletonData()) == null ? void 0 : _b.pages[0].height) != null ? _c : 0;
  const width = (_f = (_e = (_d = font.documentSkeleton) == null ? void 0 : _d.getSkeletonData()) == null ? void 0 : _e.pages[0].width) != null ? _f : 0;
  const vt = font.verticalAlign;
  const ht = font.horizontalAlign;
  let paddingTop = 0;
  switch (vt) {
    case 0 /* UNSPECIFIED */:
    case 3 /* BOTTOM */:
      paddingTop = cell.mergeInfo.endY - cell.mergeInfo.startY - height;
      break;
    case 2 /* MIDDLE */:
      paddingTop = (cell.mergeInfo.endY - cell.mergeInfo.startY - height) / 2;
      break;
    default:
      break;
  }
  let paddingLeft = 0;
  switch (ht) {
    case 3 /* RIGHT */:
      paddingLeft = cell.mergeInfo.endX - cell.mergeInfo.startX - width;
      break;
    case 2 /* CENTER */:
      paddingLeft = (cell.mergeInfo.endX - cell.mergeInfo.startX - width) / 2;
      break;
    case 0 /* UNSPECIFIED */: {
      if (isNum) {
        paddingLeft = cell.mergeInfo.endX - cell.mergeInfo.startX - width;
      }
      break;
    }
    default:
      break;
  }
  return {
    paddingLeft,
    paddingTop
  };
}
var getCustomRangePosition = (injector, unitId, subUnitId, row, col, rangeId) => {
  var _a, _b, _c;
  const univerInstanceService = injector.get(IUniverInstanceService);
  const renderManagerService = injector.get(IRenderManagerService);
  const workbook = univerInstanceService.getUnit(unitId, O.UNIVER_SHEET);
  if (!workbook) {
    return null;
  }
  const worksheet = workbook.getSheetBySheetId(subUnitId);
  if (!worksheet) {
    return null;
  }
  const currentRender = renderManagerService.getRenderById(workbook.getUnitId());
  const skeletonParam = currentRender == null ? void 0 : currentRender.with(SheetSkeletonManagerService).getSkeletonParam(worksheet.getSheetId());
  const skeleton = skeletonParam == null ? void 0 : skeletonParam.skeleton;
  if (!skeleton || !currentRender) return;
  const font = skeleton.getFont(row, col);
  const docSkeleton = font == null ? void 0 : font.documentSkeleton;
  if (!docSkeleton) {
    return null;
  }
  const customRange = (_b = (_a = docSkeleton.getViewModel().getBody()) == null ? void 0 : _a.customRanges) == null ? void 0 : _b.find((range) => range.rangeId === rangeId);
  if (!customRange) {
    return null;
  }
  const PADDING = DOC_VERTICAL_PADDING;
  const cellIndex = skeleton.getCellWithCoordByIndex(row, col);
  let { actualColumn, actualRow } = cellIndex;
  skeleton.overflowCache.forValue((r, c, range) => {
    if (range.startRow <= actualRow && range.endRow >= actualRow && range.startColumn <= actualColumn && range.endColumn >= actualColumn) {
      actualColumn = c;
      actualRow = r;
    }
  });
  const actualCell = skeleton.getCellWithCoordByIndex(actualRow, actualColumn);
  const cellData = worksheet.getCell(actualCell.actualRow, actualCell.actualColumn);
  const { topOffset = 0, leftOffset = 0 } = (_c = cellData == null ? void 0 : cellData.fontRenderExtension) != null ? _c : {};
  const { paddingLeft, paddingTop } = calcPadding(actualCell, font, false);
  const rects = calcDocRangePositions({ startOffset: customRange.startIndex, endOffset: customRange.endIndex, collapsed: false }, docSkeleton);
  return {
    rects: rects == null ? void 0 : rects.map((rect) => ({
      top: rect.top + actualCell.mergeInfo.startY + paddingTop + topOffset + PADDING,
      bottom: rect.bottom + actualCell.mergeInfo.startY + paddingTop + topOffset + PADDING,
      left: rect.left + actualCell.mergeInfo.startX + paddingLeft + leftOffset,
      right: rect.right + actualCell.mergeInfo.startX + paddingLeft + leftOffset
    })),
    customRange,
    label: docSkeleton.getViewModel().getBody().dataStream.slice(customRange.startIndex, customRange.endIndex + 1)
  };
};
var getEditingCustomRangePosition = (injector, unitId, subUnitId, row, col, rangeId) => {
  var _a, _b, _c;
  const editorBridgeService = injector.get(IEditorBridgeService);
  const state = editorBridgeService.getEditCellState();
  if (!state) {
    return null;
  }
  const visible = editorBridgeService.isVisible();
  if (!visible.visible) {
    return null;
  }
  const { editorUnitId, unitId: editingUnitId, sheetId, row: editRow, column: editCol } = state;
  if (unitId !== editingUnitId || subUnitId !== sheetId || editRow !== row || editCol !== col) {
    return null;
  }
  const renderManagerService = injector.get(IRenderManagerService);
  const renderer = renderManagerService.getRenderById(editorUnitId);
  const sheetRenderer = renderManagerService.getRenderById(unitId);
  if (!renderer || !sheetRenderer) {
    return null;
  }
  const docSkeleton = renderer.with(DocSkeletonManagerService).getSkeleton();
  const sheetSkeleton = (_a = sheetRenderer.with(SheetSkeletonManagerService).getSkeletonParam(sheetId)) == null ? void 0 : _a.skeleton;
  if (!docSkeleton || !sheetSkeleton) {
    return null;
  }
  const customRange = (_c = (_b = docSkeleton.getViewModel().getBody()) == null ? void 0 : _b.customRanges) == null ? void 0 : _c.find((range) => range.rangeId === rangeId);
  if (!customRange) {
    return null;
  }
  const PADDING = 4;
  const rects = calcDocRangePositions({ startOffset: customRange.startIndex, endOffset: customRange.endIndex, collapsed: false }, docSkeleton);
  const canvasClientRect = renderer.engine.getCanvasElement().getBoundingClientRect();
  return {
    rects: rects == null ? void 0 : rects.map((rect) => ({
      top: rect.top + canvasClientRect.top - PADDING,
      bottom: rect.bottom + canvasClientRect.top + PADDING,
      left: rect.left + canvasClientRect.left,
      right: rect.right + canvasClientRect.left
    })),
    customRange,
    label: docSkeleton.getViewModel().getBody().dataStream.slice(customRange.startIndex, customRange.endIndex + 1)
  };
};

// ../packages/sheets-ui/src/services/hover-manager.service.ts
function getLocationBase(location) {
  const { workbook, worksheet, ...locBase } = location;
  return locBase;
}
var HoverManagerService = class extends Disposable {
  constructor(_univerInstanceService, _renderManagerService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_currentCell$", new BehaviorSubject(null));
    __publicField(this, "_currentRichText$", new BehaviorSubject(null));
    __publicField(this, "_currentClickedCell$", new Subject());
    __publicField(this, "_currentDbClickedCell$", new Subject());
    __publicField(this, "_currentCellWithEvent$", new Subject());
    __publicField(this, "_currentPointerDownCell$", new Subject());
    __publicField(this, "_currentPointerUpCell$", new Subject());
    __publicField(this, "_currentHoveredRowHeader$", new BehaviorSubject(null));
    __publicField(this, "_currentHoveredColHeader$", new BehaviorSubject(null));
    __publicField(this, "_currentRowHeaderClick$", new Subject());
    __publicField(this, "_currentColHeaderClick$", new Subject());
    __publicField(this, "_currentRowHeaderDbClick$", new Subject());
    __publicField(this, "_currentColHeaderDbClick$", new Subject());
    __publicField(this, "_currentRowHeaderPointerDown$", new Subject());
    __publicField(this, "_currentColHeaderPointerDown$", new Subject());
    __publicField(this, "_currentRowHeaderPointerUp$", new Subject());
    __publicField(this, "_currentColHeaderPointerUp$", new Subject());
    // Notify when hovering over different cells
    __publicField(this, "currentCell$", this._currentCell$.asObservable().pipe(
      distinctUntilChanged(
        (pre, aft) => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          return ((_a = pre == null ? void 0 : pre.location) == null ? void 0 : _a.unitId) === ((_b = aft == null ? void 0 : aft.location) == null ? void 0 : _b.unitId) && ((_c = pre == null ? void 0 : pre.location) == null ? void 0 : _c.subUnitId) === ((_d = aft == null ? void 0 : aft.location) == null ? void 0 : _d.subUnitId) && ((_e = pre == null ? void 0 : pre.location) == null ? void 0 : _e.row) === ((_f = aft == null ? void 0 : aft.location) == null ? void 0 : _f.row) && ((_g = pre == null ? void 0 : pre.location) == null ? void 0 : _g.col) === ((_h = aft == null ? void 0 : aft.location) == null ? void 0 : _h.col);
        }
      )
    ));
    // Notify when hovering over different cells and different custom range or bullet
    __publicField(this, "currentRichText$", this._currentRichText$.pipe(
      distinctUntilChanged(
        // eslint-disable-next-line complexity
        (pre, aft) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
          return ((_a = pre == null ? void 0 : pre.location) == null ? void 0 : _a.unitId) === ((_b = aft == null ? void 0 : aft.location) == null ? void 0 : _b.unitId) && ((_c = pre == null ? void 0 : pre.location) == null ? void 0 : _c.subUnitId) === ((_d = aft == null ? void 0 : aft.location) == null ? void 0 : _d.subUnitId) && ((_e = pre == null ? void 0 : pre.location) == null ? void 0 : _e.row) === ((_f = aft == null ? void 0 : aft.location) == null ? void 0 : _f.row) && ((_g = pre == null ? void 0 : pre.location) == null ? void 0 : _g.col) === ((_h = aft == null ? void 0 : aft.location) == null ? void 0 : _h.col) && ((_i = pre == null ? void 0 : pre.customRange) == null ? void 0 : _i.rangeId) === ((_j = aft == null ? void 0 : aft.customRange) == null ? void 0 : _j.rangeId) && ((_k = pre == null ? void 0 : pre.bullet) == null ? void 0 : _k.startIndex) === ((_l = aft == null ? void 0 : aft.bullet) == null ? void 0 : _l.startIndex) && ((_m = pre == null ? void 0 : pre.customRange) == null ? void 0 : _m.startIndex) === ((_n = aft == null ? void 0 : aft.customRange) == null ? void 0 : _n.startIndex) && ((_o = pre == null ? void 0 : pre.customRange) == null ? void 0 : _o.endIndex) === ((_p = aft == null ? void 0 : aft.customRange) == null ? void 0 : _p.endIndex) && (pre == null ? void 0 : pre.drawing) === (aft == null ? void 0 : aft.drawing);
        }
      ),
      map((cell) => cell && {
        unitId: cell.location.unitId,
        subUnitId: cell.location.subUnitId,
        row: cell.location.row,
        col: cell.location.col,
        customRange: cell.customRange,
        bullet: cell.bullet,
        rect: cell.rect,
        drawing: cell.drawing
      })
    ));
    /**
     * Nearly same as currentRichText$, but with event
     */
    __publicField(this, "currentCellPosWithEvent$", this._currentCellWithEvent$.pipe(
      distinctUntilChanged(
        (pre, aft) => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          return ((_a = pre == null ? void 0 : pre.location) == null ? void 0 : _a.unitId) === ((_b = aft == null ? void 0 : aft.location) == null ? void 0 : _b.unitId) && ((_c = pre == null ? void 0 : pre.location) == null ? void 0 : _c.subUnitId) === ((_d = aft == null ? void 0 : aft.location) == null ? void 0 : _d.subUnitId) && ((_e = pre == null ? void 0 : pre.location) == null ? void 0 : _e.row) === ((_f = aft == null ? void 0 : aft.location) == null ? void 0 : _f.row) && ((_g = pre == null ? void 0 : pre.location) == null ? void 0 : _g.col) === ((_h = aft == null ? void 0 : aft.location) == null ? void 0 : _h.col);
        }
      ),
      map((cell) => cell && {
        unitId: cell.location.unitId,
        subUnitId: cell.location.subUnitId,
        row: cell.location.row,
        col: cell.location.col,
        event: cell.event
      })
    ));
    // Notify when mouse position changes
    __publicField(this, "currentPosition$", this._currentCell$.asObservable());
    __publicField(this, "currentClickedCell$", this._currentClickedCell$.asObservable());
    __publicField(this, "currentDbClickedCell$", this._currentDbClickedCell$.asObservable());
    __publicField(this, "currentPointerDownCell$", this._currentPointerDownCell$.asObservable());
    __publicField(this, "currentPointerUpCell$", this._currentPointerUpCell$.asObservable());
    __publicField(this, "currentHoveredRowHeader$", this._currentHoveredRowHeader$.asObservable());
    __publicField(this, "currentHoveredColHeader$", this._currentHoveredColHeader$.asObservable());
    __publicField(this, "currentRowHeaderClick$", this._currentRowHeaderClick$.asObservable());
    __publicField(this, "currentColHeaderClick$", this._currentColHeaderClick$.asObservable());
    __publicField(this, "currentRowHeaderDbClick$", this._currentRowHeaderDbClick$.asObservable());
    __publicField(this, "currentColHeaderDbClick$", this._currentColHeaderDbClick$.asObservable());
    __publicField(this, "currentRowHeaderPointerDown$", this._currentRowHeaderPointerDown$.asObservable());
    __publicField(this, "currentColHeaderPointerDown$", this._currentColHeaderPointerDown$.asObservable());
    __publicField(this, "currentRowHeaderPointerUp$", this._currentRowHeaderPointerUp$.asObservable());
    __publicField(this, "currentColHeaderPointerUp$", this._currentColHeaderPointerUp$.asObservable());
    this._initCellDisposableListener();
  }
  dispose() {
    super.dispose();
    this._currentCell$.complete();
    this._currentClickedCell$.complete();
    this._currentPointerDownCell$.complete();
    this._currentPointerUpCell$.complete();
    this._currentCellWithEvent$.complete();
  }
  _initCellDisposableListener() {
    this.disposeWithMe(this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).subscribe((workbook) => {
      if (!workbook) this._currentCell$.next(null);
    }));
    this.disposeWithMe(this._univerInstanceService.unitDisposed$.subscribe((unit) => {
      var _a, _b;
      if (((_a = this._currentCell$.getValue()) == null ? void 0 : _a.location.unitId) === unit.getUnitId()) {
        this._currentCell$.next(null);
      }
      if (((_b = this._currentRichText$.getValue()) == null ? void 0 : _b.location.unitId) === unit.getUnitId()) {
        this._currentRichText$.next(null);
      }
    }));
  }
  _getCalcDeps(unitId) {
    const workbook = this._univerInstanceService.getUnit(unitId, O.UNIVER_SHEET);
    if (!workbook) {
      return null;
    }
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      return null;
    }
    const currentRender = this._renderManagerService.getRenderById(workbook.getUnitId());
    if (!currentRender) return null;
    const skeletonParam = currentRender.with(SheetSkeletonManagerService).getSkeletonParam(worksheet.getSheetId());
    if (!skeletonParam) return null;
    const scrollManagerService = currentRender.with(SheetScrollManagerService);
    const scrollInfo = scrollManagerService == null ? void 0 : scrollManagerService.getCurrentScrollState();
    if (!scrollInfo || !currentRender) return;
    return { currentRender, workbook, worksheet, skeletonParam };
  }
  // eslint-disable-next-line complexity
  _calcActiveCell(currentRender, workbook, worksheet, skeletonParam, offsetX, offsetY) {
    var _a, _b, _c;
    const hoverPosition = getHoverCellPosition(currentRender, workbook, worksheet, skeletonParam, offsetX, offsetY);
    const skeleton = skeletonParam.skeleton;
    if (!hoverPosition) {
      return null;
    }
    const { position, overflowLocation, location } = hoverPosition;
    const font = skeleton.getFont(overflowLocation.row, overflowLocation.col);
    let customRange = null;
    let bullet = null;
    let drawing = null;
    const cell = skeleton.getCellWithCoordByIndex(overflowLocation.row, overflowLocation.col);
    const cellData = worksheet.getCell(overflowLocation.row, overflowLocation.col);
    const { topOffset = 0, leftOffset = 0 } = (_a = cellData == null ? void 0 : cellData.fontRenderExtension) != null ? _a : {};
    if (font == null ? void 0 : font.documentSkeleton) {
      const { paddingLeft, paddingTop } = calcPadding(cell, font, (cellData == null ? void 0 : cellData.v) !== null && (cellData == null ? void 0 : cellData.v) !== void 0 ? !Number.isNaN(+cellData.v) : false);
      const rects = calculateDocSkeletonRects(font.documentSkeleton, paddingLeft, paddingTop);
      const innerX = offsetX - position.startX - leftOffset;
      const innerY = offsetY - position.startY - topOffset;
      customRange = rects.links.find((link) => link.rects.some((rect2) => rect2.left <= innerX && innerX <= rect2.right && rect2.top <= innerY && innerY <= rect2.bottom));
      bullet = rects.checkLists.find((list) => list.rect.left <= innerX && innerX <= list.rect.right && list.rect.top <= innerY && innerY <= list.rect.bottom);
      drawing = rects.drawings.find((drawing2) => drawing2.rect.left <= innerX && innerX <= drawing2.rect.right && drawing2.rect.top <= innerY && innerY <= drawing2.rect.bottom);
    }
    const rect = (_c = (_b = customRange == null ? void 0 : customRange.rects.pop()) != null ? _b : bullet == null ? void 0 : bullet.rect) != null ? _c : drawing == null ? void 0 : drawing.rect;
    return {
      location,
      position,
      overflowLocation,
      customRange: customRange == null ? void 0 : customRange.range,
      bullet: bullet == null ? void 0 : bullet.paragraph,
      drawing: drawing == null ? void 0 : drawing.drawingId,
      rect: rect && {
        top: rect.top + cell.mergeInfo.startY + topOffset,
        bottom: rect.bottom + cell.mergeInfo.startY + topOffset,
        left: rect.left + cell.mergeInfo.startX + leftOffset,
        right: rect.right + cell.mergeInfo.startX + leftOffset
      }
    };
  }
  _calcActiveRowHeader(unitId, offsetX, offsetY) {
    const deps = this._getCalcDeps(unitId);
    if (!deps) {
      return;
    }
    const { currentRender, worksheet, skeletonParam } = deps;
    const { scaleY } = currentRender.scene.getAncestorScale();
    const activeViewport = currentRender.scene.getViewports().find((v) => v.isHit(new Vector2(offsetX, offsetY)));
    if (!activeViewport || activeViewport.viewportKey !== "viewRowTop" /* VIEW_ROW_TOP */ && activeViewport.viewportKey !== "viewRowBottom" /* VIEW_ROW_BOTTOM */) {
      return;
    }
    const scrollXY = {
      x: activeViewport.viewportScrollX,
      y: activeViewport.viewportScrollY
    };
    const index = skeletonParam.skeleton.getRowIndexByOffsetY(offsetY, scaleY, scrollXY);
    return { unitId, index, subUnitId: worksheet.getSheetId() };
  }
  _calcActiveColHeader(unitId, offsetX, offsetY) {
    const deps = this._getCalcDeps(unitId);
    if (!deps) {
      return;
    }
    const { currentRender, worksheet, skeletonParam } = deps;
    const { scaleX } = currentRender.scene.getAncestorScale();
    const activeViewport = currentRender.scene.getViewports().find((v) => v.isHit(new Vector2(offsetX, offsetY)));
    if (!activeViewport || activeViewport.viewportKey !== "viewColumnLeft" /* VIEW_COLUMN_LEFT */ && activeViewport.viewportKey !== "viewColumnRight" /* VIEW_COLUMN_RIGHT */) {
      return;
    }
    const scrollXY = {
      x: activeViewport.viewportScrollX,
      y: activeViewport.viewportScrollY
    };
    const index = skeletonParam.skeleton.getColumnIndexByOffsetX(offsetX, scaleX, scrollXY);
    return { unitId, index, subUnitId: worksheet.getSheetId() };
  }
  triggerPointerDown(unitId, event) {
    const deps = this._getCalcDeps(unitId);
    if (!deps) {
      return;
    }
    const { currentRender, workbook, worksheet, skeletonParam } = deps;
    const activeCell = this._calcActiveCell(currentRender, workbook, worksheet, skeletonParam, event.offsetX, event.offsetY);
    if (activeCell && activeCell.location) {
      const { unitId: unitId2, subUnitId, row, col } = getLocationBase(activeCell.location);
      this._currentPointerDownCell$.next({
        unitId: unitId2,
        subUnitId,
        row,
        col,
        event
      });
    }
  }
  triggerPointerUp(unitId, event) {
    const deps = this._getCalcDeps(unitId);
    if (!deps) {
      return;
    }
    const { currentRender, workbook, worksheet, skeletonParam } = deps;
    const activeCell = this._calcActiveCell(currentRender, workbook, worksheet, skeletonParam, event.offsetX, event.offsetY);
    if (activeCell) {
      const location = getLocationBase(activeCell.location);
      this._currentPointerUpCell$.next({
        ...location,
        event
      });
    }
  }
  triggerMouseMove(unitId, event) {
    const deps = this._getCalcDeps(unitId);
    if (!deps) {
      return;
    }
    const { currentRender, workbook, worksheet, skeletonParam } = deps;
    const activeCell = this._calcActiveCell(currentRender, workbook, worksheet, skeletonParam, event.offsetX, event.offsetY);
    this._currentCell$.next(activeCell && {
      location: getLocationBase(activeCell.location),
      position: activeCell.position
    });
    this._currentRichText$.next(activeCell && {
      ...activeCell,
      location: getLocationBase(activeCell.overflowLocation)
    });
    this._currentCellWithEvent$.next(activeCell && {
      ...activeCell,
      location: getLocationBase(activeCell.location),
      event
    });
  }
  /**
   * Trigger by pointerup.
   * @param unitId
   * @param offsetX
   * @param offsetY
   */
  triggerClick(unitId, offsetX, offsetY) {
    const deps = this._getCalcDeps(unitId);
    if (!deps) {
      return;
    }
    const { currentRender, workbook, worksheet, skeletonParam } = deps;
    const activeCell = this._calcActiveCell(currentRender, workbook, worksheet, skeletonParam, offsetX, offsetY);
    if (activeCell) {
      this._currentClickedCell$.next({
        ...activeCell,
        location: getLocationBase(activeCell.location)
      });
    }
  }
  triggerDbClick(unitId, offsetX, offsetY) {
    const deps = this._getCalcDeps(unitId);
    if (!deps) {
      return;
    }
    const { currentRender, workbook, worksheet, skeletonParam } = deps;
    const activeCell = this._calcActiveCell(currentRender, workbook, worksheet, skeletonParam, offsetX, offsetY);
    if (activeCell) {
      this._currentDbClickedCell$.next({
        ...activeCell,
        location: getLocationBase(activeCell.location)
      });
    }
  }
  triggerScroll() {
    this._currentCell$.next(null);
  }
  triggerRowHeaderClick(unitId, offsetX, offsetY) {
    const pos = this._calcActiveRowHeader(unitId, offsetX, offsetY);
    pos && this._currentRowHeaderClick$.next(pos);
  }
  triggerColHeaderClick(unitId, offsetX, offsetY) {
    const pos = this._calcActiveColHeader(unitId, offsetX, offsetY);
    pos && this._currentColHeaderClick$.next(pos);
  }
  triggerRowHeaderDbClick(unitId, offsetX, offsetY) {
    const pos = this._calcActiveRowHeader(unitId, offsetX, offsetY);
    pos && this._currentRowHeaderDbClick$.next(pos);
  }
  triggerColHeaderDbClick(unitId, offsetX, offsetY) {
    const pos = this._calcActiveColHeader(unitId, offsetX, offsetY);
    pos && this._currentColHeaderDbClick$.next(pos);
  }
  triggerRowHeaderMouseMove(unitId, offsetX, offsetY) {
    this._currentHoveredRowHeader$.next(this._calcActiveRowHeader(unitId, offsetX, offsetY));
  }
  triggerColHeaderMouseMove(unitId, offsetX, offsetY) {
    this._currentHoveredColHeader$.next(this._calcActiveColHeader(unitId, offsetX, offsetY));
  }
  triggerRowHeaderPoniterDown(unitId, offsetX, offsetY) {
    const pos = this._calcActiveRowHeader(unitId, offsetX, offsetY);
    pos && this._currentRowHeaderPointerDown$.next(pos);
  }
  triggerColHeaderPoniterDown(unitId, offsetX, offsetY) {
    const pos = this._calcActiveColHeader(unitId, offsetX, offsetY);
    pos && this._currentColHeaderPointerDown$.next(pos);
  }
  triggerRowHeaderPoniterUp(unitId, offsetX, offsetY) {
    const pos = this._calcActiveRowHeader(unitId, offsetX, offsetY);
    pos && this._currentRowHeaderPointerUp$.next(pos);
  }
  triggerColHeaderPoniterUp(unitId, offsetX, offsetY) {
    const pos = this._calcActiveColHeader(unitId, offsetX, offsetY);
    pos && this._currentColHeaderPointerUp$.next(pos);
  }
};
HoverManagerService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService)
], HoverManagerService);

// ../packages/sheets-ui/src/controllers/force-string-alert-render.controller.ts
var ALERT_KEY = "SHEET_FORCE_STRING_ALERT";
var ForceStringAlertRenderController = class extends Disposable {
  constructor(_context, _hoverManagerService, _cellAlertManagerService, _localeService, _zenZoneService) {
    super();
    this._context = _context;
    this._hoverManagerService = _hoverManagerService;
    this._cellAlertManagerService = _cellAlertManagerService;
    this._localeService = _localeService;
    this._zenZoneService = _zenZoneService;
    this._init();
  }
  _init() {
    this._initCellAlertPopup();
    this._initZenService();
  }
  _initCellAlertPopup() {
    this.disposeWithMe(this._hoverManagerService.currentCell$.subscribe((cellPos) => {
      var _a;
      if (cellPos) {
        const workbook = this._context.unit;
        const worksheet = workbook.getActiveSheet();
        if (!worksheet) return;
        const cellData = worksheet.getCell(cellPos.location.row, cellPos.location.col);
        if ((cellData == null ? void 0 : cellData.t) === 4 /* FORCE_STRING */ && cellData.v && isRealNum(cellData.v)) {
          const currentAlert = this._cellAlertManagerService.currentAlert.get(ALERT_KEY);
          const currentLoc = (_a = currentAlert == null ? void 0 : currentAlert.alert) == null ? void 0 : _a.location;
          if (currentLoc && currentLoc.row === cellPos.location.row && currentLoc.col === cellPos.location.col && currentLoc.subUnitId === cellPos.location.subUnitId && currentLoc.unitId === cellPos.location.unitId) {
            return;
          }
          this._cellAlertManagerService.showAlert({
            type: 2 /* ERROR */,
            title: this._localeService.t("info.error"),
            message: this._localeService.t("info.forceStringInfo"),
            location: cellPos.location,
            width: 200,
            height: 74,
            key: ALERT_KEY
          });
          return;
        }
      }
      this._hideAlert();
    }));
  }
  _initZenService() {
    this.disposeWithMe(this._zenZoneService.visible$.subscribe((visible) => {
      if (visible) {
        this._hideAlert();
      }
    }));
  }
  _hideAlert() {
    this._cellAlertManagerService.removeAlert(ALERT_KEY);
  }
};
ForceStringAlertRenderController = __decorateClass([
  __decorateParam(1, Inject(HoverManagerService)),
  __decorateParam(2, Inject(CellAlertManagerService)),
  __decorateParam(3, Inject(LocaleService)),
  __decorateParam(4, IZenZoneService)
], ForceStringAlertRenderController);

// ../packages/sheets-ui/src/controllers/force-string-render.controller.ts
var ForceStringRenderController = class extends RxDisposable {
  constructor(_context, _sheetSkeletonManagerService, _sheetInterceptorService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._initViewModelIntercept();
  }
  _initViewModelIntercept() {
    const FORCE_STRING_MARK = {
      tl: {
        size: 6,
        color: "#409f11"
      }
    };
    this.disposeWithMe(
      this._sheetInterceptorService.intercept(
        INTERCEPTOR_POINT.CELL_CONTENT,
        {
          priority: 10,
          effect: 1 /* Style */,
          handler: (cell, pos, next) => {
            var _a;
            const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
            if (!skeleton) {
              return next(cell);
            }
            const cellRaw = pos.worksheet.getCellRaw(pos.row, pos.col);
            if (!cellRaw || cellRaw.v === null || cellRaw.v === void 0) {
              return next(cell);
            }
            if ((cell == null ? void 0 : cell.t) === 4 /* FORCE_STRING */ && isRealNum(cellRaw.v)) {
              return next({
                ...cell,
                markers: {
                  ...cell == null ? void 0 : cell.markers,
                  ...FORCE_STRING_MARK
                }
              });
            }
            return next(cell);
          }
        }
      )
    );
  }
};
ForceStringRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, Inject(SheetInterceptorService))
], ForceStringRenderController);

// ../packages/sheets-ui/src/controllers/hover-render.controller.ts
var HoverRenderController = class extends Disposable {
  constructor(_context, _hoverManagerService, _sheetSkeletonManagerService, _scrollManagerService) {
    super();
    this._context = _context;
    this._hoverManagerService = _hoverManagerService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._scrollManagerService = _scrollManagerService;
    __publicField(this, "_active", false);
    this._initPointerEvent();
    this._initScrollEvent();
  }
  get active() {
    return this._active;
  }
  // eslint-disable-next-line max-lines-per-function
  _initPointerEvent() {
    const disposeSet = new DisposableCollection();
    const handleSkeletonChange = (skeletonParam) => {
      disposeSet.dispose();
      if (!skeletonParam) {
        return;
      }
      const { mainComponent, unitId, components } = this._context;
      if (!mainComponent) {
        return;
      }
      disposeSet.add(mainComponent.onPointerEnter$.subscribeEvent((evt) => {
        this._active = true;
      }));
      disposeSet.add(fromEventSubject(mainComponent.onPointerMove$).subscribe((evt) => {
        this._active = true;
        this._hoverManagerService.triggerMouseMove(unitId, evt);
      }));
      disposeSet.add(mainComponent.onPointerDown$.subscribeEvent((evt) => {
        this._hoverManagerService.triggerPointerDown(unitId, evt);
      }));
      disposeSet.add(mainComponent.onPointerUp$.subscribeEvent((evt) => {
        this._hoverManagerService.triggerPointerUp(unitId, evt);
        this._hoverManagerService.triggerClick(unitId, evt.offsetX, evt.offsetY);
      }));
      disposeSet.add(mainComponent.onDblclick$.subscribeEvent((evt) => {
        this._hoverManagerService.triggerDbClick(unitId, evt.offsetX, evt.offsetY);
      }));
      disposeSet.add(mainComponent.onPointerLeave$.subscribeEvent(() => {
        this._active = false;
      }));
      const rowHeader = components.get("__SpreadsheetRowHeader__" /* ROW */);
      const colHeader = components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
      if (rowHeader) {
        disposeSet.add(rowHeader.onPointerMove$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerRowHeaderMouseMove(unitId, evt.offsetX, evt.offsetY);
        }));
        disposeSet.add(rowHeader.onPointerDown$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerRowHeaderPoniterDown(unitId, evt.offsetX, evt.offsetY);
        }));
        disposeSet.add(rowHeader.onPointerUp$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerRowHeaderPoniterUp(unitId, evt.offsetX, evt.offsetY);
          this._hoverManagerService.triggerRowHeaderClick(unitId, evt.offsetX, evt.offsetY);
        }));
        disposeSet.add(rowHeader.onDblclick$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerRowHeaderDbClick(unitId, evt.offsetX, evt.offsetY);
        }));
      }
      if (colHeader) {
        disposeSet.add(colHeader.onPointerMove$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerColHeaderMouseMove(unitId, evt.offsetX, evt.offsetY);
        }));
        disposeSet.add(colHeader.onPointerDown$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerColHeaderPoniterDown(unitId, evt.offsetX, evt.offsetY);
        }));
        disposeSet.add(colHeader.onPointerUp$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerColHeaderPoniterUp(unitId, evt.offsetX, evt.offsetY);
          this._hoverManagerService.triggerColHeaderClick(unitId, evt.offsetX, evt.offsetY);
        }));
        disposeSet.add(colHeader.onDblclick$.subscribeEvent((evt) => {
          this._hoverManagerService.triggerColHeaderDbClick(unitId, evt.offsetX, evt.offsetY);
        }));
      }
    };
    handleSkeletonChange(this._sheetSkeletonManagerService.getCurrentParam());
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((skeletonParam) => {
      handleSkeletonChange(skeletonParam);
    }));
  }
  _initScrollEvent() {
    this.disposeWithMe(this._scrollManagerService.validViewportScrollInfo$.subscribe(() => this._hoverManagerService.triggerScroll()));
  }
};
HoverRenderController = __decorateClass([
  __decorateParam(1, Inject(HoverManagerService)),
  __decorateParam(2, Inject(SheetSkeletonManagerService)),
  __decorateParam(3, Inject(SheetScrollManagerService))
], HoverRenderController);

// ../packages/sheets-ui/src/controllers/mark-selection.controller.ts
var MarkSelectionRenderController = class extends Disposable {
  constructor(_context, _markSelectionService, _commandService, _sheetSkeletonManagerService) {
    super();
    this._context = _context;
    this._markSelectionService = _markSelectionService;
    this._commandService = _commandService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._initListeners();
  }
  _initListeners() {
    this._addRemoveListener();
    this._addRefreshListener();
  }
  _addRemoveListener() {
    const removeCommands = [SetCellEditVisibleOperation.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (removeCommands.includes(command.id)) {
          this._markSelectionService.removeAllShapes();
        } else {
          const shapes = this._markSelectionService.getShapeMap();
          shapes.forEach((shape, id) => {
            if (shape.exits.includes(command.id)) {
              this._markSelectionService.removeShape(id);
            }
          });
        }
      })
    );
  }
  _addRefreshListener() {
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((skeleton) => {
      if (skeleton) {
        this._markSelectionService.refreshShapes();
      }
    }));
  }
};
MarkSelectionRenderController = __decorateClass([
  __decorateParam(1, Inject(IMarkSelectionService)),
  __decorateParam(2, ICommandService),
  __decorateParam(3, Inject(SheetSkeletonManagerService))
], MarkSelectionRenderController);

// ../packages/sheets-ui/src/views/mobile/sheet-bar/MobileSheetBar.tsx
var import_react20 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/mobile/sheet-bar/index.module.less
var index_module_default12 = {
  "mobileSheetBarContainer": "univer-mobile-sheet-bar-container",
  "mobileSheetBarSlider": "univer-mobile-sheet-bar-slider",
  "mobileSheetBarItem": "univer-mobile-sheet-bar-item",
  "mobileSheetBarItemActivated": "univer-mobile-sheet-bar-item-activated"
};

// ../packages/sheets-ui/src/views/mobile/sheet-bar/MobileSheetBar.tsx
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
function MobileSheetBar() {
  const workbook = useActiveWorkbook();
  if (!workbook) {
    return null;
  }
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(MobileSheetBarImpl, { workbook });
}
function MobileSheetBarImpl(props) {
  const { workbook } = props;
  const [sheetList, setSheetList] = (0, import_react20.useState)([]);
  const [activeKey, setActiveKey] = (0, import_react20.useState)("");
  const tabMapRef = (0, import_react20.useRef)(/* @__PURE__ */ new Map());
  const commandService = useDependency(ICommandService);
  const updateSheetItems = (0, import_react20.useCallback)(() => {
    const currentSubUnitId = workbook.getActiveSheet().getSheetId();
    const sheets = workbook.getSheets();
    const activeSheet = workbook.getActiveSheet();
    const sheetListItems = sheets.filter((sheet) => !sheet.isSheetHidden()).map((sheet, index) => {
      var _a;
      return {
        sheetId: sheet.getSheetId(),
        label: sheet.getName(),
        index,
        selected: activeSheet === sheet,
        color: (_a = sheet.getTabColor()) != null ? _a : void 0
      };
    });
    setSheetList(sheetListItems);
    setActiveKey(currentSubUnitId);
    if (tabMapRef.current.has(currentSubUnitId)) {
      const element = tabMapRef.current.get(currentSubUnitId);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "nearest" });
      }
    }
    tabMapRef.current.clear();
  }, [workbook]);
  (0, import_react20.useEffect)(() => updateSheetItems(), [updateSheetItems]);
  const onTabClick = (0, import_react20.useCallback)((sheetId) => {
    commandService.executeCommand(SetWorksheetActiveOperation.id, {
      unitId: workbook.getUnitId(),
      subUnitId: sheetId
    });
  }, [commandService, workbook]);
  (0, import_react20.useEffect)(() => {
    const disposable = commandService.onCommandExecuted((commandInfo) => {
      switch (commandInfo.id) {
        case SetWorksheetHideMutation.id:
        case RemoveSheetMutation.id:
        case SetWorksheetNameMutation.id:
        case InsertSheetMutation.id:
        case SetWorksheetOrderMutation.id:
        case SetWorksheetActiveOperation.id:
          updateSheetItems();
          break;
        default:
          break;
      }
    });
    return () => disposable.dispose();
  }, [commandService, updateSheetItems]);
  return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", { className: index_module_default12.mobileSheetBarContainer, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", { className: index_module_default12.mobileSheetBarSlider, children: sheetList.map((sheet) => /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
    "div",
    {
      className: clsx(
        index_module_default12.mobileSheetBarItem,
        {
          [index_module_default12.mobileSheetBarItemActivated]: sheet.sheetId === activeKey
        }
      ),
      onClick: () => onTabClick(sheet.sheetId),
      ref: (element) => {
        tabMapRef.current.set(sheet.sheetId, element);
      },
      children: sheet.label
    },
    sheet.sheetId
  )) }) });
}

// ../packages/sheets-ui/src/controllers/mobile/menu.schema.ts
var menuSchema2 = {
  ["contextMenu.mainArea" /* MAIN_AREA */]: {
    ["contextMenu.format" /* FORMAT */]: {
      [SheetCopyCommand.name]: {
        order: 0,
        menuItemFactory: CopyMenuItemFactory
      }
    },
    ["contextMenu.data" /* DATA */]: {
      order: 2
    },
    ["contextMenu.others" /* OTHERS */]: {
      order: 3
    }
  },
  ["contextMenu.colHeader" /* COL_HEADER */]: {
    ["contextMenu.format" /* FORMAT */]: {
      [SheetCopyCommand.name]: {
        order: 0,
        menuItemFactory: CopyMenuItemFactory
      }
    },
    ["contextMenu.layout" /* LAYOUT */]: {
      order: 1
    },
    ["contextMenu.data" /* DATA */]: {
      order: 2
    },
    ["contextMenu.others" /* OTHERS */]: {
      order: 3
    }
  },
  ["contextMenu.rowHeader" /* ROW_HEADER */]: {
    ["contextMenu.format" /* FORMAT */]: {
      [SheetCopyCommand.name]: {
        order: 0,
        menuItemFactory: CopyMenuItemFactory
      }
    },
    ["contextMenu.layout" /* LAYOUT */]: {
      order: 1
    },
    ["contextMenu.data" /* DATA */]: {
      order: 2
    },
    ["contextMenu.others" /* OTHERS */]: {
      order: 3
    }
  }
};

// ../packages/sheets-ui/src/controllers/mobile/mobile-sheet-ui.controller.ts
var SheetUIMobileController = class extends Disposable {
  constructor(_injector, _componentManager, _layoutService, _commandService, _shortcutService, _menuManagerService, _uiPartsService) {
    super();
    this._injector = _injector;
    this._componentManager = _componentManager;
    this._layoutService = _layoutService;
    this._commandService = _commandService;
    this._shortcutService = _shortcutService;
    this._menuManagerService = _menuManagerService;
    this._uiPartsService = _uiPartsService;
    this._init();
  }
  _init() {
    this._initCustomComponents();
    this._initCommands();
    this._initMenus();
    this._initShortcuts();
    this._initWorkbenchParts();
    this._initFocusHandler();
  }
  _initCustomComponents() {
    const componentManager = this._componentManager;
    this.disposeWithMe(componentManager.register(MENU_ITEM_INPUT_COMPONENT, MenuItemInput));
    this.disposeWithMe(componentManager.register(BORDER_PANEL_COMPONENT, BorderPanel));
    this.disposeWithMe(componentManager.register(COLOR_PICKER_COMPONENT, ColorPicker));
    this.disposeWithMe(componentManager.register(FONT_FAMILY_COMPONENT, FontFamily));
    this.disposeWithMe(componentManager.register(FONT_FAMILY_ITEM_COMPONENT, FontFamilyItem));
    this.disposeWithMe(componentManager.register(FONT_SIZE_COMPONENT, FontSize));
    this.disposeWithMe(componentManager.register(DEFINED_NAME_CONTAINER, DefinedNameContainer));
  }
  _initCommands() {
    [
      AddWorksheetMergeAllCommand2,
      AddWorksheetMergeCommand2,
      AddWorksheetMergeHorizontalCommand2,
      AddWorksheetMergeVerticalCommand2,
      ChangeZoomRatioCommand,
      ExpandSelectionCommand,
      MoveSelectionCommand,
      MoveSelectionEnterAndTabCommand,
      RenameSheetOperation,
      RemoveSheetConfirmCommand,
      RemoveRowConfirmCommand,
      RemoveColConfirmCommand,
      HideRowConfirmCommand,
      HideColConfirmCommand,
      ScrollCommand,
      ScrollToCellCommand,
      SelectAllCommand,
      SetActivateCellEditOperation,
      SetBoldCommand,
      SetCellEditVisibleArrowOperation,
      SetCellEditVisibleOperation,
      SetCellEditVisibleWithF2Operation,
      SetRangeBoldCommand,
      SetRangeItalicCommand,
      SetRangeUnderlineCommand,
      SetRangeStrickThroughCommand,
      SetRangeSubscriptCommand,
      SetRangeSuperscriptCommand,
      SetRangeFontSizeCommand,
      SetRangeFontFamilyCommand,
      SetRangeTextColorCommand,
      SetItalicCommand,
      SetStrikeThroughCommand,
      SetFontFamilyCommand,
      SetFontSizeCommand,
      SetFormatPainterOperation,
      SetInfiniteFormatPainterCommand,
      SetOnceFormatPainterCommand,
      ApplyFormatPainterCommand,
      SetScrollOperation,
      SetScrollRelativeCommand,
      SetSelectionFrozenCommand,
      SetRowFrozenCommand,
      SetColumnFrozenCommand,
      SetUnderlineCommand,
      SetZoomRatioCommand,
      SetZoomRatioOperation,
      ShowMenuListCommand,
      RefillCommand,
      InsertRangeMoveDownConfirmCommand,
      DeleteRangeMoveUpConfirmCommand,
      InsertRangeMoveRightConfirmCommand,
      DeleteRangeMoveLeftConfirmCommand,
      SidebarDefinedNameOperation,
      AutoFillCommand,
      AutoClearContentCommand,
      // permission
      SheetPermissionOpenPanelOperation,
      SheetPermissionOpenDialogOperation,
      AddRangeProtectionFromToolbarCommand,
      AddRangeProtectionFromContextMenuCommand,
      ViewSheetPermissionFromContextMenuCommand,
      AddRangeProtectionFromSheetBarCommand,
      ViewSheetPermissionFromSheetBarCommand,
      ChangeSheetProtectionFromSheetBarCommand,
      DeleteRangeProtectionFromContextMenuCommand,
      SetRangeProtectionFromContextMenuCommand,
      DeleteWorksheetProtectionFormSheetBarCommand
    ].forEach((c) => {
      this.disposeWithMe(this._commandService.registerCommand(c));
    });
  }
  _initMenus() {
    this._menuManagerService.mergeMenu(menuSchema2);
  }
  _initShortcuts() {
    [
      // selection shortcuts
      MoveSelectionDownShortcutItem,
      MoveSelectionUpShortcutItem,
      MoveSelectionLeftShortcutItem,
      MoveSelectionRightShortcutItem,
      MoveSelectionTabShortcutItem,
      MoveSelectionTabLeftShortcutItem,
      MoveSelectionEnterShortcutItem,
      MoveSelectionEnterUpShortcutItem,
      // MoveBackSelectionShortcutItem,
      MoveSelectionEndDownShortcutItem,
      MoveSelectionEndUpShortcutItem,
      MoveSelectionEndLeftShortcutItem,
      MoveSelectionEndRightShortcutItem,
      ExpandSelectionDownShortcutItem,
      ExpandSelectionUpShortcutItem,
      ExpandSelectionLeftShortcutItem,
      ExpandSelectionRightShortcutItem,
      ExpandSelectionEndDownShortcutItem,
      ExpandSelectionEndUpShortcutItem,
      ExpandSelectionEndLeftShortcutItem,
      ExpandSelectionEndRightShortcutItem,
      SelectAllShortcutItem,
      // view shortcuts
      ZoomInShortcutItem,
      ZoomOutShortcutItem,
      ResetZoomShortcutItem,
      PreventDefaultResetZoomShortcutItem,
      PreventDefaultZoomInShortcutItem,
      PreventDefaultZoomOutShortcutItem,
      // toggle cell style shortcuts
      SetBoldShortcutItem,
      SetItalicShortcutItem,
      SetUnderlineShortcutItem,
      SetStrikeThroughShortcutItem,
      // cell content editing shortcuts
      ClearSelectionValueShortcutItem,
      ...generateArrowSelectionShortCutItem(),
      EditorCursorEnterShortcut,
      StartEditWithF2Shortcut,
      EditorCursorTabShortcut,
      EditorBreakLineShortcut,
      EditorDeleteLeftShortcut,
      EditorDeleteLeftShortcutInActive,
      EditorCursorEscShortcut,
      // operation shortcuts
      SetRowHiddenShortcutItem,
      SetColHiddenShortcutItem
    ].forEach((item) => {
      this.disposeWithMe(this._shortcutService.registerShortcut(item));
    });
  }
  _initWorkbenchParts() {
    this._uiPartsService.registerComponent("header" /* HEADER */, () => connectInjector(MobileSheetBar, this._injector));
  }
  _initFocusHandler() {
    this.disposeWithMe(
      this._layoutService.registerFocusHandler(O.UNIVER_SHEET, (_unitId) => {
      })
    );
  }
};
SheetUIMobileController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, Inject(ComponentManager)),
  __decorateParam(2, ILayoutService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, IShortcutService),
  __decorateParam(5, IMenuManagerService),
  __decorateParam(6, IUIPartsService)
], SheetUIMobileController);

// ../packages/sheets-ui/src/views/permission/error-msg-dialog/interface.ts
var UNIVER_SHEET_PERMISSION_ALERT_DIALOG_ID = "UNIVER_SHEET_PERMISSION_ALERT_DIALOG_ID";
var UNIVER_SHEET_PERMISSION_ALERT_DIALOG = "UNIVER_SHEET_PERMISSION_ALERT_DIALOG";

// ../packages/sheets-ui/src/controllers/permission/sheet-permission-check-ui.controller.ts
var SheetPermissionCheckUIController = class extends Disposable {
  constructor(_commandService, _univerInstanceService, _permissionService, _dialogService, _rangeProtectionRuleModel, _autoFillService, _localeService, _contextService, _sheetPermissionCheckController) {
    super();
    this._commandService = _commandService;
    this._univerInstanceService = _univerInstanceService;
    this._permissionService = _permissionService;
    this._dialogService = _dialogService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._autoFillService = _autoFillService;
    this._localeService = _localeService;
    this._contextService = _contextService;
    this._sheetPermissionCheckController = _sheetPermissionCheckController;
    __publicField(this, "disposableCollection", new DisposableCollection());
    this._initialize();
    this._initUIEvent();
  }
  _initUIEvent() {
    this.disposeWithMe(
      this._sheetPermissionCheckController.triggerPermissionUIEvent$.subscribe((errorMsg) => {
        this._haveNotPermissionHandle(errorMsg);
      })
    );
  }
  _haveNotPermissionHandle(errorMsg) {
    const dialogProps = {
      id: UNIVER_SHEET_PERMISSION_ALERT_DIALOG_ID,
      title: { title: "" },
      children: {
        label: UNIVER_SHEET_PERMISSION_ALERT_DIALOG,
        errorMsg
      },
      width: 320,
      destroyOnClose: true,
      onClose: () => this._dialogService.close(UNIVER_SHEET_PERMISSION_ALERT_DIALOG_ID),
      className: "sheet-permission-user-dialog"
    };
    if (this._permissionService.getShowComponents()) {
      this._dialogService.open(dialogProps);
    }
  }
  _getPermissionCheck(id, params) {
    var _a, _b;
    let permission = true;
    let errorMsg = "";
    switch (id) {
      case InsertCommand.id:
      case IMEInputCommand.id:
        if (this._contextService.getContextValue(FOCUSING_EDITOR_STANDALONE) === true) {
          break;
        }
        permission = this._sheetPermissionCheckController.permissionCheckWithoutRange({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetSetCellValuePermission, WorksheetEditPermission]
        });
        errorMsg = this._localeService.t("permission.dialog.editErr");
        break;
      case SetCellEditVisibleOperation.id:
        if (params.visible === false) {
          break;
        }
        permission = this._sheetPermissionCheckController.permissionCheckWithoutRange({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetSetCellValuePermission, WorksheetEditPermission]
        });
        errorMsg = this._localeService.t("permission.dialog.editErr");
        break;
      case SheetPasteColWidthCommand.id:
        permission = this._sheetPermissionCheckController.permissionCheckWithoutRange({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetEditPermission, WorksheetSetColumnStylePermission]
        });
        errorMsg = this._localeService.t("permission.dialog.pasteErr");
        break;
      case SheetPasteShortKeyCommand.id:
        permission = this._permissionCheckByPaste(params);
        errorMsg = this._localeService.t("permission.dialog.pasteErr");
        break;
      case ApplyFormatPainterCommand.id:
        permission = this._sheetPermissionCheckController.permissionCheckWithRanges({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetEditPermission, WorksheetSetCellValuePermission, WorksheetSetCellStylePermission]
        });
        errorMsg = this._localeService.t("permission.dialog.commonErr");
        break;
      case SetBackgroundColorCommand.id:
      case SetRangeBoldCommand.id:
      case SetRangeItalicCommand.id:
      case SetRangeUnderlineCommand.id:
      case SetRangeStrickThroughCommand.id:
        permission = this._sheetPermissionCheckController.permissionCheckWithRanges({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetSetCellStylePermission, WorksheetEditPermission]
        });
        errorMsg = this._localeService.t("permission.dialog.setStyleErr");
        break;
      case SheetCopyCommand.id:
        permission = this._sheetPermissionCheckController.permissionCheckWithRanges({
          workbookTypes: [WorkbookCopyPermission],
          rangeTypes: [RangeProtectionPermissionViewPoint],
          worksheetTypes: [WorksheetCopyPermission]
        });
        errorMsg = this._localeService.t("permission.dialog.copyErr");
        if (!((_a = this._permissionService.getPermissionPoint(new WorkbookCopyPermission(this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getUnitId()).id)) == null ? void 0 : _a.value)) {
          errorMsg = this._localeService.t("permission.dialog.workbookCopyErr");
        }
        break;
      case SheetCutCommand.id:
        permission = this._sheetPermissionCheckController.permissionCheckWithRanges({
          workbookTypes: [WorkbookCopyPermission, WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionViewPoint, RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetCopyPermission, WorksheetEditPermission]
        });
        errorMsg = this._localeService.t("permission.dialog.copyErr");
        if (!((_b = this._permissionService.getPermissionPoint(new WorkbookCopyPermission(this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getUnitId()).id)) == null ? void 0 : _b.value)) {
          errorMsg = this._localeService.t("permission.dialog.workbookCopyErr");
        }
        break;
      case AutoFillCommand.id:
        permission = this._permissionCheckByAutoFillCommand(params);
        errorMsg = this._localeService.t("permission.dialog.autoFillErr");
        break;
      default:
        break;
    }
    if (!permission) {
      this._sheetPermissionCheckController.blockExecuteWithoutPermission(errorMsg);
    }
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((command) => {
        this._getPermissionCheck(command.id, command == null ? void 0 : command.params);
      })
    );
  }
  _permissionCheckByPaste(params) {
    if (params.value === PREDEFINED_HOOK_NAME.SPECIAL_PASTE_VALUE || params.value === PREDEFINED_HOOK_NAME.SPECIAL_PASTE_FORMULA) {
      return this._sheetPermissionCheckController.permissionCheckWithRanges({
        workbookTypes: [WorkbookEditablePermission],
        rangeTypes: [RangeProtectionPermissionEditPoint],
        worksheetTypes: [WorksheetSetCellStylePermission, WorksheetEditPermission]
      });
    } else if (params.value === PREDEFINED_HOOK_NAME.SPECIAL_PASTE_FORMAT) {
      return this._sheetPermissionCheckController.permissionCheckWithRanges({
        workbookTypes: [WorkbookEditablePermission],
        rangeTypes: [RangeProtectionPermissionEditPoint],
        worksheetTypes: [WorksheetSetCellStylePermission, WorksheetEditPermission]
      });
    } else {
      return this._sheetPermissionCheckController.permissionCheckWithRanges({
        workbookTypes: [WorkbookEditablePermission],
        rangeTypes: [RangeProtectionPermissionEditPoint],
        worksheetTypes: [WorksheetSetCellValuePermission, WorksheetSetCellStylePermission, WorksheetEditPermission]
      });
    }
  }
  _permissionCheckByAutoFillCommand(params) {
    if (!params) {
      return false;
    }
    const { targetRange } = params;
    const target = getSheetCommandTarget(this._univerInstanceService);
    if (!target) {
      return false;
    }
    const { worksheet, unitId, subUnitId } = target;
    const permissionLapRanges = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).reduce((p, c) => {
      return [...p, ...c.ranges];
    }, []).filter((range) => {
      return Rectangle.intersects(range, targetRange);
    });
    const hasNotPermission = permissionLapRanges.some((range) => {
      var _a, _b;
      for (let row = range.startRow; row <= range.endRow; row++) {
        for (let col = range.startColumn; col <= range.endColumn; col++) {
          const permission = (_b = (_a = worksheet.getCell(row, col)) == null ? void 0 : _a.selectionProtection) == null ? void 0 : _b[0];
          if ((permission == null ? void 0 : permission[D.Edit]) === false) {
            return true;
          }
        }
      }
      return false;
    });
    return !hasNotPermission;
  }
};
SheetPermissionCheckUIController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IPermissionService),
  __decorateParam(3, IDialogService),
  __decorateParam(4, Inject(RangeProtectionRuleModel)),
  __decorateParam(5, IAutoFillService),
  __decorateParam(6, Inject(LocaleService)),
  __decorateParam(7, IContextService),
  __decorateParam(8, Inject(SheetPermissionCheckController))
], SheetPermissionCheckUIController);

// ../packages/sheets-ui/src/controllers/render-controllers/freeze.render-controller.ts
var FREEZE_ROW_MAIN_NAME = "__SpreadsheetFreezeRowMainName__";
var FREEZE_ROW_HEADER_NAME = "__SpreadsheetFreezeRowHeaderName__";
var FREEZE_COLUMN_MAIN_NAME = "__SpreadsheetFreezeColumnMainName__";
var FREEZE_COLUMN_HEADER_NAME = "__SpreadsheetFreezeColumnHeaderName__";
var FREEZE_SIZE_NORMAL = 2;
var AUXILIARY_CLICK_HIDDEN_OBJECT_TRANSPARENCY = 0.01;
var FREEZE_PERMISSION_CHECK = createInterceptorKey("freezePermissionCheck");
var HeaderFreezeRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _commandService, _selectionManagerService, _scrollManagerService, _themeService, _sheetInterceptorService, _injector) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._commandService = _commandService;
    this._selectionManagerService = _selectionManagerService;
    this._scrollManagerService = _scrollManagerService;
    this._themeService = _themeService;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._injector = _injector;
    __publicField(this, "_rowFreezeHeaderRect");
    __publicField(this, "_rowFreezeMainRect");
    __publicField(this, "_columnFreezeHeaderRect");
    __publicField(this, "_columnFreezeMainRect");
    __publicField(this, "_freezeDownSubs");
    __publicField(this, "_freezePointerEnterSubs");
    __publicField(this, "_freezePointerLeaveSubs");
    __publicField(this, "_scenePointerMoveSub");
    __publicField(this, "_scenePointerUpSub");
    __publicField(this, "_changeToRow", -1);
    __publicField(this, "_changeToColumn", -1);
    __publicField(this, "_changeToOffsetX", 0);
    __publicField(this, "_changeToOffsetY", 0);
    __publicField(this, "_activeViewport", null);
    __publicField(this, "_freezeNormalHeaderColor", "");
    __publicField(this, "_freezeNormalMainColor", "");
    __publicField(this, "_freezeActiveColor", "");
    __publicField(this, "_freezeHoverColor", "");
    __publicField(this, "_lastFreeze");
    __publicField(this, "interceptor", new InterceptorManager({ FREEZE_PERMISSION_CHECK }));
    this._initialize();
  }
  dispose() {
    super.dispose();
  }
  _initialize() {
    this._skeletonListener();
    this._commandExecutedListener();
    this._themeChangeListener();
    this._interceptorCommands();
    this._bindViewportScroll();
    this._zoomRefresh();
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _createFreeze(freezeDirectionType = 0 /* ROW */, freezeConfig) {
    var _a;
    const config = freezeConfig != null ? freezeConfig : this._getFreeze();
    if (config == null) return null;
    const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
    const { startRow: freezeRow, startColumn: freezeColumn } = config;
    const position = this._getPositionByIndex(freezeRow, freezeColumn);
    if (position == null || skeleton == null) return null;
    const sheetObject = this._getSheetObject();
    const engine = sheetObject.engine;
    const canvasMaxWidth = (engine == null ? void 0 : engine.width) || 0;
    const canvasMaxHeight = (engine == null ? void 0 : engine.height) || 0;
    const scene = sheetObject.scene;
    const { startX, startY } = position;
    const { rowTotalHeight, columnTotalWidth, rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop } = skeleton;
    const contentWidth = canvasMaxWidth > columnTotalWidth + rowHeaderWidthAndMarginLeft ? canvasMaxWidth : columnTotalWidth + columnHeaderHeightAndMarginTop;
    const contentHeight = canvasMaxHeight > rowTotalHeight + columnHeaderHeightAndMarginTop ? canvasMaxHeight : rowTotalHeight + columnHeaderHeightAndMarginTop;
    this._changeToRow = freezeRow;
    this._changeToColumn = freezeColumn;
    this._changeToOffsetX = startX;
    this._changeToOffsetY = startY;
    const scale = Math.max(scene.scaleX, scene.scaleY);
    let freezeSize = FREEZE_SIZE_NORMAL / Math.max(1, scale);
    if (freezeDirectionType === 0 /* ROW */) {
      if (freezeRow === -1 || freezeRow === 0) {
        freezeSize = freezeSize * 2;
      }
      const freezeOffset = freezeSize;
      this._rowFreezeHeaderRect = new Rect(FREEZE_ROW_HEADER_NAME, {
        fill: this._freezeNormalHeaderColor,
        width: rowHeaderWidthAndMarginLeft,
        height: freezeSize,
        left: 0,
        top: startY - freezeOffset,
        zIndex: 3
      });
      let fill = this._freezeNormalHeaderColor;
      if (freezeRow === -1 || freezeRow === 0) {
        fill = this._freezeNormalMainColor;
      }
      this._rowFreezeMainRect = new Rect(FREEZE_ROW_MAIN_NAME, {
        fill,
        width: contentWidth * 2 / scale,
        height: freezeSize,
        left: rowHeaderWidthAndMarginLeft,
        top: startY - freezeOffset,
        zIndex: 3
      });
      scene.addObjects([this._rowFreezeHeaderRect, this._rowFreezeMainRect], SHEET_COMPONENT_HEADER_LAYER_INDEX);
    } else {
      if (freezeColumn === -1 || freezeColumn === 0) {
        freezeSize = freezeSize * 2;
      }
      const FREEZE_OFFSET = freezeSize;
      this._columnFreezeHeaderRect = new Rect(FREEZE_COLUMN_HEADER_NAME, {
        fill: this._freezeNormalHeaderColor,
        width: freezeSize,
        height: columnHeaderHeightAndMarginTop,
        left: startX - FREEZE_OFFSET,
        top: 0,
        zIndex: 3
      });
      let fill = this._freezeNormalHeaderColor;
      if (freezeColumn === -1 || freezeColumn === 0) {
        fill = this._freezeNormalMainColor;
      }
      this._columnFreezeMainRect = new Rect(FREEZE_COLUMN_MAIN_NAME, {
        fill,
        width: freezeSize,
        height: contentHeight * 2 / scale,
        left: startX - FREEZE_OFFSET,
        top: columnHeaderHeightAndMarginTop,
        zIndex: 3
      });
      scene.addObjects([this._columnFreezeHeaderRect, this._columnFreezeMainRect], SHEET_COMPONENT_HEADER_LAYER_INDEX);
    }
    this._eventBinding(freezeDirectionType);
  }
  // eslint-disable-next-line max-lines-per-function
  _eventBinding(freezeDirectionType = 0 /* ROW */) {
    let freezeObjectHeaderRect = this._rowFreezeHeaderRect;
    let freezeObjectMainRect = this._rowFreezeMainRect;
    if (freezeDirectionType === 1 /* COLUMN */) {
      freezeObjectHeaderRect = this._columnFreezeHeaderRect;
      freezeObjectMainRect = this._columnFreezeMainRect;
    }
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    const { scene } = sheetObject;
    this._freezePointerEnterSubs = new Subscription();
    this._freezePointerLeaveSubs = new Subscription();
    this._freezeDownSubs = new Subscription();
    if (freezeObjectMainRect) {
      const _freezeObjectMainRectEnterSub = freezeObjectMainRect.onPointerEnter$.subscribeEvent(() => {
        const permissionCheck = this.interceptor.fetchThroughInterceptors(FREEZE_PERMISSION_CHECK)(true, null);
        if (!permissionCheck) {
          return false;
        }
        freezeObjectHeaderRect == null ? void 0 : freezeObjectHeaderRect.setProps({
          fill: this._freezeHoverColor,
          zIndex: 4
        });
        scene.setCursor("grab" /* GRAB */);
      });
      this._freezePointerEnterSubs.add(_freezeObjectMainRectEnterSub);
      const _freezeObjectMainPointerLeaveSub = freezeObjectMainRect.onPointerLeave$.subscribeEvent(() => {
        freezeObjectHeaderRect == null ? void 0 : freezeObjectHeaderRect.setProps({
          fill: this._freezeNormalHeaderColor,
          zIndex: 3
        });
        scene.resetCursor();
      });
      this._freezePointerLeaveSubs.add(_freezeObjectMainPointerLeaveSub);
    }
    if (freezeObjectHeaderRect) {
      const _freezeObjHeaderPointerEnterSub = freezeObjectHeaderRect.onPointerEnter$.subscribeEvent(() => {
        const permissionCheck = this.interceptor.fetchThroughInterceptors(FREEZE_PERMISSION_CHECK)(true, null);
        if (!permissionCheck) {
          return false;
        }
        freezeObjectHeaderRect == null ? void 0 : freezeObjectHeaderRect.setProps({
          fill: this._freezeHoverColor,
          zIndex: 4
        });
        scene.setCursor("grab" /* GRAB */);
      });
      this._freezePointerEnterSubs.add(_freezeObjHeaderPointerEnterSub);
      const _freezeObjHeaderPointerLeaveSub = freezeObjectHeaderRect.onPointerLeave$.subscribeEvent(() => {
        freezeObjectHeaderRect == null ? void 0 : freezeObjectHeaderRect.setProps({
          fill: this._freezeNormalHeaderColor,
          zIndex: 3
        });
        scene.resetCursor();
      });
      this._freezePointerLeaveSubs.add(_freezeObjHeaderPointerLeaveSub);
    }
    const s1 = freezeObjectHeaderRect == null ? void 0 : freezeObjectHeaderRect.onPointerDown$.subscribeEvent((evt) => {
      this._freezeDown(evt, freezeObjectHeaderRect, freezeObjectMainRect, freezeDirectionType);
    });
    if (s1) {
      this._freezeDownSubs.add(s1);
    }
    const s2 = freezeObjectMainRect == null ? void 0 : freezeObjectMainRect.onPointerDown$.subscribeEvent((evt) => {
      this._freezeDown(evt, freezeObjectHeaderRect, freezeObjectMainRect, freezeDirectionType);
    });
    if (s2) {
      this._freezeDownSubs.add(s2);
    }
  }
  // eslint-disable-next-line complexity
  _getCurrentLastVisible() {
    var _a, _b, _c, _d, _e, _f, _g;
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
    if (skeleton == null) {
      return;
    }
    const scene = sheetObject.scene;
    const scale = Math.max(scene.scaleX, scene.scaleY);
    const currentScroll = this._scrollManagerService.getCurrentScrollState();
    const skeletonViewHeight = (sheetObject.engine.height - skeleton.columnHeaderHeight) / scale;
    const skeletonViewWidth = (sheetObject.engine.width - skeleton.rowHeaderWidth) / scale;
    const startRow = (_b = currentScroll == null ? void 0 : currentScroll.sheetViewStartRow) != null ? _b : 0;
    const startHeight = startRow === 0 ? -((_c = currentScroll == null ? void 0 : currentScroll.offsetY) != null ? _c : 0) : skeleton.rowHeightAccumulation[startRow - 1] - ((_d = currentScroll == null ? void 0 : currentScroll.offsetY) != null ? _d : 0);
    let lastRow = 0;
    let hadFind = false;
    for (let i = startRow, len = skeleton.rowHeightAccumulation.length; i < len; i++) {
      const height = skeleton.rowHeightAccumulation[i];
      if (height - startHeight > skeletonViewHeight) {
        lastRow = i;
        hadFind = true;
        break;
      }
    }
    if (!hadFind) {
      lastRow = skeleton.rowHeightAccumulation.length - 1;
    }
    const startColumn = (_e = currentScroll == null ? void 0 : currentScroll.sheetViewStartColumn) != null ? _e : 0;
    const startWidth = startColumn === 0 ? -((_f = currentScroll == null ? void 0 : currentScroll.offsetX) != null ? _f : 0) : skeleton.columnWidthAccumulation[startColumn - 1] - ((_g = currentScroll == null ? void 0 : currentScroll.offsetX) != null ? _g : 0);
    let lastColumn = 0;
    let hadFindCol = false;
    for (let i = startColumn, len = skeleton.columnWidthAccumulation.length; i < len; i++) {
      const width = skeleton.columnWidthAccumulation[i];
      if (width - startWidth > skeletonViewWidth) {
        lastColumn = i;
        hadFindCol = true;
        break;
      }
    }
    if (!hadFindCol) {
      lastColumn = skeleton.columnWidthAccumulation.length - 1;
    }
    return { lastRow, lastColumn };
  }
  _getActiveViewport(evt) {
    var _a;
    const viewports = (_a = this._getSheetObject()) == null ? void 0 : _a.scene.getViewports();
    if (!viewports) {
      return null;
    }
    return viewports.find((i) => i.isHit(new Vector2(evt.offsetX, evt.offsetY))) || null;
  }
  // eslint-disable-next-line max-lines-per-function
  _freezeDown(evt, freezeObjectHeaderRect, freezeObjectMainRect, freezeDirectionType = 0 /* ROW */) {
    var _a;
    const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
    if (skeleton == null) {
      return;
    }
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    const permissionCheck = this.interceptor.fetchThroughInterceptors(FREEZE_PERMISSION_CHECK)(true, null);
    if (!permissionCheck) {
      return false;
    }
    const { scene } = sheetObject;
    scene.setCursor("grabbing" /* GRABBING */);
    scene.disableObjectsEvent();
    const last = this._getCurrentLastVisible();
    const lastRowY = last === void 0 ? Number.POSITIVE_INFINITY : skeleton.rowHeightAccumulation[last.lastRow];
    const lastColumnX = last === void 0 ? Number.POSITIVE_INFINITY : skeleton.columnWidthAccumulation[last.lastColumn - 1] + skeleton.rowHeaderWidth;
    this._activeViewport = null;
    const oldFreeze = this._getFreeze();
    if (oldFreeze) {
      this._changeToColumn = oldFreeze.startColumn;
      this._changeToRow = oldFreeze.startRow;
    }
    this._scenePointerMoveSub = scene.onPointerMove$.subscribeEvent((moveEvt) => {
      var _a2, _b, _c, _d;
      const activeViewport = this._getActiveViewport(moveEvt);
      const { startX, startY, row, column } = getCoordByOffset(
        moveEvt.offsetX,
        moveEvt.offsetY,
        scene,
        skeleton,
        activeViewport || void 0,
        true
      );
      const permissionCheck2 = this.interceptor.fetchThroughInterceptors(FREEZE_PERMISSION_CHECK)(true, null);
      if (!permissionCheck2) {
        return false;
      }
      scene.setCursor("grabbing" /* GRABBING */);
      const FREEZE_SIZE = FREEZE_SIZE_NORMAL / Math.max(scene.scaleX, scene.scaleY);
      if (freezeDirectionType === 0 /* ROW */) {
        (_a2 = freezeObjectHeaderRect.transformByState({
          top: Math.min(startY, lastRowY) - FREEZE_SIZE / 2
        })) == null ? void 0 : _a2.setProps({
          fill: this._freezeActiveColor
        });
        (_b = freezeObjectMainRect.transformByState({
          top: Math.min(startY, lastRowY) - FREEZE_SIZE / 2
        })) == null ? void 0 : _b.setProps({
          fill: this._freezeNormalHeaderColor
        });
        this._changeToRow = last === void 0 ? row : Math.min(row, last.lastRow);
        this._changeToOffsetY = Math.min(startY, lastRowY);
        this._activeViewport = activeViewport;
      } else {
        (_c = freezeObjectHeaderRect.transformByState({
          left: Math.min(startX, lastColumnX) - FREEZE_SIZE / 2
        })) == null ? void 0 : _c.setProps({
          fill: this._freezeActiveColor
        });
        (_d = freezeObjectMainRect.transformByState({
          left: Math.min(startX, lastColumnX) - FREEZE_SIZE / 2
        })) == null ? void 0 : _d.setProps({
          fill: this._freezeNormalHeaderColor
        });
        this._changeToColumn = last === void 0 ? column : Math.min(column, last.lastColumn);
        this._changeToOffsetX = startX;
        this._activeViewport = activeViewport;
      }
    });
    this._scenePointerUpSub = scene.onPointerUp$.subscribeEvent(() => {
      var _a2, _b;
      scene.resetCursor();
      scene.enableObjectsEvent();
      this._clearObserverEvent();
      const { rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop } = skeleton;
      if (freezeDirectionType === 0 /* ROW */ && (this._changeToRow === 0 || this._changeToRow === -1) || freezeDirectionType === 1 /* COLUMN */ && (this._changeToColumn === 0 || this._changeToColumn === -1)) {
        freezeObjectHeaderRect.setProps({
          fill: this._freezeNormalHeaderColor
        });
        freezeObjectMainRect.setProps({
          fill: this._freezeNormalMainColor
        });
      } else {
        freezeObjectHeaderRect == null ? void 0 : freezeObjectHeaderRect.setProps({
          fill: this._freezeNormalHeaderColor
        });
        freezeObjectMainRect == null ? void 0 : freezeObjectMainRect.setProps({
          fill: this._freezeNormalHeaderColor
        });
      }
      const FREEZE_SIZE = FREEZE_SIZE_NORMAL / Math.max(scene.scaleX, scene.scaleY);
      if (freezeDirectionType === 0 /* ROW */) {
        if (this._changeToRow === 0 || this._changeToRow === -1) {
          freezeObjectHeaderRect.transformByState({
            top: columnHeaderHeightAndMarginTop - FREEZE_SIZE
          });
          freezeObjectMainRect.transformByState({
            top: columnHeaderHeightAndMarginTop - FREEZE_SIZE
          });
        }
      } else {
        if (this._changeToColumn === 0 || this._changeToColumn === -1) {
          freezeObjectHeaderRect.transformByState({
            left: rowHeaderWidthAndMarginLeft - FREEZE_SIZE
          });
          freezeObjectMainRect.transformByState({
            left: rowHeaderWidthAndMarginLeft - FREEZE_SIZE
          });
        }
      }
      const sheetViewScroll = this._scrollManagerService.getCurrentScrollState() || {
        sheetViewStartRow: 0,
        sheetViewStartColumn: 0
      };
      const { sheetViewStartRow, sheetViewStartColumn } = sheetViewScroll;
      if (sheetViewStartColumn == null || sheetViewStartRow == null) {
        return;
      }
      const workbook = this._context.unit;
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) return;
      const oldFreeze2 = (_a2 = worksheet.getConfig()) == null ? void 0 : _a2.freeze;
      let xSplit = (oldFreeze2 == null ? void 0 : oldFreeze2.xSplit) || 0;
      let ySplit = (oldFreeze2 == null ? void 0 : oldFreeze2.ySplit) || 0;
      const viewPortKey = (_b = this._activeViewport) == null ? void 0 : _b.viewportKey;
      if (freezeDirectionType === 0 /* ROW */) {
        if (!viewPortKey || viewPortKey === "viewLeftTop" /* VIEW_LEFT_TOP */ || viewPortKey === "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */ || viewPortKey === "viewMainTop" /* VIEW_MAIN_TOP */ || viewPortKey === "viewRowTop" /* VIEW_ROW_TOP */) {
          ySplit = this._changeToRow - (oldFreeze2.startRow - oldFreeze2.ySplit);
        } else {
          ySplit = this._changeToRow - sheetViewStartRow;
        }
        ySplit = ySplit < 0 ? 0 : ySplit;
      }
      if (freezeDirectionType === 1 /* COLUMN */) {
        if (!viewPortKey || viewPortKey === "viewLeftTop" /* VIEW_LEFT_TOP */ || viewPortKey === "viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */ || viewPortKey === "viewMainLeft" /* VIEW_MAIN_LEFT */ || viewPortKey === "viewColumnLeft" /* VIEW_COLUMN_LEFT */) {
          xSplit = this._changeToColumn - (oldFreeze2.startColumn - oldFreeze2.xSplit);
        } else {
          xSplit = this._changeToColumn - sheetViewStartColumn;
        }
        xSplit = xSplit < 0 ? 0 : xSplit;
      }
      this._commandService.executeCommand(SetFrozenCommand.id, {
        startRow: ySplit === 0 ? -1 : this._changeToRow,
        startColumn: xSplit === 0 ? -1 : this._changeToColumn,
        ySplit,
        xSplit,
        unitId: workbook.getUnitId(),
        subUnitId: worksheet.getSheetId()
      });
    });
  }
  _getViewports() {
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    const { scene } = sheetObject;
    const viewColumnLeft = scene.getViewport("viewColumnLeft" /* VIEW_COLUMN_LEFT */);
    const viewColumnRight = scene.getViewport("viewColumnRight" /* VIEW_COLUMN_RIGHT */);
    const viewRowTop = scene.getViewport("viewRowTop" /* VIEW_ROW_TOP */);
    const viewRowBottom = scene.getViewport("viewRowBottom" /* VIEW_ROW_BOTTOM */);
    const viewLeftTop = scene.getViewport("viewLeftTop" /* VIEW_LEFT_TOP */);
    const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const viewMainLeftTop = scene.getViewport("viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */);
    const viewMainLeft = scene.getViewport("viewMainLeft" /* VIEW_MAIN_LEFT */);
    const viewMainTop = scene.getViewport("viewMainTop" /* VIEW_MAIN_TOP */);
    if (viewColumnLeft == null || viewColumnRight == null || viewRowTop == null || viewRowBottom == null || viewLeftTop == null || viewMain == null || viewMainLeftTop == null || viewMainLeft == null || viewMainTop == null) {
      return;
    }
    return {
      viewMain,
      viewMainLeftTop,
      viewMainLeft,
      viewMainTop,
      viewColumnLeft,
      viewColumnRight,
      viewRowTop,
      viewRowBottom,
      viewLeftTop
    };
  }
  _bindViewportScroll() {
    const viewports = this._getViewports();
    if (!viewports) {
      return;
    }
    const { viewRowBottom, viewColumnRight, viewMainLeft, viewMainTop } = viewports;
    this.disposeWithMe(
      this._scrollManagerService.validViewportScrollInfo$.subscribe((param) => {
        if (!param) return;
        const { scrollX, scrollY, viewportScrollX, viewportScrollY } = param;
        if (viewRowBottom.isActive) {
          viewRowBottom.updateScrollVal({
            scrollY,
            viewportScrollY
          });
        }
        if (viewColumnRight.isActive) {
          viewColumnRight.updateScrollVal({
            scrollX,
            viewportScrollX
          });
        }
        if (viewMainLeft.isActive) {
          viewMainLeft.updateScrollVal({
            scrollY,
            viewportScrollY
          });
        }
        if (viewMainTop.isActive) {
          viewMainTop.updateScrollVal({
            scrollX,
            viewportScrollX
          });
        }
      })
    );
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _updateViewport(row = -1, column = -1, ySplit = 0, xSplit = 0, resetScroll = 3 /* ALL */) {
    var _a;
    const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
    if (skeleton == null) {
      return;
    }
    const { rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop } = skeleton;
    const viewports = this._getViewports();
    if (!viewports) {
      return;
    }
    const {
      viewMain,
      viewMainLeftTop,
      viewMainLeft,
      viewMainTop,
      viewColumnLeft,
      viewColumnRight,
      viewRowTop,
      viewRowBottom,
      viewLeftTop
    } = viewports;
    viewColumnRight.resizeWhenFreezeChange({
      left: rowHeaderWidthAndMarginLeft,
      top: 0,
      // ctx.clip by the size of viewport, and selection header border is slightly below column header
      // I think it's a bad design, Should not clip for selection rendering in viewport,
      height: columnHeaderHeightAndMarginTop + 1,
      right: 0
    });
    viewRowBottom.resizeWhenFreezeChange({
      left: 0,
      top: columnHeaderHeightAndMarginTop,
      bottom: 0,
      width: rowHeaderWidthAndMarginLeft + 1
    });
    viewLeftTop.resizeWhenFreezeChange({
      left: 0,
      top: 0,
      width: rowHeaderWidthAndMarginLeft + 1,
      height: columnHeaderHeightAndMarginTop
    });
    let isTopView = true;
    let isLeftView = true;
    viewMainLeftTop.enable();
    if (row === -1 || row === 0) {
      isTopView = false;
    }
    if (column === -1 || column === 0) {
      isLeftView = false;
    }
    const startSheetView = skeleton.getNoMergeCellWithCoordByIndex(row - ySplit, column - xSplit, false);
    const endSheetView = skeleton.getNoMergeCellWithCoordByIndex(row, column, false);
    viewMainLeftTop.disable();
    viewMainTop.disable();
    viewMainLeft.disable();
    viewRowTop.disable();
    viewColumnLeft.disable();
    viewMainLeftTop.resetPadding();
    viewMainTop.resetPadding();
    viewMainLeft.resetPadding();
    viewRowTop.resetPadding();
    viewColumnLeft.resetPadding();
    if (isTopView === false && isLeftView === false) {
      viewMain.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop,
        bottom: 0,
        right: 0
      });
      viewMain.resetPadding();
      viewMainLeft.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop,
        bottom: 0,
        width: 0
      });
      viewMainTop.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop,
        height: 0,
        right: 0
      });
      viewMainLeftTop.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop,
        width: 0,
        height: 0
      });
      viewRowTop.resizeWhenFreezeChange({
        left: 0,
        top: columnHeaderHeightAndMarginTop,
        width: rowHeaderWidthAndMarginLeft + 1,
        height: 0
      });
      viewColumnLeft.resizeWhenFreezeChange({
        left: 0,
        top: 0,
        height: columnHeaderHeightAndMarginTop + 1,
        width: 0
      });
    } else if (isTopView === true && isLeftView === false) {
      const topGap = endSheetView.startY - startSheetView.startY;
      viewMain.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop + topGap,
        bottom: 0,
        right: 0
      });
      viewMain.setPadding({
        startY: startSheetView.startY,
        endY: endSheetView.startY,
        startX: 0,
        endX: 0
      });
      if (resetScroll & 2 /* Y */) {
        this._commandService.executeCommand(ScrollCommand.id, {
          sheetViewStartRow: 0,
          offsetY: 0
        });
      }
      viewMainTop.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop,
        height: topGap,
        right: 0
      });
      viewMainTop.updateScrollVal({
        viewportScrollY: startSheetView.startY,
        rawScrollX: viewMain.scrollX,
        viewportScrollX: viewMain.viewportScrollX
      });
      viewRowTop.resizeWhenFreezeChange({
        left: 0,
        top: columnHeaderHeightAndMarginTop,
        width: rowHeaderWidthAndMarginLeft + 1,
        height: topGap
      });
      viewRowTop.updateScrollVal({
        viewportScrollY: startSheetView.startY
      });
      viewRowBottom.resizeWhenFreezeChange({
        left: 0,
        top: columnHeaderHeightAndMarginTop + topGap,
        bottom: 0,
        width: rowHeaderWidthAndMarginLeft + 1
      });
      viewMainTop.enable();
      viewRowTop.enable();
    } else if (isTopView === false && isLeftView === true) {
      const leftGap = endSheetView.startX - startSheetView.startX;
      viewMain.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft + leftGap,
        top: columnHeaderHeightAndMarginTop,
        bottom: 0,
        right: 0
      });
      viewMain.setPadding({
        startX: startSheetView.startX,
        endX: endSheetView.startX,
        startY: 0,
        endY: 0
      });
      if (resetScroll & 1 /* X */) {
        this._commandService.executeCommand(ScrollCommand.id, {
          sheetViewStartColumn: 0,
          offsetX: 0
        });
      }
      viewMainLeft.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop,
        width: leftGap,
        bottom: 0,
        right: 0
      });
      viewMainLeft.updateScrollVal({
        viewportScrollX: startSheetView.startX,
        rawScrollY: viewMain.scrollY,
        viewportScrollY: viewMain.viewportScrollY
      });
      viewColumnLeft.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: 0,
        width: leftGap,
        height: columnHeaderHeightAndMarginTop + 1
      });
      viewColumnLeft.updateScrollVal({
        viewportScrollX: startSheetView.startX
      });
      viewColumnRight.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft + leftGap,
        top: 0,
        height: columnHeaderHeightAndMarginTop + 1,
        right: 0
      });
      viewMainLeft.enable();
      viewColumnLeft.enable();
    } else {
      const leftGap = endSheetView.startX - startSheetView.startX;
      const topGap = endSheetView.startY - startSheetView.startY;
      viewMain.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft + leftGap,
        top: columnHeaderHeightAndMarginTop + topGap,
        bottom: 0,
        right: 0
      });
      viewMain.setPadding({
        startY: startSheetView.startY,
        endY: endSheetView.startY,
        startX: startSheetView.startX,
        endX: endSheetView.startX
      });
      if (resetScroll) {
        this._commandService.executeCommand(ScrollCommand.id, {
          ...resetScroll & 1 /* X */ ? {
            sheetViewStartColumn: 0,
            offsetX: 0
          } : null,
          ...resetScroll & 2 /* Y */ ? {
            sheetViewStartRow: 0,
            offsetY: 0
          } : null
        });
      }
      viewMainLeft.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop + topGap,
        width: leftGap,
        bottom: 0
      });
      viewMainLeft.updateScrollVal({
        viewportScrollX: startSheetView.startX,
        rawScrollY: viewMain.scrollY,
        viewportScrollY: viewMain.viewportScrollY
      });
      viewMainTop.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft + leftGap,
        top: columnHeaderHeightAndMarginTop,
        height: topGap,
        right: 0
      });
      viewMainTop.updateScrollVal({
        viewportScrollY: startSheetView.startY,
        rawScrollX: viewMain.scrollX,
        viewportScrollX: viewMain.viewportScrollX
      });
      viewMainLeftTop.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: columnHeaderHeightAndMarginTop,
        width: leftGap,
        height: topGap
      });
      viewMainLeftTop.updateScrollVal({
        viewportScrollX: startSheetView.startX,
        viewportScrollY: startSheetView.startY
      });
      viewRowTop.resizeWhenFreezeChange({
        left: 0,
        top: columnHeaderHeightAndMarginTop,
        width: rowHeaderWidthAndMarginLeft + 1,
        height: topGap
      });
      viewRowTop.updateScrollVal({
        viewportScrollY: startSheetView.startY
      });
      viewRowBottom.resizeWhenFreezeChange({
        left: 0,
        top: columnHeaderHeightAndMarginTop + topGap,
        bottom: 0,
        width: rowHeaderWidthAndMarginLeft + 1
      });
      viewColumnLeft.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft,
        top: 0,
        width: leftGap,
        height: columnHeaderHeightAndMarginTop + 1
      });
      viewColumnLeft.updateScrollVal({
        viewportScrollX: startSheetView.startX
      });
      viewColumnRight.resizeWhenFreezeChange({
        left: rowHeaderWidthAndMarginLeft + leftGap,
        top: 0,
        height: columnHeaderHeightAndMarginTop + 1,
        right: 0
      });
      viewMainLeftTop.enable();
      viewMainTop.enable();
      viewMainLeft.enable();
      viewRowTop.enable();
      viewColumnLeft.enable();
    }
  }
  /**
   * When switching sheet tabs, it is necessary to update the frozen state of the current view.
   */
  _skeletonListener() {
    this.disposeWithMe(
      toDisposable(
        this._sheetSkeletonManagerService.currentSkeleton$.subscribe((param) => {
          const allowedCommands = [
            SetWorksheetActiveOperation.id,
            InsertRangeMoveDownCommand.id,
            InsertRangeMoveRightCommand.id
          ];
          if (allowedCommands.includes((param == null ? void 0 : param.commandId) || "")) {
            this._refreshCurrent();
          }
        })
      )
    );
  }
  _refreshCurrent() {
    const workbook = this._context.unit;
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return;
    const freeze = worksheet.getConfig().freeze;
    const { startRow = -1, startColumn = -1, ySplit = 0, xSplit = 0 } = freeze;
    this._refreshFreeze(startRow, startColumn, ySplit, xSplit, 0 /* NONE */);
  }
  _themeChangeListener() {
    this._themeChange(this._themeService.getCurrentTheme());
    this.disposeWithMe(
      this._themeService.currentTheme$.subscribe((style) => {
        this._clearFreeze();
        this._themeChange(style);
        this._refreshCurrent();
      })
    );
  }
  _themeChange(style) {
    this._freezeNormalHeaderColor = style.grey400;
    this._freezeNormalMainColor = new ColorKit(style.grey400).setAlpha(AUXILIARY_CLICK_HIDDEN_OBJECT_TRANSPARENCY).toRgbString();
    this._freezeActiveColor = style.primaryColor;
    this._freezeHoverColor = style.grey500;
  }
  // eslint-disable-next-line max-lines-per-function
  _interceptorCommands() {
    this.disposeWithMe(
      this._sheetInterceptorService.interceptCommand({
        // eslint-disable-next-line complexity, max-lines-per-function
        getMutations: (command) => {
          const empty = {
            redos: [],
            undos: []
          };
          const freeze = this._getFreeze();
          if (!freeze) {
            return empty;
          }
          const createFreezeMutationAndRefresh = (newFreeze) => {
            const workbook = this._context.unit;
            const unitId = workbook.getUnitId();
            const worksheet = workbook.getActiveSheet();
            if (!worksheet) {
              return empty;
            }
            const subUnitId = worksheet.getSheetId();
            this._refreshFreeze(
              newFreeze.startRow,
              newFreeze.startColumn,
              newFreeze.ySplit,
              newFreeze.xSplit,
              0 /* NONE */
            );
            const redoMutationParams = {
              ...newFreeze,
              unitId,
              subUnitId,
              resetScroll: false
            };
            const undoMutationParams = SetFrozenMutationFactory(this._injector, redoMutationParams);
            return {
              undos: [{ id: SetFrozenMutation.id, params: undoMutationParams }],
              redos: [{ id: SetFrozenMutation.id, params: redoMutationParams }]
            };
          };
          if (command.id === InsertRowCommand.id) {
            const params = command.params;
            const { range, direction } = params;
            const insertCount = range.endRow - range.startRow + 1;
            if (range.startRow + 1 < freeze.startRow || range.startRow + 1 === freeze.startRow && direction === 0 /* UP */) {
              const newFreeze = {
                ...freeze,
                startRow: Math.max(1, freeze.startRow + insertCount),
                ySplit: Math.max(1, freeze.ySplit + insertCount)
              };
              return createFreezeMutationAndRefresh(newFreeze);
            }
          }
          if (command.id === InsertColCommand.id) {
            const params = command.params;
            const { range, direction } = params;
            const insertCount = range.endColumn - range.startColumn + 1;
            if (range.startColumn + 1 < freeze.startColumn || range.startColumn + 1 === freeze.startColumn && direction === 3 /* LEFT */) {
              const newFreeze = {
                ...freeze,
                startColumn: Math.max(1, freeze.startColumn + insertCount),
                xSplit: Math.max(1, freeze.xSplit + insertCount)
              };
              return createFreezeMutationAndRefresh(newFreeze);
            }
          }
          if (command.id === MoveColsCommand.id) {
            const selections = this._selectionManagerService.getCurrentSelections();
            const {
              fromRange: { startColumn: fromCol },
              toRange: { startColumn: toCol }
            } = command.params;
            const filteredSelections = selections == null ? void 0 : selections.filter(
              (selection) => selection.range.rangeType === 2 /* COLUMN */ && selection.range.startColumn <= fromCol && fromCol <= selection.range.endColumn
            );
            if (!(filteredSelections == null ? void 0 : filteredSelections.length)) {
              return empty;
            }
            const sourceRange = filteredSelections[0].range;
            const targetRange = {
              ...sourceRange,
              startColumn: toCol,
              endColumn: toCol + sourceRange.endColumn - sourceRange.startColumn
            };
            if (!freeze || freeze.startColumn <= 0 || // move out of freeze
            sourceRange.startColumn >= freeze.startColumn && targetRange.startColumn >= freeze.startColumn || // not move
            sourceRange.startColumn === targetRange.startColumn || // move in freeze range
            sourceRange.endColumn < freeze.startColumn && targetRange.startColumn < freeze.startColumn) {
              return empty;
            }
            const totalColCount = sourceRange.endColumn - sourceRange.startColumn + 1;
            const moveFreezeColCount = Math.max(
              Math.min(freeze.startColumn, sourceRange.endColumn + 1) - sourceRange.startColumn,
              0
            );
            let newStartColumn;
            let newXSplit;
            if (targetRange.startColumn >= freeze.startColumn) {
              newStartColumn = Math.max(freeze.startColumn - moveFreezeColCount, 1);
              newXSplit = Math.max(freeze.xSplit - moveFreezeColCount, 1);
            } else {
              newStartColumn = freeze.startColumn + totalColCount - moveFreezeColCount;
              newXSplit = freeze.xSplit + totalColCount - moveFreezeColCount;
            }
            const redoMutationParams = {
              ...freeze,
              startColumn: newStartColumn,
              xSplit: newXSplit
            };
            return createFreezeMutationAndRefresh(redoMutationParams);
          }
          if (command.id === MoveRowsCommand.id) {
            const selections = this._selectionManagerService.getCurrentSelections();
            const {
              fromRange: { startRow: fromRow },
              toRange: { startRow: toRow }
            } = command.params;
            const filteredSelections = selections == null ? void 0 : selections.filter(
              (selection) => selection.range.rangeType === 1 /* ROW */ && selection.range.startRow <= fromRow && fromRow <= selection.range.endRow
            );
            if (!(filteredSelections == null ? void 0 : filteredSelections.length)) {
              return empty;
            }
            const sourceRange = filteredSelections[0].range;
            const targetRange = {
              ...sourceRange,
              startRow: toRow,
              endRow: toRow + sourceRange.endRow - sourceRange.startRow
            };
            if (!freeze || freeze.startRow <= 0 || // move out of freeze
            sourceRange.startRow >= freeze.startRow && targetRange.startRow >= freeze.startRow || // not move
            sourceRange.startRow === targetRange.startRow || // move in freeze range
            sourceRange.endRow < freeze.startRow && targetRange.startRow < freeze.startRow) {
              return empty;
            }
            const totalColCount = sourceRange.endRow - sourceRange.startRow + 1;
            const moveFreezeColCount = Math.max(
              Math.min(freeze.startRow, sourceRange.endRow + 1) - sourceRange.startRow,
              0
            );
            let newStartRow;
            let newYSplit;
            if (targetRange.startRow >= freeze.startRow) {
              newStartRow = Math.max(freeze.startRow - moveFreezeColCount, 1);
              newYSplit = Math.max(freeze.ySplit - moveFreezeColCount, 1);
            } else {
              newStartRow = freeze.startRow + totalColCount - moveFreezeColCount;
              newYSplit = freeze.ySplit + totalColCount - moveFreezeColCount;
            }
            const redoMutationParams = {
              ...freeze,
              startRow: newStartRow,
              ySplit: newYSplit
            };
            return createFreezeMutationAndRefresh(redoMutationParams);
          }
          if (command.id === RemoveColCommand.id || command.id === RemoveRowCommand.id) {
            const params = command.params;
            const range = params.range;
            if (range.rangeType === 2 /* COLUMN */ && range.startColumn < freeze.startColumn) {
              const deleteFreezeColCount = Math.min(freeze.startColumn, range.endColumn + 1) - range.startColumn;
              const newFreeze = {
                ...freeze,
                startColumn: Math.max(1, freeze.startColumn - deleteFreezeColCount),
                xSplit: Math.max(1, freeze.xSplit - deleteFreezeColCount)
              };
              return createFreezeMutationAndRefresh(newFreeze);
            }
            if (params.range.rangeType === 1 /* ROW */ && range.startRow < freeze.startRow) {
              const deleteFreezeRowCount = Math.min(freeze.startRow, range.endRow + 1) - range.startRow;
              const newFreeze = {
                ...freeze,
                startRow: Math.max(1, freeze.startRow - deleteFreezeRowCount),
                ySplit: Math.max(1, freeze.ySplit - deleteFreezeRowCount)
              };
              return createFreezeMutationAndRefresh(newFreeze);
            }
          }
          return empty;
        }
      })
    );
  }
  /**
   * Update freeze line position when some cmds cause sk change.
   */
  // TODO @lumixraku But there is a _zoomRefresh method? Duplicated?
  _commandExecutedListener() {
    this.disposeWithMe(
      // eslint-disable-next-line complexity
      this._commandService.onCommandExecuted((command) => {
        switch (command.id) {
          case SetFrozenMutation.id:
          case SetZoomRatioOperation.id:
            {
              const lastFreeze = this._lastFreeze;
              const workbook = this._context.unit;
              const worksheet = workbook.getActiveSheet();
              const params = command.params;
              const { unitId, subUnitId } = params;
              if (!(unitId === workbook.getUnitId() && subUnitId === (worksheet == null ? void 0 : worksheet.getSheetId()))) {
                return;
              }
              const freeze = worksheet.getConfig().freeze;
              this._lastFreeze = freeze;
              if (freeze == null) {
                return;
              }
              let resetScroll = 0 /* NONE */;
              const { startRow = -1, startColumn = -1, ySplit = 0, xSplit = 0 } = freeze;
              if (!lastFreeze || lastFreeze.startRow !== startRow || lastFreeze.ySplit !== ySplit) {
                resetScroll |= 2 /* Y */;
              }
              if (!lastFreeze || lastFreeze.startColumn !== startColumn || lastFreeze.xSplit !== xSplit) {
                resetScroll |= 1 /* X */;
              }
              if (params.resetScroll === false) {
                resetScroll = 0 /* NONE */;
              }
              this._refreshFreeze(startRow, startColumn, ySplit, xSplit, resetScroll);
            }
            break;
          case SetWorksheetRowHeightMutation.id:
            {
              const freeze = this._getFreeze();
              const isRefresh = freeze && command.params.ranges.some((i) => i.startRow < freeze.startRow);
              if (command.params && isRefresh) {
                this._refreshCurrent();
              }
            }
            break;
          case SetWorksheetColWidthMutation.id:
            {
              const freeze = this._getFreeze();
              if (command.params && freeze && command.params.ranges.some(
                (i) => i.startColumn < freeze.startColumn
              )) {
                this._refreshCurrent();
              }
            }
            break;
          case SetWorksheetRowAutoHeightMutation.id:
            {
              const params = command.params;
              const freeze = this._getFreeze();
              if (freeze && freeze.startRow > -1 && params.rowsAutoHeightInfo.some((info) => info.row < freeze.startRow)) {
                const subscription = this._sheetSkeletonManagerService.currentSkeleton$.subscribe(() => {
                  this._refreshCurrent();
                  setTimeout(() => {
                    subscription.unsubscribe();
                  });
                });
              }
            }
            break;
          case SetColHiddenMutation.id:
          case SetColVisibleMutation.id:
            {
              const params = command.params;
              const freeze = this._getFreeze();
              const ranges = params.ranges;
              if (freeze && freeze.startColumn > -1 && ranges.some((range) => range.startColumn < freeze.startColumn)) {
                this._refreshCurrent();
              }
            }
            break;
          case SetRowHiddenMutation.id:
          case SetRowVisibleMutation.id:
            {
              const params = command.params;
              const freeze = this._getFreeze();
              const ranges = params.ranges;
              if (freeze && freeze.startRow > -1 && ranges.some((range) => range.startRow < freeze.startRow)) {
                this._refreshCurrent();
              }
            }
            break;
          case SetRowHeaderWidthCommand.id:
          case SetColumnHeaderHeightCommand.id:
            this._refreshCurrent();
        }
      })
    );
  }
  _zoomRefresh() {
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    const { scene } = sheetObject;
    this.disposeWithMe(scene.onTransformChange$.subscribeEvent((state) => {
      if (![2 /* scale */, 5 /* all */].includes(state.type)) {
        return;
      }
      this._refreshCurrent();
    }));
  }
  _clearObserverEvent() {
    var _a, _b;
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    (_a = this._scenePointerMoveSub) == null ? void 0 : _a.unsubscribe();
    (_b = this._scenePointerUpSub) == null ? void 0 : _b.unsubscribe();
    this._scenePointerMoveSub = null;
    this._scenePointerUpSub = null;
  }
  _clearFreeze() {
    var _a, _b, _c, _d, _e, _f;
    (_a = this._rowFreezeHeaderRect) == null ? void 0 : _a.dispose();
    (_b = this._rowFreezeMainRect) == null ? void 0 : _b.dispose();
    (_c = this._columnFreezeHeaderRect) == null ? void 0 : _c.dispose();
    (_d = this._columnFreezeMainRect) == null ? void 0 : _d.dispose();
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    [this._freezeDownSubs, this._freezePointerEnterSubs, this._freezePointerLeaveSubs].forEach((s) => {
      s == null ? void 0 : s.unsubscribe();
    });
    this._freezeDownSubs = null;
    this._freezePointerEnterSubs = null;
    this._freezePointerLeaveSubs = null;
    (_e = this._scenePointerMoveSub) == null ? void 0 : _e.unsubscribe();
    (_f = this._scenePointerUpSub) == null ? void 0 : _f.unsubscribe();
    this._scenePointerMoveSub = null;
    this._scenePointerUpSub = null;
  }
  _getPositionByIndex(row, column) {
    var _a;
    const sheetObject = this._getSheetObject();
    if (sheetObject == null) {
      return;
    }
    const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
    const position = skeleton == null ? void 0 : skeleton.getNoMergeCellWithCoordByIndex(row, column);
    if (skeleton == null) {
      return;
    }
    if (position != null && (!isNaN(position.endX) || !isNaN(position.endY))) {
      return position;
    }
    const { rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop } = skeleton;
    return {
      startX: rowHeaderWidthAndMarginLeft,
      endX: rowHeaderWidthAndMarginLeft,
      startY: columnHeaderHeightAndMarginTop,
      endY: columnHeaderHeightAndMarginTop
    };
  }
  _getFreeze() {
    var _a;
    const config = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton.getWorksheetConfig();
    if (config == null) {
      return;
    }
    return config.freeze;
  }
  _getSheetObject() {
    return getSheetObject(this._context.unit, this._context);
  }
  /**
   * Core function of _refreshCurrent
   * @param startRow
   * @param startColumn
   * @param ySplit
   * @param xSplit
   * @param resetScroll
   */
  _refreshFreeze(startRow, startColumn, ySplit, xSplit, resetScroll) {
    var _a;
    const newFreeze = {
      startRow,
      startColumn,
      ySplit,
      xSplit
    };
    this._clearFreeze();
    this._createFreeze(0 /* ROW */, newFreeze);
    this._createFreeze(1 /* COLUMN */, newFreeze);
    this._updateViewport(startRow, startColumn, ySplit, xSplit, resetScroll);
    (_a = this._getSheetObject()) == null ? void 0 : _a.spreadsheet.makeForceDirty();
  }
};
HeaderFreezeRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, ICommandService),
  __decorateParam(3, Inject(SheetsSelectionsService)),
  __decorateParam(4, Inject(SheetScrollManagerService)),
  __decorateParam(5, Inject(ThemeService)),
  __decorateParam(6, Inject(SheetInterceptorService)),
  __decorateParam(7, Inject(Injector))
], HeaderFreezeRenderController);

// ../packages/sheets-ui/src/controllers/render-controllers/header-move.render-controller.ts
var HEADER_MOVE_CONTROLLER_BACKGROUND = "__SpreadsheetHeaderMoveControllerBackground__";
var HEADER_MOVE_CONTROLLER_LINE = "__SpreadsheetHeaderMoveControllerShapeLine__";
var HEADER_MOVE_CONTROLLER_BACKGROUND_FILL = "rgba(0, 0, 0, 0.1)";
var HEADER_MOVE_CONTROLLER_LINE_FILL = "rgb(119, 119, 119)";
var HEADER_MOVE_CONTROLLER_LINE_SIZE = 4;
var HEADER_MOVE_PERMISSION_CHECK = createInterceptorKey("headerMovePermissionCheck");
var HeaderMoveRenderController = class extends Disposable {
  constructor(_context, selectionManagerService, _sheetSkeletonManagerService, _commandService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._commandService = _commandService;
    __publicField(this, "_startOffsetX", Number.NEGATIVE_INFINITY);
    __publicField(this, "_startOffsetY", Number.NEGATIVE_INFINITY);
    __publicField(this, "_moveHelperBackgroundShape");
    __publicField(this, "_moveHelperLineShape");
    __publicField(this, "_headerPointerDownSubs");
    __publicField(this, "_headerPointerMoveSubs");
    __publicField(this, "_headerPointerLeaveSubs");
    __publicField(this, "_dragHeaderMoveSub");
    __publicField(this, "_scenePointerUpSub");
    __publicField(this, "_scrollTimer");
    __publicField(this, "_changeFromColumn", -1);
    __publicField(this, "_changeFromRow", -1);
    __publicField(this, "_changeToColumn", -1);
    __publicField(this, "_changeToRow", -1);
    __publicField(this, "interceptor", new InterceptorManager({ HEADER_MOVE_PERMISSION_CHECK }));
    __publicField(this, "_workbookSelections");
    this._workbookSelections = selectionManagerService.getWorkbookSelections(this._context.unitId);
    this._init();
  }
  dispose() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    (_a = this._moveHelperBackgroundShape) == null ? void 0 : _a.dispose();
    (_b = this._moveHelperLineShape) == null ? void 0 : _b.dispose();
    (_c = this._headerPointerMoveSubs) == null ? void 0 : _c.unsubscribe();
    (_d = this._headerPointerLeaveSubs) == null ? void 0 : _d.unsubscribe();
    (_e = this._headerPointerDownSubs) == null ? void 0 : _e.unsubscribe();
    this._headerPointerMoveSubs = null;
    this._headerPointerLeaveSubs = null;
    this._headerPointerDownSubs = null;
    (_f = this._dragHeaderMoveSub) == null ? void 0 : _f.unsubscribe();
    (_g = this._scenePointerUpSub) == null ? void 0 : _g.unsubscribe();
    this._dragHeaderMoveSub = null;
    this._scenePointerUpSub = null;
    (_h = this._scrollTimer) == null ? void 0 : _h.dispose();
  }
  _init() {
    this._initialRowOrColumn(1 /* ROW */);
    this._initialRowOrColumn(2 /* COLUMN */);
  }
  // eslint-disable-next-line max-lines-per-function
  _initialRowOrColumn(initialType = 1 /* ROW */) {
    const spreadsheetColumnHeader = this._context.components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
    const spreadsheetRowHeader = this._context.components.get("__SpreadsheetRowHeader__" /* ROW */);
    const scene = this._context.scene;
    const eventBindingObject = initialType === 1 /* ROW */ ? spreadsheetRowHeader : spreadsheetColumnHeader;
    const pointerMoveHandler = (evt) => {
      var _a, _b;
      const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
      if (skeleton == null) {
        return;
      }
      const selectionRange = (_b = this._workbookSelections.getCurrentLastSelection()) == null ? void 0 : _b.range;
      if (!selectionRange) return;
      const permissionCheck = this.interceptor.fetchThroughInterceptors(HEADER_MOVE_PERMISSION_CHECK)(false, selectionRange);
      if (!permissionCheck) {
        return;
      }
      const currentSelections = this._workbookSelections.getCurrentSelections();
      const { row, column } = getCoordByOffset(evt.offsetX, evt.offsetY, scene, skeleton);
      const matchSelectionData = matchedSelectionByRowColIndex(
        currentSelections,
        initialType === 1 /* ROW */ ? row : column,
        initialType
      );
      if (!matchSelectionData) {
        scene.resetCursor();
        return;
      }
      scene.setCursor("grab" /* GRAB */);
    };
    const pointerLeaveHandler = () => {
      var _a, _b;
      (_a = this._moveHelperBackgroundShape) == null ? void 0 : _a.hide();
      (_b = this._moveHelperLineShape) == null ? void 0 : _b.hide();
      scene.resetCursor();
    };
    const pointerDownHandler = (evt, state) => {
      var _a, _b;
      if (state.isStopPropagation) return;
      const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
      if (skeleton == null) {
        return;
      }
      const selectionRange = (_b = this._workbookSelections.getCurrentLastSelection()) == null ? void 0 : _b.range;
      if (!selectionRange) return;
      const permissionCheck = this.interceptor.fetchThroughInterceptors(HEADER_MOVE_PERMISSION_CHECK)(false, selectionRange);
      if (!permissionCheck) {
        return;
      }
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
      const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
      const { x: newEvtOffsetX, y: newEvtOffsetY } = relativeCoords;
      this._startOffsetX = newEvtOffsetX;
      this._startOffsetY = newEvtOffsetY;
      const { row, column } = getCoordByOffset(evt.offsetX, evt.offsetY, scene, skeleton);
      let scrollType;
      if (initialType === 1 /* ROW */) {
        this._changeFromRow = row;
        scrollType = 2 /* Y */;
      } else {
        this._changeFromColumn = column;
        scrollType = 1 /* X */;
      }
      const currentSelections = this._workbookSelections.getCurrentSelections();
      const matchSelectionData = matchedSelectionByRowColIndex(
        currentSelections,
        initialType === 1 /* ROW */ ? row : column,
        initialType
      );
      if (!matchSelectionData) {
        return;
      }
      const startScrollXY = scene.getScrollXYInfoByViewport(
        Vector2.FromArray([this._startOffsetX, this._startOffsetY])
      );
      this._newBackgroundAndLine();
      scene.setCursor("grabbing" /* GRABBING */);
      scene.disableObjectsEvent();
      let scrollTimerInitd = false;
      let scrollTimer;
      const initScrollTimer = () => {
        if (scrollTimerInitd) {
          return;
        }
        scrollTimer = ScrollTimer.create(scene, scrollType);
        this._scrollTimer = scrollTimer;
        const mainViewport = scene.getViewport("viewMain" /* VIEW_MAIN */);
        scrollTimer.startScroll(newEvtOffsetX, newEvtOffsetY, mainViewport);
        scrollTimerInitd = true;
      };
      this._dragHeaderMoveSub = scene.onPointerMove$.subscribeEvent((moveEvt) => {
        initScrollTimer();
        const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
        const { x: newMoveOffsetX, y: newMoveOffsetY } = scene.getCoordRelativeToViewport(
          Vector2.FromArray([moveOffsetX, moveOffsetY])
        );
        this._rowColumnMoving(
          newMoveOffsetX,
          newMoveOffsetY,
          matchSelectionData,
          startScrollXY,
          initialType
        );
        scrollTimer.scrolling(newMoveOffsetX, newMoveOffsetY, () => {
          this._rowColumnMoving(
            newMoveOffsetX,
            newMoveOffsetY,
            matchSelectionData,
            startScrollXY,
            initialType
          );
        });
      });
      this._scenePointerUpSub = scene.onPointerUp$.subscribeEvent(() => {
        var _a2, _b2, _c;
        this._disposeBackgroundAndLine();
        scene.resetCursor();
        scene.enableObjectsEvent();
        this._clearObserverEvent();
        (_a2 = this._scrollTimer) == null ? void 0 : _a2.dispose();
        const selections = this._workbookSelections.getCurrentSelections();
        if (initialType === 1 /* ROW */) {
          if (this._changeFromRow !== this._changeToRow && this._changeToRow !== -1) {
            const filteredSelections = (selections == null ? void 0 : selections.filter(
              (selection) => selection.range.rangeType === 1 /* ROW */ && selection.range.startRow <= this._changeFromRow && this._changeFromRow <= selection.range.endRow
            )) || [];
            const range = (_b2 = filteredSelections[0]) == null ? void 0 : _b2.range;
            if (range) {
              this._commandService.executeCommand(MoveRowsCommand.id, {
                fromRange: range,
                toRange: {
                  ...range,
                  startRow: this._changeToRow,
                  endRow: this._changeToRow + range.endRow - range.startRow
                }
              });
            }
          }
          this._changeToRow = this._changeFromRow = -1;
        } else {
          if (this._changeFromColumn !== this._changeToColumn && this._changeToColumn !== -1) {
            const filteredSelections = (selections == null ? void 0 : selections.filter(
              (selection) => selection.range.rangeType === 2 /* COLUMN */ && selection.range.startColumn <= this._changeFromColumn && this._changeFromColumn <= selection.range.endColumn
            )) || [];
            const range = (_c = filteredSelections[0]) == null ? void 0 : _c.range;
            if (range) {
              this._commandService.executeCommand(MoveColsCommand.id, {
                fromRange: range,
                toRange: {
                  ...range,
                  startColumn: this._changeToColumn,
                  endColumn: this._changeToColumn + range.endColumn - range.startColumn
                }
              });
            }
          }
          this._changeToColumn = this._changeFromColumn = -1;
        }
      });
    };
    this._headerPointerMoveSubs = new Subscription();
    this._headerPointerMoveSubs.add(eventBindingObject.onPointerMove$.subscribeEvent(pointerMoveHandler));
    this._headerPointerLeaveSubs = new Subscription();
    this._headerPointerLeaveSubs.add(eventBindingObject == null ? void 0 : eventBindingObject.onPointerLeave$.subscribeEvent(pointerLeaveHandler));
    this._headerPointerDownSubs = new Subscription();
    this._headerPointerDownSubs.add(eventBindingObject == null ? void 0 : eventBindingObject.onPointerDown$.subscribeEvent(pointerDownHandler));
  }
  // eslint-disable-next-line max-lines-per-function
  _rowColumnMoving(moveOffsetX, moveOffsetY, matchSelectionData, startScrollXY, initialType) {
    var _a, _b, _c, _d, _e, _f, _g;
    const scene = this._context.scene;
    const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
    if (skeleton == null) {
      return;
    }
    const { rowHeaderWidth, columnHeaderHeight, rowTotalHeight, columnTotalWidth } = skeleton;
    const scrollXY = scene.getViewportScrollXY(scene.getViewport("viewMain" /* VIEW_MAIN */));
    const { scaleX, scaleY } = scene.getAncestorScale();
    const moveActualSelection = skeleton.getCellIndexByOffset(
      moveOffsetX,
      moveOffsetY,
      scaleX,
      scaleY,
      scrollXY
    );
    const { row, column } = moveActualSelection;
    const startCell = skeleton.getNoMergeCellWithCoordByIndex(row, column);
    const { startX: cellStartX, startY: cellStartY, endX: cellEndX, endY: cellEndY } = startCell;
    const selectionWithCoord = this._sheetSkeletonManagerService.attachRangeWithCoord(matchSelectionData.range);
    if (selectionWithCoord == null) {
      return;
    }
    const scale = Math.max(scaleX, scaleX);
    const {
      startX: selectedStartX,
      endX: selectedEndX,
      startY: selectedStartY,
      endY: selectedEndY,
      startRow: selectedStartRow,
      startColumn: selectedStartColumn,
      endRow: selectedEndRow,
      endColumn: selectedEndColumn
    } = selectionWithCoord;
    if (initialType === 1 /* ROW */) {
      (_b = this._moveHelperBackgroundShape) == null ? void 0 : _b.transformByState({
        height: selectedEndY - selectedStartY,
        width: columnTotalWidth + rowHeaderWidth,
        left: 0,
        top: selectedStartY + (moveOffsetY - this._startOffsetY) / scale + scrollXY.y - startScrollXY.y
      });
    } else {
      (_c = this._moveHelperBackgroundShape) == null ? void 0 : _c.transformByState({
        height: rowTotalHeight + columnHeaderHeight,
        width: selectedEndX - selectedStartX,
        left: selectedStartX + (moveOffsetX - this._startOffsetX) / scale + scrollXY.x - startScrollXY.x,
        top: 0
      });
    }
    (_d = this._moveHelperBackgroundShape) == null ? void 0 : _d.show();
    const HEADER_MOVE_CONTROLLER_LINE_SIZE_SCALE = HEADER_MOVE_CONTROLLER_LINE_SIZE / scale;
    if (initialType === 1 /* ROW */) {
      let top = 0;
      if (row <= selectedStartRow) {
        top = cellStartY - HEADER_MOVE_CONTROLLER_LINE_SIZE_SCALE / 2;
        this._changeToRow = row;
      } else if (row > selectedEndRow) {
        top = cellEndY - HEADER_MOVE_CONTROLLER_LINE_SIZE_SCALE / 2;
        this._changeToRow = row + 1;
      } else {
        return;
      }
      (_e = this._moveHelperLineShape) == null ? void 0 : _e.transformByState({
        height: HEADER_MOVE_CONTROLLER_LINE_SIZE_SCALE,
        width: columnTotalWidth,
        left: rowHeaderWidth,
        top
      });
    } else {
      let left = 0;
      if (column <= selectedStartColumn) {
        left = cellStartX - HEADER_MOVE_CONTROLLER_LINE_SIZE_SCALE / 2;
        this._changeToColumn = column;
      } else if (column > selectedEndColumn) {
        left = cellEndX - HEADER_MOVE_CONTROLLER_LINE_SIZE_SCALE / 2;
        this._changeToColumn = column + 1;
      } else {
        return;
      }
      (_f = this._moveHelperLineShape) == null ? void 0 : _f.transformByState({
        height: rowTotalHeight,
        width: HEADER_MOVE_CONTROLLER_LINE_SIZE_SCALE,
        left,
        top: columnHeaderHeight
      });
    }
    (_g = this._moveHelperLineShape) == null ? void 0 : _g.show();
  }
  _clearObserverEvent() {
    var _a, _b;
    (_a = this._dragHeaderMoveSub) == null ? void 0 : _a.unsubscribe();
    (_b = this._scenePointerUpSub) == null ? void 0 : _b.unsubscribe();
    this._dragHeaderMoveSub = null;
    this._scenePointerUpSub = null;
  }
  _newBackgroundAndLine() {
    const scene = this._context.scene;
    this._moveHelperBackgroundShape = new Rect(HEADER_MOVE_CONTROLLER_BACKGROUND, {
      fill: HEADER_MOVE_CONTROLLER_BACKGROUND_FILL,
      evented: false,
      zIndex: 100
    });
    this._moveHelperLineShape = new Rect(HEADER_MOVE_CONTROLLER_LINE, {
      fill: HEADER_MOVE_CONTROLLER_LINE_FILL,
      evented: false,
      zIndex: 100
    });
    scene.addObjects(
      [this._moveHelperBackgroundShape, this._moveHelperLineShape],
      SHEET_COMPONENT_HEADER_LAYER_INDEX
    );
  }
  _disposeBackgroundAndLine() {
    var _a, _b;
    (_a = this._moveHelperBackgroundShape) == null ? void 0 : _a.dispose();
    (_b = this._moveHelperLineShape) == null ? void 0 : _b.dispose();
  }
};
HeaderMoveRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetsSelectionsService)),
  __decorateParam(2, Inject(SheetSkeletonManagerService)),
  __decorateParam(3, ICommandService)
], HeaderMoveRenderController);

// ../packages/sheets-ui/src/views/header-resize-shape.ts
var HEADER_MENU_SHAPE_RECT_BACKGROUND_FILL = "rgba(120, 120, 120, 0.01)";
var HEADER_MENU_SHAPE_RECT_FILL = "rgb(68, 71, 70)";
var HEADER_MENU_SHAPE_SIZE = 12;
var MAX_HEADER_MENU_SHAPE_SIZE = 44;
var HEADER_MENU_SHAPE_THUMB_SIZE = 4;
var HeaderMenuResizeShape = class extends Shape {
  constructor(key, props) {
    super(key, props);
    __publicField(this, "_size", HEADER_MENU_SHAPE_SIZE);
    __publicField(this, "_color", HEADER_MENU_SHAPE_RECT_FILL);
    __publicField(this, "_mode", 0 /* VERTICAL */);
    this.setShapeProps(props);
  }
  get size() {
    return this._size;
  }
  get mode() {
    return this._mode;
  }
  get color() {
    return this._color;
  }
  _draw(ctx) {
    const scene = this.getScene();
    if (!scene) return;
    const { scaleX, scaleY } = scene.getAncestorScale();
    const scale = Math.max(scaleX, scaleY);
    const HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE = HEADER_MENU_SHAPE_SIZE / scale;
    const HEADER_MENU_SHAPE_THUMB_SIZE_SCALE = HEADER_MENU_SHAPE_THUMB_SIZE / scale;
    let { width, height } = this;
    let left = 0;
    let top = 0;
    if (this.mode === 0 /* VERTICAL */) {
      width = HEADER_MENU_SHAPE_THUMB_SIZE_SCALE;
      left = HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE - HEADER_MENU_SHAPE_THUMB_SIZE_SCALE;
    } else {
      height = HEADER_MENU_SHAPE_THUMB_SIZE_SCALE;
      top = HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE - HEADER_MENU_SHAPE_THUMB_SIZE_SCALE;
    }
    Rect.drawWith(ctx, {
      width: this.width,
      height: this.height,
      left: 0,
      top: 0,
      fill: HEADER_MENU_SHAPE_RECT_BACKGROUND_FILL
    });
    Rect.drawWith(ctx, {
      width,
      height,
      fill: HEADER_MENU_SHAPE_RECT_FILL,
      radius: HEADER_MENU_SHAPE_THUMB_SIZE_SCALE
    });
    ctx.save();
    ctx.transform(1, 0, 0, 1, left, top);
    Rect.drawWith(ctx, {
      width,
      height,
      fill: HEADER_MENU_SHAPE_RECT_FILL,
      radius: HEADER_MENU_SHAPE_THUMB_SIZE_SCALE
    });
    ctx.restore();
  }
  setShapeProps(props) {
    if (props == null ? void 0 : props.size) {
      this._size = props.size;
    }
    if (props == null ? void 0 : props.mode) {
      this._mode = props.mode;
    }
    if (props == null ? void 0 : props.color) {
      this._color = props.color;
    }
    if (this.mode === 0 /* VERTICAL */) {
      this.transformByState({
        width: HEADER_MENU_SHAPE_SIZE,
        height: this.size
      });
    } else {
      this.transformByState({
        width: this.size,
        height: HEADER_MENU_SHAPE_SIZE
      });
    }
    return this;
  }
};

// ../packages/sheets-ui/src/controllers/render-controllers/header-resize.render-controller.ts
var HEADER_RESIZE_CONTROLLER_SHAPE_ROW = "__SpreadsheetHeaderResizeControllerShapeRow__";
var HEADER_RESIZE_CONTROLLER_SHAPE_COLUMN = "__SpreadsheetHeaderResizeControllerShapeColumn__";
var HEADER_RESIZE_CONTROLLER_SHAPE_HELPER = "__SpreadsheetHeaderResizeControllerShapeHelper__";
var HEADER_RESIZE_CONTROLLER_SHAPE_HELPER_COLOR = "rgb(199, 199, 199)";
var MINIMAL_OFFSET = 2;
var HEADER_RESIZE_PERMISSION_CHECK = createInterceptorKey("headerResizePermissionCheck");
var HeaderResizeRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _selectionManagerService, _commandService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._selectionManagerService = _selectionManagerService;
    this._commandService = _commandService;
    __publicField(this, "_currentRow", 0);
    __publicField(this, "_currentColumn", 0);
    __publicField(this, "_rowResizeRect");
    __publicField(this, "_columnResizeRect");
    __publicField(this, "_headerPointerSubs");
    // private _colHeaderPointerSubs: Array<Subscription>;
    __publicField(this, "_scenePointerMoveSub");
    __publicField(this, "_scenePointerUpSub");
    __publicField(this, "_resizeHelperShape");
    __publicField(this, "_startOffsetX", Number.POSITIVE_INFINITY);
    __publicField(this, "_startOffsetY", Number.POSITIVE_INFINITY);
    __publicField(this, "interceptor", new InterceptorManager({ HEADER_RESIZE_PERMISSION_CHECK }));
    this._init();
  }
  dispose() {
    var _a, _b, _c;
    (_a = this._rowResizeRect) == null ? void 0 : _a.dispose();
    this._rowResizeRect = null;
    (_b = this._columnResizeRect) == null ? void 0 : _b.dispose();
    this._columnResizeRect = null;
    (_c = this._headerPointerSubs) == null ? void 0 : _c.unsubscribe();
    this._headerPointerSubs = null;
  }
  _init() {
    const scene = this._context.scene;
    this._rowResizeRect = new HeaderMenuResizeShape(HEADER_RESIZE_CONTROLLER_SHAPE_ROW, {
      visible: false,
      mode: 1 /* HORIZONTAL */,
      zIndex: 100
    });
    this._columnResizeRect = new HeaderMenuResizeShape(HEADER_RESIZE_CONTROLLER_SHAPE_COLUMN, {
      visible: false,
      mode: 0 /* VERTICAL */,
      zIndex: 100
    });
    scene.addObjects([this._rowResizeRect, this._columnResizeRect], SHEET_COMPONENT_HEADER_LAYER_INDEX);
    this._initialHover(0 /* ROW */);
    this._initialHover(1 /* COLUMN */);
    this._initialHoverResize(0 /* ROW */);
    this._initialHoverResize(1 /* COLUMN */);
  }
  _initialHover(initialType = 0 /* ROW */) {
    const spreadsheetColumnHeader = this._context.components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
    const spreadsheetRowHeader = this._context.components.get("__SpreadsheetRowHeader__" /* ROW */);
    const scene = this._context.scene;
    const eventBindingObject = initialType === 0 /* ROW */ ? spreadsheetRowHeader : spreadsheetColumnHeader;
    const pointerLeaveEvent = (_evt, _state) => {
      var _a, _b;
      (_a = this._rowResizeRect) == null ? void 0 : _a.hide();
      (_b = this._columnResizeRect) == null ? void 0 : _b.hide();
    };
    const pointerMoveEvent = (evt, _state) => {
      var _a;
      const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
      if (skeleton == null || this._rowResizeRect == null || this._columnResizeRect == null) {
        return;
      }
      const { rowHeaderWidth, columnHeaderHeight } = skeleton;
      const { startX, startY, endX, endY, row, column } = getCoordByOffset(
        evt.offsetX,
        evt.offsetY,
        scene,
        skeleton
      );
      const transformCoord = getTransformCoord(evt.offsetX, evt.offsetY, scene, skeleton);
      const { scaleX, scaleY } = scene.getAncestorScale();
      const scale = Math.max(scaleX, scaleY);
      const HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE = HEADER_MENU_SHAPE_SIZE / scale;
      if (initialType === 0 /* ROW */) {
        let top = startY - HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2;
        if (transformCoord.y <= startY + HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2 && transformCoord.y >= startY) {
          this._currentRow = row - 1;
        } else if (transformCoord.y >= endY - HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2 && transformCoord.y <= endY) {
          this._currentRow = row;
          top = endY - HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2;
        } else {
          this._rowResizeRect.hide();
          return;
        }
        if (this._currentRow === -1) {
          return;
        }
        const permissionCheck = this.interceptor.fetchThroughInterceptors(HEADER_RESIZE_PERMISSION_CHECK)(null, { row: this._currentRow });
        if (!permissionCheck) {
          return false;
        }
        const rowSize = Math.min(MAX_HEADER_MENU_SHAPE_SIZE, rowHeaderWidth / 3);
        this._rowResizeRect.transformByState({
          left: rowHeaderWidth / 2 - rowSize / 2,
          top
        });
        this._rowResizeRect.setShapeProps({
          size: rowSize
        });
        this._rowResizeRect.show();
      } else {
        let left = startX - HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2;
        if (transformCoord.x <= startX + HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2 && transformCoord.x >= startX) {
          this._currentColumn = column - 1;
        } else if (transformCoord.x >= endX - HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2 && transformCoord.x <= endX) {
          this._currentColumn = column;
          left = endX - HEADER_MENU_SHAPE_WIDTH_HEIGHT_SCALE / 2;
        } else {
          this._columnResizeRect.hide();
          return;
        }
        if (this._currentColumn === -1) {
          return;
        }
        const permissionCheck = this.interceptor.fetchThroughInterceptors(HEADER_RESIZE_PERMISSION_CHECK)(null, { col: this._currentColumn });
        if (!permissionCheck) {
          return false;
        }
        const columnSize = columnHeaderHeight * 0.7;
        this._columnResizeRect.transformByState({
          left,
          top: columnHeaderHeight / 2 - columnSize / 2
        });
        this._columnResizeRect.setShapeProps({
          size: columnSize
        });
        this._columnResizeRect.show();
      }
    };
    this._headerPointerSubs = new Subscription();
    this._headerPointerSubs.add(eventBindingObject == null ? void 0 : eventBindingObject.onPointerMove$.subscribeEvent(pointerMoveEvent));
    this._headerPointerSubs.add(eventBindingObject == null ? void 0 : eventBindingObject.onPointerLeave$.subscribeEvent(pointerLeaveEvent));
  }
  _initialHoverResize(initialType = 0 /* ROW */) {
    const scene = this._context.scene;
    const eventBindingObject = initialType === 0 /* ROW */ ? this._rowResizeRect : this._columnResizeRect;
    if (eventBindingObject == null) {
      return;
    }
    this.disposeWithMe(
      eventBindingObject.onPointerEnter$.subscribeEvent(() => {
        if (eventBindingObject == null) {
          return;
        }
        eventBindingObject.show();
        scene.setCursor(
          initialType === 0 /* ROW */ ? "row-resize" /* ROW_RESIZE */ : "col-resize" /* COLUMN_RESIZE */
        );
      })
    );
    this.disposeWithMe(
      eventBindingObject.onPointerLeave$.subscribeEvent(() => {
        if (eventBindingObject == null) {
          return;
        }
        eventBindingObject.hide();
        scene.resetCursor();
      })
    );
    this.disposeWithMe(
      eventBindingObject.onPointerDown$.subscribeEvent((evt) => {
        var _a, _b, _c, _d, _e, _f, _g;
        const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
        if (skeleton == null) return;
        const scene2 = this._context.scene;
        const engine = scene2.getEngine();
        const canvasMaxHeight = (engine == null ? void 0 : engine.height) || 0;
        const canvasMaxWidth = (engine == null ? void 0 : engine.width) || 0;
        const viewPort = scene2.getViewport("viewMain" /* VIEW_MAIN */);
        const scrollBarHorizontalHeight = (((_c = (_b = viewPort == null ? void 0 : viewPort.getScrollBar()) == null ? void 0 : _b.horizonScrollTrack) == null ? void 0 : _c.height) || 0) + 10;
        const scrollBarVerticalWidth = (((_e = (_d = viewPort == null ? void 0 : viewPort.getScrollBar()) == null ? void 0 : _d.verticalScrollTrack) == null ? void 0 : _e.width) || 0) + 10;
        const transformCoord = getTransformCoord(evt.offsetX, evt.offsetY, scene2, skeleton);
        const { scaleX, scaleY } = scene2.getAncestorScale();
        this._startOffsetX = transformCoord.x;
        this._startOffsetY = transformCoord.y;
        const currentOffsetX = skeleton.getOffsetByColumn(this._currentColumn);
        const currentOffsetY = skeleton.getOffsetByRow(this._currentRow);
        const cell = skeleton.getNoMergeCellWithCoordByIndex(this._currentRow, this._currentColumn);
        let isStartMove = false;
        let moveChangeX = 0;
        let moveChangeY = 0;
        const { columnTotalWidth, rowHeaderWidth, rowTotalHeight, columnHeaderHeight } = skeleton;
        const shapeWidth = canvasMaxWidth > columnTotalWidth + rowHeaderWidth ? canvasMaxWidth : columnTotalWidth + rowHeaderWidth;
        const shapeHeight = canvasMaxHeight > rowTotalHeight + columnHeaderHeight ? canvasMaxHeight : rowTotalHeight + columnHeaderHeight;
        const scale = Math.max(scaleX, scaleY);
        const HEADER_MENU_SHAPE_THUMB_SIZE_SCALE = HEADER_MENU_SHAPE_THUMB_SIZE / scale;
        if (initialType === 0 /* ROW */) {
          this._resizeHelperShape = new Rect(HEADER_RESIZE_CONTROLLER_SHAPE_HELPER, {
            width: shapeWidth,
            height: HEADER_MENU_SHAPE_THUMB_SIZE_SCALE,
            fill: HEADER_RESIZE_CONTROLLER_SHAPE_HELPER_COLOR,
            left: 0,
            top: currentOffsetY - HEADER_MENU_SHAPE_THUMB_SIZE_SCALE / 2
          });
        } else {
          this._resizeHelperShape = new Rect(HEADER_RESIZE_CONTROLLER_SHAPE_HELPER, {
            width: HEADER_MENU_SHAPE_THUMB_SIZE_SCALE,
            height: shapeHeight,
            fill: HEADER_RESIZE_CONTROLLER_SHAPE_HELPER_COLOR,
            left: currentOffsetX - HEADER_MENU_SHAPE_THUMB_SIZE_SCALE / 2,
            top: 0
          });
        }
        const rowResizeRectX = ((_f = this._columnResizeRect) == null ? void 0 : _f.left) || 0;
        const rowResizeRectY = ((_g = this._rowResizeRect) == null ? void 0 : _g.top) || 0;
        scene2.addObject(this._resizeHelperShape, SHEET_COMPONENT_HEADER_LAYER_INDEX);
        scene2.disableObjectsEvent();
        this._scenePointerMoveSub = scene2.onPointerMove$.subscribeEvent((moveEvt) => {
          var _a2, _b2, _c2, _d2, _e2, _f2;
          const relativeCoords = scene2.getCoordRelativeToViewport(
            Vector2.FromArray([this._startOffsetX, this._startOffsetY])
          );
          const scrollXY = scene2.getScrollXYInfoByViewport(relativeCoords, viewPort);
          const transformCoord2 = getTransformCoord(moveEvt.offsetX, moveEvt.offsetY, scene2, skeleton);
          const { x: moveOffsetX, y: moveOffsetY } = transformCoord2;
          const { scaleX: scaleX2, scaleY: scaleY2 } = scene2.getAncestorScale();
          const scale2 = Math.max(scaleX2, scaleY2);
          const HEADER_MENU_SHAPE_THUMB_SIZE_SCALE2 = HEADER_MENU_SHAPE_THUMB_SIZE / scale2;
          moveChangeX = moveOffsetX - this._startOffsetX - HEADER_MENU_SHAPE_THUMB_SIZE_SCALE2 / 2;
          moveChangeY = moveOffsetY - this._startOffsetY - HEADER_MENU_SHAPE_THUMB_SIZE_SCALE2 / 2;
          if (Math.abs(initialType === 0 /* ROW */ ? moveChangeY : moveChangeX) >= MINIMAL_OFFSET) {
            isStartMove = true;
          }
          if (initialType === 0 /* ROW */) {
            if (moveChangeY > canvasMaxHeight - scrollBarHorizontalHeight + scrollXY.y - cell.startY) {
              moveChangeY = canvasMaxHeight - scrollBarHorizontalHeight + scrollXY.y - cell.startY;
            }
            if (moveChangeY < -(cell.endY - cell.startY) + 2) {
              moveChangeY = -(cell.endY - cell.startY) + 2;
            }
            if (isStartMove) {
              (_a2 = this._resizeHelperShape) == null ? void 0 : _a2.transformByState({
                top: currentOffsetY + moveChangeY
              });
              (_b2 = this._rowResizeRect) == null ? void 0 : _b2.transformByState({
                top: rowResizeRectY + moveChangeY + HEADER_MENU_SHAPE_THUMB_SIZE_SCALE2 / 2
              });
              (_c2 = this._rowResizeRect) == null ? void 0 : _c2.show();
              scene2.setCursor("row-resize" /* ROW_RESIZE */);
            }
          } else {
            if (moveChangeX > canvasMaxWidth - scrollBarVerticalWidth + scrollXY.x - cell.startX) {
              moveChangeX = canvasMaxWidth - scrollBarVerticalWidth + scrollXY.x - cell.startX;
            }
            if (moveChangeX < -(cell.endX - cell.startX) + 2) {
              moveChangeX = -(cell.endX - cell.startX) + 2;
            }
            if (isStartMove) {
              (_d2 = this._resizeHelperShape) == null ? void 0 : _d2.transformByState({
                left: currentOffsetX + moveChangeX
              });
              (_e2 = this._columnResizeRect) == null ? void 0 : _e2.transformByState({
                left: rowResizeRectX + moveChangeX + HEADER_MENU_SHAPE_THUMB_SIZE_SCALE2 / 2
              });
              (_f2 = this._columnResizeRect) == null ? void 0 : _f2.show();
              scene2.setCursor("col-resize" /* COLUMN_RESIZE */);
            }
          }
        });
        this._scenePointerUpSub = scene2.onPointerUp$.subscribeEvent((upEvt) => {
          var _a2, _b2, _c2;
          const scene3 = this._context.scene;
          this._clearObserverEvent();
          (_a2 = this._resizeHelperShape) == null ? void 0 : _a2.dispose();
          this._resizeHelperShape = null;
          scene3.enableObjectsEvent();
          if (isStartMove) {
            scene3.resetCursor();
            (_b2 = this._rowResizeRect) == null ? void 0 : _b2.hide();
            (_c2 = this._columnResizeRect) == null ? void 0 : _c2.hide();
            if (initialType === 0 /* ROW */) {
              this._commandService.executeCommand(DeltaRowHeightCommand.id, {
                deltaY: moveChangeY,
                anchorRow: this._currentRow
              });
            } else {
              this._commandService.executeCommand(
                DeltaColumnWidthCommand.id,
                {
                  deltaX: moveChangeX,
                  anchorCol: this._currentColumn
                }
              );
            }
          }
        });
      })
    );
    this.disposeWithMe(
      eventBindingObject.onDblclick$.subscribeEvent(() => {
        var _a, _b, _c;
        const scene2 = this._context.scene;
        scene2.resetCursor();
        const sk = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
        if (!sk) return;
        const startRow = 0;
        const startColumn = 0;
        const endRow = sk.worksheet.getRowCount() - 1 || 0;
        const endColumn = sk.worksheet.getColumnCount() - 1 || 0;
        switch (initialType) {
          case 1 /* COLUMN */: {
            const curSelections = this._selectionManagerService.getCurrentSelections();
            const ranges = [];
            for (let i = 0; i < curSelections.length; i++) {
              const selection = curSelections[i];
              if (selection.range.rangeType === 2 /* COLUMN */ && this._currentColumn <= selection.range.endColumn && this._currentColumn >= selection.range.startColumn) {
                ranges.push({
                  startColumn: selection.range.startColumn,
                  endColumn: selection.range.endColumn,
                  startRow,
                  endRow
                });
              }
            }
            if (ranges.length === 0) {
              ranges.push({
                startColumn: this._currentColumn,
                endColumn: this._currentColumn,
                startRow,
                endRow
              });
            }
            this._commandService.executeCommand(
              SetWorksheetColAutoWidthCommand.id,
              { ranges }
            );
            (_b = this._columnResizeRect) == null ? void 0 : _b.hide();
            break;
          }
          case 0 /* ROW */:
            this._commandService.executeCommand(
              SetWorksheetRowIsAutoHeightCommand.id,
              {
                ranges: [{
                  startRow: this._currentRow,
                  endRow: this._currentRow,
                  startColumn,
                  endColumn
                }]
              }
            );
            (_c = this._rowResizeRect) == null ? void 0 : _c.hide();
            break;
        }
      })
    );
  }
  _clearObserverEvent() {
    var _a, _b;
    (_a = this._scenePointerMoveSub) == null ? void 0 : _a.unsubscribe();
    (_b = this._scenePointerUpSub) == null ? void 0 : _b.unsubscribe();
    this._scenePointerMoveSub = null;
    this._scenePointerUpSub = null;
  }
};
HeaderResizeRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, Inject(SheetsSelectionsService)),
  __decorateParam(3, ICommandService)
], HeaderResizeRenderController);

// ../packages/sheets-ui/src/controllers/permission/sheet-permission-interceptor-canvas-render.controller.ts
var SheetPermissionInterceptorCanvasRenderController = class extends RxDisposable {
  constructor(_context, _univerInstanceService, _permissionService, _selectionManagerService, _rangeProtectionRuleModel, _headerMoveRenderController, _selectionRenderService, _headerFreezeRenderController, _rangeProtectionCache, _headerResizeRenderController) {
    super();
    this._context = _context;
    this._univerInstanceService = _univerInstanceService;
    this._permissionService = _permissionService;
    this._selectionManagerService = _selectionManagerService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._headerMoveRenderController = _headerMoveRenderController;
    this._selectionRenderService = _selectionRenderService;
    this._headerFreezeRenderController = _headerFreezeRenderController;
    this._rangeProtectionCache = _rangeProtectionCache;
    this._headerResizeRenderController = _headerResizeRenderController;
    __publicField(this, "disposableCollection", new DisposableCollection());
    this._initHeaderMovePermissionInterceptor();
    this._initHeaderResizePermissionInterceptor();
    this._initRangeFillPermissionInterceptor();
    this._initRangeMovePermissionInterceptor();
  }
  _initHeaderMovePermissionInterceptor() {
    const headerMoveInterceptor = this._headerMoveRenderController.interceptor.getInterceptPoints().HEADER_MOVE_PERMISSION_CHECK;
    this.disposeWithMe(
      this._headerMoveRenderController.interceptor.intercept(headerMoveInterceptor, {
        handler: (defaultValue, selectionRange) => {
          const target = getSheetCommandTarget(this._univerInstanceService);
          if (!target) {
            return false;
          }
          const { unitId, subUnitId } = target;
          const worksheetEditPermission = this._permissionService.composePermission([new WorkbookEditablePermission(unitId).id, new WorksheetEditPermission(unitId, subUnitId).id]).every((permission) => permission.value);
          if (!worksheetEditPermission) {
            return false;
          }
          if (!selectionRange) {
            return true;
          }
          if (selectionRange.rangeType !== 1 /* ROW */ && selectionRange.rangeType !== 2 /* COLUMN */) {
            return defaultValue;
          }
          if (selectionRange.rangeType === 1 /* ROW */) {
            for (let i = selectionRange.startRow; i <= selectionRange.endRow; i++) {
              const rowAllowed = this._rangeProtectionCache.getRowPermissionInfo(unitId, subUnitId, i, [D.Edit]);
              if (rowAllowed === false) {
                return false;
              }
            }
          } else {
            for (let i = selectionRange.startColumn; i <= selectionRange.endColumn; i++) {
              const colAllowed = this._rangeProtectionCache.getColPermissionInfo(unitId, subUnitId, i, [D.Edit]);
              if (colAllowed === false) {
                return false;
              }
            }
          }
          return true;
        }
      })
    );
  }
  _initHeaderResizePermissionInterceptor() {
    if (!this._headerResizeRenderController) {
      return;
    }
    this.disposeWithMe(
      this._headerResizeRenderController.interceptor.intercept(this._headerResizeRenderController.interceptor.getInterceptPoints().HEADER_RESIZE_PERMISSION_CHECK, {
        handler: (defaultValue, rangeParams) => {
          var _a, _b, _c, _d;
          const target = getSheetCommandTarget(this._univerInstanceService);
          if (!target) {
            return false;
          }
          const { unitId, subUnitId } = target;
          if (rangeParams.row) {
            const setRowStylePermission = (_b = (_a = this._permissionService.getPermissionPoint(new WorksheetSetRowStylePermission(unitId, subUnitId).id)) == null ? void 0 : _a.value) != null ? _b : false;
            if (setRowStylePermission === false) {
              return false;
            }
          } else if (rangeParams.col) {
            const setColStylePermission = (_d = (_c = this._permissionService.getPermissionPoint(new WorksheetSetColumnStylePermission(unitId, subUnitId).id)) == null ? void 0 : _c.value) != null ? _d : false;
            if (setColStylePermission === false) {
              return false;
            }
          }
          return true;
        }
      })
    );
  }
  _initRangeFillPermissionInterceptor() {
    this.disposeWithMe(
      this._selectionRenderService.interceptor.intercept(this._selectionRenderService.interceptor.getInterceptPoints().RANGE_FILL_PERMISSION_CHECK, {
        handler: (_, position) => {
          var _a, _b, _c;
          const target = getSheetCommandTarget(this._univerInstanceService);
          if (!target) {
            return false;
          }
          const { worksheet, unitId, subUnitId } = target;
          const worksheetEditPermission = this._permissionService.composePermission([
            new WorkbookEditablePermission(unitId).id,
            new WorksheetEditPermission(unitId, subUnitId).id,
            new WorksheetSetCellValuePermission(unitId, subUnitId).id,
            new WorksheetSetCellStylePermission(unitId, subUnitId).id
          ]).every((permission) => permission.value);
          if (!worksheetEditPermission) {
            return false;
          }
          const ranges = (_a = this._selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((selection) => {
            return selection.range;
          });
          const selectionRange = ranges == null ? void 0 : ranges.find((range) => {
            const transformCoord = getTransformCoord(position.x, position.y, position.scene, position.skeleton);
            const cellPosition = position.skeleton.getCellWithCoordByIndex(range.endRow, range.endColumn);
            const missX = Math.abs(cellPosition.endX - transformCoord.x);
            const missY = Math.abs(cellPosition.endY - transformCoord.y);
            return missX <= 5 && missY <= 5;
          });
          if (!selectionRange) {
            return true;
          }
          const { startRow, endRow, startColumn, endColumn } = selectionRange;
          for (let row = startRow; row <= endRow; row++) {
            for (let col = startColumn; col <= endColumn; col++) {
              const permission = (_c = (_b = worksheet.getCell(row, col)) == null ? void 0 : _b.selectionProtection) == null ? void 0 : _c[0];
              if ((permission == null ? void 0 : permission[D.Edit]) === false || (permission == null ? void 0 : permission[D.View]) === false) {
                return false;
              }
            }
          }
          return true;
        }
      })
    );
  }
  _initRangeMovePermissionInterceptor() {
    this.disposeWithMe(
      this._selectionRenderService.interceptor.intercept(this._selectionRenderService.interceptor.getInterceptPoints().RANGE_MOVE_PERMISSION_CHECK, {
        handler: (_, _cellInfo) => {
          var _a;
          const target = getSheetCommandTarget(this._univerInstanceService);
          if (!target) {
            return false;
          }
          const { worksheet, unitId, subUnitId } = target;
          const worksheetEditPermission = this._permissionService.composePermission([new WorkbookEditablePermission(unitId).id, new WorksheetEditPermission(unitId, subUnitId).id]).every((permission) => permission.value);
          if (!worksheetEditPermission) {
            return false;
          }
          const ranges = (_a = this._selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((selection) => {
            return selection.range;
          });
          const ruleRanges = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).reduce((p, c) => {
            return [...p, ...c.ranges];
          }, []);
          const permissionLapRanges = ranges == null ? void 0 : ranges.filter((range) => {
            return ruleRanges.some((ruleRange) => {
              return Rectangle.intersects(ruleRange, range);
            });
          });
          const haveNotPermission = permissionLapRanges == null ? void 0 : permissionLapRanges.some((range) => {
            var _a2, _b;
            const { startRow, startColumn, endRow, endColumn } = range;
            for (let row = startRow; row <= endRow; row++) {
              for (let col = startColumn; col <= endColumn; col++) {
                const permission = (_b = (_a2 = worksheet.getCell(row, col)) == null ? void 0 : _a2.selectionProtection) == null ? void 0 : _b[0];
                if ((permission == null ? void 0 : permission[D.Edit]) === false) {
                  return true;
                }
              }
            }
            return false;
          });
          return !haveNotPermission;
        }
      })
    );
  }
  _initFreezePermissionInterceptor() {
    this.disposeWithMe(
      this._headerFreezeRenderController.interceptor.intercept(this._headerFreezeRenderController.interceptor.getInterceptPoints().FREEZE_PERMISSION_CHECK, {
        handler: (_, __) => {
          var _a, _b;
          const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
          const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
          if (!worksheet || !workbook) {
            return false;
          }
          const permission = (_b = (_a = this._permissionService.getPermissionPoint(new WorkbookEditablePermission(workbook.getUnitId()).id)) == null ? void 0 : _a.value) != null ? _b : false;
          return permission;
        }
      })
    );
  }
};
SheetPermissionInterceptorCanvasRenderController = __decorateClass([
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IPermissionService),
  __decorateParam(3, Inject(SheetsSelectionsService)),
  __decorateParam(4, Inject(RangeProtectionRuleModel)),
  __decorateParam(5, Inject(HeaderMoveRenderController)),
  __decorateParam(6, ISheetSelectionRenderService),
  __decorateParam(7, Inject(HeaderFreezeRenderController)),
  __decorateParam(8, Inject(RangeProtectionCache)),
  __decorateParam(9, Optional(HeaderResizeRenderController))
], SheetPermissionInterceptorCanvasRenderController);

// ../packages/sheets-ui/src/controllers/permission/sheet-permission-interceptor-clipboard.controller.ts
var SHEET_PERMISSION_PASTE_PLUGIN = "SHEET_PERMISSION_PASTE_PLUGIN";
var SheetPermissionInterceptorClipboardController = class extends Disposable {
  constructor(_univerInstanceService, _selectionManagerService, _localService, _sheetClipboardService, _sheetPermissionCheckController) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._selectionManagerService = _selectionManagerService;
    this._localService = _localService;
    this._sheetClipboardService = _sheetClipboardService;
    this._sheetPermissionCheckController = _sheetPermissionCheckController;
    __publicField(this, "disposableCollection", new DisposableCollection());
    this._initClipboardHook();
  }
  _initClipboardHook() {
    this.disposeWithMe(
      this._sheetClipboardService.addClipboardHook({
        id: SHEET_PERMISSION_PASTE_PLUGIN,
        onBeforePaste: (pasteTo) => {
          var _a, _b, _c;
          const [ranges] = virtualizeDiscreteRanges([pasteTo.range]).ranges;
          const startRange = (_a = this._selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a.range;
          if (!startRange) {
            return false;
          }
          const targetRange = {
            startRow: startRange.startRow + ranges.startRow,
            endRow: startRange.startRow + ranges.endRow,
            startColumn: startRange.startColumn + ranges.startColumn,
            endColumn: startRange.startColumn + ranges.endColumn
          };
          const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
          const worksheet = workbook.getActiveSheet();
          if (!worksheet) {
            return false;
          }
          const { startRow, endRow, startColumn, endColumn } = targetRange;
          let hasPermission = true;
          for (let row = startRow; row <= endRow; row++) {
            for (let col = startColumn; col <= endColumn; col++) {
              const permission = (_c = (_b = worksheet.getCell(row, col)) == null ? void 0 : _b.selectionProtection) == null ? void 0 : _c[0];
              if ((permission == null ? void 0 : permission[D.Edit]) === false) {
                hasPermission = false;
                break;
              }
            }
          }
          if (!hasPermission) {
            this._sheetPermissionCheckController.blockExecuteWithoutPermission(this._localService.t("permission.dialog.pasteErr"));
          }
          return hasPermission;
        }
      })
    );
  }
};
SheetPermissionInterceptorClipboardController = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, Inject(SheetsSelectionsService)),
  __decorateParam(2, Inject(LocaleService)),
  __decorateParam(3, Inject(ISheetClipboardService)),
  __decorateParam(4, Inject(SheetPermissionCheckController))
], SheetPermissionInterceptorClipboardController);

// ../packages/sheets-ui/src/controllers/status-bar.controller.ts
var STATUS_BAR_PERMISSION_CORRECT = createInterceptorKey("statusBarPermissionCorrect");
var CalculateValueSet = class {
  constructor() {
    __publicField(this, "_sum", 0);
    __publicField(this, "_count", 0);
    __publicField(this, "_countNumber", 0);
    __publicField(this, "_min", Number.POSITIVE_INFINITY);
    __publicField(this, "_max", Number.NEGATIVE_INFINITY);
  }
  add(value, styles, patternInfoRecord) {
    if (!(value == null ? void 0 : value.v)) {
      return;
    }
    const t = value == null ? void 0 : value.t;
    let { v } = value;
    const updateNumberStats = (v2) => {
      this._sum += v2;
      this._countNumber++;
      this._min = Math.min(this._min, v2);
      this._max = Math.max(this._max, v2);
    };
    const processNumberWithStyle = (style, v2, patternInfoRecord2) => {
      var _a;
      if (!((_a = style == null ? void 0 : style.n) == null ? void 0 : _a.pattern)) {
        return;
      }
      const { pattern } = style.n;
      if (!patternInfoRecord2[pattern]) {
        patternInfoRecord2[pattern] = numfmt.getInfo(pattern);
      }
      const formatInfo = patternInfoRecord2[pattern];
      if (formatInfo.isDate) {
        const dateValue = v2;
        updateNumberStats(dateValue);
      }
    };
    if (typeof v === "string" && t === 2 /* NUMBER */) {
      const numValue = Number(v);
      if (!Number.isNaN(numValue)) {
        v = numValue;
      }
    }
    if (typeof v === "number" && t !== 1 /* STRING */) {
      updateNumberStats(v);
    } else if (t === 2 /* NUMBER */ && value.s) {
      const style = styles.get(value.s);
      processNumberWithStyle(style, v, patternInfoRecord);
    }
    this._count++;
  }
  getResults() {
    return {
      sum: this._sum,
      count: this._countNumber,
      // the countA in formula is the count of all values
      countA: this._count,
      min: this._min,
      max: this._max
    };
  }
};
function calculateValues(valueSet) {
  const { sum, count, countA, min, max } = valueSet.getResults();
  return [
    {
      func: "MAX" /* MAX */,
      value: max
    },
    {
      func: "MIN" /* MIN */,
      value: min
    },
    {
      func: "SUM" /* SUM */,
      value: sum
    },
    {
      func: "COUNTA" /* COUNTA */,
      value: countA
    },
    {
      func: "COUNT" /* COUNT */,
      value: count
    },
    {
      func: "AVERAGE" /* AVERAGE */,
      value: sum / count
    }
  ];
}
var StatusBarController = class extends Disposable {
  constructor(_univerInstanceService, _selectionManagerService, _statusBarService, _commandService, _numfmtService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._selectionManagerService = _selectionManagerService;
    this._statusBarService = _statusBarService;
    this._commandService = _commandService;
    this._numfmtService = _numfmtService;
    __publicField(this, "interceptor", new InterceptorManager({ STATUS_BAR_PERMISSION_CORRECT }));
    this._init();
  }
  _init() {
    this._registerSelectionListener();
  }
  _registerSelectionListener() {
    const _statisticsHandler = debounce_default((selections) => {
      var _a;
      const primary = (_a = selections[selections.length - 1]) == null ? void 0 : _a.primary;
      this._calculateSelection(
        selections.map((selection) => selection.range),
        primary
      );
    }, 100);
    const _statisticsMovingHandler = debounce_default((selections) => {
      var _a;
      const primary = (_a = selections[selections.length - 1]) == null ? void 0 : _a.primary;
      this._calculateSelection(
        selections.map((selection) => selection.range),
        primary
      );
    }, 500);
    this.disposeWithMe(
      toDisposable(
        this._selectionManagerService.selectionMoving$.subscribe((selections) => {
          if (selections) {
            _statisticsMovingHandler(selections);
          }
        })
      )
    );
    this.disposeWithMe(
      toDisposable(
        this._selectionManagerService.selectionMoveEnd$.subscribe((selections) => {
          if (selections) {
            _statisticsHandler(selections);
          }
        })
      )
    );
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === SetRangeValuesMutation.id) {
          const selections = this._selectionManagerService.getCurrentSelections();
          if (selections) {
            _statisticsHandler(selections);
          }
        }
      })
    );
  }
  _clearResult() {
    this._statusBarService.setState(null);
  }
  getRangeStartEndInfo(range, sheet) {
    if (range.rangeType === 3 /* ALL */) {
      return {
        startRow: 0,
        startColumn: 0,
        endRow: sheet.getRowCount() - 1,
        endColumn: sheet.getColumnCount() - 1
      };
    }
    if (range.rangeType === 2 /* COLUMN */) {
      return {
        startRow: 0,
        startColumn: range.startColumn,
        endRow: sheet.getRowCount() - 1,
        endColumn: range.endColumn
      };
    }
    if (range.rangeType === 1 /* ROW */) {
      return {
        startRow: range.startRow,
        startColumn: 0,
        endRow: range.endRow,
        endColumn: sheet.getColumnCount() - 1
      };
    }
    return {
      startRow: range.startRow,
      startColumn: range.startColumn,
      endRow: range.endRow,
      endColumn: range.endColumn
    };
  }
  // eslint-disable-next-line max-lines-per-function
  _calculateSelection(selections, primary) {
    var _a;
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) {
      return this._clearResult();
    }
    const unitId = workbook.getUnitId();
    const sheet = workbook.getActiveSheet();
    const sheetId = sheet == null ? void 0 : sheet.getSheetId();
    if (!sheetId) {
      return this._clearResult();
    }
    const sheetData = {};
    this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getSheets().forEach((sheet2) => {
      const sheetConfig = sheet2.getConfig();
      sheetData[sheet2.getSheetId()] = {
        cellData: new ObjectMatrix(sheetConfig.cellData),
        rowCount: sheetConfig.rowCount,
        columnCount: sheetConfig.columnCount,
        rowData: sheetConfig.rowData,
        columnData: sheetConfig.columnData
      };
    });
    if (selections == null ? void 0 : selections.length) {
      const realSelections = [];
      selections.forEach((selection) => {
        const { startRow: start, endRow: end } = selection;
        let prev = null;
        for (let r = start; r <= end; r++) {
          if (sheet.getRowVisible(r)) {
            if (prev === null) {
              prev = r;
            }
          } else {
            if (prev !== null) {
              realSelections.push({ ...selection, startRow: prev, endRow: r - 1 });
              prev = null;
            }
          }
        }
        if (prev !== null) {
          realSelections.push({ ...selection, startRow: prev, endRow: end });
        }
      });
      const noDuplicate = splitIntoGrid(realSelections);
      const calculateValueSet = new CalculateValueSet();
      const styles = workbook.getStyles();
      const patternInfoRecord = {};
      for (const range of noDuplicate) {
        const { startRow, startColumn, endColumn, endRow } = this.getRangeStartEndInfo(range, sheet);
        for (let r = startRow; r <= endRow; r++) {
          for (let c = startColumn; c <= endColumn; c++) {
            const value = sheet.getCellRaw(r, c);
            calculateValueSet.add(value, styles, patternInfoRecord);
          }
        }
      }
      const calcResult = calculateValues(calculateValueSet);
      if (calcResult.every((r) => r === void 0)) {
        return;
      }
      let pattern = null;
      if (primary) {
        const { actualRow, actualColumn } = primary;
        pattern = (_a = this._numfmtService.getValue(unitId, sheetId, actualRow, actualColumn)) == null ? void 0 : _a.pattern;
      }
      const availableResult = calcResult.filter((r) => r !== void 0);
      const newState = {
        values: availableResult,
        pattern
      };
      this._statusBarService.setState(newState);
    } else {
      this._clearResult();
    }
  }
};
StatusBarController = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, Inject(SheetsSelectionsService)),
  __decorateParam(2, IStatusBarService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, Inject(INumfmtService))
], StatusBarController);

// ../packages/sheets-ui/src/controllers/permission/sheet-permission-interceptor-formula-render.controller.ts
var SheetPermissionInterceptorFormulaRenderController = class extends RxDisposable {
  constructor(_context, _univerInstanceService, _permissionService, _statusBarController, _rangeProtectionCache) {
    super();
    this._context = _context;
    this._univerInstanceService = _univerInstanceService;
    this._permissionService = _permissionService;
    this._statusBarController = _statusBarController;
    this._rangeProtectionCache = _rangeProtectionCache;
    __publicField(this, "disposableCollection", new DisposableCollection());
    this._initStatusBarPermissionInterceptor();
  }
  _initStatusBarPermissionInterceptor() {
    this.disposeWithMe(
      this._statusBarController.interceptor.intercept(this._statusBarController.interceptor.getInterceptPoints().STATUS_BAR_PERMISSION_CORRECT, {
        priority: 100,
        handler: (defaultValue, originValue) => {
          var _a;
          const target = getSheetCommandTarget(this._univerInstanceService);
          if (!target) {
            return defaultValue != null ? defaultValue : [];
          }
          const { worksheet, unitId, subUnitId } = target;
          const sheetViewPermission = (_a = this._permissionService.getPermissionPoint(new WorksheetViewPermission(unitId, subUnitId).id)) == null ? void 0 : _a.value;
          if (sheetViewPermission === false) {
            originValue.forEach((item) => {
              const itemValue = item.getArrayValue();
              itemValue.forEach((row, rowIndex) => {
                row.forEach((col, colIndex) => {
                  itemValue[rowIndex][colIndex] = NullValueObject.create();
                });
              });
            });
          } else {
            originValue.forEach((item) => {
              const itemValue = item.getArrayValue();
              const startRow = item.getCurrentRow();
              const startCol = item.getCurrentColumn();
              itemValue.forEach((row, rowIndex) => {
                row.forEach((col, colIndex) => {
                  var _a2;
                  const cellValue = (_a2 = worksheet.getCellRaw(rowIndex + startRow, colIndex + startCol)) == null ? void 0 : _a2.v;
                  if (cellValue === void 0) {
                    return;
                  }
                  const permission = this._rangeProtectionCache.getCellInfo(unitId, subUnitId, rowIndex + startRow, colIndex + startCol);
                  if ((permission == null ? void 0 : permission[D.View]) === false) {
                    itemValue[rowIndex][colIndex] = NullValueObject.create();
                  }
                });
              });
            });
          }
          return originValue;
        }
      })
    );
  }
};
SheetPermissionInterceptorFormulaRenderController = __decorateClass([
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IPermissionService),
  __decorateParam(3, Inject(StatusBarController)),
  __decorateParam(4, Inject(RangeProtectionCache))
], SheetPermissionInterceptorFormulaRenderController);

// ../packages/sheets-ui/src/views/permission/panel-detail/PermissionDetailPanel.tsx
var import_react22 = __toESM(require_react());

// ../packages/sheets-ui/src/views/permission/util.ts
var checkRangeValid = (injector, permissionRanges, permissionId, unitId, subUnitId) => {
  const localeService = injector.get(LocaleService);
  const worksheetRuleModel = injector.get(WorksheetProtectionRuleModel);
  const rangeProtectionRuleModel = injector.get(RangeProtectionRuleModel);
  let rangeErrorString = "";
  if (permissionRanges.length === 0) {
    rangeErrorString = localeService.t("permission.panel.emptyRangeError");
  } else if (permissionRanges.length > 1) {
    let hasLap = false;
    for (let i = 0; i < permissionRanges.length; i++) {
      for (let j = i + 1; j < permissionRanges.length; j++) {
        if (Rectangle.intersects(permissionRanges[i], permissionRanges[j])) {
          hasLap = true;
          break;
        }
      }
      if (hasLap) {
        break;
      }
    }
    if (hasLap) {
      rangeErrorString = localeService.t("permission.panel.rangeOverlapError");
    }
  }
  if (!rangeErrorString) {
    const worksheetRule = worksheetRuleModel.getRule(unitId, subUnitId);
    if (worksheetRule && !permissionId) {
      rangeErrorString = localeService.t("permission.panel.rangeOverlapOverPermissionError");
      return rangeErrorString;
    }
    const lapRule = rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
      return rule.permissionId !== permissionId;
    }).find((rule) => {
      return rule.ranges.some((ruleRange) => {
        return permissionRanges.some((r) => Rectangle.intersects(ruleRange, r));
      });
    });
    const lapRange = lapRule == null ? void 0 : lapRule.ranges.find((range) => {
      return permissionRanges.some((r) => Rectangle.intersects(range, r));
    });
    if (lapRange) {
      rangeErrorString = localeService.t("permission.panel.rangeOverlapOverPermissionError");
    }
  }
  return rangeErrorString === "" ? void 0 : rangeErrorString;
};
var checkRangesIsWholeSheet = (ranges, sheet) => {
  if (ranges.length !== 1) {
    return false;
  }
  const range = ranges[0];
  const rowCount = sheet.getRowCount();
  const colCount = sheet.getColumnCount();
  const { startRow, endRow, startColumn, endColumn } = range;
  return startRow === 0 && startColumn === 0 && endRow === rowCount - 1 && endColumn === colCount - 1;
};
var generateDefaultRule = (injector, fromSheetBar) => {
  var _a, _b;
  const univerInstanceService = injector.get(IUniverInstanceService);
  const selectionManagerService = injector.get(SheetsSelectionsService);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const worksheet = workbook.getActiveSheet();
  let unitType = a.SelectRange;
  let ranges = (_b = (_a = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range)) != null ? _b : [];
  if (fromSheetBar) {
    unitType = a.Worksheet;
    ranges = [{
      startRow: 0,
      startColumn: 0,
      endRow: worksheet.getRowCount() - 1,
      endColumn: worksheet.getColumnCount() - 1,
      rangeType: 3 /* ALL */
    }];
  }
  return {
    unitId: workbook.getUnitId(),
    subUnitId: worksheet.getSheetId(),
    permissionId: "",
    unitType,
    description: "",
    id: "",
    ranges,
    editState: "onlyMe" /* OnlyMe */,
    viewState: "othersCanView" /* OthersCanView */
  };
};
var generateRuleByUnitType = (injector, rule) => {
  const univerInstanceService = injector.get(IUniverInstanceService);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const worksheet = workbook.getActiveSheet();
  const { unitType } = rule;
  if (unitType === a.Worksheet) {
    return {
      ...rule,
      ranges: [{
        startRow: 0,
        startColumn: 0,
        endRow: worksheet.getRowCount() - 1,
        endColumn: worksheet.getColumnCount() - 1,
        rangeType: 3 /* ALL */
      }]
    };
  }
  return rule;
};

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/permission/panel-detail/index.module.less
var index_module_default13 = {
  "permissionPanelDetailWrapper": "univer-permission-panel-detail-wrapper",
  "radioGroupVertical": "univer-radio-group-vertical",
  "sheetPermissionDesignPersonPanel": "univer-sheet-permission-design-person-panel",
  "sheetPermissionDesignPersonPanelHeader": "univer-sheet-permission-design-person-panel-header",
  "sheetPermissionDesignPersonPanelHeaderAdd": "univer-sheet-permission-design-person-panel-header-add",
  "sheetPermissionDesignPersonPanelSplit": "univer-sheet-permission-design-person-panel-split",
  "sheetPermissionDesignPersonPanelContentItem": "univer-sheet-permission-design-person-panel-content-item",
  "sheetPermissionDesignPersonPanelContentItemName": "univer-sheet-permission-design-person-panel-content-item-name",
  "sheetPermissionDesignPersonPanelContentItemSelect": "univer-sheet-permission-design-person-panel-content-item-select",
  "sheetPermissionDesignPersonPanelContent": "univer-sheet-permission-design-person-panel-content",
  "sheetPermissionUserListEmpty": "univer-sheet-permission-user-list-empty",
  "sheetPermissionUserListEmptyText": "univer-sheet-permission-user-list-empty-text",
  "sheetPermissionPanelTitle": "univer-sheet-permission-panel-title",
  "sheetPermissionPanelFooter": "univer-sheet-permission-panel-footer",
  "permissionRangeSelector": "univer-permission-range-selector",
  "permissionRangeSelectorError": "univer-permission-range-selector-error",
  "sheetPermissionPanelNameInputError": "univer-sheet-permission-panel-name-input-error",
  "permissionRangeSelectorErrorText": "univer-permission-range-selector-error-text",
  "sheetPermissionPanelNameInputErrorText": "univer-sheet-permission-panel-name-input-error-text"
};

// ../packages/sheets-ui/src/views/permission/panel-detail/PermissionDetailFooterPart.tsx
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var PermissionDetailFooterPart = (props) => {
  const { viewState, editState, permissionId, ranges, rangesErrMsg, desc, oldRule, id } = props;
  const sheetPermissionPanelModel = useDependency(SheetPermissionPanelModel);
  const sidebarService = useDependency(ISidebarService);
  const authzIoService = useDependency(IAuthzIoService);
  const localeService = useDependency(LocaleService);
  const commandService = useDependency(ICommandService);
  const sheetPermissionUserManagerService = useDependency(SheetPermissionUserManagerService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
  if (!workbook || !worksheet) {
    return null;
  }
  const unitId = workbook.getUnitId();
  const subUnitId = worksheet.getSheetId();
  return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)("div", { className: index_module_default13.sheetPermissionPanelFooter, children: [
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      Button,
      {
        type: "primary",
        onClick: async () => {
          if (rangesErrMsg) return;
          const activeRule = {
            unitId,
            subUnitId,
            permissionId,
            id,
            viewState,
            editState,
            unitType: a.SelectRange,
            ranges,
            description: desc
          };
          const isSelectWholeSheet = checkRangesIsWholeSheet(ranges, worksheet);
          if (isSelectWholeSheet) {
            activeRule.unitType = a.Worksheet;
            activeRule.ranges = [];
          }
          let collaborators = sheetPermissionUserManagerService.selectUserList;
          if (activeRule.editState === "onlyMe" /* OnlyMe */) {
            collaborators = [];
            sheetPermissionUserManagerService.setSelectUserList([]);
          }
          const scopeObj = {
            read: activeRule.viewState === "othersCanView" /* OthersCanView */ ? G.AllCollaborator : G.SomeCollaborator,
            edit: activeRule.editState === "designedUserCanEdit" /* DesignedUserCanEdit */ ? G.SomeCollaborator : G.OneSelf
          };
          if (activeRule.editState === "designedUserCanEdit" /* DesignedUserCanEdit */ && collaborators.length === 0) {
            collaborators = [];
            scopeObj.edit = G.OneSelf;
          }
          if (activeRule.permissionId) {
            const isSameCollaborators = getUserListEqual(collaborators.filter((user) => user.role === S.Editor), sheetPermissionUserManagerService.oldCollaboratorList.filter((user) => user.role === S.Editor));
            const isSameReadStatus = (oldRule == null ? void 0 : oldRule.viewState) === activeRule.viewState;
            const isSameEditStatus = (oldRule == null ? void 0 : oldRule.editState) === activeRule.editState;
            const ruleConfigIsOrigin = activeRule.unitType === (oldRule == null ? void 0 : oldRule.unitType) && activeRule.description === oldRule.description && activeRule.ranges === oldRule.ranges;
            const collaboratorsIsChange = !isSameCollaborators || !isSameReadStatus || !isSameEditStatus;
            if (ruleConfigIsOrigin && collaboratorsIsChange) {
              await authzIoService.update({
                objectType: activeRule.unitType,
                objectID: activeRule.permissionId,
                unitID: activeRule.unitId,
                share: void 0,
                name: "",
                strategies: [],
                scope: scopeObj,
                collaborators: {
                  collaborators
                }
              });
            } else {
              let newPermissionId = activeRule.permissionId;
              if (collaboratorsIsChange) {
                if (activeRule.unitType === a.Worksheet) {
                  newPermissionId = await authzIoService.create({
                    worksheetObject: {
                      collaborators,
                      unitID: activeRule.unitId,
                      name: "",
                      strategies: [{ role: S.Editor, action: D.Edit }, { role: S.Reader, action: D.View }],
                      scope: scopeObj
                    },
                    objectType: a.Worksheet
                  });
                } else {
                  newPermissionId = await authzIoService.create({
                    selectRangeObject: {
                      collaborators,
                      unitID: activeRule.unitId,
                      name: "",
                      scope: scopeObj
                    },
                    objectType: a.SelectRange
                  });
                }
              }
              commandService.executeCommand(SetProtectionCommand.id, {
                rule: {
                  ...activeRule,
                  permissionId: newPermissionId
                },
                oldRule
              });
            }
          } else {
            if (activeRule.unitType === a.Worksheet) {
              const permissionId2 = await authzIoService.create({
                worksheetObject: {
                  collaborators,
                  unitID: activeRule.unitId,
                  name: "",
                  strategies: [{ role: S.Editor, action: D.Edit }, { role: S.Reader, action: D.View }],
                  scope: scopeObj
                },
                objectType: a.Worksheet
              });
              const { ranges: _range = [], ...sheetRule } = activeRule;
              sheetRule.permissionId = permissionId2;
              commandService.executeCommand(AddWorksheetProtectionCommand.id, {
                rule: sheetRule,
                unitId: activeRule.unitId
              });
            } else if (activeRule.unitType === a.SelectRange) {
              const permissionId2 = await authzIoService.create({
                selectRangeObject: {
                  collaborators,
                  unitID: activeRule.unitId,
                  name: "",
                  scope: scopeObj
                },
                objectType: a.SelectRange
              });
              commandService.executeCommand(AddRangeProtectionCommand.id, {
                rule: activeRule,
                permissionId: permissionId2
              });
            }
          }
          const sidebarProps = {
            header: { title: `${localeService.t("permission.panel.title")}` },
            children: {
              label: UNIVER_SHEET_PERMISSION_PANEL,
              showDetail: false
            },
            width: 330
          };
          sidebarService.open(sidebarProps);
        },
        children: localeService.t("permission.button.confirm")
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
      Button,
      {
        className: index_module_default13.sheetPermissionPanelFooterCancel,
        onClick: () => {
          sheetPermissionPanelModel.reset();
          sheetPermissionUserManagerService.reset();
          sidebarService.close();
        },
        children: localeService.t("permission.button.cancel")
      }
    )
  ] });
};

// ../packages/sheets-ui/src/views/permission/panel-detail/PermissionDetailMainPart.tsx
var import_react21 = __toESM(require_react());
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var PermissionDetailMainPart = (props) => {
  const { ranges, onRangesChange, desc, onDescChange, rangesErrMsg, permissionId } = props;
  const componentManager = useDependency(ComponentManager);
  const RangeSelector = (0, import_react21.useMemo)(() => componentManager.get(RANGE_SELECTOR_COMPONENT_KEY), []);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const localeService = useDependency(LocaleService);
  const injector = useDependency(Injector);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
  if (!workbook || !worksheet) {
    return null;
  }
  const unitId = workbook.getUnitId();
  const subUnitId = worksheet.getSheetId();
  const handleRangeChange = (rangeText) => {
    const newRange = rangeText.split(",").map(deserializeRangeWithSheet).map((item) => item.range);
    if (newRange.some((i) => !isValidRange(i) || i.endColumn < i.startColumn || i.endRow < i.startRow)) {
      return;
    }
    const workbook2 = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet2 = workbook2 == null ? void 0 : workbook2.getActiveSheet();
    if (!workbook2 || !worksheet2) {
      return;
    }
    const unitId2 = workbook2.getUnitId();
    const subUnitId2 = worksheet2.getSheetId();
    const transformedRange = newRange.map((range) => {
      const rowCount = worksheet2.getRowCount();
      const colCount = worksheet2.getColumnCount();
      setEndForRange(range, rowCount, colCount);
      return range;
    });
    const rangeErrorString = checkRangeValid(injector, transformedRange, permissionId, unitId2, subUnitId2);
    onRangesChange(transformedRange, rangeErrorString);
  };
  return /* @__PURE__ */ (0, import_jsx_runtime35.jsxs)(import_jsx_runtime35.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      FormLayout,
      {
        className: index_module_default13.sheetPermissionPanelTitle,
        label: localeService.t("permission.panel.protectedRange"),
        error: rangesErrMsg,
        children: RangeSelector && /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
          RangeSelector,
          {
            unitId,
            subUnitId,
            initialValue: ranges == null ? void 0 : ranges.map((i) => serializeRange(i)).join(","),
            onChange: (_, text) => handleRangeChange(text)
          }
        )
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(FormLayout, { className: index_module_default13.sheetPermissionPanelTitle, label: localeService.t("permission.panel.permissionDirection"), children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      Input,
      {
        value: desc,
        onChange: (v) => onDescChange(v),
        placeholder: localeService.t("permission.panel.permissionDirectionPlaceholder")
      }
    ) })
  ] });
};

// ../packages/sheets-ui/src/views/permission/panel-detail/PermissionDetailPanel.tsx
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var SheetPermissionPanelDetail = (props) => {
  var _a, _b;
  const { fromSheetBar, rule, oldRule } = props;
  const injector = useDependency(Injector);
  const activeRule = rule ? generateRuleByUnitType(injector, rule) : generateDefaultRule(injector, fromSheetBar);
  const [ranges, setRanges] = (0, import_react22.useState)(activeRule.ranges);
  const [rangesErrMsg, setRangesErrMsg] = (0, import_react22.useState)(() => {
    return checkRangeValid(injector, activeRule.ranges, activeRule.permissionId, activeRule.unitId, activeRule.subUnitId);
  });
  const [desc, setDesc] = (0, import_react22.useState)(activeRule.description);
  const [editState, setEditState] = (0, import_react22.useState)((_a = activeRule.editState) != null ? _a : "onlyMe" /* OnlyMe */);
  const [viewState, setViewState] = (0, import_react22.useState)((_b = activeRule.viewState) != null ? _b : "othersCanView" /* OthersCanView */);
  const PermissionDetailUserPart2 = useComponentsOfPart(UNIVER_SHEET_PERMISSION_USER_PART);
  (0, import_react22.useEffect)(() => {
    const univerInstanceService = injector.get(IUniverInstanceService);
    const sidebarService = injector.get(ISidebarService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return;
    const subUnitId = workbook.getActiveSheet().getSheetId();
    const activeSheetSubscribe = workbook.activeSheet$.subscribe((sheet) => {
      if ((sheet == null ? void 0 : sheet.getSheetId()) !== subUnitId) {
        sidebarService.close();
      }
    });
    return () => {
      activeSheetSubscribe.unsubscribe();
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)("div", { className: index_module_default13.permissionPanelDetailWrapper, children: [
    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
      PermissionDetailMainPart,
      {
        permissionId: activeRule.permissionId,
        ranges,
        onRangesChange: (v, err) => {
          setRanges(v);
          setRangesErrMsg(err);
        },
        rangesErrMsg,
        desc,
        onDescChange: (v) => setDesc(v)
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
      ComponentContainer,
      {
        components: PermissionDetailUserPart2,
        sharedProps: {
          editState,
          onEditStateChange: (v) => setEditState(v),
          viewState,
          onViewStateChange: (v) => setViewState(v),
          permissionId: activeRule.permissionId
        }
      },
      "user-part"
    ),
    /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
      PermissionDetailFooterPart,
      {
        permissionId: activeRule.permissionId,
        id: activeRule.id,
        ranges,
        rangesErrMsg,
        desc,
        viewState,
        editState,
        oldRule
      }
    )
  ] });
};

// ../packages/sheets-ui/src/views/permission/panel-list/index.tsx
var import_react24 = __toESM(require_react());

// ../packages/sheets-ui/src/hooks/use-highlight-range.ts
var import_react23 = __toESM(require_react());
var useHighlightRange = (ranges = []) => {
  const markSelectionService = useDependency(IMarkSelectionService);
  (0, import_react23.useEffect)(() => {
    const ids = ranges.map((range) => markSelectionService.addShape({
      range,
      style: {
        fill: "rgba(73, 184, 17, 0.05)",
        strokeWidth: 1,
        stroke: "#49B811",
        widgets: {}
      },
      primary: {
        startColumn: range.startColumn,
        endColumn: range.endColumn,
        startRow: range.startRow,
        endRow: range.endRow,
        actualRow: range.startRow,
        actualColumn: range.startColumn,
        isMerged: false,
        isMergedMainCell: false
      }
    }));
    return () => {
      ids.forEach((id) => {
        id && markSelectionService.removeShape(id);
      });
    };
  }, [ranges]);
};

// ../packages/sheets-ui/src/views/permission/panel-list/constant.ts
var panelListEmptyBase64 = "data:image/png;base64,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";

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/permission/panel-list/index.module.less
var index_module_default14 = {
  "sheetPermissionListPanelWrapper": "univer-sheet-permission-list-panel-wrapper",
  "sheetPermissionListPanelHeader": "univer-sheet-permission-list-panel-header",
  "sheetPermissionListPanelHeaderType": "univer-sheet-permission-list-panel-header-type",
  "sheetPermissionListPanelHeaderTypeBottom": "univer-sheet-permission-list-panel-header-type-bottom",
  "sheetPermissionListPanelHeaderSelect": "univer-sheet-permission-list-panel-header-select",
  "sheetPermissionListItemHeaderIcon": "univer-sheet-permission-list-item-header-icon",
  "sheetPermissionListItem": "univer-sheet-permission-list-item",
  "sheetPermissionListItemHeader": "univer-sheet-permission-list-item-header",
  "sheetPermissionListItemHeaderName": "univer-sheet-permission-list-item-header-name",
  "sheetPermissionListItemHeaderOperator": "univer-sheet-permission-list-item-header-operator",
  "sheetPermissionListItemSplit": "univer-sheet-permission-list-item-split",
  "sheetPermissionListItemContentEdit": "univer-sheet-permission-list-item-content-edit",
  "sheetPermissionListItemContentView": "univer-sheet-permission-list-item-content-view",
  "sheetPermissionListItemContentDesc": "univer-sheet-permission-list-item-content-desc",
  "sheetPermissionListEmpty": "univer-sheet-permission-list-empty",
  "sheetPermissionListEmptyText": "univer-sheet-permission-list-empty-text",
  "sheetPermissionListItemContentTitle": "univer-sheet-permission-list-item-content-title",
  "sheetPermissionListItemContentSub": "univer-sheet-permission-list-item-content-sub",
  "sheetPermissionPanelAddWrapper": "univer-sheet-permission-panel-add-wrapper",
  "sheetPermissionPanelAddButton": "univer-sheet-permission-panel-add-button"
};

// ../packages/sheets-ui/src/views/permission/panel-list/index.tsx
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var SheetPermissionPanelList = () => {
  var _a;
  const [isCurrentSheet, setIsCurrentSheet] = (0, import_react24.useState)(true);
  const [forceUpdateFlag, setForceUpdateFlag] = (0, import_react24.useState)(false);
  const localeService = useDependency(LocaleService);
  const rangeProtectionRuleModel = useDependency(RangeProtectionRuleModel);
  const worksheetProtectionModel = useDependency(WorksheetProtectionRuleModel);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const commandService = useDependency(ICommandService);
  const sidebarService = useDependency(ISidebarService);
  const authzIoService = useDependency(IAuthzIoService);
  const permissionService = useDependency(IPermissionService);
  const usesManagerService = useDependency(UserManagerService);
  const currentUser = usesManagerService.getCurrentUser();
  const [currentRuleRanges, currentRuleRangesSet] = (0, import_react24.useState)([]);
  const sheetPermissionUserManagerService = useDependency(SheetPermissionUserManagerService);
  const _sheetRuleRefresh = useObservable(worksheetProtectionModel.ruleRefresh$, "");
  const _rangeRuleRefresh = useObservable(rangeProtectionRuleModel.ruleRefresh$, "");
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  if (!workbook) {
    return null;
  }
  const unitId = workbook == null ? void 0 : workbook.getUnitId();
  const getRuleList = (0, import_react24.useCallback)(async (isCurrentSheet2) => {
    var _a2;
    const worksheet = workbook.getActiveSheet();
    const unitId2 = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    const allRangePermissionId = [];
    const allSheetPermissionId = [];
    workbook.getSheets().forEach((sheet) => {
      const sheetId = sheet.getSheetId();
      const rules = rangeProtectionRuleModel.getSubunitRuleList(unitId2, sheetId);
      rules.forEach((rule) => {
        if (rule.permissionId) {
          allRangePermissionId.push(rule.permissionId);
        }
      });
      const worksheetPermissionRule = worksheetProtectionModel.getRule(unitId2, sheetId);
      if (worksheetPermissionRule == null ? void 0 : worksheetPermissionRule.permissionId) {
        allSheetPermissionId.push(worksheetPermissionRule.permissionId);
      }
    });
    const allPermissionId = [...allRangePermissionId, ...allSheetPermissionId];
    const allPermissionRule = await authzIoService.list({
      objectIDs: allPermissionId,
      unitID: unitId2,
      actions: baseProtectionActions
    });
    const subUnitPermissionIds = rangeProtectionRuleModel.getSubunitRuleList(unitId2, subUnitId).map((item) => item.permissionId);
    const sheetPermissionId = (_a2 = worksheetProtectionModel.getRule(unitId2, subUnitId)) == null ? void 0 : _a2.permissionId;
    if (sheetPermissionId) {
      subUnitPermissionIds.push(sheetPermissionId);
    }
    const subUnitRuleList = allPermissionRule.filter((item) => {
      var _a3;
      return subUnitPermissionIds.includes(item.objectID) || item.objectID === ((_a3 = worksheetProtectionModel.getRule(unitId2, subUnitId)) == null ? void 0 : _a3.permissionId);
    });
    return isCurrentSheet2 ? subUnitRuleList : allPermissionRule;
  }, []);
  const [ruleList, setRuleList] = (0, import_react24.useState)([]);
  (0, import_react24.useEffect)(() => {
    const subscription = merge(
      rangeProtectionRuleModel.ruleChange$,
      worksheetProtectionModel.ruleChange$
    ).subscribe(async () => {
      const ruleList2 = await getRuleList(isCurrentSheet);
      setRuleList(ruleList2);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [isCurrentSheet]);
  (0, import_react24.useEffect)(() => {
    const subscribe = workbook.activeSheet$.pipe(
      distinctUntilChanged((prevSheet, currSheet) => (prevSheet == null ? void 0 : prevSheet.getSheetId()) === (currSheet == null ? void 0 : currSheet.getSheetId()))
    ).subscribe(async () => {
      const ruleList2 = await getRuleList(isCurrentSheet);
      setRuleList(ruleList2);
    });
    return () => {
      subscribe.unsubscribe();
    };
  }, [isCurrentSheet]);
  (0, import_react24.useEffect)(() => {
    const getRuleListByRefresh = async () => {
      if (_sheetRuleRefresh || _rangeRuleRefresh) {
        const ruleList2 = await getRuleList(true);
        setRuleList(ruleList2);
      }
      ;
    };
    getRuleListByRefresh();
  }, [_sheetRuleRefresh, _rangeRuleRefresh]);
  const handleDelete = (rule) => {
    const { unitId: unitId2, subUnitId, unitType } = rule;
    let res;
    if (unitType === a.Worksheet) {
      res = commandService.executeCommand(DeleteWorksheetProtectionCommand.id, { unitId: unitId2, subUnitId, rule });
    } else if (unitType === a.SelectRange) {
      res = commandService.executeCommand(DeleteRangeProtectionCommand.id, { unitId: unitId2, subUnitId, rule });
    }
    if (res) {
      setForceUpdateFlag(!forceUpdateFlag);
      if (rule.ranges === currentRuleRanges) {
        currentRuleRangesSet([]);
      }
    }
  };
  (0, import_react24.useEffect)(() => {
    sheetPermissionUserManagerService.reset();
  }, []);
  useHighlightRange(currentRuleRanges);
  const allRuleMap = /* @__PURE__ */ new Map();
  workbook.getSheets().forEach((sheet) => {
    const sheetId = sheet.getSheetId();
    const rangeRules = rangeProtectionRuleModel.getSubunitRuleList(unitId, sheetId);
    rangeRules.forEach((rule) => {
      allRuleMap.set(rule.permissionId, rule);
    });
    const sheetRule = worksheetProtectionModel.getRule(unitId, sheetId);
    if (sheetRule) {
      allRuleMap.set(sheetRule == null ? void 0 : sheetRule.permissionId, sheetRule);
    }
  });
  const handleEdit = (rule) => {
    if (rule.subUnitId !== workbook.getActiveSheet().getSheetId()) {
      commandService.executeCommand(SetWorksheetActiveOperation.id, {
        unitId: rule.unitId,
        subUnitId: rule.subUnitId
      });
    }
    const sidebarProps = {
      header: { title: "permission.panel.title" },
      children: {
        label: UNIVER_SHEET_PERMISSION_PANEL,
        showDetail: true,
        rule: Tools.deepClone(rule),
        oldRule: Tools.deepClone(rule)
      },
      width: 330
    };
    sidebarService.open(sidebarProps);
  };
  const handleChangeHeaderType = (isCurrentSheet2) => {
    setIsCurrentSheet(isCurrentSheet2);
  };
  const hasSetProtectPermission = (_a = permissionService.getPermissionPoint(new WorkbookCreateProtectPermission(unitId).id)) == null ? void 0 : _a.value;
  return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListPanelWrapper, children: [
    /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListPanelHeader, children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListPanelHeaderType, onClick: () => handleChangeHeaderType(true), children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: clsx({ [index_module_default14.sheetPermissionListPanelHeaderSelect]: isCurrentSheet }), children: localeService.t("permission.panel.currentSheet") }),
        isCurrentSheet && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListPanelHeaderTypeBottom })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListPanelHeaderType, onClick: () => handleChangeHeaderType(false), children: [
        /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: clsx({ [index_module_default14.sheetPermissionListPanelHeaderSelect]: !isCurrentSheet }), children: localeService.t("permission.panel.allSheet") }),
        !isCurrentSheet && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListPanelHeaderTypeBottom })
      ] })
    ] }),
    (ruleList == null ? void 0 : ruleList.length) > 0 ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListPanelContent, children: ruleList == null ? void 0 : ruleList.map((item) => {
      var _a2, _b, _c, _d, _e;
      const rule = allRuleMap.get(item.objectID);
      if (!rule) {
        return null;
      }
      const editAction = item.actions.find((action) => action.action === D.Edit);
      const editPermission = editAction == null ? void 0 : editAction.allowed;
      const viewAction = item.actions.find((action) => action.action === D.View);
      const viewPermission = viewAction == null ? void 0 : viewAction.allowed;
      const manageCollaboratorAction = item.actions.find((action) => action.action === D.ManageCollaborator);
      const deleteAction = item.actions.find((action) => action.action === D.Delete);
      const hasManagerPermission = (manageCollaboratorAction == null ? void 0 : manageCollaboratorAction.allowed) || currentUser.userID === ((_a2 = item.creator) == null ? void 0 : _a2.userID);
      const hasDeletePermission = (deleteAction == null ? void 0 : deleteAction.allowed) || currentUser.userID === ((_b = item.creator) == null ? void 0 : _b.userID);
      let ruleName = "";
      const targetSheet = workbook.getSheetBySheetId(rule.subUnitId);
      const targetName = targetSheet == null ? void 0 : targetSheet.getName();
      if (rule.unitType === a.SelectRange) {
        const ranges = rule.ranges;
        const rangeStr = (ranges == null ? void 0 : ranges.length) ? ranges.map((range) => {
          const v = serializeRange(range);
          return v === "NaN" ? "" : v;
        }).filter((r) => !!r).join(",") : "";
        ruleName = `${targetName}(${rangeStr})`;
      } else if (rule.unitType === a.Worksheet) {
        ruleName = targetName || "";
      }
      return /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
        "div",
        {
          className: index_module_default14.sheetPermissionListItem,
          onMouseMove: () => {
            const { subUnitId, unitType } = rule;
            const activeSheet = workbook.getActiveSheet();
            if (!activeSheet) {
              return false;
            }
            const activeSubUnitId = activeSheet.getSheetId();
            if (subUnitId !== activeSubUnitId) {
              return false;
            }
            if (unitType === a.SelectRange) {
              const ranges = rule.ranges || [];
              ranges !== currentRuleRanges && currentRuleRangesSet(ranges);
            } else if (unitType === a.Worksheet) {
              const ranges = [{ startRow: 0, endRow: activeSheet.getRowCount() - 1, startColumn: 0, endColumn: activeSheet.getColumnCount() - 1 }];
              ranges !== currentRuleRanges && currentRuleRangesSet(ranges);
            }
          },
          onMouseLeave: () => currentRuleRangesSet([]),
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListItemHeader, children: [
              /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Tooltip, { title: ruleName, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListItemHeaderName, children: ruleName }) }),
              (hasManagerPermission || hasDeletePermission) && /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListItemHeaderOperator, children: [
                hasManagerPermission && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Tooltip, { title: localeService.t("permission.panel.edit"), children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListItemHeaderIcon, onClick: () => handleEdit(rule), children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(write_single_default, {}) }) }),
                hasDeletePermission && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Tooltip, { title: localeService.t("permission.panel.delete"), children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListItemHeaderIcon, onClick: () => handleDelete(rule), children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(delete_single_default, {}) }) })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListItemSplit }),
            /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListItemContent, children: [
              /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListItemContentEdit, children: [
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Tooltip, { title: (_d = (_c = item.creator) == null ? void 0 : _c.name) != null ? _d : "", children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Avatar, { src: (_e = item.creator) == null ? void 0 : _e.avatar, style: { marginRight: 6 }, size: 24 }) }) }),
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: index_module_default14.sheetPermissionListItemContentTitle, children: localeService.t("permission.panel.created") }),
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: index_module_default14.sheetPermissionListItemContentSub, children: editPermission ? `${localeService.t("permission.panel.iCanEdit")}` : `${localeService.t("permission.panel.iCanNotEdit")}` })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListItemContentView, children: [
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: index_module_default14.sheetPermissionListItemContentTitle, children: localeService.t("permission.panel.viewPermission") }),
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("span", { className: index_module_default14.sheetPermissionListItemContentSub, children: viewPermission ? `${localeService.t("permission.panel.iCanView")}` : `${localeService.t("permission.panel.iCanNotView")}` })
              ] }),
              rule.description && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(Tooltip, { title: rule.description, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionListItemContentDesc, children: rule.description }) })
            ] })
          ]
        },
        item.objectID
      );
    }) }) : /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: index_module_default14.sheetPermissionListEmpty, children: [
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("img", { width: 240, height: 120, src: panelListEmptyBase64, alt: "" }),
      /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("p", { className: index_module_default14.sheetPermissionListEmptyText, children: localeService.t("permission.dialog.listEmpty") })
    ] }),
    hasSetProtectPermission && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: index_module_default14.sheetPermissionPanelAddWrapper, children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
      Button,
      {
        className: index_module_default14.sheetPermissionPanelAddButton,
        type: "primary",
        onClick: () => {
          const sidebarProps = {
            header: { title: `${localeService.t("permission.panel.title")}` },
            children: {
              label: UNIVER_SHEET_PERMISSION_PANEL,
              showDetail: true
            },
            width: 330
          };
          sidebarService.open(sidebarProps);
        },
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { children: "+ " }),
          localeService.t("permission.button.addNewPermission")
        ]
      }
    ) })
  ] });
};

// ../packages/sheets-ui/src/views/permission/panel/index.tsx
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var SheetPermissionPanel = ({ showDetail, fromSheetBar, rule, oldRule }) => {
  var _a;
  const univerInstanceService = useDependency(IUniverInstanceService);
  const sheetsSelectionsService = useDependency(SheetsSelectionsService);
  const sheetPermissionPanelModel = useDependency(SheetPermissionPanelModel);
  if (!sheetPermissionPanelModel.getVisible()) return null;
  const target = getSheetCommandTarget(univerInstanceService);
  if (!target) return null;
  const { worksheet } = target;
  const selectionRanges = (_a = sheetsSelectionsService.getCurrentSelections()) == null ? void 0 : _a.map((selection) => selection.range);
  const key = selectionRanges.reduce((acc, range) => acc + serializeRangeWithSheet(worksheet.getName(), range), "");
  return showDetail ? /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    SheetPermissionPanelDetail,
    {
      fromSheetBar,
      rule,
      oldRule
    },
    fromSheetBar ? "sheet-bar" : "normal"
  ) : /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(SheetPermissionPanelList, {}, key);
};

// ../packages/sheets-ui/src/views/permission/permission-dialog/index.tsx
var import_react25 = __toESM(require_react());

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/permission/spin/index.module.less
var index_module_default15 = {
  "spinContainer": "univer-spin-container",
  "spinOverlay": "univer-spin-overlay",
  "spinner": "univer-spinner",
  "spin": "univer-spin",
  "contentBlur": "univer-content-blur"
};

// ../packages/sheets-ui/src/views/permission/spin/index.tsx
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var Spin = ({ loading, children }) => {
  return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)("div", { className: index_module_default15.spinContainer, children: [
    loading && /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("div", { className: index_module_default15.spinOverlay, children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("div", { className: index_module_default15.spinner }) }),
    /* @__PURE__ */ (0, import_jsx_runtime39.jsx)("div", { className: loading ? index_module_default15.contentBlur : "", children })
  ] });
};
var spin_default = Spin;

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/permission/permission-dialog/index.module.less
var index_module_default16 = {
  "sheetPermissionDialogWrapper": "univer-sheet-permission-dialog-wrapper",
  "sheetPermissionDialogSplit": "univer-sheet-permission-dialog-split",
  "sheetPermissionDialogItem": "univer-sheet-permission-dialog-item",
  "sheetPermissionUserDialogFooter": "univer-sheet-permission-user-dialog-footer",
  "sheetPermissionUserDialogFooterConfirm": "univer-sheet-permission-user-dialog-footer-confirm",
  "sheetPermissionUserDialogButton": "univer-sheet-permission-user-dialog-button"
};

// ../packages/sheets-ui/src/views/permission/permission-dialog/index.tsx
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var SheetPermissionDialog = () => {
  const localeService = useDependency(LocaleService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const authzIoService = useDependency(IAuthzIoService);
  const worksheetProtectionPointRuleModel = useDependency(WorksheetProtectionPointModel);
  const dialogService = useDependency(IDialogService);
  const permissionService = useDependency(IPermissionService);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const worksheet = workbook.getActiveSheet();
  if (!worksheet) {
    throw new Error("No active sheet found");
  }
  const [collaborators, setCollaborators] = (0, import_react25.useState)([]);
  const commandService = useDependency(ICommandService);
  const [loading, setLoading] = (0, import_react25.useState)(() => {
    const pointRule = worksheetProtectionPointRuleModel.getRule(workbook.getUnitId(), worksheet.getSheetId());
    return !!pointRule;
  });
  const [permissionMap, setPermissionMap] = (0, import_react25.useState)(() => {
    return Object.keys(subUnitPermissionTypeMap).reduce((acc, action) => {
      acc[action] = {
        text: localeService.t(`permission.panel.${subUnitPermissionTypeMap[Number(action)]}`),
        allowed: true
      };
      return acc;
    }, {});
  });
  (0, import_react25.useEffect)(() => {
    const getUserList = async () => {
      const unitId = workbook.getUnitId();
      const collaborators2 = await authzIoService.listCollaborators({
        objectID: unitId,
        unitID: unitId
      });
      setCollaborators(collaborators2);
    };
    getUserList();
  }, []);
  (0, import_react25.useEffect)(() => {
    const getPermissionPoints = async () => {
      const unitId = workbook.getUnitId();
      const worksheetPointRule = worksheetProtectionPointRuleModel.getRule(unitId, worksheet.getSheetId());
      if (!worksheetPointRule) {
        return;
      }
      ;
      setLoading(true);
      const result = await authzIoService.list({
        unitID: workbook.getUnitId(),
        objectIDs: [worksheetPointRule.permissionId],
        actions: defaultWorksheetUnitActionList
      });
      const actions = result[0].strategies.reduce((p, c) => {
        if (subUnitPermissionTypeMap[c.action]) {
          p[c.action] = {
            text: localeService.t(`permission.panel.${subUnitPermissionTypeMap[c.action]}`),
            allowed: c.role !== S.Owner
          };
        }
        return p;
      }, {});
      setPermissionMap(actions);
      setTimeout(() => {
        setLoading(false);
      }, 100);
    };
    getPermissionPoints();
  }, []);
  const handleChangeActionPermission = async () => {
    const workbook2 = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet2 = workbook2 == null ? void 0 : workbook2.getActiveSheet();
    if (!worksheet2) {
      throw new Error("No active sheet found");
    }
    const unitId = workbook2.getUnitId();
    const subUnitId = worksheet2.getSheetId();
    const pointRule = worksheetProtectionPointRuleModel.getRule(unitId, subUnitId);
    const actions = Object.keys(permissionMap).map((action) => {
      return {
        action: Number(action),
        role: permissionMap[action].allowed ? S.Editor : S.Owner
      };
    });
    let permissionId = pointRule == null ? void 0 : pointRule.permissionId;
    if (!permissionId) {
      permissionId = await authzIoService.create({
        objectType: a.Worksheet,
        worksheetObject: {
          unitID: unitId,
          collaborators,
          name: "",
          strategies: actions,
          scope: {
            read: G.AllCollaborator,
            edit: G.AllCollaborator
          }
        }
      });
      commandService.executeCommand(SetWorksheetPermissionPointsCommand.id, {
        rule: {
          permissionId,
          unitId,
          subUnitId
        }
      });
    } else {
      authzIoService.update({
        objectType: a.Worksheet,
        objectID: permissionId,
        unitID: unitId,
        strategies: actions,
        share: void 0,
        name: "",
        scope: {
          read: G.AllCollaborator,
          edit: G.AllCollaborator
        },
        collaborators: void 0
      }).then(() => {
        getAllWorksheetPermissionPoint().forEach((F) => {
          const instance = new F(unitId, subUnitId);
          const unitActionName = instance.subType;
          const action = actions.find((item) => item.action === unitActionName);
          if (action) {
            permissionService.updatePermissionPoint(instance.id, action.role === S.Editor);
          }
        });
      });
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(spin_default, { loading, children: /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: index_module_default16.sheetPermissionDialogWrapper, children: [
    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("div", { className: index_module_default16.sheetPermissionDialogSplit }),
    Object.keys(permissionMap).map((action) => {
      const actionItem = permissionMap[action];
      const { text, allowed } = actionItem;
      return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: index_module_default16.sheetPermissionDialogItem, children: [
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("div", { children: text }),
        /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
          Switch,
          {
            defaultChecked: allowed,
            onChange: () => {
              setPermissionMap({
                ...permissionMap,
                [action]: {
                  ...actionItem,
                  allowed: !allowed
                }
              });
            }
          }
        )
      ] }, text);
    }),
    /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("div", { className: index_module_default16.sheetPermissionDialogSplit }),
    /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("div", { className: index_module_default16.sheetPermissionUserDialogFooter, children: [
      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        Button,
        {
          className: index_module_default16.sheetPermissionUserDialogButton,
          onClick: () => {
            dialogService.close(UNIVER_SHEET_PERMISSION_DIALOG_ID);
          },
          children: localeService.t("permission.button.cancel")
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        Button,
        {
          type: "primary",
          onClick: () => {
            handleChangeActionPermission();
            dialogService.close(UNIVER_SHEET_PERMISSION_DIALOG_ID);
          },
          className: clsx(index_module_default16.sheetPermissionUserDialogFooterConfirm, index_module_default16.sheetPermissionUserDialogButton),
          children: localeService.t("permission.button.confirm")
        }
      )
    ] })
  ] }) });
};

// ../packages/sheets-ui/src/views/permission/user-dialog/index.tsx
var import_react26 = __toESM(require_react());

// ../packages/sheets-ui/src/views/permission/user-dialog/constant.ts
var UserEmptyBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAADwCAYAAADYdbe6AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAB4KADAAQAAAABAAAA8AAAAAAt6wVXAABAAElEQVR4Aey9C5Rm11Xfee/3rEd3V78lWS2p5Qe2sAHxCGYWMMgrK8AAs0LWjDyTNcPDY7CHYTC2CWBw1rg8E3Bggh1kHMbMsGRWEmaWPQ8SB3AIGQsmLCDgxBjLOLZBJautV7f6UV2P73Xvnd9/n7u/OnW7qtVSV1VXS+dI9Z1z9tl7n332/fr87z733PNlWUrJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQPJA8kDyQMbHsg3iqmUPHDze+Dff766r5Vlf7MosvuyPDtdZdlhfckrCjkFz32kTvO6tyv3JB79oTNrodyT87oOr8e5+F2X564vo4+oG8wNdbUriV/tddVo+nA+lcXjNsX6VXa+KU+tT3JKppePK+SglbW82zI1pKEjaEJX3RnN01STrL5VuxpEn/ZPveSvJUGSjYHy2QtZ9vi5kK8Osmw8CbbDu0TzEjp+r8yz3/jZN+WfDJLpM3ng5vBA/VW/OYxNViYPbOcBAS9f5nfxd5/Aw5N/wZ3kQGDtNPokH4OhZKb8kSLxChy8zYHDaE6E30HF8ykSSlekXCKxvmmTGqaVoE+iSurTu3KgEl1jNiCu2yWu5DbauFWvaW6z6lOf1H1OeWm0cq3MdDkNue2S6YwaTQ4dbpOanGeau97ahtE4yz5/Jss+98Usm3DjMx20hOGZjkt1kvSQHoL+az/7Q/mHrJY+kgf2uQfifxP73NRkXvLAlR545JHq8OUyexcz8FvVqolZoDHNjbhZTu36KwmhDGDqZv1j0EQuWYGZt7uuzVpCraknrsflWFb9WISpQiNJxvvzXCxeVu5JvEpO87rTprrEw99W7VfwRjqn8g07m7aYXjpw0+KbCumPk9sqmtsT65Ps+ctZ9gefyrKVNXhqYbN/i7JIzTau3YfaRfbuxR/Kl2qRlCUP7EsP+Pd7XxqXjEoeuJoHBL5rVfZxJvB7Yz4HghgYNk32NfOULxIWn9H5sLLnzhMJWbvWTD0hq39Qsbw3KZ+CT/NfnfdR6/Z+JaOyJwcqr3semeSkKWCLoHa3y/KoHxcw22j07tzWuH9XEuuT8pjH2+J+XW6ay6Zazsfq+SNPZNkffzrojG2Iy5tspuL9O4/aoS21utnrFt+QQNj9lfL95wH/97b/LEsWJQ88iwc+80j1cVjui9kEALY0S0FlJZ/crWyUGpT49mvS1p8i3k0TOHy2rCueWkZ64+VtkdWmf0Tqw6JaEUmi6SPWaaSa1gQNq8sWiUU8sXxMly61NfWIrjTlDdWp3rq6SdZoPhBncLm6j7gvNWl80/FG9tZiG5n0KklAqVl3Gu1LgO+ffMa47ENjsD5q/SK6mmkbtKnpaqz117Slbit73U8lEJbrUtqHHvDv8z40LZmUPLC9Bz7/WPWuoswWncPn3mbebFc95vH27XAh5nfeprzLxrziUaqBYFPZ+Zt6jKmWsWXcmtF0OLMzRXmsz8lTGnICz1if8yjfEsigW5/GECrTumgkB3jRTTe5gbQaG6kpa831eKRHaXU9yz72R6GsT9e/QXl+Jfr+5Ki0SPji89OQpJIHds8Dnd1TnTQnD+yOB1h6Ps1G2EVFrTZ/a4ZXaoBNPbeHprrNKnw4IDkAOF35pmgP3VIvfqVNbYG06TMGuyaItNGhiM50SWlkoOSU3B7PnR4a7XP64bZ4LnWu1tR5pe7HgdKqfLjujspTrYHu4xXZxuF5xOg2Gs/0Q4UwtIg1EJuf9CtbxPeHf55lHc1GLhS1TWmRvNvkJOlRknhcpnpvN7P9AYuUU0oe2Fce8O/qvjIqGZM8cDUP/OWXqgcBj+8Xj32B9eETtxPrmVig50kkA6GYt250kqsycIE4pbseEeqyMl+GNUCo20xHLWgkCEZTXy4f8YocJxO1j5oqYZIBbShuRIi0iT4dV81bZzV34LFK1KBi3I3avdnpzrOJrsaaoEw+0IY1JTVtAvqa5h3FwOm6zzydZf/+c8FG97vrtzF759JFB9LvNzLmf+quC5Ypj5VVz7KLWS+7+21/K09RsJyS0r7xQIqA982lSIZcqweYpO+zZ7bRBqhc0bAmZmhq6/HN7tbfbpv0hQxXSTbx064JvpmuVd7BwnVcTefV+vD+PI95XafTnq3Ppo6r1b0t7iMey9XKAsLBMABjU4/ZyDXZLv3VGa5VO2oVmpKmoFpfE9OrBtW9sZmr/cp0mBeMtUt+8cqmREkeuHEeqKeoG2dA6jl54Ll44JEnOGgjz057hDTNUaKJvs1EPtcPYCy9TTCI+/I2p6nepLmOODdA0cRP8rLnoklHnHRD4El8SsrtJoLc+/S62l0m1uV9uA61ebvrkGxMV11pu3bX6Tyuz4TqD6d57jJeV64hzs0AwqM6OoXgdk4j4shn1h8feuVoxPOEjgBY7bU/1G6uso8r7TfdGr/4Ih/GOrx/6cLGHyVbVDml5IH94oEEwPvlSiQ7rskDTOb3akK3FAGb1aFrInfwqrmmIOX1OHcQeS60WMbLnsd6tio737Pl1yLb5HGd29G3at+KFstv1b4VTTLye48HrjqpylJ9nQSE02umBr9+FM8vBxnj9w+118DrpC3zrfic5vmG4OEHf6e69w3fmk7L2nBJKt1oDyQAvtFXIPX/nDzARH7YI8UYCDwKskhqG43id744OtqG/TmTXb8LNutOv5Y8lo3LklVdf/7ctdne1O/tzdz5nO515VvR4va4HPPK/3ZyFQzua7VvSgLXmqbdz9d8zaTEZZ8NoKW/wZNPsvugfpK/lJIH9oUHEgDvi8uQjLhWDzCvnhavJvV4jvVJ3uhqIDVB1usODF4P3Buf0uFtcXmDY+tSLCMOr2/NvTXV+4tl47LrjWlxeSut3t7MndfpXncbVI/L3t7MXd55VVfZ655P9Ukvf+ITWAuAxePJ5U1vRBegXqHLaQhrQYSqJckq6vZNWkbMs9OhNX0mD+wPDyQA3h/XIVlxjR7QpBpPshKzHbHMvjZhU/f8aiqvxhO3xWXpiwFgO/1NmavJNfU1ZZvt2/W5k/TYBi9fix3O63lsk8t7m+fCVy1bK/frGsvtcHlhh/UldckD1+WBBMDX5b4kvNcemCiyaXSqyX0vZm9168DRMOFZq9vJbUd3hc/W7ny7nT9XOxxw7dLUyCoddq0iY7V7ndOqzK9TGYRMRB9SEKea5uRNdllnG8yuz9G93fzibLCmUvLADfFAAuAb4vbU6fV4wCdyTbDTH0y4HoVJdsc94MDoS8B+zZod6fUjB0oD3ZpBWCq6kmRjLI7pam/WTUYfpFpFKMcVo6SP5IEb64EEwDfW/6n35+EBTbgOvD75upp4onZayvfWA7omDrh+fZTrz6+bLBKPvatNbjJG5AM+S1tdTNHiJN4mn/PEbdBagH1KyQP7yQMJgPfT1Ui2XJMHfHKPmUVLaX95oHlNBL7NHezxBizxq118nhzA42ve1CteB3DDXPTEctauj7QELS+ktI88kAB4H12MZMpz94BPzMJfD5yeu5YksZMe0DXx69LU6xGwg6hOLNO1i5Oe1ard3x1utjuvB7iqi0f4qny7vh2UYUkpeWBfeCAB8L64DMmIa/VApehIM289+1rkY7NuTbtWRYlv1zwQA2YMhn6t1G6Xj8Kmd4BFrFMs5zTlTleu5Dq3A9f6a5JuzoK70uc+80AC4H12QW6EOYvve+Sw9Xv49IAfMB/cCBuerc93/tKFu8q889eevlB+xa3HWjYR+6xqryEx0243CT+b7tS+wx4AHB1kDSBRH2HrRiN0+wWkuBFBu46uwE1znfA6CKsTsQU0D4wua3Q11boNsON+Anv6TB64oR5IAHxD3X9jOl/84Pqdw/H6V7az/h1VXi0MWRds8fCtWl+t3vmBlZzqU61OazmbVI9WRfXYz771wFM3xlIO78XW0aj4JibZO7XEmGd5Fe+slV2aVzXBip7S/vGAR6myaHpp7GJtAKeWoC3VdJWnvJQj8pbRrvdhQB8LmtKND9Ojj5SSB/aRB/zrv49MSqbslgd+4v0Xv66Tdb5xNC56WdXJq6wAtFraGmNdQlDS54lyUp6g/tK8m+U/9cDlQavVfqxqF58vWuPHfu7NRy8Z5y59LD74yMzaypHXdKrOa0bj8S15q1VVwG5ekecZ/5OwsjmfOv2Khl2yM6nd2gO+IqEv0vQ0qppVgOnXSe3+G8AqK1mbPsRHLn61eWQ7vbZq17Ni37AF75RfAi5DPu0zfM2tLX0kD+wHDyQA3g9XYZdtWHygOjSqVr6d6PFOJiP9V7byVq6yTXjqvyS0VB0mgLeewgIdUrcqy5eCfi/r8MOq7/yl5bPtPP9ikY2+8DM/fOyxnTL/nR945o5q0nv5aCUDfNu9PC8Jd1uTil052GT2hRm3HRkYep+OY6eMSXqetwcMLAWIfIumqxLUBYT6E4jqeukvfgY8BVno/gU0mupOqOW8Ov0ZSgjSN6VT9jSliSGl5IF95IEEwPvoYuyGKUSvJwb5yv2tPO8zERU2S6kjIkl9EkHkTGLga8hFZLKzqUp05wsimuAgFtmxqpUdrcr+V7/j/Zf1zPhsu2o/xomCZ45ms2ff8pacX4Z99vTAA1X/6f7wVF5Up8bF5NVVmfcVjOsmgHuEMHdjCUZqWVy2QIvvDjb34RPtZmqq7bkHuBDxtYjB023xdt/xPKXrelPRn3iUK/nrSyoLlJs6fce087t+r3su+ZSSB/aLBxIA75crsQt2/N0PDO8py/G3MlsxX1VFTlI3VrVpLKtabVveBfKmcx4zXJjeiHi1aKe5zOazguU+IhbwN8vtTANkiE276LutysuX8FOwr30yW81+6oHVQSsvz4HswzJrDwFTfnROk2l5KOOn6vJ2dQi8PwTvoQwhehPm0kmwUb1XLDcrApac6maJdNCRiEJnn4gtr/nIUrrRHuAC2TWzqxeuk0wSzfPwTbS2t3ItNz3SqNlYlOGgjvrwjIIvna82t5yBdqeZ4vojXml2VsR1V7cU86Vy8sCN9kAC4Bt9BXap/7/7vsv3TIrRX+cn6osKXAvn4IYpsMraYGah53NElsLlrNSEqPBSNC8bUDODtesjhEK0oqkMpGTmy0FSaZR+PlgpDrMlz5a7RdW+TVBN5A2cFzYPojcvFVVbzVDX5k/Zo+AcXXkb7rJqY0eRk5emmw7Vt+iAuuva8BwUEev5foOeSjfEAw60rFpY5GpGcIH0vVIK35m6nmf/7OWn8iVr2IGP099fzRzrZcUnfiUf74C6pCJ5YFc9kAB4V917Y5T/9D9a+cpJkX8TvTMFsurMxAdg2vQXlpUBO9UBQ2GXlpXFyjIfoFcHFXD7hFmiw8DaAZpNUUS48ApYWwLHXBFKUdKXdApbWwF0oUX90gxDafuY6dN0EOkShCNKU0tzNgoKVqWFqQHs2+C69Ie6pOuwyHhr8KUXBFLabx7QF8xtqgv60um7pXyn0/xqdnKlyPQFeWSndSd9yQM77YEEwDvt0Rus753sdC6K6uuY3ogetYyrp2OgrR6iWeJhqgFkq5yAyvb6EWAnvqIkECaWDZFLAGWJiD8AIhBYtYDCUlunTb/KamMuRYeBPIBqyE6d1WL0BXpLNwFGC/pLRdwk2SMwNuCHgk0dIbJWmoPNQK4tQcsObhakzzqUtMqe4rLTdivXgJXiPkWL62rfik/03U5uy7PlssN5vKy8OQ7RtktNecnanRQCuqHSJRKPvonmNuVb+Go7/c+FXsxmMyxbrz8XmcSbPHCjPJAA+EZ5fhf6fccvrn4t8ebXhOmPsFQTHTMhkx3PeslLRZuCRD33ZUJsE4MqNBZM5i1bhhboaSVZdOVBxnYj29wJMubQC9FVZhiF+BROKwXgFDijDhyuJ3Jk1b84DLu1qQr9RMPWj2yAGdCVraCsQBzdgDRwr5sDNWsshu1mSZjEpbHuwyZ11ZU0Pk/e7vWr5ZK7Gr+3i8f7iGnS7fU4d3qz71iP2rzuecwvWpxcv2jNcsynclOf15U39XrddXouPV5W7vXpvV0gTf3iffilUG7Xna+KyqajMaZaxfPLFrmT+yueG+dh6eT5KUlSyQN754EEwHvn613r6Uce+Hx/rnXra1kSfgVzW6nlWgGWrdtqMY4tU7SRM+npB3WhiUw0G0BYEeyENeBOm6Vk1u+05ssyM+W83S6kplKuZ7AkPZslFhULC9EsQ9NuAGkDpGMtFTO5ajk7dGYN9E8N3NVDYfZmwYV+0Nz6sSVrbe3K6Ydla0r2LFi4rveVecKsDomiheLsBNMMTvJJ3kEjUDfoXlcume34t9LX5Pf6Vrq8zXPvV3X9xSm2NW7bzrYmf8wXy8s1atOfuanuNObxNucTi7eL5nXRVPc2rzstzqegWo/TZaTL+UzxFvUZb9iJfDEvO3+7usSKzMpOqEs6kgd22wMJgHfbw7usf/ED1YGVyeW/no+rYwAiASPYxlYmXuIxkGxr15O2QYGv7TbAB+aqDTg0EHbzwDYWgdk6pUhYwAsjIrZMbKvDBKlsqqo6CnfoZUId1UJDYbHR/DmxZAW1kwnzL4GyNlAZpyZ0ba4iIyC3MAWYV/StB8Usgcsq7IICDjOdUxeJX2zXm79gv8B7E5x5zXPJe1m5AMBpTve6g0PME7iDDqc7v7cpj2W9H88dCGP+uBzbIbrLOT2Wb7Y1+3W9TVu97rnzKXea9+d152nWnR7zq+x1b/dcdLl904WivtW4dvrc00//7/kNO7XNx5/y5IFr9UAC4Gv11D7k+/EPrNw6mqzfx/u3fRaGJwIxOy2KGTCswhH5Yjf4lwOcYyZAbYIiltTzV0CYVWIFu/xv0bByRbRQLbLVJNoqgUMSiG2xrYpCVZ4YUwJqw1tByIVlbWbZvABdBZQtg3GWlQFi1pQ5/APQFnITXVPKO+gR6JoO8DX0H/To+bHVteELESG47h6wTY+EbYZvAoADh/LmZK8xeLsBRM2j+wmvi8eTeJv6vS2mx2W1q273KNjoOpp1t8P547pocV2ycfL+PPc2r0s2HrvK3r94Y91NWeloyqvuup3f81hXzON01+dtTnf5lCcPvNg9kAD4Jv0GvPP9q1/HGu2reBjLCLQxSuDJBGrPSgVYgq+QRK+BVou/RJqAIc0AYkvLxNp1HF7zYVEa8EWHdlkBmu1SoC3A5MgsbecKy8qGxrwSxI4oHWWpPvlP27iIigWQimr1ahHAzrNidKPAXl2qn+3KViGfzNbyuHFqos85mlDROknL2+G1KHLBSIiMicONnY8YHBiwAY8kla422cdygTvICqgcLGIQE4/osZzXY3mVY7BzHs+dd6tcPJ5i27ezQ7yu13PJiT9ui8uuV/wu47n4vF256Fsl5/E253MZz9Wua2L6vRLXvSymHUpf+6ZqTqp4BWlth1QmNckDu+qBBMC76t6dV/6Of3TxCHj5DZNycgTwCrEh+5uY+G0qswkx7DzWYq3talZurwgJFOECMAlQsS3XsRiAHuhsy7/EnNqTBUiXnP2cC2cFxuJVDhBqMRta/f6v8FXQC2CigrCWB8WwEqXyALeATTu/AG0tJKvfMNnWU7uUmx7ZiF694yuFZhdhNpKIGJ4EuUCzGw52j0Ezu+rcmGs+By0boxm0wUvV7VDRdGzSo7GiR3+evK9Yn7e7rNe9b5dV7jxXy53f+9oqdx7X4316LnqcVL/aTYV4435Ud93eFut2/U0ep8d9uV7TWX+4nJtpdbXtUFpZz26pVT2yQyqTmuSBXfVAAuBdde/OKX/TB6vukfHKl1Xj7NVo1cKkRafaK8XEp0hWS7wExSFSrSdFAa5Fp1oi1tNgRauaHBVlokQwU43teStKtFBMBKooWYBLm/GTZ8UEPO3wrBaY5TUnkUJCgyJjHhsbdKusBjRxA6ANW6bHeBWFo7u2Ua89Ta20dpcVqNtzY6w3sOfZNAwoNMOs81oyRP0mvfHhk38MHjHNQdJ1OJ80eNnbRFPZ5VWP01b83u5yqnt5q9z5BWBum2gOaN63ci9Ljyenqa6yJ/G4vrhfb1e+FT3WvZW899fsq6mL6zi1x82S2c4X23G9ZaLf7too63TH6RWk6/Vlkt87DyQA3jtfP6+eBLwHhyuv6Awuv4LfA+qhhGVicEc7o3QuIzMau5YLYlfTL4xTISzjqmBkRbB6i2fTCxo2QRLNAnY2P2oHtPNrAZslaAJZ7Y+ij45CT9sRbQoFpt6H6VEwi36VBaQAJ0X0AaLiVYJgUTlFLWnbjYE18OH6tAOb0FsgDQDp+XN4+ExfhX5AAiOkY1NS1UChpnq7T/QOGGqO22r2KU31mNfLyrdLri/m9X5jGW+PaXFZ7QI7JdcZl92Gpm7VneZlyTm/6/D+PXd6nMdtXvbc+baqq82TbPBkbqvrThYt1uG815sPLrAPgpPE6X/1enUl+eSBvfJAAuC98vRz7GcKvMO1lzF5dRW7MnEZnBqQQgSsBFT8EcJacMhcXOcAbosyQMc+aJ7NqntoJKFhAFqe14KDRRtwY+oH+KjTBhfPfm3GtO5MVmArkNQ7ugjZyVfSVkeo4iHoFYWCxOCtbal1hX6Rh1FAreXzCWDNvjFK0i9d9roUwlrCBnOlUyNFYcHthspa1dbmL/SYjTTFZaqeNNEriS+e9L3czAN34HW5OPf2mOY6RFPZ09S2mh7XncfzWIfTlMcyPgbvw+vO36THsrEul4tztbsNsZ5YztubesUTJ5OPr0dddtdIXpfN67HsdZXnswOtUVb2LmfX9EMg19VXEk4e2CEPJADeIUfuhBqB7sJweCcPQm9tDdaOT/QTuDXm8isIvNdjgBgmL65cyXs+9ntuvNur4ElxsDC6nNRRMoBWldocLZAOwMmWZMMvzYNtGAG4MTMigDhRZ3ZWM2dkaY5kTRtARrEDeB2gAcKKt4lM9dy2moQ5O5gmK5ALZ2NpCdqeCkuZTbuoxe58oihXfaMfUoj8pM9sJVKeKMq35WctPusVJLNeIE3kbwOC5FrV7BO6A4u11TzBwMDvdNEcTDx3DtfhPHEel12Xy8V152vqjnm8zXO1udx2uXiU1B4n6dhKj/PE/DGft8e5t28l4zTncTnRRTN67Xe1xXwR2b4NLrsT+biVzfG2WvWJj6YNWDvhz6RjbzyQAHhv/LxlL4uL1dzqidVDrWF1rOxkx/P1ywtiDAdeECgqSuSxq3C3NbYotsZAIkAtDetFHYWvAKF+2LwAj3luaKdMAVslZ00SNrMUzMQEiPL+L/pIPDYGkAE/dBeFol7J8RBXrSCrMunRzx5wDrR4BdQVD4vzNj+HFPoJG6iwQXJwCoGxyx4TK2LVOIStQZYbA23S0rHSvJBMv9r+he3SV/etmwQH5bCUzYYvBdUYREvQI+s1qTsQOA5BCqkmePsUFLw5BooGTdVNgBH1423e7vodeLzd684n+nbJeT13Pq97LrrrezZa3K6yy7q86jHdGOoPl/Vnzy4jeiyzVT3Wo7Kuh/FR8GtTmxPamgLXWe+W2RprN+kHGK7Tj0l8bz2QAHgP/P0mNoi85DXZ7LibHRysrix0u61ZFlSPrRTLXf0cX8kDVu041hGPhZCJpdkq7xA+avISQCnAE2J5mgjc6kQBfi3hikv0dqfDJ8u7LO2aHLoM/HKi1RYPc4ms8/bE5lf1oaR+0GNzJKvCegUJ5IUf20LfCl05RsPsE0B3FIrqSA8wHuy0vtQ/7CRbOobfcumHzJ8tKQP63DwoAsYWo2tRWjLYqYgde6XDdVE3fdaHwBje0Iu4Qqq7DQ02Cm8JucCgtmHa4LQpgYJongREuikxIKnp035gUjnmdznPXf92uevy3PlcPtbv5TgXX9y/l2M9zi9elT133kDZGEss623N3PWI1/Vc0U/D36YXRcYnhXV7U/fzrT/8ofzJ5yub5JIHbpQHEgDvgucFuPOvWj/Z65ZHiR6PlsXy3GVFfkSdbJtqDQk2CfwEInrdB0D0ZWKWdEFhHcUIEAFyITq1MFAASZqAtHptSBEnAGXv7Xr0qd9S0Cu7tT7abWe0zsSwQzCkW70G3FC/gV96VVZjsEeRM0vS9ky3nrVrOUCpAoOJZsMyNfyslEulnh27zQp90cFGrAlryB0dY8kCObYRLYvOKrn5Q/Yzh1s/wbYw/nAjQHQN3Aa9mq/VhpXWm2yeJhplfPgIoBCDhMoOEJ6L3XlUdrB1urzh4OsyMb/44tTkMW/WDC7nPCKrP6e7Hq9L1nk9d32eSybmU93lvc3zpg7ni+VFcz7PXV65J8noT75xPd62KdfXBj4l46dusoFksmLZ6ZOwavUpSx64KTyQAHiHLtOb3vSn3SNf++rbRqvDk63WKu/oMknpmapeoSHcZMLNJzyzVZSrXcdMYKJrkuI/fv/WaDz7bHWmdfHrApUWtfIeEDmgJr2kNgdPAoJEuywtmzwRqkWUvH9rU1+LoJkoNbQxX6pP64eZU5uYxD/h/SJpq3WHsgG8Jtmw7E2fZu8jo9lb7+qOntIYpEeAa2OSXdxb6AFvDbwam5aRucFQN21uHxgJz31lW20HvPTd6pRqZZnc6LRxGIduQgTq2KWNZuarMJ0TUxvdPmjXpO5AYC113elqU7mZXEZ0lWM+l3W5Zt11xXTXoTaXi/uQHxjHNKnc5IvrrnsqQMH1qc3bPZd+t8FpW8luRXO9avOyctfjudpVjschmieXtSvlF0iNkS5VdTn0HZau6z0LWq8fjVayA3/+6/kF6U4peeBm8kAC4Ou8Wu94z8Uj4/n2bQSsJ8YrQ9CT+aaYWGRb8MxUwEK8y7YilnOJ3bRDWMvFFqmyBbgYh6hRB0BqqZXHs6zHSgcTFDA2QV5bqYBUtjaxbIsuYe645MBHGPOxIlGWaClLEFDmLZ42B1BpGZk+C5Z1FQIHMMUAbZxi1zH9KuXIVnaKpezrFAJUsxlQ5fGvbZoqeLKmZ8wzq+Plj/7VzHefPDr5wjfcNfgz46u0jEyf4w5jVkdaptb4JuEmgz60mau0PqAzPv1QkvrEDv38ESvL8oneMmLZnTFiv/lAY9ANAu8e1adjIU/kb8vlMp5kQBGK07qDkQjmF4bh5bgeqIHHy1MQgRCDkNrjNuffir4Vn4NW3BaXXZ/TPJe93kdcFi0ei/j1F9NMsP5welOH83i715W7DU7bisd9HfNOy7VNDsgaigOvdNZDc/XPKx8MstvGVTbHfopLi4vh3JbnpSgJJQ/cAA8kAH6eTl98sJpZu7hyNzB2CyAHWCpC7fNjPfXyKfMXkWnW4Vlp3mUuA2GJ9ureFDkWLSI99hfxC0RVpyQ8tp/mZaK2eYmJrWp3+/ZsWDqrvD+mD8U5Fh3mpZZ06cPmsUCjkbYQ/erdYA66QCdgprd6wG6BqBC13e1UALD1x0u6wbaqk40BurZFu4wl0yYtZlDNmNgNMOe3H29f/O4j4w//+mf7P/mXf9n/ntOd8Ye++e7iz7RBKlO4TVKELhsn7HTuhA4DHQPUt8YCUGO2ZGSQfGFy4DlTd6uvvrJunxsAbMQeaAA0QJ9XAyzi6EvrIUzgWBdMhKiyPqYAoKoR1bC5HINJzBM4N4DM27YCrlhHU87rzyX3vmKZJs3rzb6d7rl0OI/nosXtqntq0iXjyds8j/X5jYXzKhefy9vrYnWjLkWzXjc9r8yi3xG7n7vZWgLf5+XCJHSDPeCIcIPNuLm6f9t7z92+vnz5rmEB8maK/MYEfhzRyKSlVWWLIok0292cAHWQdYhsieQMCgBNQQVxIruTa/4CHoCLh66KWrXMDODiEqEmz3mBZD0lBUFZ+pWn1KZ+PBdNp0rx64CAOcvWAB9Ap5sCgnA12tKvtl4RlWLrqACMOwJokHIMryw3Gwi/SejOxacI1MCRGAMOJUXVf/ue7D0P/n73pz53Z/cfLj3S+eSxQfGxl56oPvnKE8UT4hfutvmFCJSj26dtgSwjkW57Ti3dAmXo3APoLWdzkI2TQQPU3CgYg8qc14XLbHOWKbSP2iZl08iqppniq3xsWLU1U7O9WZfUtdK27uHq1BjkxNmsb9V3U6PzeO7tTV3PVX9Tn+v1/Ar9fk24wLa0QS6e600rrDr1eOt35mB27np1JfnkgRvhgQTAz8HrDzxQ9b9YrbyCleTD3PkDsO1Jm4hTy6sdAJWXdAw4dPRTh//0zLNHuZyM856OkmITEjuTDWda3cBbssRqFwFg4jxJAuKxeLQqa8me1VqgCwTzUhJr3Nam9y3sBCsVADuWnokuOqX6EzJYe7edd8BOPUeVMtZ72ccEQMOnMpNh1WfZl3OlwX/sYSe2zFO7dimD4Nhtz40ZVwdwBwTpJuO8vzd+8/jv/a+/e7BYPZl/Z3Gyc++XznWyP/1S9Vunj40+9s2nRv8umMWNRznIZ7ozHJvJknQ+zmVY0Q0RP62cHThTDtVWjhkbdunMS3zHsZi8ssTNATbxenPJj6zbuJi4bSw+ydtEbm3WrGHueXJbdrLjJsg169fT11a6tqI1+7DFkGsATumy6yIFlFWf0uzqBfqUp9nRNdRf/l9Vh8pxtsCt2dqfpx9fuAaPJZb96IEEwNd4VQS+j2drX847QzPMQVpQBpKICxXRFR2iNwEb041mKdbEJuMxwNcF1ABURIj8eDjK88wQxdm7rRyuDFazJAzqjQFBoE+/+GOPOAXwADiRL5eIvhQ9dsfEs52ugZKA0VBWh1Mq9TZfSidb5IqNsqejsFT6mLnalPktBk2nebtHpEk7IWfelV5SyZj0jFYRC+vkWlnmfA1+QLAHpurMDHh+4L7LP/Orvzu/srre+i9mThFDt/PvePjp/nd89sn+EwsHyt/6iuOT33zV8Zkn7cXirFO1J9wN9LBB6NwT2OI3xqsRtqoZxsZNBf6YJvi0oG57wiRjgszlPolD8ckd/xBti8CfRrWHKbZnD7vdk65GrKAMuBcbkus6HuCLpb846SuvFG4WQ1nXIgbYuBz76/nugp6bzQ6VRL/9A9njocf0mTxw83kgmu1uPuP3yuLFDz4+9/jltXuIdAk6u/xwkECVqb7sMvUAtBhikVrBU1SBiFZ/AQEiWRo0MUGfADzAdgFPu9UlyhtrZZgy+A0bOpRlxWhsZzNLp6oGOprgBMgCQ9qtgRaLgJkcDRABaaursU5MmBbVKnokGGdGpM+YxvIwk6HBlfZkcd+QlUOiVBI3D+oR3TbWgvsLxeH2dhRjs53cY4D9B79t5b0P/s785fNn2z9w8FXoOIGNa9ltZ59uvfFfP9174x8uVP/uxGz1L+69df33b5/Plsv1cd6lIx+HRmVjlW2j2l7ZAch3iJRlV5v7FllpGFyPTZkmdZ/oHQSi5lS8Dg+M8PsKDhcAKwlcueljT0Oox5/LoKj45vjuzzXAWXwC3BiAvRwDcazvWsqcevUU5l3gpwebX4trEU88yQP7wgM22e4LS/apEYsfrnorT+hXiIq+TPSoVmBX5V2iuABYbr7AZRxFv7Y+HEGH5MUb5LqA6JhfBeryGo/AJ+gS+KjufYlf/aE26/QE6SAUia3HLQGq+AhJmRrDXKR6ANpJu83zVvGqLrm4H9fjcuLbGNdWkIdEDY6uL8h2swd/Z+4HLw6zN8+/EhtnsU198quso7MUqHQPZpdnO9Xv3b4w+ejrbl/7RPCT/BlAN/hBNippfFoW79j0r3GKKt7X/yeH3jXfz/9T1ZU0mWuEElSfhw/AtwVIiDela/PAZSLLVZ2ojB9nAdVZLofAd7s0BKwvc6BMeDhCtIysgHgrgLWbJi6WrpWuWdXL7r7ntnyJYkrJAy86D6QI+CqX/MMfrtp//OTKy9l3y1qxwEC394RpeRfwDdM+ILFJAxubrF3Tjzbwhmkm8BSlADZMS0GO7dHoC3y2ZG26tBFKr/QU5UiRH0p66GSjUkdgLZCUDo5w5gZAvAAWjSNavB/eIGJjFTuhxxPl8LfaAmen84w39MSnomKL5Fu9bi8bwcYvAcNvy981nwA8xC3auKVXprS5qmv3Eh3aRvn3f9vog7/2sUPVM59q/bcztzNpv4T5m5c8Z08Bpev0ci47OMrz71oZd7/r888sPH7L7OSDLztcfOKeY+tfkincNDCeYGvwmU6Rru1thc1YNnYtjDNiTeAW9crFJNVT2hkPrPEd0E3MYW6krga83lufr53+tFTNTwJm6zrdjcZ53UdFyW+W/Fopry9fxLV98dX3V732QnayuJQ9/fBHckF+SskDN7UHwox9Uw9h94z//afO3dIe8iu47Z4tuQp8lVo8fNK+3Lzq6dloNR4LRHvczANUej7Krt5qAniqTjtQoo1EFc9d8xG8XYBOEWS7JR6WYy065dEvfFkXXcxeFNmMxfu+BvpD6YcPHu0WNlAOcuydIkBc4QGt8fNzwQKzHn2xX2ow4pkr4C1b6j6xLpxhNRrxUBmcB3w5JwNbMJnQRWWWq9lYxqu6JfJMokWJvnJo46nKXtbqYg82apm9TduE96yU3vCd67/8q/9iprpwpv1DFcuSM3fIFv5wTP82JmUtVT6Nvl72kieqzrufWOtkf/xE70+PzVf/7G+9cv2fy6+6jegyZvlL/qzot2Ls8rF6qbL58BoSM7cMmk7gqpuFEFO6Lg+cmA/i8TPda1E4w2zSA7gvXQaM+SLqpXhtTfDLohsmu0bk0+t2LYrhuf/+qv252ew0jylmhr1sGVIC4Gv0XWLbvx5Ii3XbXJsP8stEM4OZo62iW2SjYVkMeOmId410ogZACq1iZ65q7JSiDlgWI/iAw0m7GHFwhAJF2qBzroTxF4OqmIGXF5CMX7JFOeTYjBFgo2gW2RLdCu5yi/r0w0JsVeqySWpUSla7tUKveqrLAR3IA1klB2FwSmXQrz7FI3qwpWu2A3BgH09ysZ2NTQAsthWSZ/V7gG76YWy6UeAEkc7Y7B53gVza0V2o/3yIzcFGgueScyjNP5wcXWl8/823r//S4QPlB4a8GHL5MwF0LebXjAuCKjrWXrDRl4iMmUZHZf51T1xu/U//y5/O/faDDx/+H//ozPwrijY2YaN0W7+13+QXhb0W+VKRSk3u9uezPPWUrs8DAt7nCr7eoyLneVY+dDnqH+/yJqOF9Z/QPm24hsKnD2WneGttjvu5Z77wT3MBcErJAze9B9K0tc0l/PGfX7m1bJWH1dzu9DjcKkS0qhfFiOXdnt3EswIdbuZ5wwewqEJdsRt8yDAJVX2eHrPhaurrQOvxrGyU9ftEe6Zbj5iH9CV9TjM19iG661B5NBy1ev0DxM48Bxb48RoyUe80d8kg16dvPdQLqalLz+xkhwcV6kdjlm7CZN4MCmOP5VwXkthcYc8YezZ4f/W35n/44mrrv9d7vwLdHodzavK17dPyGH9jng+PL0Gjrc2zW09M/l86Nlf+0ssOl3/yNSfDErXaerjo9X/jwHtmZ/Pvdl7lppcRysHpGXDsmRtTfgZ4tGui7qffesq67nXd26v+sz8DfvX3VneyCfAo+xPWP/VP8v8gtSklD7wQPJAi4G2uYqts91rdHhGfolFe3Cl7her6684c4NCMXtlir5PAVOWq1YVmPzJAPcgEeR26QTs0lxeQTYh6Vfe81R2Y7qAv8LqekPewQVF16CPYMCwHen8JO7ozXc6/7PHIV/Vgt+qToqf3j41H8qEt2O7lYI9ehZI9PXL1QzRfj0n69UeEbjZIzmUDnf3g9D9gBSDUe+UP/s2VBw7Nle9XHL7+KEuSTzD3MgFr4rWJmLxzjGfEdwO+8Iwf4yZlJTRxAubtT6+23vNHX+r87v/2qQPv/78+N/86jXt13U470ePFTcnneKnejWQ2R4qb9ahpU3E7e7ajx8LXwhPze3k725zuepV7WbJx2XVdLd+OX3RdD3veGymY9t8UfJb3kF72PdVJbshO8Bhj8Mph9oVIZSomD9z0HvC566YfyE4P4McfuPgy6eSsWUsz9anxqvMqLgu0Wa4mI/Mh4BTNcn60R23OFxRs1iU++ymYWi8PVFsKUjvzPIJdBaDRYXLSI93zM/mAzmWH28QhFkSpw9aEXxaUGn7+Nzf5AvoAOhFxB5pytddDMbXSo346vKM8Ye1YRPUpmzkca1Mu29SHeLx/9T0ZD8xG1y1Z8fBbCpxypZOuqurXfvvgW5ZXW28RvQ3j7F0sb2rngTjjP6rj8/wRPbWO8lc/h4RsiUn4TK9d/dt//N9lt3/ZbflrZY3EZYDlFEQ7cpB+uK0UzZPxQHBQmMo4w1Vy0x21P1vdWb1/78votQ3OY89E64rZVivfJOPM5KIrNW0I1M30mEdlCcXjj2XkN9nyDLvWD7LKMMcjAsmYHbWc8yv3NqepPk1UFAHHycfjedyGsrvvuTtf2kSLKtp4NTyQLXz1Snb+Ix+xN/ai1v1RXHywOjxeX38V57u+tJ23T/KcRDsy+LdZDdhYeBGX/EVvbn5p8Q35xf1hcbJiv3jA/03vF3v2jR1vfc+F09qYK4M4kIkzKlR2qJmBFsCnDRAJGDnAwnzZ4fyKAFYzPOsMwBYGVcuggs1Wpks6JC9oDH3M8G8YvaBc4BlkQ8CvA5BN0Ktc+hWJui2Sc6fJxuF63urP6o0mXluiH7drw35xByj2ccV558BMXg21iXVAxLoBvNOh150JYPuzffoJ9oo8mQzNRpXVn/TK7n/y2wvfd3Ele5foeum3rdeUmOjb9V/O6rcDkPIR0fKEm5EWS9OtaGla8t/y1Vn2H70yy+69LctuPxQAQ3QlOUIArOeQONXS1DnUjMaH+lBSXcUr8ppHdEt1PaoGuYje5FXddUvO7TA+b2zQxWOgTGErWekRWLr9W9ZFJIlPSXrE73qng7XWjX60w/xJNk9pN/PxudAouVpNzR34p5W6ENukfs4BM7z5nmlTViwf8011bAHAnPE8d6mfFV94f863YH8mQHdmuLr+VexifBVvBNwF4MrVOJo9ghxqzrdQfmc3pu0ZtCY2+S8V+fj3/v4PHVkyQvp40XsgfGle9G640gF/539+cn5Ydo90O7O1j3iXxtIsvxGwXs3OznK61DptoEm2TrQ7W62vr/P7BWxeBiBdznlpyrqddSLLWZuTOGDCIs0uv9UgeenZ4F2HV1HobBSNqq+QeF3YgDuOVodrg9YMpownM5XTg17JSLcmBR8D00Nt58Y4JAtgR/2KP8jNmu1193UWxj2eaDzBXm93X0hXkM+yf/qvjt5/fjl776YZ2QXI9cqSALnDn8r8MkM2ISKesCzdvhVaHRELgL+M3dWeXsnBH19+Mstuq4H6GKAcTvbYABfntb7xohypizAFBCqqawp1muoixiDkF8Da1E5ymsqim+5poZZv6HFG45XgVZLzeC7WK8qu3/uNeJq83pWzarxSKL6zq+wU4HGAdkFz4xb8UQu4HstdWG2UYx9J3xd5tj9ga99hruOmgztq3unNQJCfRsAv/5Gq372c3ckO+yO8wXf2U/84f6Tuft9kb33fhcOz/Zmv4PbytawMMULuNPTCNLlFvUS/VglEtRmhqIFYPKQvLnTn//k73pxfgiGlF7EH9O8ppW088CZOwDo86h7mVKCqO56t8tn11hjwm81nywngIjqvWfC+Dv+6VvLWqLfGFBPCB9GDXFWN+VGGuAu1qa525ZPRWt7pzVFmDRB51UWfm0PXGjTy0WSNwDen/9mKwzimcmKRTeNxVYl/Tfwk9lATNYd+XLfGMO6u5z3eQKoOzJbj0Xo+oezt6rvXWcPuORuXVHXot3dozsayYae9XkKf65xqNVupT/lE45RuWdDBF7JncnGNunyylv36vzz6+vOXW++TfVdNNjqmLqY3zW+llqUBhfYtWXbfNwHAd24GIenS0ulLiZhf94osW6A7OTAGF1OpDxriNsnGdZUFEAbGalSiHoOMeOLk/RjNOtrM77yxnGT8W1GLBDZVzKCNPOZzHZv69A7ITa/qMLoa0er4zL44Rvd+AquNmbPGs6d1wwOEKAoWCHvy/lzW/aG6krfrZLLPP4kOaEe4ZkY3jmi89G1jkg1ZdvcP/Vp25tyj/KzgJLsF8O3Q/6XBueyvvvDb+TBEmsM72+XkTl4dmOHtuAXegxvwj+7SpBpemun0nlp88+wX6y52LVv84Pqdg8nomzkQ4E6GGBKD1VD4HU3t8dAb6uz/YBcGDC3+05HuOloWH+jNfouGLYeXw9VV/DNegfg3P/fmowmI3acvstz//bzIhn3tw7VIuD8/R1jbyogQMiYVpS6AN+ZkCauv1g20TemBLXxKBhaOQeY9YP7N1nzOYgBN+7i7lncFxJTn4VmVXivAWeuQjPSEZWjXIFlscTs2yLz+W9s5pQWdbqfUn79YVQfIBfBmX92H2+rjlkyPfjgN06bOvFonkBaQ59gdbjTEo67MN+Sie31I2//xe3P/5cWV1i+KNkUDLyu3GV6FKGkhsp71jn9lln3zN2bZS45H7XVRorMA8V08Q341YP1yNnlpSdW/5GaIeCk4gKgad2nlul1tSpJzHUbgw0Ha6547r0a9XR/ev2Sm/JSbfcQ6vew8Lud01ZW2ar9aW5AKdqisQzQuaKEERbqpOcSfJ+8zzr1NucZ8HtmzF4Ks+b5hkPvF+f/yieyet/9ytgBQtTgBbsJJa489/KH8ycUHH5kZrhz7Wt5U/zqcNGNopmervLDOL3sAbACajqnhe6GvBqeUf3Hcqj7P6+9P/8wPzz0m/debZMNg/eSr25PJl3EyzZ1cT3dlUF1/J0VnXFp6ZgU62MZGQhu5wmElscKnY3NMB/whL6tlXuT/g5/90aOfNsb08aLygP/zeFEN+rkOln9d+Rt//tyB+WJmplcDyoADsXjK0xqOqqrfW8WPGw8rxaN2zo4AmLJqpsemrJrf+5bcwVpkJCAnue5QJxRBp/M5j/i47y6lU+U4OY/0qBxsIyqt626X7Fb58spKdvDAgczlpCvmVV1t6k9j6fc2dKnNk8uIR7waV6xTNO9T9Ac/duD1q+vZzzAJLbiOq+YCBJ/6WH6+/e4s++APAK5sFmomnj0b8ImuZ5CneJFM+c2aNOwrLvR1DMbdKBXb6dUy9EW2Cei58EluzNhUt2WKbVNZx1fqFC2+VtkhnlAIbLdKTte3/mOfzF77y/8335tO9vgdd2VPPLSYT975gWfuYNvgt4FVhwSyALOwzZKOiFNBEaRybot5zYDH/kAxOyOIKtVtxakx1Rm+c1+YLbOnf/otB8+K91qSfnTlqfb6SX4q82va7fwU//RnLbJFqQBUyuPc+qPfpm7xOU2H0WgMkjNaXfcxiQbPw525sw8tvuHueK+kq0j5C9QDV3xxXqDj3JFh6WjKz5zNZp9avmRTf4tf4OWwKfuHdohnj4Mh00Zfm6TK8vKlViummQEspY4EYjPIUB70g6zaFoCi4SDPl6G7nOjS53r7yKk8Xm+3tdDlbUgjfym7fLHV6s7yRjB2SdblPBfNzhDC1v7MoerSpUtT/f2ZhWo4uGTfhwWMGQ6WN3033C6pkL7RkHFgv2wwtdh94mSwz/vfileyov/GQwuvefJ89lFqVwdhhQ7xlHQqy37y+7Lse76BSSuawaRVlmgT1naAoX7VeTywZl08Sk2665/m8EiP+PQRvKBKSC7vudM9n+rZQlY8sdx2Zdd1Lbn6U5Kdrq8mTf3RrOu3pLUM7fwC5FUA1n+UQUvVppOPFSLnVf74kYRszPVSP/rTcqwuoZa3pU+69GtKviQOy/QZsHT99AdW7iXQ/RaVN29g8iXcEG2i28BQfM2ktd3Qq9CYpau8GgDS5/i+PM2yMFsMW3Z0tb/5zgnpxPnVCWw6jp9OxvroRyYL1S16Va563QdGhfZAC+CsNxzQxb2CyVl0rLItTVNQlOz8sV5Elnnb6v9cfMsx/jWl9GLwgH2ZXgwD3ckx3n//h9t3ff1/PLNc9Do8dszWBvwzUjp6lDU4Fc5nc/wCoeizsyWbszTdHM1mZ89VFzn0se/8tcxw7UI+B5BxRFYp+dnZo8icz4foEIv4VY5z51H7cOYobRl9Zei/YNPikewIdmlykC1HTc/a4LzZ6bokq2T1uSNVdt6M36DRr4/DiPUHO61z1PP/kewC/4UkT3g52Cx/aGz9AbqDY4xV9kjuN/7lwdecvdz5TRq3BmFZy6QdHzr4rd+VXXrzf54t2A5ozaAkecmuAPzHiHjl7SlN5cBWz6QSCDSpV1J7XDZi9GG6ayXOW1eNS+3hStV20Gh8Ulozxvyu2vu0zk0g6HF9WuY2vbUe1+H21CKmLm5zW6bytRmuVwLNsttpyhr8PgxFt8v1vmSXFwgrQFafAugjRL7aBb1OFK1IejpGKa7Hs8CzfV0j6eCol7u/un4N6SceuPT1PDv9emls5UV97nkbvTqYVQerg2wGhOH3raVSfMrVtydsMdCTbfgAOVlY8LOW6OKsWOnwm4eSc2M39G7wikf6BKTqO0S6waZOh6Ptpnr4nU5ekXd+t1Nyoe9gVbA72OU8oUVnv/JL4mZrbUvW//9+7i29Pwvt6fOF7AH7kr2QB7ibY1vkNwuydy/1ns7mO3PzJ/iH/JR1t7aq6WUjeVtMv7xyorqF55RPPfVUdguFZb2Tm51tOW+W3ZKtrZ7N5+Y1jaqd05Oz2/hnejYTzXWFdm4CrM8TtD0FvxLKSa5jbfUWdD1VLa/eUh2afyoX/0ZfTKzQ11eeyg8eaOWDtTyfmdMSdVl1W+2WyqaMD2+TrHRPshOsHp5tiVfj8P68/+ATp5+oNF4l8Sr9ym+Ov2J5pfsxigGE1ZN7T2Umff0UohLz6hc/9dH89zkv+r+eYU7VpC/LtFyq8gHWJU5yH6DJzCyG5qokb4No6q8ZxC8dnrzo7N4+rYuRiuoGJuSS2dRO/YoEg/oxcPRG74y66/Am5VGz6Zct/g1Tf0qb5Oo+xKd29ad26zNmpLyVLumzZMKUPKfIxkF+VRNwVTRLrshWev13gsX6NPdxAmD9sIdWI9S/ckXHslt1ydZ2WQT8U+9f/kYw76us320+FHUih7RS2HXsUTL/FNU1OnkHgbLyUA+Rs8oxj+q2tI1dMR396NG6tjZJBT2iYavpDVGt+gg06fEU6xEtRMnSfyW/eENUrHFsLG1LTrp52P2p9/zI3B+ontIL1wP1l/mFO8C9GNni4mIr+/J3dZ55Mssvn9cEsZQdOdTJLyxPbFLIstOYsZSdvut0tvTokpl08OjpqjM50xJPgvHDvAAAQABJREFU4D1V86r9NLwcan/hDLpOZReWl2qeDd4jh0Jblp2h/RTtZ/LV5XY+f+m2Krsj0IKODDuWKvXtSTaoz0nnlMUNw/NPtEfZkLLzLGWy7/L5pfzIodPIZ6bfxyNdsm3hyKlq6VGinktn8gsLm+3XeFcvdfJTdzBJ0w+7shnrEmMMY3NbLl3I8l/96Pgrl5cNhIlfG6negMUkdfHY4eE3fPzX+u+k/D382QTOZJUtEXHpl3j0ysvtAPBth5jso81XrlG8SpJV8rrINWkKWCqILsC4GlhKj1KtelrZ1Ac6vC/vRx3GtKkNNd34nJlG6Yvt8LqB/1Q46LS+a5pUqOjjcbs2G0w7jLLHuxSf1et82iAeaLJFSWX+t1STDICn/XhbLedjlpDkzg+zV/7mv1o9DebcLVZFmg6Atahl/uxXlZJwl/vCKUj682C1CdgC+PJlsMVvUaUXIDZQjUcuno2kduwzsA38DM9WsQMYi9N51L+S2aItz+yENkJNY/ymS89/NR6lrfqXvHh93MHmemx5dq6cO/A7P//GnDe0U3ohemDzN/CFOMI9GBMAXC6+Ph+9/y358DQ3/qez05MzyyxQ33Y6/D3+Ccsf/0N+COi2Z4rV7HQ5/PQnyjPLp4y++tlTk95tGXSOW8zWSpWzRz9D+3JxZvkzRe/xZ8iXC+ldMBl4509NVuc5zOqzT3GgVWa8L/ny2yZnFj5jbdhRPv6HnyhWP6sDr9ZKdlGXj4+y4uFHM/SfNn3DflY+ef4zFcvBE+k+ePQLlfruPX66UJvkJN97PCsWTp0qTn/56VJtGTqwYyx9ZvOrTiGvfjbsl81HVp8yPxy7NasWljOzX7qQn0hW9kEfv/1bup841Mv+Gpdqib/NaTrRl3/vdX/jLx/RThslTeT1o7TsJTz31WYhTfqKhv8DW24eeSZEaxL3PxOsZZtAEPMIGFT3XHIGKCJESTqmemIF8Jh9tRLnkbj0iKyPqToKpr+WE93UxTzQpjw1H9lG/1YJOmN51zPtDILbIxEl8UhGf5YoGA+5A62YXE5R7zku9jm9byZ6yEKZytTOWkbtljZ1Ekif+OT6d/JM9A5e5ZkQ4NqvXbKkK4gdU4HGT16zRgs3513oN0UUgLNhmqLorATzClDF73YEWbAOHn7CJOdHv5Bn7Zg/tSNHWW38nInxlPx8iev0dgYJTX/wcwq6+pFdWuQWr3QZPNIum8wW+sFgbgHFA91ttlz91XabHRzdjmbZIN28kE9N9mmcWiGnzcZpH0daayvfsfiBamOHZ3Bb+nyBeGD6b+4FMp59NowqX1zM8ocfzvJXv9rmqal9W9HU2KQ/zA+fvprz+JyOvur++8MttXSK7kpVf+ihh1of//h9xbvfHeje7rxux0PZQ60TD5+1uVH6peNd78oqyXkeZD9Cy/2Zyzkt2OS2fQQb7s8+8pGslG3idTtdzm3MsnfTz7uq17++Dgsy6Q/po4/efycHOPy/1E4bRVhLBMxd4gP/w+uzt4n2n31v9iCdfa8GLaM9d+/qpw/1g/LaFPRSHsnP18+Jp15yNHBBcgGLqkqxTtEMMNVe8xkTZbUxYU7ljM6H5OPkEarkxR+nWGdcFo/0i30ruhplcxydO+8VA6ChqUP6XYf3Y7RAno7Bbfc25WvAzDI3OWKSbw/0gx3qXzTleg1JSf0quZ822VF3/K//7eqPP/l0dhYc5VApoleLOGUdF19RpiJE9jgDqGAfw9bu5ymd4zAEd5ytDoDZxid+QktnUul3O03WDKjL9MAvgNW6abAol+iz7gPTMYAt+yYrQfpWwibe2w22gZnWn76V3Awq7sVmRddBr233lw77epvtG3pNG+EyUbFpNv2KgVQLeehL46FbbSZro4w9j2x9+zc/96O7/76zmZg+9swD9T+RPesvdbQrHmB6Yo64UrXTPb+Sgymz/g64vPN63pTZih7TVFZq6hPN+TwXrZG+oTrNpquPM52dthhjRFS8ln01n5ek89N/VX0I8Pk+SdUdbVJwlCfJm05fqlvPIK1dutoAdIRDJrSTV/LutGZZYt6msrc7qHij80zbaznVlabtNYPX1eY8VqbiEabqSs5bi075Rd8EjrWs2VYLuawpqj+8P29zftWvaINm9LpzPfe9yOtgI+I+9R2fGS31Lq/y0wDwVGctbwwQp3Qxkh76k+HbvvTU5BkAh5/BBPPQjx+m78uGTVa2jmv84rMCH9gRd7ttu3BOGIx2QLNtQO1A7/o297mh19u9L9Vlk+uxTuuP0MZvf1N3i4lmsREUFQ1iAOpawL7g2sS1oZPgmw1ZQVo2yh/eN/+i/uxn33rgUy6d8pvfA/a1vPmH8WIfgYNd0w9O97zZrrra4nYve96U2Yoe01Ru1l2H0z13epT/Ub5EQPA6plnlCg5ely3pEPsgo8nUZ90pGMKmWVl/Pt973XMBrmR13OLnWaL+AkvUWkIVsLgM4pZcJu5HNCWBpP2pbJQNedfjct5ubJsqyMDkJOVMwtOkov5iPV52pqYNoosmIWVM2tOkoleNpa64DmdU2xUJopacdUKWdjXrtaRj3MDEP9ggdS6rPC6rYnUn1u2qasxEkXqSUPCTlrZMDOjokmyU87aWd3XS1AQ79KOetswrPsmJpjaV9ad2INB4nA6e1TztsLQsfpZ7Az8ZMupTufWv5ev6L+gL/Ze6PYAHCdPvfXo/pgc5/IFdhenIW21+XCzYJTnXK10c2WH2S25Stusx88vadd+cDFa4PdZXK3v1T7535StwXUovEA+wVSWl5IF95oFPAsL3VgLh+7LPUo6SIhkDGmiaNT0ZoFEXySM7tXn9JE/RTvCnKE5LqHqd5kl26Wr2V1ucHFBcvfcnHm+L+b0P53O5mEflmC7epq64/WqyrsvlXZfRayWxb5p6xS+AvhqP9y9Z8WpVQaCrJWfJuU7lskMpLls9Iji/03WN7K/T0rNTgY89mCVKFCC2FC2GyJHXhqiDVnrvO6gh8mUMtlzN94FlY38tSbGnEm/2tigrQja9JqfDOmznMbqkx+pkjEeryEG3fKMke+C3oVnZhskRdDxelke06mzL3+iMZNSf/EU/WksPyvRznx75Oq/65XmvRcXqTzuilegLzA22xHJqM9l2ds9PPrB6ZzGce+gf/HjO7WRKN7MHEgDfzFfvhWy7QDjLPtQcogDTwVbAoClOs6QmJwPeqOyTnefSdZj3VPXHRGfPifUc03UoItYxjDo56xBL1WrjiERL3qfzxrkYrH/lxr3xYbZtQRdHk3dDKpS83XU025t152/Sm3Xp0/g9xfpV1i8ZKQ/LtsGv+oEGibgvY5lI1RU83kecG/BKl4h1NKnVWKJFItQC8CXq1dqrLdGKySJTjp5p2zK1AlHZL4xWUXysjxiasXEK02ogrjPTEHSI35L6crt11BYvFIKI9ZtJOucGLQSu9kwYRGTYvK8r3S6vZXJFt9Zf3UOd6Tkyz6U3LVMjO7UPObrGZj1b5h3jYLONxjRInpuOcLY0/YgoYG6zlF2x/E3q592Vb/+xB575i194y7HP1N2m7Cb0QALgm/CiJZMDKExBRJMlU5qDoPyzFVDEfhN4LxDN+SRsOR8s+2UDIuNLALFoAuFjgE/zTGTrI1ZI2XXF5K1ocfu1lLfTEdNV1kwd51vpdp64zfXo3V6tDug57xwzg56Ve3KeZr6Vvk0yCPiNkeh+XVwPwMkqNFEw+FNNcH5bICwhQV44OKMlwCoAQxJLu4owBX78Ulgo8z2wV4dKfgfUnrPqcA2AXMApvNTGq1L8QLXgOjzD1SuCNejpmSuQb3q1XIwBAlZuBFjLlikCdX7dRCAvfXnbDtlolRMicfpCnH3ZWMVJOnyiH7BWKM/gOBYryHB5iqCDLWXSwuqLbhy00VsHe2jsYX+Won31BBuHygHm2C9L9Rq0cFwy8nun6r7ix/7hxdtnur3P7tT516hNaQ89kAB4D52dutoBD2h9ThNUI1nEwqRlM2TcFiFEVDSOJq+AVn/arKWd1Mr1pxQDsGiKDuMzpqVbSTqb/VjDNXw8XzlX7ePx3Olx3mzTTYzGo5sOAbCM1yEnWmp+vsnw0x2CEq9brnqkmLdveM6pl2+0DtwB6wKQcT05V1ygY9EfAKvtwFin3xGqOsIwIRGgChaLt8LoHIjNtd6rFtrLdilANggEXwWQ9GXwtwGyQKGAGohTfyz7WmKrNVoBdh1UxbtGBtZhQ5WWxHVDYPbBz0NsdBqjmuy0LIwCKQFni3LJFblKh76nROGhHYtBeV6p0kBlKL/3hC0as5asQz/k0GQUi97KjF4UoDXjREFvOJzc+473XX4Fg/3cXP/i+cU3v0QviKV0E3ggAfBNcJGSiRseqAgUNEF5mgIvU5TKWyWRNYPFE/9WfKKJV1Gv/pS0ThmrFVAtcdKTdGl52nlneT7qMtfSjymPPtzGiLRtscnbrG8rGDW4357kiAeLuGibYQxaeu+DBdeaNNZm/34dBLh6tqlcf0rKVHaedqvL81/2WQFSsBLYsuoL5BmsGje4CWTaGRparQWYFDAqsOyArroRCsvARJe0ESUC0GB6W8u8lZ3cFc4G10PhikCXtWbAUFGnwBLgq0ZE3q2c31NShImUImrrxwBXY2CDFNGuwL3Fa8Vl2QF89dpTwc90VhUnU2qUtmytyFZYqiS7J3yBpFcYbi9TaenZHnALabWbWm3BHmSJuBmC+GmTnzSOQFO/uDrcYOAExms3JQXmsZzeyvswvGZ1cCj7iQfWzuPH88Ph8PzqZw9d/pVfyfnWprQfPZAAeD9elWTTVT0QT+AqK2mi13JhM3l7k75dvVY3bZ4+A4aiNoHU7bzqpKVanb6lSFkbuug+e9lxwKv+F6V+tWtY/E2AmiqvC8/aDkM8DtkRyzRtltq4ve7GfgxBu8HF7/q0sUrL8Yp4NdamLgNKiE2661S+VZvrV+5lB13Pja6HvaypApI84yWipWYgJ8joCPBE7xDr6c7LwJfrPAnHOHI4q9oFomZHPrGlYSGggFTLxnppN5RVr78nwjw00q+1gWC0ICB5+oIs/bU3anndiXXG8HOBwTMAGxmdWS3AbgPu2GdJdJV5CGx6+OFELVV3OtruLeCnj1o/dnPzYRdramNtk9kmwNVZIiw20wf2Sq8GNpEdrAOw8o0CC575qc8K+2nUg+zDLFsvMPa7F15zKX/7L1xazjudMc693O1MBsWoO2gdHaz//BtPpBO25LAbmOrp4gZakLpOHniOHtg0gdeymsyd/hzVXRO7pj1P+sEBbeRSUiSmwyn07Dj+7WG9d2wHVjAlCuT4DWdbstb7szoTOU6uW7Onlze1N4jb8dnsWwtKRM9ydZMw1PIyuSZ5PdeVDZ58HF5v5g6eMd38jK6GWVMWvxbxDZFknC5GtRlNq79Vf1yM9SxU4MfzTcCGZ6kEhlrphbc10IEXOcuuZTjoIgCu7UQWkMIjwESOVVrAtxwK6ADRPo+Vhy1+PCF0KUBjxmMrF9qJF8s2uESUim+UtKzL42j6Qr/hKHKSNd9N8g7L3OpzhFxP0TL6dDNQsnTeAYwFrMEr0sNKcg20haJ7/V4D/PhAwy6LsQBeyWyzflVWt66HU9h55os/0MXqs43HInH4eFOJFej+SG6aDMFokoN7Gz9KDmUt+oHemuM9J+TzhaLki8jNwOTiTP4Tv7hO3F5c6M20znZnZp9ZfEOuI1ZS2kMPJADeQ2enrq7fAwIRZp5NyQABiib1OGlWclbnaQJKzNOUVV3yBhSuqKapTUnz8yHNoTWoOdtxXm3SSuM6E+CanrECEvqNOf3gvSJoT9p1reQ/8ecg7nq2ss/bguTGp9MVlUuvR1XSIdBXlKul8u2Sy8ftPvbYDgPSiCluU1mp6WfVY9r0emj5NB+VFsWVY373Xgu3+DzgEte0qrqsM7Myq8iR7U9spiJq7HRmWDoHLG11GmADiSRTokM/LWTPXieDrN3tmBukR7pt3xOrv15nHxfL1brMHYB4wHdLz2uFs1pT7tjaMv21OrwArZssbaQSuGN0PqnLGMx6dAc57G+FkWltGWOnYxkbyhMV8z0QyuY8POY3h9URMXUX32ggNLfGQLQi+w5vM2/4QwE436ew2Qw+bOCeRX7Ar8C6PYcW0NPnWOPQDYhuTiSE3VR0xofdgOiOQjLDMTc2rc5CuVocGgxXXvZj/+DCo7/wd448ioUp7ZEHEgDvkaNTNzvjAS35Kflk7gAhmk/qKitpIvfk/F73POZxmvKYvpVsDDqxnJe1Qes2zqj2pEhUv4ergyw86XUfHQzSTBrjcSJVRaeyQ32JV+cvO6ja5loatLN3HlC9JepLMtIxx3NsbajSMvhWp4M1+92yXjsi9of43C7lcVtcNj4Ifl38WnmudszT9mYeZBKKRr5Rm4BxMp7YdqYu6DqmHdjKQGT6HLNkTqTHsmsPMBtDb3GaR07kx3Yte4La7XKgOSBdKLJuA1Z0MCaXjUJGQMiAXtG1ASH8SsgAn52yp8fEJMBXh29UbV4D1mhbtkw9aXVn+iVo12IA9jC30+20BIq6x+HGrBrDq3IBf7sbHmYQr0LTtEsrvxiiKJkyQ+2UnTbHTNMGnSCeiFv3EdxwaGzcoLEZq5KmXGPoGF/I5ZcZ8wE+Y7w9e8ZMF3xxeeStDdkCWoG3+Uv9y29Vu1+2ifglLzvZxHXq7b+wcvjQ5fmHFxdtvRtqSrvpgQTAu+ndpHvHPaAg11ZwNTVqElUPfMSTukh1s4q7kqzf56BZgBzvmpaootK7j4Tdx1oiFsgKWAWying8qajf4l0hslXS+FlytdwAtvGvWDu2413bJvQ8PyIzrtCwXZvfsNg1QUrjMSSzj1pNfYFabKcCCLVXCaAi+mOcwqUs77I7WOu03aJi51vRHwNIXQOSlpYVukAGOgDvrBiPsz718WQMjHVZVYW33QXV4QBkOwV6gRj05S3JwS/EKfi97Ha/m09G46rbhQaxbMFTdQF+6sgLeCWiwLULxpfo1TPgvOyyA4uxCRT11hG82MniNMPV0i9tuk4Fshl22TUzUIaGHerfaIq00RGAWNucQXlk2Y5NuM76vOJhYFdjalVjxoQPGE6BvS1MVK4xj7BXgb9dExmMI1vQFQV3kAtbwSFXRNY2fg4rQX9VyNgxYNylTB9ZMXNp5sI9i4sf/4vFxdcp5k9pFz3Q+Ke7iz0l1ckDO+EBZhjFJTaX20eo26Rf19WNTUQ70d8u61BErD/9nu7VkgBVPL4CcDXe/dKma6Lr4DY7MNu1qS9Qu8+9xqQzYcWU9107LJkCKhVrBfr9AaEUB4OTgGhWUcG+kZ5SCmYmIyJeCERz2hzFbmRWngmAyxGrwYBvMSJ6FBgD78YH0rFQ3apGRIF8fYCWTg95jKJv5EJfkmFLdt7pcTbmaMxKLhzQ2EPNwvRYv1fIaq8WqdGP3mLcAdtAQrvLCIPCPH5CCaBEtpwAatiTV2PhbdbhxkImyzFtdOimq0toPS7DeErZjRx8tGmzl+zhdqRHPwLMCY99+Z7rJiFvYx/tkiXpZiHrz1Afj7g/CTr1bpXGPxmNGAvjpW5L3FqRLse2JK/+GLP5VTydTqe7NvfaW+E8I8Up7Z4HEgDvnm+T5l3ywKaJnD6muBvmv13q9cardSC78ZY8NwvsevlFqnNdKisKRdrrHIzc5RCNca7gTAlwDEAHWmnDsULj0WTEGzcBdAVGgC2cAk4efbKhmOeqFVEtADYCbAVcgBrgB2wZ+AGrdDs2oArgzVNb65BosD2ijSi5DtcFZoAw53f0APFVgS3L/USiAKDAjaX/qhwGEO4Sshso2+0Gz3OJgvUIVsAmyNXNRVnMsYw9YgE59CkdgyFL1JYHwFS7ngMH23VwFjckqNCz5dGkC29PNwtyD0H8iDER/nIjAjybj0THR1mXHX+DgdvGvYFuQnh/mr8gjC/thgPHBt+apEXQZmNrnk1fq8ff9t7H1t739jt46S6l3fJAAuDd8mzSu3seYBoJT+ci8KW3enbZvX6T5mv2QHwtrFwTFLx6m3Le5CUC5j9FwKzdahOalmgBQluO9g4FRmxS5qwrgElLpkUA4qwnLTwZHg4BLO3UYil1AuiFyBnsrYA1MJ7noBZBAszqYzQa6skqz2oFcoBYHQEboLPSULBBmE3PPDUdEj3y9LgNoNETEafeDLLl4y5bqDlCJF9nm7n0Z6Muj1EJTAHe0WhUtNs9dAN2RNvQWdYmcKevDnRbGgYQpUt7qNnJzEAARPrQy8jSVxEBM2YiXqJm7AUcaa6XlzFROosi2F9wY6IlZd53ahVD+sDOTDcoE0W/RMZE0NyWmO/k0xH/tfGhbnqCTsaEb+iTp8PDCs9kM+XJkx/+cHXp9a+3rWMSS2mHPZAAeIcdmtTtrgc03erZok1UlFVPaX95QEGkonVdG4+5dM1E8BsnWay2iqCTyHTC499qItDJe2x4ZrVZO7M6faQA1o5QFvjQ7xWRWl12J4O/ABuxph6XAnh6MSjvsfw8tH7bnTlO6xBgEWXm85w4PdQuY86rEEbRLTvThkSg2Jn3QOQCMLLfL4KfTcRVnwNJ2JtOlDpiWVfPByr4AbJ+6Jdn9digSBT4EohraZcAW79NzD4sLTsjIQ8A3kar7NUqnk3nY72ShB0hbKU/dIU+YCfJbklqDLbkjJ42S8vqn0M/CPTnUD1mvN2y2x3xehY7sLUEj5+QVeyObAB0bQNrdUY6I0zvB1ddjRX72I9QDblQ3a7OGwWhkeHuJmfXuOnSw992Z1h98vExb7dnT/GX0i54IAHwLjh1r1V+7pHqXnZvHL7n7vyhve57r/uzGZhObaWwrijThOVte21T6m+zB3zzlVMNfFWpL5CgwW+iFPCyCWmiTWWlvcsFgOZ9+41CPTqdFIAqO3knkx4R7BCQ6Vfj0dA0CdjYbQygIWKPSgWOQBsxZAdeIl7jLyYD8qxiZRZ9OjBKxgwBcvWpYzjD7meOuxIqarUZgOzDOwwgC3jrPbNWV7bRH0Ltbh8e3TAA7NgnUFMfZdln17T6GfIsFSybzOj1Ke4a9C74EDrATZlXmoy/32enNsg6tj4EvlneZ3c1VmXVYJDxWNzGKh1mHDavDwdlB3ox3vBD1tKOb+xUmE6SHRqj/IN/9c+DjXt92+gnP9rNiG4gkOngU4u4ucehnvdn+3azoT7H2fDg295bLb/v7Xn9wpw0pbRTHkgAvFOevAF6/uKR6jT/PB9kU8l9+lf62UerJV72fx1AvHQDzNmTLh1op5M6vYoWppg9MSF18iweiK+FrlNcd9EpDUjiOCfWlGdaEwMsQZ82/Wb5+mSogzKqcU44OuTdVoT1DFU7htrdGR0UmVeAMdEfYMd7ueS8MWxdVAWACYiNh4O8c4CIk81b4xn0WGxJhf9ZqSb2luzAZNtqHwwKwuNsvBbhjdHXASpOXubExxYPmlutdUL0GX71sMdzXWwA2JUPUNzi5yWqNsA7GrD/eNDqTAibZYssQ1eHcbG9WfL2HFi3AbzXzFjBXHQTIcMIgFLWdvhgZ7/qdZAjWAWI6aPHjuuhwe2A19M6B9arDmd2yAczspd/FbppGbO03e4SGfPOL9BtY5CtelguvcZJeYCcbMsGZbZSDOwa4OqW9HXbq3pzPXIItZR2xAMJgHfEjXuvRFEvs83H+ad6WMt9ultlsjvNxo8HseZ1e2/R3vWoydsAmJz/QzSFD1LaHx7QpdB1UXKgnV6zQJ5+8noqMSvvo4IRPeZ4PRatql6rNw/OTHo8N13PZ9l4NOn1eeV2negRVOixoiyQHmmpt8jFO57M0rbGyu9stW5QsabXmfI52jh+hJelFXUSkQLsHd5smnBghn5NATxl2XqOaBmhEb9hAKSpv4xVa+mZndWRZzyOZu25rNZbq6M11plnbenabLbgmc1RrTVecZrlgTD/FrtrVTGiTv88PS168+G3EUwfutdH2s4u3YyL8cm+4WStGo7oiwe53XLNvs2deRhIvJHLoNdaQ8YoHFSjnufOzvb0dlTW4/UjNj5XPYm31nMO8jK5slznHWgtu/P8m1z9aJzd3ho+mK0KDGrZ+NBh45CfeQJAf+1AZ3PcOvcAw86PPFD13/8Wwv2UdtQDCYB31J17o+wRIl/2QP4/gNBh+5dKtwIkA6Usu+/zj1X3veKO/KG9sWbve9E46xsOzSobs72KIujPHUPxeaWmjmY9VrpdW0yPy8g6IHkeq5uWGzKiX5V/KtgobKGnwbGjVXXXTLpmbrtyS9BmOnY48XgeKFm1l1Xnsvl59u3q0JEe4MESbTVggzMA2l7t87y1pKnPcm6Zgw0Ec/2szc5nAsKqN+rnIwC6Db6NCCOLAl0K8VZDVDyLPlRkHQ7e6uRz9LeWzUzmWN8uOZ6zry6zfHW9tTIoq3ktOQNE6lv0XpcbgdbshFOf9e3LRmy04keQWl2eXas9RKxlNq/v3YQol3wMyB8Et8eDtXzUm6vQl6E7P8yQAMx8ZbCG3jzvjgmYOaZsRN7r9vNVFDJcbfPOwGpAfV03FgUHdGbj7gz8RKWMd8y4xcj4s0G+xtGj8zmHg2BQGG+Jj4qcGxNsbfPjjKPxCuNi3AX94qcZ7j448sNskZ6RTg7Re2HFGrYxFmhF3jdbJpMzMikBME7YyZQAeCe9uUe6OLnmXfz7Pu3d1cBrAGyTW57dS9tD3v5Cy30C9wk9Hp9N9BA0DyptxRPT4rKA27BKwq4g0uG8ypUcVKwCLa437XB9rkPtSlfI1HpCo31OP0yWmuvYZK8Zrkb+ItslvAXJdKhNyW3ZpA/6dJzGpI+QpvRGP2pVW9wel32s3p/a2KhbtSdaEAVIiND6PPcdXDKTBRIyneVRJDhbW6DFYRhVX2/d6Od0wRoCTTvAmO1aetZZFOtBu3Rp5CUrxYo2RyMCXvRpwhtMZrGcEyrY5wtw2yjsrGx42J5UlmvYAPANATodgTnbO1CN1qv8MjLDUVUd5JhRglTpYF+T7Aage9iCvMahpLps0a8d9Hqc6YxOXRcC3eoy49EY2mOiUO2QBky1wGu2oXcWWd4iMrvkgxE28Wzb+u739AOE6IBPfVw+C/RDm6WP0To3Kixt+3jHazP5/IGylI9kq3gGo8p4QVnzq05os4R/Pa1fLrKjx8pqcCmyZXK4vbhYtRYXtW6Q0k55IAHwTnlyj/R84YvVd/NP+fub3YV/roHKfPNVzfYXSl2zkjZgaWrWZpYwRW/UFRlzx28pbjP/SI4Wm9kCy5TP2tVQ63Z/NnWorjblXpYS5/M20UydOlSZyjRqj3R4W6zPdZkgH6rrMYMlU7rRn2hqj/u1QUJ3mnKlWG9Ma9LjusnVslMTKIhHf7U5YrP+XK/q1l7zel25ksv3211+hkE/ZwGQzCzo2GKeXV5iI1JVrQ0AKnLwinyhujy6mB0+nOeXAAvWRllpbbUEegcXyvIctNk+zzRn2EO9zHakvhaHLtnrPwLvCW1rK/ByFVTu82x0/mSen19eKOcGF/P8EK/tzrI9iT4Pn1zILtHJ3ALnJVNvty/WNvA8FVt0KpkGLptk90z/kulp55f4RoakV476gHW2cDhbA8n6sxoxx4PyDHeIDnZKZ06zdWRsHGKXxtOePcSBkpfkWh2iZXwztE00Dmj2SpN00EbAuok2nCyU873ldofXmvXzEGvjoPPQIU5T06tOaJ1n47N8GMYQ7JKPeJqVZQsXs4XZW20tQja021yT2palbIm1BT09T2mnPJAAeKc8uUd6AN8ftUlOk5/9E2Uy875VgDatO/0FlOuABI1bf/XUYaNzX3jebPO6t0sopk3LovPnYCk+pWeTE4906M9vDEyGussq15/zSUZpWqdNnTuP2lwWsiXxOq0mTeVjObVtxesy3h7XnRbrn+qoDfA+PBfZy01drk86PIlXvlVSmYXRojMsitW1sjp4jPOunzmXzcwd5ynwuXz5Qr3mCX04Osfi6fGqvHwu7wxb+cFZbsO0z3n2eLZ+6TyPSMtqSNCrX346Dm20ftZ67bEMvIInEMlZcc5G6D6Ibp5+5k8vldUMK9CF9jED2rLp4OzR6umlYEMxPN8aojfnbSBdmtHwRDZcO6dilmFTfulsNZjN8+UnRDiX9ed4u5dUnDhaDlbO0eHxKrt0Fp15fk5v+pBmsCVHzwA9ObYcmD2XnzP6cW2oZuH7bNYbMcbO8XJt9WzO6rXxLcM3zyB4pFxqTPLN8WN6Q+gc/2E3+kcAbAd59qsVkoOML/jg79yTqtE/Y1l++gQ2nctX1o+zh40QOjuRtY+ebxXns3LwxCSXT/TsvNfi9C783msdt15Y0GebmCJ528lm+tLH9XkgAfD1+W9PpfVsl0joPuuUf142+VEJMwJ1CtNb8D21bG878wndxs2HIuJphNgwxWZE+wgNU1l3GmQHGWuDzk7yK5LanM8bjZ9KmOqcupE7v6Z2gbL4XGaDK5SmbfV4ZJ7Jey5ClLbS06S5TuWbQI96kzdSvWWb2VMzNX3qslOdYojsVf9xcrv0BT7Q600uZ8ujI7eezueOZNVC9zjcZ7JHHsuyU3ecQuyMia4us//40Bl+mACQXW/nl9dvm16lI4fWWBc9Zcu4Yh4fOqMl3kwyYzZc9bunADb03KrWM9nckVOV3n7NWFO+fH4pP33X6ezShSxfoP9LF87knTn1JeuO6n6vopxfWF6qTt91Ilt69Hh2xOosnR/FXs6Hzm4NNkrlheVJdWS4Zv3rzIwLyyeqtfUlWk5np+/KkKdk+XHuB5aytfXTtBGdUl69pCfHgDDRquxc05jmlqgP8rP4Y+EOcB/bZeud92TV0qNL2HI6X4D3ImMdZbeVbtuRW8+YrjFysm5+AV2ksB1sKTt58nT2NLYcOXQCPjgmWXHsrqPoXIEH2+zB9vHCbQbKZZeQ1y6fdKV0/R54MczX1++lfaKBg97fZabwT0b/Cvh/U/I6+elNDS/Aik3q9YAdfAUyUxBgzOLZ6gsunphP7hGIK4luvkXW+KBZX1Husk43vkhnXFdZfMp96dz7Ub5V0rDsry54P84rXUreT6iFupfj3Pndjqac8zqf1z3//9l7t6DNrrPOb7+H79Bft6SWD5Jlt+yWEQZsAuYQMpUKg6DI3VRBLpiL3ODUVJiqHDCegA0zqahdSU0xwGBsEqaYUIOZS8/NzE2qElKgpIaBC4TNzFgmII9adlutk9XdUn/H95T/73nWf+/1vv12S5aF+/u69+r+9lrrWc9pPWvt59lr7cOLXfU/UuBU8s3TuNFU+lvLoezxoRx90uBs68Hc88356edfbSbPHT052z3dTC+dO3f00n3nJvcJdt+r5OcmV7740OHnX316cunVV2dXmivT8woZ/G0+B8256eZDetpYZXLTNA89NKFt9y+e1N+5KfDP6695tpk+98cKOK+I5qHzM+rIeuLZJwIn6RK2+0Xp8H3NZPM54Z1Pmbt/IbmSAz36Wh4ywEPmpT8+d3Tp1afUN2jOB/5zf/zk7KLqyEPXi83F6fkfSV67Xzw/uf87z03v303a7JP61pyfw4s25FjX1OX8dPe0+iZ5f9k8dIQs7HixeUL9fSHg98mOH9Lf5nNNyA47lT6jC/qDC2/6jz3gQxs0na7gPTn92387pmbTp7fGApzifToBFnjm8uIxPfHxh97erFVedYKqX3zk3YNHapw7pfynX1p8Vn35afcnJnCZxTj2d2lrkN/oJbWOXuVVGwXCysH45CTTkNdltxu/xg1CHeq2W8Hc5ty8LQ/4urJh5E41zHzctpqv6md88wC/5u268cxvlQ/wr2lXcx0ec5dUt422m0e+7xG5+QK3/JTNgkvv/eq4qgv4Tuvaa1hXzq1TveekfV1TpwzXEncZRhtwUkeXdY43bxssyoNLvFu1hhYlCuPCp+Pf6XDhwicHjz/+OD8n2KbUs62GDnW7Wy5caAb664SowbSZd3JMsz6vdYWmT2+FBaohfSvY9Tz+uizwzHOLP9QJ9hgnjRMnHHX+bgjMh839jzwyuGrcOyUnAKvfP13bwWXs4QBsGHZh5VXbhzZwSbZh1jrntK5e09HuumUBszzKJMsBxzqYLjESBx2Na7jpzb+mq8vGX+0L8BrPfMy3lmc8cpfN13XnpqNuXi6TX3qx62vNg7UTZjcfyMeNAvB3DS4ar897C9xNFli3Q3c39f9E9FWr3/Nyeo/ZyeEA+bMjs0Nc6sxW85Gl+h1S8VYo3aH/tU3qLq7aqA5wtb1sQ9PWbcDqOgG0TpZR5zW/gBcebJNHW82glIGv8qYJOH9OtS512e3BnwhXpRov9FG7ZZm/ZWAjJ8Oog1/zqdtor+uBJxncPHVb2+7+WMeqb4ndH3sL3F0WWHEpd1fnT0pv5QAfx7GtOsJVh+r2Av+Jk9K/b0RPnDmBghz/HQ6/MGgd/QrctluVY/sZbl6rcLfD3zhLMFUcU4JWdY9F11AoqnE0L/JadzCBwcNl58araRMrdfCFBu3636baVg60qzyQ5z4GfWFgmXX7Ep6k1LwsN+6ru9JqogJjh0J96i1wl1ugD8DHfAKw+tVTuR+xmqyk+LODtX+LB5Hk1Oz41f4Y941Ndyfm9H314Sn6iW0iQLjTxeHXTj8CRoE7IJm2DfCl3WzIzSPoVUcHobUXA7RHvaINmOrWS+iRat0Ncw5NrQdwYJZLvS6rKeQ6SIJbR2CvwKHzHKFMCtySL/GEhxIwdEFfyuAv/QlntY5d+EOpaKMcgABR61NvgbveAn0APuZTYKTVbwRc6Vn8VzhByuFsyVXBMVLH4VGmvX1qWuU7NdFPdTkSjj4LCaMaAaOAKTs56EIT9iptwIOmwI1vWsto6Y1QcrcbXNdDlhrI6zK4UZcO5FHXwTKdZ0tHbz7AY+hFa72M69x8qbsc9Ea4RQ4eOlTmW6kkcasn/UOOeRbakFeAS+3G6/PeAneZBfoAfIwH/Jkrce/3J8P5Fe9nJ+dcAbpNASvOrtA89tWX7rxVsJ23HTymMQxjxEqtWCWCB+1C8F9pChrb0W3UKZPq3OVsufFoOuc1fY0deuqAzvw5mS5yAaNdB8ONR+5VLmXr5dUp+E6rwdi4tLtsdOr+q9vNi3xJl2Ijt5u2xoG30VbzoDPQTPq8t8BdZoHKfd9lPT8B3R1NmsfkwfTxvVS23jo0jJYluOq0tX9NeXc4WZz4I6YIcxTnTeCJYqm73w4IdJgm28s5TMBxcpncOOZVR0q3mc55yFPFNObndnLDwLHe5ue2wC96BU+V3baubr7mg22qbgW7dQfzqtusew2jbPneHQAWuBRKYg7WFwYogR5BG4UsQ2d+gPWTt33qLXDXWqAPwMd46PU6azx8ZcdITnLdZTs0w5fwmuax515a/FwQ3gGH1qkXW9Al+g88nH4UuiAKeF0K8ooHNrMd6zzK8C98yfkzfgFne2lDnseilm2aGkYZfg5eNW/jmY6cBA7JMtwOjMBuO8CzTjW9ac0LPNhTNyzKwCvbgEeiLWS5zD3i8nBctBc4ZVJReYk38PjpWgp96i1wF1pg5RS9Cy1wTLt8ma3jQXPeTjMespKudpw4S7afyX0PmHKN77qc3+OXtZ2t5jsihTPXgf45WNAx4K7XOeX6D9xIFZy6bRdtYu565KoHT4QqUQ544UGZv8BRO2guk/vPtHVOud4urulqPMOBWZb5uk6bk9vqepSLnuZHDr0DKjjUIxXdKVuG6YyzmotkKdV12Jr1ElJf6S1wF1qgD8DHddD1sQkHXXKcmJ3XqsOjbly6s+rg1HZWH8D73ePa1TejF/YgYNB399f5aoCAf+AVBLdbru1Zw0F1PXIEkorMKBoGWOUa38HMMPBJlpW1jsb1Ol/CLbobZr6u13Qug0P7DbiV3jWuy+Q30BSY5ZlvjdeWhVvUhVWbaEc0f7V9W4S+0FvgLrNAH4CP6YDLQf0kXsqBlXxQRivK1MtfdEFl4wNn+zHaAWfbY899/eRvRa9dKaqPOHcH5LBHgdVlcMIWN2kDd127eThvAw12vUkK269pN+1NyJbAS7hELaWAVXyN4zyxumMNp1zX3dcO+8ZSjU+r684NW63HBUjR2Vw9l4PGwD7vLXAXW6APwMdw8J97eUHw5QdNM4iqEA5ddd/Xs/Nsc9qMVxx00FRl/Vja43qyWj/6eYJTuc9YO3x6476uwld7+s221/xuxYu2W7XXfL7h8kpguxW958c6XdbBbsXrjbahXvDW3CNv/wrcdfj1D2FhhT7drRboA/AxHHm9v3vDV6zsSCPQSOe67pVFtFVB2HW6GPgK6qfnJ/yp6LKy97DZmTs3vM/TAtjlW508N2vZ/fh8q0ehl3cSLNAH4OM4SvqKlYOnc9SMchSWlTYOi92y4I0cOClWxuQabS0gf+6kP5BVO3b657pzYH26/RZYHQ/qhkX59qvYa9Bb4LZaoA/At9X8Nwp/8criwwqY5x1s6zxWul7hijQCawmyEWwp017Y4uRcNpwgrP8fKSgnL6u2oKPPVV9PXmfuTI3r94X9MFrdUwfheBqrbujLvQXuMgv0AfiYDbgC5mOoROCsg68DaQtXIdqdr+DDwAG6vm8c9Ivmo8g46al+77QOxie9X3eC/l7hMt8Iwut2wtfB7oS+933oLfBGLdAH4DdqqW8RnhzWjywFVjwYSTkOKwKNChFUBaPZ+CC4HO8I0w6Ckj9ZWdrPstLOlpN5xBb8Oa1babmtz7+1FvC4lKmXc1QqtEHZDd9atXppvQWOnQX6AHzMhkSvGp13EHXwJNjis2ILmlx1nJnrxqvpaDecLroODPrhqDmRARjnTl9W0+v59NoWdXmVz1tdfzOy3gzNW623+b0ZXeqxYKza4VIDbYbVeJbX570F7iYLjO+mzp6Qvn7YwbLWd9URuh4rYSFSd2Bym3Pzoe77c4PFyQzA4c2ry0Y793Ds7uia3LahqS6vQX1LQW9G1puheUuVrpi9GV3YjeDiMGgZGKUbysDUVpoDZ/XwV19dPKYL0o/q9bmlV+f0GED8+lOdMy90URlPGQJ38lQxjPoSneqGmaa9YpByN7RV+HVbXVanrmrH6WOPPDS42PLsC70F1ligD8BrjHK7QFf0uUicEkG1DZQ4Kf3ZEZJ7BWwY+jrYGpfcf+AZ7oAtB3Hf7ernNyN31jRb+Fl1L1LYwPYxsLT12e2xQATfIrqde6rroi9im7J2Pt5syPgd7Om0+UP9FnYETNhB5zQvY675EOcG83tGxSmECKY6MkxrFOeg12XqbRLRujZg8HQO77qMsEle4D7S8uoLvQXWWKAPwGuMcttA4+Y8J6+dlvWIIKOKAypwys7rdtMa5rpxIcNhaJVyHthxTRc+deXsdGv04Gy+ODtsBu8aDEYPzOaz+69dX3zgbfcMWqccdsBmdCQOx7VHd49erIAZFw9HOxdlgrhtooaYl7cwyWzSfNj0gQa/Qke9nf8qm3/guS58Aj6JLOQJVqdVWM2nvsity5Zr3ZybL3XE6MLh/Jd0EfFd/SrYpunzNRboA/Aao9xOkE/wOImlSNSrs9wnODrSRt33gjnzoYtUCnVbwAsvyynYtzX7+//79QebycaDw8XkXbNF86BUf9dhs9iSA1VxtNCuQPhGqgvVAmyNbZvaMG7r89tiAeaWd3BWFfDDcmV6Nk9++eiH/sffenVrvnHP1X/4Xw9eMP5kpi/Bsa+rBG4ES/JShz8N5mO+gmbyvKirghlsOgfdlq8K6D8Tf3CAhyxy2pS3tKUMTiQXhGAcN/V5b4F1FugD8Dqr3EZYBEydvWy9OUiSc27HSV0KlO2Uoh24/lwOXGhqWtVhQpucyjWq3+p04VPPnD3aeud7x8Pmwfls8F714cH54Uz32hRym5G+d60QO2eDcTRnBTNXLwfzxVBhd6FVMH1klz7sEc6TCsl51vrjbbRAzMuV8ahhMW4MmXD2d2f/sYLdo4PJ7uKXfvPViS6xnh9vjF54/uXp+971TrknzQEPODk0BMLgJx4qtqmWYWDbDo2B5OJDvaaJAAu8IJKp2r5GxbnJeWl91JTlCg8YNEuyAPapt8AaC/QBeI1Rbhto2lxsNlI6jqZNKhOMgPFnB+GtscClrSXIgnnUcDscOZOLK+hvefXC7y62J7tXH2wGo4cXc+5vjx44bObbg/l8MZmrK0PFVfm3ocKv9Bo0etrGKda6w3k8BKM1viIybUIaKBJTwh4lh6a1S8cCcJ9ugwVigNbIreEeQ4Z+OGB8m8F8pNk/Hzw8nc4fvnK9+e4H3i4mDHJZ7fq+g+c1/IInOEqBCm6VjAso2hFc8TSN5w8BlnbTOShDz6rYCTqSL5SjP2pn1c6KGfrBQeL0x94CN7NAH4BvZpnbA78aJ65OXk58B1hU4cS2A7NzCHjxBHF1LhrawKvzuivmKX5P1PC3okzAbY4OHphPZt8+GzQPHO3uvlerVsXM4WIuHzuUB1VInUvXxXSuTJ4Kz7uYaSGhfLiIPce5orII1Actf9FrMNBiWIvg0FHHVccL3H0OnP5wrCzgeYtS9dwNuKaAkuCaIAOFvpy/2gXRkOaI59gy7tDrz2Pt9pjrmi/RDgI4+jOu8aKhgtOuWx4tntsD33CApex2Mzdf59Eu3Ja+bKG3dH2ht8CKBfoAvGKQ21m9//7B1dd2F1/QCfxhAmU4EClUB9c3oh/44ZRgUJJ5UaVtOmi+4LZvJv/Ep1957+Zw/HAzHj88ub77XgXPhXQfzhVUlS9wcGwcC6SdZRyt4uqimY8UlEMXDjzWnD6zrB5iZYwfk6bDuQpD7QDoKKxcCncEwSWqCav63EGXS5DUaK7fkAuArUgoQzu2dQoF3Q6wwjeOc+M6L+jtGMOGNisW9ULM7gdwskiVnIrETTfgADCeeRS1k6f5FaTAMSy5dfQFHjilrdWdOnqWRjLbL5pKGzDjaDpw2aU9EXC5/8BcISkyw6DwCpDoEk/gEnCB60It+ME3Vp8BrEjFY4kNFXSoeASo6KUs28lLoh2dW90BKIFrWurRLwHY2jkC0KfeArewQB+Ab2Gc29T0r3SSx0cyfGI752zHwfBVK2B2YtazDQ7hQRLqIvgkHIjIn7jn1Jt7R/HC7z6zffTqOx5VXHx4MRh+uxzoVryqoT1lpVi5KOiyol0stGc31DYzcRcnK1fLCoenqNJPgRdbz6IUOTQ4X+nK4lgBV88/i0I4sfs3mBG8ccxxLzj6YqeIcGwDMTD6S19JZDVe4AgY8MDIg+uhXAV3PfjBuyAiIwWVvNAAtzxQSdYFoaFbHBIviiDqz/gONKFrcNCh0AQPlam2qdAil3kQOqrRerS0BdbSlYL7GNUih8xw9Kp5FrJOYQHoo/HRP/SIadG1Rb/AhR9MtC2iecT+BsEXMKtSzSMNdSAAUYJ34ZWAlGWZxiUPspq2ELS4qsPLY1KjrtJTNx5sLKewTLOWfi+1wfRNROC/fHbxUdnogsjPyn4f+Y73DX7Psvr8zrNAH4CP2ZhOj5rf2NjSt5rL7wH7pLYTYGXshIOrU+0sWmdTvItxqcr3fEMn9YXPLO49WOx9u3zlt012B+cUTbVUGRE8SbF1qGLUQk8FTKmmZrlVnCZhV0kfSphrZRyIxQHGNqO3mt1XIcSWdPAoCyHpjzhxSy8NWztkmKcqykvB/Y+8tId9jCu80JV6oSGDVyirQ8BLG8AWD1rwONBOvbQbJ5oKXkFp5YkizaIG2ozbwldgwENGyaFZTciteVE2Hm3IaINfCKx0rpiVMW2JQW37XhjSV/NDCGDX21yFsIVzdFCZdtMUvnFBBlhGyW1ojT/XX9Y3+HMoCbgT/FqbF3jgA9cf7cgNmoouGtXmFE06BL8CpEyyPM4h6wQcGmC+N2x82t5M0odHHtdF5AXbSflvPPPM4l898sjg6pvh19Mcfwv0AfiYjVFsQ+8vPq04+ziqEXBbB8MZrrM+HOrK2c5JSyKnvaYxLHAWzWdPnxp8NpBvcSDoHg5f+9BwMT53ON99mO1krUp4AZenoDLoylEGC0EVlEMDeU7tJMqB5n1dcGPhJMfF+tf3stmejjZxAL8hMJP4mlHQZNBmRR0JnqUf7b3BbOkcJPXAoZCahR1QzM6zgNPRYidowK9S4BTEtr2qg1rjRL20V2yiGNcfCFB7OyYrSJBaB+egFLLALn2Psg9uN/1NVDB65IGrA3mtT00bOLQXyjYol7rpSnVJT3cEnNDPTITsQGY6BDCuyjT6mhC6DawKK191Ny/LyvB3ukAsxux2cG7ErkdhaFHYClkwjvNHuG5rZatAu21Yw6GN+VKAtj23U0juh+UY5jkGnFSyrLzOUYH2vD7eccG0Bf3sZKM5r/JbcrvodVTom2+DBfoAfBuM/noitT18Yf9g8SM63x8Dtz4pKbtOjhNZhwOsdUDCCbqmuSiSTwbBmsNnPrPYeq7Z+6Di6bcdDXYf5u6ctnwXw5EeR2bNlhcD8xIk9XBV8I2tQzlCr4RZvAx+8se2/ua5B0ffbTGoaX2dAxpp2zkcWvZFR1HzxlF52hlAnQbDwXugd0oC1UofT2255RvIQ7nk0XrkSkZwWsX5BtgvoZrPErBU3EbutE4P2tzxde3r2szbfOt6KU81xAeHiVCrUJdrcpfr3POR8RC7NsGDABW8dHBdX68KENjMIQg0vwLmQAcMvoy7YZT95SvK/Fk2QVnVSODQVifzAlaEt83UaXewpQFy4OZjenLgTtbNFwX5aINbb53PNpo/5KkI8wtZqmh1fV6UfQC+tflObGsfgI/p0B1sNf/F5kHzG7qC/2mrWJ/4dmZ2CuBQNo7rbb7Qa0dbzY+eGtx47/fCZ/bOHTazv/H8YPc9Wu2ICy6nOEPdw2XpC0AJ/8D92ShLXtRVEURoupkHDB3O3jt49z2nB49CCBJpiYkBhUM4TSEkfmK6PyuorVDzpZ0EfqTCsxVcgwtObSeaqbcKCid4CWaw738aBza03SrVOG2ZQpUMD3Be4HT9ENB6Rg4diDW88AIc+lAgOXeRekFawgNc5DKn6lTQA+Sy8xpv1Q6trkKqx5AAFfVCXOqQa9WbV100Qa8voPHswFICXid0AYVdkloOZQfDsNWadngt8as7pjJttkfwKu2hc1GipTdtyVtdqL+B9PSlxUck6zzdg8T0zDldoJ59Ayx6lBNqgT4AH9OBu38Q930+sr+/eEIO8nGdnOftEHCYkThjldrzXAWfvAHTASch2Ke3Ntne6u4lsdq9PH/1w8Px8HsnTbMdTy0LW7jF7WkZsphpSzD2houkEKft47yZWxxQbBnSEs9bJbXu6w15BisSehc92twrDPSNp1gTtXOcpY7g6EupRwag1qi0AbKsAooseFgHQWyjaKx4Gb5WppBrkdbJuOTItuOPdvNWzjZuTY9s5LX4Knu73XiQt6lUbEczs1zsafnuBzly41Uv5bBwGxXqZQyD3Q0BrxWeups26Kq2dUX0IrX8C8D1lpfmG8G3YBMqueKj3kKDjw70z+Va1wKOtgiQUAsIF2+fW0LQl/bahh6f4FXaLcPoaTDZE/YCAidZhgGhQ61Uot30qIvsx4NHRRNjB+8+AN/UbndCQx+Aj/konsr7tZ9VIH5MO8IfkRP6Xp34H+ZcDSdGvqYParsoR/B725vNb9SB9x/8k7336I7bDz2/uH5OkRQnJ/IMh/oSlZxhuRkbn5eP+7a8NiSRbKjpi1W6OadvMrd1PYwl2IxA0gZc1JkSTdSGk3KwtYPyigW9cVZtKuVwnGp0Do6Di3Gj74KTO4EfzlEwwIVdNNNGikwH8wbgtsTo7Goct1uW4cY337afRY77WcugH0WVtmD+cb+ybUzbrPZzVTZ1r86R7/aaJ8y9w5EAAEAASURBVPfX4YMd2z5gKCXzp7w0FgBKsi3Ns1LRKEv2JnDVfbFOLbIK5gVMchc82U+ulrziG4zy1aRsb/W3bOsNn1YWje6nirS1+KrTZrkeG/Oh7zE20Et/4PyRgo/ajUsOfjTrYDltu2hoL6/XweKmST868RGxOA968DNmqYjnTwj0Gwb3+Z1lgT4An5DxVCB+QqrypxN+cfbi15r/6Wi2+OgmX87S2atPO/75O94++Iy81xdOb+peb7XaheYXf+vq+wezje+ZHs3eM1IsxdnJcS24B8eDMELxapctyXxhSEDdAZ4P9XDMrNxww2/L4SxGIz3qHK5SwTdXzXrjCD5DwYWlFfA02kVwk2SHdZPmBOOIxBW5xif36qSG0YnoCXlJtDvhKF2vy7RTdzIOdTtj4zuv4eAt6VHxchs5qQ7S1Gu5NU/rAIwAU8wPSZtWZa7WQYS/ZbjdDGp4wFb0bvFcuEVek1qO+UPmfhhmHMEZ2jlThnmnwDhgfkLAxZ35QkeZPw+pecE7khpYSUZwBFEp5CgP3AIj8wVdu3oVLIJmwal5qCnlmt65G2gXDFmRlFM/eANfwpIeHy1UQR/6qj9FBIXHnnlmcfaR/klom+mOyvsAfAKHk+D6Z//f4qpUX+z6JF80Vx5+aPDZ1e7o+7rfqbdxf1Afk7qHh5fl5bSyII8VKw9YyVnoIWY9aOUPZcCDAM2HEXAIs7keD8G5iYlg8oy8pClmfENSia9UKUjoth1PsapFuFN51HhfNxCKI8SrqC2Sy/Y0q/CCGo5N5UDjYLpgogPOF1rzuVm78Y1HvS67Di/zrGEu1/xr+lLGoddgyFoADda1zgOp4AEngVvw51OVjU9bjUPdAiuaFr0KTi0eNHUyTg37JssR8AqPOjiVLi0FrHIBGNgRhHnLjQ+3CLntR+EVdR0cdCNggUeD+tF2RfXQQQDxDBsh24kLoUKStKq7HXiUzUN145qePGSCCJ6y6Kfy0E2wODlUv1n66mXtamk3K9qFjwx4cMHlvkf/TscbER+7GZ8efnIt0Afgkzt2t9T847918B3D6fQH9ZWDM7glxVOtdPVVKUVTEdpP8dpH+g6WHjgSakoE367MaiQevlIE5o7iUGtbfUqSYBy40EUxAja40OOI4GFH5TK56bKkY2hRauGJBCq59Qo+oBT69FiFpoZTRh3oSeC7XMGDbyAUHMq0YyFW76ZRseUBr4oHTUuJdujJLdc5iJRJq3lCu6PbgRSdijmybkwD18mgzbo6N2xpFiQzj4tZ1+PlMaCtHYeCaDrDGXfKDiKmcdB014Iudk/yKXsu5PKzowjR1BEiuNYDPtENM6CucnSp5OC0dXSgzoFcf4FPgbL+wgwVP8MDN4iTzijWxTn4vuiyjQLXBCDcLA2bjyLHdKAV1WKFbrh0/LlLLy5+79wDgy/cjFUPP5kW6APwyRy3m2r98d/cfbccwg8008m70wdwTG8rp6FKfNoxtvs4wUnE3ixx5GUIAq6AukeccNHnKllgxeDcap5lWYEaGGtqBeQCm/NKix/CaoONmLWCkKI/6kVIigIHQNUQDr3g4ficrD+eNEjMXJXAUx4gHfL6ICmDdeFjHnaoQeetc+gr2uAlFpAu8WgVSrm6Jd7iRFORBdDF4FUYuk+hCzj6C/7mS26dKphxCpslupoXQt0P08CvLbu95BYRPFRZzd3u3O2uk9d9QI6D7w04XBnmi2jRxJwTrd4jZw6WLWjpVduoDqJ0gja3w6TEzbiAq+G+V2589K5vCbgf0V4UtY2AuR351DmrSCpGAkainXva3pxK6PLx8pXFef3m8U+ap/MWSzxgB7y0/a6q39e294U7wgJ9AL4jhpEt38GZX/hfd/+W3tx9d65AcnVK98oWn5ak8hsEVla3BC0F1WgfEF314q22moHxCm68UBSuDAx+SSGCuBDwa9pexoHHCjgDMr+2EI4+YjWsu4eyQghsSK6Ed6mqdjigCAf9IlEGVwnSIGsL2RZOSm04PlLV3MHgk80Z4EvZvKPNgVxt1OOhHBWME3rRVhjVcmAHGBgHcFwG5KgQ8GhIWHGuqVvhu0pLPXQRCaTUSSVr5RgvAlSiFAJVikyLhtZyKMOfZH2y9uaOyLe+oat4hyxkqA15ISfhQGT5fGt2rpvdMRc155jHLW5RJfgVHoC8+oxm81c7287gQs9fNAEvdfCDVxQ4JF6W8hg6GwCvllHixnyDYUlxhpRye/HpxpVc58/j2CjmFHxJ5lXk0N7aUt+H/9oLiwvveXBwIXD7wx1hgT4A3wHDqBOVD+feoyd13qW4GKErH9yZNSM90cIDVMoEn+le7yja6bYeZtbDVOn4VNU6JJZZ+ZqR9qrlFsMlgCJHoKC6mJsfQV3fleQ7zdqLHkl+ypLr5aEurSzwnrmCsX8JU6tCPZwL4nBCCM9i5BxwduC0TlLtJPCAkedavQCVOeEIaTffgANQWoUbh5xEjoHIp4VGxahDbFBNB775govTdDu6Uo6kcuBxUAIeTjxqebBDNl5BDTyXK/QoBlwHcvOz/NhNAKsQk7X6FDD1uCeqArYjhd6qO0/oGz/aBqYImUWHuqwIygMI0SKayLX7HGZwX+CBHqQI3MrbC7SAJhwc47nd+oc+9KfgO3N70KnR9q/bKVtuzcB9NA/mS4sXROZyY64V8mPWkVbO19CBShiIQp4D1mk0bh5/8cXFv3yg34pO49wBxz4An+BB5MTUwpXtX/kFvUREcGVpqjTXklhuLR6I0sv8TaOXfXm8VIFyENuZCqpyfEJkJ1lFOUEFTq2NRSMeOGIcjBwDgVnwkRa5cJZ3DDxxl6fUikW/4yr3rTKRS89LB67icTwFnbpBpT/0EA4BmueKIgHnzwmckpZWQKs4qkegjL6LoLQjr+Vd+FQsA60O7GYbvAq+Yat0hhe06E4NA586OfzqtMqrbnPZtKs863bKDEONYzraajh1Ui2bOjjr8Ng2JTmgODfMOTYmOc/a8jGCScGLa7EK34EGev0xb9JcmjsxN4cjZqX2YdqLw9jCtjzrVfNx2W0xd9RJ06AdsDrRVtPVbYYbtlqv4bQ5gFI230GnvtEjv/zS4jGJPs95YPwwFfYAQ4daHvzgH30ZN58Sxo8Go/5w4i3QB+ATOoRHR/N7Tm0TfksH8KgKnFrxaP+YTzxqS5inTwBMdUrLGRBLBeILk3rWRR/KkO+LrWWtX3kaS1XfJovXXkYjdpy1TS0HOcczToUxFohwqyU38Vvb0IOZfgkJZ4P3JOiz4iZ48yfcLrm84ghBoBvRbByAKtO/4EO11NfyVDs8jKviUloy01JLVoJ2Dfz1QNDVKr8eft3+ZmnXmK9m+4bL6+SPS2diOrxOx8BZTcAYAy5yMAwojGG7Ei916EKGNlp4WEAXd7rE05zUBNXFo5hscC846Use/GBYaCPXoebttpBLRakNvNIDnqhGqvknpIIZUOU1z6JGy8sy4AkQGZZTsYiiLnR+kgKocTGofAm/0C/JAKY/8X/spSuLx955f7yWCJs+nWAL9AH4hA3ehc8tNieX9j/86vX5t+2c8mmriMi+nVyZVhuKifwcL6/v6hyXZ5Bzm7PJp5tq0cbFtNasCsH854ER7gnPB3IMwiJMc0uYKK0TXlEaOHzxEspFxCKMG8oEcdHpFSblsmTSlijOyvqGhFOBbzhTygXDTjscmHFoE0HQZPEGZwvKnZ6K4/1r6WbNO4ZFxjaMVRdj6Do5iTGqYat1j1liJ37QreGlySfoXE8QSJie4dNnXTSR40n7+BBH0BVGzAOnMoWyqko7bwRp8QT3HAzdy3wsmVlF3tIUaFtXgTL0yAzaACRiyKWBVOBcEIB3s18j1Pn0I7SbzLzdB1jR6PZSDXABPq7KEwnojyfZAn0APkGjd+F/e/HM4YuvPab1wdubZoPTXUlLzlLSojS2grU81b3Z4YwVqiAKzKwr5Nrk6xTo4t9QTk7vB+v+LQ9dCaZGtprlHPJ+IEEX1gPuxwllOGStosAs3AGvIcnJqKSV9hQ6nAWrZG2DcyGwOJo0uzi/olr4Dcr8SUTkEBF4g1gwHlyJsmDASdTpXzgj4wtemgOnPgTeSrtpIarpVnkjxwkaqjUtbQET0Lgtj0JgGrNyf1paCsE0mdX8CgswbpqCVIdWvjBXecDfNnMbDE1DOfQChs3JA8ihw1vFD56Fd11eRxO0hbFl2VYhpMjRFNWPLxCEQy7vl2tWQc1spnU50cKq0U8vw9MXCWDSD/4QHXOrlP1QlHUReClBQyoqt7YyPnKNE4ilzly2HNNTB//Zp6ffJthF4E5XrizOaqM9vmQHP+SRkMMfdLdK4Asv3x2+FWLfdiIs0AfgEzFMTUPwPZhu/+eKf2fGG9x01blanawsFwiOWkPoLzvFt5yzNFKg5VznsaWZvnLFQ1Pp9HBnck6CgcunKHV+Kxgnfjg7Hsdiu5n1NA4SCnBDXs1fi2a+rBXtu/vNS28/2zmUokjscYe3FSG8gBMESKjNn3GBkXBMdDjgQZDwwC11yk6A7Mwow546zI0X7WqgDYfuBmxqHEHbtlZXwUB3go/bgEFbtxvP8MCX0BondBECeSTltgn1aKcgHPMx3LLph9vISbCzvAD4oAZWaZ4/ls/FV53c7pw2l01T47tcy6cMDboEbRQSk7ZXrs1fYJ4yb2XtaGDuCTfnsaDgIc8pgil9EID+M37Wq83V5nus2MbkS8FatGEfBCitygkYwIIH79ADZiojOzuWtJRb+Wp7dX/2PZ/49Kv7/+ij9/4beEUaK/gy/kUh83S+CofGbckgjmd5jemh+2/8YZUKpy+eAAv0AfgEDFKsfOfbPy6PsqOTXr+Q0Az0c4UvoXp9ci70/VyfwLTNZrqrpkUEMP0Ro7WUjSeTy2OmsTJWyJzp0WU9wKV23jECX7h65jkDrdrhhkOTW4F+FKtj4YUb4cd/Z9zBQ458KO1fvzZ79j0PjkL20jYgTqskiCOwBpfUs3aQxkMqKbKKHpjxsQOp6B459dY+FZ1hiAXMO8vQOVEGh79w3qUNXGCria1ar97N23jmFfzFB31XceICQExx6IiynFYnAcwP2Us8ASjRDh/0dQo+K32rZa/yeb1Ph5ovea1PDafsPnjcyNElZwuFpJ9M51/R7olmnXZNIFLiNSTd1IhuhIwgLPRqt/7mSZ1bHgGHgcqwClvaGMKhiIxoi0pFk2Rr+wR+qIAcynFQoSTktAkc/bkvEqZzaPGIgnDjIKzenvV4hz4IqBIwePihLuscigvP/LfHzXlVL+qvTyfYAn0APuaD9/P//PnTh9dO/5ii545OxnAd+Kg/+sLR//va7uKlcr+s+doL02fVFfxXJJ3AuciJVbBeRUpHkUcF07nuCuvJ5zj99TS0XkjSKa4VdDnBwRO9Vs7cCpaDFGMtn10PXwRtWTGH04E2t7PV8JUX58986NF0eDDD6USQUtmpKCOv0uHBFB3aNiOTg1dWaeA40VGn1iGCKyAOLC4AlNe8wziFyHCqsIp6yYHVgZE6yTiUdSM86FAtdC/6RFbKtY6AWtxCE3qqAb5OtR0CXoSij+0JrnWxnsCQYXjYrcBoc9344AKj/s2mIz2Cbj5mt6QHFSXajiaLi9pmJviqqvmlVS/jS12FeA84kHUIHoUhdsFe5CTnIMWWemkzXo1TSHKHoeAHEx1iDHSGkZPMN2RV9WjUwTo4N9w5X6PhtT/xOf/xz1yb/8rP3vcnuh4+a/7kHgN0D3jpW3QYGTArbeCyS4Fe7odl9fnJtEAfgI/xuP3Mny42Rv/mtR+bzqan9UsHnMikhd4HjIei/v2Xj55aVp/4rLuyuDLhcRUdW83c4c3nrEqbPuLMbrRw8rmsxAegk5wHn8En+JK0rcyu9DAe8IIE7Ii0CrmiD+bC0zbiYjYSqsCLK1dme7sHi6d2tgYfBB/N1qXghZxQp2BQDs+zhoILDNqMv4prOuDGAVbgQYoykhnlGkfgoDHPQABYJbc5V1M4YPGMPhY5FUVXND/lviiIRutgTLUHKgwpOAUwKxHkqBtW9AldVvmZ3rlpIFeZC4i4IpA8VsHjG2+9mvJ186uvJUrOkVIuVMDq9MIrsyckvczrfK6Adm55oBb4pVtLwRCcsJ9y9HcQW+UfNhIDusshdFKxxaNtlR48273IRwkueKwP5Za38WsZwi8pLog5l/RMxvlf/PTViUx7FVtbBwdUscmxKLn1auew4Mht00B8+nTiLdAH4GM8hPf+61e/X0u+U6PxgF/3wy0qNGplqs1iVgp5v5X3d7UrLZiC7WCk14SA8/EM58XFKaBqiZr0nMrBizeNklYbgaLRnWEhhUu2ZQjGuGgH7YDLScYDWeY50xpaDiI+30EuPQZffnbyL77r/ZuPh5Mv3GofEiABlqQVvNrxBH3n1IzR5bTxZ+bRu1I33LmpokeulNz05rfS3FZpJzmHzuU6N79ALodaN3QwrXFNbzhkddtqGXzjciETVwEQlUSbYaalyTSU4VHkHhw2zZkdgN942hftC68s00XQkywHHOfakXnx6quTi5qP5bmB1ID5GRNdEVY7LqFXxEPzKHpGV3RwIKY/5k2b5cKVaB7cXa5U1NwvgotJCn/gzLts1LkkuOsRfAsPl90GGBahS7wKGHesdQpyfo0e/aM/P3jhP/v+7RRWeAStyojjvIYB9ARceJHAcZ8Eu3jvTv9d6LTMyT72AfiYjt8vfurKeX0O472oJ2fAw0+zElT19apQmiCsFaju0/JCr5LqXHFHICX4kqCVA4oaZW2F8kIR+8tD4ejLVoEGDfeI5SaSRie/SnJwRS5leAIXv7mu3NGJoKufKlTAFR/alYdDRaen/sPRU4+c2/ji1ubgQzhKVtQo2jqS4l1CEHJVXy0XFMS3aQknKoUWZOrKW15QmYlzYOvS67WvowF2M7p1cMNulluG21f5r4MbJhvfkNx2Kz5V2/X9bzwAE2K+fq1pXqrWZNifvzpRjzmg/OuvzP7F1euL15g/ZQ4GKnOJea3pubQFvcRLYxz1iv9SuzjRZBibPRGoywVKBDNsVc2d2C1Cg5vxFDwCOTS2cwmWQVbRBX9Y6f62+jKT7JiVnH9/+IXJ2b/xvdt/uTFuPgDUOjoIh3zxTYK0F/yB23bS44mA9YcTb4E+AB/DIfz5X33+9GK8+V26h6TTjgdS4lOSEeB0QpeAp0inh58IeMIC1mxo5Vl/rUonfHyUw13EsVGW0+N6XMtmnj6NE7u9d0w7rxLF16+Ep0AdvgAZalrotlasfCUueDnPp69nQ346D4caMkTwH742+dwH3rf5SfiyvWlHU98TRQeYuS05Q6EUUpRLOs5KfAOEQw18O8PQLigCHo6t0IBHMwl4yFIZOLLdDrxtNFKhCbmBkCjUTRtkaqthyIFv5EKgbDz3pZVbcGmHJ8m86rzmCU5BTZsUHtBD0/YTuSAqLyokXcFv8QoatF/+mj6cVj4nRjsp+kKh0FEkMe9ijZfVtp/uewFHBoxxE/6LTz2z/wRA6Rs7MJpzqsWDfjG/9g5mL/FWMDoX9UGPFHZQqai21C/wbcPEVl0F4BSClwmdq4k+rJUFnZJtaqHRP/NTe/ANTJUL36PJUBvynDBJJRrdsBmM/vyvjv7lD37X5sfhiVDjB7nqth05Kfpbysqu6ifAP5kt/fGkWyDXPye9F3eY/n/zb33ye7RQfceYp0F1a4wTcaCHVeSr4tZrnKC6kcSDyrq6V5DlPmyexwq6nNRyAeBrnzjPYnah5Ze0L0xEzV1nrFbwBENG0rLGxYXo+p3vWul6O/jBP0QBELbwJTNKItdLSbra52YzFwT6z7PUenjrpZenLz74jo3TmxuDDwRXGIu7/+wsg2Fpi9WK8chLWVk4cOqk4EGuP/gYbp51Dm6NAz115NKWQkoGLgiFBhzTgkpqZRfayHRwbpzIjV+1G898IGzLxi85PEKXqg49Cd3KA3ahIzDzsQzD6AN/oaSyG/oUiDqI6b5+yoegxFiUoNnmwOOvXH0hLxLKlAQsZ0kCQqeUvfvs5cP/5dq1+RU9oSRIzCmppK0WzUs5pHj4/uru9IX3vGPzPxGTsy1/sbKoYBXUcEhZIUM4oYYO6G0daIu+Fx7Qg2je1PkD33wCBzylGmZ4TVvLge+167PPPffS0efZCeKp7tgu4g0EDdZfXZp97Xs+MH5Zz0f8ELxZ2Zq+zinTxh9J5xv3j/+rne3BnySkP550C2iI+3ScLHDhtxc7+3t7Pyp3pAvd5TQc6mbwbBo/fiAX2DZq1au7TTizCiaPpivsQTxRo6Vn4uBjFCo3ZuKjE1s0c90/5r5vtMshsqUd94HFHZgcooJp+jTzIEd40MXrR7yupBRP74ixP8as/RU5wcG4GTc//p9u/+ON8eAREHFgba4CjiwZZBus6hROCSKlmjYhN6e1DPxXIW9zaN1uPnXerngENG3dXpfRL3itIFpXcOuy6+YBLck4kQtoB1+3J+b6Y+iw0lTT1mWjmcZthrMC5p4uHavHx+302QHNtNYfnBgz5cDcMfCuvDb7Zxe/NvmDq9cne56z9bzim+RslYi35u9ocO5d4++OB8Tgo4BaHmDSLQ99Qob3x0pwonkpBa4mH5eouj7VxI6rQ3CkBxswodoSDZUio82XEBAGQhDTRfHoYNGgw/Rwsfv812fPcD7W5wrt0VddpM4Om5c/+d/e86hOmcdl3/PBTNzaXLgoiM3IdXhiNmw+dmazv/eLOe6UxPj26RhZ4BOf3n/vbDaJ3/1kW658V3kxVjnu967oiqOiTSeu1q35wworKLqCzsBqOLt9EapLvI66yqu58W+Vx484xIc5xLPwq/FjRSw/eP+9w9M/9B+d/p/H4+b9dfsbLUcQqGarHVVNvw5Wt68rQ0NysKP8ZvhA5/SN0BvXuXnU+eu1gVvrX9N+M2V9zSxuGzjQruPVBojSWA1Rix4BRLWXr00//aW/OvqDdfPYyJ6rnjcdPHZb4laL5xzzjTlLWjf3PJ8TQ6GS3ZlyMQmMdl6DiovO3M0J9c2LC9i4EIiVOvNCd20KPvToQV73x/oDr9OqLrS9evqe/+Of/t3BZH+yeEy/If1hvcL1E9pZ+BGY7pxq/h/Jv6jfDH5W169PnNrov/1c2/NOKff3gI/dSC7OSSVdZss7yB3IafD2L06CMitKnZ8KuDgMvTsZ19+061FiFqA4GbrECpc6P/U202omEKOv/CKSOLLSjfeAtUcmCtrTiQs/AikHMVCoVls4Jt4dDhbVSluA2Dhk3xBZrJb1mlQzkwLUcXjodu36/Pr/+Ud7P/fDP3Dq75zZGfxE8skjTNc6bjVE8CntbzTI3CpgIfFW7bRJ52880YFinW+U+E3LfD1BNuqb1Iv5g82ZP+hIou5y1AssdgwoA1TyWIGrObF75dr0d7705f0/oM1zlDLJc1pvug0oj8Y5ZyWZ+yYD9Cg4aCOKGYE4RsnB0nMveYx4VS/moOeu5zLigPFOu2ijV6pL75FOsZk+i865hFaRAlcNAdH5ImCcF4Kz6yMldE7oXIxdIukt4vh4jXSLk6g9d2JzXf3hnIMfOjxwdMC5/kwJrk98/kvTK2r4YSR//3cMf5S8T3e2BfoAfMzGdz6b3KsIpqioB5p0GuuE5YnjuMLXiS6PQeBUK+e3QjNX5Dib+YRAp7J8BG0jPWNVgq9+V4HvbPDhDfmHsgKQs9BTplzR4yrHcqq5jYwMQQQbxQpBDkbOKhyHoPpZJaWQmU4xnJB01OtHrMBFpzemJpPBYGMjgy8XCkJFCBcNzb/+/P7vfO93bj7z9ntH/+V4PHgA89OIJwyPqlxo4cihiTIFJXBIpZqVcnSbGYHTBgpVVutBVjMyAytBPYhKHgTlUHCjUwYJ5npNSrPZFNQuM2LBoSEClghCRGk3/VJetQVde0g9gt4wEULraluoGQponGgvB+bTlgaB1XCdYsxaIR2tbWDc6XTx75792tHvXN/TJyfLA4XMrZzDiuzMPV6jW+hNOykQgVMRn6cXmEPEsQiIA+ZeXDTG3IeGecd8Nq/BUC/Ia56rLS6iYi5LtcRLfKlMAIy5KCPrSQUeROSJBc6X+MFsbVpLviDQ65yShNRTV7zC5E33ONc0U7gykQBmuOY9550+WhMXnNiNlLzH0b/AFQoXGLQd7h/cR96nu9cCfQA+RmP/iV9+5b75aKz7VVNO8ggFWkjKgVAf62SOE14BbhqOSs5LF9xyTGrjpIYunICCnrolh6Y2grkc3myazkLricCbL/TDcxEy5RyIfbzGOxxrtdzyLo5PwT5+aTwMJf5yQeMpK2wC+oDVEY5F75JIDhVJwzEWXWkfad85+Wb7F740/b/lOH//+z648+P33zP+Cb2S8X6crAOm37nEmZe7y+nhkSOY/reJssBdolIjlBYHtqhWPCyTix1IXY+H2QqtZdQ8DCsokbndPOgTeKSWNzBV6BurRhJl8KiHHuQFBgp/Mu5SP2sZxmHC+OIFWBAICG/+Ak8HB8nQN2YZyGovbc4NI49VKDoJnwewwInAKJjL8A9ZWvFOpot/+9r+7E+08v23l188eom5JblIEBbzZ5wrUc1ZzUnNP+VKs5hQzBnFVuav5jaJnRVNsgLDTmNtrEx1g3c8UzxVQB+zehbPqQIyxMjS72cqFx/W0bmyVaDkwYY8x/jxxXwIjDxx01RcoCJXgXQxnY7FH/24WOBk4GHGnMvgxAXAVMOn8058qasAbryeJ110/kbv6AsXGrpQEGyxNToDfZ/uXgv0AfgYjf2pzftHu/oRIZ3hfFgjkj50gceSc5nGlby2diNQ4qhxMAReTnCu8qHz1X4Q6wA9K105g3Du0CgVRwFNOj6chXiynVbjCRVHouCf+rDaBi/cifGDnWQge6ifKEZX48APhzQPHum0VNfrGOPBF/5i7/cl4PcfeufmAw++ffw9WxuD929tjd4v7fgfqXgueUX5UHkxvGgIT48m0fwXLPZAqaiVKJ1YyYQjRMFzTVtgFf6BA6DgmcbyCjyiCbBA08HlIC20NJouRqdVQlgsp+gLj5hnHjpC7wR6zAYKTuatesuTtlV4wQ97ZLnVuTQtZTUvqwlLUojv+IPK80/oZhTFzRcEuv7aweLf7e5OXnzuxemXmXfMCc0B7eYQuOKiTTlbtcw7faYxR1XzSg8Y6uLP81c/YL2Y6mpyOMj5yZzJPubSkg/AaI4p4GoqSw3J0ixjnhJ8p814PFbgRHkFS83xmJPaIdI0KcaMC1EQWpmSLRkEfZ63yHNKMnL+KqdNekh/uoIe2qXSgxfSTOcXF6BhD/GPQCulyDn/LMN9UfDllODD7H26qy3QB+BjNPzXmlf1uGZ8ozl8Gyd7BjKd3HpKg3upudLM133yV43k1HSZDh7fnSUfKyhzDxhnI5qF6+VempyirurVjm93W8QBfWIjHaCdFI4jHEjQwJt3M8M/qYzp0iEpL3tuckhy2IGT8uWEeQAV/uadcrXpOEv/87UXj164/PLs/1oditS/9fGrzbEqox/0S1uk6rfMgB1wkjKRZEbdeq62wR96koNFljte1N3H4AmuuLcw6thcOpgXNOsSOKSjyUz43IvPrf3oZ9EbXjfqjQ1HethOgSx8fPKxDkEjEPxpdz2xOlzLWeIRW7DLtydqOpeRBV9WlwSiSLIxvGq54CFH7TqyfQudtlxL2KOOHYMfJe3CiIceSdCaUYywIfMY/povcV0V+gafHFuPldpDftphpA9ecLVBwtASwvvswPQ6HNpIL9okDd7M6+CPttKTrWPBlbuOrlNd8Ma8pU0XE8Cgxxb6YxXfzoewu9rhjQ7IDp7lvIx+MS9RTnja6en9L8a8i1M/AY7R4G9M5Jq3TunU1pWytoh1QpN0MheHp/NVJ3xczTdTrRj0U7yd+jhGndbyB3pVSRlb1unE5NRok+OfKkjlVlw4Djb+cHhle01y9L7iNvUmVyPWgRUtUyUcNY4HnfQHjNXFmIAU7o22XD2IVjgj4RDjCgz9oZVuQRs85HjNU+2xlVj4SQb/6ItWJBubrFrC8YUMrXPUJm7qb/YnpjMwOT56nXXuKy6O5IC5RZiywyJyk/PhaIpDJGlrXWsamU6BPG0c/MP2RT+28zPl2HhcsGPIUiP3D5cDFX2CSqEg9NcQoH/oLnx9D0VbsLIfGmNH27ezBRELG8ZTd8ELfokX4UaXZtgU2hgLmku79aFvY/3gsySxJZtjF3MkkGWzHBvoNG7ltoH7Ihho2C9k0E/xCHswh0o92nN7mTkcQZvGkMcYqk/IVFQj+KFbjiFyxLHtf85JNecYKlqJR6yGsaXMl1u9mm3M0dClyIm5IFsGPOe7sLAfCZthY8r0V3VBqOV4hDxun4QQzjdJVl/Rm8S78thafeeCIcaKcM+2vJLmu273RNk0WlFnH5FCQA5+2F8PThwFVX+4ay1gr3HXGuA4dXznh96xf/0Lu2xqEbxCtVi1yJHpxC9uIrexdKYLheFLvAX3ieV0tLUXzg4Hpm1frrK1qta9YWGOuP8bwRknkinWCjg3FfJm8AEPcXGFrnryho/e+RVE99TUFt4ryFWXI+ImsdYvkhH37HSPTRGMdYSCEv3AH+EAoQUHmfAyH/eXYE1ZnVeImCpWsN+tuvqC7hGg5MShk4z41AdbmXJqsg+BJ22jNb+2uLUA0spmQrseIFI5gp/4x31CNIh+KfixRuI+IbJ5a5T+oLPWYzqik2wqHNknAudQLzRbLnzyIoN+5cUGsmayHf3E4XNfk2Aq4Jx9R8bNQUAXDxohtUsg/Olj2kdQtZVVa+DQHvaRLhG0RbcgmOif7DOfzadDjVnwiPmiIMq4YfvkG+OHbdR32UxxfSE60fDAH/X47Ir1wIaDhYJ2uT+LnZCrDoTtsIF1pY1+SM4cu4lf9Ef3SGQ0jZn0CrtMcjyZq8xBtpglA9noIf4MOQrqv/SBJ2Ore685zu1YZOBl3GKeSH6Wc56hozSK+Q4/Tc62bzE/1Hd0Cluo777YGeiCzHYI2dIhzxX0ULndhRB/McYe6nWMJzaclOCOXWb6vcW4mmsKz3J+chGErsPRxh5dddJWwsW4ilro1aM+3RUWYP716RhZ4Bc+s//Ds8nhJiczW3LkOpXlIHObULdOh/MjtuvkHuQDyL0lV+d0KbbOtAVcl2MbTQBwa7iedS2BSR40gi30BBwcOFt5eT8PGpL1Sn4R3gscvvmzhQEI3I52lQ841oXysqzUpdVZwUueSw5xpl3w2G6P1Qy6ENBq3gQ6cNNGxYVO5aq5ZinJ+LlqzOBNE/xxtpYLD147Sd1SVmf7HJ+6DR5dnxBYBgqiNgEn1nDvMpPldbRpD7ejGeGe5D6nbp0ObstxA05iGxX7ZN1ysi11TVjHnzbbpbOT7Zw5+ghH4x0BSLI0X+MCgzpzJvWCF/Vu3DRHNBCMD23JhwBO6uZO9UtdYc/k2c2lxM9j2oHV9GFsGddtdTnxcu5zcZW65/y2bM+dtt9lLrkOP5e7nHNFtxbYj6/ao1LVwTFsOht85TMfv++vXCf//DOLs9/3yKD6qnbd2pfvNAtU7uhO69rJ7I/i60v6wvND8k8R/OiFHA+ekXucOvFVZjWg6262k7lyVxsX+UqxJSb8LdVjFULQ0O21WC3gmKI80qpDOOKVW4IEWrac5ZCCj5YFWq2kYxVQuEyTMdt+4TzAly7SgftuGaDTmaGrUJVylXEgmds4WZx/JHQzn3R+CpTZP+mDE2630kW3VfhN4acXQlI+wVcr+wU/CCGm2EAZD6m5T4JpHZb8Q0/4xEVLykBPthD94E8EpmJvVua5tdrpLCGDrRgD8YxARj9ph+9ssTWNJ7e10pHQ0lN+FjK3V0UtqPTR8pqEDr63nk4fvDY4M06SFX0Sdm6/I4d7lsGgOmgcirzQL8YUXupbwLO/cbESuiZp8k490t70RboETtLQt9hNkV3jAScu0No+C1n6aOGqb4qPuH9axkYrOOHnfVbhSN98sAn8ZiEdY+4pULP4VJ8EF8/ol+hynki+yrGjUWxFGUx2DjTx9AyXonnIxC7RwskRNvSczPMHcBecp8O0F3PDdrWuet2Op7E1vppKRbeil5biJPUr8jxkm/rPvNGYoUdcMEezcMXLMlJ/7Ao8c20QHN74k4J98K1MfBcUmbV9OkYW2J/uPb+xMX4w4qECIaoRENnrm8zKKi3g2u5Uq7Y3cU4ZPASnrK3IdNSqg4NjEg99kpaPQoZDUoAl+Ea7HILC/khex6skbbgS4KAcb4wXk1BGlZCb+sBX22ii22brU7z85DOrn21tneKs1aatWPkvHlYJnajDx8FJN2ZxpLEdOtqQX5aseO855OuDxJFiyxZIqxfOTduF9Ft/2RdkaINX4uz4wh6xzaqnvYPTSNvHyAh76iVVtFrwa484R/ynbCHXGnIUxMq9cMyniwCClLbCsWcmxoD+EqgizdL2snLYSlv/0ho7twFKaENtn4uXpCRd2KQwUL8UfJOntkL1BnfoGOPoh9/gBzqH4sxDp64Pcu68diO7YEsCC2XDxnqNDPvx7i1zS3aXTeDIhRP6YQd4IIKGNohiCPqkJHixheYVD1hHP4OvWqO/QQ9uzlXksp8rHpqLkoUNaNUcY0yK7BgL2kMn8bB9mLNhT8a86AkPzyV0JuCiC7oXXUuOTfWQg+yAPoyZ6jE3lOvZxhwLjb8uK0KO9IrzKnqLnkmHzuqHZKAvc0Q8c9xlD8YGPXTByCK/6AJv2bvwxb6y6eFv/v2dl5Jvf7xbLRAnwN3a+ePa74/9+jV9pH2wxQlMsnPMV3xYYegtRAFZaVCOrdZwlIVANMBxFFpdtNvVuaU3KQ4FXNr1G0pBG1f4rbNJesHYxlU7joaUuqQDB3R0xLYbTqjTy/XckoOKQIazwjFPQmf0ihbB6v4BI8EPveDl9mzhiHwSjjRtETUEcHd2ktu62CfQdKj7w/evoSVhx9QXx6oXRwKsKwE56tQh0MAseLxmRR/SbuiWT72Chx28VU2OTTaW+GR7wqFABuMCf48ncKdunKWz7h3P4wlbcDciaFp2fpkJfrmdSj+sW447cyW3P217ZKYNiz1kO+45I3O5L4Oy+5JjDJ3lbG7qifuwQTztLnunDXLcbDPbK/vLWCzbFnjqlvowRzOAZf/Thgpceu89g7btk7nsoYuAvF/e8cYG9L0br5QPje1DOecGDx5So97Nm4QYP+2StClzOtEwD1PfHEPmxc37SRvytKHz/K//d/f+JfU+3b0WSC909/b/WPZ8NBteXGwuPqBbbBFAtEKQI9Eqjw/eERik9aZWUXiR+aGu6OWYxuPtwKFD8SMJWr/Ejy1oW3QSD840w/GGfH3rwNLbpPMQjRzYsjEIgHIkWokMCVY8HKOVAquVWGmxCtGTxZtb2u6W55Lzi8v98QZbc1q6iW68kdvNODStOwf6aIh0Er1Qcab85h1PnYIbHyfikRk9EIQu2gCXPK2OpQXtDV9ian+eQvq09cViU6+bqJWneMRfttjQfUT0k77OUQ75fOFBqw/9ScfElQdVfcrKCH3gpCT5ITdroZ96r7WNniTf2JYNwB9pHHKMwq6hX/SdV8NSJ33MdzzY1sNX9F06hX3o70T9Gkv3scx4oG+XsHrKVSt9s+7SLfRCNanJM7R6uE7aKVhubqkvsn3YlVVu9FdjQec0vOKdvdlSzyayqx6oClpts6oPulBhy1yIU/VrQ6jYVKuzsX4+g/7oVSmGqplvpF09xlKEvui1J22nag+B36Acqo/seggq/LiYUaDRs3FCoG/ur4RJd7Z6u0CKXYZ89UqJOatvqanbeqBJc24DXVi7Mx941WwrV/PMI3SP+cIDeMzLwwNkzdWHsLWCt2bQWDf0NV/EnnNFeIiJcfb4Sth8fjhhbue5g32dsAlJD1AJP+Diq92StC3nFH0mhU7ldTzmCXMOGTHuMTbY4UAbBqPJzul7vxJE/eGutkA30e5qMxy/zn/i11/70HBzdO+hgkbGHW3jyVHhdHCiGzrpqY/k2Gc4A76Oldu5OJI20IKjpRN38XRfVPdRw7mko6TX5kFQpS4B8QQxZQcEttXaeCd4+KTCQi466MCxI4I2U64ScOaWU+PAB+eEfrmNOI3focVH8ms8Gyw1CBCR0slNVN9SfyciLveAAwf+9KH4V/UrPsCgi47xnC+HRWCQrbBlXEAUfeHnPmCjut08ui1OOV4Fyey/+qaydYAPybqhN+NBjm66rRBB0GMznx+oTduSurcOj7QPtpQNxAedgi5sgM44dI2XdIy2oqvtSTu8I9CGjtO4XiFQMIe6sRcv5B3p6WHl9IFgFxdAyk1vfeBrmdaVvnr+IWTEhU0JQjUd+npLtp4fyMvx6wLZoeYItm95C4e338GFj+cQ9pGwMl9o6WhS13GMoeHk2CvHrdPb42Z7M26WwTnl/nh+0HdfROV4ZQBOmMphhxw/5g1wZJOwFXLMs2kOLv2jj76tD8AY5y5P7SS5y+1w7LrPzxJOjvY+qIt2ndoZyJaUlAebjza0asoA2LYBj+1ReanKeQkr7sPa0a7F19YqtDhCvW4Rjm8Vr7ual7POUKyV7gZOTl+vlhQCo2j1i05aqbE9no4qYbl6gwcOy7qs5q3MNQXjNnhwkmRnWTmKFzCFkT6tBdpQ/Qq8IMgD91cV+bnXmTaELuhVoD/qC4GbLXjsLI1jVRarTS54nEKPItuwkre61nDw0TkUVa46Nm/t2o5ZBs0WD/ygK8xCrsqGlXqMPWMt+0cb/YpkOZ0t2r7THnpovErf0B1wjJVlB6+iR+GrHRLZRhdQjHNlP2ijizqk/XJnI/nmfE4bB2bMVQLurMxB5qttHnzgTaKf9Bn5hhnuCWCbACcV3LZPK3M7A2pehHTnSQZhn0M1nw7fgTr7E/bEbpVeIdN9UY/0ntvRr37s9J8Fv/5w11ugD8DHeAr8wq+8+K7F5pn3hYrF8YSjxrlWaUMOB8eFR8ptSLmu4nViy7E4Z0i61YdWBQpQOA2cmt5JVPAV33BWOLiEwQcnggzSRPBY5WzhoDfCQYeMaC2HoEUHUuqU/IqTax2khFkeqK3MXKVRJ4Vu7rNoHayM7z5mH6RXoauDE/qjeyS6UopcwIQNsqVt1/f8M4Bpw0Hbp9H/DA7wL2grPLHLtoJpjkV1gVEuTMIxi7bV0zLdT3Qh2FtP2qXrhv4hMtWetPW4sBhv6BW1CTfq59ppHVo3SBlrAvLscBKrXc8TByJwnNCJt1hHym2n1ma2V9heF2myTQQmXZRoZrT2gS5oYLrUBxgkDDldAMt5HHoWey/1ER6SaVryFjehpd3WEbCiaecJdMxzGaeeq9iVxal+D3BpjqWdjM893bQ540s5UzevYZPnJedE6jiKeYD9cz6i93B7PNud7vz73/zZAb+03KfeAjlhejscXwv8g3+89/BkMHkoT/7Us3Ng6Qipa/NYT9byME+HQ8l0ifP69ULe0lGHFr8WTjcQ9OMPevCklmc656N4WIgvQXcyKVv3Wucahr7ZlnSULbsuw8uBIC8QluXQvi6h18307uSyws0t5eSdtoVWv/Q0JCagp+VDV9t5tQ/eUl9nk7pPlo/e5pG55eo2aCXf/bMe1JOH8ax3p1+Hc6O9bBv3x3nN3zLX5cav24DV41e3Ua7tVrexjRu3VyLoLc8b2hifzq7d/EdefS5YJ+dE3FW+tR6dDnrKXit7PQk9jzsYakj7bOjJ8txetu7Q2EaWk3okt1bfyeLpX/6ls1cS2h97C1QPQvTGOL4W+MVP7Z+fzA7f7pPazhmNCSbpGLoVp4KjHlvZ0LMrE22zbsQ9xlyd6PpdgdR8YtUjHqzwsjxRO0GT+5KTCCq1Q7FcOx5WCtDacglnxcIqQSxLsLN+lgseQcy6uA/USV70gIde9IPcjhxnh4yaX1fOp4mo03f0oww95ZmeKKJvXkllv9MGyEameWU9+Xk1SBv6aqtWX4jSd49Kyj6xE0FgTpmUaU6aTi9gHpfUKWUmPtvfHo9OL2i6ZBt3+ro/xkl7YdAON/XwPEm9bBfTed7YTu4D7dDXcih7zJLesrIPprVcVoU5N9YH3sTnAof79jm+NQ90pY7NrC+5x4Yysuo+g5+w5XOlhnks6Ysvrjoe2afaTpaXML3CVM436wXv2k7oMFiMvvprv3DPi+jYp94CtsDSRDawz4+fBf6HX9t/38bm/G3cW03niKPpHBnlTfkK2tlGjLZwVDgQOSY5S31isgRVHFjC0yHKYZZ250FUHYDzm7CbER21DS1eiWtebE3n9iJkdnw38iMo8BSsbnsWR4qzqvVBf/hbt04NaEm17jvitReBkMBMAAEDW6AvzhBdgKXTtZ6dHbt+YCdstyFaB3hk1jZcpYP/kWg2i/2X7ZJ2yDHJPqEJKfnSnuOWerqcON3FkXWc6Z70aLgZtgeH8UY/25ncv93rINO1bahNjxKXCxrouzEoc6YKWNYxc7DzAgO+8ASCrOSXY+hxd79tu9U69Pr0eVxYwSd1dGBNOcBJ2CRxNYc1x5iDOT45Fu4PMsD3OHseWXZ3UQGPtB2wpOlku9+dTjn+wJNnfY7leQiPTn7qBQw5up3x/D/82OnL1PvUW6C2QDjxGtCXj68FPvZP9t4zPpi/U/cYNW6bcjQ4fpyDg4Sdeq6Ku564HSdRt8X9XF3B58rCDttX7+DCgxXsSL9DfqTbf8ZZ5gNfVn3w6finnrkC73TstMrSZtBaDiuf4UgBpt0qPpITE86s6ysrlcQ5krzENVfrkfWu37layy1xeNNuXZdpzClz02HrVVkd5qaK3Xf1sZV+Nzkde1XOQOALp8629Hl7e1M09JFEAMKO2eeaX7bn0fpTMw6wbD3SuGVwyXp9TLss25rgtWyfm49ZPd457h0uvEkZtNwP9V16MRc2lXe2qvuQdHm8cUwIfptlDuZFRyezpsxy17e0oeU4rylybuc8X8+z7lOONTQHB0fayXFw9hgsz5PpYvaVT/29+16p5fXl3gK2QDlZXe3z426B/0YPZu1s7jzglQv68qSu9Y4nj7WKo32oq3serGKrjMCJU2IFpWViu/JIh2NqAlvSOrB7mw08PR+tx31y2zXeSZVfquV1XLLEanQ8mOjbgLk6Go6OFtMjfftqM7eGaxk4ZX2LQbryvu5mbOFp2RP8zde65AVC2aYVzmC8OUQGH8lGn8TnYa0jXiDNNla2wY8AUDvULHtlSZvlwMcXI0mzerFje+Vq3bbDKWefpdsidbPMGCtdUOT4JT/GJvGTH08D62aApGc7fFnlYc8Y17CR+4mW6musSLFh9g85cBi19hDvMk86G0FLWpaDLr6nmXOI7YqjxWhrM+7nQtGOATxFbrnQEZPQ1XMu8GMupp2QBw47BwRkLqg6+8Jb46i5ANS2wQbUs/+eo0C6hK48iKbgHbgeR2RBlzZWhTGW3mkH6k6566EXkfNHMwS2/LQRePo1CfVN72uNYh4f6GKgsLA8bKNrvMlkcebip/7eYN/c+7y3wKoF+gC8apETUP/vP/P1ezePNt6tQKpvIWhlGisKrYhnR3oneFPOxysMrtZZK2cCCo5WEvp1PieVSmW0jYMUtla6zUa5vzlhS7esPoSojVYdtbqaabUr2eKnfHOADK/6ZqOyQtcqMHHKCvpIdHJO4KdQ60yAdln6C48k3OjPCD5stUoI8nndCee9pIva4Y2jVPAaysXP0QMcklfQtW7tqhF9JTLliQfiN6Gjn+iQsNyeBq+zeeBIn0Z2Mm/k6TscqTMV6UAfKGEP8pYO/dhZEBz72V4tHrbILqTJkrg9olNHm/2gMXWdDNE9gsiB+iA+lGUgjWkXeFJWdFqUyl0sUnKs05Y59oyhtqH1oYzMUwfIYuyKnAx4Ma7GV981n/TWlbfttcrXWJY5KwaMAaq1MGzXXqCEhNCqHvuiZtq2nTvWqesMZmQeMP9yPDTH2V2JC4HuIoj+x1ZzjFU3B9q5EAOSuhhW6zMezQ+2X733Kxcu6NTsU2+BW1igOINbYPRNx9ICFy58cfPa1jvfqy8/bDVHclIKIlyZx/eD5WTYrvOWJg6aTuDgNxVYjuSk9E17fbNRgbM497g/HHTg5j3F8GU4UwW3jrccepEFT8uDr358bTHGwSshg6TlbsBoA5cg6TbTzLUspuyUpEfSdxD6OfDRDq37QL/Qi1c9oDYd7b4XvnqvGptke97HhF/YSnrBw3RoT7+xGX1Qte0r5bRp2ok6/SMn1TZJu2pFFPY+KudbN170PS4rJDx1yT7ZjugzUzAflRUh/aVttV/YFR2SX9o9dclXiyi7r8ZFz7y4ytWlbZsydZ+00EBL8pzCHvr4lfSWlYRE8JkqiGkw4jWm1oZqpt/oC+/kkf1jRY9tffEQjYWX6bM/Wn2H7TTGxUbI945A2oL5qc+IxvZ2jqHnes676mE5yWy0wdJokY3utV2zT2hS5oTmCjXPTfch+59jSRsyso96umG4//Vf/fgDz0PXp94Cr2eB4hBeD61vP64W+KXPvPbOo6PF2+VI+fqhVl1eYWkLsARedFfgiZWvy5njALfKHMBByiOl81GQPMThhgMyH3xoOkHakEMgIaDyWuNWtOH40AFdTJeyVuUTJA/Ff0s8MgiFQxdPBRcFyU5ny6UPlglPkgOc8WOFFbZA98MIytnHcKrRn6Q5jL6jfxcIIrAJnhcRKSHpoEE/cNF5sDgabmxtxgNfqQe6dTZHZ/gkf63ySrAxTvILnNApZXVH9wsItsz7szlG8ATe2SVt3Y2ZVpiyLfafzTajP9Bk+5Zgh7LvVtgu+Sc/ZJp39hPZWu1HX7pxZRygX02djTZj/KwfeOadOKbEnqmfIeSpa861yWFnZ+SmHT1nu50D7CPeYRfRx1jBC/45Z5Ofz4PsHxcBnX2sI3SZcl4b3o1hB0+8o2ZjePpoOrt6+dd+4V27pu7z3gKvZwFN1D6ddAv8zG8vNs5e3X+w2Rqe5ofX9ZOkg5lWVvwWun4LPvLso4Kb4IvBpj7odKT9667NeJln4I2AE/Sb4pNX/PCBb20zaBIOnZxqkWk48jqdzFvh8fBI3xOug515p57mSZ8IeLrpFnp0eaeHZRKgM6UepdJm8Nra6uywjq+RLSf1l/NXvyhDA05n365P9N/J+NSx3xbfZJbDr+lpOzocDDe3dNuzsrVlp61TX8OgoWxbU6/Tsl4ZtJHvcUMO+DfDSxuBcaMtV3VIvh6Xer7VY9gsDhWzsDvJNLYVNhmXizDaAkkH9z3xOht4PnR4aQvq8IKH5xU80r7cSlmeE2lD67Mezzog03O4ng/w2N07evmdv3TPlQv63Qfr1Oe9Bd6IBdrJ/kaQe5zjbYFP/PIr981Gw7cNNvXJnXC4GRjS4WZgqB1oOth00AQHAiIpcbrA2DnqslIKB550o/GhHB4rkpoWZ18H7U05X/h3Tj/l1PxCdDks80JPHDROEL44QuuaBDj21Ge9Hnmh0dlBK/e4OElnD09Wy6xsSRkEjIMdOn0IntajCxbgHkaQOb2zJd2CjQ6pUwZeghPyal21ZRn92lxMtSodx27Ecj8IWr5QwfF3MrtxQnZK1Kq2BLBuDDvdM8Db5qu6JB62JYjBz+PufpDbVvr8c+U73Cfr1Nm163NqaJ6eDzXvzjbgLvME0o3fje2Mi+2TfU8dwExe5NlHbMoY2la1LLDSBr64Sz2y393cAE+Pdu1fP3Pq+X/6d/XMXJ96C7wJC1Qn0Zug7kmOpQU+9uuLt41m1+6TkxwRU2rHm8Er1cYZZgnHfRgrJNqB0UYgyTqB6TCc1lg//docDIbT8VahPSyOMTnOOY65AAAS9UlEQVRxxLmS0sk1g53TW+LlAHcYPB2kalwC4Hh0GIE2OQDZavakG3U771HIdpRL3cB0H0ybjhQ9C66yrXu34kJgPD7Qz+hlECHwod+WlRED6junsUHqBH9gKRsJlm9ptZ2tU7bB3wHWPKxrBt20VWKnfZDnOnbMvjBe6EOQJGBzYZG29RiT04+U42Db7XQUptFXcMEjeS6Yj22S8M627suqnLF+WvjQrzGV8UkcbNmNHXNhb5e51o0L+mKPGo922wg+tY6hcNjBcyXpjYNdSreiX7ad+5T0y8daH/cRW6ODMdETuw+2NnS1derl/glnW6bP36wF2sn1Zhn0dMfTAj/z23+6cWr/O982XExPEzC3trfmu5MD/ThbOvNmW3rr9+6nY35Pl3uMTYCoUx6Hg1ThQEhk+iskUR+Dh+9WnICeHy8f6xsPBItA4LC9rV8AOhhAN1V7wJEpB6mmYA0fnDdtlgFu8Gp1oT0JHIzkBeeDrcMh6m1RXhwOp/qZQOTRx1C20OCA4X1a7diA/BBCKTEeHeh9zuxb6s67sPGLic34tBy/2iwT/grJw+hv9F94dE5pqr6TU0WW+1WXaSeFHCFGH9VXaIONDsXcwSfGIn7fWG9aFTzoaxm2PfBICMS40lMb5u2WaKtfIc6+Ji42s208P2BDAp0DeqEDVRL8rJPHvqPZlg0Osg9lPjDm8I6xFz24thH8nOgz84H2lJ0KW/6WoDPp280nPaOle+RLYyTuoZ/kRfAttgs9pcd0V3O3XN9gv5SQGoxnGmPNq+YQ22kuCA990Gu4OZ+MTp195Vf+zuA169vnvQW+GQv0Afibsd4JoL1wYTE+fNv1+2f7R1v6HdeN2Xh7MJoeaHWRqyIc28YZueqDhX6GcDBUhNGP0mcQpnvgTbQaxgnVcNociMI5amU82Fagb7b0s6xyYEqsnsABPpp2zjtoFeDH4u1VDgEfOmjgRwyBFlzkUmbFur29Jfd6mM5ZbbESF0E4c+lw/To/Hp+6phPH02r1Xulv/rGyqrwv/YzIIBhg20hF/Rxs2mjVBvDSN4kHEGBDty/rrr6Ou5UU/Ejwx97Y3StQw6nTD/o8nSY9OmBHXxw5yKHtYSPbqS3l6sJC8qzztow51UrOunq119VT1nXJqscZXtCmnOQRV1yVPdGRlS/jjoyYL9KDcdIvKWo8st/orCu2IXZCT8ZmI+agV8JaXWpe2n7YwWNGTgBkTEj1uCQkj8Gz2KiGu4wO6Jj1nBeUsRM545dzLC8QPAc2Tm8evby/e+2ffeKdfeDFUH16yyzQB+C3zJTHm9GFC/rl++al7b1TZ84ezQ/HI1aLcoSKvArL2wtWFSOtFPQ78W1Oj+L1Djk/w93L1bqDmtudT6fbcqr89m2d5NRFQJB1srOlbt7k1NErQyIulpWYVrB7B7rnlwHP+ODA98w9ctgTX0QgRCFEpJZn+mCmA/0HxzpsaJX02i5BpNOllm8867e1w4/bL/cxdcLG+1JTW/YKbluncPC+kFjmPd7YV58UiEtfvbpEL/dvuQ+rfaQ3uhDZ6ODI2j7VNNdfGwzok3mDVyfzJ6cvB/v7cUHT4aQN3Sfmiq6qdLGh1aTmUNN0+ObV0WYgxQY559Ie9ZzrcJflrOppPMYPe1sW+USrXcaLNvRPeXlBQlA3Lu3wqemp005Osp30rdTD03unr164EBso2dgfewu8hRZoJ91byLNndcwt8PO/+vxpbcienswmclmn5HD2wil1ap+Kbb4MTP6Qjzy5HC34GaxxZG5LyoF+WZet4XDIG6diazVx2aKmvh/zbUMOcaLAnFTJQ6+7DggWEwUNgk8Go8UC3AOhaI9ZfE/pR3wPhuDtHWzPKWfwgy/6kTodqek7FVXfOpxaHmVwSeBTd47zxmlPpnst3DawvsYHrl/Okc7Zz+SITAUo9V9xQavlfQUD+OdFT+qvnQAFlLmCGu0Ovp1ep5qtnT2ZYGeIfeBHm+Ujp9YhbVDDUpPumDpNpqdCV9OSo8/s6HDkcQQGXTcXbhx/06fep4SfYwpdPe7UsVHcLoh+dONjHs6N674yHthWE0yBvBujdfxNAw/0hm5HuzAEZts927Bl9sd1bKIn3fZ3j76++9kLjyxfqYDUp94Cb6EFWsfzFvLsWZ0QC3zuc4vRn7187d6Dw43t2dHBCLVPnTrV7LMCisC1o5VCF0zUpNti2/wkXpk3ewLs6G9PeASqU1WwY5WxPzglhz5peezkdq0cNI4OOgIsgQneCRM7JQKR61kmGO8IplWN+N3oeJMOeEeLfk6pJ/omfQbmDXSWUyfAdm15sZA2QBfk7oV8nHsGwYTD3fbCBqd29Ou8yk0Dzw2CR2sDKNAl7eN+ZP+LTsUm4Bie9pUNpG/a3zbv7II9SXmBA6+U043PMgwdwUf/zv7JN8eNcV61IRSkbuyz3tnXbavjlnjWMW3a7VS4r4yfVrSydzenmCeJz8p2MTg1T5tiZ+ZJ2mVfuyI5B4Vf7FTbftUug8V+8pK8+YYuOyZnDt7+SnNdK9723nnq3B97C/z1WKAPwH89dj1xXC/89nM7ckCn9icj3rtoNo/2BvrA1mJTnzO2C7aLPXXm1HxylEE4ndhivrGpwCDYppzZkZxn5mxPdkEgjaKApN+PH5za131ite3t6UNeOwU/g+BOgpupdLBMYODDGyeMYz1SMLYccrFqxuKVcjhmkNgcqy/CtS7Umz0x3FG7/iMfbPSajg9G+ojvYkzfoy/swutBn63tGf2zTtjG/ICBD48uhcLBc7KRdlns63d6N7ig2dEqEOe/mG9GEJQNpjuLsIvgnT2QXYKEdNpXOc2QvKP/Gh90QQdk03/3F962EW1pA9sEFXT/WX0LI4hlrQP46J12Fs+Qk+Nj/jvqB3LhGHJV7uwClHmEfjm+aWvtEGyqL9cZ/0wdLeOQ+pG3tKWPxs88+Rt9KhzmSD3OxksbZxtjCm8uYubD7en9w9P7X2+ePvzNn/32Gx9rXxbY13oLvOUW6APwW27Sk83wp7QqPnep2RzOXzu9NR6OJhtyWHzbR5vWk6P9wY5WH1TTORKgcfw7iSIcCvqJOn7urQ3gDuR2rlGnveAFcZjNzpdKlglYrHjAgSd6GD/57g025OBDp6IrcNAmERDk1NU42NkfbkxO8VN9ESg3Nwpd8M3gdTRRoBCPVqZ40L/gL7zTYYO8V9j1SUikSq+6bF1A4Xcj9OnhxW7hdRXekklb2KvVresnQXCxp0AtfQlk9Oms8j2CcT0WhTZ1zDGBL/KRi3rY1H2hFrj0VxcWBH90g78vLKgjB/t7nLHfRLqgQ4erC4iVfsBbl0rD1D1thsywDblskJl0Knb3mGeL55H6XdrDdmrM/uSFG7jMRdPAIwJ+sTW4u4Kd5uJN/aGfZ0b66OT99+41zzZHF/rVbme6vvQtt0A1cb/lsnuBx9wCP/VTi9H9H7q89fbNM6f29DVj7sNuEeSUwmlrJeMuXFdUOSOve12O9f63yUnr0diuTc/OsppawgeWwS35ZflQDh4Zq/zNC6dPEAkaeMqhgotHN9y4wA4npwu/jq5rv7EfbluVvylZr1yV81ZgoY/uD2USwUHRZnioYHHmNMDTkp19CQQdlnQn6BV71HDjOseuWxtnbugfctGFZNtneb39wUUfcLAv/XlNgd3jaR4ZVE+rPwrIW83iyivNoJMDdTduq/3L1uXjqh1prcfL/VjFW1eH9lDjbdtTX02mq/kyb8dHV2fNvef273u1OeyD7qrV+vrtskDrJG+XAr3ck2EBVsann2o2zr/tlc33PTwcXr2aeu+cziCMQ9fvBesjCwN9eCNzMNx+5Yoc96bvHa/vM7jmAwa8mgZBZ4NP1pMn/O6/3zhyzEeLBXXSOh0MW9ceRDqcPcuqq7uoMI3lGo/c8lbb6EOtm/tvPOrmC5/VMjaCN21ONc0qH3Dcjv6My6pMcNbpa7qax83KNc9ajvW3XjeTA98at+N3TfPlvtYm0M8mw3Z7GjqPy+kzi8VLL2Sbde/45LwD3+nyS9PZF58+nH3ovnN90LVR+vxYWaAPwMdqOE6GMgvdwpWmw6eeemq0s7MzHOtR4Tei+QsvjAYPPviQgsulQB/pS/8zfeG+pk2cmX5AwG3n9HH+y4PnnmuaBx807rnmhRcuBy/aoJ/NHhLN5RV+HV7KuCRe5gsk2ym9+93w6Phbx1WcVT2MB1/aSOjpfiRET+OW9q4PbmnUl1H0oWvLPqNP3dbxeEhw+n+jnI5rysw+nQswNO5n6pc2s94gwbO2kftRw8AznHKXUk6OQ45zrX9tS+tufeBhXMpur8vAqJPATdpuPukVtPm1a9fmP/ADP6CfA+kfpEpL9cfjbIE35DiPcwd63W6/BRyQpQkrl+GlS5eGX/1q0zz8cNM4n07PyXlebC5fHg+AUx+PL+k90mk4VeAPPZQ4BHTDHdxdr3tb4wFfxj2vevKHN+0PPYSs8ypdDNxah4429QKfhNy67fLlS9Izde7gyZc2aCxntd7JTXp0sY7reGEP2uFJsg1qXNuTdmyNbNsyeZ8Lu9OecLcv98ty3N9aFuWaZz2mprNs5KSNkYetuj50dMuyL168qE9jel5km3HhtqqL+0/AffTRR3liOf4UdGMuQdOn3gInwQLtyX0SlO11PBkWUEAmEA+efPLJ4X333Rcr5On0/OLRRxWCLl6MOVc7ejnRgJ8/f35BO7jjMXk6Y+fret/hng/nC535gG9a8qaRAs3TgCPhyKGvYTQYXusL3LIok5Dz9NNPBz71VV4OFLSRTJ+6JAyd0Nnt6JLyHaS7dlMY13R1veZ96dJ4cO5cZ5fEm2oc0t7Wx/BVfYHbljUucJJteunSRdk8+2eb2Ra2Jfg5pjm21BMn4dRXk2UiBz57e+fn+/tPLrTC7QPuqrH6+om0QB+AT+SwnSylywqZuTZ88slmcN99Tw+Pjh6NgLm5+XTMQQWFxVNP0a+n+AH0CvZU88EPfrChDVzjmQ4+LtdW0Y+ni/8HRauQ9vTT+k3bxEu5CPogv18sOV1Aht54q8F6uY1al0yDzNT9UfF5akV+toFDf9Cp49CVzKuD1DrV0K68jobWTp/ExXa2BZDabm4DvkoH7OYp+0q/TbfMa3l86raap2ndF3KCLThsKStb9Cvc2mJ9+U6wwNLDDndCh/o+HD8L4Di5J6e/6Q/+4GAiJ3ykGDTR3+zSpUdn3LfT/WQpHhG4Ufsch5wBWVCBCaQ1jDJ/0IBvmg6OHZ4SbbaLPvDJacn6UwtkQyP6tj3rTcBLW5T///bOILltGIaikrvOSbKMD6BL+D4+j30JXSDbXiKrjHdpOyo+SFCwrHjSmSxq+2lGJgl+AuCTJpC8iOUv/KtARD/sVljlx7Q/VWQ9N8WXTgW/tKauNo0j9/d3rdNDSdHn/WRb0ZV1y/gxjlY5yGfEsIeftsfic95D5CSt+ET8ZZtzLn3/+tf3pnjiacutLdcwuEcOOU7NzXOyfwaiPP+Y/re1H8/P/cd2u/2ls947ft2UGwcE7oXA6lP4vWyOfdwOgfqWrIR1T/bjOPbDMGjsh96cu+41hl9q7c1psq/BF/f4i71RddW+1r+MIz8W0L5Sj7Clc25/1ZtaZ/FCpLGvM0MrHpf5NHnqvFj/0t8s0LzeDE3Vwrn+Yl/KobDTijlv5aF87VhhJLO/eXpb9lRihg+brZq8t3N2c+w5t9PpNNl1DR5e7PWA5s74gMCDEVj8cXqw3bPd/55ALszH47Hf7XbdOHqRttxHO4faWpOOWrynWsit1Zqxiz/+soe8as3vWE2Dta6ttjbOfqQN/2mtZVQeHKKo6GEibFqzpnWbrXN/T09PvQqVi+1D/sKHUrShz5lNDym+ZqnNY+tLr/1W7WBdz8nt8q1DcexY1Wri/Bg8D+Uge6yNnGRT/+1tmOySRaGV2XNXhwMCEIAABG6QgApzOjfW3xwOB/tl2OmH2nJOdVxsMaf2X079z+zQh+/sK9uqznOR3caeW7bH2ryuamu+ZR+LtS2H6sv22PJqMbLP0H0xnnxci3G2l7y3/X6vte163ODtRMoQgAAEIPCNBLwgmL9WGOwnGTcqFvm0wuHj3Kq/PLV2TZOKT16jmM1v+KrarFvr9wud+yr+5rwiH7M3fbJZ7MjX26aJXFbaFifmgpNi1OvSWH7jdcIVBCAAAQg8IoFaXKLAdGV89jbXio7m1k7jtmpPWhVa19TCeFWv6xD6T9rm75P5KLhX42itRfK9l/4j3gHsGQIQgAAE7pLAsrCtjZe2DEJz1+azlj4EIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQgUAn8BrzesdviE5ggAAAAASUVORK5CYII=";

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/permission/user-dialog/index.module.less
var index_module_default17 = {
  "sheetPermissionUserDialogWrapper": "univer-sheet-permission-user-dialog-wrapper",
  "sheetPermissionUserDialogSearchInput": "univer-sheet-permission-user-dialog-search-input",
  "sheetPermissionUserList": "univer-sheet-permission-user-list",
  "sheetPermissionUserListEmpty": "univer-sheet-permission-user-list-empty",
  "sheetPermissionUserListEmptyText": "univer-sheet-permission-user-list-empty-text",
  "sheetPermissionUserItem": "univer-sheet-permission-user-item",
  "sheetPermissionUserItemName": "univer-sheet-permission-user-item-name",
  "sheetPermissionSplit": "univer-sheet-permission-split",
  "sheetPermissionUserDialogFooter": "univer-sheet-permission-user-dialog-footer",
  "sheetPermissionUserDialogFooterConfirm": "univer-sheet-permission-user-dialog-footer-confirm",
  "sheetPermissionUserDialogButton": "univer-sheet-permission-user-dialog-button"
};

// ../packages/sheets-ui/src/views/permission/user-dialog/index.tsx
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var SheetPermissionUserDialog = () => {
  var _a;
  const [inputValue, setInputValue] = (0, import_react26.useState)("");
  const localeService = useDependency(LocaleService);
  const dialogService = useDependency(IDialogService);
  const sheetPermissionUserManagerService = useDependency(SheetPermissionUserManagerService);
  const userList = useObservable(sheetPermissionUserManagerService.userList$, sheetPermissionUserManagerService.userList);
  const searchUserList = (_a = userList == null ? void 0 : userList.filter((item) => {
    var _a2;
    return ((_a2 = item.subject) == null ? void 0 : _a2.name.toLocaleLowerCase().includes(inputValue.toLocaleLowerCase())) && item.role === S.Editor;
  })) != null ? _a : [];
  const [selectUserInfo, setSelectUserInfo] = (0, import_react26.useState)(sheetPermissionUserManagerService.selectUserList);
  const handleChangeUser = (item) => {
    const index = selectUserInfo == null ? void 0 : selectUserInfo.findIndex((v) => {
      var _a2, _b;
      return ((_a2 = v.subject) == null ? void 0 : _a2.userID) === ((_b = item.subject) == null ? void 0 : _b.userID);
    });
    if (index === -1) {
      const select = { ...item };
      setSelectUserInfo([...selectUserInfo, select]);
    } else {
      const newSelectUserInfo = selectUserInfo.filter((v) => {
        var _a2, _b;
        return ((_a2 = v.subject) == null ? void 0 : _a2.userID) !== ((_b = item.subject) == null ? void 0 : _b.userID);
      });
      setSelectUserInfo(newSelectUserInfo);
    }
  };
  return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)("div", { className: index_module_default17.sheetPermissionUserDialogWrapper, children: [
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("div", { className: index_module_default17.sheetPermissionUserDialogSearch, children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
      Input,
      {
        placeholder: localeService.t("permission.dialog.search"),
        className: index_module_default17.sheetPermissionUserDialogSearchInput,
        value: inputValue,
        onChange: (v) => setInputValue(v)
      }
    ) }),
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("div", { className: index_module_default17.sheetPermissionUserList, children: (searchUserList == null ? void 0 : searchUserList.length) > 0 ? /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(import_jsx_runtime41.Fragment, { children: searchUserList == null ? void 0 : searchUserList.map((item) => {
      var _a2, _b, _c;
      return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)("div", { className: index_module_default17.sheetPermissionUserItem, onClick: () => handleChangeUser(item), children: [
        /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Avatar, { src: (_b = item.subject) == null ? void 0 : _b.avatar, size: 24 }),
        /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("div", { className: index_module_default17.sheetPermissionUserItemName, children: (_c = item.subject) == null ? void 0 : _c.name }),
        (selectUserInfo == null ? void 0 : selectUserInfo.findIndex((v) => {
          var _a3, _b2;
          return ((_a3 = v.subject) == null ? void 0 : _a3.userID) === ((_b2 = item.subject) == null ? void 0 : _b2.userID);
        })) !== -1 && /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(check_mark_single_default, {}) })
      ] }, (_a2 = item.subject) == null ? void 0 : _a2.userID);
    }) }) : /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)("div", { className: index_module_default17.sheetPermissionUserListEmpty, children: [
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("img", { width: 240, height: 120, src: UserEmptyBase64, alt: "" }),
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("p", { className: index_module_default17.sheetPermissionUserListEmptyText, children: localeService.t("permission.dialog.userEmpty") })
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("div", { className: index_module_default17.sheetPermissionSplit }),
    /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)("div", { className: index_module_default17.sheetPermissionUserDialogFooter, children: [
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(Button, { className: index_module_default17.sheetPermissionUserDialogButton, onClick: () => dialogService.close(UNIVER_SHEET_PERMISSION_USER_DIALOG_ID), children: localeService.t("permission.button.cancel") }),
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(
        Button,
        {
          type: "primary",
          onClick: () => {
            sheetPermissionUserManagerService.setSelectUserList(selectUserInfo);
            dialogService.close(UNIVER_SHEET_PERMISSION_USER_DIALOG_ID);
          },
          className: clsx(index_module_default17.sheetPermissionUserDialogFooterConfirm, index_module_default17.sheetPermissionUserDialogButton),
          children: localeService.t("permission.button.confirm")
        }
      )
    ] })
  ] });
};

// stylePlugin:/Users/zhongjiafeng/Desktop/5000_Project/github/univer/packages/sheets-ui/src/views/permission/error-msg-dialog/index.module.less
var index_module_default18 = {
  "sheetPermissionAlertDialog": "univer-sheet-permission-alert-dialog",
  "sheetPermissionAlertDialogTitle": "univer-sheet-permission-alert-dialog-title",
  "sheetPermissionAlertDialogButton": "univer-sheet-permission-alert-dialog-button"
};

// ../packages/sheets-ui/src/views/permission/error-msg-dialog/index.tsx
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var AlertDialog = ({ errorMsg }) => {
  const localeService = useDependency(LocaleService);
  const dialogService = useDependency(IDialogService);
  return /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)("div", { className: index_module_default18.sheetPermissionAlertDialog, children: [
    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)("h1", { className: index_module_default18.sheetPermissionAlertDialogTitle, children: localeService.t("permission.dialog.alert") }),
    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)("p", { children: errorMsg || localeService.t("permission.dialog.alertContent") }),
    /* @__PURE__ */ (0, import_jsx_runtime42.jsx)("div", { className: index_module_default18.sheetPermissionAlertDialogButton, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
      Button,
      {
        type: "primary",
        onClick: () => {
          dialogService.close(UNIVER_SHEET_PERMISSION_ALERT_DIALOG_ID);
        },
        children: localeService.t("permission.button.confirm")
      }
    ) })
  ] });
};

// ../packages/sheets-ui/src/views/permission/extensions/protect-background-img.ts
var base64 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNCIgaGVpZ2h0PSI0IiB2aWV3Qm94PSIwIDAgNCA0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8bWFzayBpZD0ibWFzazBfNzU5XzExMDgiIHN0eWxlPSJtYXNrLXR5cGU6YWxwaGEiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjRDZEOEQ5Ii8+CjwvbWFzaz4KPGcgbWFzaz0idXJsKCNtYXNrMF83NTlfMTEwOCkiPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTS0zLjY0MDAyIDMuNDQxNDFMMi4wNzM5NyAtMi4yNzI1OEwyLjc4MTA4IC0xLjU2NTQ4TC0yLjkzMjkxIDQuMTQ4NTJMLTMuNjQwMDIgMy40NDE0MVoiIGZpbGw9IiNENkQ4REIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0tMS41MTg2OCA1LjU2Mjc1TDQuMTk1MzEgLTAuMTUxMjQ1TDQuOTAyNDIgMC41NTU4NjJMLTAuODExNTc1IDYuMjY5ODZMLTEuNTE4NjggNS41NjI3NVoiIGZpbGw9IiNENkQ4REIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0wLjYwMjY1NiA3LjY4NDAzTDYuMzE2NjUgMS45NzAwM0w3LjAyMzc2IDIuNjc3MTRMMS4zMDk3NiA4LjM5MTEzTDAuNjAyNjU2IDcuNjg0MDNaIiBmaWxsPSIjRDZEOERCIi8+CjwvZz4KPC9zdmc+";

// ../packages/sheets-ui/src/views/permission/extensions/range-protection.render.ts
var RANGE_PROTECTION_CAN_VIEW_RENDER_EXTENSION_KEY = "RANGE_PROTECTION_CAN_VIEW_RENDER_EXTENSION_KEY";
var RANGE_PROTECTION_CAN_NOT_VIEW_RENDER_EXTENSION_KEY = "RANGE_PROTECTION_CAN_NOT_VIEW_RENDER_EXTENSION_KEY";
var EXTENSION_CAN_VIEW_Z_INDEX = 25;
var EXTENSION_CAN_NOT_VIEW_Z_INDEX = 80;
var RangeProtectionRenderExtension = class extends SheetExtension {
  constructor() {
    super();
    __publicField(this, "_pattern", null);
    __publicField(this, "_img", new Image());
    __publicField(this, "renderCache", /* @__PURE__ */ new Set());
    this._img.src = base64;
  }
  clearCache() {
    this.renderCache.clear();
  }
  draw(ctx, _parentScale, spreadsheetSkeleton) {
    const { worksheet } = spreadsheetSkeleton;
    if (!worksheet) {
      return;
    }
    ctx.save();
    if (!this._pattern) {
      this._pattern = ctx.createPattern(this._img, "repeat");
    }
    this.renderCache.clear();
    Range.foreach(spreadsheetSkeleton.rowColumnSegment, (row, col) => {
      if (!worksheet.getRowVisible(row) || !worksheet.getColVisible(col)) {
        return;
      }
      const { selectionProtection = [] } = worksheet.getCell(row, col) || {};
      if (!this._pattern) {
        return;
      }
      ctx.fillStyle = this._pattern;
      selectionProtection.forEach((config) => {
        if (!config.ruleId) {
          return;
        }
        if (this.shouldRender(config)) {
          if (this.renderCache.has(config.ruleId)) {
            return;
          }
          this.renderCache.add(config.ruleId);
          config.ranges.forEach((range) => {
            const start = spreadsheetSkeleton.getCellWithCoordByIndex(range.startRow, range.startColumn, false);
            const end = spreadsheetSkeleton.getCellWithCoordByIndex(range.endRow, range.endColumn, false);
            ctx.fillRect(start.startX, start.startY, end.endX - start.startX, end.endY - start.startY);
          });
        }
      });
    });
    ctx.restore();
  }
};
var RangeProtectionCanViewRenderExtension = class extends RangeProtectionRenderExtension {
  constructor() {
    super();
    __publicField(this, "uKey", RANGE_PROTECTION_CAN_VIEW_RENDER_EXTENSION_KEY);
    __publicField(this, "Z_INDEX", EXTENSION_CAN_VIEW_Z_INDEX);
  }
  shouldRender(config) {
    return (config == null ? void 0 : config[D.View]) !== false;
  }
};
var RangeProtectionCanNotViewRenderExtension = class extends RangeProtectionRenderExtension {
  constructor() {
    super();
    __publicField(this, "uKey", RANGE_PROTECTION_CAN_NOT_VIEW_RENDER_EXTENSION_KEY);
    __publicField(this, "Z_INDEX", EXTENSION_CAN_NOT_VIEW_Z_INDEX);
  }
  shouldRender(config) {
    return (config == null ? void 0 : config[D.View]) === false;
  }
};

// ../packages/sheets-ui/src/views/permission/extensions/worksheet-permission.render.ts
var worksheetProtectionKey = "worksheet-protection";
var EXTENSION_CAN_VIEW_Z_INDEX2 = 25;
var EXTENSION_CAN_NOT_VIEW_Z_INDEX2 = 80;
var WorksheetProtectionRenderExtension = class extends SheetExtension {
  constructor() {
    super();
    __publicField(this, "uKey", worksheetProtectionKey);
    __publicField(this, "Z_INDEX", EXTENSION_CAN_VIEW_Z_INDEX2);
    __publicField(this, "_pattern");
    __publicField(this, "_img", new Image());
    this._img.src = base64;
  }
  draw(ctx, _parentScale, spreadsheetSkeleton) {
    const { worksheet } = spreadsheetSkeleton;
    if (!worksheet) {
      return false;
    }
    ctx.save();
    if (!this._pattern) {
      this._pattern = ctx.createPattern(this._img, "repeat");
    }
    const { startRow, startColumn, endRow, endColumn } = spreadsheetSkeleton.rowColumnSegment;
    const start = spreadsheetSkeleton.getCellWithCoordByIndex(startRow, startColumn, false);
    const end = spreadsheetSkeleton.getCellWithCoordByIndex(endRow, endColumn, false);
    const { hasWorksheetRule = false, selectionProtection = [] } = worksheet.getCell(startRow, startColumn) || {};
    if (!this._pattern) {
      return;
    }
    if (selectionProtection.length > 0) {
      const cellProtectionConfig = selectionProtection[0];
      const viewPermission = cellProtectionConfig == null ? void 0 : cellProtectionConfig[D.View];
      if (viewPermission) {
        this.setZIndex(EXTENSION_CAN_VIEW_Z_INDEX2);
      } else {
        this.setZIndex(EXTENSION_CAN_NOT_VIEW_Z_INDEX2);
      }
    }
    ctx.fillStyle = this._pattern;
    if (hasWorksheetRule) {
      ctx.fillRect(start.startX, start.startY, end.endX - start.startX, end.endY - start.startY);
    }
    ctx.restore();
  }
  setZIndex(zIndex) {
    this.Z_INDEX = zIndex;
  }
};

// ../packages/sheets-ui/src/views/permission/panel-detail/PermissionDetailUserPart.tsx
var import_react27 = __toESM(require_react());
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var PermissionDetailUserPart = (props) => {
  const { editState, onEditStateChange, viewState, onViewStateChange, permissionId } = props;
  const localeService = useDependency(LocaleService);
  const dialogService = useDependency(IDialogService);
  const authzIoService = useDependency(IAuthzIoService);
  const sheetPermissionUserManagerService = useDependency(SheetPermissionUserManagerService);
  const userManagerService = useDependency(UserManagerService);
  const univerInstanceService = useDependency(IUniverInstanceService);
  const selectUserList = useObservable(sheetPermissionUserManagerService.selectUserList$, sheetPermissionUserManagerService.selectUserList);
  const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
  if (!workbook || !worksheet) {
    return null;
  }
  const unitId = workbook.getUnitId();
  const handleAddPerson = async () => {
    const userList = await authzIoService.listCollaborators({
      objectID: unitId,
      unitID: unitId
    });
    const currentUser = userManagerService.getCurrentUser();
    sheetPermissionUserManagerService.setCanEditUserList(userList.filter((user) => {
      var _a;
      return ((_a = user.subject) == null ? void 0 : _a.userID) !== currentUser.userID;
    }));
    dialogService.open({
      id: UNIVER_SHEET_PERMISSION_USER_DIALOG_ID,
      title: { title: "" },
      children: { label: UNIVER_SHEET_PERMISSION_USER_DIALOG },
      width: 280,
      destroyOnClose: true,
      onClose: () => dialogService.close(UNIVER_SHEET_PERMISSION_USER_DIALOG_ID),
      className: "sheet-permission-user-dialog"
    });
  };
  (0, import_react27.useEffect)(() => {
    const getSelectUserList = async () => {
      const collaborators = await authzIoService.listCollaborators({
        objectID: permissionId,
        unitID: unitId
      });
      const selectUserList2 = collaborators.filter((user) => {
        return user.role === S.Editor;
      });
      if (selectUserList2.length > 0) {
        onEditStateChange("designedUserCanEdit" /* DesignedUserCanEdit */);
      }
      sheetPermissionUserManagerService.setSelectUserList(selectUserList2);
      sheetPermissionUserManagerService.setOldCollaboratorList(selectUserList2);
    };
    if (permissionId) {
      getSelectUserList();
    } else {
      sheetPermissionUserManagerService.setSelectUserList([]);
      sheetPermissionUserManagerService.setOldCollaboratorList([]);
    }
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(import_jsx_runtime43.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(FormLayout, { className: index_module_default13.sheetPermissionPanelTitle, label: localeService.t("permission.panel.editPermission"), children: /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(
      RadioGroup,
      {
        value: editState,
        onChange: (v) => onEditStateChange(v),
        className: index_module_default13.radioGroupVertical,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Radio, { value: "onlyMe" /* OnlyMe */, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("span", { className: index_module_default13.text, children: localeService.t("permission.panel.onlyICanEdit") }) }),
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Radio, { value: "designedUserCanEdit" /* DesignedUserCanEdit */, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("span", { className: index_module_default13.text, children: localeService.t("permission.panel.designedUserCanEdit") }) })
        ]
      }
    ) }),
    editState === "designedUserCanEdit" /* DesignedUserCanEdit */ && /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("div", { className: index_module_default13.sheetPermissionDesignPersonPanel, children: [
      /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("div", { className: index_module_default13.sheetPermissionDesignPersonPanelHeader, children: [
        /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("span", { children: localeService.t("permission.panel.designedPerson") }),
        /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("span", { className: index_module_default13.sheetPermissionDesignPersonPanelHeaderAdd, onClick: handleAddPerson, children: localeService.t("permission.panel.addPerson") })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("div", { className: index_module_default13.sheetPermissionDesignPersonPanelSplit }),
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("div", { className: index_module_default13.sheetPermissionDesignPersonPanelContent, children: (selectUserList == null ? void 0 : selectUserList.length) > 0 ? selectUserList.map((item) => {
        var _a, _b, _c;
        return /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("div", { className: index_module_default13.sheetPermissionDesignPersonPanelContentItem, children: [
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Avatar, { size: 24, src: (_b = item.subject) == null ? void 0 : _b.avatar }),
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("span", { className: index_module_default13.sheetPermissionDesignPersonPanelContentItemName, children: (_c = item.subject) == null ? void 0 : _c.name }),
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(
            Select,
            {
              className: index_module_default13.sheetPermissionDesignPersonPanelContentItemSelect,
              value: "edit",
              onChange: (v) => {
                if (v === "delete") {
                  sheetPermissionUserManagerService.setSelectUserList(selectUserList.filter((i) => {
                    var _a2, _b2;
                    return ((_a2 = i.subject) == null ? void 0 : _a2.userID) !== ((_b2 = item.subject) == null ? void 0 : _b2.userID);
                  }));
                }
              },
              options: [
                { label: `${localeService.t("permission.panel.canEdit")}`, value: "edit" },
                { label: `${localeService.t("permission.panel.delete")}`, value: "delete" }
              ]
            }
          )
        ] }, (_a = item.subject) == null ? void 0 : _a.userID);
      }) : /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("div", { className: index_module_default13.sheetPermissionUserListEmpty, children: [
        /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("img", { width: 240, height: 120, src: UserEmptyBase64, alt: "" }),
        /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("p", { className: index_module_default13.sheetPermissionUserListEmptyText, children: localeService.t("permission.dialog.userEmpty") })
      ] }) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(FormLayout, { className: index_module_default13.sheetPermissionPanelTitle, label: localeService.t("permission.panel.viewPermission"), children: /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(
      RadioGroup,
      {
        value: viewState,
        onChange: (v) => onViewStateChange(v),
        className: index_module_default13.radioGroupVertical,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Radio, { value: "othersCanView" /* OthersCanView */, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("span", { className: index_module_default13.text, children: localeService.t("permission.panel.othersCanView") }) }),
          /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Radio, { value: "noOneElseCanView" /* NoOneElseCanView */, children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("span", { className: index_module_default13.text, children: localeService.t("permission.panel.noOneElseCanView") }) })
        ]
      }
    ) })
  ] });
};

// ../packages/sheets-ui/src/controllers/permission/sheet-permission-render.controller.ts
var SheetPermissionRenderManagerController = class extends Disposable {
  constructor(_injector, _componentManager, _uiPartsService) {
    super();
    this._injector = _injector;
    this._componentManager = _componentManager;
    this._uiPartsService = _uiPartsService;
    this._init();
  }
  _init() {
    this._initComponents();
    this._initUiPartComponents();
  }
  _initComponents() {
    [
      [permissionMenuIconKey, protect_single_default],
      [permissionDeleteIconKey, delete_single_default],
      [permissionEditIconKey, write_single_default],
      [permissionCheckIconKey, check_mark_single_default],
      [permissionLockIconKey, lock_single_default],
      [UNIVER_SHEET_PERMISSION_PANEL, SheetPermissionPanel],
      [UNIVER_SHEET_PERMISSION_USER_DIALOG, SheetPermissionUserDialog],
      [UNIVER_SHEET_PERMISSION_DIALOG, SheetPermissionDialog],
      [UNIVER_SHEET_PERMISSION_ALERT_DIALOG, AlertDialog]
    ].forEach(([key, component]) => {
      this.disposeWithMe(this._componentManager.register(
        key,
        component
      ));
    });
  }
  _initUiPartComponents() {
    var _a;
    const configService = this._injector.get(IConfigService);
    const config = configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY);
    if (!((_a = config == null ? void 0 : config.customComponents) == null ? void 0 : _a.has(UNIVER_SHEET_PERMISSION_USER_PART))) {
      this.disposeWithMe(this._uiPartsService.registerComponent(UNIVER_SHEET_PERMISSION_USER_PART, () => connectInjector(PermissionDetailUserPart, this._injector)));
    }
  }
};
SheetPermissionRenderManagerController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, Inject(ComponentManager)),
  __decorateParam(2, Inject(IUIPartsService))
], SheetPermissionRenderManagerController);
var SheetPermissionRenderController = class extends Disposable {
  constructor(_context, _rangeProtectionRuleModel, _sheetSkeletonManagerService, _permissionService, _configService) {
    var _a;
    super();
    this._context = _context;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._permissionService = _permissionService;
    this._configService = _configService;
    __publicField(this, "_rangeProtectionCanViewRenderExtension", new RangeProtectionCanViewRenderExtension());
    __publicField(this, "_rangeProtectionCanNotViewRenderExtension", new RangeProtectionCanNotViewRenderExtension());
    const config = this._configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY);
    if ((_a = config == null ? void 0 : config.customComponents) == null ? void 0 : _a.has(UNIVER_SHEET_PERMISSION_BACKGROUND)) {
      return;
    }
    this._initRender();
    this._initSkeleton();
    this.disposeWithMe(this._rangeProtectionRuleModel.ruleChange$.subscribe((info) => {
      var _a2, _b;
      if (((_a2 = info.oldRule) == null ? void 0 : _a2.id) && this._rangeProtectionCanViewRenderExtension.renderCache.has(info.oldRule.id) || this._rangeProtectionCanViewRenderExtension.renderCache.has(info.rule.id)) {
        this._rangeProtectionCanViewRenderExtension.clearCache();
      }
      if (((_b = info.oldRule) == null ? void 0 : _b.id) && this._rangeProtectionCanNotViewRenderExtension.renderCache.has(info.oldRule.id) || this._rangeProtectionCanNotViewRenderExtension.renderCache.has(info.rule.id)) {
        this._rangeProtectionCanNotViewRenderExtension.clearCache();
      }
    }));
  }
  _initRender() {
    const spreadsheetRender = this._context.mainComponent;
    if (spreadsheetRender) {
      if (!spreadsheetRender.getExtensionByKey(RANGE_PROTECTION_CAN_VIEW_RENDER_EXTENSION_KEY)) {
        spreadsheetRender.register(this._rangeProtectionCanViewRenderExtension);
      }
      if (!spreadsheetRender.getExtensionByKey(RANGE_PROTECTION_CAN_NOT_VIEW_RENDER_EXTENSION_KEY)) {
        spreadsheetRender.register(this._rangeProtectionCanNotViewRenderExtension);
      }
    }
  }
  _initSkeleton() {
    const markDirtySkeleton = () => {
      var _a;
      this._sheetSkeletonManagerService.reCalculate();
      (_a = this._context.mainComponent) == null ? void 0 : _a.makeDirty();
    };
    this.disposeWithMe(merge(
      this._permissionService.permissionPointUpdate$.pipe(throttleTime(300, void 0, { trailing: true })),
      this._rangeProtectionRuleModel.rangeRuleInitStateChange$,
      this._rangeProtectionRuleModel.ruleChange$
    ).pipe().subscribe(markDirtySkeleton));
  }
};
SheetPermissionRenderController = __decorateClass([
  __decorateParam(1, Inject(RangeProtectionRuleModel)),
  __decorateParam(2, Inject(SheetSkeletonManagerService)),
  __decorateParam(3, IPermissionService),
  __decorateParam(4, IConfigService)
], SheetPermissionRenderController);
var WorksheetProtectionRenderController = class extends Disposable {
  constructor(_context, _renderManagerService, _univerInstanceService, _sheetSkeletonManagerService, _worksheetProtectionRuleModel, _configService) {
    var _a;
    super();
    this._context = _context;
    this._renderManagerService = _renderManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._worksheetProtectionRuleModel = _worksheetProtectionRuleModel;
    this._configService = _configService;
    __publicField(this, "_worksheetProtectionRenderExtension", new WorksheetProtectionRenderExtension());
    const config = this._configService.getConfig(SHEETS_UI_PLUGIN_CONFIG_KEY);
    if ((_a = config == null ? void 0 : config.customComponents) == null ? void 0 : _a.has(UNIVER_SHEET_PERMISSION_BACKGROUND)) {
      return;
    }
    this._initRender();
    this._initSkeleton();
  }
  _initRender() {
    const renderId = this._context.unitId;
    const render = renderId && this._renderManagerService.getRenderById(renderId);
    const spreadsheetRender = render && render.mainComponent;
    if (spreadsheetRender) {
      if (!spreadsheetRender.getExtensionByKey(worksheetProtectionKey)) {
        spreadsheetRender.register(this._worksheetProtectionRenderExtension);
      }
    }
  }
  _initSkeleton() {
    const markDirtySkeleton = () => {
      var _a;
      this._sheetSkeletonManagerService.reCalculate();
      (_a = this._context.mainComponent) == null ? void 0 : _a.makeDirty();
    };
    this.disposeWithMe(merge(
      this._worksheetProtectionRuleModel.worksheetRuleInitStateChange$
    ).pipe().subscribe(markDirtySkeleton));
  }
};
WorksheetProtectionRenderController = __decorateClass([
  __decorateParam(1, Inject(IRenderManagerService)),
  __decorateParam(2, Inject(IUniverInstanceService)),
  __decorateParam(3, Inject(SheetSkeletonManagerService)),
  __decorateParam(4, Inject(WorksheetProtectionRuleModel)),
  __decorateParam(5, Inject(IConfigService))
], WorksheetProtectionRenderController);

// ../packages/sheets-ui/src/controllers/render-controllers/format-painter.render-controller.ts
var FormatPainterRenderController = class extends Disposable {
  constructor(_context, _formatPainterService, _selectionRenderService, _commandService) {
    super();
    this._context = _context;
    this._formatPainterService = _formatPainterService;
    this._selectionRenderService = _selectionRenderService;
    this._commandService = _commandService;
    this._initialize();
  }
  _initialize() {
    this._bindFormatPainterStatus();
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._selectionRenderService.selectionMoveEnd$.subscribe((selections) => {
        var _a;
        if (this._formatPainterService.getStatus() !== 0 /* OFF */) {
          const { rangeWithCoord } = selections[selections.length - 1];
          this._commandService.executeCommand(ApplyFormatPainterCommand.id, {
            unitId: this._context.unitId,
            subUnitId: ((_a = this._context.unit.getActiveSheet()) == null ? void 0 : _a.getSheetId()) || "",
            range: {
              startRow: rangeWithCoord.startRow,
              startColumn: rangeWithCoord.startColumn,
              endRow: rangeWithCoord.endRow,
              endColumn: rangeWithCoord.endColumn
            }
          });
          if (this._formatPainterService.getStatus() === 1 /* ONCE */) {
            this._commandService.executeCommand(SetOnceFormatPainterCommand.id);
          }
        }
      })
    );
  }
  _bindFormatPainterStatus() {
    this.disposeWithMe(
      toDisposable(this._formatPainterService.status$.subscribe((status) => {
        const scene = this._context.scene;
        if (!scene) return;
        if (status !== 0 /* OFF */) {
          scene.setDefaultCursor("cell" /* CELL */);
        } else {
          scene.setDefaultCursor("default" /* DEFAULT */);
        }
      }))
    );
  }
};
FormatPainterRenderController = __decorateClass([
  __decorateParam(1, IFormatPainterService),
  __decorateParam(2, ISheetSelectionRenderService),
  __decorateParam(3, ICommandService)
], FormatPainterRenderController);

// ../packages/sheets-ui/src/controllers/render-controllers/mobile/mobile-contextmenu.render-controller.ts
var SheetContextMenuMobileRenderController = class extends Disposable {
  constructor(_context, _layoutService, _contextMenuService, _selectionManagerService, _selectionRenderService, _sheetSkeletonManagerService) {
    super();
    this._context = _context;
    this._layoutService = _layoutService;
    this._contextMenuService = _contextMenuService;
    this._selectionManagerService = _selectionManagerService;
    this._selectionRenderService = _selectionRenderService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._init();
  }
  _init() {
    let listenToSelectionChangeEvent = false;
    this.disposeWithMe(this._selectionManagerService.selectionMoveStart$.subscribe(() => listenToSelectionChangeEvent = true));
    this.disposeWithMe(this._selectionManagerService.selectionMoveEnd$.subscribe((selectionWithStyleList) => {
      const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
      if (!skeleton || !selectionWithStyleList || listenToSelectionChangeEvent === false) {
        return;
      }
      listenToSelectionChangeEvent = false;
      const selectionRangeWithStyle = selectionWithStyleList[0];
      if (!selectionRangeWithStyle.primary) return;
      const selectionWithCoord = attachSelectionWithCoord(selectionRangeWithStyle, skeleton);
      const rangeType = selectionRangeWithStyle.range.rangeType;
      const { scene } = this._context;
      const viewMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
      const viewportScrollX = (viewMain == null ? void 0 : viewMain.viewportScrollX) || 0;
      const viewportScrollY = (viewMain == null ? void 0 : viewMain.viewportScrollY) || 0;
      let clientX = 0;
      let clientY = 0;
      const rowHeaderWidth = skeleton.rowHeaderWidth;
      const canvasRect = this._layoutService.getContentElement().getBoundingClientRect();
      switch (rangeType) {
        case 0 /* NORMAL */:
          clientX = selectionWithCoord.rangeWithCoord.startX + canvasRect.left - viewportScrollX;
          clientY = selectionWithCoord.rangeWithCoord.endY + canvasRect.top - viewportScrollY;
          break;
        case 2 /* COLUMN */:
          clientX = selectionWithCoord.rangeWithCoord.startX + canvasRect.left - viewportScrollX;
          clientY = Math.min(canvasRect.height / 2, selectionWithCoord.rangeWithCoord.endY) + 40;
          break;
        case 1 /* ROW */:
          clientX = (canvasRect.width - rowHeaderWidth) / 2 + 20;
          clientY = selectionWithCoord.rangeWithCoord.endY + canvasRect.top - viewportScrollY;
          break;
        case 3 /* ALL */:
          clientX = selectionWithCoord.rangeWithCoord.startX + canvasRect.left;
          clientY = selectionWithCoord.rangeWithCoord.startY + canvasRect.top;
          break;
        default:
          clientX = selectionWithCoord.rangeWithCoord.startX + canvasRect.left - viewportScrollX;
          clientY = selectionWithCoord.rangeWithCoord.endY + canvasRect.top - viewportScrollY;
          break;
      }
      clientX = Tools.clamp(clientX, rowHeaderWidth, canvasRect.width);
      clientY = Tools.clamp(clientY, canvasRect.top, canvasRect.height);
      this._contextMenuService.triggerContextMenu({
        clientX,
        clientY,
        preventDefault: () => {
        },
        stopPropagation: () => {
        }
      }, "contextMenu.mainArea" /* MAIN_AREA */);
    }));
  }
};
SheetContextMenuMobileRenderController = __decorateClass([
  __decorateParam(1, ILayoutService),
  __decorateParam(2, IContextMenuService),
  __decorateParam(3, Inject(SheetsSelectionsService)),
  __decorateParam(4, ISheetSelectionRenderService),
  __decorateParam(5, Inject(SheetSkeletonManagerService))
], SheetContextMenuMobileRenderController);

// ../packages/sheets-ui/src/controllers/render-controllers/mobile/mobile-scroll.render-controller.ts
var SHEET_NAVIGATION_COMMANDS2 = [MoveSelectionCommand.id, MoveSelectionEnterAndTabCommand.id];
var MobileSheetsScrollRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _commandService, _renderManagerService, _selectionManagerService, _scrollManagerService, _univerInstanceService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._commandService = _commandService;
    this._renderManagerService = _renderManagerService;
    this._selectionManagerService = _selectionManagerService;
    this._scrollManagerService = _scrollManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._init();
  }
  scrollToRange(range) {
    let { endRow, endColumn, startColumn, startRow } = range;
    const bounding = this._getViewportBounding();
    if (range.rangeType === 1 /* ROW */) {
      startColumn = 0;
      endColumn = 0;
    } else if (range.rangeType === 2 /* COLUMN */) {
      startRow = 0;
      endRow = 0;
    }
    if (bounding) {
      const row = bounding.startRow > endRow ? startRow : endRow;
      const col = bounding.startColumn > endColumn ? startColumn : endColumn;
      return this._scrollToCell(row, col);
    } else {
      return this._scrollToCell(startRow, startColumn);
    }
  }
  _init() {
    this._initCommandListener();
    this._initScrollEventListener();
    this._initPointerScrollEvent();
    this._initSkeletonListener();
  }
  _initCommandListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (SHEET_NAVIGATION_COMMANDS2.includes(command.id)) {
          this._scrollToSelection();
        } else if (command.id === ScrollToCellOperation.id) {
          const param = command.params.range;
          this.scrollToRange(param);
        } else if (command.id === ExpandSelectionCommand.id) {
          const param = command.params;
          this._scrollToSelectionForExpand(param);
        }
      })
    );
  }
  _scrollToSelectionForExpand(param) {
    setTimeout(() => {
      const selection = this._selectionManagerService.getCurrentLastSelection();
      if (selection == null) {
        return;
      }
      const { startRow, startColumn, endRow, endColumn } = selection.range;
      const bounds = this._getViewportBounding();
      if (bounds == null) {
        return;
      }
      const { startRow: viewportStartRow, startColumn: viewportStartColumn, endRow: viewportEndRow, endColumn: viewportEndColumn } = bounds;
      let row = 0;
      let column = 0;
      if (startRow > viewportStartRow) {
        row = endRow;
      } else if (endRow < viewportEndRow) {
        row = startRow;
      } else {
        row = viewportStartRow;
      }
      if (startColumn > viewportStartColumn) {
        column = endColumn;
      } else if (endColumn < viewportEndColumn) {
        column = startColumn;
      } else {
        column = viewportStartColumn;
      }
      if (param.direction === 2 /* DOWN */) {
        row = endRow;
      } else if (param.direction === 0 /* UP */) {
        row = startRow;
      } else if (param.direction === 1 /* RIGHT */) {
        column = endColumn;
      } else if (param.direction === 3 /* LEFT */) {
        column = startColumn;
      }
      this._scrollToCell(row, column);
    }, 0);
  }
  _getFreeze() {
    var _a;
    const snapshot = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton.getWorksheetConfig();
    if (snapshot == null) {
      return;
    }
    return snapshot.freeze;
  }
  // eslint-disable-next-line max-lines-per-function
  _initScrollEventListener() {
    const { scene } = this._context;
    if (scene == null) return;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (!viewportMain) return;
    this.disposeWithMe(
      toDisposable(
        // wheel event --> set-scroll.command('sheet.operation.set-scroll') --> scroll.operation.ts -->
        // scrollManagerService.setScrollInfoAndEmitEvent --->  scrollManagerService.setScrollInfo(raw value, may be negative) &&
        // _notifyCurrentScrollInfo
        this._scrollManagerService.rawScrollInfo$.subscribe((rawScrollInfo) => {
          var _a;
          if (rawScrollInfo == null) {
            viewportMain.scrollToViewportPos({
              viewportScrollX: 0,
              viewportScrollY: 0
            });
            return;
          }
          const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
          if (!skeleton) return;
          const { sheetViewStartRow, sheetViewStartColumn, offsetX, offsetY } = rawScrollInfo;
          const { startX, startY } = skeleton.getCellWithCoordByIndex(
            sheetViewStartRow,
            sheetViewStartColumn,
            false
          );
          const viewportScrollX = startX + offsetX;
          const viewportScrollY = startY + offsetY;
          viewportMain.scrollToViewportPos({ viewportScrollX, viewportScrollY });
        })
      )
    );
    this.disposeWithMe(
      viewportMain.onScrollAfter$.subscribeEvent((scrollAfterParam) => {
        var _a;
        if (!scrollAfterParam) return;
        const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
        if (skeleton == null) return;
        const sheetObject = this._getSheetObject();
        if (skeleton == null || sheetObject == null) return;
        const { viewportScrollX, viewportScrollY, scrollX, scrollY } = scrollAfterParam;
        const { row, column, rowOffset, columnOffset } = skeleton.getOffsetRelativeToRowCol(
          viewportScrollX,
          viewportScrollY
        );
        const scrollInfo = {
          sheetViewStartRow: row,
          sheetViewStartColumn: column,
          offsetX: columnOffset,
          offsetY: rowOffset,
          viewportScrollX,
          viewportScrollY,
          scrollX,
          scrollY
        };
        this._scrollManagerService.setValidScrollStateToCurrSheet(scrollInfo);
        this._scrollManagerService.validViewportScrollInfo$.next({
          ...scrollInfo,
          scrollX,
          scrollY,
          viewportScrollX,
          viewportScrollY
        });
      })
    );
    this.disposeWithMe(
      viewportMain.onScrollByBar$.subscribeEvent((param) => {
        var _a;
        const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
        if (skeleton == null || param.isTrigger === false) {
          return;
        }
        const sheetObject = this._getSheetObject();
        if (skeleton == null || sheetObject == null) {
          return;
        }
        const { viewportScrollX = 0, viewportScrollY = 0 } = param;
        const freeze = this._getFreeze();
        const { row, column, rowOffset, columnOffset } = skeleton.getOffsetRelativeToRowCol(
          viewportScrollX,
          viewportScrollY
        );
        this._commandService.executeCommand(ScrollCommand.id, {
          sheetViewStartRow: row + ((freeze == null ? void 0 : freeze.ySplit) || 0),
          sheetViewStartColumn: column + ((freeze == null ? void 0 : freeze.xSplit) || 0),
          offsetX: columnOffset,
          offsetY: rowOffset
        });
      })
    );
  }
  _initSkeletonListener() {
    this.disposeWithMe(toDisposable(
      this._sheetSkeletonManagerService.currentSkeletonBefore$.subscribe((param) => {
        if (param == null) {
          return;
        }
        const scrollParam = { unitId: param.unitId, sheetId: param.sheetId };
        this._scrollManagerService.setSearchParam(scrollParam);
        const sheetObject = this._getSheetObject();
        if (!sheetObject) return;
        const scene = sheetObject.scene;
        const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
        const currScrollInfo = this._scrollManagerService.getScrollStateByParam(scrollParam);
        const { viewportScrollX, viewportScrollY } = this._scrollManagerService.calcViewportScrollFromRowColOffset(currScrollInfo);
        if (viewportMain) {
          if (currScrollInfo) {
            viewportMain.viewportScrollX = viewportScrollX;
            viewportMain.viewportScrollY = viewportScrollY;
          } else {
            viewportMain.viewportScrollX = 0;
            viewportMain.viewportScrollY = 0;
          }
          this._updateSceneSize(param);
        }
      })
    ));
  }
  /**
   * for mobile
   */
  // eslint-disable-next-line max-lines-per-function
  _initPointerScrollEvent() {
    const sheetObject = this._getSheetObject();
    if (!sheetObject) return;
    const scrollManagerService = this._scrollManagerService;
    const scene = sheetObject.scene;
    const spreadsheet = sheetObject.spreadsheet;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const lastPointerPos = { x: 0, y: 0 };
    let _pointerScrolling = false;
    const velocity = { x: 0, y: 0 };
    const deceleration = 0.95;
    let scrollInertiaAnimationID = null;
    const pointerScrollInertia = () => {
      if (!viewportMain) return;
      velocity.x *= deceleration;
      velocity.y *= deceleration;
      lastPointerPos.x += velocity.x;
      lastPointerPos.y += velocity.y;
      const offsetX = velocity.x;
      const offsetY = velocity.y;
      if (offsetY !== 0 || offsetX !== 0) {
        this._commandService.executeCommand(SetScrollRelativeCommand.id, { offsetY, offsetX });
      }
      if (Math.abs(velocity.x) > 1 || Math.abs(velocity.y) > 1) {
        scrollInertiaAnimationID = requestAnimationFrame(pointerScrollInertia);
      } else {
        scrollInertiaAnimationID = null;
      }
    };
    const cancelInertiaAnimation = () => {
      cancelAnimationFrame(scrollInertiaAnimationID);
      scrollInertiaAnimationID = null;
    };
    spreadsheet.onPointerDown$.subscribeEvent((evt, state) => {
      cancelInertiaAnimation();
      if (!viewportMain) return;
      lastPointerPos.x = evt.offsetX;
      lastPointerPos.y = evt.offsetY;
      _pointerScrolling = true;
      state.stopPropagation();
    });
    spreadsheet.onPointerMove$.subscribeEvent((evt, state) => {
      if (!_pointerScrolling) return;
      if (!viewportMain) return;
      const e = evt;
      const deltaX = -(e.offsetX - lastPointerPos.x);
      const deltaY = -(e.offsetY - lastPointerPos.y);
      velocity.x = -(e.offsetX - lastPointerPos.x);
      velocity.y = -(e.offsetY - lastPointerPos.y);
      const offsetX = deltaX;
      const offsetY = deltaY;
      if (deltaX !== 0 || deltaY !== 0) {
        if (offsetY !== 0 || offsetX !== 0) {
          this._commandService.executeCommand(SetScrollRelativeCommand.id, { offsetY, offsetX });
        }
      }
      const _currentScroll = scrollManagerService.getCurrentScrollState();
      lastPointerPos.x = e.offsetX;
      lastPointerPos.y = e.offsetY;
      state.stopPropagation();
    });
    spreadsheet.onPointerUp$.subscribeEvent((_evt) => {
      _pointerScrolling = false;
      scrollInertiaAnimationID = requestAnimationFrame(pointerScrollInertia);
    });
    spreadsheet.onPointerLeave$.subscribeEvent(() => {
      _pointerScrolling = false;
    });
    spreadsheet.onPointerOut$.subscribeEvent(() => {
      _pointerScrolling = false;
    });
    scene.onPointerOut$.subscribeEvent(() => {
      _pointerScrolling = false;
    });
    scene.onPointerCancel$.subscribeEvent(() => {
      _pointerScrolling = false;
    });
  }
  _updateSceneSize(param) {
    var _a;
    if (param == null) {
      return;
    }
    const { unitId } = this._context;
    const { skeleton } = param;
    const scene = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.scene;
    if (skeleton == null || scene == null) {
      return;
    }
    const { rowTotalHeight, columnTotalWidth, rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop } = skeleton;
    const workbook = this._context.unit;
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return;
    const zoomRatio = worksheet.getZoomRatio() || 1;
    scene == null ? void 0 : scene.setScaleValueOnly(zoomRatio, zoomRatio);
    scene == null ? void 0 : scene.transformByState({
      width: rowHeaderWidthAndMarginLeft + columnTotalWidth,
      height: columnHeaderHeightAndMarginTop + rowTotalHeight
    });
  }
  _getSheetObject() {
    return getSheetObject(this._context.unit, this._context);
  }
  _scrollToSelectionByDirection(range) {
    const bounds = this._getViewportBounding();
    if (bounds == null) {
      return false;
    }
    const {
      startRow: viewportStartRow,
      startColumn: viewportStartColumn,
      endRow: viewportEndRow,
      endColumn: viewportEndColumn
    } = bounds;
    let row = 0;
    let column = 0;
    const { startRow, startColumn, endRow, endColumn } = range;
    if (startRow >= viewportStartRow) {
      row = endRow;
    }
    if (endRow <= viewportEndRow) {
      row = startRow;
    }
    if (startColumn >= viewportStartColumn) {
      column = endColumn;
    }
    if (endColumn <= viewportEndColumn) {
      column = startColumn;
    }
    this._scrollToCell(row, column);
  }
  _scrollToSelection(targetIsActualRowAndColumn = true) {
    const selection = this._selectionManagerService.getCurrentLastSelection();
    if (selection == null) {
      return;
    }
    const { startRow, startColumn, actualRow, actualColumn } = selection.primary;
    const selectionStartRow = targetIsActualRowAndColumn ? actualRow : startRow;
    const selectionStartColumn = targetIsActualRowAndColumn ? actualColumn : startColumn;
    this._scrollToCell(selectionStartRow, selectionStartColumn);
  }
  _getViewportBounding() {
    var _a, _b;
    const scene = (_a = this._getSheetObject()) == null ? void 0 : _a.scene;
    if (scene == null) {
      return;
    }
    const viewport = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (viewport == null) {
      return;
    }
    const skeleton = (_b = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _b.skeleton;
    if (skeleton == null) {
      return;
    }
    return skeleton.getRangeByViewport(viewport.calcViewportInfo());
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _scrollToCell(row, column) {
    var _a, _b, _c, _d;
    const { rowHeightAccumulation, columnWidthAccumulation } = (_b = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton) != null ? _b : {};
    if (rowHeightAccumulation == null || columnWidthAccumulation == null) return false;
    const scene = (_c = this._getSheetObject()) == null ? void 0 : _c.scene;
    if (scene == null) return false;
    const viewport = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (viewport == null) return false;
    const skeleton = (_d = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _d.skeleton;
    if (skeleton == null) return false;
    const worksheet = this._context.unit.getActiveSheet();
    if (!worksheet) return false;
    const {
      startColumn: freezeStartColumn,
      startRow: freezeStartRow,
      ySplit: freezeYSplit,
      xSplit: freezeXSplit
    } = worksheet.getFreeze();
    const bounds = this._getViewportBounding();
    if (bounds == null) return false;
    const {
      startRow: viewportStartRow,
      startColumn: viewportStartColumn,
      endRow: viewportEndRow,
      endColumn: viewportEndColumn
    } = bounds;
    let startSheetViewRow;
    let startSheetViewColumn;
    if (row >= freezeStartRow && column >= freezeStartColumn - freezeXSplit) {
      if (row <= viewportStartRow) {
        startSheetViewRow = row;
      }
      if (row >= viewportEndRow) {
        const minRowAccumulation = rowHeightAccumulation[row] - viewport.height;
        for (let r = viewportStartRow; r <= row; r++) {
          if (rowHeightAccumulation[r] >= minRowAccumulation) {
            startSheetViewRow = r + 1;
            break;
          }
        }
      }
    }
    if (column >= freezeStartColumn && row >= freezeStartRow - freezeYSplit) {
      if (column <= viewportStartColumn) {
        startSheetViewColumn = column;
      }
      if (column >= viewportEndColumn) {
        const minColumnAccumulation = columnWidthAccumulation[column] - viewport.width;
        for (let c = viewportStartColumn; c <= column; c++) {
          if (columnWidthAccumulation[c] >= minColumnAccumulation) {
            startSheetViewColumn = c + 1;
            break;
          }
        }
      }
    }
    if (startSheetViewRow === void 0 && startSheetViewColumn === void 0) return false;
    const { offsetX, offsetY } = this._scrollManagerService.getCurrentScrollState() || {};
    return this._commandService.syncExecuteCommand(ScrollCommand.id, {
      sheetViewStartRow: startSheetViewRow,
      sheetViewStartColumn: startSheetViewColumn,
      offsetX: startSheetViewColumn === void 0 ? offsetX : 0,
      offsetY: startSheetViewRow === void 0 ? offsetY : 0
    });
  }
};
MobileSheetsScrollRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, ICommandService),
  __decorateParam(3, IRenderManagerService),
  __decorateParam(4, Inject(SheetsSelectionsService)),
  __decorateParam(5, Inject(SheetScrollManagerService)),
  __decorateParam(6, IUniverInstanceService)
], MobileSheetsScrollRenderController);

// ../packages/telemetry/src/services/telemetry-service.ts
var ITelemetryService = createIdentifier("telemetry.service");

// ../packages/sheets-ui/src/services/sheets-render.service.ts
var SHEET_MAIN_CANVAS_ID = "univer-sheet-main-canvas";
var SheetsRenderService = class extends RxDisposable {
  constructor(_contextService, _instanceSrv, _renderManagerService) {
    super();
    this._contextService = _contextService;
    this._instanceSrv = _instanceSrv;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_skeletonChangeMutations", /* @__PURE__ */ new Set());
    Promise.resolve().then(() => this._init());
  }
  /**
   * Register a mutation id that will trigger the skeleton change.
   *
   * @param mutationId the id of the mutation
   * @returns a disposable to unregister the mutation
   */
  registerSkeletonChangingMutations(mutationId) {
    if (this._skeletonChangeMutations.has(mutationId)) {
      return toDisposable(() => {
      });
    }
    this._skeletonChangeMutations.add(mutationId);
    return toDisposable(() => this._skeletonChangeMutations.delete(mutationId));
  }
  /**
   * Examine if a mutation would make the skeleton to change.
   */
  checkMutationShouldTriggerRerender(id) {
    return this._skeletonChangeMutations.has(id);
  }
  _init() {
    this._initWorkbookListener();
    this._initContextListener();
  }
  _initWorkbookListener() {
    this._instanceSrv.getTypeOfUnitAdded$(O.UNIVER_SHEET).pipe(takeUntil(this.dispose$)).subscribe((workbook) => this._createRenderer(workbook));
    this._instanceSrv.getAllUnitsForType(O.UNIVER_SHEET).forEach((workbook) => this._createRenderer(workbook));
    this._instanceSrv.getTypeOfUnitDisposed$(O.UNIVER_SHEET).pipe(takeUntil(this.dispose$)).subscribe((workbook) => this._disposeRenderer(workbook));
  }
  _createRenderer(workbook) {
    const unitId = workbook.getUnitId();
    this._renderManagerService.created$.subscribe((renderer) => {
      if (renderer.unitId === unitId) {
        renderer.engine.getCanvas().setId(`${SHEET_MAIN_CANVAS_ID}_${unitId}`);
        renderer.engine.getCanvas().getContext().setId(`${SHEET_MAIN_CANVAS_ID}_${unitId}`);
      }
    });
    this._renderManagerService.createRender(unitId);
  }
  _disposeRenderer(workbook) {
    const unitId = workbook.getUnitId();
    this._renderManagerService.removeRender(unitId);
  }
  _initContextListener() {
    this.disposeWithMe(this._contextService.subscribeContextValue$(RENDER_RAW_FORMULA_KEY).pipe(distinctUntilChanged()).subscribe(() => {
      this._renderManagerService.getRenderAll().forEach((renderer) => {
        if (renderer.mainComponent instanceof Spreadsheet) {
          renderer.mainComponent.makeForceDirty(true);
        }
      });
    }));
  }
};
SheetsRenderService = __decorateClass([
  __decorateParam(0, IContextService),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IRenderManagerService)
], SheetsRenderService);

// ../packages/sheets-ui/src/controllers/render-controllers/sheet.render-controller.ts
var FRAME_STACK_THRESHOLD = 60;
var SheetRenderController = class extends RxDisposable {
  constructor(_context, _sheetSkeletonManagerService, _sheetRenderService, _commandService, _telemetryService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._sheetRenderService = _sheetRenderService;
    this._commandService = _commandService;
    this._telemetryService = _telemetryService;
    __publicField(this, "_renderMetric$", new Subject());
    __publicField(this, "renderMetric$", this._renderMetric$.asObservable());
    __publicField(this, "_renderFrameTimeMetric", null);
    __publicField(this, "_renderFrameTags", {});
    __publicField(this, "_afterRenderMetric$", new Subject());
    this._addNewRender();
    this._initRenderMetricSubscriber();
  }
  _addNewRender() {
    const { scene, engine, unit: workbook } = this._context;
    this._addComponent(workbook);
    this._initRerenderScheduler();
    this._initCommandListener();
    const worksheet = this._context.unit.getActiveSheet();
    if (!worksheet) {
      throw new Error("No active sheet found");
    }
    const sheetId = worksheet.getSheetId();
    this._sheetSkeletonManagerService.setCurrent({ sheetId });
    const frameFn = () => scene.render();
    this.disposeWithMe(this._context.activated$.subscribe((activated) => {
      if (activated) {
        engine.runRenderLoop(frameFn);
      } else {
        engine.stopRenderLoop(frameFn);
      }
    }));
  }
  _initRenderMetricSubscriber() {
    const { engine } = this._context;
    engine.beginFrame$.subscribe(() => {
      this._renderFrameTimeMetric = null;
      this._renderFrameTags = {};
    });
    engine.endFrame$.subscribe(() => {
      const validRenderInfo = this._renderFrameTimeMetric && Object.keys(this._renderFrameTimeMetric).filter((key) => key.startsWith(SHEET_EXTENSION_PREFIX)).length > 0;
      if (validRenderInfo) {
        this._afterRenderMetric$.next({
          frameTimeMetric: this._renderFrameTimeMetric,
          tags: this._renderFrameTags
        });
      }
    });
    engine.renderFrameTimeMetric$.subscribe(([key, value]) => {
      if (!this._renderFrameTimeMetric) this._renderFrameTimeMetric = {};
      if (!this._renderFrameTimeMetric[key]) {
        this._renderFrameTimeMetric[key] = [];
      }
      this._renderFrameTimeMetric[key].push(Math.round(value * 100) / 100);
    });
    engine.renderFrameTags$.subscribe(([key, value]) => {
      this._renderFrameTags[key] = value;
    });
    const frameInfoList = [];
    this._afterRenderMetric$.pipe(withLatestFrom(engine.endFrame$)).subscribe(([sceneRenderDetail, basicFrameTimeInfo]) => {
      frameInfoList.push({
        ...{
          FPS: basicFrameTimeInfo.FPS,
          elapsedTime: basicFrameTimeInfo.elapsedTime,
          frameTime: Math.round(basicFrameTimeInfo.frameTime * 100) / 100
        },
        ...sceneRenderDetail.frameTimeMetric,
        ...sceneRenderDetail.tags
      });
      if (frameInfoList.length > FRAME_STACK_THRESHOLD) {
        this._captureRenderMetric(frameInfoList);
        frameInfoList.length = 0;
      }
    });
  }
  /**
   * Send render metric to telemetry service
   * @param frameInfoList
   */
  _captureRenderMetric(frameInfoList) {
    var _a;
    const filteredFrameInfo = frameInfoList;
    if (filteredFrameInfo.length === 0) return;
    const sumValueForNumListFields = (data) => {
      let totalSum = 0;
      const numberListValueKeys = Object.entries(data).filter(([_, value]) => Array.isArray(value)).map(([key]) => key);
      const sums = numberListValueKeys.reduce((acc, key) => {
        const keySum = data[key].reduce((sum, num) => sum + num, 0);
        acc[key] = keySum;
        return acc;
      }, {});
      const extKeys = Object.keys(data).filter((key) => key.startsWith(SHEET_EXTENSION_PREFIX));
      extKeys.forEach((key) => {
        totalSum += sums[key];
      });
      return { ...sums, extensionTotal: totalSum };
    };
    const frameTimeListAfterSum = frameInfoList.map((info) => {
      return { ...info, ...sumValueForNumListFields(info) };
    });
    const getSummaryStats = (list) => {
      const numberValueKeys = Object.entries(list[0]).filter(([key, _]) => !["elapsedTime"].includes(key)).filter(([_, value]) => typeof value === "number").map(([key]) => key);
      const stats = numberValueKeys.reduce((acc, key) => {
        const values = list.map((obj) => obj[key]);
        const max = Math.max(...values);
        const min = Math.min(...values);
        const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
        acc[key] = {
          max: Math.round(max * 100) / 100,
          min: Math.round(min * 100) / 100,
          avg: Math.round(avg * 100) / 100
        };
        return acc;
      }, {});
      return stats;
    };
    const summaryFrameStats = getSummaryStats(frameTimeListAfterSum);
    const elapsedTimeToStart = filteredFrameInfo[filteredFrameInfo.length - 1].elapsedTime;
    const sheetId = this._context.unit.getActiveSheet().getSheetId();
    const unitId = this._context.unit.getUnitId();
    const telemetryData = { sheetId, unitId, elapsedTimeToStart, ...summaryFrameStats };
    this._renderMetric$.next(telemetryData);
    (_a = this._telemetryService) == null ? void 0 : _a.capture("sheet_render_cost", telemetryData);
  }
  _addComponent(workbook) {
    const { scene, components } = this._context;
    const worksheet = workbook.getActiveSheet();
    const spreadsheet = new Spreadsheet("__SpreadsheetRender__" /* MAIN */);
    this._addViewport(worksheet);
    const spreadsheetRowHeader = new SpreadsheetRowHeader("__SpreadsheetRowHeader__" /* ROW */);
    const spreadsheetColumnHeader = new SpreadsheetColumnHeader("__SpreadsheetColumnHeader__" /* COLUMN */);
    const SpreadsheetLeftTopPlaceholder = new Rect("__SpreadsheetLeftTopPlaceholder__" /* LEFT_TOP */, {
      zIndex: 2,
      left: -1,
      top: -1,
      fill: "rgb(248, 249, 250)",
      stroke: "rgb(217, 217, 217)",
      strokeWidth: 1
    });
    this._context.mainComponent = spreadsheet;
    components.set("__SpreadsheetRender__" /* MAIN */, spreadsheet);
    components.set("__SpreadsheetRowHeader__" /* ROW */, spreadsheetRowHeader);
    components.set("__SpreadsheetColumnHeader__" /* COLUMN */, spreadsheetColumnHeader);
    components.set("__SpreadsheetLeftTopPlaceholder__" /* LEFT_TOP */, SpreadsheetLeftTopPlaceholder);
    scene.addObjects([spreadsheet], SHEET_COMPONENT_MAIN_LAYER_INDEX);
    scene.addObjects(
      [spreadsheetRowHeader, spreadsheetColumnHeader, SpreadsheetLeftTopPlaceholder],
      SHEET_COMPONENT_HEADER_LAYER_INDEX
    );
    scene.enableLayerCache(SHEET_COMPONENT_MAIN_LAYER_INDEX, SHEET_COMPONENT_HEADER_LAYER_INDEX);
  }
  _initViewports(scene, rowHeader, columnHeader) {
    const bufferEdgeX = 100;
    const bufferEdgeY = 100;
    const viewMain = new Viewport("viewMain" /* VIEW_MAIN */, scene, {
      left: rowHeader.width,
      top: columnHeader.height,
      bottom: 0,
      right: 0,
      isWheelPreventDefaultX: true,
      allowCache: true,
      bufferEdgeX,
      bufferEdgeY
    });
    const viewMainLeftTop = new Viewport("viewMainLeftTop" /* VIEW_MAIN_LEFT_TOP */, scene, {
      isWheelPreventDefaultX: true,
      active: false,
      allowCache: true,
      bufferEdgeX: 0,
      bufferEdgeY: 0
    });
    const viewMainLeft = new Viewport("viewMainLeft" /* VIEW_MAIN_LEFT */, scene, {
      isWheelPreventDefaultX: true,
      active: false,
      allowCache: true,
      bufferEdgeX: 0,
      bufferEdgeY
    });
    const viewMainTop = new Viewport("viewMainTop" /* VIEW_MAIN_TOP */, scene, {
      isWheelPreventDefaultX: true,
      active: false,
      allowCache: true,
      bufferEdgeX,
      bufferEdgeY: 0
    });
    const viewRowTop = new Viewport("viewRowTop" /* VIEW_ROW_TOP */, scene, {
      active: false,
      isWheelPreventDefaultX: true
    });
    const viewRowBottom = new Viewport("viewRowBottom" /* VIEW_ROW_BOTTOM */, scene, {
      left: 0,
      top: columnHeader.height,
      bottom: 0,
      width: rowHeader.width + 1,
      isWheelPreventDefaultX: true
    });
    const viewColumnLeft = new Viewport("viewColumnLeft" /* VIEW_COLUMN_LEFT */, scene, {
      active: false,
      isWheelPreventDefaultX: true
    });
    const viewColumnRight = new Viewport("viewColumnRight" /* VIEW_COLUMN_RIGHT */, scene, {
      left: rowHeader.width,
      top: 0,
      height: columnHeader.height + 1,
      right: 0,
      isWheelPreventDefaultX: true
    });
    const viewLeftTop = new Viewport("viewLeftTop" /* VIEW_LEFT_TOP */, scene, {
      left: 0,
      top: 0,
      width: rowHeader.width,
      height: columnHeader.height,
      isWheelPreventDefaultX: true
    });
    return {
      viewMain,
      viewLeftTop,
      viewMainLeftTop,
      viewMainLeft,
      viewMainTop,
      viewColumnLeft,
      viewRowTop,
      viewRowBottom,
      viewColumnRight
    };
  }
  /**
   *
   * initViewport & wheel event
   * +-----------------+--------------------+-------------------+
   * |  VIEW_LEFT_TOP  |  VIEW_COLUMN_LEFT  | VIEW_COLUMN_RIGHT |
   * +-----------------+--------------------+-------------------+
   * |  VIEW_ROW_TOP   | VIEW_MAIN_LEFT_TOP |   VIEW_MAIN_TOP   |
   * +-----------------+--------------------+-------------------+
   * | VIEW_ROW_BOTTOM |   VIEW_MAIN_LEFT   |     VIEW_MAIN     |
   * +-----------------+--------------------+-------------------+
   */
  _addViewport(worksheet) {
    const scene = this._context.scene;
    const { rowHeader, columnHeader } = worksheet.getConfig();
    const { viewMain } = this._initViewports(scene, rowHeader, columnHeader);
    const _scrollBar = new ScrollBar(viewMain);
    scene.attachControl();
    return viewMain;
  }
  _initRerenderScheduler() {
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((param) => {
      if (!param) return null;
      const { skeleton: spreadsheetSkeleton, sheetId } = param;
      const workbook = this._context.unit;
      const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(sheetId);
      if (workbook == null || worksheet == null) return;
      const { mainComponent, components } = this._context;
      const spreadsheet = mainComponent;
      const spreadsheetRowHeader = components.get("__SpreadsheetRowHeader__" /* ROW */);
      const spreadsheetColumnHeader = components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
      const spreadsheetLeftTopPlaceholder = components.get("__SpreadsheetLeftTopPlaceholder__" /* LEFT_TOP */);
      const { rowHeaderWidth, columnHeaderHeight } = spreadsheetSkeleton;
      spreadsheet == null ? void 0 : spreadsheet.updateSkeleton(spreadsheetSkeleton);
      spreadsheetRowHeader == null ? void 0 : spreadsheetRowHeader.updateSkeleton(spreadsheetSkeleton);
      spreadsheetColumnHeader == null ? void 0 : spreadsheetColumnHeader.updateSkeleton(spreadsheetSkeleton);
      spreadsheetLeftTopPlaceholder == null ? void 0 : spreadsheetLeftTopPlaceholder.transformByState({
        width: rowHeaderWidth,
        height: columnHeaderHeight
      });
    }));
  }
  _initCommandListener() {
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      const { unit: workbook } = this._context;
      const { id: commandId } = command;
      if (COMMAND_LISTENER_SKELETON_CHANGE.includes(commandId) || this._sheetRenderService.checkMutationShouldTriggerRerender(commandId)) {
        const params = command.params;
        const { unitId, subUnitId } = params;
        const worksheet = workbook.getActiveSheet();
        if (!worksheet) return;
        const workbookId = this._context.unitId;
        const worksheetId = worksheet.getSheetId();
        if (unitId !== workbookId || subUnitId !== worksheetId) {
          return;
        }
        this._sheetSkeletonManagerService.makeDirty({
          sheetId: worksheetId,
          commandId
        }, true);
        this._sheetSkeletonManagerService.setCurrent({
          sheetId: worksheetId,
          commandId
        });
      } else if (COMMAND_LISTENER_VALUE_CHANGE.includes(commandId)) {
        this._sheetSkeletonManagerService.reCalculate();
      }
      if (command.type === 2 /* MUTATION */) {
        this._markUnitDirty(command);
      }
    }));
  }
  _markUnitDirty(command) {
    const { mainComponent: spreadsheet, scene } = this._context;
    if (command.id === SetFormulaCalculationNotificationMutation.id) {
      const params = command.params;
      if (params.stageInfo != null) {
        return;
      }
    }
    if (spreadsheet) {
      spreadsheet.makeDirty();
    }
    scene.makeDirty();
    if (!command.params) return;
    const cmdParams = command.params;
    const viewports = this._spreadsheetViewports(scene);
    if (command.id === SetRangeValuesMutation.id && cmdParams.cellValue) {
      const dirtyRange = this._cellValueToRange(cmdParams.cellValue);
      const dirtyBounds = this._rangeToBounds([dirtyRange]);
      this._markViewportDirty(viewports, dirtyBounds);
      spreadsheet.setDirtyArea(dirtyBounds);
    }
    if (command.id === MoveRangeMutation.id && cmdParams.from && cmdParams.to) {
      const fromRange = cmdParams.fromRange || this._cellValueToRange(cmdParams.from.value);
      const toRange = cmdParams.toRange || this._cellValueToRange(cmdParams.to.value);
      const dirtyBounds = this._rangeToBounds([fromRange, toRange]);
      this._markViewportDirty(viewports, dirtyBounds);
      spreadsheet.setDirtyArea(dirtyBounds);
    }
  }
  /**
   * cellValue data structure:
   * {[row]: { [col]: value}}
   * @param cellValue
   * @returns IRange
   */
  _cellValueToRange(cellValue) {
    const columns = [];
    let minCol = 0;
    let maxCol = 0;
    let minRow = 0;
    let maxRow = 0;
    for (const [_row, columnObj] of Object.entries(cellValue)) {
      for (const column in columnObj) {
        columns.push(Number(column));
        if (minCol > Number(column)) {
          minCol = Number(column);
        }
        if (maxCol < Number(column)) {
          maxCol = Number(column);
        }
      }
      if (minRow > Number(_row)) {
        minRow = Number(_row);
      }
      if (maxRow < Number(_row)) {
        maxRow = Number(_row);
      }
    }
    const startRow = minRow;
    const endRow = maxRow;
    const startColumn = minCol;
    const endColumn = maxCol;
    return {
      startRow,
      endRow,
      startColumn,
      endColumn
    };
  }
  _rangeToBounds(ranges) {
    const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
    const { rowHeightAccumulation, columnWidthAccumulation, rowHeaderWidth, columnHeaderHeight } = skeleton;
    const dirtyBounds = [];
    for (const r of ranges) {
      const { startRow, endRow, startColumn, endColumn } = r;
      const top = startRow === 0 ? 0 : rowHeightAccumulation[startRow - 1] + columnHeaderHeight;
      const bottom = rowHeightAccumulation[endRow] + columnHeaderHeight;
      const left = startColumn === 0 ? 0 : columnWidthAccumulation[startColumn - 1] + rowHeaderWidth;
      const right = columnWidthAccumulation[endColumn] + rowHeaderWidth;
      dirtyBounds.push({ top, left, bottom, right, width: right - left, height: bottom - top });
    }
    return dirtyBounds;
  }
  _markViewportDirty(viewports, dirtyBounds) {
    const activeViewports = viewports.filter((vp) => vp.isActive && vp.cacheBound);
    for (const vp of activeViewports) {
      for (const b of dirtyBounds) {
        if (Rectangle.hasIntersectionBetweenTwoRect(vp.cacheBound, b)) {
          vp.markDirty(true);
        }
      }
    }
  }
  _spreadsheetViewports(scene) {
    return scene.getViewports().filter((v) => ["viewMain", "viewMainLeftTop", "viewMainTop", "viewMainLeft"].includes(v.viewportKey));
  }
};
SheetRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, Inject(SheetsRenderService)),
  __decorateParam(3, ICommandService),
  __decorateParam(4, Optional(ITelemetryService))
], SheetRenderController);

// ../packages/sheets-ui/src/services/print-interceptor.service.ts
var PRINTING_RANGE = createInterceptorKey("PRINTING_RANGE");
var PRINTING_COMPONENT_COLLECT = createInterceptorKey("PRINTING_COMPONENT_COLLECT");
var SheetPrintInterceptorService = class extends Disposable {
  constructor() {
    super();
    __publicField(this, "interceptor", new InterceptorManager({
      PRINTING_RANGE,
      PRINTING_COMPONENT_COLLECT
    }));
    this.disposeWithMe(this.interceptor.intercept(this.interceptor.getInterceptPoints().PRINTING_RANGE, {
      priority: -1,
      handler: (_value) => _value
    }));
    this.disposeWithMe(this.interceptor.intercept(this.interceptor.getInterceptPoints().PRINTING_COMPONENT_COLLECT, {
      priority: -1,
      handler: (_value) => _value
    }));
  }
};

// ../packages/sheets-ui/src/services/selection/mobile-selection-shape.ts
var MobileSelectionControl = class extends SelectionControl {
  constructor(_scene, _zIndex, _themeService, options) {
    super(_scene, _zIndex, _themeService, options);
    this._scene = _scene;
    this._zIndex = _zIndex;
    this._themeService = _themeService;
    /**
     * topLeft controlPointer, it is not visible, just transparent, for handling event.
     */
    __publicField(this, "_fillControlTopLeft");
    /**
     * bottomRight controlPointer, it is not visible, just transparent, for handling event.
     */
    __publicField(this, "_fillControlBottomRight");
    __publicField(this, "_rangeType", 0 /* NORMAL */);
    this._rangeType = (options == null ? void 0 : options.rangeType) || 0 /* NORMAL */;
    this.initControlPoints();
  }
  initControlPoints() {
    const defaultStyle = this.currentStyle;
    const expandCornerSize = defaultStyle.expandCornerSize || 0;
    const expandCornerInnerSize = (defaultStyle.expandCornerSize || 0) / 4;
    const AutofillStrokeWidth = defaultStyle.autofillStrokeWidth || 0;
    const stroke = defaultStyle.stroke;
    const AutofillStroke = defaultStyle.autofillStroke;
    const zIndex = this.zIndex;
    this._fillControlTopLeft = new Rect("__SpreadsheetSelectionFillControlTopLeft__" /* fillTopLeft */ + zIndex, {
      zIndex: zIndex + 2,
      width: expandCornerSize,
      height: expandCornerSize,
      radius: expandCornerSize / 2,
      visualWidth: expandCornerInnerSize,
      visualHeight: expandCornerInnerSize,
      strokeWidth: AutofillStrokeWidth
    });
    this._fillControlBottomRight = new Rect("__SpreadsheetSelectionFillControlBottomRight__" /* fillBottomRight */ + zIndex, {
      zIndex: zIndex + 2,
      width: expandCornerSize,
      height: expandCornerSize,
      radius: expandCornerSize / 2,
      visualHeight: expandCornerInnerSize,
      visualWidth: expandCornerInnerSize,
      strokeWidth: AutofillStrokeWidth
    });
    const fillProps = {
      fill: stroke,
      stroke: AutofillStroke,
      strokeScaleEnabled: false
    };
    this._fillControlTopLeft.setProps({ ...fillProps });
    this._fillControlBottomRight.setProps({ ...fillProps });
    const objs = [
      this._fillControlTopLeft,
      this._fillControlBottomRight
    ];
    switch (this._rangeType) {
      case 1 /* ROW */:
        this.rowHeaderGroup.addObjects(...objs);
        break;
      case 2 /* COLUMN */:
        this.columnHeaderGroup.addObjects(...objs);
        break;
      case 0 /* NORMAL */:
        this.selectionShapeGroup.addObjects(...objs);
    }
    const scene = this.getScene();
    scene.addObjects(objs, SHEET_COMPONENT_SELECTION_LAYER_INDEX);
  }
  get fillControlTopLeft() {
    return this._fillControlTopLeft;
  }
  set fillControlTopLeft(value) {
    this._fillControlTopLeft = value;
  }
  get fillControlBottomRight() {
    return this._fillControlBottomRight;
  }
  set fillControlBottomRight(value) {
    this._fillControlBottomRight = value;
  }
  get rangeType() {
    return this._rangeType;
  }
  set rangeType(value) {
    this._rangeType = value;
  }
  dispose() {
    var _a, _b;
    (_a = this._fillControlBottomRight) == null ? void 0 : _a.dispose();
    (_b = this._fillControlTopLeft) == null ? void 0 : _b.dispose();
    super.dispose();
  }
  _updateLayoutOfSelectionControl(style) {
    var _a, _b;
    super._updateLayoutOfSelectionControl(style);
    const defaultStyle = this.currentStyle;
    if (style == null) {
      style = defaultStyle;
    }
    const {
      widgets = defaultStyle.widgets
    } = style;
    this.currentStyle = style;
    if (this._enableAutoFill === true && !super._hasWidgets(widgets)) {
      const { viewportScrollX, viewportScrollY } = this.getViewportMainScrollInfo();
      const { endX, endY } = this.selectionModel;
      this.transformControlPoint(viewportScrollX, viewportScrollY, endX, endY);
      this.fillControlTopLeft.show();
      this.fillControlBottomRight.show();
    } else {
      (_a = this.fillControlTopLeft) == null ? void 0 : _a.hide();
      (_b = this.fillControlBottomRight) == null ? void 0 : _b.hide();
    }
  }
  getViewportMainScrollInfo() {
    const viewMain = this.getScene().getViewport("viewMain" /* VIEW_MAIN */);
    return {
      viewportScrollX: (viewMain == null ? void 0 : viewMain.viewportScrollX) || 0,
      viewportScrollY: (viewMain == null ? void 0 : viewMain.viewportScrollY) || 0,
      width: (viewMain == null ? void 0 : viewMain.width) || 0,
      height: (viewMain == null ? void 0 : viewMain.height) || 0
    };
  }
  /**
   * Mainly for row & col selection control point position. update control point position by when scrolling.
   * @param viewportScrollX viewportScrollX
   * @param viewportScrollY
   * @param sheetContentWidth
   * @param sheetContentHeight max sheet content height, for very short sheet, control pointer shoud not out of sheet
   */
  transformControlPoint(viewportScrollX = 0, viewportScrollY = 0, sheetContentWidth = 0, sheetContentHeight = 0) {
    const style = this.currentStyle;
    const rangeType = this.selectionModel.rangeType;
    const expandCornerSize = style.expandCornerSize;
    const { startX, startY, endX, endY } = this.selectionModel;
    const viewportSizeInfo = this.getViewportMainScrollInfo();
    const viewportW = viewportSizeInfo.width;
    const viewportH = viewportSizeInfo.height;
    switch (rangeType) {
      case 0 /* NORMAL */:
        this.fillControlTopLeft.transformByState({
          left: -expandCornerSize / 2,
          top: -expandCornerSize / 2
        });
        this.fillControlBottomRight.transformByState({
          left: endX - startX - expandCornerSize / 2,
          top: endY - startY - expandCornerSize / 2
        });
        break;
      case 1 /* ROW */:
        {
          const left = Math.min(viewportW / 2 + viewportScrollX, sheetContentWidth);
          const controlLeft = -expandCornerSize / 2 + left;
          this.fillControlTopLeft.transformByState({
            left: controlLeft,
            top: -expandCornerSize / 2
          });
          this.fillControlBottomRight.transformByState({
            left: controlLeft,
            top: -expandCornerSize / 2 + endY - startY
          });
        }
        break;
      case 2 /* COLUMN */:
        {
          const top = Math.min(+viewportH / 2 + viewportScrollY, sheetContentHeight);
          const controlTop = -expandCornerSize / 2 + top;
          this.fillControlTopLeft.transformByState({
            left: -expandCornerSize / 2,
            top: controlTop
          });
          this.fillControlBottomRight.transformByState({
            left: -expandCornerSize / 2 + endX - startX,
            top: controlTop
          });
        }
        break;
      default:
        console.error("unknown range type");
    }
  }
};

// ../packages/sheets-ui/src/services/selection/mobile-selection-render.service.ts
var MobileSheetsSelectionRenderService = class extends BaseSelectionRenderService {
  constructor(_context, injector, themeService, shortcutService, selectionManagerService, sheetSkeletonManagerService, _logService, _commandService, _contextService, _scrollManagerService) {
    super(
      injector,
      themeService,
      shortcutService,
      sheetSkeletonManagerService,
      _contextService
    );
    this._context = _context;
    this._logService = _logService;
    this._commandService = _commandService;
    this._contextService = _contextService;
    this._scrollManagerService = _scrollManagerService;
    __publicField(this, "_workbookSelections");
    __publicField(this, "_renderDisposable", null);
    __publicField(this, "_expandingSelection", false);
    __publicField(this, "_selectionControls", []);
    // sheetID:Controls
    __publicField(this, "expandingControlMode", "bottom-right" /* BOTTOM_RIGHT */);
    this._workbookSelections = selectionManagerService.getWorkbookSelections(this._context.unitId);
    this._init();
  }
  _init() {
    const sheetObject = this._getSheetObject();
    this._initEventListeners(sheetObject);
    this._initSelectionChangeListener();
    this._initSkeletonChangeListener();
    this._initUserActionSyncListener();
    this._updateControlPointWhenScrolling();
  }
  _initSkeletonChangeListener() {
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((param) => {
      if (param == null) {
        this._logService.error("[SelectionRenderService]: should not receive null!");
        return;
      }
      const unitId = this._context.unitId;
      const { sheetId, skeleton } = param;
      const { scene } = this._context;
      const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
      this._changeRuntime(skeleton, scene, viewportMain);
      const firstSelection = this._workbookSelections.getCurrentLastSelection();
      if (!firstSelection) {
        this._commandService.syncExecuteCommand(SetSelectionsOperation.id, {
          unitId,
          subUnitId: sheetId,
          selections: [getTopLeftSelectionOfCurrSheet(skeleton)]
        });
      }
    }));
  }
  _initSelectionChangeListener() {
  }
  _initEventListeners(sheetObject) {
    const { spreadsheetRowHeader, spreadsheetColumnHeader, spreadsheet, spreadsheetLeftTopPlaceholder } = sheetObject;
    const { scene } = this._context;
    this._initSpreadsheetEvent(sheetObject);
    this.disposeWithMe(
      spreadsheetRowHeader == null ? void 0 : spreadsheetRowHeader.onPointerUp$.subscribeEvent((evt, _state) => {
        if (this._normalSelectionDisabled()) return;
        const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
        const { row } = getCoordByOffset(evt.offsetX, evt.offsetY, scene, skeleton);
        const matchSelectionData = isThisRowSelected(this._workbookSelections.getCurrentSelections(), row);
        if (matchSelectionData) return;
        this.createNewSelection(evt, (spreadsheet.zIndex || 1) + 1, 1 /* ROW */, this._getActiveViewport(evt));
        this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
      })
    );
    this.disposeWithMe(
      spreadsheetColumnHeader == null ? void 0 : spreadsheetColumnHeader.onPointerUp$.subscribeEvent((evt, _state) => {
        if (this._normalSelectionDisabled()) return;
        const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
        const { column } = getCoordByOffset(evt.offsetX, evt.offsetY, scene, skeleton);
        const matchSelectionData = isThisColSelected(this._workbookSelections.getCurrentSelections(), column);
        if (matchSelectionData) return;
        this.createNewSelection(evt, (spreadsheet.zIndex || 1) + 1, 2 /* COLUMN */, this._getActiveViewport(evt));
        this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
      })
    );
    this.disposeWithMe(spreadsheetLeftTopPlaceholder == null ? void 0 : spreadsheetLeftTopPlaceholder.onPointerUp$.subscribeEvent((_evt, state) => {
      if (this._normalSelectionDisabled()) return;
      this._reset();
      const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
      const selectionWithStyle = selectionDataForSelectAll(skeleton);
      this._addSelectionControlByModelData(selectionWithStyle);
      this.refreshSelectionMoveStart();
      state.stopPropagation();
      this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
    }));
  }
  _initSpreadsheetEvent(sheetObject) {
    const { spreadsheet } = sheetObject;
    let longPressTimer;
    const longPressDuration = 500;
    const pointerDownPos = { x: 0, y: 0 };
    const clearLongPressTimer = () => {
      clearTimeout(longPressTimer);
    };
    const createNewSelection = (evt, showContextMenu) => {
      this.createNewSelection(
        evt,
        spreadsheet.zIndex + 1,
        0 /* NORMAL */,
        this._getActiveViewport(evt)
      );
      if (showContextMenu) {
        this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
      }
    };
    spreadsheet == null ? void 0 : spreadsheet.onPointerMove$.subscribeEvent((evt, _state) => {
      const edge = 10;
      if (Math.abs(evt.offsetX - pointerDownPos.x) > edge || Math.abs(evt.offsetY - pointerDownPos.y) > edge) {
        clearLongPressTimer();
      }
    });
    const spreadsheetPointerDownSub = spreadsheet == null ? void 0 : spreadsheet.onPointerDown$.subscribeEvent((evt, state) => {
      pointerDownPos.x = evt.offsetX;
      pointerDownPos.y = evt.offsetY;
      longPressTimer = setTimeout(() => {
        createNewSelection(evt, true);
      }, longPressDuration);
      state.stopPropagation();
    });
    const spreadsheetPointerUpSub = spreadsheet == null ? void 0 : spreadsheet.onPointerUp$.subscribeEvent((evt, state) => {
      if (this._normalSelectionDisabled()) return;
      clearTimeout(longPressTimer);
      const edge = 10;
      if (Math.abs(evt.offsetX - pointerDownPos.x) > edge || Math.abs(evt.offsetY - pointerDownPos.y) > edge) {
        return;
      }
      createNewSelection(evt, false);
      state.stopPropagation();
    });
    this.disposeWithMe(toDisposable(spreadsheetPointerDownSub));
    this.disposeWithMe(toDisposable(spreadsheetPointerUpSub));
  }
  _initUserActionSyncListener() {
    this.disposeWithMe(this.selectionMoveStart$.subscribe((params) => this._updateSelections(params, 0 /* MOVE_START */)));
    this.disposeWithMe(this.selectionMoving$.subscribe((params) => this._updateSelections(params, 1 /* MOVING */)));
    this.disposeWithMe(this._contextService.subscribeContextValue$(REF_SELECTIONS_ENABLED).pipe(startWith(false), distinctUntilChanged()).subscribe((disabled) => {
      var _a;
      if (disabled) {
        (_a = this._renderDisposable) == null ? void 0 : _a.dispose();
        this._renderDisposable = null;
        this._reset();
      } else {
        this._renderDisposable = toDisposable(
          this.selectionMoveEnd$.subscribe((params) => this._updateSelections(params, 2 /* MOVE_END */))
        );
      }
    }));
  }
  _updateSelections(selectionDataWithStyleList, type) {
    const workbook = this._context.unit;
    const unitId = workbook.getUnitId();
    const sheetId = workbook.getActiveSheet().getSheetId();
    if (selectionDataWithStyleList.length === 0) {
      return;
    }
    this._commandService.executeCommand(SetSelectionsOperation.id, {
      unitId,
      subUnitId: sheetId,
      type,
      selections: selectionDataWithStyleList.map(
        (selectionDataWithStyle) => convertSelectionDataToRange(selectionDataWithStyle)
      )
    });
  }
  /**
   * invoked when pointerup or long press on spreadsheet, or pointerdown on row&col
   * then move curr selection to cell at cursor
   * Main purpose to create a new selection, or update curr selection to a new range.
   * @param evt
   * @param _zIndex
   * @param rangeType
   * @param viewport
   */
  createNewSelection(evt, _zIndex = 0, rangeType = 0 /* NORMAL */, viewport) {
    this._rangeType = rangeType;
    const skeleton = this._skeleton;
    const scene = this._scene;
    if (!scene || !skeleton) {
      return;
    }
    if (viewport) {
      this._activeViewport = viewport;
    }
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    const { x: offsetX, y: offsetY } = relativeCoords;
    this._startViewportPosX = offsetX;
    this._startViewportPosY = offsetY;
    const scrollXY = scene.getScrollXYInfoByViewport(relativeCoords);
    const { scaleX, scaleY } = scene.getAncestorScale();
    const selectCell = this._skeleton.getCellByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
    if (!selectCell) return;
    switch (rangeType) {
      case 0 /* NORMAL */:
        break;
      case 1 /* ROW */:
        selectCell.startColumn = 0;
        selectCell.endColumn = this._skeleton.getColumnCount() - 1;
        break;
      case 2 /* COLUMN */:
        selectCell.startRow = 0;
        selectCell.endRow = this._skeleton.getRowCount() - 1;
        break;
      case 3 /* ALL */:
        selectCell.startRow = 0;
        selectCell.startColumn = 0;
        selectCell.endRow = this._skeleton.getRowCount() - 1;
        selectCell.endColumn = this._skeleton.getColumnCount() - 1;
    }
    const selectionWithStyle = { range: selectCell, primary: selectCell, style: null };
    selectionWithStyle.range.rangeType = rangeType;
    const selectionCellWithCoord = attachSelectionWithCoord(selectionWithStyle, this._skeleton);
    this._startRangeWhenPointerDown = { ...selectionCellWithCoord.rangeWithCoord };
    let activeSelectionControl = this.getActiveSelectionControl();
    const cursorRangeWidthCoord = { ...selectionCellWithCoord.rangeWithCoord };
    for (const control of this.getSelectionControls()) {
      if (control.model.isEqual(cursorRangeWidthCoord)) {
        activeSelectionControl = control;
        break;
      }
    }
    if ((activeSelectionControl == null ? void 0 : activeSelectionControl.model.rangeType) !== rangeType) {
      this._clearAllSelectionControls();
      activeSelectionControl = this.newSelectionControl(scene, skeleton, selectionWithStyle);
    } else {
      activeSelectionControl.updateRangeBySelectionWithCoord(selectionCellWithCoord);
    }
    this._selectionMoveStart$.next(this.getSelectionDataWithStyle());
    this._clearUpdatingListeners();
    this._expandingSelection = false;
  }
  /**
   * Not same as PC version,
   * new selection control for mobile do one more thing: bind event for two control points.
   * @param scene
   * @param rangeType
   */
  newSelectionControl(scene, skeleton, selection) {
    const selectionControls = this.getSelectionControls();
    const { rowHeaderWidth, columnHeaderHeight } = skeleton;
    const rangeType = selection.range.rangeType;
    const control = new MobileSelectionControl(scene, selectionControls.length, this._themeService, {
      highlightHeader: this._highlightHeader,
      rowHeaderWidth,
      columnHeaderHeight,
      rangeType
    });
    const selectionWithCoord = attachSelectionWithCoord(selection, skeleton);
    control.updateRangeBySelectionWithCoord(selectionWithCoord);
    this._selectionControls.push(control);
    const { expandingModeForTopLeft, expandingModeForBottomRight } = (() => {
      switch (rangeType) {
        case 0 /* NORMAL */:
          return {
            expandingModeForTopLeft: "top-left" /* TOP_LEFT */,
            expandingModeForBottomRight: "bottom-right" /* BOTTOM_RIGHT */
          };
        case 1 /* ROW */:
          return {
            expandingModeForTopLeft: "top" /* TOP */,
            expandingModeForBottomRight: "bottom" /* BOTTOM */
          };
        case 2 /* COLUMN */:
          return {
            expandingModeForTopLeft: "left" /* LEFT */,
            expandingModeForBottomRight: "right" /* RIGHT */
          };
        case 3 /* ALL */:
          return {
            expandingModeForTopLeft: "top-left" /* TOP_LEFT */,
            expandingModeForBottomRight: "bottom-right" /* BOTTOM_RIGHT */
          };
        default:
          return {
            expandingModeForTopLeft: "top-left" /* TOP_LEFT */,
            expandingModeForBottomRight: "bottom-right" /* BOTTOM_RIGHT */
          };
      }
    })();
    control.fillControlTopLeft.onPointerDown$.subscribeEvent((evt) => {
      this._expandingSelection = true;
      this.expandingControlMode = expandingModeForTopLeft;
      this._selectionMoveStart$.next(this.getSelectionDataWithStyle());
      this._fillControlPointerDownHandler(
        evt,
        rangeType,
        this._activeViewport
      );
    });
    control.fillControlBottomRight.onPointerDown$.subscribeEvent((evt) => {
      this._expandingSelection = true;
      this.expandingControlMode = expandingModeForBottomRight;
      this._selectionMoveStart$.next(this.getSelectionDataWithStyle());
      this._fillControlPointerDownHandler(
        evt,
        rangeType,
        this._activeViewport
      );
    });
    if (rangeType === 1 /* ROW */ || rangeType === 2 /* COLUMN */) {
      const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
      if (!viewportMain) return control;
    }
    return control;
  }
  // same as PC
  _getActiveViewport(evt) {
    const sheetObject = this._getSheetObject();
    return sheetObject == null ? void 0 : sheetObject.scene.getActiveViewportByCoord(Vector2.FromArray([evt.offsetX, evt.offsetY]));
  }
  // same as PC
  _getSheetObject() {
    return getSheetObject(this._context.unit, this._context);
  }
  // same as PC
  _normalSelectionDisabled() {
    return this._contextService.getContextValue(REF_SELECTIONS_ENABLED);
  }
  getSelectionControls() {
    return this._selectionControls;
  }
  _fillControlPointerDownHandler(evt, rangeType = 0 /* NORMAL */, viewport, scrollTimerType = 3 /* ALL */) {
    var _a, _b, _c;
    const skeleton = this._skeleton;
    const scene = this._scene;
    if (!scene || !skeleton) {
      return;
    }
    if (viewport) {
      this._activeViewport = viewport;
    }
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const activeSelectionControl = this.getActiveSelectionControl();
    if (!activeSelectionControl) return;
    this._changeCurrCellWhenControlPointerDown();
    this._selectionMoveStart$.next(this.getSelectionDataWithStyle());
    this._clearUpdatingListeners();
    this._addEndingListeners();
    this._scrollTimer = ScrollTimer.create(this._scene, scrollTimerType);
    this._scrollTimer.startScroll((_a = viewportMain == null ? void 0 : viewportMain.left) != null ? _a : 0, (_b = viewportMain == null ? void 0 : viewportMain.top) != null ? _b : 0, viewportMain);
    (_c = scene.getTransformer()) == null ? void 0 : _c.clearSelectedObjects();
    const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evt.offsetX, evt.offsetY]));
    this._setupPointerMoveListener(viewportMain, activeSelectionControl, rangeType, scrollTimerType, relativeCoords.x, relativeCoords.y);
    const disposableShortcut = this._shortcutService.forceEscape();
    this._scenePointerUpSub = scene.onPointerUp$.subscribeEvent((_evt) => {
      this.endSelection();
      this._expandingSelection = false;
      this.expandingControlMode = "bottom-right" /* BOTTOM_RIGHT */;
      this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
      disposableShortcut.dispose();
    });
  }
  _changeCurrCellWhenControlPointerDown() {
    const activeSelectionControl = this.getActiveSelectionControl();
    const skeleton = this._skeleton;
    let currCellRange;
    const { startRow, startColumn, endRow, endColumn } = activeSelectionControl.model;
    switch (this.expandingControlMode) {
      case "top-left" /* TOP_LEFT */:
        currCellRange = skeleton.getCellWithCoordByIndex(endRow, endColumn);
        break;
      case "bottom-right" /* BOTTOM_RIGHT */:
        currCellRange = skeleton.getCellWithCoordByIndex(startRow, startColumn);
        break;
      case "left" /* LEFT */:
        currCellRange = skeleton.getCellWithCoordByIndex(startRow, endColumn);
        currCellRange.isMerged = false;
        currCellRange.isMergedMainCell = false;
        break;
      case "right" /* RIGHT */:
        currCellRange = skeleton.getCellWithCoordByIndex(startRow, startColumn);
        currCellRange.isMerged = false;
        currCellRange.isMergedMainCell = false;
        break;
      case "top" /* TOP */:
        currCellRange = skeleton.getCellWithCoordByIndex(endRow, startColumn);
        currCellRange.isMerged = false;
        currCellRange.isMergedMainCell = false;
        break;
      case "bottom" /* BOTTOM */:
        currCellRange = skeleton.getCellWithCoordByIndex(startRow, startColumn);
        currCellRange.isMerged = false;
        currCellRange.isMergedMainCell = false;
        break;
      default:
        currCellRange = skeleton.getCellWithCoordByIndex(startRow, startColumn);
    }
    activeSelectionControl.updateCurrCell(currCellRange);
    return currCellRange;
  }
  /**
   * Not same as _moving in PC (base selection render service)
   * The diff is
   * In base version, new selection is determined by the cursor cell and _startRangeWhenPointerDown
   *
   * In Mobile version, new selection is determined by cursor cell and current of activeSelectionControl.model
   */
  _movingHandler(offsetX, offsetY, activeSelectionControl, rangeType) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    this._rangeType = rangeType;
    const skeleton = this._skeleton;
    const scene = this._scene;
    const currSelectionRange = {
      startRow: activeSelectionControl.model.startRow,
      endRow: activeSelectionControl.model.endRow,
      startColumn: activeSelectionControl.model.startColumn,
      endColumn: activeSelectionControl.model.endColumn
    };
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    const targetViewport = (_a = this._getViewportByCell(currSelectionRange.endRow, currSelectionRange.endColumn)) != null ? _a : viewportMain;
    const scrollXY = scene.getScrollXYInfoByViewport(
      Vector2.FromArray([this._startViewportPosX, this._startViewportPosY]),
      targetViewport
    );
    const { scaleX, scaleY } = scene.getAncestorScale();
    if (rangeType === 1 /* ROW */) {
      offsetX = Number.POSITIVE_INFINITY;
    } else if (rangeType === 2 /* COLUMN */) {
      offsetY = Number.POSITIVE_INFINITY;
    }
    const cursorCellRangeInfo = this._getSelectionWithCoordByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
    if (!cursorCellRangeInfo) {
      return false;
    }
    const { rangeWithCoord: cursorCellRange } = cursorCellRangeInfo;
    const currCellRange = activeSelectionControl.model.currentCell;
    const startRowOfActiveCell = (_b = currCellRange == null ? void 0 : currCellRange.mergeInfo.startRow) != null ? _b : -1;
    const endRowOfActiveCell = (_c = currCellRange == null ? void 0 : currCellRange.mergeInfo.endRow) != null ? _c : -1;
    const startColumnOfActiveCell = (_d = currCellRange == null ? void 0 : currCellRange.mergeInfo.startColumn) != null ? _d : -1;
    const endColOfActiveCell = (_e = currCellRange == null ? void 0 : currCellRange.mergeInfo.endColumn) != null ? _e : -1;
    let newSelectionRange = {
      startRow: Math.min(cursorCellRange.startRow, startRowOfActiveCell),
      startColumn: Math.min(cursorCellRange.startColumn, startColumnOfActiveCell),
      endRow: Math.max(cursorCellRange.endRow, endRowOfActiveCell),
      endColumn: Math.max(cursorCellRange.endColumn, endColOfActiveCell)
    };
    if (rangeType === 0 /* NORMAL */) {
      newSelectionRange = skeleton.expandRangeByMerge(newSelectionRange);
    } else if (rangeType === 2 /* COLUMN */) {
      newSelectionRange = {
        startRow: Math.min(cursorCellRange.startRow, (_f = currCellRange == null ? void 0 : currCellRange.actualRow) != null ? _f : -1),
        startColumn: Math.min(cursorCellRange.startColumn, (_g = currCellRange == null ? void 0 : currCellRange.actualColumn) != null ? _g : -1),
        endRow: Math.max(cursorCellRange.endRow, (_h = currCellRange == null ? void 0 : currCellRange.actualRow) != null ? _h : -1),
        endColumn: Math.max(cursorCellRange.endColumn, (_i = currCellRange == null ? void 0 : currCellRange.actualColumn) != null ? _i : -1)
      };
    } else if (rangeType === 1 /* ROW */) {
      newSelectionRange = {
        startRow: Math.min(cursorCellRange.startRow, (_j = currCellRange == null ? void 0 : currCellRange.actualRow) != null ? _j : -1),
        startColumn: Math.min(cursorCellRange.startColumn, (_k = currCellRange == null ? void 0 : currCellRange.actualColumn) != null ? _k : -1),
        endRow: Math.max(cursorCellRange.endRow, (_l = currCellRange == null ? void 0 : currCellRange.actualRow) != null ? _l : -1),
        endColumn: Math.max(cursorCellRange.endColumn, (_m = currCellRange == null ? void 0 : currCellRange.actualColumn) != null ? _m : -1)
      };
    }
    if (!newSelectionRange) {
      return false;
    }
    const newSelection = { range: newSelectionRange, style: null, primary: null };
    const newSelectionRangeWithCoord = attachSelectionWithCoord(newSelection, skeleton);
    const rangeChanged = currSelectionRange.startRow !== newSelectionRange.startRow || currSelectionRange.startColumn !== newSelectionRange.startColumn || currSelectionRange.endRow !== newSelectionRange.endRow || currSelectionRange.endColumn !== newSelectionRange.endColumn;
    if (rangeChanged) {
      if (activeSelectionControl) {
        activeSelectionControl.updateRangeBySelectionWithCoord(newSelectionRangeWithCoord);
        this._selectionMoving$.next(this.getSelectionDataWithStyle());
      }
    }
  }
  _updateControlPointWhenScrolling() {
    const { scene } = this._context;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (!viewportMain) return;
    const sub = this._scrollManagerService.validViewportScrollInfo$.subscribe((param) => {
      var _a;
      if (param == null) {
        return;
      }
      const { viewportScrollX, viewportScrollY } = param;
      const activeControl = this.getActiveSelectionControl();
      if (activeControl == null) {
        return;
      }
      const skeleton = (_a = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a.skeleton;
      const sheetContentHeight = skeleton == null ? void 0 : skeleton.rowTotalHeight;
      const sheetContentWidth = skeleton == null ? void 0 : skeleton.columnTotalWidth;
      const rangeType = activeControl.rangeType;
      if (rangeType === 2 /* COLUMN */) {
        activeControl.transformControlPoint(0, viewportScrollY, sheetContentWidth, sheetContentHeight);
      } else if (rangeType === 1 /* ROW */) {
        activeControl.transformControlPoint(viewportScrollX, 0, sheetContentWidth, sheetContentHeight);
      }
    });
    this.disposeWithMe(toDisposable(sub));
  }
};
MobileSheetsSelectionRenderService = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, Inject(ThemeService)),
  __decorateParam(3, IShortcutService),
  __decorateParam(4, Inject(SheetsSelectionsService)),
  __decorateParam(5, Inject(SheetSkeletonManagerService)),
  __decorateParam(6, ILogService),
  __decorateParam(7, ICommandService),
  __decorateParam(8, IContextService),
  __decorateParam(9, Inject(SheetScrollManagerService))
], MobileSheetsSelectionRenderService);

// ../packages/sheets-ui/src/mobile-plugin.ts
var UniverSheetsMobileUIPlugin = class extends Plugin {
  constructor(_config = defaultPluginConfig, _injector, _renderManagerService, _univerInstanceService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._renderManagerService = _renderManagerService;
    this._univerInstanceService = _univerInstanceService;
  }
  onStarting() {
    [
      [ShortcutExperienceService],
      [ISheetClipboardService, { useClass: SheetClipboardService }],
      [ISheetBarService, { useClass: SheetBarService }],
      [IFormatPainterService, { useClass: FormatPainterService }],
      [IAutoFillService, { useClass: AutoFillService }],
      [SheetPrintInterceptorService],
      [ISheetSelectionRenderService, { useClass: MobileSheetsSelectionRenderService }],
      [IStatusBarService, { useClass: StatusBarService }],
      [IMarkSelectionService, { useClass: MarkSelectionService }],
      [HoverManagerService],
      [DragManagerService],
      [SheetCanvasPopManagerService],
      [CellAlertManagerService],
      [SelectAllService],
      [ActiveWorksheetController],
      [AutoHeightController],
      [SheetClipboardController],
      [SheetsRenderService],
      [SheetUIMobileController],
      [StatusBarController],
      [IRefSelectionsService, { useClass: RefSelectionsService }],
      // permission
      [SheetPermissionPanelModel],
      [SheetPermissionUserManagerService],
      [WorksheetProtectionRenderController],
      [SheetPermissionInterceptorClipboardController],
      [SheetPermissionCheckUIController],
      [SheetPermissionRenderManagerController]
    ].forEach((d) => this._injector.add(d));
  }
  onReady() {
    this._markSheetAsFocused();
    this._registerRenderBasics();
    this._injector.get(SheetUIMobileController);
  }
  onRendered() {
    this._registerRenderModules();
  }
  _registerRenderBasics() {
    [
      [SheetSkeletonManagerService],
      [SheetRenderController],
      [ISheetSelectionRenderService, { useClass: MobileSheetsSelectionRenderService }],
      [SheetScrollManagerService]
    ].forEach((renderDep) => {
      this.disposeWithMe(this._renderManagerService.registerRenderModule(O.UNIVER_SHEET, renderDep));
    });
  }
  // We have to let render basics get bootstrapped before. Because some render controllers relies on
  // a correct skeleton when they get loaded.
  _registerRenderModules() {
    [
      // https://github.com/dream-num/univer-pro/issues/669
      // HeaderMoveRenderController(HMRC) must be initialized before SelectionRenderController(SRC).
      // Before HMRC expected selections remain unchanged when user clicks on the header. If we don't initialize HMRC before SRC,
      // the selections will be changed by SRC first. Maybe we should merge row/col header related render controllers to one class.
      [HeaderMoveRenderController],
      [HeaderFreezeRenderController],
      // Caution: ScrollRenderController should placed before ZoomRenderController
      // because ZoomRenderController would change scrollInfo in currentSkeletonBefore$.
      [MobileSheetsScrollRenderController],
      [SheetsZoomRenderController],
      [FormatPainterRenderController],
      [CellAlertRenderController],
      [ForceStringAlertRenderController],
      [MarkSelectionRenderController],
      [HoverRenderController],
      [DragRenderController],
      [ForceStringRenderController],
      [CellCustomRenderController],
      [SheetContextMenuMobileRenderController],
      [SheetPermissionInterceptorCanvasRenderController],
      [SheetPermissionInterceptorFormulaRenderController],
      [SheetPermissionRenderController]
    ].forEach((renderModule) => {
      this.disposeWithMe(this._renderManagerService.registerRenderModule(O.UNIVER_SHEET, renderModule));
    });
  }
  _markSheetAsFocused() {
    const univerInstanceService = this._univerInstanceService;
    this.disposeWithMe(univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).pipe(filter((v) => !!v)).subscribe((workbook) => {
      if (this._univerInstanceService.getFocusedUnit() === workbook) return;
      univerInstanceService.focusUnit(workbook.getUnitId());
    }));
  }
};
__publicField(UniverSheetsMobileUIPlugin, "pluginName", "SHEET_UI_PLUGIN");
__publicField(UniverSheetsMobileUIPlugin, "type", O.UNIVER_SHEET);
UniverSheetsMobileUIPlugin = __decorateClass([
  DependentOn(UniverSheetsPlugin, UniverMobileUIPlugin),
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IRenderManagerService),
  __decorateParam(3, IUniverInstanceService)
], UniverSheetsMobileUIPlugin);

// ../packages/sheets-ui/src/controllers/auto-fill.controller.ts
var AutoFillController = class extends Disposable {
  constructor(_univerInstanceService, _commandService, _autoFillService, _editorBridgeService, _renderManagerService, _injector, _sheetsRenderService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._commandService = _commandService;
    this._autoFillService = _autoFillService;
    this._editorBridgeService = _editorBridgeService;
    this._renderManagerService = _renderManagerService;
    this._injector = _injector;
    this._sheetsRenderService = _sheetsRenderService;
    __publicField(this, "_beforeApplyData", []);
    __publicField(this, "_currentLocation", null);
    __publicField(this, "_copyData", []);
    __publicField(this, "_defaultHook");
    this._defaultHook = {
      id: "default",
      type: "DEFAULT" /* Default */,
      priority: 0,
      onBeforeFillData: (location, direction) => {
        return this._presetAndCacheData(location, direction);
      },
      onFillData: (location, direction, applyType) => {
        return this._fillData(location, direction, applyType);
      }
    };
    this._init();
  }
  _init() {
    this._initDefaultHook();
    this._initSelectionControlFillChanged();
    this._initQuitListener();
    this._initSkeletonChange();
  }
  _initSkeletonChange() {
    this.disposeWithMe(this._sheetsRenderService.registerSkeletonChangingMutations(AutoFillCommand.id));
  }
  _initDefaultHook() {
    this.disposeWithMe(this._autoFillService.addHook(this._defaultHook));
  }
  _initQuitListener() {
    const quitCommands = [
      SetCellEditVisibleOperation.id,
      AutoClearContentCommand.id,
      SetRangeValuesCommand.id,
      SetZoomRatioOperation.id,
      SetWorksheetActiveOperation.id,
      MoveRangeMutation.id,
      RemoveRowMutation.id,
      RemoveColMutation.id,
      InsertRowMutation.id,
      InsertColMutation.id,
      MoveRowsMutation.id,
      MoveColsMutation.id,
      SetWorksheetColWidthMutation.id,
      SetWorksheetRowHeightMutation.id,
      SetRangeValuesMutation.id
    ];
    this.disposeWithMe(this._commandService.onCommandExecuted((command, options) => {
      var _a, _b;
      const fromCollab = options == null ? void 0 : options.fromCollab;
      const fromSync = options == null ? void 0 : options.fromSync;
      const fromFormula = options == null ? void 0 : options.fromFormula;
      if (quitCommands.includes(command.id) && !fromCollab && !fromSync && !fromFormula && command.params.trigger !== AutoFillCommand.id && command.params.trigger !== RefillCommand.id) {
        this._quit();
      }
      if (command.id === RemoveSheetMutation.id) {
        if (command.params.unitId === ((_a = this._currentLocation) == null ? void 0 : _a.unitId) && command.params.subUnitId === ((_b = this._currentLocation) == null ? void 0 : _b.subUnitId)) {
          this._quit();
        }
      }
    }));
    this.disposeWithMe(this._univerInstanceService.unitDisposed$.subscribe((unit) => {
      var _a;
      if (unit.getUnitId() === ((_a = this._currentLocation) == null ? void 0 : _a.unitId)) {
        this._quit();
      }
    }));
  }
  _quit() {
    this._currentLocation = null;
    this._beforeApplyData = [];
    this._copyData = [];
    this._autoFillService.setShowMenu(false);
  }
  _initSelectionControlFillChanged() {
    const disposableCollection = new DisposableCollection();
    const updateListener = () => {
      disposableCollection.dispose();
      const currentRenderer = getCurrentTypeOfRenderer(O.UNIVER_SHEET, this._univerInstanceService, this._renderManagerService);
      if (!currentRenderer) return;
      const selectionRenderService = currentRenderer.with(ISheetSelectionRenderService);
      const selectionControls = selectionRenderService.getSelectionControls();
      selectionControls.forEach((controlSelection) => {
        disposableCollection.add(controlSelection.selectionFilled$.subscribe((filled) => {
          if (filled == null || filled.startColumn === -1 || filled.startRow === -1 || filled.endColumn === -1 || filled.endRow === -1) {
            return;
          }
          const source = {
            startColumn: controlSelection.model.startColumn,
            endColumn: controlSelection.model.endColumn,
            startRow: controlSelection.model.startRow,
            endRow: controlSelection.model.endRow
          };
          const selection = {
            startColumn: filled.startColumn,
            endColumn: filled.endColumn,
            startRow: filled.startRow,
            endRow: filled.endRow
          };
          this._commandService.executeCommand(AutoFillCommand.id, { sourceRange: source, targetRange: selection });
        }));
        disposableCollection.add(controlSelection.fillControl.onDblclick$.subscribeEvent(() => {
          const source = {
            startColumn: controlSelection.model.startColumn,
            endColumn: controlSelection.model.endColumn,
            startRow: controlSelection.model.startRow,
            endRow: controlSelection.model.endRow
          };
          this._handleDbClickFill(source);
        }));
        disposableCollection.add(controlSelection.fillControl.onPointerDown$.subscribeEvent(() => {
          const visibleState = this._editorBridgeService.isVisible();
          if (visibleState.visible) {
            this._commandService.syncExecuteCommand(
              SetCellEditVisibleOperation.id,
              {
                visible: false,
                eventType: 1 /* PointerDown */,
                unitId: currentRenderer.unitId
              }
            );
          }
        }));
      });
    };
    updateListener();
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      if (command.id === SetSelectionsOperation.id) {
        updateListener();
      }
    }));
    this.disposeWithMe(this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).subscribe(() => updateListener()));
  }
  _handleDbClickFill(source) {
    const selection = this._detectFillRange(source);
    if (selection.endRow <= source.endRow) {
      return;
    }
    this._commandService.executeCommand(AutoFillCommand.id, { sourceRange: source, targetRange: selection });
  }
  _detectFillRange(source) {
    var _a, _b, _c, _d, _e, _f;
    const { startRow, endRow, startColumn, endColumn } = source;
    const worksheet = (_a = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET)) == null ? void 0 : _a.getActiveSheet();
    if (!worksheet) {
      return source;
    }
    const matrix = worksheet.getCellMatrix();
    const maxRow = worksheet.getMaxRows() - 1;
    const maxColumn = worksheet.getMaxColumns() - 1;
    let detectEndRow = endRow;
    if (startColumn > 0 && ((_b = matrix.getValue(startRow, startColumn - 1)) == null ? void 0 : _b.v) != null) {
      let cur = startRow;
      while (((_c = matrix.getValue(cur, startColumn - 1)) == null ? void 0 : _c.v) != null && cur < maxRow) {
        cur += 1;
      }
      detectEndRow = cur - 1;
    } else if (endColumn < maxColumn && ((_d = matrix.getValue(endRow, endColumn + 1)) == null ? void 0 : _d.v) != null) {
      let cur = startRow;
      while (((_e = matrix.getValue(cur, endColumn + 1)) == null ? void 0 : _e.v) != null && cur < maxRow) {
        cur += 1;
      }
      detectEndRow = cur - 1;
    }
    for (let i = endRow + 1; i <= detectEndRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        if (((_f = matrix.getValue(i, j)) == null ? void 0 : _f.v) != null) {
          detectEndRow = i - 1;
          break;
        }
      }
    }
    return {
      startColumn,
      endColumn,
      startRow,
      endRow: detectEndRow
    };
  }
  // calc apply data according to copy data and direction
  _getApplyData(copyDataPiece, csLen, asLen, direction, applyType, hasStyle = true, location) {
    const applyData = [];
    const num = Math.floor(asLen / csLen);
    const rsd = asLen % csLen;
    const rules = this._autoFillService.getRules();
    if (!hasStyle && applyType === "ONLY_FORMAT" /* ONLY_FORMAT */) {
      console.error("ERROR: only format can not be applied when hasStyle is false");
      return [];
    }
    const applyDataInTypes = {};
    rules.forEach((r) => {
      applyDataInTypes[r.type] = [];
    });
    rules.forEach((r) => {
      const { type, applyFunctions: customApplyFunctions = {} } = r;
      const copyDataInType = copyDataPiece[type];
      if (!copyDataInType) {
        return;
      }
      copyDataInType.forEach((copySquad) => {
        const s = getLenS(copySquad.index, rsd);
        const len = copySquad.index.length * num + s;
        const arrData = this._applyFunctions(
          copySquad,
          len,
          direction,
          applyType,
          customApplyFunctions,
          copyDataPiece,
          location
        );
        const arrIndex = getDataIndex(csLen, asLen, copySquad.index);
        applyDataInTypes[type].push({ data: arrData, index: arrIndex });
      });
    });
    for (let x = 0; x < asLen; x++) {
      rules.forEach((r) => {
        const { type } = r;
        const applyDataInType = applyDataInTypes[type];
        for (let y = 0; y < applyDataInType.length; y++) {
          if (x in applyDataInType[y].index) {
            applyData.push(applyDataInType[y].data[applyDataInType[y].index[x]]);
          }
        }
      });
    }
    return applyData;
  }
  _applyFunctions(copySquad, len, direction, applyType, customApplyFunctions, copyDataPiece, location) {
    const { data } = copySquad;
    const isReverse = direction === 0 /* UP */ || direction === 3 /* LEFT */;
    if (applyType === "COPY" /* COPY */) {
      const custom = customApplyFunctions == null ? void 0 : customApplyFunctions["COPY" /* COPY */];
      if (custom) {
        return custom(copySquad, len, direction, copyDataPiece, location);
      }
      isReverse && data.reverse();
      return fillCopy(data, len);
    }
    if (applyType === "SERIES" /* SERIES */) {
      const custom = customApplyFunctions == null ? void 0 : customApplyFunctions["SERIES" /* SERIES */];
      if (custom) {
        return custom(copySquad, len, direction, copyDataPiece);
      }
      isReverse && data.reverse();
      if (customApplyFunctions == null ? void 0 : customApplyFunctions["COPY" /* COPY */]) {
        return customApplyFunctions["COPY" /* COPY */](copySquad, len, direction, copyDataPiece, location);
      }
      return fillCopy(data, len);
    }
    if (applyType === "ONLY_FORMAT" /* ONLY_FORMAT */) {
      const custom = customApplyFunctions == null ? void 0 : customApplyFunctions["ONLY_FORMAT" /* ONLY_FORMAT */];
      if (custom) {
        return custom(copySquad, len, direction, copyDataPiece);
      }
      return fillCopyStyles(data, len);
    }
  }
  _getCopyData(source, direction) {
    const worksheet = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getActiveSheet();
    if (!worksheet) {
      throw new Error("No active sheet found");
    }
    const currentCellDatas = worksheet.getCellMatrix();
    const rules = this._autoFillService.getRules();
    const copyData = [];
    const isVertical = direction === 2 /* DOWN */ || direction === 0 /* UP */;
    let aArray;
    let bArray;
    if (isVertical) {
      aArray = source.cols;
      bArray = source.rows;
    } else {
      aArray = source.rows;
      bArray = source.cols;
    }
    aArray.forEach((a2) => {
      const copyDataPiece = this._getEmptyCopyDataPiece();
      const prevData = {
        type: void 0,
        cellData: void 0
      };
      bArray.forEach((b) => {
        let data;
        if (isVertical) {
          data = currentCellDatas.getValue(b, a2);
        } else {
          data = currentCellDatas.getValue(a2, b);
        }
        const { type, isContinue } = rules.find((r) => r.match(data, this._injector)) || otherRule;
        if (isContinue(prevData, data)) {
          const typeInfo = copyDataPiece[type];
          const last = typeInfo[typeInfo.length - 1];
          last.data.push(data);
          last.index.push(b - bArray[0]);
        } else {
          const typeInfo = copyDataPiece[type];
          if (typeInfo) {
            typeInfo.push({
              data: [data],
              index: [b - bArray[0]]
            });
          } else {
            copyDataPiece[type] = [
              {
                data: [data],
                index: [b - bArray[0]]
              }
            ];
          }
        }
        prevData.type = type;
        prevData.cellData = data;
      });
      copyData.push(copyDataPiece);
    });
    return copyData;
  }
  _getEmptyCopyDataPiece() {
    const copyDataPiece = {};
    this._autoFillService.getRules().forEach((r) => {
      copyDataPiece[r.type] = [];
    });
    return copyDataPiece;
  }
  _getMergeApplyData(source, target, direction, csLen) {
    const worksheet = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getActiveSheet();
    if (!worksheet) {
      throw new Error("No active sheet found");
    }
    const applyMergeRanges = [];
    for (let i = source.startRow; i <= source.endRow; i++) {
      for (let j = source.startColumn; j <= source.endColumn; j++) {
        const { isMergedMainCell, startRow, startColumn, endRow, endColumn } = worksheet.getCellInfoInMergeData(i, j);
        if (isMergedMainCell) {
          if (direction === 2 /* DOWN */) {
            let windowStartRow = startRow + csLen;
            let windowEndRow = endRow + csLen;
            while (windowEndRow <= target.endRow) {
              applyMergeRanges.push({
                startRow: windowStartRow,
                startColumn,
                endRow: windowEndRow,
                endColumn
              });
              windowStartRow += csLen;
              windowEndRow += csLen;
            }
          } else if (direction === 0 /* UP */) {
            let windowStartRow = startRow - csLen;
            let windowEndRow = endRow - csLen;
            while (windowStartRow >= target.startRow) {
              applyMergeRanges.push({
                startRow: windowStartRow,
                startColumn,
                endRow: windowEndRow,
                endColumn
              });
              windowStartRow -= csLen;
              windowEndRow -= csLen;
            }
          } else if (direction === 1 /* RIGHT */) {
            let windowStartColumn = startColumn + csLen;
            let windowEndColumn = endColumn + csLen;
            while (windowEndColumn <= target.endColumn) {
              applyMergeRanges.push({
                startRow,
                startColumn: windowStartColumn,
                endRow,
                endColumn: windowEndColumn
              });
              windowStartColumn += csLen;
              windowEndColumn += csLen;
            }
          } else if (direction === 3 /* LEFT */) {
            let windowStartColumn = startColumn - csLen;
            let windowEndColumn = endColumn - csLen;
            while (windowStartColumn >= target.startColumn) {
              applyMergeRanges.push({
                startRow,
                startColumn: windowStartColumn,
                endRow,
                endColumn: windowEndColumn
              });
              windowStartColumn -= csLen;
              windowEndColumn -= csLen;
            }
          }
        }
      }
    }
    return applyMergeRanges;
  }
  _presetAndCacheData(location, direction) {
    const { source, target } = location;
    const worksheet = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getActiveSheet();
    if (!worksheet) {
      throw new Error("No active sheet found");
    }
    const currentCellDatas = worksheet.getCellMatrix();
    const applyData = [];
    target.rows.forEach((i) => {
      const row = [];
      target.cols.forEach((j) => {
        row.push(Tools.deepClone(currentCellDatas.getValue(i, j)));
      });
      applyData.push(row);
    });
    this._beforeApplyData = applyData;
    this._copyData = this._getCopyData(source, direction);
    this._currentLocation = location;
    if (this._shouldDisableSeries(this._copyData)) {
      this._autoFillService.setDisableApplyType("SERIES" /* SERIES */, true);
      return "COPY" /* COPY */;
    } else {
      this._autoFillService.setDisableApplyType("SERIES" /* SERIES */, false);
    }
    return this._getPreferredApplyType(this._copyData);
  }
  // auto fill entry
  // eslint-disable-next-line max-lines-per-function
  _fillData(location, direction, applyType) {
    var _a, _b;
    const undos = [];
    const redos = [];
    let hasStyle = true;
    if (applyType === "NO_FORMAT" /* NO_FORMAT */) {
      hasStyle = false;
      applyType = "SERIES" /* SERIES */;
    }
    const { source, target, unitId, subUnitId } = location;
    if (!source || !target || direction == null) {
      return {
        undos,
        redos
      };
    }
    const sourceRange = discreteRangeToRange(source);
    const targetRange = discreteRangeToRange(target);
    const { cols: targetCols, rows: targetRows } = target;
    const { cols: sourceCols, rows: sourceRows } = source;
    const copyData = this._copyData;
    let csLen;
    if (direction === 2 /* DOWN */ || direction === 0 /* UP */) {
      csLen = sourceRows.length;
    } else {
      csLen = sourceCols.length;
    }
    const applyDatas = [];
    if (direction === 2 /* DOWN */ || direction === 0 /* UP */) {
      const asLen = targetRows.length;
      const untransformedApplyDatas = [];
      targetCols.forEach((_, i) => {
        const copyD = copyData[i];
        const applyData = this._getApplyData(copyD, csLen, asLen, direction, applyType, hasStyle, location);
        untransformedApplyDatas.push(applyData);
      });
      for (let i = 0; i < untransformedApplyDatas[0].length; i++) {
        const row = [];
        for (let j = 0; j < untransformedApplyDatas.length; j++) {
          row.push({
            s: null,
            ...untransformedApplyDatas[j][i]
          });
        }
        applyDatas.push(row);
      }
    } else {
      const asLen = targetCols.length;
      targetRows.forEach((_, i) => {
        const copyD = copyData[i];
        const applyData = this._getApplyData(copyD, csLen, asLen, direction, applyType, hasStyle, location);
        const row = [];
        for (let j = 0; j < applyData.length; j++) {
          row.push({
            s: null,
            ...applyData[j]
          });
        }
        applyDatas.push(row);
      });
    }
    let applyMergeRanges = [];
    const style = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getStyles();
    if (hasStyle) {
      applyMergeRanges = this._getMergeApplyData(sourceRange, targetRange, direction, csLen);
      applyDatas.forEach((row) => {
        row.forEach((cellData) => {
          if (cellData && style) {
            if (style) {
              cellData.s = style.getStyleByCell(cellData);
            }
          }
        });
      });
    } else {
      applyDatas.forEach((row, rowIndex) => {
        row.forEach((cellData, colIndex) => {
          if (cellData && style) {
            cellData.s = style.getStyleByCell(this._beforeApplyData[rowIndex][colIndex]) || null;
          }
        });
      });
    }
    if (applyType === "ONLY_FORMAT" /* ONLY_FORMAT */) {
      applyDatas.forEach((row, rowIndex) => {
        row.forEach((cellData, colIndex) => {
          if (cellData) {
            const old = this._beforeApplyData[rowIndex][colIndex] || {};
            cellData.f = old.f;
            cellData.si = old.si;
            cellData.t = old.t;
            cellData.v = old.v;
          }
        });
      });
    }
    if (hasStyle) {
      const deleteMergeRanges = [];
      const mergeData = (_b = (_a = this._univerInstanceService.getUniverSheetInstance(unitId)) == null ? void 0 : _a.getSheetBySheetId(subUnitId)) == null ? void 0 : _b.getMergeData();
      if (mergeData) {
        mergeData.forEach((merge2) => {
          if (Rectangle.intersects(merge2, targetRange)) {
            deleteMergeRanges.push(merge2);
          }
        });
      }
      const removeMergeMutationParams = {
        unitId,
        subUnitId,
        ranges: deleteMergeRanges
      };
      const undoRemoveMergeMutationParams = this._injector.invoke(
        RemoveMergeUndoMutationFactory,
        removeMergeMutationParams
      );
      if (deleteMergeRanges.length) {
        redos.push({ id: RemoveWorksheetMergeMutation.id, params: removeMergeMutationParams });
        undos.unshift({ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams });
      }
    }
    const clearMutationParams = {
      subUnitId,
      unitId,
      cellValue: generateNullCellValueRowCol([target])
    };
    const undoClearMutationParams = this._injector.invoke(
      SetRangeValuesUndoMutationFactory,
      clearMutationParams
    );
    redos.push({ id: SetRangeValuesMutation.id, params: clearMutationParams });
    undos.unshift({ id: SetRangeValuesMutation.id, params: undoClearMutationParams });
    const cellValue = new ObjectMatrix();
    targetRows.forEach((row, rowIndex) => {
      targetCols.forEach((col, colIndex) => {
        if (applyDatas[rowIndex][colIndex]) {
          cellValue.setValue(row, col, applyDatas[rowIndex][colIndex]);
        }
      });
    });
    const cellValueMatrix = cellValue.getMatrix();
    const setRangeValuesMutationParams = {
      subUnitId,
      unitId,
      cellValue: cellValueMatrix
    };
    const undoSetRangeValuesMutationParams = this._injector.invoke(
      SetRangeValuesUndoMutationFactory,
      setRangeValuesMutationParams
    );
    this._autoFillService.getActiveHooks().forEach((hook) => {
      var _a2;
      (_a2 = hook.onBeforeSubmit) == null ? void 0 : _a2.call(hook, location, direction, applyType, cellValueMatrix);
    });
    undos.unshift({ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams });
    redos.push({ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams });
    if (applyMergeRanges == null ? void 0 : applyMergeRanges.length) {
      const ranges = getAddMergeMutationRangeByType(applyMergeRanges);
      const addMergeMutationParams = {
        unitId,
        subUnitId,
        ranges
      };
      const undoAddMergeMutationParams = this._injector.invoke(
        AddMergeUndoMutationFactory,
        addMergeMutationParams
      );
      undos.unshift({ id: RemoveWorksheetMergeMutation.id, params: undoAddMergeMutationParams });
      redos.push({ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams });
    }
    return {
      undos,
      redos
    };
  }
  _shouldDisableSeries(copyData) {
    return copyData.every(
      (copyDataPiece) => Object.keys(copyDataPiece).every(
        (type) => {
          var _a;
          return ((_a = copyDataPiece[type]) == null ? void 0 : _a.length) === 0 || ["other" /* OTHER */, "formula" /* FORMULA */].includes(type);
        }
      )
    );
  }
  _getPreferredApplyType(copyData) {
    const preferCopy = copyData.every(
      (copyDataPiece) => Object.keys(copyDataPiece).every(
        (type) => {
          var _a, _b;
          return ((_a = copyDataPiece[type]) == null ? void 0 : _a.length) === 0 || ((_b = copyDataPiece[type]) == null ? void 0 : _b.length) === 1 && copyDataPiece[type][0].data.length === 1 && "number" /* NUMBER */ === type;
        }
      )
    );
    return preferCopy ? "COPY" /* COPY */ : "SERIES" /* SERIES */;
  }
};
AutoFillController = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, ICommandService),
  __decorateParam(2, IAutoFillService),
  __decorateParam(3, IEditorBridgeService),
  __decorateParam(4, IRenderManagerService),
  __decorateParam(5, Inject(Injector)),
  __decorateParam(6, Inject(SheetsRenderService))
], AutoFillController);

// ../packages/sheets-ui/src/controllers/checkbox.controller.ts
var SheetCheckboxController = class extends Disposable {
  constructor(_hoverManagerService, _instanceService, _commandService, _renderManagerService) {
    super();
    this._hoverManagerService = _hoverManagerService;
    this._instanceService = _instanceService;
    this._commandService = _commandService;
    this._renderManagerService = _renderManagerService;
    __publicField(this, "_isPointer", false);
    this._initPointerEvent();
    this._initHover();
  }
  get _mainComponent() {
    var _a;
    return (_a = getCurrentTypeOfRenderer(O.UNIVER_SHEET, this._instanceService, this._renderManagerService)) == null ? void 0 : _a.mainComponent;
  }
  _initHover() {
    this.disposeWithMe(this._hoverManagerService.currentRichText$.subscribe((richText) => {
      var _a, _b;
      if (richText == null ? void 0 : richText.bullet) {
        if (!this._isPointer) {
          (_a = this._mainComponent) == null ? void 0 : _a.setCursor("pointer" /* POINTER */);
        }
        this._isPointer = true;
      } else {
        if (this._isPointer) {
          (_b = this._mainComponent) == null ? void 0 : _b.setCursor("auto" /* AUTO */);
        }
        this._isPointer = false;
      }
    }));
  }
  _initPointerEvent() {
    this.disposeWithMe(this._hoverManagerService.currentClickedCell$.subscribe((cell) => {
      const { location, bullet } = cell;
      if (!bullet) {
        return;
      }
      this._commandService.executeCommand(ToggleCellCheckboxCommand.id, {
        unitId: location.unitId,
        subUnitId: location.subUnitId,
        row: location.row,
        col: location.col,
        paragraphIndex: bullet.startIndex
      });
    }));
  }
};
SheetCheckboxController = __decorateClass([
  __decorateParam(0, Inject(HoverManagerService)),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, ICommandService),
  __decorateParam(3, IRenderManagerService)
], SheetCheckboxController);

// ../packages/sheets-ui/src/controllers/defined-name/defined-name.controller.ts
var SheetsDefinedNameController = class extends Disposable {
  constructor(_selectionManagerService, _themeService, _instanceSrv, _cmdSrv, _definedNamesService) {
    super();
    this._selectionManagerService = _selectionManagerService;
    this._themeService = _themeService;
    this._instanceSrv = _instanceSrv;
    this._cmdSrv = _cmdSrv;
    this._definedNamesService = _definedNamesService;
    this._init();
  }
  _init() {
    this.disposeWithMe(merge(
      this._selectionManagerService.selectionMoveStart$,
      this._selectionManagerService.selectionMoving$,
      this._selectionManagerService.selectionMoveEnd$,
      this._selectionManagerService.selectionSet$
    ).pipe(filter((params) => !!params)).subscribe((params) => {
      this._syncDefinedNameRange(params);
    }));
    this.disposeWithMe(this._definedNamesService.focusRange$.subscribe(async (item) => {
      if (item == null) return;
      const { unitId } = item;
      let { formulaOrRefString } = item;
      if (formulaOrRefString.substring(0, 1) === "=" /* EQUALS */) {
        formulaOrRefString = formulaOrRefString.substring(1);
      }
      const result = isReferenceStrings(formulaOrRefString);
      if (!result) {
        return;
      }
      const workbook = this._instanceSrv.getUnit(unitId);
      const selections = await this._getSelections(workbook, unitId, formulaOrRefString);
      this._selectionManagerService.setSelections(selections);
      this._cmdSrv.executeCommand(ScrollToCellOperation.id, {
        unitId,
        range: selections[0].range
      });
    }));
  }
  _syncDefinedNameRange(params) {
    if (params.length === 0) {
      return;
    }
    const lastSelection = params[params.length - 1];
    const workbook = this._instanceSrv.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
    if (!worksheet) {
      return;
    }
    this._definedNamesService.setCurrentRange({
      range: lastSelection.range,
      unitId: workbook.getUnitId(),
      sheetId: worksheet.getSheetId()
    });
  }
  async _getSelections(workbook, unitId, formulaOrRefString) {
    const valueArray = formulaOrRefString.split(",");
    let worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      return [];
    }
    const selections = [];
    for (let i = 0; i < valueArray.length; i++) {
      const refString = valueArray[i].trim();
      const unitRange = deserializeRangeWithSheet(refString.trim());
      if (i === 0) {
        const worksheetCache = workbook.getSheetBySheetName(unitRange.sheetName);
        if (worksheetCache && worksheet.getSheetId() !== worksheetCache.getSheetId()) {
          worksheet = worksheetCache;
          await this._cmdSrv.executeCommand(SetWorksheetActivateCommand.id, {
            subUnitId: worksheet.getSheetId(),
            unitId
          });
        }
      }
      if (worksheet.getName() !== unitRange.sheetName) {
        continue;
      }
      let primary = null;
      if (i === valueArray.length - 1) {
        const range = unitRange.range;
        const { startRow, startColumn, endRow, endColumn } = range;
        primary = getPrimaryForRange({
          startRow,
          startColumn,
          endRow,
          endColumn
        }, worksheet);
      }
      selections.push({
        range: unitRange.range,
        style: genNormalSelectionStyle(this._themeService),
        primary
      });
    }
    return selections;
  }
};
SheetsDefinedNameController = __decorateClass([
  __decorateParam(0, Inject(SheetsSelectionsService)),
  __decorateParam(1, Inject(ThemeService)),
  __decorateParam(2, IUniverInstanceService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, IDefinedNamesService)
], SheetsDefinedNameController);

// ../packages/sheets-ui/src/controllers/editor/formula-editor.controller.ts
var FormulaEditorController = class extends RxDisposable {
  constructor(_univerInstanceService, _renderManagerService, _editorBridgeService, _commandService, _contextService, _formulaEditorManagerService, _undoRedoService, _textSelectionManagerService, _editorService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    this._editorBridgeService = _editorBridgeService;
    this._commandService = _commandService;
    this._contextService = _contextService;
    this._formulaEditorManagerService = _formulaEditorManagerService;
    this._undoRedoService = _undoRedoService;
    this._textSelectionManagerService = _textSelectionManagerService;
    this._editorService = _editorService;
    __publicField(this, "_loadedMap", /* @__PURE__ */ new WeakSet());
    __publicField(this, "_scheduledCallback", -1);
    this._initialize();
  }
  _initialize() {
    this._syncEditorSize();
    this._listenFxBtnClick();
    this._handleContentChange();
    this._univerInstanceService.focused$.pipe(takeUntil(this.dispose$)).subscribe((unitId) => {
      this._create(unitId);
    });
    this._create(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY);
    this.disposeWithMe(this._editorService.focus$.subscribe(() => {
      var _a;
      const focusUnitId = (_a = this._editorService.getFocusEditor()) == null ? void 0 : _a.getEditorId();
      if (focusUnitId !== DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) {
        this._contextService.setContextValue(FOCUSING_FX_BAR_EDITOR, false);
      } else {
        this._contextService.setContextValue(FOCUSING_FX_BAR_EDITOR, true);
      }
    }));
  }
  _handleContentChange() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((commandInfo) => {
        if (commandInfo.id === RichTextEditingMutation.id) {
          const params = commandInfo.params;
          const { unitId } = params;
          if (unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) {
            this.autoScroll();
          }
        }
      })
    );
  }
  _create(unitId) {
    if (unitId !== DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) {
      return;
    }
    const formulaEditorDocObject = this._renderManagerService.getRenderById(unitId);
    if (formulaEditorDocObject == null) {
      return;
    }
    const { mainComponent: documentComponent } = formulaEditorDocObject;
    if (documentComponent == null) {
      return;
    }
    if (!this._loadedMap.has(documentComponent)) {
      this._loadedMap.add(documentComponent);
    }
  }
  _listenFxBtnClick() {
    this._formulaEditorManagerService.fxBtnClick$.pipe(takeUntil(this.dispose$)).subscribe(() => {
      var _a, _b;
      const isFocusButHidden = this._contextService.getContextValue(FOCUSING_EDITOR_BUT_HIDDEN) && !this._contextService.getContextValue(EDITOR_ACTIVATED);
      if (isFocusButHidden) {
        this._univerInstanceService.setCurrentUnitForType(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY);
        this._contextService.setContextValue(FOCUSING_FX_BAR_EDITOR, true);
        const currentSheet = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
        const formulaEditorDataModel = this._univerInstanceService.getUniverDocInstance(
          DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY
        );
        const visibleState = this._editorBridgeService.isVisible();
        if (visibleState.visible === false) {
          this._commandService.syncExecuteCommand(
            SetCellEditVisibleOperation.id,
            {
              visible: true,
              eventType: 1 /* PointerDown */,
              unitId: (_a = currentSheet == null ? void 0 : currentSheet.getUnitId()) != null ? _a : ""
            }
          );
        }
        const content = (_b = formulaEditorDataModel == null ? void 0 : formulaEditorDataModel.getBody()) == null ? void 0 : _b.dataStream;
        if (content == null) {
          return;
        }
        let newContent = content.startsWith("=") ? content : `=${content}`;
        newContent = newContent.replace(/\r\n$/, "");
        const textRanges = [
          {
            startOffset: newContent.length,
            endOffset: newContent.length
          }
        ];
        const coverContentParams = {
          unitId: DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY,
          body: {
            dataStream: newContent
          },
          segmentId: ""
        };
        this._commandService.executeCommand(CoverContentCommand.id, coverContentParams);
        this._textSelectionManagerService.replaceDocRanges(textRanges);
      }
    });
  }
  _syncEditorSize() {
    const addFOrmulaBar$ = this._univerInstanceService.unitAdded$.pipe(filter((unit) => unit.getUnitId() === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY));
    this.disposeWithMe(combineLatest([this._formulaEditorManagerService.position$, addFOrmulaBar$]).subscribe(([position]) => {
      if (!position) return this._clearScheduledCallback();
      const editorObject = getEditorObject(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY, this._renderManagerService);
      const formulaEditorDataModel = this._univerInstanceService.getUniverDocInstance(
        DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY
      );
      if (editorObject == null || formulaEditorDataModel == null) return this._clearScheduledCallback();
      const { width, height } = position;
      if (width === 0 || height === 0) return this._clearScheduledCallback();
      const { engine } = editorObject;
      formulaEditorDataModel.updateDocumentDataPageSize(width);
      this.autoScroll();
      this._scheduledCallback = requestIdleCallback(() => engine.resizeBySize(width, height));
    }));
  }
  _clearScheduledCallback() {
    if (this._scheduledCallback !== -1) cancelIdleCallback(this._scheduledCallback);
    this._scheduledCallback = -1;
  }
  autoScroll() {
    var _a, _b;
    const position = this._formulaEditorManagerService.getPosition();
    const skeleton = (_a = this._renderManagerService.getRenderById(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY)) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
    const editorObject = this._renderManagerService.getRenderById(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY);
    const formulaEditorDataModel = this._univerInstanceService.getUniverDocInstance(
      DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY
    );
    if (skeleton == null || position == null || editorObject == null || formulaEditorDataModel == null) {
      return;
    }
    const { marginTop = 0, marginBottom = 0 } = formulaEditorDataModel.getSnapshot().documentStyle;
    const { scene, mainComponent } = editorObject;
    let { actualHeight } = skeleton.getActualSize();
    actualHeight += marginTop + marginBottom;
    const { width, height } = position;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    let scrollBar = viewportMain == null ? void 0 : viewportMain.getScrollBar();
    scene.transformByState({
      width,
      height: actualHeight
    });
    mainComponent == null ? void 0 : mainComponent.resize(width, actualHeight);
    if (actualHeight > height) {
      if (scrollBar == null) {
        viewportMain && new ScrollBar(viewportMain, { enableHorizontal: false, barSize: 8 });
      } else {
        viewportMain == null ? void 0 : viewportMain.resetCanvasSizeAndUpdateScroll();
      }
    } else {
      scrollBar = null;
      viewportMain == null ? void 0 : viewportMain.scrollToViewportPos({ viewportScrollX: 0, viewportScrollY: 0 });
      (_b = viewportMain == null ? void 0 : viewportMain.getScrollBar()) == null ? void 0 : _b.dispose();
    }
  }
};
FormulaEditorController = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, IEditorBridgeService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, IContextService),
  __decorateParam(5, IFormulaEditorManagerService),
  __decorateParam(6, IUndoRedoService),
  __decorateParam(7, Inject(DocSelectionManagerService)),
  __decorateParam(8, IEditorService)
], FormulaEditorController);

// ../packages/sheets-ui/src/controllers/editor/data-sync.controller.ts
var formulaEditorStyle = {
  pageSize: {
    width: Number.POSITIVE_INFINITY,
    height: Number.POSITIVE_INFINITY
  },
  documentFlavor: 0 /* UNSPECIFIED */,
  marginTop: 5,
  marginBottom: 5,
  marginRight: 0,
  marginLeft: 0,
  paragraphLineGapDefault: 0,
  renderConfig: {
    horizontalAlign: 0 /* UNSPECIFIED */,
    verticalAlign: 1 /* TOP */,
    centerAngle: 0,
    vertexAngle: 0,
    wrapStrategy: 3 /* WRAP */,
    isRenderStyle: 0 /* FALSE */
  }
};
var EditorDataSyncController = class extends Disposable {
  constructor(_univerInstanceService, _renderManagerService, _editorBridgeService, _commandService, _rangeProtectionRuleModel, _worksheetProtectionRuleModel, _formulaEditorController, _formulaEditorManagerService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    this._editorBridgeService = _editorBridgeService;
    this._commandService = _commandService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._worksheetProtectionRuleModel = _worksheetProtectionRuleModel;
    this._formulaEditorController = _formulaEditorController;
    this._formulaEditorManagerService = _formulaEditorManagerService;
    this._initialize();
  }
  _initialize() {
    this._syncFormulaEditorContent();
    this._commandExecutedListener();
  }
  _getEditorViewModel(unitId) {
    var _a;
    return (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService).getViewModel();
  }
  // Sync cell content to formula editor bar when sheet selection changed.
  _syncFormulaEditorContent() {
    this.disposeWithMe(this._editorBridgeService.currentEditCellState$.subscribe((editCellState) => {
      if (editCellState == null || this._editorBridgeService.isForceKeepVisible() || !this._rangeProtectionRuleModel.getRangeRuleInitState() || !this._worksheetProtectionRuleModel.getSheetRuleInitState()) {
        return;
      }
      this._editorSyncHandler(editCellState);
    }));
  }
  // Sync cell content to formula editor bar when sheet selection changed or visible changed.
  _editorSyncHandler(param) {
    var _a, _b, _c;
    let body = Tools.deepClone((_a = param.documentLayoutObject.documentModel) == null ? void 0 : _a.getBody());
    const drawings = Tools.deepClone((_b = param.documentLayoutObject.documentModel) == null ? void 0 : _b.drawings);
    const drawingsOrder = Tools.deepClone((_c = param.documentLayoutObject.documentModel) == null ? void 0 : _c.getDrawingsOrder());
    if (!body || param.isInArrayFormulaRange === true && this._editorBridgeService.isVisible().eventType === 3 /* Dblclick */) {
      body = {
        dataStream: "\r\n",
        paragraphs: [
          {
            startIndex: 0
          }
        ],
        textRuns: []
      };
    }
    this._syncContentAndRender(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY, body, drawings, drawingsOrder);
  }
  _commandExecutedListener() {
    const INCLUDE_LIST = [DOCS_NORMAL_EDITOR_UNIT_ID_KEY, DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === RichTextEditingMutation.id) {
          const params = command.params;
          const { unitId, trigger, isSync } = params;
          if (isSync || trigger === ReplaceSnapshotCommand.id) {
            return;
          }
          if (INCLUDE_LIST.includes(unitId)) {
            const editorDocDataModel = this._univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
            const syncId = unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY ? DOCS_NORMAL_EDITOR_UNIT_ID_KEY : DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY;
            this._checkAndSetRenderStyleConfig(editorDocDataModel);
            this._syncActionsAndRender(syncId, params);
          }
        }
      })
    );
    const needUpdateFormulaEditorContentCommandList = [SetRangeValuesMutation.id, MoveRangeMutation.id];
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        var _a, _b, _c, _d, _e, _f, _g;
        if (needUpdateFormulaEditorContentCommandList.includes(command.id)) {
          const editCellState = this._editorBridgeService.getLatestEditCellState();
          if (editCellState == null) {
            return;
          }
          let needUpdate = false;
          const { row, column } = editCellState;
          if (command.id === SetRangeValuesMutation.id && command.params) {
            const params = command.params;
            if ((_b = (_a = params.cellValue) == null ? void 0 : _a[row]) == null ? void 0 : _b[column]) {
              needUpdate = true;
            }
          } else if (command.id === MoveRangeMutation.id && command.params) {
            const params = command.params;
            if ((_d = (_c = params.to.value) == null ? void 0 : _c[row]) == null ? void 0 : _d[column]) {
              needUpdate = true;
            }
          }
          if (needUpdate) {
            const body = Tools.deepClone((_e = editCellState.documentLayoutObject.documentModel) == null ? void 0 : _e.getBody());
            const drawings = Tools.deepClone((_f = editCellState.documentLayoutObject.documentModel) == null ? void 0 : _f.drawings);
            const drawingsOrder = Tools.deepClone((_g = editCellState.documentLayoutObject.documentModel) == null ? void 0 : _g.getDrawingsOrder());
            if (body == null) {
              return;
            }
            this._syncContentAndRender(DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY, body, drawings, drawingsOrder);
          }
        }
      })
    );
  }
  // Sync actions between cell editor and formula editor, and make `dataStream` and `paragraph` is the same.
  _syncActionsAndRender(unitId, parmas) {
    var _a;
    const INCLUDE_LIST = [DOCS_NORMAL_EDITOR_UNIT_ID_KEY, DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY];
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (currentRender == null) {
      return;
    }
    const skeleton = currentRender.with(DocSkeletonManagerService).getSkeleton();
    const docDataModel = this._univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    const docViewModel = this._getEditorViewModel(unitId);
    if (docDataModel == null || docViewModel == null) {
      return;
    }
    this._commandService.syncExecuteCommand(RichTextEditingMutation.id, {
      ...parmas,
      textRanges: null,
      isSync: true,
      unitId,
      syncer: parmas.unitId
    });
    docViewModel.reset(docDataModel);
    skeleton.calculate();
    if (INCLUDE_LIST.includes(unitId)) {
      (_a = currentRender.mainComponent) == null ? void 0 : _a.makeDirty();
    }
  }
  _syncContentAndRender(unitId, body, drawings, drawingsOrder) {
    var _a, _b;
    if (unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) {
      if (body.paragraphs) {
        body.paragraphs = this._clearParagraph(body.paragraphs);
      }
    }
    const INCLUDE_LIST = [DOCS_NORMAL_EDITOR_UNIT_ID_KEY, DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY];
    const skeleton = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.with(DocSkeletonManagerService).getSkeleton();
    const docDataModel = this._univerInstanceService.getUnit(unitId, O.UNIVER_DOC);
    const docViewModel = this._getEditorViewModel(unitId);
    if (docDataModel == null || docViewModel == null || skeleton == null) {
      return;
    }
    docDataModel.getSnapshot().body = body;
    docDataModel.getSnapshot().drawings = drawings != null ? drawings : {};
    docDataModel.getSnapshot().drawingsOrder = drawingsOrder != null ? drawingsOrder : [];
    this._checkAndSetRenderStyleConfig(docDataModel);
    docViewModel.reset(docDataModel);
    const currentRender = this._renderManagerService.getRenderById(unitId);
    if (currentRender == null) {
      return;
    }
    skeleton.calculate();
    if (INCLUDE_LIST.includes(unitId)) {
      (_b = currentRender.mainComponent) == null ? void 0 : _b.makeDirty();
    }
    if (unitId === DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) {
      this._formulaEditorController.autoScroll();
    }
  }
  _checkAndSetRenderStyleConfig(documentDataModel) {
    var _a;
    const snapshot = documentDataModel.getSnapshot();
    const { body } = snapshot;
    if (snapshot.id !== DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY) {
      return;
    }
    snapshot.documentStyle = formulaEditorStyle;
    let renderConfig = snapshot.documentStyle.renderConfig;
    if (renderConfig == null) {
      renderConfig = {};
      snapshot.documentStyle.renderConfig = renderConfig;
    }
    const position = this._formulaEditorManagerService.getPosition();
    if (position) {
      const width = position.width;
      snapshot.documentStyle.pageSize = {
        width,
        height: Infinity
      };
    }
    if (((_a = body == null ? void 0 : body.dataStream) != null ? _a : "").startsWith("=")) {
      renderConfig.isRenderStyle = 1 /* TRUE */;
    } else {
      renderConfig.isRenderStyle = 0 /* FALSE */;
    }
  }
  _clearParagraph(paragraphs) {
    const newParagraphs = Tools.deepClone(paragraphs);
    for (const paragraph of newParagraphs) {
      if (paragraph.paragraphStyle) {
        paragraph.paragraphStyle.horizontalAlign = 0 /* UNSPECIFIED */;
      }
    }
    return newParagraphs;
  }
};
EditorDataSyncController = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IRenderManagerService),
  __decorateParam(2, IEditorBridgeService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, Inject(RangeProtectionRuleModel)),
  __decorateParam(5, Inject(WorksheetProtectionRuleModel)),
  __decorateParam(6, Inject(FormulaEditorController)),
  __decorateParam(7, IFormulaEditorManagerService)
], EditorDataSyncController);

// ../packages/sheets-ui/src/controllers/format-painter/format-painter.controller.ts
var FormatPainterController = class extends Disposable {
  constructor(_commandService, _formatPainterService, _univerInstanceService, _renderManagerService, _selectionManagerService, _sheetInterceptorService, _injector) {
    super();
    this._commandService = _commandService;
    this._formatPainterService = _formatPainterService;
    this._univerInstanceService = _univerInstanceService;
    this._renderManagerService = _renderManagerService;
    this._selectionManagerService = _selectionManagerService;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._injector = _injector;
    this._initialize();
  }
  _initialize() {
    this._addDefaultHook();
  }
  _addDefaultHook() {
    const defaultHook = {
      id: "default-format-painter",
      priority: 0,
      isDefaultHook: true,
      onStatusChange: (status) => {
        if (status !== 0 /* OFF */) {
          const format = this._collectSelectionRangeFormat();
          if (format) {
            this._formatPainterService.setSelectionFormat(format);
          }
        }
      },
      onApply: (unitId, subUnitId, range, format) => {
        return this._getUndoRedoMutationInfo(unitId, subUnitId, range, format);
      }
    };
    this._formatPainterService.addHook(defaultHook);
  }
  _collectSelectionRangeFormat() {
    const selection = this._selectionManagerService.getCurrentLastSelection();
    const range = selection == null ? void 0 : selection.range;
    if (!range) return null;
    const { startRow, endRow, startColumn, endColumn } = range;
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
    if (!worksheet) return null;
    const cellData = worksheet.getCellMatrix();
    const styles = workbook.getStyles();
    const stylesMatrix = new ObjectMatrix();
    const merges = [];
    for (let r = startRow; r <= endRow; r++) {
      for (let c = startColumn; c <= endColumn; c++) {
        const cell = cellData.getValue(r, c);
        stylesMatrix.setValue(r, c, styles.getStyleByCell(cell) || {});
        const { isMergedMainCell, ...mergeInfo } = worksheet.getCellInfoInMergeData(r, c);
        if (isMergedMainCell) {
          merges.push({
            startRow: mergeInfo.startRow,
            startColumn: mergeInfo.startColumn,
            endRow: mergeInfo.endRow,
            endColumn: mergeInfo.endColumn
          });
        }
      }
    }
    return {
      styles: stylesMatrix,
      merges
    };
  }
  _getUndoRedoMutationInfo(unitId, subUnitId, originRange, format) {
    const sheetInterceptorService = this._sheetInterceptorService;
    const univerInstanceService = this._univerInstanceService;
    const { merges, styles: stylesMatrix } = format;
    if (!stylesMatrix) return { undos: [], redos: [] };
    const { startRow, startColumn, endRow, endColumn } = stylesMatrix.getDataRange();
    const styleRowsNum = endRow - startRow + 1;
    const styleColsNum = endColumn - startColumn + 1;
    const range = originRange.startRow === originRange.endRow && originRange.startColumn === originRange.endColumn ? {
      startRow: originRange.startRow,
      startColumn: originRange.startColumn,
      endRow: originRange.startRow + styleRowsNum - 1,
      endColumn: originRange.startColumn + styleColsNum - 1
    } : originRange;
    const styleValues = Array.from({ length: range.endRow - range.startRow + 1 }, () => Array.from({ length: range.endColumn - range.startColumn + 1 }, () => ({})));
    const mergeRanges = [];
    styleValues.forEach((row, rowIndex) => {
      row.forEach((col, colIndex) => {
        const mappedRowIndex = rowIndex % styleRowsNum + startRow;
        const mappedColIndex = colIndex % styleColsNum + startColumn;
        const style = stylesMatrix.getValue(mappedRowIndex, mappedColIndex);
        if (style) {
          styleValues[rowIndex][colIndex].s = Object.keys(style).length > 0 ? style : null;
        }
      });
    });
    merges.forEach((merge2) => {
      const relatedRange = {
        startRow: merge2.startRow - startRow,
        startColumn: merge2.startColumn - startColumn,
        endRow: merge2.endRow - startRow,
        endColumn: merge2.endColumn - startColumn
      };
      const rowRepeats = Math.max(1, Math.floor((range.endRow - range.startRow + 1) / styleRowsNum));
      const colRepeats = Math.max(1, Math.floor((range.endColumn - range.startColumn + 1) / styleColsNum));
      for (let i = 0; i < rowRepeats; i++) {
        for (let j = 0; j < colRepeats; j++) {
          mergeRanges.push({
            startRow: relatedRange.startRow + i * styleRowsNum + range.startRow,
            startColumn: relatedRange.startColumn + j * styleColsNum + range.startColumn,
            endRow: relatedRange.endRow + i * styleRowsNum + range.startRow,
            endColumn: relatedRange.endColumn + j * styleColsNum + range.startColumn
          });
        }
      }
    });
    const currentSelections = [range];
    const clearCellValue = new ObjectMatrix();
    const cellValue = new ObjectMatrix();
    if (Tools.isArray(styleValues)) {
      for (let i = 0; i < currentSelections.length; i++) {
        const { startRow: startRow2, startColumn: startColumn2, endRow: endRow2, endColumn: endColumn2 } = currentSelections[i];
        for (let r = 0; r <= endRow2 - startRow2; r++) {
          for (let c = 0; c <= endColumn2 - startColumn2; c++) {
            clearCellValue.setValue(r + startRow2, c + startColumn2, { s: null });
            cellValue.setValue(r + startRow2, c + startColumn2, styleValues[r][c]);
          }
        }
      }
    }
    const clearStyleMutationParams = {
      subUnitId,
      unitId,
      cellValue: clearCellValue.getMatrix()
    };
    const setRangeValuesMutationParams = {
      subUnitId,
      unitId,
      cellValue: cellValue.getMatrix()
    };
    const undoSetRangeValuesMutationParams = this._injector.invoke(
      SetRangeValuesUndoMutationFactory,
      clearStyleMutationParams
    );
    const { undos: interceptorUndos, redos: interceptorRedos } = sheetInterceptorService.onCommandExecute({
      id: SetRangeValuesCommand.id,
      params: { ...setRangeValuesMutationParams, range: currentSelections }
    });
    const ranges = getAddMergeMutationRangeByType(mergeRanges);
    const mergeRedos = [];
    const mergeUndos = [];
    const worksheet = univerInstanceService.getUnit(unitId).getSheetBySheetId(subUnitId);
    const willRemoveSomeCell = checkCellContentInRanges(worksheet, ranges);
    const removeMergeMutationParams = {
      unitId,
      subUnitId,
      ranges
    };
    const addMergeMutationParams = {
      unitId,
      subUnitId,
      ranges
    };
    mergeRedos.push({ id: RemoveWorksheetMergeMutation.id, params: removeMergeMutationParams });
    mergeRedos.push({ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams });
    const undoRemoveMergeMutationParams = this._injector.invoke(
      RemoveMergeUndoMutationFactory,
      removeMergeMutationParams
    );
    const undoMutationParams = this._injector.invoke(
      AddMergeUndoMutationFactory,
      addMergeMutationParams
    );
    mergeUndos.push({ id: RemoveWorksheetMergeMutation.id, params: undoMutationParams });
    mergeUndos.push({ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams });
    if (willRemoveSomeCell) {
      const data = this._injector.invoke((accessor) => getClearContentMutationParamsForRanges(accessor, unitId, worksheet, ranges));
      mergeRedos.unshift(...data.redos);
      mergeUndos.push(...data.undos);
    }
    return {
      undos: [
        { id: SetRangeValuesMutation.id, params: clearStyleMutationParams },
        { id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams },
        ...interceptorUndos,
        ...mergeUndos
      ],
      redos: [
        { id: SetRangeValuesMutation.id, params: clearStyleMutationParams },
        { id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams },
        ...interceptorRedos,
        ...mergeRedos
      ]
    };
  }
};
FormatPainterController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IFormatPainterService),
  __decorateParam(2, IUniverInstanceService),
  __decorateParam(3, IRenderManagerService),
  __decorateParam(4, Inject(SheetsSelectionsService)),
  __decorateParam(5, Inject(SheetInterceptorService)),
  __decorateParam(6, Inject(Injector))
], FormatPainterController);

// ../packages/sheets-ui/src/controllers/move-range.controller.ts
var MoveRangeRenderController = class extends Disposable {
  constructor(_context, _selectionRenderService, _selectionManagerService, _commandService) {
    super();
    this._context = _context;
    this._selectionRenderService = _selectionRenderService;
    this._selectionManagerService = _selectionManagerService;
    this._commandService = _commandService;
    __publicField(this, "_initialize", () => {
      const disposableCollection = new DisposableCollection();
      this.disposeWithMe(
        this._selectionManagerService.selectionMoveEnd$.subscribe(() => {
          disposableCollection.dispose();
          const selectionControls = this._selectionRenderService.getSelectionControls();
          selectionControls.forEach((controlSelection) => {
            disposableCollection.add(
              toDisposable(
                controlSelection.selectionMoveEnd$.subscribe((_toRange) => {
                  if (!_toRange) {
                    return;
                  }
                  const _fromRange = controlSelection.model.getRange();
                  const fromRange = {
                    startRow: _fromRange.startRow,
                    startColumn: _fromRange.startColumn,
                    endRow: _fromRange.endRow,
                    endColumn: _fromRange.endColumn,
                    rangeType: _fromRange.rangeType
                  };
                  const toRange = {
                    startRow: _toRange.startRow,
                    startColumn: _toRange.startColumn,
                    endRow: _toRange.endRow,
                    endColumn: _toRange.endColumn,
                    // rangeType must equal to fromRange
                    rangeType: _fromRange.rangeType
                  };
                  if (fromRange.startRow === toRange.startRow && fromRange.startColumn === toRange.startColumn) {
                    return;
                  }
                  if (toRange.startRow < 0 || toRange.startColumn < 0) {
                    return;
                  }
                  const params = {
                    fromRange,
                    toRange
                  };
                  this._commandService.executeCommand(MoveRangeCommand.id, params);
                })
              )
            );
          });
        })
      );
    });
    this._initialize();
  }
};
MoveRangeRenderController = __decorateClass([
  __decorateParam(1, Inject(ISheetSelectionRenderService)),
  __decorateParam(2, Inject(SheetsSelectionsService)),
  __decorateParam(3, Inject(ICommandService))
], MoveRangeRenderController);

// ../packages/sheets-ui/src/controllers/permission/sheet-permission-init-ui.controller.ts
var SheetPermissionInitUIController = class extends Disposable {
  constructor(_sheetPermissionInitController) {
    super();
    this._sheetPermissionInitController = _sheetPermissionInitController;
    this._initPermission();
  }
  _initPermission() {
    this._sheetPermissionInitController.initPermission();
  }
};
SheetPermissionInitUIController = __decorateClass([
  __decorateParam(0, Inject(SheetPermissionInitController))
], SheetPermissionInitUIController);

// ../packages/sheets-ui/src/controllers/render-controllers/clipboard.render-controller.ts
var ClipboardRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _sheetClipboardService, _sheetClipboardController) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._sheetClipboardService = _sheetClipboardService;
    this._sheetClipboardController = _sheetClipboardController;
    this._initialize();
  }
  _initialize() {
    this.disposeWithMe(
      toDisposable(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((skeleton) => {
        if (!(skeleton == null ? void 0 : skeleton.unitId)) {
          return;
        }
        if (!this._sheetClipboardService.getPasteMenuVisible()) {
          return;
        }
        const pasteOptionsCache = this._sheetClipboardService.getPasteOptionsCache();
        const menuUnitId = pasteOptionsCache == null ? void 0 : pasteOptionsCache.target.unitId;
        if (skeleton.unitId === menuUnitId) {
          this._sheetClipboardController.refreshOptionalPaste();
        }
      }))
    );
  }
};
ClipboardRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, ISheetClipboardService),
  __decorateParam(3, Inject(SheetClipboardController))
], ClipboardRenderController);

// ../packages/sheets-ui/src/controllers/render-controllers/contextmenu.render-controller.ts
var SheetContextMenuRenderController = class extends Disposable {
  constructor(_context, _contextMenuService, _selectionManagerService, _selectionRenderService) {
    super();
    this._context = _context;
    this._contextMenuService = _contextMenuService;
    this._selectionManagerService = _selectionManagerService;
    this._selectionRenderService = _selectionRenderService;
    this._init();
  }
  _init() {
    var _a, _b;
    const spreadsheetPointerDownObserver = (_b = (_a = this._context) == null ? void 0 : _a.mainComponent) == null ? void 0 : _b.onPointerDown$;
    const spreadsheetSubscription = spreadsheetPointerDownObserver.subscribeEvent((event) => {
      if (event.button === 2) {
        const selections = this._selectionManagerService.getCurrentSelections();
        const currentSelection = selections == null ? void 0 : selections[0];
        if (!currentSelection) {
          return;
        }
        const rangeType = currentSelection.range.rangeType;
        const skeleton = this._selectionRenderService.getSkeleton();
        const selectionRangeWithCoord = attachSelectionWithCoord(currentSelection, skeleton);
        const range = selectionRangeWithCoord.rangeWithCoord;
        const isPointerInRange = () => {
          if (!range) {
            return false;
          }
          const x = event.offsetX;
          const y = event.offsetY;
          switch (rangeType) {
            case 1 /* ROW */:
              return range.startY <= y && range.endY >= y;
            case 2 /* COLUMN */:
              return range.startX <= x && range.endX >= x;
            default:
              return range.startX <= x && range.endX >= x && range.startY <= y && range.endY >= y;
          }
        };
        const triggerMenu = (position) => {
          this._contextMenuService.triggerContextMenu(event, position);
        };
        if (!isPointerInRange()) {
          triggerMenu("contextMenu.mainArea" /* MAIN_AREA */);
        } else if (rangeType === 2 /* COLUMN */) {
          triggerMenu("contextMenu.colHeader" /* COL_HEADER */);
        } else if (rangeType === 1 /* ROW */) {
          triggerMenu("contextMenu.rowHeader" /* ROW_HEADER */);
        } else {
          triggerMenu("contextMenu.mainArea" /* MAIN_AREA */);
        }
      }
    });
    this.disposeWithMe(spreadsheetSubscription);
    const spreadsheetColumnHeader = this._context.components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
    const spreadsheetRowHeader = this._context.components.get("__SpreadsheetRowHeader__" /* ROW */);
    const rowHeaderSub = spreadsheetRowHeader.onPointerDown$.subscribeEvent((event) => {
      if (event.button === 2) {
        this._contextMenuService.triggerContextMenu(event, "contextMenu.rowHeader" /* ROW_HEADER */);
      }
    });
    this.disposeWithMe(rowHeaderSub);
    const colHeaderPointerDownObserver = spreadsheetColumnHeader.onPointerDown$;
    const colHeaderObserver = colHeaderPointerDownObserver.subscribeEvent((event) => {
      if (event.button === 2) {
        this._contextMenuService.triggerContextMenu(event, "contextMenu.colHeader" /* COL_HEADER */);
      }
    });
    this.disposeWithMe(colHeaderObserver);
  }
};
SheetContextMenuRenderController = __decorateClass([
  __decorateParam(1, IContextMenuService),
  __decorateParam(2, Inject(SheetsSelectionsService)),
  __decorateParam(3, ISheetSelectionRenderService)
], SheetContextMenuRenderController);

// ../packages/sheets-ui/src/controllers/render-controllers/editor-bridge.render-controller.ts
var EditorBridgeRenderController = class extends RxDisposable {
  constructor(_context, _instanceSrv, _commandService, _editorBridgeService, _selectionManagerService, _rangeSelectorService, _contextService, _renderManagerService, _editorService, _sheetSkeletonManagerService) {
    super();
    this._context = _context;
    this._instanceSrv = _instanceSrv;
    this._commandService = _commandService;
    this._editorBridgeService = _editorBridgeService;
    this._selectionManagerService = _selectionManagerService;
    this._rangeSelectorService = _rangeSelectorService;
    this._contextService = _contextService;
    this._renderManagerService = _renderManagerService;
    this._editorService = _editorService;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    __publicField(this, "_d");
    this.disposeWithMe(this._instanceSrv.getCurrentTypeOfUnit$(O.UNIVER_SHEET).subscribe((workbook) => {
      if (workbook && workbook.getUnitId() === this._context.unitId) {
        this._d = this._init();
      } else {
        this._disposeCurrent();
      }
    }));
    this._initialRangeSelector();
  }
  _init() {
    const d = new DisposableCollection();
    this._initSelectionChangeListener(d);
    this._initEventListener(d);
    this._commandExecutedListener(d);
    this._initialKeyboardListener(d);
    return d;
  }
  _disposeCurrent() {
    var _a;
    (_a = this._d) == null ? void 0 : _a.dispose();
    this._d = null;
  }
  _initSelectionChangeListener(d) {
    d.add(merge(
      this._selectionManagerService.selectionMoveEnd$,
      this._selectionManagerService.selectionSet$,
      this._selectionManagerService.selectionMoveStart$
    ).subscribe((params) => this._updateEditorPosition(params)));
  }
  _updateEditorPosition(params) {
    var _a, _b, _c;
    if (this._editorBridgeService.isVisible().visible) return;
    if (this._rangeSelectorService.selectorModalVisible) return;
    const primary = (_a = params == null ? void 0 : params[params.length - 1]) == null ? void 0 : _a.primary;
    if (primary) {
      const sheetObject = this._getSheetObject();
      const { scene, engine } = sheetObject;
      const unitId = this._context.unitId;
      const sheetId = (_b = this._context.unit.getActiveSheet()) == null ? void 0 : _b.getSheetId();
      if (!sheetId) return;
      const mergeInfo = (_c = this._sheetSkeletonManagerService.getSkeletonParam(sheetId)) == null ? void 0 : _c.skeleton.getCellWithCoordByIndex(primary.actualRow, primary.actualColumn);
      const newPrimary = mergeInfo ? {
        actualRow: mergeInfo.actualRow,
        actualColumn: mergeInfo.actualColumn,
        isMerged: mergeInfo.isMerged,
        startRow: mergeInfo.mergeInfo.startRow,
        startColumn: mergeInfo.mergeInfo.startColumn,
        endRow: mergeInfo.mergeInfo.endRow,
        endColumn: mergeInfo.mergeInfo.endColumn,
        isMergedMainCell: mergeInfo.isMergedMainCell
      } : primary;
      this._commandService.executeCommand(SetActivateCellEditOperation.id, {
        scene,
        engine,
        primary: newPrimary,
        unitId,
        sheetId
      });
    }
  }
  _initEventListener(d) {
    const sheetObject = this._getSheetObject();
    const { spreadsheet, spreadsheetColumnHeader, spreadsheetLeftTopPlaceholder, spreadsheetRowHeader } = sheetObject;
    d.add(spreadsheet.onDblclick$.subscribeEvent((evt) => {
      if (evt.button === 2) {
        return;
      }
      this._commandService.executeCommand(SetCellEditVisibleOperation.id, {
        visible: true,
        eventType: 3 /* Dblclick */,
        unitId: this._context.unitId
      });
    }));
    d.add(spreadsheet.onPointerDown$.subscribeEvent({
      next: this._tryHideEditor.bind(this),
      priority: -1
    }));
    d.add(spreadsheetColumnHeader.onPointerDown$.subscribeEvent({
      next: this._tryHideEditor.bind(this),
      priority: -1
    }));
    d.add(spreadsheetLeftTopPlaceholder.onPointerDown$.subscribeEvent({
      next: this._tryHideEditor.bind(this),
      priority: -1
    }));
    d.add(spreadsheetRowHeader.onPointerDown$.subscribeEvent({
      next: this._tryHideEditor.bind(this),
      priority: -1
    }));
  }
  /**
   * Should activate the editor when the user inputs text.
   * @param d DisposableCollection
   */
  _initialKeyboardListener(d) {
    let disposable = null;
    const addEvent = (render2) => {
      const docSelectionRenderService = render2.with(DocSelectionRenderService);
      if (docSelectionRenderService) {
        disposable = toDisposable(docSelectionRenderService.onInputBefore$.subscribe((config) => {
          if (!this._isCurrentSheetFocused()) {
            return;
          }
          const isFocusFormulaEditor = this._contextService.getContextValue(FOCUSING_FX_BAR_EDITOR);
          const isFocusSheets = this._contextService.getContextValue(FOCUSING_SHEET);
          const unitId = render2.unitId;
          if (this._editorBridgeService.isVisible().visible) return;
          if (unitId && isFocusSheets && !isFocusFormulaEditor) {
            this._showEditorByKeyboard(config);
          }
        }));
        d.add(disposable);
      }
    };
    const render = this._renderManagerService.getRenderById(DOCS_NORMAL_EDITOR_UNIT_ID_KEY);
    if (render) {
      addEvent(render);
    } else {
      this.disposeWithMe(this._renderManagerService.created$.pipe(filter((render2) => render2.unitId === DOCS_NORMAL_EDITOR_UNIT_ID_KEY)).subscribe((render2) => {
        disposable == null ? void 0 : disposable.dispose();
        addEvent(render2);
      }));
    }
  }
  _commandExecutedListener(d) {
    const refreshCommandSet = /* @__PURE__ */ new Set([ClearSelectionFormatCommand.id, SetZoomRatioCommand.id]);
    d.add(this._commandService.onCommandExecuted((command) => {
      if (refreshCommandSet.has(command.id)) {
        if (this._editorBridgeService.isVisible().visible) return;
        this._editorBridgeService.refreshEditCellState();
      }
      if (command.id === SetRangeValuesMutation.id) {
        const params = command.params;
        const { cellValue, unitId, subUnitId } = params;
        if (!cellValue) return;
        const editCell = this._editorBridgeService.getEditLocation();
        if (editCell) {
          const { unitId: editingUnitId, sheetId: editingSheetId, row, column } = editCell;
          if (unitId === editingUnitId && subUnitId === editingSheetId && cellValue && cellValue[row] && Object.prototype.hasOwnProperty.call(cellValue[row], column)) {
            this._editorBridgeService.refreshEditCellState();
          }
        }
      }
    }));
    d.add(this._commandService.beforeCommandExecuted((command, options) => {
      if (options == null ? void 0 : options.fromCollab) return;
      if (command.id === SetWorksheetActiveOperation.id) {
        this._tryHideEditor();
      }
    }));
  }
  _showEditorByKeyboard(config) {
    const event = config == null ? void 0 : config.event;
    if (config == null || !event.data && event.inputType !== "InsertParagraph") {
      return;
    }
    this._commandService.syncExecuteCommand(SetCellEditVisibleOperation.id, {
      visible: true,
      eventType: 4 /* Keyboard */,
      keycode: event.which,
      unitId: this._context.unitId
    });
  }
  _tryHideEditor() {
    if (this._editorBridgeService.isForceKeepVisible()) {
      return;
    }
    this._hideEditor();
  }
  _hideEditor() {
    if (this._editorBridgeService.isVisible().visible !== true) return;
    this._commandService.syncExecuteCommand(SetCellEditVisibleOperation.id, {
      visible: false,
      eventType: 1 /* PointerDown */,
      unitId: this._context.unitId
    });
  }
  _initialRangeSelector() {
    this.disposeWithMe(this._selectionManagerService.selectionMoving$.subscribe(this._rangeSelector.bind(this)));
    this.disposeWithMe(this._selectionManagerService.selectionMoveStart$.subscribe(this._rangeSelector.bind(this)));
    this.disposeWithMe(
      this._rangeSelectorService.openSelector$.subscribe(() => {
        const { unitId, sheetId, sheetName } = this._getCurrentUnitIdAndSheetId();
        if (!sheetId || !sheetName) return;
        const selectionWithStyle = this._selectionManagerService.getCurrentSelections();
        const ranges = selectionWithStyle == null ? void 0 : selectionWithStyle.map((value) => ({ range: value.range, unitId, sheetId, sheetName }));
        if (ranges) {
          this._rangeSelectorService.selectionChange(ranges);
        }
      })
    );
  }
  _rangeSelector(selectionWithStyle) {
    if (!selectionWithStyle) {
      return;
    }
    const { unitId, sheetId, sheetName } = this._getCurrentUnitIdAndSheetId();
    if (!sheetId || !sheetName) return;
    const ranges = selectionWithStyle.map((value) => {
      return { range: value.range, unitId, sheetId, sheetName };
    });
    this._rangeSelectorService.selectionChange(ranges);
  }
  _getCurrentUnitIdAndSheetId() {
    const workbook = this._context.unit;
    const worksheet = workbook.getActiveSheet();
    return {
      unitId: workbook.getUnitId(),
      sheetId: worksheet == null ? void 0 : worksheet.getSheetId(),
      sheetName: worksheet == null ? void 0 : worksheet.getName()
    };
  }
  _getSheetObject() {
    return getSheetObject(this._context.unit, this._context);
  }
  _isCurrentSheetFocused() {
    var _a;
    return ((_a = this._instanceSrv.getFocusedUnit()) == null ? void 0 : _a.getUnitId()) === this._context.unitId;
  }
};
EditorBridgeRenderController = __decorateClass([
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, ICommandService),
  __decorateParam(3, IEditorBridgeService),
  __decorateParam(4, Inject(SheetsSelectionsService)),
  __decorateParam(5, IRangeSelectorService),
  __decorateParam(6, IContextService),
  __decorateParam(7, IRenderManagerService),
  __decorateParam(8, IEditorService),
  __decorateParam(9, Inject(SheetSkeletonManagerService))
], EditorBridgeRenderController);

// ../packages/sheets-ui/src/views/header-menu-shape.ts
var HEADER_MENU_SHAPE_CIRCLE_FILL = "rgba(0, 0, 0, 0.15)";
var HEADER_MENU_SHAPE_TRIANGLE_FILL = "rgb(0, 0, 0)";
var HEADER_MENU_BACKGROUND_COLOR = "rgb(255, 255, 255, 1)";
var HeaderMenuShape = class extends Shape {
  constructor(key, props) {
    super(key, props);
    __publicField(this, "_size", 12);
    __publicField(this, "_iconRatio", 0.4);
    __publicField(this, "_mode", 0 /* NORMAL */);
    this.setShapeProps(props);
  }
  setShapeProps(props) {
    if (props == null ? void 0 : props.size) {
      this._size = props.size;
    }
    if (props == null ? void 0 : props.mode) {
      this._mode = props.mode;
    }
    this.transformByState({
      width: this._size,
      height: this._size
    });
  }
  _draw(ctx) {
    if (this._mode === 1 /* HIGHLIGHT */) {
      Rect.drawWith(ctx, {
        width: this._size,
        height: this._size,
        radius: this._size,
        fill: HEADER_MENU_SHAPE_CIRCLE_FILL
      });
    }
    const iconSize = this._size * 0.5 * this._iconRatio;
    const sixtyDegree = Math.PI / 180 * 60;
    const left = iconSize * Math.sin(sixtyDegree);
    const top = iconSize * Math.cos(sixtyDegree);
    RegularPolygon.drawWith(ctx, {
      pointsGroup: [
        [
          { x: -left + this._size / 2, y: -top + this._size / 2 },
          { x: left + this._size / 2, y: -top + this._size / 2 },
          { x: this._size / 2, y: iconSize + this._size / 2 }
        ]
      ],
      // left: this.left,
      // top: this.top,
      fill: HEADER_MENU_SHAPE_TRIANGLE_FILL
    });
  }
};

// ../packages/sheets-ui/src/controllers/render-controllers/header-menu.render-controller.ts
var HEADER_MENU_CONTROLLER_SHAPE = "__SpreadsheetHeaderMenuSHAPEControllerShape__";
var HEADER_MENU_CONTROLLER_MENU = "__SpreadsheetHeaderMenuMAINControllerShape__";
var HEADER_MENU_CONTROLLER_SHAPE_COLOR = "rgba(0, 0, 0, 0.1)";
var HeaderMenuRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _contextMenuService, _commandService, _selectionManagerService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._contextMenuService = _contextMenuService;
    this._commandService = _commandService;
    this._selectionManagerService = _selectionManagerService;
    __publicField(this, "_hoverRect");
    __publicField(this, "_hoverMenu");
    __publicField(this, "_currentColumn", Number.POSITIVE_INFINITY);
    // private _rowHeaderPointerMoveSub: Subscription;
    // private _colHeaderPointerMoveSub: Subscription;
    // private _rowHeaderPointerLeaveSub: Subscription;
    // private _colHeaderPointerLeaveSub: Subscription;
    // private _rowHeaderPointerEnterSub: Subscription;
    // private _colHeaderPointerEnterSub: Subscription;
    __publicField(this, "_headerPointerSubs");
    __publicField(this, "_colHeaderPointerSubs");
    this._initialize();
  }
  dispose() {
    var _a, _b, _c;
    (_a = this._hoverRect) == null ? void 0 : _a.dispose();
    (_b = this._hoverMenu) == null ? void 0 : _b.dispose();
    (_c = this._headerPointerSubs) == null ? void 0 : _c.unsubscribe();
    this._headerPointerSubs = null;
  }
  _initialize() {
    const scene = this._context.scene;
    this._hoverRect = new Rect(HEADER_MENU_CONTROLLER_SHAPE, {
      fill: HEADER_MENU_CONTROLLER_SHAPE_COLOR,
      evented: false
    });
    this._hoverMenu = new HeaderMenuShape(HEADER_MENU_CONTROLLER_MENU, { zIndex: 100, visible: false });
    scene.addObjects([this._hoverRect, this._hoverMenu], SHEET_COMPONENT_HEADER_LAYER_INDEX);
    this._initialHover(0 /* ROW */);
    this._initialHover(1 /* COLUMN */);
    this._initialHoverMenu();
  }
  // eslint-disable-next-line max-lines-per-function
  _initialHover(initialType = 0 /* ROW */) {
    var _a, _b, _c;
    const spreadsheetColumnHeader = this._context.components.get("__SpreadsheetColumnHeader__" /* COLUMN */);
    const spreadsheetRowHeader = this._context.components.get("__SpreadsheetRowHeader__" /* ROW */);
    const eventBindingObject = initialType === 0 /* ROW */ ? spreadsheetRowHeader : spreadsheetColumnHeader;
    const pointerMoveHandler = (evt) => {
      var _a2, _b2, _c2;
      const skeleton = (_a2 = this._sheetSkeletonManagerService.getCurrentParam()) == null ? void 0 : _a2.skeleton;
      if (skeleton == null) {
        return;
      }
      const { rowHeaderWidth, columnHeaderHeight } = skeleton;
      const { startX, startY, endX, endY, column } = getCoordByOffset(
        evt.offsetX,
        evt.offsetY,
        this._context.scene,
        skeleton
      );
      if (initialType === 0 /* ROW */) {
        (_b2 = this._hoverRect) == null ? void 0 : _b2.transformByState({
          width: rowHeaderWidth,
          height: endY - startY,
          left: 0,
          top: startY
        });
      } else {
        this._currentColumn = column;
        (_c2 = this._hoverRect) == null ? void 0 : _c2.transformByState({
          width: endX - startX,
          height: columnHeaderHeight,
          left: startX,
          top: 0
        });
        if (this._hoverMenu == null) {
          return;
        }
        if (endX - startX < columnHeaderHeight * 2) {
          this._hoverMenu.hide();
          return;
        }
        const menuSize = columnHeaderHeight * 0.8;
        this._hoverMenu.transformByState({
          left: endX - columnHeaderHeight,
          top: columnHeaderHeight / 2 - menuSize / 2
        });
        this._hoverMenu.setShapeProps({ size: menuSize });
        this._hoverMenu.show();
      }
    };
    const pointerEnterHandler = () => {
      var _a2;
      (_a2 = this._hoverRect) == null ? void 0 : _a2.show();
    };
    const pointerLeaveHandler = () => {
      var _a2, _b2;
      (_a2 = this._hoverRect) == null ? void 0 : _a2.hide();
      (_b2 = this._hoverMenu) == null ? void 0 : _b2.hide();
    };
    this._headerPointerSubs = new Subscription();
    const headerPointerMoveSub = eventBindingObject.onPointerMove$.subscribeEvent(pointerMoveHandler);
    const headerPointerEnterSub = eventBindingObject.onPointerEnter$.subscribeEvent(pointerEnterHandler);
    const headerPointerLeaveSub = eventBindingObject.onPointerLeave$.subscribeEvent(pointerLeaveHandler);
    (_a = this._headerPointerSubs) == null ? void 0 : _a.add(headerPointerMoveSub);
    (_b = this._headerPointerSubs) == null ? void 0 : _b.add(headerPointerEnterSub);
    (_c = this._headerPointerSubs) == null ? void 0 : _c.add(headerPointerLeaveSub);
  }
  _initialHoverMenu() {
    if (this._hoverMenu == null) {
      return;
    }
    this._hoverMenu.onPointerEnter$.subscribeEvent(() => {
      if (this._hoverMenu == null) {
        return;
      }
      this._hoverMenu.setProps({
        mode: 1 /* HIGHLIGHT */,
        visible: true
      });
      this._context.scene.setCursor("pointer" /* POINTER */);
    });
    this._hoverMenu.onPointerLeave$.subscribeEvent(() => {
      if (this._hoverMenu == null) {
        return;
      }
      this._hoverMenu.setProps({
        mode: 0 /* NORMAL */,
        visible: false
      });
      this._context.scene.resetCursor();
    });
    this._hoverMenu.onPointerDown$.subscribeEvent((evt) => {
      var _a;
      const currentColumn = this._currentColumn;
      const currentSelectionDatas = (_a = this._selectionManagerService.getCurrentSelections()) == null ? void 0 : _a.map((s) => s.range);
      const menuInSelections = !!(currentSelectionDatas == null ? void 0 : currentSelectionDatas.filter((range) => range.rangeType === 2 /* COLUMN */).find((data) => {
        const { startColumn, endColumn } = data;
        if (currentColumn >= startColumn && currentColumn <= endColumn) {
          return true;
        }
        return false;
      }));
      if (!menuInSelections) {
        const selection = this._getSelectionOnColumn(currentColumn);
        this._commandService.syncExecuteCommand(SetSelectionsOperation.id, selection);
      }
      evt.stopPropagation();
      evt.preventDefault();
      this._contextMenuService.triggerContextMenu(evt, "contextMenu.colHeader" /* COL_HEADER */);
    });
  }
  _getSelectionOnColumn(column) {
    const workbook = this._context.unit;
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) {
      throw new Error("No active worksheet");
    }
    return {
      unitId: workbook.getUnitId(),
      subUnitId: worksheet.getSheetId(),
      selections: [
        {
          range: {
            startRow: 0,
            startColumn: column,
            endRow: worksheet.getRowCount() - 1,
            endColumn: column,
            rangeType: 2 /* COLUMN */
          },
          primary: {
            startRow: 0,
            startColumn: column,
            endRow: 0,
            endColumn: column,
            actualRow: 0,
            actualColumn: column,
            isMerged: false,
            isMergedMainCell: false
          },
          style: null
        }
      ]
    };
  }
};
HeaderMenuRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, IContextMenuService),
  __decorateParam(3, ICommandService),
  __decorateParam(4, Inject(SheetsSelectionsService))
], HeaderMenuRenderController);

// ../packages/sheets-ui/src/views/header-unhide-shape.ts
var UNHIDE_ICON_SIZE = 12;
var UNHIDE_ARROW_RATIO = 0.4;
var HeaderUnhideShape = class extends Shape {
  constructor(key, props, onClick) {
    super(key, props);
    __publicField(this, "_size", UNHIDE_ICON_SIZE);
    __publicField(this, "_iconRatio", UNHIDE_ARROW_RATIO);
    __publicField(this, "_hovered", true);
    __publicField(this, "_hasPrevious", true);
    __publicField(this, "_hasNext", true);
    __publicField(this, "_unhideType");
    if (props) {
      this.setShapeProps(props);
    }
    this.onPointerEnter$.subscribeEvent(() => this.setShapeProps({ hovered: true }));
    this.onPointerLeave$.subscribeEvent(() => this.setShapeProps({ hovered: false }));
    this.onPointerDown$.subscribeEvent(() => onClick == null ? void 0 : onClick());
  }
  setShapeProps(props) {
    if (props.type !== void 0) {
      this._unhideType = props.type;
    }
    if (props.hovered !== void 0) {
      this._hovered = props.hovered;
    }
    if (props.hasPrevious !== void 0) {
      this._hasPrevious = props.hasPrevious;
    }
    if (props.hasNext !== void 0) {
      this._hasNext = props.hasNext;
    }
    this.transformByState({
      width: this._size * (this._unhideType === 1 /* COLUMN */ ? 2 : 1),
      height: this._size * (this._unhideType === 0 /* ROW */ ? 2 : 1)
    });
  }
  _draw(ctx) {
    if (this._unhideType === 0 /* ROW */) {
      this._drawOnRow(ctx);
    } else {
      this._drawOnCol(ctx);
    }
  }
  _drawOnRow(ctx) {
    if (this._hovered) {
      if (!this._hasNext || !this._hasPrevious) {
        Rect.drawWith(ctx, {
          width: this._size,
          height: this._size,
          stroke: HEADER_MENU_SHAPE_TRIANGLE_FILL,
          fill: HEADER_MENU_BACKGROUND_COLOR
        });
      } else {
        Rect.drawWith(ctx, {
          width: this._size,
          height: 2 * this._size,
          stroke: HEADER_MENU_SHAPE_TRIANGLE_FILL,
          fill: HEADER_MENU_BACKGROUND_COLOR
        });
      }
    }
    const iconSize = this._size * 0.5 * this._iconRatio;
    const sixtyDegree = Math.PI / 3;
    const top = iconSize * Math.cos(sixtyDegree);
    const left = iconSize * Math.sin(sixtyDegree);
    if (this._hasPrevious) {
      RegularPolygon.drawWith(ctx, {
        pointsGroup: [
          [
            { x: this._size / 2, y: this._size / 2 - left },
            { x: this._size / 2 - left, y: this._size / 2 + top },
            { x: this._size / 2 + left, y: this._size / 2 + top }
          ]
        ],
        fill: HEADER_MENU_SHAPE_TRIANGLE_FILL
      });
    }
    if (this._hasNext) {
      const offset = this._hasPrevious ? 3 : 1;
      RegularPolygon.drawWith(ctx, {
        pointsGroup: [
          [
            { x: this._size / 2, y: this._size * offset / 2 + left },
            { x: this._size / 2 - left, y: this._size * offset / 2 - top },
            { x: this._size / 2 + left, y: this._size * offset / 2 - top }
          ]
        ],
        fill: HEADER_MENU_SHAPE_TRIANGLE_FILL
      });
    }
  }
  /**
   *
   * @param ctx
   */
  _drawOnCol(ctx) {
    if (this._hovered) {
      if (!this._hasNext || !this._hasPrevious) {
        Rect.drawWith(ctx, {
          width: this._size,
          height: this._size,
          stroke: HEADER_MENU_SHAPE_TRIANGLE_FILL,
          fill: HEADER_MENU_BACKGROUND_COLOR
        });
      } else {
        Rect.drawWith(ctx, {
          width: 2 * this._size,
          height: this._size,
          stroke: HEADER_MENU_SHAPE_TRIANGLE_FILL,
          fill: HEADER_MENU_BACKGROUND_COLOR
        });
      }
    }
    const iconSize = this._size * 0.5 * this._iconRatio;
    const sixtyDegree = Math.PI / 3;
    const top = iconSize * Math.cos(sixtyDegree);
    const left = iconSize * Math.sin(sixtyDegree);
    if (this._hasPrevious) {
      RegularPolygon.drawWith(ctx, {
        pointsGroup: [
          [
            { x: -top + this._size / 2, y: this._size / 2 },
            { x: this._size / 2 + left, y: this._size / 2 - left },
            { x: this._size / 2 + left, y: this._size / 2 + left }
          ]
        ],
        fill: HEADER_MENU_SHAPE_TRIANGLE_FILL
      });
    }
    if (this._hasNext) {
      const offset = this._hasPrevious ? 3 : 1;
      RegularPolygon.drawWith(ctx, {
        pointsGroup: [
          [
            { x: top + this._size * offset / 2, y: this._size / 2 },
            { x: -left + this._size * offset / 2, y: this._size / 2 - left },
            { x: -left + this._size * offset / 2, y: this._size / 2 + left }
          ]
        ],
        fill: HEADER_MENU_SHAPE_TRIANGLE_FILL
      });
    }
  }
};

// ../packages/sheets-ui/src/controllers/render-controllers/header-unhide.render-controller.ts
var HEADER_UNHIDE_CONTROLLER_SHAPE = "__SpreadsheetHeaderUnhideSHAPEControllerShape__";
var HeaderUnhideRenderController = class extends RxDisposable {
  constructor(_context, _sheetSkeletonManagerService, _commandService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._commandService = _commandService;
    __publicField(this, "_shapes", { cols: [], rows: [] });
    this._init();
  }
  get _workbook() {
    return this._context.unit;
  }
  dispose() {
    super.dispose();
    this._clearShapes();
  }
  _init() {
    let activeSheetId = "";
    this._context.unit.activeSheet$.pipe(takeUntil(this.dispose$)).subscribe((worksheet) => {
      this._clearShapes();
      if (!worksheet) {
        activeSheetId = "";
        return;
      }
      ;
      activeSheetId = worksheet.getSheetId();
      this._update(this._workbook, worksheet);
    });
    this.disposeWithMe(
      this._sheetSkeletonManagerService.currentSkeleton$.subscribe((param) => {
        if (param) {
          const { unitId, sheetId } = param;
          if (unitId === this._workbook.getUnitId() && sheetId === activeSheetId) {
            const worksheet = this._workbook.getSheetBySheetId(sheetId);
            if (worksheet) {
              this._update(this._workbook, worksheet);
            }
          }
        }
      })
    );
  }
  _update(workbook, worksheet) {
    var _a;
    const skeleton = (_a = this._sheetSkeletonManagerService.getSkeletonParam(worksheet.getSheetId())) == null ? void 0 : _a.skeleton;
    if (!skeleton) return;
    const hiddenRowRanges = worksheet.getHiddenRows();
    const hiddenColRanges = worksheet.getHiddenCols();
    const sheetObject = this._getSheetObject();
    const { scene } = sheetObject;
    const rowCount = worksheet.getRowCount();
    const rowShapes = hiddenRowRanges.map((range) => {
      const { startRow, endRow } = range;
      const position = getCoordByCell(startRow, 0, scene, skeleton);
      const hasPrevious = startRow !== 0;
      const hasNext = endRow !== rowCount - 1;
      return new HeaderUnhideShape(
        HEADER_UNHIDE_CONTROLLER_SHAPE,
        {
          type: 0 /* ROW */,
          hovered: false,
          hasPrevious,
          hasNext,
          top: position.startY - (hasPrevious ? UNHIDE_ICON_SIZE : 0),
          left: position.startX - UNHIDE_ICON_SIZE
        },
        () => this._commandService.executeCommand(
          SetSpecificRowsVisibleCommand.id,
          {
            unitId: workbook.getUnitId(),
            subUnitId: worksheet.getSheetId(),
            ranges: [range]
          }
        )
      );
    });
    const colCount = worksheet.getColumnCount();
    const colShapes = hiddenColRanges.map((range) => {
      const { startColumn, endColumn } = range;
      const position = getCoordByCell(0, startColumn, scene, skeleton);
      const hasPrevious = startColumn !== 0;
      const hasNext = endColumn !== colCount - 1;
      return new HeaderUnhideShape(
        HEADER_UNHIDE_CONTROLLER_SHAPE,
        {
          type: 1 /* COLUMN */,
          hovered: false,
          hasPrevious,
          hasNext,
          top: 20 - UNHIDE_ICON_SIZE,
          left: position.startX - (hasPrevious ? UNHIDE_ICON_SIZE : 0)
        },
        () => this._commandService.executeCommand(
          SetSpecificColsVisibleCommand.id,
          {
            unitId: workbook.getUnitId(),
            subUnitId: worksheet.getSheetId(),
            ranges: [range]
          }
        )
      );
    });
    scene.addObjects(colShapes, SHEET_COMPONENT_UNHIDE_LAYER_INDEX);
    scene.addObjects(rowShapes, SHEET_COMPONENT_UNHIDE_LAYER_INDEX);
    this._clearShapes();
    this._shapes = { cols: colShapes, rows: rowShapes };
  }
  _clearShapes() {
    this._shapes.cols.forEach((shape) => shape.dispose());
    this._shapes.rows.forEach((shape) => shape.dispose());
    this._shapes = { cols: [], rows: [] };
  }
  _getSheetObject() {
    return getSheetObject(this._workbook, this._context);
  }
};
HeaderUnhideRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, ICommandService)
], HeaderUnhideRenderController);

// ../packages/sheets-ui/src/controllers/render-controllers/skeleton.render-controller.ts
var SheetSkeletonRenderController = class extends Disposable {
  constructor(_context, _sheetSkeletonManagerService, _renderManagerService) {
    super();
    this._context = _context;
    this._sheetSkeletonManagerService = _sheetSkeletonManagerService;
    this._renderManagerService = _renderManagerService;
    this.disposeWithMe(this._context.unit.sheetDisposed$.subscribe((sheet) => {
      this._sheetSkeletonManagerService.disposeSkeleton(sheet.getSheetId());
    }));
    this._sheetSkeletonManagerService.currentSkeleton$.subscribe((param) => {
      this._updateSceneSize(param);
    });
  }
  _updateSceneSize(param) {
    var _a;
    if (param == null) {
      return;
    }
    const { unitId } = this._context;
    const { skeleton } = param;
    const scene = (_a = this._renderManagerService.getRenderById(unitId)) == null ? void 0 : _a.scene;
    if (skeleton == null || scene == null) {
      return;
    }
    const { rowTotalHeight, columnTotalWidth, rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop } = skeleton;
    const workbook = this._context.unit;
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return;
    scene == null ? void 0 : scene.transformByState({
      width: rowHeaderWidthAndMarginLeft + columnTotalWidth,
      height: columnHeaderHeightAndMarginTop + rowTotalHeight
    });
  }
};
SheetSkeletonRenderController = __decorateClass([
  __decorateParam(1, Inject(SheetSkeletonManagerService)),
  __decorateParam(2, IRenderManagerService)
], SheetSkeletonRenderController);

// ../packages/sheets-ui/src/services/selection/selection-render.service.ts
var SheetSelectionRenderService = class extends BaseSelectionRenderService {
  constructor(_context, injector, themeService, shortcutService, selectionManagerService, sheetSkeletonManagerService, _logService, _commandService, _contextService) {
    super(
      injector,
      themeService,
      shortcutService,
      sheetSkeletonManagerService,
      _contextService
    );
    this._context = _context;
    this._logService = _logService;
    this._commandService = _commandService;
    this._contextService = _contextService;
    __publicField(this, "_workbookSelections");
    __publicField(this, "_renderDisposable", null);
    this._workbookSelections = selectionManagerService.getWorkbookSelections(this._context.unitId);
    this._init();
  }
  _init() {
    const sheetObject = this._getSheetObject();
    this._contextService.setContextValue(SELECTIONS_ENABLED, true);
    this._initEventListeners(sheetObject);
    this._initSelectionModelChangeListener();
    this._initThemeChangeListener();
    this._initSkeletonChangeListener();
    this._initUserActionSyncListener();
  }
  _initEventListeners(sheetObject) {
    const { spreadsheetRowHeader, spreadsheetColumnHeader, spreadsheet, spreadsheetLeftTopPlaceholder } = sheetObject;
    const { scene } = this._context;
    this.disposeWithMe(spreadsheet == null ? void 0 : spreadsheet.onPointerDown$.subscribeEvent((evt, state) => {
      if (this.isSelectionDisabled()) return;
      if (this.inRefSelectionMode()) return;
      this._onPointerDown(evt, spreadsheet.zIndex + 1, 0 /* NORMAL */, this._getActiveViewport(evt));
      if (evt.button !== 2) {
        state.stopPropagation();
      }
    }));
    this.disposeWithMe(
      spreadsheetRowHeader == null ? void 0 : spreadsheetRowHeader.onPointerDown$.subscribeEvent((evt, state) => {
        if (this.isSelectionDisabled()) return;
        if (this.inRefSelectionMode()) return;
        const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
        const { row } = getCoordByOffset(evt.offsetX, evt.offsetY, scene, skeleton);
        const matchSelectionData = isThisRowSelected(this._workbookSelections.getCurrentSelections(), row);
        if (matchSelectionData) return;
        this._onPointerDown(evt, (spreadsheet.zIndex || 1) + 1, 1 /* ROW */, this._getActiveViewport(evt), 2 /* Y */);
        if (evt.button !== 2) {
          state.stopPropagation();
        }
      })
    );
    this.disposeWithMe(spreadsheetColumnHeader == null ? void 0 : spreadsheetColumnHeader.onPointerDown$.subscribeEvent((evt, state) => {
      if (this.isSelectionDisabled()) return;
      if (this.inRefSelectionMode()) return;
      const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
      const { column } = getCoordByOffset(evt.offsetX, evt.offsetY, scene, skeleton);
      const matchSelectionData = isThisColSelected(this._workbookSelections.getCurrentSelections(), column);
      if (matchSelectionData) return;
      this._onPointerDown(evt, (spreadsheet.zIndex || 1) + 1, 2 /* COLUMN */, this._getActiveViewport(evt), 1 /* X */);
      if (evt.button !== 2) {
        state.stopPropagation();
      }
    }));
    this.disposeWithMe(spreadsheetLeftTopPlaceholder == null ? void 0 : spreadsheetLeftTopPlaceholder.onPointerDown$.subscribeEvent((evt, state) => {
      if (this.isSelectionDisabled()) return;
      if (this.inRefSelectionMode()) return;
      this._reset();
      const skeleton = this._sheetSkeletonManagerService.getCurrentParam().skeleton;
      const selectionWithStyle = selectionDataForSelectAll(skeleton);
      this._addSelectionControlByModelData(selectionWithStyle);
      this.refreshSelectionMoveEnd();
      if (evt.button !== 2) {
        state.stopPropagation();
      }
    }));
  }
  _initThemeChangeListener() {
    this.disposeWithMe(this._themeService.currentTheme$.subscribe(() => {
      this._initSelectionThemeFromThemeService();
      const selections = this._workbookSelections.getCurrentSelections();
      if (!selections) return;
      this.resetSelectionsByModelData(selections);
    }));
  }
  /**
   * Response for selection model changing.
   */
  _initSelectionModelChangeListener() {
    this.disposeWithMe(merge(
      this._workbookSelections.selectionMoveEnd$,
      // triggered by keyboard(e.g. arrow key tab enter)
      this._workbookSelections.selectionSet$
      // shift + arrow key
    ).subscribe((selectionWithStyleList) => {
      this.resetSelectionsByModelData(selectionWithStyleList);
    }));
  }
  disableSelection() {
    this._contextService.setContextValue(SELECTIONS_ENABLED, false);
  }
  enableSelection() {
    this._contextService.setContextValue(SELECTIONS_ENABLED, true);
  }
  transparentSelection() {
    this.setSelectionTheme({
      primaryColor: "transparent"
    });
    const selectionsWithStyle = this._workbookSelections.getCurrentSelections();
    for (let index = 0; index < selectionsWithStyle.length; index++) {
      const selectionWithStyle = selectionsWithStyle[index];
      selectionWithStyle.style = genNormalSelectionStyle(this._selectionTheme);
    }
    this.resetSelectionsByModelData(selectionsWithStyle);
  }
  showSelection() {
    const currTheme = this._themeService.getCurrentTheme();
    this.setSelectionTheme(currTheme);
    const selectionsWithStyle = this._workbookSelections.getCurrentSelections();
    for (let index = 0; index < selectionsWithStyle.length; index++) {
      const selectionWithStyle = selectionsWithStyle[index];
      if (selectionWithStyle.style) {
        selectionWithStyle.style = genNormalSelectionStyle(this._selectionTheme);
      }
    }
    this.resetSelectionsByModelData(selectionsWithStyle);
  }
  /**
   * Handle events in spreadsheet. (e.g. drag and move to make a selection)
   */
  _initUserActionSyncListener() {
    this.disposeWithMe(this.selectionMoveStart$.subscribe((params) => this._updateSelections(params, 0 /* MOVE_START */)));
    this.disposeWithMe(this.selectionMoving$.subscribe((params) => this._updateSelections(params, 1 /* MOVING */)));
    this.disposeWithMe(this._contextService.subscribeContextValue$(REF_SELECTIONS_ENABLED).pipe(startWith(false), distinctUntilChanged()).subscribe((enabled) => {
      if (enabled) {
        this._reset();
      } else {
      }
    }));
    this.disposeWithMe(this._contextService.subscribeContextValue$(SELECTIONS_ENABLED).pipe(startWith(true), distinctUntilChanged()).subscribe((enabled) => {
      var _a;
      if (!enabled) {
        (_a = this._renderDisposable) == null ? void 0 : _a.dispose();
        this._renderDisposable = null;
        this._reset();
      } else {
        this._renderDisposable = toDisposable(
          this.selectionMoveEnd$.subscribe((params) => {
            this._updateSelections(params, 2 /* MOVE_END */);
          })
        );
      }
    }));
  }
  /**
   * Update selectionData to selectionDataModel (WorkBookSelections) by SetSelectionsOperation.
   *
   * Unlike baseSelectionRenderService@resetSelectionsByModelData, this method is for update WorkbookSelectionModel.
   *
   *
   * @param selectionDataWithStyleList
   * @param type
   */
  _updateSelections(selectionDataWithStyleList, type) {
    const workbook = this._context.unit;
    const unitId = workbook.getUnitId();
    const sheetId = workbook.getActiveSheet().getSheetId();
    if (selectionDataWithStyleList.length === 0) {
      return;
    }
    const selectionWithStyles = selectionDataWithStyleList.map(
      (selectionDataWithStyle) => convertSelectionDataToRange(selectionDataWithStyle)
    );
    this._commandService.executeCommand(SetSelectionsOperation.id, {
      unitId,
      subUnitId: sheetId,
      type,
      selections: selectionWithStyles
    });
  }
  _initSkeletonChangeListener() {
    this.disposeWithMe(this._sheetSkeletonManagerService.currentSkeleton$.subscribe((param) => {
      var _a, _b;
      if (param == null) {
        this._logService.error("[SelectionRenderService]: should not receive null!");
        return;
      }
      const unitId = this._context.unitId;
      const { sheetId, skeleton } = param;
      const { scene } = this._context;
      const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
      const prevSheetId = (_b = (_a = this._skeleton) == null ? void 0 : _a.worksheet) == null ? void 0 : _b.getSheetId();
      this._changeRuntime(skeleton, scene, viewportMain);
      if (prevSheetId !== skeleton.worksheet.getSheetId()) {
        const selections = this._workbookSelections.getCurrentSelections();
        this._commandService.syncExecuteCommand(SetSelectionsOperation.id, {
          unitId,
          subUnitId: sheetId,
          selections: selections.length !== 0 ? selections : [getTopLeftSelectionOfCurrSheet(skeleton)]
        });
      }
      const currentSelections = this._workbookSelections.getCurrentSelections();
      if (currentSelections != null) {
        this.resetSelectionsByModelData(currentSelections);
      }
    }));
  }
  _getActiveViewport(evt) {
    const sheetObject = this._getSheetObject();
    return sheetObject == null ? void 0 : sheetObject.scene.getActiveViewportByCoord(Vector2.FromArray([evt.offsetX, evt.offsetY]));
  }
  _getSheetObject() {
    return getSheetObject(this._context.unit, this._context);
  }
  /**
   * Handle pointer down event, bind pointermove & pointerup handler.
   * then trigger selectionMoveStart$.
   *
   * @param evt
   * @param _zIndex
   * @param rangeType
   * @param viewport
   * @param scrollTimerType
   */
  // eslint-disable-next-line complexity, max-lines-per-function
  _onPointerDown(evt, _zIndex = 0, rangeType = 0 /* NORMAL */, viewport, scrollTimerType = 3 /* ALL */) {
    var _a, _b;
    this._rangeType = rangeType;
    const skeleton = this._skeleton;
    const scene = this._scene;
    if (!scene || !skeleton) {
      return;
    }
    if (viewport) {
      this._activeViewport = viewport;
    }
    const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
    const viewportMain = scene.getViewport("viewMain" /* VIEW_MAIN */);
    if (!viewportMain) return;
    const relativeCoords = scene.getCoordRelativeToViewport(Vector2.FromArray([evtOffsetX, evtOffsetY]));
    const { x: offsetX, y: offsetY } = relativeCoords;
    this._startViewportPosX = offsetX;
    this._startViewportPosY = offsetY;
    const scrollXY = scene.getScrollXYInfoByViewport(relativeCoords);
    const { scaleX, scaleY } = scene.getAncestorScale();
    const selectCell = this._skeleton.getCellByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
    if (!selectCell) return;
    switch (rangeType) {
      case 0 /* NORMAL */:
        break;
      case 1 /* ROW */:
        selectCell.startColumn = 0;
        selectCell.endColumn = this._skeleton.getColumnCount() - 1;
        selectCell.startRow = selectCell.actualRow;
        selectCell.endRow = selectCell.actualRow;
        break;
      case 2 /* COLUMN */:
        selectCell.startRow = 0;
        selectCell.endRow = this._skeleton.getRowCount() - 1;
        selectCell.startColumn = selectCell.actualColumn;
        selectCell.endColumn = selectCell.actualColumn;
        break;
      case 3 /* ALL */:
        selectCell.startRow = 0;
        selectCell.startColumn = 0;
        selectCell.endRow = this._skeleton.getRowCount() - 1;
        selectCell.endColumn = this._skeleton.getColumnCount() - 1;
    }
    const selectionWithStyle = { range: selectCell, primary: selectCell, style: null };
    selectionWithStyle.range.rangeType = rangeType;
    const selectionCellWithCoord = attachSelectionWithCoord(selectionWithStyle, this._skeleton);
    this._startRangeWhenPointerDown = { ...selectionCellWithCoord.rangeWithCoord };
    let activeSelectionControl = this.getActiveSelectionControl();
    const cursorRangeWidthCoord = { ...selectionCellWithCoord.rangeWithCoord, rangeType };
    const curControls = this.getSelectionControls();
    for (const control of curControls) {
      if (evt.button === 2 && Rectangle.contains(control.model, cursorRangeWidthCoord)) {
        activeSelectionControl = control;
        return;
      }
    }
    this._checkClearPreviousControls(evt);
    const currentCell = activeSelectionControl == null ? void 0 : activeSelectionControl.model.currentCell;
    const expandByShiftKey = evt.shiftKey && currentCell;
    const remainLastEnable = this._remainLastEnabled && !evt.ctrlKey && !evt.shiftKey && !this._skipLastEnabled && !this._singleSelectionEnabled;
    if (expandByShiftKey && currentCell) {
      this._makeSelectionByTwoCells(
        currentCell,
        cursorRangeWidthCoord,
        skeleton,
        rangeType,
        activeSelectionControl
        // Get updated in this method
      );
    } else if (remainLastEnable && activeSelectionControl) {
      activeSelectionControl.updateRangeBySelectionWithCoord(selectionCellWithCoord);
    } else {
      activeSelectionControl = this.newSelectionControl(scene, skeleton, selectionWithStyle);
    }
    for (let i = 0; i < this.getSelectionControls().length - 1; i++) {
      this.getSelectionControls()[i].clearHighlight();
    }
    scene.disableObjectsEvent();
    this._clearUpdatingListeners();
    this._addEndingListeners();
    (_a = scene.getTransformer()) == null ? void 0 : _a.clearSelectedObjects();
    this._setupPointerMoveListener(viewportMain, activeSelectionControl, rangeType, scrollTimerType, offsetX, offsetY);
    this._escapeShortcutDisposable = this._shortcutService.forceEscape();
    this._selectionMoveStart$.next(this.getSelectionDataWithStyle());
    this._scenePointerUpSub = scene.onPointerUp$.subscribeEvent(() => {
      var _a2;
      this._clearUpdatingListeners();
      this._selectionMoveEnd$.next(this.getSelectionDataWithStyle());
      (_a2 = this._escapeShortcutDisposable) == null ? void 0 : _a2.dispose();
      this._escapeShortcutDisposable = null;
    });
    (_b = this._scene.getEngine()) == null ? void 0 : _b.setCapture();
  }
};
SheetSelectionRenderService = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, Inject(ThemeService)),
  __decorateParam(3, IShortcutService),
  __decorateParam(4, Inject(SheetsSelectionsService)),
  __decorateParam(5, Inject(SheetSkeletonManagerService)),
  __decorateParam(6, ILogService),
  __decorateParam(7, ICommandService),
  __decorateParam(8, IContextService)
], SheetSelectionRenderService);

// ../packages/sheets-ui/src/plugin.ts
var UniverSheetsUIPlugin = class extends Plugin {
  /** @ignore */
  constructor(_config = defaultPluginConfig, _injector, _renderManagerService, _configService, _univerInstanceService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._renderManagerService = _renderManagerService;
    this._configService = _configService;
    this._univerInstanceService = _univerInstanceService;
    const { menu, ...rest } = merge_default(
      {},
      defaultPluginConfig,
      this._config
    );
    if (menu) {
      this._configService.setConfig("menu", menu, { merge: true });
    }
    this._configService.setConfig(SHEETS_UI_PLUGIN_CONFIG_KEY, rest);
  }
  onStarting() {
    registerDependencies(this._injector, mergeOverrideWithDependencies([
      [ShortcutExperienceService],
      [IEditorBridgeService, { useClass: EditorBridgeService }],
      [ISheetClipboardService, { useClass: SheetClipboardService }],
      [ISheetBarService, { useClass: SheetBarService }],
      [IFormatPainterService, { useClass: FormatPainterService }],
      [ICellEditorManagerService, { useClass: CellEditorManagerService }],
      [IFormulaEditorManagerService, { useClass: FormulaEditorManagerService }],
      [IRefSelectionsService, { useClass: RefSelectionsService }],
      [IAutoFillService, { useClass: AutoFillService }],
      [SheetPrintInterceptorService],
      [IStatusBarService, { useClass: StatusBarService }],
      [IMarkSelectionService, { useClass: MarkSelectionService }],
      [HoverManagerService],
      [DragManagerService],
      [SheetCanvasPopManagerService],
      [CellAlertManagerService],
      [SelectAllService],
      // controllers
      [ActiveWorksheetController],
      [AutoHeightController],
      [AutoWidthController],
      [FormulaEditorController],
      [SheetsRenderService],
      [SheetUIController],
      [StatusBarController],
      [AutoFillController],
      [FormatPainterController],
      [SheetsDefinedNameController],
      [EditorDataSyncController],
      [SheetCheckboxController],
      // permission
      [SheetPermissionPanelModel],
      [SheetPermissionInitUIController],
      [SheetPermissionUserManagerService],
      [SheetPermissionInterceptorClipboardController],
      [SheetPermissionCheckUIController],
      [SheetPermissionRenderManagerController]
    ], this._config.override));
  }
  onReady() {
    if (!this._config.disableAutoFocus) {
      this._initAutoFocus();
    }
    registerDependencies(this._injector, [
      [SheetClipboardController]
    ]);
    this._registerRenderBasics();
    touchDependencies(this._injector, [
      [SheetUIController],
      [SheetsRenderService],
      [ActiveWorksheetController],
      [SheetPermissionCheckUIController],
      [SheetPermissionInitUIController]
    ]);
  }
  onRendered() {
    this._registerRenderModules();
    touchDependencies(this._injector, [
      [SheetPermissionRenderManagerController],
      [SheetPermissionPanelModel],
      [SheetClipboardController],
      [FormulaEditorController],
      [SheetsDefinedNameController],
      [StatusBarController],
      [AutoHeightController],
      [AutoWidthController],
      [EditorDataSyncController],
      [SheetCheckboxController]
    ]);
  }
  onSteady() {
    touchDependencies(this._injector, [
      [FormatPainterController],
      [AutoFillController],
      [SheetPermissionInterceptorClipboardController]
    ]);
  }
  _registerRenderBasics() {
    [
      [SheetSkeletonManagerService],
      [SheetSkeletonRenderController],
      [SheetRenderController],
      [ISheetSelectionRenderService, { useClass: SheetSelectionRenderService }]
    ].forEach((m) => {
      this.disposeWithMe(this._renderManagerService.registerRenderModule(O.UNIVER_SHEET, m));
    });
  }
  // We have to let render basics get bootstrapped before. Because some render controllers relies on
  // a correct skeleton when they get loaded.
  _registerRenderModules() {
    var _a;
    const modules = [
      [HeaderMoveRenderController],
      [HeaderUnhideRenderController],
      [HeaderResizeRenderController],
      // Caution: ScrollRenderController should placed before ZoomRenderController.
      [SheetScrollManagerService],
      [SheetsScrollRenderController],
      [HeaderFreezeRenderController],
      [SheetsZoomRenderController],
      [SheetCellEditorResizeService],
      [FormatPainterRenderController],
      [ClipboardRenderController],
      [CellAlertRenderController],
      [ForceStringAlertRenderController],
      [MarkSelectionRenderController],
      [HoverRenderController],
      [DragRenderController],
      [ForceStringRenderController],
      [CellCustomRenderController],
      [SheetContextMenuRenderController],
      [MoveRangeRenderController],
      // editor
      [EditorBridgeRenderController],
      [EditingRenderController],
      // permission
      [SheetPermissionInterceptorCanvasRenderController],
      [SheetPermissionInterceptorFormulaRenderController],
      [SheetPermissionRenderController],
      [WorksheetProtectionRenderController]
    ];
    const config = this._configService.getConfig(UI_PLUGIN_CONFIG_KEY);
    const showContextMenu = (_a = config == null ? void 0 : config.contextMenu) != null ? _a : true;
    if (showContextMenu) {
      modules.push([HeaderMenuRenderController]);
    }
    modules.forEach((m) => {
      this.disposeWithMe(this._renderManagerService.registerRenderModule(O.UNIVER_SHEET, m));
    });
  }
  _initAutoFocus() {
    const univerInstanceService = this._univerInstanceService;
    this.disposeWithMe(univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).pipe(filter((v) => !!v)).subscribe((workbook) => univerInstanceService.focusUnit(workbook.getUnitId())));
  }
};
__publicField(UniverSheetsUIPlugin, "pluginName", "SHEET_UI_PLUGIN");
__publicField(UniverSheetsUIPlugin, "type", O.UNIVER_SHEET);
UniverSheetsUIPlugin = __decorateClass([
  DependentOn(UniverSheetsPlugin),
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IRenderManagerService),
  __decorateParam(3, IConfigService),
  __decorateParam(4, IUniverInstanceService)
], UniverSheetsUIPlugin);

// ../packages/sheets-ui/src/controllers/editor/utils/is-embedding-formula-editor.ts
var EMBEDDING_FORMULA_EDITOR = "embedding_formula_editor";

// ../packages/sheets-ui/src/services/utils/drawing-position-util.ts
function convertPositionSheetOverGridToAbsolute(unitId, subUnitId, sheetOverGridPosition, sheetSkeletonManagerService) {
  const { from, to } = sheetOverGridPosition;
  const { column: fromColumn, columnOffset: fromColumnOffset, row: fromRow, rowOffset: fromRowOffset } = from;
  const { column: toColumn, columnOffset: toColumnOffset, row: toRow, rowOffset: toRowOffset } = to;
  const skeleton = sheetSkeletonManagerService.ensureSkeleton(subUnitId);
  if (skeleton == null) {
    throw new Error("No current skeleton");
  }
  const startSelectionCell = attachRangeWithCoord(skeleton, {
    startColumn: fromColumn,
    endColumn: fromColumn,
    startRow: fromRow,
    endRow: fromRow
  });
  const endSelectionCell = attachRangeWithCoord(skeleton, {
    startColumn: toColumn,
    endColumn: toColumn,
    startRow: toRow,
    endRow: toRow
  });
  const { startX: startSelectionX, startY: startSelectionY } = startSelectionCell;
  const { startX: endSelectionX, startY: endSelectionY } = endSelectionCell;
  const left = precisionTo(startSelectionX + fromColumnOffset, 1);
  const top = precisionTo(startSelectionY + fromRowOffset, 1);
  let width = precisionTo(endSelectionX + toColumnOffset - left, 1);
  let height = precisionTo(endSelectionY + toRowOffset - top, 1);
  if (startSelectionCell.startX === endSelectionCell.endX) {
    width = 0;
  }
  if (startSelectionCell.startY === endSelectionCell.endY) {
    height = 0;
  }
  return {
    unitId,
    subUnitId,
    left,
    top,
    width,
    height
  };
}
function convertPositionCellToSheetOverGrid(unitId, subUnitId, cellOverGridPosition, width, height, selectionRenderService, sheetSkeletonManagerService) {
  const { column: fromColumn, columnOffset: fromColumnOffset, row: fromRow, rowOffset: fromRowOffset } = cellOverGridPosition;
  const skeleton = sheetSkeletonManagerService.ensureSkeleton(subUnitId);
  if (skeleton == null) {
    throw new Error("No current skeleton");
  }
  const startSelectionCell = attachRangeWithCoord(skeleton, {
    startColumn: fromColumn,
    endColumn: fromColumn,
    startRow: fromRow,
    endRow: fromRow
  });
  const { startX: startSelectionX, startY: startSelectionY } = startSelectionCell;
  const left = precisionTo(startSelectionX + fromColumnOffset, 1);
  const top = precisionTo(startSelectionY + fromRowOffset, 1);
  const endSelectionCell = selectionRenderService.getCellWithCoordByOffset(left + width, top + height, skeleton);
  if (endSelectionCell == null) {
    throw new Error("No end selection cell");
  }
  const to = {
    column: endSelectionCell.actualColumn,
    columnOffset: precisionTo(left + width - endSelectionCell.startX, 1),
    row: endSelectionCell.actualRow,
    rowOffset: precisionTo(top + height - endSelectionCell.startY, 1)
  };
  return {
    unitId,
    subUnitId,
    sheetTransform: {
      from: {
        column: fromColumn,
        columnOffset: fromColumnOffset,
        row: fromRow,
        rowOffset: fromRowOffset
      },
      to
    },
    transform: {
      left,
      top,
      width,
      height
    }
  };
}

export {
  getEditorObject,
  RANGE_SELECTOR_COMPONENT_KEY,
  EMBEDDING_FORMULA_EDITOR_COMPONENT_KEY,
  SetRowHeaderWidthCommand,
  SetColumnHeaderHeightCommand,
  genNormalSelectionStyle,
  attachRangeWithCoord,
  attachSelectionWithCoord,
  SelectionControl,
  ISheetSelectionRenderService,
  BaseSelectionRenderService,
  selectionDataForSelectAll,
  SheetSkeletonManagerService,
  useActiveWorkbook,
  useWorkbooks,
  AutoHeightController,
  discreteRangeToRange,
  virtualizeDiscreteRanges,
  getAutoFillRepeatRange,
  IAutoFillService,
  AutoFillCommand,
  RefillCommand,
  IEditorBridgeService,
  SetCellEditVisibleOperation,
  SetZoomRatioCommand,
  getSheetObject,
  getCoordByCell,
  getCoordByOffset,
  SetZoomRatioOperation,
  SheetsRenderService,
  MoveSelectionCommand,
  ExpandSelectionCommand,
  SheetScrollManagerService,
  SetScrollOperation,
  ScrollToCellCommand,
  SheetsScrollRenderController,
  ScrollToRangeOperation,
  IFormulaEditorManagerService,
  RenderSheetContent,
  whenSheetEditorFocused,
  whenFormulaEditorActivated,
  EditingRenderController,
  IMarkSelectionService,
  getRepeatRange,
  PREDEFINED_HOOK_NAME,
  ISheetClipboardService,
  SheetCopyCommand,
  SheetCutCommand,
  SheetPasteCommand,
  SheetPasteShortKeyCommand,
  SheetPasteValueCommand,
  SheetPasteFormatCommand,
  SheetPasteColWidthCommand,
  SheetPasteBesidesBorderCommand,
  SetRangeBoldCommand,
  SetRangeItalicCommand,
  SetRangeUnderlineCommand,
  SetRangeStrickThroughCommand,
  SetRangeSubscriptCommand,
  SetRangeSuperscriptCommand,
  SetRangeFontSizeCommand,
  SetRangeFontFamilyCommand,
  SetRangeTextColorCommand,
  IFormatPainterService,
  SetWorksheetColAutoWidthCommand,
  deriveStateFromActiveSheet$,
  getCurrentExclusiveRangeInterest$,
  getObservableWithExclusiveRange$,
  getCurrentRangeDisable$,
  PASTE_SPECIAL_MENU_ID,
  matchedSelectionByRowColIndex,
  menuSchema,
  SheetUIController,
  useHighlightRange,
  SheetCanvasPopManagerService,
  CellAlertManagerService,
  DragManagerService,
  getCustomRangePosition,
  getEditingCustomRangePosition,
  HoverManagerService,
  HoverRenderController,
  SheetPrintInterceptorService,
  UniverSheetsMobileUIPlugin,
  UniverSheetsUIPlugin,
  EMBEDDING_FORMULA_EDITOR,
  convertPositionSheetOverGridToAbsolute,
  convertPositionCellToSheetOverGrid
};
//# sourceMappingURL=chunk-NW7E7FBW.js.map
