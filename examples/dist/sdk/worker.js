"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isFunction = void 0;
    function isFunction2(value) {
      return typeof value === "function";
    }
    exports2.isFunction = isFunction2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createErrorClass = void 0;
    function createErrorClass(createImpl) {
      var _super = function(instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      var ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }
    exports2.createErrorClass = createErrorClass;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnsubscriptionError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
      return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
      };
    });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.arrRemove = void 0;
    function arrRemove(arr, item) {
      if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }
    exports2.arrRemove = arrRemove;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isSubscription = exports2.EMPTY_SUBSCRIPTION = exports2.Subscription = void 0;
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var arrRemove_1 = require_arrRemove();
    var Subscription = function() {
      function Subscription2(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
      }
      Subscription2.prototype.unsubscribe = function() {
        var e_1, _a2, e_2, _b2;
        var errors;
        if (!this.closed) {
          this.closed = true;
          var _parentage = this._parentage;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              try {
                for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                  var parent_1 = _parentage_1_1.value;
                  parent_1.remove(this);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return)) _a2.call(_parentage_1);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
            } else {
              _parentage.remove(this);
            }
          }
          var initialFinalizer = this.initialTeardown;
          if (isFunction_1.isFunction(initialFinalizer)) {
            try {
              initialFinalizer();
            } catch (e) {
              errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
            }
          }
          var _finalizers = this._finalizers;
          if (_finalizers) {
            this._finalizers = null;
            try {
              for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                var finalizer = _finalizers_1_1.value;
                try {
                  execFinalizer(finalizer);
                } catch (err) {
                  errors = errors !== null && errors !== void 0 ? errors : [];
                  if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                    errors = __spreadArray2(__spreadArray2([], __read(errors)), __read(err.errors));
                  } else {
                    errors.push(err);
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return)) _b2.call(_finalizers_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
          }
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var _a2;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execFinalizer(teardown);
          } else {
            if (teardown instanceof Subscription2) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
          }
        }
      };
      Subscription2.prototype._hasParent = function(parent) {
        var _parentage = this._parentage;
        return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
      };
      Subscription2.prototype._addParent = function(parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      };
      Subscription2.prototype._removeParent = function(parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove_1.arrRemove(_parentage, parent);
        }
      };
      Subscription2.prototype.remove = function(teardown) {
        var _finalizers = this._finalizers;
        _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
        if (teardown instanceof Subscription2) {
          teardown._removeParent(this);
        }
      };
      Subscription2.EMPTY = function() {
        var empty = new Subscription2();
        empty.closed = true;
        return empty;
      }();
      return Subscription2;
    }();
    exports2.Subscription = Subscription;
    exports2.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription2(value) {
      return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
    }
    exports2.isSubscription = isSubscription2;
    function execFinalizer(finalizer) {
      if (isFunction_1.isFunction(finalizer)) {
        finalizer();
      } else {
        finalizer.unsubscribe();
      }
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.config = void 0;
    exports2.config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: void 0,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutProvider = void 0;
    exports2.timeoutProvider = {
      setTimeout: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports2.timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
          return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout], __read(args)));
        }
        return setTimeout.apply(void 0, __spreadArray2([handler, timeout], __read(args)));
      },
      clearTimeout: function(handle) {
        var delegate = exports2.timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: void 0
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportUnhandledError = void 0;
    var config_1 = require_config();
    var timeoutProvider_1 = require_timeoutProvider();
    function reportUnhandledError(err) {
      timeoutProvider_1.timeoutProvider.setTimeout(function() {
        var onUnhandledError = config_1.config.onUnhandledError;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }
    exports2.reportUnhandledError = reportUnhandledError;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.noop = void 0;
    function noop() {
    }
    exports2.noop = noop;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNotification = exports2.nextNotification = exports2.errorNotification = exports2.COMPLETE_NOTIFICATION = void 0;
    exports2.COMPLETE_NOTIFICATION = function() {
      return createNotification("C", void 0, void 0);
    }();
    function errorNotification(error) {
      return createNotification("E", void 0, error);
    }
    exports2.errorNotification = errorNotification;
    function nextNotification(value) {
      return createNotification("N", value, void 0);
    }
    exports2.nextNotification = nextNotification;
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error
      };
    }
    exports2.createNotification = createNotification;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.captureError = exports2.errorContext = void 0;
    var config_1 = require_config();
    var context = null;
    function errorContext(cb) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
          context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
          var _a2 = context, errorThrown = _a2.errorThrown, error = _a2.error;
          context = null;
          if (errorThrown) {
            throw error;
          }
        }
      } else {
        cb();
      }
    }
    exports2.errorContext = errorContext;
    function captureError(err) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
      }
    }
    exports2.captureError = captureError;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EMPTY_OBSERVER = exports2.SafeSubscriber = exports2.Subscriber = void 0;
    var isFunction_1 = require_isFunction();
    var Subscription_1 = require_Subscription();
    var config_1 = require_config();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var noop_1 = require_noop();
    var NotificationFactories_1 = require_NotificationFactories();
    var timeoutProvider_1 = require_timeoutProvider();
    var errorContext_1 = require_errorContext();
    var Subscriber = function(_super) {
      __extends2(Subscriber2, _super);
      function Subscriber2(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
          _this.destination = destination;
          if (Subscription_1.isSubscription(destination)) {
            destination.add(_this);
          }
        } else {
          _this.destination = exports2.EMPTY_OBSERVER;
        }
        return _this;
      }
      Subscriber2.create = function(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      };
      Subscriber2.prototype.next = function(value) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
        } else {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (this.isStopped) {
          handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
          this.destination = null;
        }
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      };
      Subscriber2.prototype._complete = function() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports2.Subscriber = Subscriber;
    var _bind = Function.prototype.bind;
    function bind(fn, thisArg) {
      return _bind.call(fn, thisArg);
    }
    var ConsumerObserver = function() {
      function ConsumerObserver2(partialObserver) {
        this.partialObserver = partialObserver;
      }
      ConsumerObserver2.prototype.next = function(value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
          try {
            partialObserver.next(value);
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      ConsumerObserver2.prototype.error = function(err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
          try {
            partialObserver.error(err);
          } catch (error) {
            handleUnhandledError(error);
          }
        } else {
          handleUnhandledError(err);
        }
      };
      ConsumerObserver2.prototype.complete = function() {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
          try {
            partialObserver.complete();
          } catch (error) {
            handleUnhandledError(error);
          }
        }
      };
      return ConsumerObserver2;
    }();
    var SafeSubscriber = function(_super) {
      __extends2(SafeSubscriber2, _super);
      function SafeSubscriber2(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
          partialObserver = {
            next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
            error: error !== null && error !== void 0 ? error : void 0,
            complete: complete !== null && complete !== void 0 ? complete : void 0
          };
        } else {
          var context_1;
          if (_this && config_1.config.useDeprecatedNextContext) {
            context_1 = Object.create(observerOrNext);
            context_1.unsubscribe = function() {
              return _this.unsubscribe();
            };
            partialObserver = {
              next: observerOrNext.next && bind(observerOrNext.next, context_1),
              error: observerOrNext.error && bind(observerOrNext.error, context_1),
              complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
            };
          } else {
            partialObserver = observerOrNext;
          }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
      }
      return SafeSubscriber2;
    }(Subscriber);
    exports2.SafeSubscriber = SafeSubscriber;
    function handleUnhandledError(error) {
      if (config_1.config.useDeprecatedSynchronousErrorHandling) {
        errorContext_1.captureError(error);
      } else {
        reportUnhandledError_1.reportUnhandledError(error);
      }
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      var onStoppedNotification = config_1.config.onStoppedNotification;
      onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
        return onStoppedNotification(notification, subscriber);
      });
    }
    exports2.EMPTY_OBSERVER = {
      closed: true,
      next: noop_1.noop,
      error: defaultErrorHandler,
      complete: noop_1.noop
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observable = void 0;
    exports2.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.identity = void 0;
    function identity2(x) {
      return x;
    }
    exports2.identity = identity2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pipeFromArray = exports2.pipe = void 0;
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports2.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports2.pipeFromArray = pipeFromArray;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Observable = void 0;
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var isFunction_1 = require_isFunction();
    var errorContext_1 = require_errorContext();
    var Observable8 = function() {
      function Observable9(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable9.prototype.lift = function(operator) {
        var observable = new Observable9();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable9.prototype.subscribe = function(observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error, complete);
        errorContext_1.errorContext(function() {
          var _a2 = _this, operator = _a2.operator, source = _a2.source;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
        });
        return subscriber;
      };
      Observable9.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      };
      Observable9.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscriber.unsubscribe();
              }
            },
            error: reject,
            complete: resolve
          });
          _this.subscribe(subscriber);
        });
      };
      Observable9.prototype._subscribe = function(subscriber) {
        var _a2;
        return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
      };
      Observable9.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable9.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable9.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x) {
            return value = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable9.create = function(subscribe) {
        return new Observable9(subscribe);
      };
      return Observable9;
    }();
    exports2.Observable = Observable8;
    function getPromiseCtor(promiseCtor) {
      var _a2;
      return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
    }
    function isObserver(value) {
      return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
    }
    function isSubscriber(value) {
      return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operate = exports2.hasLift = void 0;
    var isFunction_1 = require_isFunction();
    function hasLift(source) {
      return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    exports2.hasLift = hasLift;
    function operate(init) {
      return function(source) {
        if (hasLift(source)) {
          return source.lift(function(liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError("Unable to lift unknown Observable type");
      };
    }
    exports2.operate = operate;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OperatorSubscriber = exports2.createOperatorSubscriber = void 0;
    var Subscriber_1 = require_Subscriber();
    function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
    }
    exports2.createOperatorSubscriber = createOperatorSubscriber;
    var OperatorSubscriber = function(_super) {
      __extends2(OperatorSubscriber2, _super);
      function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext ? function(value) {
          try {
            onNext(value);
          } catch (err) {
            destination.error(err);
          }
        } : _super.prototype._next;
        _this._error = onError ? function(err) {
          try {
            onError(err);
          } catch (err2) {
            destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._error;
        _this._complete = onComplete ? function() {
          try {
            onComplete();
          } catch (err) {
            destination.error(err);
          } finally {
            this.unsubscribe();
          }
        } : _super.prototype._complete;
        return _this;
      }
      OperatorSubscriber2.prototype.unsubscribe = function() {
        var _a2;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var closed_1 = this.closed;
          _super.prototype.unsubscribe.call(this);
          !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
        }
      };
      return OperatorSubscriber2;
    }(Subscriber_1.Subscriber);
    exports2.OperatorSubscriber = OperatorSubscriber;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.refCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function refCount() {
      return lift_1.operate(function(source, subscriber) {
        var connection = null;
        source._refCount++;
        var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
          if (!source || source._refCount <= 0 || 0 < --source._refCount) {
            connection = null;
            return;
          }
          var sharedConnection = source._connection;
          var conn = connection;
          connection = null;
          if (sharedConnection && (!conn || sharedConnection === conn)) {
            sharedConnection.unsubscribe();
          }
          subscriber.unsubscribe();
        });
        source.subscribe(refCounter);
        if (!refCounter.closed) {
          connection = source.connect();
        }
      });
    }
    exports2.refCount = refCount;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectableObservable = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var refCount_1 = require_refCount();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    var ConnectableObservable = function(_super) {
      __extends2(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._subject = null;
        _this._refCount = 0;
        _this._connection = null;
        if (lift_1.hasLift(source)) {
          _this.lift = source.lift;
        }
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype._teardown = function() {
        this._refCount = 0;
        var _connection = this._connection;
        this._subject = this._connection = null;
        _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
      };
      ConnectableObservable2.prototype.connect = function() {
        var _this = this;
        var connection = this._connection;
        if (!connection) {
          connection = this._connection = new Subscription_1.Subscription();
          var subject_1 = this.getSubject();
          connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
            _this._teardown();
            subject_1.complete();
          }, function(err) {
            _this._teardown();
            subject_1.error(err);
          }, function() {
            return _this._teardown();
          })));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription_1.Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount_1.refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable_1.Observable);
    exports2.ConnectableObservable = ConnectableObservable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.performanceTimestampProvider = void 0;
    exports2.performanceTimestampProvider = {
      now: function() {
        return (exports2.performanceTimestampProvider.delegate || performance).now();
      },
      delegate: void 0
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrameProvider = void 0;
    var Subscription_1 = require_Subscription();
    exports2.animationFrameProvider = {
      schedule: function(callback) {
        var request = requestAnimationFrame;
        var cancel = cancelAnimationFrame;
        var delegate = exports2.animationFrameProvider.delegate;
        if (delegate) {
          request = delegate.requestAnimationFrame;
          cancel = delegate.cancelAnimationFrame;
        }
        var handle = request(function(timestamp) {
          cancel = void 0;
          callback(timestamp);
        });
        return new Subscription_1.Subscription(function() {
          return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
        });
      },
      requestAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read(args)));
      },
      cancelAnimationFrame: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.animationFrameProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read(args)));
      },
      delegate: void 0
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrames = void 0;
    var Observable_1 = require_Observable();
    var performanceTimestampProvider_1 = require_performanceTimestampProvider();
    var animationFrameProvider_1 = require_animationFrameProvider();
    function animationFrames(timestampProvider) {
      return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
    }
    exports2.animationFrames = animationFrames;
    function animationFramesFactory(timestampProvider) {
      return new Observable_1.Observable(function(subscriber) {
        var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
        var start = provider.now();
        var id = 0;
        var run = function() {
          if (!subscriber.closed) {
            id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
              id = 0;
              var now = provider.now();
              subscriber.next({
                timestamp: timestampProvider ? now : timestamp,
                elapsed: now - start
              });
              run();
            });
          }
        };
        run();
        return function() {
          if (id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          }
        };
      });
    }
    var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ObjectUnsubscribedError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
      return function ObjectUnsubscribedErrorImpl() {
        _super(this);
        this.name = "ObjectUnsubscribedError";
        this.message = "object unsubscribed";
      };
    });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Subject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnonymousSubject = exports2.Subject = void 0;
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var arrRemove_1 = require_arrRemove();
    var errorContext_1 = require_errorContext();
    var Subject20 = function(_super) {
      __extends2(Subject21, _super);
      function Subject21() {
        var _this = _super.call(this) || this;
        _this.closed = false;
        _this.currentObservers = null;
        _this.observers = [];
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject21.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject21.prototype._throwIfClosed = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
      };
      Subject21.prototype.next = function(value) {
        var _this = this;
        errorContext_1.errorContext(function() {
          var e_1, _a2;
          _this._throwIfClosed();
          if (!_this.isStopped) {
            if (!_this.currentObservers) {
              _this.currentObservers = Array.from(_this.observers);
            }
            try {
              for (var _b2 = __values(_this.currentObservers), _c = _b2.next(); !_c.done; _c = _b2.next()) {
                var observer = _c.value;
                observer.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a2 = _b2.return)) _a2.call(_b2);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }
        });
      };
      Subject21.prototype.error = function(err) {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.hasError = _this.isStopped = true;
            _this.thrownError = err;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      };
      Subject21.prototype.complete = function() {
        var _this = this;
        errorContext_1.errorContext(function() {
          _this._throwIfClosed();
          if (!_this.isStopped) {
            _this.isStopped = true;
            var observers = _this.observers;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      };
      Subject21.prototype.unsubscribe = function() {
        this.isStopped = this.closed = true;
        this.observers = this.currentObservers = null;
      };
      Object.defineProperty(Subject21.prototype, "observed", {
        get: function() {
          var _a2;
          return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
        },
        enumerable: false,
        configurable: true
      });
      Subject21.prototype._trySubscribe = function(subscriber) {
        this._throwIfClosed();
        return _super.prototype._trySubscribe.call(this, subscriber);
      };
      Subject21.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      };
      Subject21.prototype._innerSubscribe = function(subscriber) {
        var _this = this;
        var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
        if (hasError || isStopped) {
          return Subscription_1.EMPTY_SUBSCRIPTION;
        }
        this.currentObservers = null;
        observers.push(subscriber);
        return new Subscription_1.Subscription(function() {
          _this.currentObservers = null;
          arrRemove_1.arrRemove(observers, subscriber);
        });
      };
      Subject21.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      };
      Subject21.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject21.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject21;
    }(Observable_1.Observable);
    exports2.Subject = Subject20;
    var AnonymousSubject = function(_super) {
      __extends2(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var _a2, _b2;
        (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, value);
      };
      AnonymousSubject2.prototype.error = function(err) {
        var _a2, _b2;
        (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, err);
      };
      AnonymousSubject2.prototype.complete = function() {
        var _a2, _b2;
        (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var _a2, _b2;
        return (_b2 = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b2 !== void 0 ? _b2 : Subscription_1.EMPTY_SUBSCRIPTION;
      };
      return AnonymousSubject2;
    }(Subject20);
    exports2.AnonymousSubject = AnonymousSubject;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BehaviorSubject = void 0;
    var Subject_1 = require_Subject();
    var BehaviorSubject19 = function(_super) {
      __extends2(BehaviorSubject20, _super);
      function BehaviorSubject20(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject20.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: false,
        configurable: true
      });
      BehaviorSubject20.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        !subscription.closed && subscriber.next(this._value);
        return subscription;
      };
      BehaviorSubject20.prototype.getValue = function() {
        var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
        if (hasError) {
          throw thrownError;
        }
        this._throwIfClosed();
        return _value;
      };
      BehaviorSubject20.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject20;
    }(Subject_1.Subject);
    exports2.BehaviorSubject = BehaviorSubject19;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dateTimestampProvider = void 0;
    exports2.dateTimestampProvider = {
      now: function() {
        return (exports2.dateTimestampProvider.delegate || Date).now();
      },
      delegate: void 0
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReplaySubject = void 0;
    var Subject_1 = require_Subject();
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var ReplaySubject2 = function(_super) {
      __extends2(ReplaySubject3, _super);
      function ReplaySubject3(_bufferSize, _windowTime, _timestampProvider) {
        if (_bufferSize === void 0) {
          _bufferSize = Infinity;
        }
        if (_windowTime === void 0) {
          _windowTime = Infinity;
        }
        if (_timestampProvider === void 0) {
          _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        var _this = _super.call(this) || this;
        _this._bufferSize = _bufferSize;
        _this._windowTime = _windowTime;
        _this._timestampProvider = _timestampProvider;
        _this._buffer = [];
        _this._infiniteTimeWindow = true;
        _this._infiniteTimeWindow = _windowTime === Infinity;
        _this._bufferSize = Math.max(1, _bufferSize);
        _this._windowTime = Math.max(1, _windowTime);
        return _this;
      }
      ReplaySubject3.prototype.next = function(value) {
        var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
        if (!isStopped) {
          _buffer.push(value);
          !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
        }
        this._trimBuffer();
        _super.prototype.next.call(this, value);
      };
      ReplaySubject3.prototype._subscribe = function(subscriber) {
        this._throwIfClosed();
        this._trimBuffer();
        var subscription = this._innerSubscribe(subscriber);
        var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
        var copy = _buffer.slice();
        for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
          subscriber.next(copy[i]);
        }
        this._checkFinalizedStatuses(subscriber);
        return subscription;
      };
      ReplaySubject3.prototype._trimBuffer = function() {
        var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
        var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
        _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
        if (!_infiniteTimeWindow) {
          var now = _timestampProvider.now();
          var last = 0;
          for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
            last = i;
          }
          last && _buffer.splice(0, last + 1);
        }
      };
      return ReplaySubject3;
    }(Subject_1.Subject);
    exports2.ReplaySubject = ReplaySubject2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncSubject = void 0;
    var Subject_1 = require_Subject();
    var AsyncSubject = function(_super) {
      __extends2(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._value = null;
        _this._hasValue = false;
        _this._isComplete = false;
        return _this;
      }
      AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
        var _a2 = this, hasError = _a2.hasError, _hasValue = _a2._hasValue, _value = _a2._value, thrownError = _a2.thrownError, isStopped = _a2.isStopped, _isComplete = _a2._isComplete;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      };
      AsyncSubject2.prototype.complete = function() {
        var _a2 = this, _hasValue = _a2._hasValue, _value = _a2._value, _isComplete = _a2._isComplete;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && _super.prototype.next.call(this, _value);
          _super.prototype.complete.call(this);
        }
      };
      return AsyncSubject2;
    }(Subject_1.Subject);
    exports2.AsyncSubject = AsyncSubject;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Action = void 0;
    var Subscription_1 = require_Subscription();
    var Action = function(_super) {
      __extends2(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription_1.Subscription);
    exports2.Action = Action;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.intervalProvider = void 0;
    exports2.intervalProvider = {
      setInterval: function(handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var delegate = exports2.intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
          return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout], __read(args)));
        }
        return setInterval.apply(void 0, __spreadArray2([handler, timeout], __read(args)));
      },
      clearInterval: function(handle) {
        var delegate = exports2.intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: void 0
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncAction = void 0;
    var Action_1 = require_Action();
    var intervalProvider_1 = require_intervalProvider();
    var arrRemove_1 = require_arrRemove();
    var AsyncAction = function(_super) {
      __extends2(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state, delay) {
        var _a2;
        if (delay === void 0) {
          delay = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a2 = this.id) !== null && _a2 !== void 0 ? _a2 : this.requestAsyncId(scheduler, this.id, delay);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && this.delay === delay && this.pending === false) {
          return id;
        }
        if (id != null) {
          intervalProvider_1.intervalProvider.clearInterval(id);
        }
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state, delay) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state, _delay) {
        var errored = false;
        var errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error("Scheduled action threw falsy error");
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype.unsubscribe = function() {
        if (!this.closed) {
          var _a2 = this, id = _a2.id, scheduler = _a2.scheduler;
          var actions = scheduler.actions;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove_1.arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          _super.prototype.unsubscribe.call(this);
        }
      };
      return AsyncAction2;
    }(Action_1.Action);
    exports2.AsyncAction = AsyncAction;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestTools = exports2.Immediate = void 0;
    var nextHandle = 1;
    var resolved;
    var activeHandles = {};
    function findAndClearHandle(handle) {
      if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
      }
      return false;
    }
    exports2.Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        if (!resolved) {
          resolved = Promise.resolve();
        }
        resolved.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
    exports2.TestTools = {
      pending: function() {
        return Object.keys(activeHandles).length;
      }
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.immediateProvider = void 0;
    var Immediate_1 = require_Immediate();
    var setImmediate = Immediate_1.Immediate.setImmediate;
    var clearImmediate = Immediate_1.Immediate.clearImmediate;
    exports2.immediateProvider = {
      setImmediate: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray2([], __read(args)));
      },
      clearImmediate: function(handle) {
        var delegate = exports2.immediateProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
      },
      delegate: void 0
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsapAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var immediateProvider_1 = require_immediateProvider();
    var AsapAction = function(_super) {
      __extends2(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a2;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id) {
          immediateProvider_1.immediateProvider.clearImmediate(id);
          if (scheduler._scheduled === id) {
            scheduler._scheduled = void 0;
          }
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.AsapAction = AsapAction;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Scheduler = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var Scheduler = function() {
      function Scheduler2(schedulerActionCtor, now) {
        if (now === void 0) {
          now = Scheduler2.now;
        }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      Scheduler2.prototype.schedule = function(work, delay, state) {
        if (delay === void 0) {
          delay = 0;
        }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      };
      Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
      return Scheduler2;
    }();
    exports2.Scheduler = Scheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncScheduler = void 0;
    var Scheduler_1 = require_Scheduler();
    var AsyncScheduler = function(_super) {
      __extends2(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now) {
        if (now === void 0) {
          now = Scheduler_1.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
      }
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this._active) {
          actions.push(action);
          return;
        }
        var error;
        this._active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this._active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler_1.Scheduler);
    exports2.AsyncScheduler = AsyncScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsapScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AsapScheduler = function(_super) {
      __extends2(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.AsapScheduler = AsapScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.asap = exports2.asapScheduler = void 0;
    var AsapAction_1 = require_AsapAction();
    var AsapScheduler_1 = require_AsapScheduler();
    exports2.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
    exports2.asap = exports2.asapScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.async = exports2.asyncScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var AsyncScheduler_1 = require_AsyncScheduler();
    exports2.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
    exports2.async = exports2.asyncScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueueAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var QueueAction = function(_super) {
      __extends2(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay > 0) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state, delay) {
        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null && delay > 0 || delay == null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.flush(this);
        return 0;
      };
      return QueueAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.QueueAction = QueueAction;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueueScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var QueueScheduler = function(_super) {
      __extends2(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.QueueScheduler = QueueScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.queue = exports2.queueScheduler = void 0;
    var QueueAction_1 = require_QueueAction();
    var QueueScheduler_1 = require_QueueScheduler();
    exports2.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
    exports2.queue = exports2.queueScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnimationFrameAction = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var animationFrameProvider_1 = require_animationFrameProvider();
    var AnimationFrameAction = function(_super) {
      __extends2(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (delay !== null && delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
          return scheduler.flush(void 0);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        var _a2;
        if (delay === void 0) {
          delay = 0;
        }
        if (delay != null ? delay > 0 : this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        var actions = scheduler.actions;
        if (id != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
          scheduler._scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.AnimationFrameAction = AnimationFrameAction;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnimationFrameScheduler = void 0;
    var AsyncScheduler_1 = require_AsyncScheduler();
    var AnimationFrameScheduler = function(_super) {
      __extends2(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this._active = true;
        var flushId = this._scheduled;
        this._scheduled = void 0;
        var actions = this.actions;
        var error;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while ((action = actions[0]) && action.id === flushId && actions.shift());
        this._active = false;
        if (error) {
          while ((action = actions[0]) && action.id === flushId && actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.AnimationFrameScheduler = AnimationFrameScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.animationFrame = exports2.animationFrameScheduler = void 0;
    var AnimationFrameAction_1 = require_AnimationFrameAction();
    var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
    exports2.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
    exports2.animationFrame = exports2.animationFrameScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VirtualAction = exports2.VirtualTimeScheduler = void 0;
    var AsyncAction_1 = require_AsyncAction();
    var Subscription_1 = require_Subscription();
    var AsyncScheduler_1 = require_AsyncScheduler();
    var VirtualTimeScheduler = function(_super) {
      __extends2(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
        if (schedulerActionCtor === void 0) {
          schedulerActionCtor = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Infinity;
        }
        var _this = _super.call(this, schedulerActionCtor, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
        var error;
        var action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler_1.AsyncScheduler);
    exports2.VirtualTimeScheduler = VirtualTimeScheduler;
    var VirtualAction = function(_super) {
      __extends2(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        if (Number.isFinite(delay)) {
          if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.active = false;
          var action = new VirtualAction2(this.scheduler, this.work);
          this.add(action);
          return action.schedule(state, delay);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return 1;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state, delay) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state, delay);
        }
      };
      VirtualAction2.sortActions = function(a2, b) {
        if (a2.delay === b.delay) {
          if (a2.index === b.index) {
            return 0;
          } else if (a2.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a2.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction_1.AsyncAction);
    exports2.VirtualAction = VirtualAction;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.empty = exports2.EMPTY = void 0;
    var Observable_1 = require_Observable();
    exports2.EMPTY = new Observable_1.Observable(function(subscriber) {
      return subscriber.complete();
    });
    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : exports2.EMPTY;
    }
    exports2.empty = empty;
    function emptyScheduled(scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        return scheduler.schedule(function() {
          return subscriber.complete();
        });
      });
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isScheduler = void 0;
    var isFunction_1 = require_isFunction();
    function isScheduler(value) {
      return value && isFunction_1.isFunction(value.schedule);
    }
    exports2.isScheduler = isScheduler;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/args.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.popNumber = exports2.popScheduler = exports2.popResultSelector = void 0;
    var isFunction_1 = require_isFunction();
    var isScheduler_1 = require_isScheduler();
    function last(arr) {
      return arr[arr.length - 1];
    }
    function popResultSelector(args) {
      return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
    }
    exports2.popResultSelector = popResultSelector;
    function popScheduler(args) {
      return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
    }
    exports2.popScheduler = popScheduler;
    function popNumber(args, defaultValue) {
      return typeof last(args) === "number" ? args.pop() : defaultValue;
    }
    exports2.popNumber = popNumber;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isArrayLike = void 0;
    exports2.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromise = void 0;
    var isFunction_1 = require_isFunction();
    function isPromise(value) {
      return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
    }
    exports2.isPromise = isPromise;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isInteropObservable = void 0;
    var observable_1 = require_observable();
    var isFunction_1 = require_isFunction();
    function isInteropObservable(input) {
      return isFunction_1.isFunction(input[observable_1.observable]);
    }
    exports2.isInteropObservable = isInteropObservable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAsyncIterable = void 0;
    var isFunction_1 = require_isFunction();
    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createInvalidObservableTypeError = void 0;
    function createInvalidObservableTypeError(input) {
      return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
    }
    exports2.createInvalidObservableTypeError = createInvalidObservableTypeError;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iterator = exports2.getSymbolIterator = void 0;
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports2.getSymbolIterator = getSymbolIterator;
    exports2.iterator = getSymbolIterator();
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isIterable = void 0;
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    function isIterable(input) {
      return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
    }
    exports2.isIterable = isIterable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports2) {
    "use strict";
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __await = exports2 && exports2.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n]) i[n] = function(v) {
          return new Promise(function(a2, b) {
            q.push([n, v, a2, b]) > 1 || resume(n, v);
          });
        };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isReadableStreamLike = exports2.readableStreamLikeToAsyncGenerator = void 0;
    var isFunction_1 = require_isFunction();
    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
        var reader, _a2, value, done;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              reader = readableStream.getReader();
              _b2.label = 1;
            case 1:
              _b2.trys.push([1, , 9, 10]);
              _b2.label = 2;
            case 2:
              if (false) return [3, 8];
              return [4, __await(reader.read())];
            case 3:
              _a2 = _b2.sent(), value = _a2.value, done = _a2.done;
              if (!done) return [3, 5];
              return [4, __await(void 0)];
            case 4:
              return [2, _b2.sent()];
            case 5:
              return [4, __await(value)];
            case 6:
              return [4, _b2.sent()];
            case 7:
              _b2.sent();
              return [3, 2];
            case 8:
              return [3, 10];
            case 9:
              reader.releaseLock();
              return [7];
            case 10:
              return [2];
          }
        });
      });
    }
    exports2.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
    function isReadableStreamLike(obj) {
      return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }
    exports2.isReadableStreamLike = isReadableStreamLike;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromReadableStreamLike = exports2.fromAsyncIterable = exports2.fromIterable = exports2.fromPromise = exports2.fromArrayLike = exports2.fromInteropObservable = exports2.innerFrom = void 0;
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var Observable_1 = require_Observable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isIterable_1 = require_isIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var isFunction_1 = require_isFunction();
    var reportUnhandledError_1 = require_reportUnhandledError();
    var observable_1 = require_observable();
    function innerFrom(input) {
      if (input instanceof Observable_1.Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise_1.isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable_1.isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports2.innerFrom = innerFrom;
    function fromInteropObservable(obj) {
      return new Observable_1.Observable(function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (isFunction_1.isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError("Provided object does not correctly implement Symbol.observable");
      });
    }
    exports2.fromInteropObservable = fromInteropObservable;
    function fromArrayLike(array) {
      return new Observable_1.Observable(function(subscriber) {
        for (var i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    exports2.fromArrayLike = fromArrayLike;
    function fromPromise(promise) {
      return new Observable_1.Observable(function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, reportUnhandledError_1.reportUnhandledError);
      });
    }
    exports2.fromPromise = fromPromise;
    function fromIterable(iterable) {
      return new Observable_1.Observable(function(subscriber) {
        var e_1, _a2;
        try {
          for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
            var value = iterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return)) _a2.call(iterable_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }
    exports2.fromIterable = fromIterable;
    function fromAsyncIterable(asyncIterable) {
      return new Observable_1.Observable(function(subscriber) {
        process3(asyncIterable, subscriber).catch(function(err) {
          return subscriber.error(err);
        });
      });
    }
    exports2.fromAsyncIterable = fromAsyncIterable;
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
    }
    exports2.fromReadableStreamLike = fromReadableStreamLike;
    function process3(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_2, _a2;
      return __awaiter(this, void 0, void 0, function() {
        var value, e_2_1;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              _b2.trys.push([0, 5, 6, 11]);
              asyncIterable_1 = __asyncValues(asyncIterable);
              _b2.label = 1;
            case 1:
              return [4, asyncIterable_1.next()];
            case 2:
              if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done)) return [3, 4];
              value = asyncIterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return [2];
              }
              _b2.label = 3;
            case 3:
              return [3, 1];
            case 4:
              return [3, 11];
            case 5:
              e_2_1 = _b2.sent();
              e_2 = { error: e_2_1 };
              return [3, 11];
            case 6:
              _b2.trys.push([6, , 9, 10]);
              if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return))) return [3, 8];
              return [4, _a2.call(asyncIterable_1)];
            case 7:
              _b2.sent();
              _b2.label = 8;
            case 8:
              return [3, 10];
            case 9:
              if (e_2) throw e_2.error;
              return [7];
            case 10:
              return [7];
            case 11:
              subscriber.complete();
              return [2];
          }
        });
      });
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.executeSchedule = void 0;
    function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
      if (delay === void 0) {
        delay = 0;
      }
      if (repeat === void 0) {
        repeat = false;
      }
      var scheduleSubscription = scheduler.schedule(function() {
        work();
        if (repeat) {
          parentSubscription.add(this.schedule(null, delay));
        } else {
          this.unsubscribe();
        }
      }, delay);
      parentSubscription.add(scheduleSubscription);
      if (!repeat) {
        return scheduleSubscription;
      }
    }
    exports2.executeSchedule = executeSchedule;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeOn = void 0;
    var executeSchedule_1 = require_executeSchedule();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function observeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.next(value);
          }, delay);
        }, function() {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.complete();
          }, delay);
        }, function(err) {
          return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            return subscriber.error(err);
          }, delay);
        }));
      });
    }
    exports2.observeOn = observeOn;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.subscribeOn = void 0;
    var lift_1 = require_lift();
    function subscribeOn(scheduler, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return lift_1.operate(function(source, subscriber) {
        subscriber.add(scheduler.schedule(function() {
          return source.subscribe(subscriber);
        }, delay));
      });
    }
    exports2.subscribeOn = subscribeOn;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleObservable = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function scheduleObservable(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports2.scheduleObservable = scheduleObservable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.schedulePromise = void 0;
    var innerFrom_1 = require_innerFrom();
    var observeOn_1 = require_observeOn();
    var subscribeOn_1 = require_subscribeOn();
    function schedulePromise(input, scheduler) {
      return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
    }
    exports2.schedulePromise = schedulePromise;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleArray = void 0;
    var Observable_1 = require_Observable();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var i = 0;
        return scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
          } else {
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
              this.schedule();
            }
          }
        });
      });
    }
    exports2.scheduleArray = scheduleArray;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleIterable = void 0;
    var Observable_1 = require_Observable();
    var iterator_1 = require_iterator();
    var isFunction_1 = require_isFunction();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleIterable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var iterator;
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator = input[iterator_1.iterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var _a2;
            var value;
            var done;
            try {
              _a2 = iterator.next(), value = _a2.value, done = _a2.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value);
            }
          }, 0, true);
        });
        return function() {
          return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
        };
      });
    }
    exports2.scheduleIterable = scheduleIterable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleAsyncIterable = void 0;
    var Observable_1 = require_Observable();
    var executeSchedule_1 = require_executeSchedule();
    function scheduleAsyncIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var iterator = input[Symbol.asyncIterator]();
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator.next().then(function(result) {
              if (result.done) {
                subscriber.complete();
              } else {
                subscriber.next(result.value);
              }
            });
          }, 0, true);
        });
      });
    }
    exports2.scheduleAsyncIterable = scheduleAsyncIterable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduleReadableStreamLike = void 0;
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    function scheduleReadableStreamLike(input, scheduler) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
    }
    exports2.scheduleReadableStreamLike = scheduleReadableStreamLike;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scheduled = void 0;
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    var isAsyncIterable_1 = require_isAsyncIterable();
    var throwUnobservableError_1 = require_throwUnobservableError();
    var isReadableStreamLike_1 = require_isReadableStreamLike();
    var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        }
        if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        }
        if (isAsyncIterable_1.isAsyncIterable(input)) {
          return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
        }
        if (isIterable_1.isIterable(input)) {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
        if (isReadableStreamLike_1.isReadableStreamLike(input)) {
          return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
        }
      }
      throw throwUnobservableError_1.createInvalidObservableTypeError(input);
    }
    exports2.scheduled = scheduled;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.from = void 0;
    var scheduled_1 = require_scheduled();
    var innerFrom_1 = require_innerFrom();
    function from(input, scheduler) {
      return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
    }
    exports2.from = from;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.of = void 0;
    var args_1 = require_args();
    var from_1 = require_from();
    function of4() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return from_1.from(args, scheduler);
    }
    exports2.of = of4;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwError = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function throwError(errorOrErrorFactory, scheduler) {
      var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
        return errorOrErrorFactory;
      };
      var init = function(subscriber) {
        return subscriber.error(errorFactory());
      };
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        return scheduler.schedule(init, 0, subscriber);
      } : init);
    }
    exports2.throwError = throwError;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/Notification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observeNotification = exports2.Notification = exports2.NotificationKind = void 0;
    var empty_1 = require_empty();
    var of_1 = require_of();
    var throwError_1 = require_throwError();
    var isFunction_1 = require_isFunction();
    var NotificationKind;
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind = exports2.NotificationKind || (exports2.NotificationKind = {}));
    var Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        return observeNotification(this, observer);
      };
      Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
        var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
        return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        var _a2;
        return isFunction_1.isFunction((_a2 = nextOrObserver) === null || _a2 === void 0 ? void 0 : _a2.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
      };
      Notification2.prototype.toObservable = function() {
        var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
        var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
          return error;
        }) : kind === "C" ? empty_1.EMPTY : 0;
        if (!result) {
          throw new TypeError("Unexpected notification kind " + kind);
        }
        return result;
      };
      Notification2.createNext = function(value) {
        return new Notification2("N", value);
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      return Notification2;
    }();
    exports2.Notification = Notification;
    function observeNotification(notification, observer) {
      var _a2, _b2, _c;
      var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
      if (typeof kind !== "string") {
        throw new TypeError('Invalid notification, missing "kind"');
      }
      kind === "N" ? (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, value) : kind === "E" ? (_b2 = observer.error) === null || _b2 === void 0 ? void 0 : _b2.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
    }
    exports2.observeNotification = observeNotification;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObservable = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    function isObservable2(obj) {
      return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
    }
    exports2.isObservable = isObservable2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EmptyError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
      return function EmptyErrorImpl() {
        _super(this);
        this.name = "EmptyError";
        this.message = "no elements in sequence";
      };
    });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lastValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    function lastValueFrom(source, config2) {
      var hasConfig = typeof config2 === "object";
      return new Promise(function(resolve, reject) {
        var _hasValue = false;
        var _value;
        source.subscribe({
          next: function(value) {
            _value = value;
            _hasValue = true;
          },
          error: reject,
          complete: function() {
            if (_hasValue) {
              resolve(_value);
            } else if (hasConfig) {
              resolve(config2.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
      });
    }
    exports2.lastValueFrom = lastValueFrom;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.firstValueFrom = void 0;
    var EmptyError_1 = require_EmptyError();
    var Subscriber_1 = require_Subscriber();
    function firstValueFrom3(source, config2) {
      var hasConfig = typeof config2 === "object";
      return new Promise(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            resolve(value);
            subscriber.unsubscribe();
          },
          error: reject,
          complete: function() {
            if (hasConfig) {
              resolve(config2.defaultValue);
            } else {
              reject(new EmptyError_1.EmptyError());
            }
          }
        });
        source.subscribe(subscriber);
      });
    }
    exports2.firstValueFrom = firstValueFrom3;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArgumentOutOfRangeError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
      return function ArgumentOutOfRangeErrorImpl() {
        _super(this);
        this.name = "ArgumentOutOfRangeError";
        this.message = "argument out of range";
      };
    });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotFoundError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
      return function NotFoundErrorImpl(message) {
        _super(this);
        this.name = "NotFoundError";
        this.message = message;
      };
    });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SequenceError = void 0;
    var createErrorClass_1 = require_createErrorClass();
    exports2.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
      return function SequenceErrorImpl(message) {
        _super(this);
        this.name = "SequenceError";
        this.message = message;
      };
    });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidDate = void 0;
    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }
    exports2.isValidDate = isValidDate;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeout = exports2.TimeoutError = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var createErrorClass_1 = require_createErrorClass();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    exports2.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
      return function TimeoutErrorImpl(info) {
        if (info === void 0) {
          info = null;
        }
        _super(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        this.info = info;
      };
    });
    function timeout(config2, schedulerArg) {
      var _a2 = isDate_1.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a2.first, each = _a2.each, _b2 = _a2.with, _with = _b2 === void 0 ? timeoutErrorFactory : _b2, _c = _a2.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a2.meta, meta = _d === void 0 ? null : _d;
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return lift_1.operate(function(source, subscriber) {
        var originalSourceSubscription;
        var timerSubscription;
        var lastValue = null;
        var seen = 0;
        var startTimer = function(delay) {
          timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            try {
              originalSourceSubscription.unsubscribe();
              innerFrom_1.innerFrom(_with({
                meta,
                lastValue,
                seen
              })).subscribe(subscriber);
            } catch (err) {
              subscriber.error(err);
            }
          }, delay);
        };
        originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          seen++;
          subscriber.next(lastValue = value);
          each > 0 && startTimer(each);
        }, void 0, void 0, function() {
          if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
          }
          lastValue = null;
        }));
        !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
      });
    }
    exports2.timeout = timeout;
    function timeoutErrorFactory(info) {
      throw new exports2.TimeoutError(info);
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.map = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function map9(project, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(project.call(thisArg, value, index++));
        }));
      });
    }
    exports2.map = map9;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapOneOrManyArgs = void 0;
    var map_1 = require_map();
    var isArray2 = Array.isArray;
    function callOrApply(fn, args) {
      return isArray2(args) ? fn.apply(void 0, __spreadArray2([], __read(args))) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map_1.map(function(args) {
        return callOrApply(fn, args);
      });
    }
    exports2.mapOneOrManyArgs = mapOneOrManyArgs;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindCallbackInternals = void 0;
    var isScheduler_1 = require_isScheduler();
    var Observable_1 = require_Observable();
    var subscribeOn_1 = require_subscribeOn();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var observeOn_1 = require_observeOn();
    var AsyncSubject_1 = require_AsyncSubject();
    function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
          };
        }
      }
      if (scheduler) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
        };
      }
      return function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var subject = new AsyncSubject_1.AsyncSubject();
        var uninitialized = true;
        return new Observable_1.Observable(function(subscriber) {
          var subs = subject.subscribe(subscriber);
          if (uninitialized) {
            uninitialized = false;
            var isAsync_1 = false;
            var isComplete_1 = false;
            callbackFunc.apply(_this, __spreadArray2(__spreadArray2([], __read(args)), [
              function() {
                var results = [];
                for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                  results[_i2] = arguments[_i2];
                }
                if (isNodeStyle) {
                  var err = results.shift();
                  if (err != null) {
                    subject.error(err);
                    return;
                  }
                }
                subject.next(1 < results.length ? results : results[0]);
                isComplete_1 = true;
                if (isAsync_1) {
                  subject.complete();
                }
              }
            ]));
            if (isComplete_1) {
              subject.complete();
            }
            isAsync_1 = true;
          }
          return subs;
        });
      };
    }
    exports2.bindCallbackInternals = bindCallbackInternals;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
    }
    exports2.bindCallback = bindCallback;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bindNodeCallback = void 0;
    var bindCallbackInternals_1 = require_bindCallbackInternals();
    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
    }
    exports2.bindNodeCallback = bindNodeCallback;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argsArgArrayOrObject = void 0;
    var isArray2 = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectProto12 = Object.prototype;
    var getKeys = Object.keys;
    function argsArgArrayOrObject(args) {
      if (args.length === 1) {
        var first_1 = args[0];
        if (isArray2(first_1)) {
          return { args: first_1, keys: null };
        }
        if (isPOJO(first_1)) {
          var keys = getKeys(first_1);
          return {
            args: keys.map(function(key) {
              return first_1[key];
            }),
            keys
          };
        }
      }
      return { args, keys: null };
    }
    exports2.argsArgArrayOrObject = argsArgArrayOrObject;
    function isPOJO(obj) {
      return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto12;
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createObject = void 0;
    function createObject(keys, values) {
      return keys.reduce(function(result, key, i) {
        return result[key] = values[i], result;
      }, {});
    }
    exports2.createObject = createObject;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestInit = exports2.combineLatest = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var from_1 = require_from();
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var args_1 = require_args();
    var createObject_1 = require_createObject();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var executeSchedule_1 = require_executeSchedule();
    function combineLatest3() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var resultSelector = args_1.popResultSelector(args);
      var _a2 = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a2.args, keys = _a2.keys;
      if (observables.length === 0) {
        return from_1.from([], scheduler);
      }
      var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
        return createObject_1.createObject(keys, values);
      } : identity_1.identity));
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports2.combineLatest = combineLatest3;
    function combineLatestInit(observables, scheduler, valueTransform) {
      if (valueTransform === void 0) {
        valueTransform = identity_1.identity;
      }
      return function(subscriber) {
        maybeSchedule(scheduler, function() {
          var length = observables.length;
          var values = new Array(length);
          var active = length;
          var remainingFirstValues = length;
          var _loop_1 = function(i2) {
            maybeSchedule(scheduler, function() {
              var source = from_1.from(observables[i2], scheduler);
              var hasFirstValue = false;
              source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                values[i2] = value;
                if (!hasFirstValue) {
                  hasFirstValue = true;
                  remainingFirstValues--;
                }
                if (!remainingFirstValues) {
                  subscriber.next(valueTransform(values.slice()));
                }
              }, function() {
                if (!--active) {
                  subscriber.complete();
                }
              }));
            }, subscriber);
          };
          for (var i = 0; i < length; i++) {
            _loop_1(i);
          }
        }, subscriber);
      };
    }
    exports2.combineLatestInit = combineLatestInit;
    function maybeSchedule(scheduler, execute, subscription) {
      if (scheduler) {
        executeSchedule_1.executeSchedule(subscription, scheduler, execute);
      } else {
        execute();
      }
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeInternals = void 0;
    var innerFrom_1 = require_innerFrom();
    var executeSchedule_1 = require_executeSchedule();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
      var buffer = [];
      var active = 0;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      var outerNext = function(value) {
        return active < concurrent ? doInnerSub(value) : buffer.push(value);
      };
      var doInnerSub = function(value) {
        expand && subscriber.next(value);
        active++;
        var innerComplete = false;
        innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
          if (expand) {
            outerNext(innerValue);
          } else {
            subscriber.next(innerValue);
          }
        }, function() {
          innerComplete = true;
        }, void 0, function() {
          if (innerComplete) {
            try {
              active--;
              var _loop_1 = function() {
                var bufferedValue = buffer.shift();
                if (innerSubScheduler) {
                  executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                    return doInnerSub(bufferedValue);
                  });
                } else {
                  doInnerSub(bufferedValue);
                }
              };
              while (buffer.length && active < concurrent) {
                _loop_1();
              }
              checkComplete();
            } catch (err) {
              subscriber.error(err);
            }
          }
        }));
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
        isComplete = true;
        checkComplete();
      }));
      return function() {
        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
      };
    }
    exports2.mergeInternals = mergeInternals;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    var isFunction_1 = require_isFunction();
    function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap(function(a2, i) {
          return map_1.map(function(b, ii) {
            return resultSelector(a2, b, i, ii);
          })(innerFrom_1.innerFrom(project(a2, i)));
        }, concurrent);
      } else if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
      });
    }
    exports2.mergeMap = mergeMap;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeAll = void 0;
    var mergeMap_1 = require_mergeMap();
    var identity_1 = require_identity();
    function mergeAll(concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return mergeMap_1.mergeMap(identity_1.identity, concurrent);
    }
    exports2.mergeAll = mergeAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatAll = void 0;
    var mergeAll_1 = require_mergeAll();
    function concatAll() {
      return mergeAll_1.mergeAll(1);
    }
    exports2.concatAll = concatAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = void 0;
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
    }
    exports2.concat = concat;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defer = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    function defer(observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
      });
    }
    exports2.defer = defer;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connectable = void 0;
    var Subject_1 = require_Subject();
    var Observable_1 = require_Observable();
    var defer_1 = require_defer();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      },
      resetOnDisconnect: true
    };
    function connectable(source, config2) {
      if (config2 === void 0) {
        config2 = DEFAULT_CONFIG;
      }
      var connection = null;
      var connector = config2.connector, _a2 = config2.resetOnDisconnect, resetOnDisconnect = _a2 === void 0 ? true : _a2;
      var subject = connector();
      var result = new Observable_1.Observable(function(subscriber) {
        return subject.subscribe(subscriber);
      });
      result.connect = function() {
        if (!connection || connection.closed) {
          connection = defer_1.defer(function() {
            return source;
          }).subscribe(subject);
          if (resetOnDisconnect) {
            connection.add(function() {
              return subject = connector();
            });
          }
        }
        return connection;
      };
      return result;
    }
    exports2.connectable = connectable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.forkJoin = void 0;
    var Observable_1 = require_Observable();
    var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
    var innerFrom_1 = require_innerFrom();
    var args_1 = require_args();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var createObject_1 = require_createObject();
    function forkJoin() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var _a2 = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a2.args, keys = _a2.keys;
      var result = new Observable_1.Observable(function(subscriber) {
        var length = sources.length;
        if (!length) {
          subscriber.complete();
          return;
        }
        var values = new Array(length);
        var remainingCompletions = length;
        var remainingEmissions = length;
        var _loop_1 = function(sourceIndex2) {
          var hasValue = false;
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!hasValue) {
              hasValue = true;
              remainingEmissions--;
            }
            values[sourceIndex2] = value;
          }, function() {
            return remainingCompletions--;
          }, void 0, function() {
            if (!remainingCompletions || !hasValue) {
              if (!remainingEmissions) {
                subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
              }
              subscriber.complete();
            }
          }));
        };
        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
      });
      return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
    }
    exports2.forkJoin = forkJoin;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromEvent = void 0;
    var innerFrom_1 = require_innerFrom();
    var Observable_1 = require_Observable();
    var mergeMap_1 = require_mergeMap();
    var isArrayLike_1 = require_isArrayLike();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var nodeEventEmitterMethods = ["addListener", "removeListener"];
    var eventTargetMethods = ["addEventListener", "removeEventListener"];
    var jqueryMethods = ["on", "off"];
    function fromEvent(target, eventName, options, resultSelector) {
      if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = void 0;
      }
      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      var _a2 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler, options);
        };
      }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add2 = _a2[0], remove2 = _a2[1];
      if (!add2) {
        if (isArrayLike_1.isArrayLike(target)) {
          return mergeMap_1.mergeMap(function(subTarget) {
            return fromEvent(subTarget, eventName, options);
          })(innerFrom_1.innerFrom(target));
        }
      }
      if (!add2) {
        throw new TypeError("Invalid event target");
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return subscriber.next(1 < args.length ? args : args[0]);
        };
        add2(handler);
        return function() {
          return remove2(handler);
        };
      });
    }
    exports2.fromEvent = fromEvent;
    function toCommonHandlerRegistry(target, eventName) {
      return function(methodName) {
        return function(handler) {
          return target[methodName](eventName, handler);
        };
      };
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromEventPattern = void 0;
    var Observable_1 = require_Observable();
    var isFunction_1 = require_isFunction();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
      }
      return new Observable_1.Observable(function(subscriber) {
        var handler = function() {
          var e = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            e[_i] = arguments[_i];
          }
          return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue = addHandler(handler);
        return isFunction_1.isFunction(removeHandler) ? function() {
          return removeHandler(handler, retValue);
        } : void 0;
      });
    }
    exports2.fromEventPattern = fromEventPattern;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports2) {
    "use strict";
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generate = void 0;
    var identity_1 = require_identity();
    var isScheduler_1 = require_isScheduler();
    var defer_1 = require_defer();
    var scheduleIterable_1 = require_scheduleIterable();
    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
      var _a2, _b2;
      var resultSelector;
      var initialState;
      if (arguments.length === 1) {
        _a2 = initialStateOrOptions, initialState = _a2.initialState, condition = _a2.condition, iterate = _a2.iterate, _b2 = _a2.resultSelector, resultSelector = _b2 === void 0 ? identity_1.identity : _b2, scheduler = _a2.scheduler;
      } else {
        initialState = initialStateOrOptions;
        if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
          resultSelector = identity_1.identity;
          scheduler = resultSelectorOrScheduler;
        } else {
          resultSelector = resultSelectorOrScheduler;
        }
      }
      function gen() {
        var state;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              state = initialState;
              _a3.label = 1;
            case 1:
              if (!(!condition || condition(state))) return [3, 4];
              return [4, resultSelector(state)];
            case 2:
              _a3.sent();
              _a3.label = 3;
            case 3:
              state = iterate(state);
              return [3, 1];
            case 4:
              return [2];
          }
        });
      }
      return defer_1.defer(scheduler ? function() {
        return scheduleIterable_1.scheduleIterable(gen(), scheduler);
      } : gen);
    }
    exports2.generate = generate;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.iif = void 0;
    var defer_1 = require_defer();
    function iif(condition, trueResult, falseResult) {
      return defer_1.defer(function() {
        return condition() ? trueResult : falseResult;
      });
    }
    exports2.iif = iif;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timer = void 0;
    var Observable_1 = require_Observable();
    var async_1 = require_async();
    var isScheduler_1 = require_isScheduler();
    var isDate_1 = require_isDate();
    function timer(dueTime, intervalOrScheduler, scheduler) {
      if (dueTime === void 0) {
        dueTime = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.async;
      }
      var intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler_1.isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable_1.Observable(function(subscriber) {
        var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        var n = 0;
        return scheduler.schedule(function() {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(void 0, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }
    exports2.timer = timer;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = void 0;
    var async_1 = require_async();
    var timer_1 = require_timer();
    function interval(period, scheduler) {
      if (period === void 0) {
        period = 0;
      }
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      if (period < 0) {
        period = 0;
      }
      return timer_1.timer(period, period, scheduler);
    }
    exports2.interval = interval;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var mergeAll_1 = require_mergeAll();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge5() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      var sources = args;
      return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
    }
    exports2.merge = merge5;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.never = exports2.NEVER = void 0;
    var Observable_1 = require_Observable();
    var noop_1 = require_noop();
    exports2.NEVER = new Observable_1.Observable(noop_1.noop);
    function never() {
      return exports2.NEVER;
    }
    exports2.never = never;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argsOrArgArray = void 0;
    var isArray2 = Array.isArray;
    function argsOrArgArray(args) {
      return args.length === 1 && isArray2(args[0]) ? args[0] : args;
    }
    exports2.argsOrArgArray = argsOrArgArray;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onErrorResumeNext = void 0;
    var Observable_1 = require_Observable();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function onErrorResumeNext() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return new Observable_1.Observable(function(subscriber) {
        var sourceIndex = 0;
        var subscribeNext = function() {
          if (sourceIndex < nextSources.length) {
            var nextSource = void 0;
            try {
              nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
            } catch (err) {
              subscribeNext();
              return;
            }
            var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
            nextSource.subscribe(innerSubscriber);
            innerSubscriber.add(subscribeNext);
          } else {
            subscriber.complete();
          }
        };
        subscribeNext();
      });
    }
    exports2.onErrorResumeNext = onErrorResumeNext;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pairs = void 0;
    var from_1 = require_from();
    function pairs(obj, scheduler) {
      return from_1.from(Object.entries(obj), scheduler);
    }
    exports2.pairs = pairs;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/util/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.not = void 0;
    function not(pred, thisArg) {
      return function(value, index) {
        return !pred.call(thisArg, value, index);
      };
    }
    exports2.not = not;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filter = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function filter8(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return predicate.call(thisArg, value, index++) && subscriber.next(value);
        }));
      });
    }
    exports2.filter = filter8;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    var innerFrom_1 = require_innerFrom();
    function partition(source, predicate, thisArg) {
      return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
    }
    exports2.partition = partition;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raceInit = exports2.race = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function race() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      sources = argsOrArgArray_1.argsOrArgArray(sources);
      return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
    }
    exports2.race = race;
    function raceInit(sources) {
      return function(subscriber) {
        var subscriptions = [];
        var _loop_1 = function(i2) {
          subscriptions.push(innerFrom_1.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (subscriptions) {
              for (var s = 0; s < subscriptions.length; s++) {
                s !== i2 && subscriptions[s].unsubscribe();
              }
              subscriptions = null;
            }
            subscriber.next(value);
          })));
        };
        for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
          _loop_1(i);
        }
      };
    }
    exports2.raceInit = raceInit;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.range = void 0;
    var Observable_1 = require_Observable();
    var empty_1 = require_empty();
    function range(start, count, scheduler) {
      if (count == null) {
        count = start;
        start = 0;
      }
      if (count <= 0) {
        return empty_1.EMPTY;
      }
      var end = count + start;
      return new Observable_1.Observable(scheduler ? function(subscriber) {
        var n = start;
        return scheduler.schedule(function() {
          if (n < end) {
            subscriber.next(n++);
            this.schedule();
          } else {
            subscriber.complete();
          }
        });
      } : function(subscriber) {
        var n = start;
        while (n < end && !subscriber.closed) {
          subscriber.next(n++);
        }
        subscriber.complete();
      });
    }
    exports2.range = range;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.using = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var empty_1 = require_empty();
    function using(resourceFactory, observableFactory) {
      return new Observable_1.Observable(function(subscriber) {
        var resource = resourceFactory();
        var result = observableFactory(resource);
        var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
        source.subscribe(subscriber);
        return function() {
          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    }
    exports2.using = using;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zip = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var empty_1 = require_empty();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var args_1 = require_args();
    function zip() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      var sources = argsOrArgArray_1.argsOrArgArray(args);
      return sources.length ? new Observable_1.Observable(function(subscriber) {
        var buffers = sources.map(function() {
          return [];
        });
        var completed = sources.map(function() {
          return false;
        });
        subscriber.add(function() {
          buffers = completed = null;
        });
        var _loop_1 = function(sourceIndex2) {
          innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffers[sourceIndex2].push(value);
            if (buffers.every(function(buffer) {
              return buffer.length;
            })) {
              var result = buffers.map(function(buffer) {
                return buffer.shift();
              });
              subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read(result))) : result);
              if (buffers.some(function(buffer, i) {
                return !buffer.length && completed[i];
              })) {
                subscriber.complete();
              }
            }
          }, function() {
            completed[sourceIndex2] = true;
            !buffers[sourceIndex2].length && subscriber.complete();
          }));
        };
        for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
          _loop_1(sourceIndex);
        }
        return function() {
          buffers = completed = null;
        };
      }) : empty_1.EMPTY;
    }
    exports2.zip = zip;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.audit = void 0;
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function audit(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var isComplete = false;
        var endDuration = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
          isComplete && subscriber.complete();
        };
        var cleanupDuration = function() {
          durationSubscriber = null;
          isComplete && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
          if (!durationSubscriber) {
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
          }
        }, function() {
          isComplete = true;
          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
        }));
      });
    }
    exports2.audit = audit;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.auditTime = void 0;
    var async_1 = require_async();
    var audit_1 = require_audit();
    var timer_1 = require_timer();
    function auditTime(duration, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return audit_1.audit(function() {
        return timer_1.timer(duration, scheduler);
      });
    }
    exports2.auditTime = auditTime;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buffer = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function buffer(closingNotifier) {
      return lift_1.operate(function(source, subscriber) {
        var currentBuffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return currentBuffer.push(value);
        }, function() {
          subscriber.next(currentBuffer);
          subscriber.complete();
        }));
        innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          var b = currentBuffer;
          currentBuffer = [];
          subscriber.next(b);
        }, noop_1.noop));
        return function() {
          currentBuffer = null;
        };
      });
    }
    exports2.buffer = buffer;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferCount = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    function bufferCount(bufferSize, startBufferEvery) {
      if (startBufferEvery === void 0) {
        startBufferEvery = null;
      }
      startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        var count = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2, e_2, _b2;
          var toEmit = null;
          if (count++ % startBufferEvery === 0) {
            buffers.push([]);
          }
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
              if (bufferSize <= buffer.length) {
                toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                toEmit.push(buffer);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a2 = buffers_1.return)) _a2.call(buffers_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (toEmit) {
            try {
              for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                var buffer = toEmit_1_1.value;
                arrRemove_1.arrRemove(buffers, buffer);
                subscriber.next(buffer);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (toEmit_1_1 && !toEmit_1_1.done && (_b2 = toEmit_1.return)) _b2.call(toEmit_1);
              } finally {
                if (e_2) throw e_2.error;
              }
            }
          }
        }, function() {
          var e_3, _a2;
          try {
            for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
              var buffer = buffers_2_1.value;
              subscriber.next(buffer);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (buffers_2_1 && !buffers_2_1.done && (_a2 = buffers_2.return)) _a2.call(buffers_2);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffers = null;
        }));
      });
    }
    exports2.bufferCount = bufferCount;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferTime = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var async_1 = require_async();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function bufferTime(bufferTimeSpan) {
      var _a2, _b2;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a2 = args_1.popScheduler(otherArgs)) !== null && _a2 !== void 0 ? _a2 : async_1.asyncScheduler;
      var bufferCreationInterval = (_b2 = otherArgs[0]) !== null && _b2 !== void 0 ? _b2 : null;
      var maxBufferSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var bufferRecords = [];
        var restartOnEmit = false;
        var emit = function(record) {
          var buffer = record.buffer, subs = record.subs;
          subs.unsubscribe();
          arrRemove_1.arrRemove(bufferRecords, record);
          subscriber.next(buffer);
          restartOnEmit && startBuffer();
        };
        var startBuffer = function() {
          if (bufferRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var buffer = [];
            var record_1 = {
              buffer,
              subs
            };
            bufferRecords.push(record_1);
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return emit(record_1);
            }, bufferTimeSpan);
          }
        };
        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
        } else {
          restartOnEmit = true;
        }
        startBuffer();
        var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a3;
          var recordsCopy = bufferRecords.slice();
          try {
            for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
              var record = recordsCopy_1_1.value;
              var buffer = record.buffer;
              buffer.push(value);
              maxBufferSize <= buffer.length && emit(record);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a3 = recordsCopy_1.return)) _a3.call(recordsCopy_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
            subscriber.next(bufferRecords.shift().buffer);
          }
          bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
          subscriber.complete();
          subscriber.unsubscribe();
        }, void 0, function() {
          return bufferRecords = null;
        });
        source.subscribe(bufferTimeSubscriber);
      });
    }
    exports2.bufferTime = bufferTime;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferToggle = void 0;
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function bufferToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffers = [];
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var buffer = [];
          buffers.push(buffer);
          var closingSubscription = new Subscription_1.Subscription();
          var emitBuffer = function() {
            arrRemove_1.arrRemove(buffers, buffer);
            subscriber.next(buffer);
            closingSubscription.unsubscribe();
          };
          closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          try {
            for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
              var buffer = buffers_1_1.value;
              buffer.push(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffers_1_1 && !buffers_1_1.done && (_a2 = buffers_1.return)) _a2.call(buffers_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (buffers.length > 0) {
            subscriber.next(buffers.shift());
          }
          subscriber.complete();
        }));
      });
    }
    exports2.bufferToggle = bufferToggle;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferWhen = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function bufferWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var buffer = null;
        var closingSubscriber = null;
        var openBuffer = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          var b = buffer;
          buffer = [];
          b && subscriber.next(b);
          innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
        };
        openBuffer();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
        }, function() {
          buffer && subscriber.next(buffer);
          subscriber.complete();
        }, void 0, function() {
          return buffer = closingSubscriber = null;
        }));
      });
    }
    exports2.bufferWhen = bufferWhen;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.catchError = void 0;
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var lift_1 = require_lift();
    function catchError(selector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub = null;
        var syncUnsub = false;
        var handledResult;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
          handledResult = innerFrom_1.innerFrom(selector(err, catchError(selector)(source)));
          if (innerSub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          } else {
            syncUnsub = true;
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        }
      });
    }
    exports2.catchError = catchError;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scanInternals = void 0;
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
      return function(source, subscriber) {
        var hasState = hasSeed;
        var state = seed;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          state = hasState ? accumulator(state, value, i) : (hasState = true, value);
          emitOnNext && subscriber.next(state);
        }, emitBeforeComplete && function() {
          hasState && subscriber.next(state);
          subscriber.complete();
        }));
      };
    }
    exports2.scanInternals = scanInternals;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reduce = void 0;
    var scanInternals_1 = require_scanInternals();
    var lift_1 = require_lift();
    function reduce(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
    }
    exports2.reduce = reduce;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toArray = void 0;
    var reduce_1 = require_reduce();
    var lift_1 = require_lift();
    var arrReducer = function(arr, value) {
      return arr.push(value), arr;
    };
    function toArray() {
      return lift_1.operate(function(source, subscriber) {
        reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
      });
    }
    exports2.toArray = toArray;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinAllInternals = void 0;
    var identity_1 = require_identity();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var mergeMap_1 = require_mergeMap();
    var toArray_1 = require_toArray();
    function joinAllInternals(joinFn, project) {
      return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
        return joinFn(sources);
      }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
    }
    exports2.joinAllInternals = joinAllInternals;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestAll = void 0;
    var combineLatest_1 = require_combineLatest();
    var joinAllInternals_1 = require_joinAllInternals();
    function combineLatestAll(project) {
      return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
    }
    exports2.combineLatestAll = combineLatestAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineAll = void 0;
    var combineLatestAll_1 = require_combineLatestAll();
    exports2.combineAll = combineLatestAll_1.combineLatestAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatest = void 0;
    var combineLatest_1 = require_combineLatest();
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
    var pipe_1 = require_pipe();
    var args_1 = require_args();
    function combineLatest3() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var resultSelector = args_1.popResultSelector(args);
      return resultSelector ? pipe_1.pipe(combineLatest3.apply(void 0, __spreadArray2([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
        combineLatest_1.combineLatestInit(__spreadArray2([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
      });
    }
    exports2.combineLatest = combineLatest3;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.combineLatestWith = void 0;
    var combineLatest_1 = require_combineLatest2();
    function combineLatestWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read(otherSources)));
    }
    exports2.combineLatestWith = combineLatestWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function concatMap(project, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
    }
    exports2.concatMap = concatMap;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatMapTo = void 0;
    var concatMap_1 = require_concatMap();
    var isFunction_1 = require_isFunction();
    function concatMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
        return innerObservable;
      }, resultSelector) : concatMap_1.concatMap(function() {
        return innerObservable;
      });
    }
    exports2.concatMapTo = concatMapTo;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concat = void 0;
    var lift_1 = require_lift();
    var concatAll_1 = require_concatAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function concat() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      return lift_1.operate(function(source, subscriber) {
        concatAll_1.concatAll()(from_1.from(__spreadArray2([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports2.concat = concat;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.concatWith = void 0;
    var concat_1 = require_concat2();
    function concatWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return concat_1.concat.apply(void 0, __spreadArray2([], __read(otherSources)));
    }
    exports2.concatWith = concatWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromSubscribable = void 0;
    var Observable_1 = require_Observable();
    function fromSubscribable(subscribable) {
      return new Observable_1.Observable(function(subscriber) {
        return subscribable.subscribe(subscriber);
      });
    }
    exports2.fromSubscribable = fromSubscribable;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connect = void 0;
    var Subject_1 = require_Subject();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var fromSubscribable_1 = require_fromSubscribable();
    var DEFAULT_CONFIG = {
      connector: function() {
        return new Subject_1.Subject();
      }
    };
    function connect(selector, config2) {
      if (config2 === void 0) {
        config2 = DEFAULT_CONFIG;
      }
      var connector = config2.connector;
      return lift_1.operate(function(source, subscriber) {
        var subject = connector();
        innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
        subscriber.add(source.subscribe(subject));
      });
    }
    exports2.connect = connect;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.count = void 0;
    var reduce_1 = require_reduce();
    function count(predicate) {
      return reduce_1.reduce(function(total, value, i) {
        return !predicate || predicate(value, i) ? total + 1 : total;
      }, 0);
    }
    exports2.count = count;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debounce = void 0;
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function debounce(durationSelector) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        var durationSubscriber = null;
        var emit = function() {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          durationSubscriber = null;
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
          hasValue = true;
          lastValue = value;
          durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = durationSubscriber = null;
        }));
      });
    }
    exports2.debounce = debounce;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.debounceTime = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function debounceTime2(dueTime, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function() {
          if (activeTask) {
            activeTask.unsubscribe();
            activeTask = null;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        };
        function emitWhenIdle() {
          var targetTime = lastTime + dueTime;
          var now = scheduler.now();
          if (now < targetTime) {
            activeTask = this.schedule(void 0, targetTime - now);
            subscriber.add(activeTask);
            return;
          }
          emit();
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          lastValue = value;
          lastTime = scheduler.now();
          if (!activeTask) {
            activeTask = scheduler.schedule(emitWhenIdle, dueTime);
            subscriber.add(activeTask);
          }
        }, function() {
          emit();
          subscriber.complete();
        }, void 0, function() {
          lastValue = activeTask = null;
        }));
      });
    }
    exports2.debounceTime = debounceTime2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultIfEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function defaultIfEmpty(defaultValue) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          if (!hasValue) {
            subscriber.next(defaultValue);
          }
          subscriber.complete();
        }));
      });
    }
    exports2.defaultIfEmpty = defaultIfEmpty;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.take = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function take3(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (++seen <= count) {
            subscriber.next(value);
            if (count <= seen) {
              subscriber.complete();
            }
          }
        }));
      });
    }
    exports2.take = take3;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ignoreElements = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    function ignoreElements() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
      });
    }
    exports2.ignoreElements = ignoreElements;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapTo = void 0;
    var map_1 = require_map();
    function mapTo(value) {
      return map_1.map(function() {
        return value;
      });
    }
    exports2.mapTo = mapTo;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delayWhen = void 0;
    var concat_1 = require_concat();
    var take_1 = require_take();
    var ignoreElements_1 = require_ignoreElements();
    var mapTo_1 = require_mapTo();
    var mergeMap_1 = require_mergeMap();
    var innerFrom_1 = require_innerFrom();
    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return function(source) {
          return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
        };
      }
      return mergeMap_1.mergeMap(function(value, index) {
        return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
      });
    }
    exports2.delayWhen = delayWhen;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.delay = void 0;
    var async_1 = require_async();
    var delayWhen_1 = require_delayWhen();
    var timer_1 = require_timer();
    function delay(due, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration = timer_1.timer(due, scheduler);
      return delayWhen_1.delayWhen(function() {
        return duration;
      });
    }
    exports2.delay = delay;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dematerialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function dematerialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
          return Notification_1.observeNotification(notification, subscriber);
        }));
      });
    }
    exports2.dematerialize = dematerialize;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinct = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function distinct(keySelector, flushes) {
      return lift_1.operate(function(source, subscriber) {
        var distinctKeys = /* @__PURE__ */ new Set();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var key = keySelector ? keySelector(value) : value;
          if (!distinctKeys.has(key)) {
            distinctKeys.add(key);
            subscriber.next(value);
          }
        }));
        flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return distinctKeys.clear();
        }, noop_1.noop));
      });
    }
    exports2.distinct = distinct;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinctUntilChanged = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function distinctUntilChanged5(comparator, keySelector) {
      if (keySelector === void 0) {
        keySelector = identity_1.identity;
      }
      comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare2;
      return lift_1.operate(function(source, subscriber) {
        var previousKey;
        var first2 = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var currentKey = keySelector(value);
          if (first2 || !comparator(previousKey, currentKey)) {
            first2 = false;
            previousKey = currentKey;
            subscriber.next(value);
          }
        }));
      });
    }
    exports2.distinctUntilChanged = distinctUntilChanged5;
    function defaultCompare2(a2, b) {
      return a2 === b;
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.distinctUntilKeyChanged = void 0;
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged_1.distinctUntilChanged(function(x, y) {
        return compare ? compare(x[key], y[key]) : x[key] === y[key];
      });
    }
    exports2.distinctUntilKeyChanged = distinctUntilKeyChanged;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throwIfEmpty = void 0;
    var EmptyError_1 = require_EmptyError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
      }
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          subscriber.next(value);
        }, function() {
          return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
        }));
      });
    }
    exports2.throwIfEmpty = throwIfEmpty;
    function defaultErrorFactory() {
      return new EmptyError_1.EmptyError();
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.elementAt = void 0;
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    var filter_1 = require_filter();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var take_1 = require_take();
    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
      }
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(filter_1.filter(function(v, i) {
          return i === index;
        }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }));
      };
    }
    exports2.elementAt = elementAt;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.endWith = void 0;
    var concat_1 = require_concat();
    var of_1 = require_of();
    function endWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      return function(source) {
        return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray2([], __read(values))));
      };
    }
    exports2.endWith = endWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.every = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function every(predicate, thisArg) {
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!predicate.call(thisArg, value, index++, source)) {
            subscriber.next(false);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports2.every = every;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaustMap = void 0;
    var map_1 = require_map();
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return function(source) {
          return source.pipe(exhaustMap(function(a2, i) {
            return innerFrom_1.innerFrom(project(a2, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a2, b, i, ii);
            }));
          }));
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        var innerSub = null;
        var isComplete = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
          if (!innerSub) {
            innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              innerSub = null;
              isComplete && subscriber.complete();
            });
            innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
          }
        }, function() {
          isComplete = true;
          !innerSub && subscriber.complete();
        }));
      });
    }
    exports2.exhaustMap = exhaustMap;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaustAll = void 0;
    var exhaustMap_1 = require_exhaustMap();
    var identity_1 = require_identity();
    function exhaustAll() {
      return exhaustMap_1.exhaustMap(identity_1.identity);
    }
    exports2.exhaustAll = exhaustAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.exhaust = void 0;
    var exhaustAll_1 = require_exhaustAll();
    exports2.exhaust = exhaustAll_1.exhaustAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function expand(project, concurrent, scheduler) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
      return lift_1.operate(function(source, subscriber) {
        return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
      });
    }
    exports2.expand = expand;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.finalize = void 0;
    var lift_1 = require_lift();
    function finalize(callback) {
      return lift_1.operate(function(source, subscriber) {
        try {
          source.subscribe(subscriber);
        } finally {
          subscriber.add(callback);
        }
      });
    }
    exports2.finalize = finalize;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFind = exports2.find = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function find(predicate, thisArg) {
      return lift_1.operate(createFind(predicate, thisArg, "value"));
    }
    exports2.find = find;
    function createFind(predicate, thisArg, emit) {
      var findIndex = emit === "index";
      return function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var i = index++;
          if (predicate.call(thisArg, value, i, source)) {
            subscriber.next(findIndex ? i : value);
            subscriber.complete();
          }
        }, function() {
          subscriber.next(findIndex ? -1 : void 0);
          subscriber.complete();
        }));
      };
    }
    exports2.createFind = createFind;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findIndex = void 0;
    var lift_1 = require_lift();
    var find_1 = require_find();
    function findIndex(predicate, thisArg) {
      return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
    }
    exports2.findIndex = findIndex;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.first = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var take_1 = require_take();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var identity_1 = require_identity();
    function first2(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports2.first = first2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.groupBy = void 0;
    var Observable_1 = require_Observable();
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function groupBy2(keySelector, elementOrOptions, duration, connector) {
      return lift_1.operate(function(source, subscriber) {
        var element;
        if (!elementOrOptions || typeof elementOrOptions === "function") {
          element = elementOrOptions;
        } else {
          duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
        }
        var groups = /* @__PURE__ */ new Map();
        var notify = function(cb) {
          groups.forEach(cb);
          cb(subscriber);
        };
        var handleError = function(err) {
          return notify(function(consumer) {
            return consumer.error(err);
          });
        };
        var activeGroups = 0;
        var teardownAttempted = false;
        var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
          try {
            var key_1 = keySelector(value);
            var group_1 = groups.get(key_1);
            if (!group_1) {
              groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
              var grouped = createGroupedObservable(key_1, group_1);
              subscriber.next(grouped);
              if (duration) {
                var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                  group_1.complete();
                  durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                }, void 0, void 0, function() {
                  return groups.delete(key_1);
                });
                groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
              }
            }
            group_1.next(element ? element(value) : value);
          } catch (err) {
            handleError(err);
          }
        }, function() {
          return notify(function(consumer) {
            return consumer.complete();
          });
        }, handleError, function() {
          return groups.clear();
        }, function() {
          teardownAttempted = true;
          return activeGroups === 0;
        });
        source.subscribe(groupBySourceSubscriber);
        function createGroupedObservable(key, groupSubject) {
          var result = new Observable_1.Observable(function(groupSubscriber) {
            activeGroups++;
            var innerSub = groupSubject.subscribe(groupSubscriber);
            return function() {
              innerSub.unsubscribe();
              --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
            };
          });
          result.key = key;
          return result;
        }
      });
    }
    exports2.groupBy = groupBy2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function isEmpty() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          subscriber.next(false);
          subscriber.complete();
        }, function() {
          subscriber.next(true);
          subscriber.complete();
        }));
      });
    }
    exports2.isEmpty = isEmpty;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeLast = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeLast(count) {
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var buffer = [];
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffer.push(value);
          count < buffer.length && buffer.shift();
        }, function() {
          var e_1, _a2;
          try {
            for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
              var value = buffer_1_1.value;
              subscriber.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (buffer_1_1 && !buffer_1_1.done && (_a2 = buffer_1.return)) _a2.call(buffer_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          subscriber.complete();
        }, void 0, function() {
          buffer = null;
        }));
      });
    }
    exports2.takeLast = takeLast;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.last = void 0;
    var EmptyError_1 = require_EmptyError();
    var filter_1 = require_filter();
    var takeLast_1 = require_takeLast();
    var throwIfEmpty_1 = require_throwIfEmpty();
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    var identity_1 = require_identity();
    function last(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function(source) {
        return source.pipe(predicate ? filter_1.filter(function(v, i) {
          return predicate(v, i, source);
        }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
          return new EmptyError_1.EmptyError();
        }));
      };
    }
    exports2.last = last;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.materialize = void 0;
    var Notification_1 = require_Notification();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function materialize() {
      return lift_1.operate(function(source, subscriber) {
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          subscriber.next(Notification_1.Notification.createNext(value));
        }, function() {
          subscriber.next(Notification_1.Notification.createComplete());
          subscriber.complete();
        }, function(err) {
          subscriber.next(Notification_1.Notification.createError(err));
          subscriber.complete();
        }));
      });
    }
    exports2.materialize = materialize;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.max = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function max2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) > 0 ? x : y;
      } : function(x, y) {
        return x > y ? x : y;
      });
    }
    exports2.max = max2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.flatMap = void 0;
    var mergeMap_1 = require_mergeMap();
    exports2.flatMap = mergeMap_1.mergeMap;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeMapTo = void 0;
    var mergeMap_1 = require_mergeMap();
    var isFunction_1 = require_isFunction();
    function mergeMapTo(innerObservable, resultSelector, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      if (isFunction_1.isFunction(resultSelector)) {
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, resultSelector, concurrent);
      }
      if (typeof resultSelector === "number") {
        concurrent = resultSelector;
      }
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, concurrent);
    }
    exports2.mergeMapTo = mergeMapTo;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeScan = void 0;
    var lift_1 = require_lift();
    var mergeInternals_1 = require_mergeInternals();
    function mergeScan(accumulator, seed, concurrent) {
      if (concurrent === void 0) {
        concurrent = Infinity;
      }
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
          return accumulator(state, value, index);
        }, concurrent, function(value) {
          state = value;
        }, false, void 0, function() {
          return state = null;
        });
      });
    }
    exports2.mergeScan = mergeScan;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var lift_1 = require_lift();
    var argsOrArgArray_1 = require_argsOrArgArray();
    var mergeAll_1 = require_mergeAll();
    var args_1 = require_args();
    var from_1 = require_from();
    function merge5() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(args);
      var concurrent = args_1.popNumber(args, Infinity);
      args = argsOrArgArray_1.argsOrArgArray(args);
      return lift_1.operate(function(source, subscriber) {
        mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source], __read(args)), scheduler)).subscribe(subscriber);
      });
    }
    exports2.merge = merge5;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeWith = void 0;
    var merge_1 = require_merge2();
    function mergeWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return merge_1.merge.apply(void 0, __spreadArray2([], __read(otherSources)));
    }
    exports2.mergeWith = mergeWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.min = void 0;
    var reduce_1 = require_reduce();
    var isFunction_1 = require_isFunction();
    function min2(comparer) {
      return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x, y) {
        return comparer(x, y) < 0 ? x : y;
      } : function(x, y) {
        return x < y ? x : y;
      });
    }
    exports2.min = min2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.multicast = void 0;
    var ConnectableObservable_1 = require_ConnectableObservable();
    var isFunction_1 = require_isFunction();
    var connect_1 = require_connect();
    function multicast(subjectOrSubjectFactory, selector) {
      var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
        return subjectOrSubjectFactory;
      };
      if (isFunction_1.isFunction(selector)) {
        return connect_1.connect(selector, {
          connector: subjectFactory
        });
      }
      return function(source) {
        return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
      };
    }
    exports2.multicast = multicast;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.onErrorResumeNext = exports2.onErrorResumeNextWith = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    function onErrorResumeNextWith() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
      return function(source) {
        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray2([source], __read(nextSources)));
      };
    }
    exports2.onErrorResumeNextWith = onErrorResumeNextWith;
    exports2.onErrorResumeNext = onErrorResumeNextWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pairwise = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function pairwise() {
      return lift_1.operate(function(source, subscriber) {
        var prev;
        var hasPrev = false;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var p = prev;
          prev = value;
          hasPrev && subscriber.next([p, value]);
          hasPrev = true;
        }));
      });
    }
    exports2.pairwise = pairwise;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.pluck = void 0;
    var map_1 = require_map();
    function pluck() {
      var properties = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
      }
      var length = properties.length;
      if (length === 0) {
        throw new Error("list of properties cannot be empty.");
      }
      return map_1.map(function(x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
          var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
          if (typeof p !== "undefined") {
            currentProp = p;
          } else {
            return void 0;
          }
        }
        return currentProp;
      });
    }
    exports2.pluck = pluck;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publish = void 0;
    var Subject_1 = require_Subject();
    var multicast_1 = require_multicast();
    var connect_1 = require_connect();
    function publish(selector) {
      return selector ? function(source) {
        return connect_1.connect(selector)(source);
      } : function(source) {
        return multicast_1.multicast(new Subject_1.Subject())(source);
      };
    }
    exports2.publish = publish;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishBehavior = void 0;
    var BehaviorSubject_1 = require_BehaviorSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishBehavior(initialValue) {
      return function(source) {
        var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports2.publishBehavior = publishBehavior;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishLast = void 0;
    var AsyncSubject_1 = require_AsyncSubject();
    var ConnectableObservable_1 = require_ConnectableObservable();
    function publishLast() {
      return function(source) {
        var subject = new AsyncSubject_1.AsyncSubject();
        return new ConnectableObservable_1.ConnectableObservable(source, function() {
          return subject;
        });
      };
    }
    exports2.publishLast = publishLast;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.publishReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var multicast_1 = require_multicast();
    var isFunction_1 = require_isFunction();
    function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
      if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
        timestampProvider = selectorOrScheduler;
      }
      var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
      return function(source) {
        return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
      };
    }
    exports2.publishReplay = publishReplay;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.raceWith = void 0;
    var race_1 = require_race();
    var lift_1 = require_lift();
    var identity_1 = require_identity();
    function raceWith() {
      var otherSources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherSources[_i] = arguments[_i];
      }
      return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        race_1.raceInit(__spreadArray2([source], __read(otherSources)))(subscriber);
      });
    }
    exports2.raceWith = raceWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.repeat = void 0;
    var empty_1 = require_empty();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var timer_1 = require_timer();
    function repeat(countOrConfig) {
      var _a2;
      var count = Infinity;
      var delay;
      if (countOrConfig != null) {
        if (typeof countOrConfig === "object") {
          _a2 = countOrConfig.count, count = _a2 === void 0 ? Infinity : _a2, delay = countOrConfig.delay;
        } else {
          count = countOrConfig;
        }
      }
      return count <= 0 ? function() {
        return empty_1.EMPTY;
      } : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var sourceSub;
        var resubscribe = function() {
          sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
          sourceSub = null;
          if (delay != null) {
            var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              subscribeToSource();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            subscribeToSource();
          }
        };
        var subscribeToSource = function() {
          var syncUnsub = false;
          sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            if (++soFar < count) {
              if (sourceSub) {
                resubscribe();
              } else {
                syncUnsub = true;
              }
            } else {
              subscriber.complete();
            }
          }));
          if (syncUnsub) {
            resubscribe();
          }
        };
        subscribeToSource();
      });
    }
    exports2.repeat = repeat;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.repeatWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function repeatWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var completions$;
        var isNotifierComplete = false;
        var isMainComplete = false;
        var checkComplete = function() {
          return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
        };
        var getCompletionSubject = function() {
          if (!completions$) {
            completions$ = new Subject_1.Subject();
            innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              if (innerSub) {
                subscribeForRepeatWhen();
              } else {
                syncResub = true;
              }
            }, function() {
              isNotifierComplete = true;
              checkComplete();
            }));
          }
          return completions$;
        };
        var subscribeForRepeatWhen = function() {
          isMainComplete = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
            isMainComplete = true;
            !checkComplete() && getCompletionSubject().next();
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRepeatWhen();
          }
        };
        subscribeForRepeatWhen();
      });
    }
    exports2.repeatWhen = repeatWhen;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retry = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    var timer_1 = require_timer();
    var innerFrom_1 = require_innerFrom();
    function retry(configOrCount) {
      if (configOrCount === void 0) {
        configOrCount = Infinity;
      }
      var config2;
      if (configOrCount && typeof configOrCount === "object") {
        config2 = configOrCount;
      } else {
        config2 = {
          count: configOrCount
        };
      }
      var _a2 = config2.count, count = _a2 === void 0 ? Infinity : _a2, delay = config2.delay, _b2 = config2.resetOnSuccess, resetOnSuccess = _b2 === void 0 ? false : _b2;
      return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var soFar = 0;
        var innerSub;
        var subscribeForRetry = function() {
          var syncUnsub = false;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (resetOnSuccess) {
              soFar = 0;
            }
            subscriber.next(value);
          }, void 0, function(err) {
            if (soFar++ < count) {
              var resub_1 = function() {
                if (innerSub) {
                  innerSub.unsubscribe();
                  innerSub = null;
                  subscribeForRetry();
                } else {
                  syncUnsub = true;
                }
              };
              if (delay != null) {
                var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err, soFar));
                var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  notifierSubscriber_1.unsubscribe();
                  resub_1();
                }, function() {
                  subscriber.complete();
                });
                notifier.subscribe(notifierSubscriber_1);
              } else {
                resub_1();
              }
            } else {
              subscriber.error(err);
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            subscribeForRetry();
          }
        };
        subscribeForRetry();
      });
    }
    exports2.retry = retry;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryWhen = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function retryWhen(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var innerSub;
        var syncResub = false;
        var errors$;
        var subscribeForRetryWhen = function() {
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
            if (!errors$) {
              errors$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                return innerSub ? subscribeForRetryWhen() : syncResub = true;
              }));
            }
            if (errors$) {
              errors$.next(err);
            }
          }));
          if (syncResub) {
            innerSub.unsubscribe();
            innerSub = null;
            syncResub = false;
            subscribeForRetryWhen();
          }
        };
        subscribeForRetryWhen();
      });
    }
    exports2.retryWhen = retryWhen;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sample = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var noop_1 = require_noop();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function sample(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var lastValue = null;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          lastValue = value;
        }));
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          if (hasValue) {
            hasValue = false;
            var value = lastValue;
            lastValue = null;
            subscriber.next(value);
          }
        }, noop_1.noop));
      });
    }
    exports2.sample = sample;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sampleTime = void 0;
    var async_1 = require_async();
    var sample_1 = require_sample();
    var interval_1 = require_interval();
    function sampleTime(period, scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return sample_1.sample(interval_1.interval(period, scheduler));
    }
    exports2.sampleTime = sampleTime;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scan = void 0;
    var lift_1 = require_lift();
    var scanInternals_1 = require_scanInternals();
    function scan(accumulator, seed) {
      return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
    }
    exports2.scan = scan;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sequenceEqual = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function sequenceEqual(compareTo, comparator) {
      if (comparator === void 0) {
        comparator = function(a2, b) {
          return a2 === b;
        };
      }
      return lift_1.operate(function(source, subscriber) {
        var aState = createState();
        var bState = createState();
        var emit = function(isEqual) {
          subscriber.next(isEqual);
          subscriber.complete();
        };
        var createSubscriber = function(selfState, otherState) {
          var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a2) {
            var buffer = otherState.buffer, complete = otherState.complete;
            if (buffer.length === 0) {
              complete ? emit(false) : selfState.buffer.push(a2);
            } else {
              !comparator(a2, buffer.shift()) && emit(false);
            }
          }, function() {
            selfState.complete = true;
            var complete = otherState.complete, buffer = otherState.buffer;
            complete && emit(buffer.length === 0);
            sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
          });
          return sequenceEqualSubscriber;
        };
        source.subscribe(createSubscriber(aState, bState));
        innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
      });
    }
    exports2.sequenceEqual = sequenceEqual;
    function createState() {
      return {
        buffer: [],
        complete: false
      };
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.share = void 0;
    var innerFrom_1 = require_innerFrom();
    var Subject_1 = require_Subject();
    var Subscriber_1 = require_Subscriber();
    var lift_1 = require_lift();
    function share(options) {
      if (options === void 0) {
        options = {};
      }
      var _a2 = options.connector, connector = _a2 === void 0 ? function() {
        return new Subject_1.Subject();
      } : _a2, _b2 = options.resetOnError, resetOnError = _b2 === void 0 ? true : _b2, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
      return function(wrapperSource) {
        var connection;
        var resetConnection;
        var subject;
        var refCount = 0;
        var hasCompleted = false;
        var hasErrored = false;
        var cancelReset = function() {
          resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
          resetConnection = void 0;
        };
        var reset = function() {
          cancelReset();
          connection = subject = void 0;
          hasCompleted = hasErrored = false;
        };
        var resetAndUnsubscribe = function() {
          var conn = connection;
          reset();
          conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
        };
        return lift_1.operate(function(source, subscriber) {
          refCount++;
          if (!hasErrored && !hasCompleted) {
            cancelReset();
          }
          var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
          subscriber.add(function() {
            refCount--;
            if (refCount === 0 && !hasErrored && !hasCompleted) {
              resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
            }
          });
          dest.subscribe(subscriber);
          if (!connection && refCount > 0) {
            connection = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                return dest.next(value);
              },
              error: function(err) {
                hasErrored = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnError, err);
                dest.error(err);
              },
              complete: function() {
                hasCompleted = true;
                cancelReset();
                resetConnection = handleReset(reset, resetOnComplete);
                dest.complete();
              }
            });
            innerFrom_1.innerFrom(source).subscribe(connection);
          }
        })(wrapperSource);
      };
    }
    exports2.share = share;
    function handleReset(reset, on) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (on === true) {
        reset();
        return;
      }
      if (on === false) {
        return;
      }
      var onSubscriber = new Subscriber_1.SafeSubscriber({
        next: function() {
          onSubscriber.unsubscribe();
          reset();
        }
      });
      return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray2([], __read(args)))).subscribe(onSubscriber);
    }
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shareReplay = void 0;
    var ReplaySubject_1 = require_ReplaySubject();
    var share_1 = require_share();
    function shareReplay5(configOrBufferSize, windowTime, scheduler) {
      var _a2, _b2, _c;
      var bufferSize;
      var refCount = false;
      if (configOrBufferSize && typeof configOrBufferSize === "object") {
        _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === void 0 ? Infinity : _a2, _b2 = configOrBufferSize.windowTime, windowTime = _b2 === void 0 ? Infinity : _b2, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
      } else {
        bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
      }
      return share_1.share({
        connector: function() {
          return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
        },
        resetOnError: true,
        resetOnComplete: false,
        resetOnRefCountZero: refCount
      });
    }
    exports2.shareReplay = shareReplay5;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.single = void 0;
    var EmptyError_1 = require_EmptyError();
    var SequenceError_1 = require_SequenceError();
    var NotFoundError_1 = require_NotFoundError();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function single(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var hasValue = false;
        var singleValue;
        var seenValue = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          seenValue = true;
          if (!predicate || predicate(value, index++, source)) {
            hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
            hasValue = true;
            singleValue = value;
          }
        }, function() {
          if (hasValue) {
            subscriber.next(singleValue);
            subscriber.complete();
          } else {
            subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
          }
        }));
      });
    }
    exports2.single = single;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skip = void 0;
    var filter_1 = require_filter();
    function skip5(count) {
      return filter_1.filter(function(_, index) {
        return count <= index;
      });
    }
    exports2.skip = skip5;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipLast = void 0;
    var identity_1 = require_identity();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipLast(skipCount) {
      return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
        var ring = new Array(skipCount);
        var seen = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var valueIndex = seen++;
          if (valueIndex < skipCount) {
            ring[valueIndex] = value;
          } else {
            var index = valueIndex % skipCount;
            var oldValue = ring[index];
            ring[index] = value;
            subscriber.next(oldValue);
          }
        }));
        return function() {
          ring = null;
        };
      });
    }
    exports2.skipLast = skipLast;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function skipUntil(notifier) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
          taking = true;
        }, noop_1.noop);
        innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return taking && subscriber.next(value);
        }));
      });
    }
    exports2.skipUntil = skipUntil;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.skipWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function skipWhile(predicate) {
      return lift_1.operate(function(source, subscriber) {
        var taking = false;
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
        }));
      });
    }
    exports2.skipWhile = skipWhile;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.startWith = void 0;
    var concat_1 = require_concat();
    var args_1 = require_args();
    var lift_1 = require_lift();
    function startWith() {
      var values = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
      }
      var scheduler = args_1.popScheduler(values);
      return lift_1.operate(function(source, subscriber) {
        (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
      });
    }
    exports2.startWith = startWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchMap = void 0;
    var innerFrom_1 = require_innerFrom();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function switchMap3(project, resultSelector) {
      return lift_1.operate(function(source, subscriber) {
        var innerSubscriber = null;
        var index = 0;
        var isComplete = false;
        var checkComplete = function() {
          return isComplete && !innerSubscriber && subscriber.complete();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
          var innerIndex = 0;
          var outerIndex = index++;
          innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
          }, function() {
            innerSubscriber = null;
            checkComplete();
          }));
        }, function() {
          isComplete = true;
          checkComplete();
        }));
      });
    }
    exports2.switchMap = switchMap3;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchAll = void 0;
    var switchMap_1 = require_switchMap();
    var identity_1 = require_identity();
    function switchAll() {
      return switchMap_1.switchMap(identity_1.identity);
    }
    exports2.switchAll = switchAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchMapTo = void 0;
    var switchMap_1 = require_switchMap();
    var isFunction_1 = require_isFunction();
    function switchMapTo(innerObservable, resultSelector) {
      return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
        return innerObservable;
      }, resultSelector) : switchMap_1.switchMap(function() {
        return innerObservable;
      });
    }
    exports2.switchMapTo = switchMapTo;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.switchScan = void 0;
    var switchMap_1 = require_switchMap();
    var lift_1 = require_lift();
    function switchScan(accumulator, seed) {
      return lift_1.operate(function(source, subscriber) {
        var state = seed;
        switchMap_1.switchMap(function(value, index) {
          return accumulator(state, value, index);
        }, function(_, innerValue) {
          return state = innerValue, innerValue;
        })(source).subscribe(subscriber);
        return function() {
          state = null;
        };
      });
    }
    exports2.switchScan = switchScan;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeUntil = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var noop_1 = require_noop();
    function takeUntil6(notifier) {
      return lift_1.operate(function(source, subscriber) {
        innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          return subscriber.complete();
        }, noop_1.noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }
    exports2.takeUntil = takeUntil6;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.takeWhile = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function takeWhile(predicate, inclusive) {
      if (inclusive === void 0) {
        inclusive = false;
      }
      return lift_1.operate(function(source, subscriber) {
        var index = 0;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var result = predicate(value, index++);
          (result || inclusive) && subscriber.next(value);
          !result && subscriber.complete();
        }));
      });
    }
    exports2.takeWhile = takeWhile;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tap = void 0;
    var isFunction_1 = require_isFunction();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var identity_1 = require_identity();
    function tap2(observerOrNext, error, complete) {
      var tapObserver = isFunction_1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
      return tapObserver ? lift_1.operate(function(source, subscriber) {
        var _a2;
        (_a2 = tapObserver.subscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
        var isUnsub = true;
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var _a3;
          (_a3 = tapObserver.next) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, value);
          subscriber.next(value);
        }, function() {
          var _a3;
          isUnsub = false;
          (_a3 = tapObserver.complete) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
          subscriber.complete();
        }, function(err) {
          var _a3;
          isUnsub = false;
          (_a3 = tapObserver.error) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, err);
          subscriber.error(err);
        }, function() {
          var _a3, _b2;
          if (isUnsub) {
            (_a3 = tapObserver.unsubscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
          }
          (_b2 = tapObserver.finalize) === null || _b2 === void 0 ? void 0 : _b2.call(tapObserver);
        }));
      }) : identity_1.identity;
    }
    exports2.tap = tap2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttle = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function throttle2(durationSelector, config2) {
      return lift_1.operate(function(source, subscriber) {
        var _a2 = config2 !== null && config2 !== void 0 ? config2 : {}, _b2 = _a2.leading, leading = _b2 === void 0 ? true : _b2, _c = _a2.trailing, trailing = _c === void 0 ? false : _c;
        var hasValue = false;
        var sendValue = null;
        var throttled = null;
        var isComplete = false;
        var endThrottling = function() {
          throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
          throttled = null;
          if (trailing) {
            send();
            isComplete && subscriber.complete();
          }
        };
        var cleanupThrottling = function() {
          throttled = null;
          isComplete && subscriber.complete();
        };
        var startThrottle = function(value) {
          return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
        };
        var send = function() {
          if (hasValue) {
            hasValue = false;
            var value = sendValue;
            sendValue = null;
            subscriber.next(value);
            !isComplete && startThrottle(value);
          }
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          hasValue = true;
          sendValue = value;
          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
        }, function() {
          isComplete = true;
          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
        }));
      });
    }
    exports2.throttle = throttle2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.throttleTime = void 0;
    var async_1 = require_async();
    var throttle_1 = require_throttle();
    var timer_1 = require_timer();
    function throttleTime(duration, scheduler, config2) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      var duration$ = timer_1.timer(duration, scheduler);
      return throttle_1.throttle(function() {
        return duration$;
      }, config2);
    }
    exports2.throttleTime = throttleTime;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TimeInterval = exports2.timeInterval = void 0;
    var async_1 = require_async();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function timeInterval(scheduler) {
      if (scheduler === void 0) {
        scheduler = async_1.asyncScheduler;
      }
      return lift_1.operate(function(source, subscriber) {
        var last = scheduler.now();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var now = scheduler.now();
          var interval = now - last;
          last = now;
          subscriber.next(new TimeInterval(value, interval));
        }));
      });
    }
    exports2.timeInterval = timeInterval;
    var TimeInterval = /* @__PURE__ */ function() {
      function TimeInterval2(value, interval) {
        this.value = value;
        this.interval = interval;
      }
      return TimeInterval2;
    }();
    exports2.TimeInterval = TimeInterval;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timeoutWith = void 0;
    var async_1 = require_async();
    var isDate_1 = require_isDate();
    var timeout_1 = require_timeout();
    function timeoutWith(due, withObservable, scheduler) {
      var first2;
      var each;
      var _with;
      scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
      if (isDate_1.isValidDate(due)) {
        first2 = due;
      } else if (typeof due === "number") {
        each = due;
      }
      if (withObservable) {
        _with = function() {
          return withObservable;
        };
      } else {
        throw new TypeError("No observable provided to switch to");
      }
      if (first2 == null && each == null) {
        throw new TypeError("No timeout provided.");
      }
      return timeout_1.timeout({
        first: first2,
        each,
        scheduler,
        with: _with
      });
    }
    exports2.timeoutWith = timeoutWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.timestamp = void 0;
    var dateTimestampProvider_1 = require_dateTimestampProvider();
    var map_1 = require_map();
    function timestamp(timestampProvider) {
      if (timestampProvider === void 0) {
        timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      return map_1.map(function(value) {
        return { value, timestamp: timestampProvider.now() };
      });
    }
    exports2.timestamp = timestamp;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.window = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var innerFrom_1 = require_innerFrom();
    function window2(windowBoundaries) {
      return lift_1.operate(function(source, subscriber) {
        var windowSubject = new Subject_1.Subject();
        subscriber.next(windowSubject.asObservable());
        var errorHandler = function(err) {
          windowSubject.error(err);
          subscriber.error(err);
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
        }, function() {
          windowSubject.complete();
          subscriber.complete();
        }, errorHandler));
        innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
          windowSubject.complete();
          subscriber.next(windowSubject = new Subject_1.Subject());
        }, noop_1.noop, errorHandler));
        return function() {
          windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
          windowSubject = null;
        };
      });
    }
    exports2.window = window2;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowCount = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    function windowCount(windowSize, startWindowEvery) {
      if (startWindowEvery === void 0) {
        startWindowEvery = 0;
      }
      var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
      return lift_1.operate(function(source, subscriber) {
        var windows = [new Subject_1.Subject()];
        var starts = [];
        var count = 0;
        subscriber.next(windows[0].asObservable());
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          try {
            for (var windows_1 = __values(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
              var window_1 = windows_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windows_1_1 && !windows_1_1.done && (_a2 = windows_1.return)) _a2.call(windows_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          var c = count - windowSize + 1;
          if (c >= 0 && c % startEvery === 0) {
            windows.shift().complete();
          }
          if (++count % startEvery === 0) {
            var window_2 = new Subject_1.Subject();
            windows.push(window_2);
            subscriber.next(window_2.asObservable());
          }
        }, function() {
          while (windows.length > 0) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, function(err) {
          while (windows.length > 0) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        }, function() {
          starts = null;
          windows = null;
        }));
      });
    }
    exports2.windowCount = windowCount;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowTime = void 0;
    var Subject_1 = require_Subject();
    var async_1 = require_async();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var arrRemove_1 = require_arrRemove();
    var args_1 = require_args();
    var executeSchedule_1 = require_executeSchedule();
    function windowTime(windowTimeSpan) {
      var _a2, _b2;
      var otherArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        otherArgs[_i - 1] = arguments[_i];
      }
      var scheduler = (_a2 = args_1.popScheduler(otherArgs)) !== null && _a2 !== void 0 ? _a2 : async_1.asyncScheduler;
      var windowCreationInterval = (_b2 = otherArgs[0]) !== null && _b2 !== void 0 ? _b2 : null;
      var maxWindowSize = otherArgs[1] || Infinity;
      return lift_1.operate(function(source, subscriber) {
        var windowRecords = [];
        var restartOnClose = false;
        var closeWindow = function(record) {
          var window2 = record.window, subs = record.subs;
          window2.complete();
          subs.unsubscribe();
          arrRemove_1.arrRemove(windowRecords, record);
          restartOnClose && startWindow();
        };
        var startWindow = function() {
          if (windowRecords) {
            var subs = new Subscription_1.Subscription();
            subscriber.add(subs);
            var window_1 = new Subject_1.Subject();
            var record_1 = {
              window: window_1,
              subs,
              seen: 0
            };
            windowRecords.push(record_1);
            subscriber.next(window_1.asObservable());
            executeSchedule_1.executeSchedule(subs, scheduler, function() {
              return closeWindow(record_1);
            }, windowTimeSpan);
          }
        };
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
        } else {
          restartOnClose = true;
        }
        startWindow();
        var loop = function(cb) {
          return windowRecords.slice().forEach(cb);
        };
        var terminate = function(cb) {
          loop(function(_a3) {
            var window2 = _a3.window;
            return cb(window2);
          });
          cb(subscriber);
          subscriber.unsubscribe();
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          loop(function(record) {
            record.window.next(value);
            maxWindowSize <= ++record.seen && closeWindow(record);
          });
        }, function() {
          return terminate(function(consumer) {
            return consumer.complete();
          });
        }, function(err) {
          return terminate(function(consumer) {
            return consumer.error(err);
          });
        }));
        return function() {
          windowRecords = null;
        };
      });
    }
    exports2.windowTime = windowTime;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowToggle = void 0;
    var Subject_1 = require_Subject();
    var Subscription_1 = require_Subscription();
    var lift_1 = require_lift();
    var innerFrom_1 = require_innerFrom();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var noop_1 = require_noop();
    var arrRemove_1 = require_arrRemove();
    function windowToggle(openings, closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var windows = [];
        var handleError = function(err) {
          while (0 < windows.length) {
            windows.shift().error(err);
          }
          subscriber.error(err);
        };
        innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
          var window2 = new Subject_1.Subject();
          windows.push(window2);
          var closingSubscription = new Subscription_1.Subscription();
          var closeWindow = function() {
            arrRemove_1.arrRemove(windows, window2);
            window2.complete();
            closingSubscription.unsubscribe();
          };
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
          } catch (err) {
            handleError(err);
            return;
          }
          subscriber.next(window2.asObservable());
          closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
        }, noop_1.noop));
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          var e_1, _a2;
          var windowsCopy = windows.slice();
          try {
            for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
              var window_1 = windowsCopy_1_1.value;
              window_1.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a2 = windowsCopy_1.return)) _a2.call(windowsCopy_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }, function() {
          while (0 < windows.length) {
            windows.shift().complete();
          }
          subscriber.complete();
        }, handleError, function() {
          while (0 < windows.length) {
            windows.shift().unsubscribe();
          }
        }));
      });
    }
    exports2.windowToggle = windowToggle;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.windowWhen = void 0;
    var Subject_1 = require_Subject();
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    function windowWhen(closingSelector) {
      return lift_1.operate(function(source, subscriber) {
        var window2;
        var closingSubscriber;
        var handleError = function(err) {
          window2.error(err);
          subscriber.error(err);
        };
        var openWindow = function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 === null || window2 === void 0 ? void 0 : window2.complete();
          window2 = new Subject_1.Subject();
          subscriber.next(window2.asObservable());
          var closingNotifier;
          try {
            closingNotifier = innerFrom_1.innerFrom(closingSelector());
          } catch (err) {
            handleError(err);
            return;
          }
          closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
        };
        openWindow();
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          return window2.next(value);
        }, function() {
          window2.complete();
          subscriber.complete();
        }, handleError, function() {
          closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
          window2 = null;
        }));
      });
    }
    exports2.windowWhen = windowWhen;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.withLatestFrom = void 0;
    var lift_1 = require_lift();
    var OperatorSubscriber_1 = require_OperatorSubscriber();
    var innerFrom_1 = require_innerFrom();
    var identity_1 = require_identity();
    var noop_1 = require_noop();
    var args_1 = require_args();
    function withLatestFrom() {
      var inputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
      }
      var project = args_1.popResultSelector(inputs);
      return lift_1.operate(function(source, subscriber) {
        var len = inputs.length;
        var otherValues = new Array(len);
        var hasValue = inputs.map(function() {
          return false;
        });
        var ready = false;
        var _loop_1 = function(i2) {
          innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            otherValues[i2] = value;
            if (!ready && !hasValue[i2]) {
              hasValue[i2] = true;
              (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
            }
          }, noop_1.noop));
        };
        for (var i = 0; i < len; i++) {
          _loop_1(i);
        }
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (ready) {
            var values = __spreadArray2([value], __read(otherValues));
            subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read(values))) : values);
          }
        }));
      });
    }
    exports2.withLatestFrom = withLatestFrom;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zipAll = void 0;
    var zip_1 = require_zip();
    var joinAllInternals_1 = require_joinAllInternals();
    function zipAll(project) {
      return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
    }
    exports2.zipAll = zipAll;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zip = void 0;
    var zip_1 = require_zip();
    var lift_1 = require_lift();
    function zip() {
      var sources = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
      }
      return lift_1.operate(function(source, subscriber) {
        zip_1.zip.apply(void 0, __spreadArray2([source], __read(sources))).subscribe(subscriber);
      });
    }
    exports2.zip = zip;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.zipWith = void 0;
    var zip_1 = require_zip2();
    function zipWith() {
      var otherInputs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        otherInputs[_i] = arguments[_i];
      }
      return zip_1.zip.apply(void 0, __spreadArray2([], __read(otherInputs)));
    }
    exports2.zipWith = zipWith;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.interval = exports2.iif = exports2.generate = exports2.fromEventPattern = exports2.fromEvent = exports2.from = exports2.forkJoin = exports2.empty = exports2.defer = exports2.connectable = exports2.concat = exports2.combineLatest = exports2.bindNodeCallback = exports2.bindCallback = exports2.UnsubscriptionError = exports2.TimeoutError = exports2.SequenceError = exports2.ObjectUnsubscribedError = exports2.NotFoundError = exports2.EmptyError = exports2.ArgumentOutOfRangeError = exports2.firstValueFrom = exports2.lastValueFrom = exports2.isObservable = exports2.identity = exports2.noop = exports2.pipe = exports2.NotificationKind = exports2.Notification = exports2.Subscriber = exports2.Subscription = exports2.Scheduler = exports2.VirtualAction = exports2.VirtualTimeScheduler = exports2.animationFrameScheduler = exports2.animationFrame = exports2.queueScheduler = exports2.queue = exports2.asyncScheduler = exports2.async = exports2.asapScheduler = exports2.asap = exports2.AsyncSubject = exports2.ReplaySubject = exports2.BehaviorSubject = exports2.Subject = exports2.animationFrames = exports2.observable = exports2.ConnectableObservable = exports2.Observable = void 0;
    exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.combineLatestWith = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = exports2.config = exports2.NEVER = exports2.EMPTY = exports2.scheduled = exports2.zip = exports2.using = exports2.timer = exports2.throwError = exports2.range = exports2.race = exports2.partition = exports2.pairs = exports2.onErrorResumeNext = exports2.of = exports2.never = exports2.merge = void 0;
    exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.pairwise = exports2.onErrorResumeNextWith = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = exports2.mergeAll = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = void 0;
    exports2.zipWith = exports2.zipAll = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = void 0;
    var Observable_1 = require_Observable();
    Object.defineProperty(exports2, "Observable", { enumerable: true, get: function() {
      return Observable_1.Observable;
    } });
    var ConnectableObservable_1 = require_ConnectableObservable();
    Object.defineProperty(exports2, "ConnectableObservable", { enumerable: true, get: function() {
      return ConnectableObservable_1.ConnectableObservable;
    } });
    var observable_1 = require_observable();
    Object.defineProperty(exports2, "observable", { enumerable: true, get: function() {
      return observable_1.observable;
    } });
    var animationFrames_1 = require_animationFrames();
    Object.defineProperty(exports2, "animationFrames", { enumerable: true, get: function() {
      return animationFrames_1.animationFrames;
    } });
    var Subject_1 = require_Subject();
    Object.defineProperty(exports2, "Subject", { enumerable: true, get: function() {
      return Subject_1.Subject;
    } });
    var BehaviorSubject_1 = require_BehaviorSubject();
    Object.defineProperty(exports2, "BehaviorSubject", { enumerable: true, get: function() {
      return BehaviorSubject_1.BehaviorSubject;
    } });
    var ReplaySubject_1 = require_ReplaySubject();
    Object.defineProperty(exports2, "ReplaySubject", { enumerable: true, get: function() {
      return ReplaySubject_1.ReplaySubject;
    } });
    var AsyncSubject_1 = require_AsyncSubject();
    Object.defineProperty(exports2, "AsyncSubject", { enumerable: true, get: function() {
      return AsyncSubject_1.AsyncSubject;
    } });
    var asap_1 = require_asap();
    Object.defineProperty(exports2, "asap", { enumerable: true, get: function() {
      return asap_1.asap;
    } });
    Object.defineProperty(exports2, "asapScheduler", { enumerable: true, get: function() {
      return asap_1.asapScheduler;
    } });
    var async_1 = require_async();
    Object.defineProperty(exports2, "async", { enumerable: true, get: function() {
      return async_1.async;
    } });
    Object.defineProperty(exports2, "asyncScheduler", { enumerable: true, get: function() {
      return async_1.asyncScheduler;
    } });
    var queue_1 = require_queue();
    Object.defineProperty(exports2, "queue", { enumerable: true, get: function() {
      return queue_1.queue;
    } });
    Object.defineProperty(exports2, "queueScheduler", { enumerable: true, get: function() {
      return queue_1.queueScheduler;
    } });
    var animationFrame_1 = require_animationFrame();
    Object.defineProperty(exports2, "animationFrame", { enumerable: true, get: function() {
      return animationFrame_1.animationFrame;
    } });
    Object.defineProperty(exports2, "animationFrameScheduler", { enumerable: true, get: function() {
      return animationFrame_1.animationFrameScheduler;
    } });
    var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
    Object.defineProperty(exports2, "VirtualTimeScheduler", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualTimeScheduler;
    } });
    Object.defineProperty(exports2, "VirtualAction", { enumerable: true, get: function() {
      return VirtualTimeScheduler_1.VirtualAction;
    } });
    var Scheduler_1 = require_Scheduler();
    Object.defineProperty(exports2, "Scheduler", { enumerable: true, get: function() {
      return Scheduler_1.Scheduler;
    } });
    var Subscription_1 = require_Subscription();
    Object.defineProperty(exports2, "Subscription", { enumerable: true, get: function() {
      return Subscription_1.Subscription;
    } });
    var Subscriber_1 = require_Subscriber();
    Object.defineProperty(exports2, "Subscriber", { enumerable: true, get: function() {
      return Subscriber_1.Subscriber;
    } });
    var Notification_1 = require_Notification();
    Object.defineProperty(exports2, "Notification", { enumerable: true, get: function() {
      return Notification_1.Notification;
    } });
    Object.defineProperty(exports2, "NotificationKind", { enumerable: true, get: function() {
      return Notification_1.NotificationKind;
    } });
    var pipe_1 = require_pipe();
    Object.defineProperty(exports2, "pipe", { enumerable: true, get: function() {
      return pipe_1.pipe;
    } });
    var noop_1 = require_noop();
    Object.defineProperty(exports2, "noop", { enumerable: true, get: function() {
      return noop_1.noop;
    } });
    var identity_1 = require_identity();
    Object.defineProperty(exports2, "identity", { enumerable: true, get: function() {
      return identity_1.identity;
    } });
    var isObservable_1 = require_isObservable();
    Object.defineProperty(exports2, "isObservable", { enumerable: true, get: function() {
      return isObservable_1.isObservable;
    } });
    var lastValueFrom_1 = require_lastValueFrom();
    Object.defineProperty(exports2, "lastValueFrom", { enumerable: true, get: function() {
      return lastValueFrom_1.lastValueFrom;
    } });
    var firstValueFrom_1 = require_firstValueFrom();
    Object.defineProperty(exports2, "firstValueFrom", { enumerable: true, get: function() {
      return firstValueFrom_1.firstValueFrom;
    } });
    var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
    Object.defineProperty(exports2, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
      return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    } });
    var EmptyError_1 = require_EmptyError();
    Object.defineProperty(exports2, "EmptyError", { enumerable: true, get: function() {
      return EmptyError_1.EmptyError;
    } });
    var NotFoundError_1 = require_NotFoundError();
    Object.defineProperty(exports2, "NotFoundError", { enumerable: true, get: function() {
      return NotFoundError_1.NotFoundError;
    } });
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    Object.defineProperty(exports2, "ObjectUnsubscribedError", { enumerable: true, get: function() {
      return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
    } });
    var SequenceError_1 = require_SequenceError();
    Object.defineProperty(exports2, "SequenceError", { enumerable: true, get: function() {
      return SequenceError_1.SequenceError;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    Object.defineProperty(exports2, "UnsubscriptionError", { enumerable: true, get: function() {
      return UnsubscriptionError_1.UnsubscriptionError;
    } });
    var bindCallback_1 = require_bindCallback();
    Object.defineProperty(exports2, "bindCallback", { enumerable: true, get: function() {
      return bindCallback_1.bindCallback;
    } });
    var bindNodeCallback_1 = require_bindNodeCallback();
    Object.defineProperty(exports2, "bindNodeCallback", { enumerable: true, get: function() {
      return bindNodeCallback_1.bindNodeCallback;
    } });
    var combineLatest_1 = require_combineLatest();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var concat_1 = require_concat();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var connectable_1 = require_connectable();
    Object.defineProperty(exports2, "connectable", { enumerable: true, get: function() {
      return connectable_1.connectable;
    } });
    var defer_1 = require_defer();
    Object.defineProperty(exports2, "defer", { enumerable: true, get: function() {
      return defer_1.defer;
    } });
    var empty_1 = require_empty();
    Object.defineProperty(exports2, "empty", { enumerable: true, get: function() {
      return empty_1.empty;
    } });
    var forkJoin_1 = require_forkJoin();
    Object.defineProperty(exports2, "forkJoin", { enumerable: true, get: function() {
      return forkJoin_1.forkJoin;
    } });
    var from_1 = require_from();
    Object.defineProperty(exports2, "from", { enumerable: true, get: function() {
      return from_1.from;
    } });
    var fromEvent_1 = require_fromEvent();
    Object.defineProperty(exports2, "fromEvent", { enumerable: true, get: function() {
      return fromEvent_1.fromEvent;
    } });
    var fromEventPattern_1 = require_fromEventPattern();
    Object.defineProperty(exports2, "fromEventPattern", { enumerable: true, get: function() {
      return fromEventPattern_1.fromEventPattern;
    } });
    var generate_1 = require_generate();
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return generate_1.generate;
    } });
    var iif_1 = require_iif();
    Object.defineProperty(exports2, "iif", { enumerable: true, get: function() {
      return iif_1.iif;
    } });
    var interval_1 = require_interval();
    Object.defineProperty(exports2, "interval", { enumerable: true, get: function() {
      return interval_1.interval;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var never_1 = require_never();
    Object.defineProperty(exports2, "never", { enumerable: true, get: function() {
      return never_1.never;
    } });
    var of_1 = require_of();
    Object.defineProperty(exports2, "of", { enumerable: true, get: function() {
      return of_1.of;
    } });
    var onErrorResumeNext_1 = require_onErrorResumeNext();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNext_1.onErrorResumeNext;
    } });
    var pairs_1 = require_pairs();
    Object.defineProperty(exports2, "pairs", { enumerable: true, get: function() {
      return pairs_1.pairs;
    } });
    var partition_1 = require_partition();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var race_1 = require_race();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports2, "range", { enumerable: true, get: function() {
      return range_1.range;
    } });
    var throwError_1 = require_throwError();
    Object.defineProperty(exports2, "throwError", { enumerable: true, get: function() {
      return throwError_1.throwError;
    } });
    var timer_1 = require_timer();
    Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
      return timer_1.timer;
    } });
    var using_1 = require_using();
    Object.defineProperty(exports2, "using", { enumerable: true, get: function() {
      return using_1.using;
    } });
    var zip_1 = require_zip();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var scheduled_1 = require_scheduled();
    Object.defineProperty(exports2, "scheduled", { enumerable: true, get: function() {
      return scheduled_1.scheduled;
    } });
    var empty_2 = require_empty();
    Object.defineProperty(exports2, "EMPTY", { enumerable: true, get: function() {
      return empty_2.EMPTY;
    } });
    var never_2 = require_never();
    Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
      return never_2.NEVER;
    } });
    __exportStar(require_types(), exports2);
    var config_1 = require_config();
    Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
      return config_1.config;
    } });
    var audit_1 = require_audit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNextWith", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNextWith;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_2 = require_timeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_2.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/partition.js
var require_partition2 = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/partition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.partition = void 0;
    var not_1 = require_not();
    var filter_1 = require_filter();
    function partition(predicate, thisArg) {
      return function(source) {
        return [filter_1.filter(predicate, thisArg)(source), filter_1.filter(not_1.not(predicate, thisArg))(source)];
      };
    }
    exports2.partition = partition;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/race.js
var require_race2 = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/internal/operators/race.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports2 && exports2.__spreadArray || function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.race = void 0;
    var argsOrArgArray_1 = require_argsOrArgArray();
    var raceWith_1 = require_raceWith();
    function race() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return raceWith_1.raceWith.apply(void 0, __spreadArray2([], __read(argsOrArgArray_1.argsOrArgArray(args))));
    }
    exports2.race = race;
  }
});

// ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/operators/index.js
var require_operators = __commonJS({
  "../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/cjs/operators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mergeAll = exports2.merge = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.concat = exports2.combineLatestWith = exports2.combineLatest = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = void 0;
    exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.race = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.partition = exports2.pairwise = exports2.onErrorResumeNext = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = void 0;
    exports2.zipWith = exports2.zipAll = exports2.zip = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = void 0;
    var audit_1 = require_audit();
    Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
      return audit_1.audit;
    } });
    var auditTime_1 = require_auditTime();
    Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
      return auditTime_1.auditTime;
    } });
    var buffer_1 = require_buffer();
    Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
      return buffer_1.buffer;
    } });
    var bufferCount_1 = require_bufferCount();
    Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
      return bufferCount_1.bufferCount;
    } });
    var bufferTime_1 = require_bufferTime();
    Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
      return bufferTime_1.bufferTime;
    } });
    var bufferToggle_1 = require_bufferToggle();
    Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
      return bufferToggle_1.bufferToggle;
    } });
    var bufferWhen_1 = require_bufferWhen();
    Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
      return bufferWhen_1.bufferWhen;
    } });
    var catchError_1 = require_catchError();
    Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
      return catchError_1.catchError;
    } });
    var combineAll_1 = require_combineAll();
    Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
      return combineAll_1.combineAll;
    } });
    var combineLatestAll_1 = require_combineLatestAll();
    Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
      return combineLatestAll_1.combineLatestAll;
    } });
    var combineLatest_1 = require_combineLatest2();
    Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
      return combineLatest_1.combineLatest;
    } });
    var combineLatestWith_1 = require_combineLatestWith();
    Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
      return combineLatestWith_1.combineLatestWith;
    } });
    var concat_1 = require_concat2();
    Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var concatAll_1 = require_concatAll();
    Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
      return concatAll_1.concatAll;
    } });
    var concatMap_1 = require_concatMap();
    Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
      return concatMap_1.concatMap;
    } });
    var concatMapTo_1 = require_concatMapTo();
    Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
      return concatMapTo_1.concatMapTo;
    } });
    var concatWith_1 = require_concatWith();
    Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
      return concatWith_1.concatWith;
    } });
    var connect_1 = require_connect();
    Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
      return connect_1.connect;
    } });
    var count_1 = require_count();
    Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
      return count_1.count;
    } });
    var debounce_1 = require_debounce();
    Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
      return debounce_1.debounce;
    } });
    var debounceTime_1 = require_debounceTime();
    Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
      return debounceTime_1.debounceTime;
    } });
    var defaultIfEmpty_1 = require_defaultIfEmpty();
    Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
      return defaultIfEmpty_1.defaultIfEmpty;
    } });
    var delay_1 = require_delay();
    Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
      return delay_1.delay;
    } });
    var delayWhen_1 = require_delayWhen();
    Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
      return delayWhen_1.delayWhen;
    } });
    var dematerialize_1 = require_dematerialize();
    Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
      return dematerialize_1.dematerialize;
    } });
    var distinct_1 = require_distinct();
    Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
      return distinct_1.distinct;
    } });
    var distinctUntilChanged_1 = require_distinctUntilChanged();
    Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
      return distinctUntilChanged_1.distinctUntilChanged;
    } });
    var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
    Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
      return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
    } });
    var elementAt_1 = require_elementAt();
    Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
      return elementAt_1.elementAt;
    } });
    var endWith_1 = require_endWith();
    Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
      return endWith_1.endWith;
    } });
    var every_1 = require_every();
    Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
      return every_1.every;
    } });
    var exhaust_1 = require_exhaust();
    Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
      return exhaust_1.exhaust;
    } });
    var exhaustAll_1 = require_exhaustAll();
    Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
      return exhaustAll_1.exhaustAll;
    } });
    var exhaustMap_1 = require_exhaustMap();
    Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
      return exhaustMap_1.exhaustMap;
    } });
    var expand_1 = require_expand();
    Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
      return expand_1.expand;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
      return filter_1.filter;
    } });
    var finalize_1 = require_finalize();
    Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
      return finalize_1.finalize;
    } });
    var find_1 = require_find();
    Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
      return find_1.find;
    } });
    var findIndex_1 = require_findIndex();
    Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
      return findIndex_1.findIndex;
    } });
    var first_1 = require_first();
    Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
      return first_1.first;
    } });
    var groupBy_1 = require_groupBy();
    Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
      return groupBy_1.groupBy;
    } });
    var ignoreElements_1 = require_ignoreElements();
    Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
      return ignoreElements_1.ignoreElements;
    } });
    var isEmpty_1 = require_isEmpty();
    Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
      return isEmpty_1.isEmpty;
    } });
    var last_1 = require_last();
    Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
      return last_1.last;
    } });
    var map_1 = require_map();
    Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
      return map_1.map;
    } });
    var mapTo_1 = require_mapTo();
    Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
      return mapTo_1.mapTo;
    } });
    var materialize_1 = require_materialize();
    Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
      return materialize_1.materialize;
    } });
    var max_1 = require_max();
    Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
      return max_1.max;
    } });
    var merge_1 = require_merge2();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var mergeAll_1 = require_mergeAll();
    Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
      return mergeAll_1.mergeAll;
    } });
    var flatMap_1 = require_flatMap();
    Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
      return flatMap_1.flatMap;
    } });
    var mergeMap_1 = require_mergeMap();
    Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
      return mergeMap_1.mergeMap;
    } });
    var mergeMapTo_1 = require_mergeMapTo();
    Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
      return mergeMapTo_1.mergeMapTo;
    } });
    var mergeScan_1 = require_mergeScan();
    Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
      return mergeScan_1.mergeScan;
    } });
    var mergeWith_1 = require_mergeWith();
    Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
      return mergeWith_1.mergeWith;
    } });
    var min_1 = require_min();
    Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
      return min_1.min;
    } });
    var multicast_1 = require_multicast();
    Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
      return multicast_1.multicast;
    } });
    var observeOn_1 = require_observeOn();
    Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
      return observeOn_1.observeOn;
    } });
    var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
    Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
      return onErrorResumeNextWith_1.onErrorResumeNext;
    } });
    var pairwise_1 = require_pairwise();
    Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
      return pairwise_1.pairwise;
    } });
    var partition_1 = require_partition2();
    Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
      return partition_1.partition;
    } });
    var pluck_1 = require_pluck();
    Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
      return pluck_1.pluck;
    } });
    var publish_1 = require_publish();
    Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
      return publish_1.publish;
    } });
    var publishBehavior_1 = require_publishBehavior();
    Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
      return publishBehavior_1.publishBehavior;
    } });
    var publishLast_1 = require_publishLast();
    Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
      return publishLast_1.publishLast;
    } });
    var publishReplay_1 = require_publishReplay();
    Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
      return publishReplay_1.publishReplay;
    } });
    var race_1 = require_race2();
    Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
      return race_1.race;
    } });
    var raceWith_1 = require_raceWith();
    Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
      return raceWith_1.raceWith;
    } });
    var reduce_1 = require_reduce();
    Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
      return reduce_1.reduce;
    } });
    var repeat_1 = require_repeat();
    Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
      return repeat_1.repeat;
    } });
    var repeatWhen_1 = require_repeatWhen();
    Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
      return repeatWhen_1.repeatWhen;
    } });
    var retry_1 = require_retry();
    Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
      return retry_1.retry;
    } });
    var retryWhen_1 = require_retryWhen();
    Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
      return retryWhen_1.retryWhen;
    } });
    var refCount_1 = require_refCount();
    Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
      return refCount_1.refCount;
    } });
    var sample_1 = require_sample();
    Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
      return sample_1.sample;
    } });
    var sampleTime_1 = require_sampleTime();
    Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
      return sampleTime_1.sampleTime;
    } });
    var scan_1 = require_scan();
    Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
      return scan_1.scan;
    } });
    var sequenceEqual_1 = require_sequenceEqual();
    Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
      return sequenceEqual_1.sequenceEqual;
    } });
    var share_1 = require_share();
    Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
      return share_1.share;
    } });
    var shareReplay_1 = require_shareReplay();
    Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
      return shareReplay_1.shareReplay;
    } });
    var single_1 = require_single();
    Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
      return single_1.single;
    } });
    var skip_1 = require_skip();
    Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
      return skip_1.skip;
    } });
    var skipLast_1 = require_skipLast();
    Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
      return skipLast_1.skipLast;
    } });
    var skipUntil_1 = require_skipUntil();
    Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
      return skipUntil_1.skipUntil;
    } });
    var skipWhile_1 = require_skipWhile();
    Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
      return skipWhile_1.skipWhile;
    } });
    var startWith_1 = require_startWith();
    Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
      return startWith_1.startWith;
    } });
    var subscribeOn_1 = require_subscribeOn();
    Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
      return subscribeOn_1.subscribeOn;
    } });
    var switchAll_1 = require_switchAll();
    Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
      return switchAll_1.switchAll;
    } });
    var switchMap_1 = require_switchMap();
    Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
      return switchMap_1.switchMap;
    } });
    var switchMapTo_1 = require_switchMapTo();
    Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
      return switchMapTo_1.switchMapTo;
    } });
    var switchScan_1 = require_switchScan();
    Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
      return switchScan_1.switchScan;
    } });
    var take_1 = require_take();
    Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
      return take_1.take;
    } });
    var takeLast_1 = require_takeLast();
    Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
      return takeLast_1.takeLast;
    } });
    var takeUntil_1 = require_takeUntil();
    Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
      return takeUntil_1.takeUntil;
    } });
    var takeWhile_1 = require_takeWhile();
    Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
      return takeWhile_1.takeWhile;
    } });
    var tap_1 = require_tap();
    Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
      return tap_1.tap;
    } });
    var throttle_1 = require_throttle();
    Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
      return throttle_1.throttle;
    } });
    var throttleTime_1 = require_throttleTime();
    Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
      return throttleTime_1.throttleTime;
    } });
    var throwIfEmpty_1 = require_throwIfEmpty();
    Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
      return throwIfEmpty_1.throwIfEmpty;
    } });
    var timeInterval_1 = require_timeInterval();
    Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
      return timeInterval_1.timeInterval;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
      return timeout_1.timeout;
    } });
    var timeoutWith_1 = require_timeoutWith();
    Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
      return timeoutWith_1.timeoutWith;
    } });
    var timestamp_1 = require_timestamp();
    Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
      return timestamp_1.timestamp;
    } });
    var toArray_1 = require_toArray();
    Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
      return toArray_1.toArray;
    } });
    var window_1 = require_window();
    Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
      return window_1.window;
    } });
    var windowCount_1 = require_windowCount();
    Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
      return windowCount_1.windowCount;
    } });
    var windowTime_1 = require_windowTime();
    Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
      return windowTime_1.windowTime;
    } });
    var windowToggle_1 = require_windowToggle();
    Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
      return windowToggle_1.windowToggle;
    } });
    var windowWhen_1 = require_windowWhen();
    Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
      return windowWhen_1.windowWhen;
    } });
    var withLatestFrom_1 = require_withLatestFrom();
    Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
      return withLatestFrom_1.withLatestFrom;
    } });
    var zip_1 = require_zip2();
    Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
      return zip_1.zip;
    } });
    var zipAll_1 = require_zipAll();
    Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
      return zipAll_1.zipAll;
    } });
    var zipWith_1 = require_zipWith();
    Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
      return zipWith_1.zipWith;
    } });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js"(exports2, module2) {
    !function(t, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports2, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a2 = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a2, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D2 = {};
      D2[g] = M;
      var p = "$isDayjsObject", S2 = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D2[s2] && (i2 = s2), n2 && (D2[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a3 = e2.name;
          D2[a3] = e2, i2 = a3;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O2 = function(t2, e2) {
        if (S2(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S2, b.w = function(t2, e2) {
        return O2(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O2(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O2(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O2(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a2);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D3 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D3 : m3 + (6 - D3), M3);
            case a2:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a2] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a2 ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O2(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a2) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a3 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a3 + 1;
                case "MM":
                  return b.s(a3 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a3, c2, 3);
                case "MMMM":
                  return h2(c2, a3);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O2(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D3 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D3() / 12;
              break;
            case c:
              $2 = D3();
              break;
            case f:
              $2 = D3() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a2:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D2[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O2.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a2], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O2.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O2), t2.$i = true), O2;
      }, O2.locale = w, O2.isDayjs = S2, O2.unix = function(t2) {
        return O2(1e3 * t2);
      }, O2.en = D2[g], O2.Ls = D2, O2.p = {}, O2;
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/advancedFormat.js
var require_advancedFormat = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/advancedFormat.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_advancedFormat = t();
    }(exports2, function() {
      "use strict";
      return function(e, t) {
        var r = t.prototype, n = r.format;
        r.format = function(e2) {
          var t2 = this, r2 = this.$locale();
          if (!this.isValid()) return n.bind(this)(e2);
          var s = this.$utils(), a2 = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
            switch (e3) {
              case "Q":
                return Math.ceil((t2.$M + 1) / 3);
              case "Do":
                return r2.ordinal(t2.$D);
              case "gggg":
                return t2.weekYear();
              case "GGGG":
                return t2.isoWeekYear();
              case "wo":
                return r2.ordinal(t2.week(), "W");
              case "w":
              case "ww":
                return s.s(t2.week(), "w" === e3 ? 1 : 2, "0");
              case "W":
              case "WW":
                return s.s(t2.isoWeek(), "W" === e3 ? 1 : 2, "0");
              case "k":
              case "kk":
                return s.s(String(0 === t2.$H ? 24 : t2.$H), "k" === e3 ? 1 : 2, "0");
              case "X":
                return Math.floor(t2.$d.getTime() / 1e3);
              case "x":
                return t2.$d.getTime();
              case "z":
                return "[" + t2.offsetName() + "]";
              case "zzz":
                return "[" + t2.offsetName("long") + "]";
              default:
                return e3;
            }
          });
          return n.bind(this)(a2);
        };
      };
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/customParseFormat.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
    }(exports2, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a2 = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var f = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3) return 0;
          if ("Z" === e3) return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], u = function(e2) {
        var t2 = s[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, d = function(e2, t2) {
        var n2, r2 = s.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1) if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
        } else n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, c = { A: [o, function(e2) {
        this.afternoon = d(e2, false);
      }], a: [o, function(e2) {
        this.afternoon = d(e2, true);
      }], Q: [n, function(e2) {
        this.month = 3 * (e2 - 1) + 1;
      }], S: [n, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [r, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
        var t2 = s.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2) for (var r2 = 1; r2 <= 31; r2 += 1) t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
        var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1) throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [o, function(e2) {
        var t2 = u("months").indexOf(e2) + 1;
        if (t2 < 1) throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
        this.year = a2(e2);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l(n2) {
        var r2, i2;
        r2 = n2, i2 = s && s.formats;
        for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a3 = o2.length, f2 = 0; f2 < a3; f2 += 1) {
          var h2 = o2[f2], u2 = c[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
          o2[f2] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a3; n3 += 1) {
            var i3 = o2[n3];
            if ("string" == typeof i3) r3 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a2 = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
          this.$u = r3;
          var a3 = o2[1];
          if ("string" == typeof a3) {
            var f2 = true === o2[2], h2 = true === o2[3], u2 = f2 || h2, d2 = o2[2];
            h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
              try {
                if (["x", "X"].indexOf(t4) > -1) return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a4 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a4 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
                o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D2, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D2 = new Date(p, v, Y, w, g, y, L), m2 && (D2 = r4(D2).week(m2).toDate()), D2);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a3, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a3) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a3 instanceof Array) for (var c2 = a3.length, m = 1; m <= c2; m += 1) {
            o2[1] = a3[m - 1];
            var M = n2.apply(this, o2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else i2.call(this, e3);
        };
      };
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/localeData.js
var require_localeData = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/localeData.js"(exports2, module2) {
    !function(n, e) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (n = "undefined" != typeof globalThis ? globalThis : n || self).dayjs_plugin_localeData = e();
    }(exports2, function() {
      "use strict";
      return function(n, e, t) {
        var r = e.prototype, o = function(n2) {
          return n2 && (n2.indexOf ? n2 : n2.s);
        }, u = function(n2, e2, t2, r2, u2) {
          var i2 = n2.name ? n2 : n2.$locale(), a3 = o(i2[e2]), s2 = o(i2[t2]), f = a3 || s2.map(function(n3) {
            return n3.slice(0, r2);
          });
          if (!u2) return f;
          var d = i2.weekStart;
          return f.map(function(n3, e3) {
            return f[(e3 + (d || 0)) % 7];
          });
        }, i = function() {
          return t.Ls[t.locale()];
        }, a2 = function(n2, e2) {
          return n2.formats[e2] || function(n3) {
            return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
              return e3 || t2.slice(1);
            });
          }(n2.formats[e2.toUpperCase()]);
        }, s = function() {
          var n2 = this;
          return { months: function(e2) {
            return e2 ? e2.format("MMMM") : u(n2, "months");
          }, monthsShort: function(e2) {
            return e2 ? e2.format("MMM") : u(n2, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return n2.$locale().weekStart || 0;
          }, weekdays: function(e2) {
            return e2 ? e2.format("dddd") : u(n2, "weekdays");
          }, weekdaysMin: function(e2) {
            return e2 ? e2.format("dd") : u(n2, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(e2) {
            return e2 ? e2.format("ddd") : u(n2, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(e2) {
            return a2(n2.$locale(), e2);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        r.localeData = function() {
          return s.bind(this)();
        }, t.localeData = function() {
          var n2 = i();
          return { firstDayOfWeek: function() {
            return n2.weekStart || 0;
          }, weekdays: function() {
            return t.weekdays();
          }, weekdaysShort: function() {
            return t.weekdaysShort();
          }, weekdaysMin: function() {
            return t.weekdaysMin();
          }, months: function() {
            return t.months();
          }, monthsShort: function() {
            return t.monthsShort();
          }, longDateFormat: function(e2) {
            return a2(n2, e2);
          }, meridiem: n2.meridiem, ordinal: n2.ordinal };
        }, t.months = function() {
          return u(i(), "months");
        }, t.monthsShort = function() {
          return u(i(), "monthsShort", "months", 3);
        }, t.weekdays = function(n2) {
          return u(i(), "weekdays", null, null, n2);
        }, t.weekdaysShort = function(n2) {
          return u(i(), "weekdaysShort", "weekdays", 3, n2);
        }, t.weekdaysMin = function(n2) {
          return u(i(), "weekdaysMin", "weekdays", 2, n2);
        };
      };
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/localizedFormat.js
var require_localizedFormat = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/localizedFormat.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_localizedFormat = t();
    }(exports2, function() {
      "use strict";
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
      return function(t, o, n) {
        var r = o.prototype, i = r.format;
        n.en.formats = e, r.format = function(t2) {
          void 0 === t2 && (t2 = "YYYY-MM-DDTHH:mm:ssZ");
          var o2 = this.$locale().formats, n2 = function(t3, o3) {
            return t3.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t4, n3, r2) {
              var i2 = r2 && r2.toUpperCase();
              return n3 || o3[r2] || e[r2] || o3[i2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t5, o4) {
                return t5 || o4.slice(1);
              });
            });
          }(t2, void 0 === o2 ? {} : o2);
          return i.call(this, n2);
        };
      };
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/utc.js"(exports2, module2) {
    !function(t, i) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_utc = i();
    }(exports2, function() {
      "use strict";
      var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
      return function(s, f, n) {
        var u = f.prototype;
        n.utc = function(t2) {
          var i2 = { date: t2, utc: true, args: arguments };
          return new f(i2);
        }, u.utc = function(i2) {
          var e2 = n(this.toDate(), { locale: this.$L, utc: true });
          return i2 ? e2.add(this.utcOffset(), t) : e2;
        }, u.local = function() {
          return n(this.toDate(), { locale: this.$L, utc: false });
        };
        var o = u.parse;
        u.parse = function(t2) {
          t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
        };
        var r = u.init;
        u.init = function() {
          if (this.$u) {
            var t2 = this.$d;
            this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
          } else r.call(this);
        };
        var a2 = u.utcOffset;
        u.utcOffset = function(s2, f2) {
          var n2 = this.$utils().u;
          if (n2(s2)) return this.$u ? 0 : n2(this.$offset) ? a2.call(this) : this.$offset;
          if ("string" == typeof s2 && (s2 = function(t2) {
            void 0 === t2 && (t2 = "");
            var s3 = t2.match(i);
            if (!s3) return null;
            var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
            return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
          }(s2), null === s2)) return this;
          var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
          if (f2) return o2.$offset = u2, o2.$u = 0 === s2, o2;
          if (0 !== s2) {
            var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
          } else o2 = this.utc();
          return o2;
        };
        var h = u.format;
        u.format = function(t2) {
          var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h.call(this, i2);
        }, u.valueOf = function() {
          var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t2;
        }, u.isUTC = function() {
          return !!this.$u;
        }, u.toISOString = function() {
          return this.toDate().toISOString();
        }, u.toString = function() {
          return this.toDate().toUTCString();
        };
        var l = u.toDate;
        u.toDate = function(t2) {
          return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
        };
        var c = u.diff;
        u.diff = function(t2, i2, e2) {
          if (t2 && this.$u === t2.$u) return c.call(this, t2, i2, e2);
          var s2 = this.local(), f2 = n(t2).local();
          return c.call(s2, f2, i2, e2);
        };
      };
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/weekday.js
var require_weekday = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/weekday.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekday = t();
    }(exports2, function() {
      "use strict";
      return function(e, t) {
        t.prototype.weekday = function(e2) {
          var t2 = this.$locale().weekStart || 0, i = this.$W, n = (i < t2 ? i + 7 : i) - t2;
          return this.$utils().u(e2) ? n : this.subtract(n, "day").add(e2, "day");
        };
      };
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/weekOfYear.js
var require_weekOfYear = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/weekOfYear.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekOfYear = t();
    }(exports2, function() {
      "use strict";
      var e = "week", t = "year";
      return function(i, n, r) {
        var f = n.prototype;
        f.week = function(i2) {
          if (void 0 === i2 && (i2 = null), null !== i2) return this.add(7 * (i2 - this.week()), "day");
          var n2 = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f2 = r(this).startOf(t).add(1, t).date(n2), s = r(this).endOf(e);
            if (f2.isBefore(s)) return 1;
          }
          var a2 = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o = this.diff(a2, e, true);
          return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
        }, f.weeks = function(e2) {
          return void 0 === e2 && (e2 = null), this.week(e2);
        };
      };
    });
  }
});

// ../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/weekYear.js
var require_weekYear = __commonJS({
  "../node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/plugin/weekYear.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "undefined" != typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_weekYear = t();
    }(exports2, function() {
      "use strict";
      return function(e, t) {
        t.prototype.weekYear = function() {
          var e2 = this.month(), t2 = this.week(), n = this.year();
          return 1 === t2 && 11 === e2 ? n + 1 : 0 === e2 && t2 >= 52 ? n - 1 : n;
        };
      };
    });
  }
});

// ../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/numfmt.js
var require_numfmt = __commonJS({
  "../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/numfmt.js"(exports2, module2) {
    !function(e, t) {
      "object" == typeof exports2 && "object" == typeof module2 ? module2.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports2 ? exports2.numfmt = t() : e.numfmt = t();
    }("undefined" != typeof self ? self : exports2, function() {
      return function() {
        "use strict";
        var e = { d: function(t2, n2) {
          for (var a3 in n2) e.o(n2, a3) && !e.o(t2, a3) && Object.defineProperty(t2, a3, { enumerable: true, get: n2[a3] });
        }, o: function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        } }, t = {};
        e.d(t, { default: function() {
          return pe;
        } });
        var n = { 1078: "af", 1052: "sq", 1118: "am", 5121: "ar_DZ", 15361: "ar_BH", 3073: "ar_EG", 2049: "ar_IQ", 11265: "ar_JO", 13313: "ar_KW", 12289: "ar_LB", 4097: "ar_LY", 6145: "ar_MA", 8193: "ar_OM", 16385: "ar_QA", 1025: "ar_SA", 10241: "ar_SY", 7169: "ar_TN", 14337: "ar_AE", 9217: "ar_YE", 1067: "hy", 1101: "as", 2092: "az_AZ", 1068: "az_AZ", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn_IN", 5146: "bs", 1026: "bg", 1109: "my", 1027: "ca", 2052: "zh_CN", 3076: "zh_HK", 5124: "zh_MO", 4100: "zh_SG", 1028: "zh_TW", 1050: "hr", 1029: "cs", 1030: "da", 1125: "dv", 2067: "nl_BE", 1043: "nl_NL", 1126: "bin", 3081: "en_AU", 10249: "en_BZ", 4105: "en_CA", 9225: "en_CB", 2057: "en_GB", 16393: "en_IN", 6153: "en_IE", 8201: "en_JM", 5129: "en_NZ", 13321: "en_PH", 7177: "en_ZA", 11273: "en_TT", 1033: "en_US", 12297: "en_ZW", 1061: "et", 1071: "mk", 1080: "fo", 1065: "fa", 1124: "fil", 1035: "fi", 2060: "fr_BE", 11276: "fr_CM", 3084: "fr_CA", 9228: "fr_CG", 12300: "fr_CI", 1036: "fr_FR", 5132: "fr_LU", 13324: "fr_ML", 6156: "fr_MC", 14348: "fr_MA", 10252: "fr_SN", 4108: "fr_CH", 7180: "fr", 1122: "fy_NL", 2108: "gd_IE", 1084: "gd", 1110: "gl", 1079: "ka", 3079: "de_AT", 1031: "de_DE", 5127: "de_LI", 4103: "de_LU", 2055: "de_CH", 1032: "el", 1140: "gn", 1095: "gu", 1279: "en", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig_NG", 1057: "id", 1040: "it_IT", 2064: "it_CH", 1041: "ja", 1099: "kn", 1120: "ks", 1087: "kk", 1107: "km", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1142: "la", 1062: "lv", 1063: "lt", 2110: "ms_BN", 1086: "ms_MY", 1100: "ml", 1082: "mt", 1112: "mni", 1153: "mi", 1102: "mr", 1104: "mn", 2128: "mn", 1121: "ne", 1044: "no_NO", 2068: "no_NO", 1096: "or", 1045: "pl", 1046: "pt_BR", 2070: "pt_PT", 1094: "pa", 1047: "rm", 2072: "ro_MO", 1048: "ro_RO", 1049: "ru", 2073: "ru_MO", 1083: "se", 1103: "sa", 3098: "sr_SP", 2074: "sr_SP", 1072: "st", 1074: "tn", 1113: "sd", 1115: "si", 1051: "sk", 1060: "sl", 1143: "so", 1070: "sb", 11274: "es_AR", 16394: "es_BO", 13322: "es_CL", 9226: "es_CO", 5130: "es_CR", 7178: "es_DO", 12298: "es_EC", 17418: "es_SV", 4106: "es_GT", 18442: "es_HN", 2058: "es_MX", 19466: "es_NI", 6154: "es_PA", 15370: "es_PY", 10250: "es_PE", 20490: "es_PR", 1034: "es_ES", 14346: "es_UY", 8202: "es_VE", 1089: "sw", 2077: "sv_FI", 1053: "sv_SE", 1114: "syc", 1064: "tg", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1073: "ts", 1055: "tr", 1090: "tk", 1058: "uk", 1056: "ur", 2115: "uz_UZ", 1091: "uz_UZ", 1075: "ve", 1066: "vi", 1106: "cy", 1076: "xh", 1085: "yi", 1077: "zu" };
        const a2 = /^([a-z\d]+)(?:[_-]([a-z\d]+))?(?:\.([a-z\d]+))?(?:@([a-z\d]+))?$/i, r = {}, i = { group: "\xA0", decimal: ".", positive: "+", negative: "-", percent: "%", exponent: "E", nan: "NaN", infinity: "\u221E", ampm: ["AM", "PM"], mmmm6: ["Muharram", "Safar", "Rabi\u02BB I", "Rabi\u02BB II", "Jumada I", "Jumada II", "Rajab", "Sha\u02BBban", "Ramadan", "Shawwal", "Dhu\u02BBl-Qi\u02BBdah", "Dhu\u02BBl-Hijjah"], mmm6: ["Muh.", "Saf.", "Rab. I", "Rab. II", "Jum. I", "Jum. II", "Raj.", "Sha.", "Ram.", "Shaw.", "Dhu\u02BBl-Q.", "Dhu\u02BBl-H."], mmmm: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], mmm: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dddd: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ddd: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] };
        function s(e2) {
          const t2 = a2.exec(e2);
          if (!t2) throw new SyntaxError("Malformed locale: ".concat(e2));
          return { lang: t2[1] + (t2[2] ? "_" + t2[2] : ""), language: t2[1], territory: t2[2] || "", codeset: t2[3] || "", modifier: t2[4] || "" };
        }
        function o(e2) {
          if ("number" == typeof e2) return n[65535 & e2] || null;
          const t2 = parseInt(e2, 16);
          return isFinite(t2) && n[65535 & t2] ? n[65535 & t2] || null : a2.test(e2) ? e2 : null;
        }
        function l(e2) {
          const t2 = o(e2);
          let n2 = null;
          if (t2) {
            const e3 = s(t2);
            n2 = r[e3.lang] || r[e3.language] || null;
          }
          return n2;
        }
        function d(e2) {
          return Object.assign({}, i, e2);
        }
        function m(e2, t2) {
          const n2 = "object" == typeof t2 ? t2 : s(t2);
          return r[n2.lang] = d(e2), n2.language === n2.lang || r[n2.language] || (r[n2.language] = d(e2)), r[n2.lang];
        }
        const u = d({ group: "," });
        function c(e2, t2) {
          if ("number" != typeof e2) return e2;
          if (e2 < 0) return -c(-e2, t2);
          if (t2) {
            const n2 = 10 ** (t2 || 0) || 1;
            return c(e2 * n2, 0) / n2;
          }
          return Math.round(e2);
        }
        u.isDefault = true, m({ group: ",", ampm: ["\u4E0A\u5348", "\u4E0B\u5348"], mmmm: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"], mmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], dddd: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], ddd: ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"] }, "zh_CN"), m({ group: ",", nan: "\u975E\u6578\u503C", ampm: ["\u4E0A\u5348", "\u4E0B\u5348"], mmmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], mmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], dddd: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], ddd: ["\u9031\u65E5", "\u9031\u4E00", "\u9031\u4E8C", "\u9031\u4E09", "\u9031\u56DB", "\u9031\u4E94", "\u9031\u516D"] }, "zh_TW"), m({ group: ",", ampm: ["\u5348\u524D", "\u5348\u5F8C"], mmmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], mmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], dddd: ["\u65E5\u66DC\u65E5", "\u6708\u66DC\u65E5", "\u706B\u66DC\u65E5", "\u6C34\u66DC\u65E5", "\u6728\u66DC\u65E5", "\u91D1\u66DC\u65E5", "\u571F\u66DC\u65E5"], ddd: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"] }, "ja"), m({ group: ",", ampm: ["\uC624\uC804", "\uC624\uD6C4"], mmmm: ["1\uC6D4", "2\uC6D4", "3\uC6D4", "4\uC6D4", "5\uC6D4", "6\uC6D4", "7\uC6D4", "8\uC6D4", "9\uC6D4", "10\uC6D4", "11\uC6D4", "12\uC6D4"], mmm: ["1\uC6D4", "2\uC6D4", "3\uC6D4", "4\uC6D4", "5\uC6D4", "6\uC6D4", "7\uC6D4", "8\uC6D4", "9\uC6D4", "10\uC6D4", "11\uC6D4", "12\uC6D4"], dddd: ["\uC77C\uC694\uC77C", "\uC6D4\uC694\uC77C", "\uD654\uC694\uC77C", "\uC218\uC694\uC77C", "\uBAA9\uC694\uC77C", "\uAE08\uC694\uC77C", "\uD1A0\uC694\uC77C"], ddd: ["\uC77C", "\uC6D4", "\uD654", "\uC218", "\uBAA9", "\uAE08", "\uD1A0"] }, "ko"), m({ group: ",", ampm: ["\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07", "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07"], mmmm: ["\u0E21\u0E01\u0E23\u0E32\u0E04\u0E21", "\u0E01\u0E38\u0E21\u0E20\u0E32\u0E1E\u0E31\u0E19\u0E18\u0E4C", "\u0E21\u0E35\u0E19\u0E32\u0E04\u0E21", "\u0E40\u0E21\u0E29\u0E32\u0E22\u0E19", "\u0E1E\u0E24\u0E29\u0E20\u0E32\u0E04\u0E21", "\u0E21\u0E34\u0E16\u0E38\u0E19\u0E32\u0E22\u0E19", "\u0E01\u0E23\u0E01\u0E0E\u0E32\u0E04\u0E21", "\u0E2A\u0E34\u0E07\u0E2B\u0E32\u0E04\u0E21", "\u0E01\u0E31\u0E19\u0E22\u0E32\u0E22\u0E19", "\u0E15\u0E38\u0E25\u0E32\u0E04\u0E21", "\u0E1E\u0E24\u0E28\u0E08\u0E34\u0E01\u0E32\u0E22\u0E19", "\u0E18\u0E31\u0E19\u0E27\u0E32\u0E04\u0E21"], mmm: ["\u0E21.\u0E04.", "\u0E01.\u0E1E.", "\u0E21\u0E35.\u0E04.", "\u0E40\u0E21.\u0E22.", "\u0E1E.\u0E04.", "\u0E21\u0E34.\u0E22.", "\u0E01.\u0E04.", "\u0E2A.\u0E04.", "\u0E01.\u0E22.", "\u0E15.\u0E04.", "\u0E1E.\u0E22.", "\u0E18.\u0E04."], dddd: ["\u0E27\u0E31\u0E19\u0E2D\u0E32\u0E17\u0E34\u0E15\u0E22\u0E4C", "\u0E27\u0E31\u0E19\u0E08\u0E31\u0E19\u0E17\u0E23\u0E4C", "\u0E27\u0E31\u0E19\u0E2D\u0E31\u0E07\u0E04\u0E32\u0E23", "\u0E27\u0E31\u0E19\u0E1E\u0E38\u0E18", "\u0E27\u0E31\u0E19\u0E1E\u0E24\u0E2B\u0E31\u0E2A\u0E1A\u0E14\u0E35", "\u0E27\u0E31\u0E19\u0E28\u0E38\u0E01\u0E23\u0E4C", "\u0E27\u0E31\u0E19\u0E40\u0E2A\u0E32\u0E23\u0E4C"], ddd: ["\u0E2D\u0E32.", "\u0E08.", "\u0E2D.", "\u0E1E.", "\u0E1E\u0E24.", "\u0E28.", "\u0E2A."] }, "th"), m({ decimal: ",", ampm: ["dop.", "odp."], mmmm: ["ledna", "\xFAnora", "b\u0159ezna", "dubna", "kv\u011Btna", "\u010Dervna", "\u010Dervence", "srpna", "z\xE1\u0159\xED", "\u0159\xEDjna", "listopadu", "prosince"], mmm: ["led", "\xFAno", "b\u0159e", "dub", "kv\u011B", "\u010Dvn", "\u010Dvc", "srp", "z\xE1\u0159", "\u0159\xEDj", "lis", "pro"], dddd: ["ned\u011Ble", "pond\u011Bl\xED", "\xFAter\xFD", "st\u0159eda", "\u010Dtvrtek", "p\xE1tek", "sobota"], ddd: ["ne", "po", "\xFAt", "st", "\u010Dt", "p\xE1", "so"] }, "cs"), m({ group: ".", decimal: ",", mmmm: ["januar", "februar", "marts", "april", "maj", "juni", "juli", "august", "september", "oktober", "november", "december"], mmm: ["jan.", "feb.", "mar.", "apr.", "maj", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "dec."], dddd: ["s\xF8ndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "l\xF8rdag"], ddd: ["s\xF8n.", "man.", "tir.", "ons.", "tor.", "fre.", "l\xF8r."] }, "da"), m({ group: ".", decimal: ",", ampm: ["a.m.", "p.m."], mmmm: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"], mmm: ["jan.", "feb.", "mrt.", "apr.", "mei", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "dec."], dddd: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"], ddd: ["zo", "ma", "di", "wo", "do", "vr", "za"] }, "nl"), m({ group: "," }, "en"), m({ decimal: ",", nan: "ep\xE4luku", ampm: ["ap.", "ip."], mmmm: ["tammikuuta", "helmikuuta", "maaliskuuta", "huhtikuuta", "toukokuuta", "kes\xE4kuuta", "hein\xE4kuuta", "elokuuta", "syyskuuta", "lokakuuta", "marraskuuta", "joulukuuta"], mmm: ["tammik.", "helmik.", "maalisk.", "huhtik.", "toukok.", "kes\xE4k.", "hein\xE4k.", "elok.", "syysk.", "lokak.", "marrask.", "jouluk."], dddd: ["sunnuntaina", "maanantaina", "tiistaina", "keskiviikkona", "torstaina", "perjantaina", "lauantaina"], ddd: ["su", "ma", "ti", "ke", "to", "pe", "la"] }, "fi"), m({ group: "\u202F", decimal: ",", mmmm: ["janvier", "f\xE9vrier", "mars", "avril", "mai", "juin", "juillet", "ao\xFBt", "septembre", "octobre", "novembre", "d\xE9cembre"], mmm: ["janv.", "f\xE9vr.", "mars", "avr.", "mai", "juin", "juil.", "ao\xFBt", "sept.", "oct.", "nov.", "d\xE9c."], dddd: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"], ddd: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."] }, "fr"), m({ group: ".", decimal: ",", mmmm: ["Januar", "Februar", "M\xE4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], mmm: ["Jan.", "Feb.", "M\xE4rz", "Apr.", "Mai", "Juni", "Juli", "Aug.", "Sept.", "Okt.", "Nov.", "Dez."], dddd: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"], ddd: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."] }, "de"), m({ group: ".", decimal: ",", ampm: ["\u03C0.\u03BC.", "\u03BC.\u03BC."], mmmm: ["\u0399\u03B1\u03BD\u03BF\u03C5\u03B1\u03C1\u03AF\u03BF\u03C5", "\u03A6\u03B5\u03B2\u03C1\u03BF\u03C5\u03B1\u03C1\u03AF\u03BF\u03C5", "\u039C\u03B1\u03C1\u03C4\u03AF\u03BF\u03C5", "\u0391\u03C0\u03C1\u03B9\u03BB\u03AF\u03BF\u03C5", "\u039C\u03B1\u0390\u03BF\u03C5", "\u0399\u03BF\u03C5\u03BD\u03AF\u03BF\u03C5", "\u0399\u03BF\u03C5\u03BB\u03AF\u03BF\u03C5", "\u0391\u03C5\u03B3\u03BF\u03CD\u03C3\u03C4\u03BF\u03C5", "\u03A3\u03B5\u03C0\u03C4\u03B5\u03BC\u03B2\u03C1\u03AF\u03BF\u03C5", "\u039F\u03BA\u03C4\u03C9\u03B2\u03C1\u03AF\u03BF\u03C5", "\u039D\u03BF\u03B5\u03BC\u03B2\u03C1\u03AF\u03BF\u03C5", "\u0394\u03B5\u03BA\u03B5\u03BC\u03B2\u03C1\u03AF\u03BF\u03C5"], mmm: ["\u0399\u03B1\u03BD", "\u03A6\u03B5\u03B2", "\u039C\u03B1\u03C1", "\u0391\u03C0\u03C1", "\u039C\u03B1\u0390", "\u0399\u03BF\u03C5\u03BD", "\u0399\u03BF\u03C5\u03BB", "\u0391\u03C5\u03B3", "\u03A3\u03B5\u03C0", "\u039F\u03BA\u03C4", "\u039D\u03BF\u03B5", "\u0394\u03B5\u03BA"], dddd: ["\u039A\u03C5\u03C1\u03B9\u03B1\u03BA\u03AE", "\u0394\u03B5\u03C5\u03C4\u03AD\u03C1\u03B1", "\u03A4\u03C1\u03AF\u03C4\u03B7", "\u03A4\u03B5\u03C4\u03AC\u03C1\u03C4\u03B7", "\u03A0\u03AD\u03BC\u03C0\u03C4\u03B7", "\u03A0\u03B1\u03C1\u03B1\u03C3\u03BA\u03B5\u03C5\u03AE", "\u03A3\u03AC\u03B2\u03B2\u03B1\u03C4\u03BF"], ddd: ["\u039A\u03C5\u03C1", "\u0394\u03B5\u03C5", "\u03A4\u03C1\u03AF", "\u03A4\u03B5\u03C4", "\u03A0\u03AD\u03BC", "\u03A0\u03B1\u03C1", "\u03A3\u03AC\u03B2"] }, "el"), m({ decimal: ",", ampm: ["de.", "du."], mmmm: ["janu\xE1r", "febru\xE1r", "m\xE1rcius", "\xE1prilis", "m\xE1jus", "j\xFAnius", "j\xFAlius", "augusztus", "szeptember", "okt\xF3ber", "november", "december"], mmm: ["jan.", "febr.", "m\xE1rc.", "\xE1pr.", "m\xE1j.", "j\xFAn.", "j\xFAl.", "aug.", "szept.", "okt.", "nov.", "dec."], dddd: ["vas\xE1rnap", "h\xE9tf\u0151", "kedd", "szerda", "cs\xFCt\xF6rt\xF6k", "p\xE9ntek", "szombat"], ddd: ["V", "H", "K", "Sze", "Cs", "P", "Szo"] }, "hu"), m({ group: ".", decimal: ",", ampm: ["f.h.", "e.h."], mmmm: ["jan\xFAar", "febr\xFAar", "mars", "apr\xEDl", "ma\xED", "j\xFAn\xED", "j\xFAl\xED", "\xE1g\xFAst", "september", "okt\xF3ber", "n\xF3vember", "desember"], mmm: ["jan.", "feb.", "mar.", "apr.", "ma\xED", "j\xFAn.", "j\xFAl.", "\xE1g\xFA.", "sep.", "okt.", "n\xF3v.", "des."], dddd: ["sunnudagur", "m\xE1nudagur", "\xFEri\xF0judagur", "mi\xF0vikudagur", "fimmtudagur", "f\xF6studagur", "laugardagur"], ddd: ["sun.", "m\xE1n.", "\xFEri.", "mi\xF0.", "fim.", "f\xF6s.", "lau."] }, "is"), m({ group: ".", decimal: ",", mmmm: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"], mmm: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agu", "Sep", "Okt", "Nov", "Des"], dddd: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"], ddd: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"] }, "id"), m({ group: ".", decimal: ",", mmmm: ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"], mmm: ["gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"], dddd: ["domenica", "luned\xEC", "marted\xEC", "mercoled\xEC", "gioved\xEC", "venerd\xEC", "sabato"], ddd: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"] }, "it"), m({ decimal: ",", ampm: ["a.m.", "p.m."], mmmm: ["januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember"], mmm: ["jan.", "feb.", "mar.", "apr.", "mai", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "des."], dddd: ["s\xF8ndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "l\xF8rdag"], ddd: ["s\xF8n.", "man.", "tir.", "ons.", "tor.", "fre.", "l\xF8r."] }, "nb"), m({ decimal: ",", mmmm: ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "wrze\u015Bnia", "pa\u017Adziernika", "listopada", "grudnia"], mmm: ["sty", "lut", "mar", "kwi", "maj", "cze", "lip", "sie", "wrz", "pa\u017A", "lis", "gru"], dddd: ["niedziela", "poniedzia\u0142ek", "wtorek", "\u015Broda", "czwartek", "pi\u0105tek", "sobota"], ddd: ["niedz.", "pon.", "wt.", "\u015Br.", "czw.", "pt.", "sob."] }, "pl"), m({ group: ".", decimal: ",", mmmm: ["janeiro", "fevereiro", "mar\xE7o", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"], mmm: ["jan.", "fev.", "mar.", "abr.", "mai.", "jun.", "jul.", "ago.", "set.", "out.", "nov.", "dez."], dddd: ["domingo", "segunda-feira", "ter\xE7a-feira", "quarta-feira", "quinta-feira", "sexta-feira", "s\xE1bado"], ddd: ["dom.", "seg.", "ter.", "qua.", "qui.", "sex.", "s\xE1b."] }, "pt"), m({ decimal: ",", nan: "\u043D\u0435\xA0\u0447\u0438\u0441\u043B\u043E", mmmm: ["\u044F\u043D\u0432\u0430\u0440\u044F", "\u0444\u0435\u0432\u0440\u0430\u043B\u044F", "\u043C\u0430\u0440\u0442\u0430", "\u0430\u043F\u0440\u0435\u043B\u044F", "\u043C\u0430\u044F", "\u0438\u044E\u043D\u044F", "\u0438\u044E\u043B\u044F", "\u0430\u0432\u0433\u0443\u0441\u0442\u0430", "\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F", "\u043E\u043A\u0442\u044F\u0431\u0440\u044F", "\u043D\u043E\u044F\u0431\u0440\u044F", "\u0434\u0435\u043A\u0430\u0431\u0440\u044F"], mmm: ["\u044F\u043D\u0432.", "\u0444\u0435\u0432\u0440.", "\u043C\u0430\u0440.", "\u0430\u043F\u0440.", "\u043C\u0430\u044F", "\u0438\u044E\u043D.", "\u0438\u044E\u043B.", "\u0430\u0432\u0433.", "\u0441\u0435\u043D\u0442.", "\u043E\u043A\u0442.", "\u043D\u043E\u044F\u0431.", "\u0434\u0435\u043A."], dddd: ["\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0432\u0442\u043E\u0440\u043D\u0438\u043A", "\u0441\u0440\u0435\u0434\u0430", "\u0447\u0435\u0442\u0432\u0435\u0440\u0433", "\u043F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0441\u0443\u0431\u0431\u043E\u0442\u0430"], ddd: ["\u0432\u0441", "\u043F\u043D", "\u0432\u0442", "\u0441\u0440", "\u0447\u0442", "\u043F\u0442", "\u0441\u0431"] }, "ru"), m({ decimal: ",", mmmm: ["janu\xE1ra", "febru\xE1ra", "marca", "apr\xEDla", "m\xE1ja", "j\xFAna", "j\xFAla", "augusta", "septembra", "okt\xF3bra", "novembra", "decembra"], mmm: ["jan", "feb", "mar", "apr", "m\xE1j", "j\xFAn", "j\xFAl", "aug", "sep", "okt", "nov", "dec"], dddd: ["nede\u013Ea", "pondelok", "utorok", "streda", "\u0161tvrtok", "piatok", "sobota"], ddd: ["ne", "po", "ut", "st", "\u0161t", "pi", "so"] }, "sk"), m({ group: ".", decimal: ",", ampm: ["a.\xA0m.", "p.\xA0m."], mmmm: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"], mmm: ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sept.", "oct.", "nov.", "dic."], dddd: ["domingo", "lunes", "martes", "mi\xE9rcoles", "jueves", "viernes", "s\xE1bado"], ddd: ["dom.", "lun.", "mar.", "mi\xE9.", "jue.", "vie.", "s\xE1b."] }, "es"), m({ decimal: ",", ampm: ["fm", "em"], mmmm: ["januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december"], mmm: ["jan.", "feb.", "mars", "apr.", "maj", "juni", "juli", "aug.", "sep.", "okt.", "nov.", "dec."], dddd: ["s\xF6ndag", "m\xE5ndag", "tisdag", "onsdag", "torsdag", "fredag", "l\xF6rdag"], ddd: ["s\xF6n", "m\xE5n", "tis", "ons", "tors", "fre", "l\xF6r"] }, "sv"), m({ group: ".", decimal: ",", ampm: ["\xD6\xD6", "\xD6S"], mmmm: ["Ocak", "\u015Eubat", "Mart", "Nisan", "May\u0131s", "Haziran", "Temmuz", "A\u011Fustos", "Eyl\xFCl", "Ekim", "Kas\u0131m", "Aral\u0131k"], mmm: ["Oca", "\u015Eub", "Mar", "Nis", "May", "Haz", "Tem", "A\u011Fu", "Eyl", "Eki", "Kas", "Ara"], dddd: ["Pazar", "Pazartesi", "Sal\u0131", "\xC7ar\u015Famba", "Per\u015Fembe", "Cuma", "Cumartesi"], ddd: ["Paz", "Pzt", "Sal", "\xC7ar", "Per", "Cum", "Cmt"] }, "tr");
        function p(e2, t2, n2) {
          const a3 = e2 < 0 ? -1 : 1, r2 = 10 ** (t2 || 2), i2 = 10 ** (n2 || 2);
          let s2, o2, l2 = Math.abs(e2), d2 = 0, m2 = 0, u2 = 0, c2 = 1;
          if ((e2 = l2) % 1 == 0) o2 = [e2 * a3, 1];
          else if (e2 < 1e-19) o2 = [a3, 1e19];
          else if (e2 > 1e19) o2 = [1e19 * a3, 1];
          else {
            do {
              if (l2 = 1 / (l2 - Math.floor(l2)), s2 = c2, c2 = c2 * Math.floor(l2) + d2, d2 = s2, m2 = u2, u2 = Math.floor(e2 * c2 + 0.5), u2 >= r2 || c2 >= i2) return [a3 * m2, d2];
            } while (Math.abs(e2 - u2 / c2) >= 1e-10 && l2 !== Math.floor(l2));
            o2 = [a3 * u2, c2];
          }
          return o2;
        }
        const f = { overflow: "######", dateErrorThrows: false, dateErrorNumber: true, dateSpanLarge: true, leap1900: true, nbsp: true, throws: true, invalid: "######", locale: "", ignoreTimezone: false }, g = Object.assign({}, f);
        function h(e2) {
          if (null === e2 && (e2 = f), e2) {
            for (const t2 in e2) if (t2 in f) {
              const n2 = e2[t2];
              g[t2] = null == n2 ? f[t2] : n2;
            }
          }
          return { ...g };
        }
        const y = { "#": "", 0: "0", "?": "\xA0" }, _ = { "@": "text", "-": "minus", "+": "plus" }, b = ["#000", "#FFF", "#F00", "#0F0", "#00F", "#FF0", "#F0F", "#0FF", "#000", "#FFF", "#F00", "#0F0", "#00F", "#FF0", "#F0F", "#0FF", "#800", "#080", "#008", "#880", "#808", "#088", "#CCC", "#888", "#99F", "#936", "#FFC", "#CFF", "#606", "#F88", "#06C", "#CCF", "#008", "#F0F", "#FF0", "#0FF", "#808", "#800", "#088", "#00F", "#0CF", "#CFF", "#CFC", "#FF9", "#9CF", "#F9C", "#C9F", "#FC9", "#36F", "#3CC", "#9C0", "#FC0"], j = ["\xA4", "$", "\xA3", "\xA5", "\u058F", "\u060B", "\u09F3", "\u0E3F", "\u17DB", "\u20A1", "\u20A6", "\u20A9", "\u20AA", "\u20AB", "\u20AC", "\u20AD", "\u20AE", "\u20B1", "\u20B2", "\u20B4", "\u20B8", "\u20B9", "\u20BA", "\u20BC", "\u20BD", "\u20BE", "\u20BF"], v = new RegExp("[" + j.join("") + "]");
        function M(e2, t2, n2) {
          return t2[n2 + "_max"] = e2.length, t2[n2 + "_min"] = e2.replace(/#/g, "").length, t2;
        }
        const k = {};
        function x(e2) {
          if (!(e2 in k)) {
            const t2 = [], n2 = e2.replace(/^[#,]+/, "").replace(/[1-9]\d*/g, (e3) => "?".repeat(e3.length));
            for (let e3 = 0; e3 < n2.length; e3++) {
              const a3 = n2.charAt(e3);
              t2[e3] = a3 in y ? y[a3] : a3;
            }
            k[e2] = t2.join("");
          }
          return k[e2];
        }
        function F(e2, t2) {
          "string" == typeof e2 && (e2 = { type: "string", value: e2 = e2.replace(/ /g, y["?"]) }), t2.push(e2);
        }
        function z(e2) {
          const t2 = [], n2 = { scale: 1, percent: false, text: false, date: 0, date_eval: false, date_system: 1, sec_decimals: 0, general: false, clock: 24, int_pattern: [], frac_pattern: [], man_pattern: [], den_pattern: [], num_pattern: [], tokens: t2 };
          let a3 = e2 + "", r2 = "int", i2 = false, s2 = null;
          const l2 = [];
          let d2, m2, u2 = false;
          for (; a3 && !i2; ) {
            if (d2 = /^General/i.exec(a3)) n2.general = true, F({ type: "general" }, t2);
            else if ("int" === r2 && (d2 = /^[#?0]+(?:,[#?0]+)*/.exec(a3)) || "den" === r2 && (d2 = /^[#?\d]+/.exec(a3)) || (d2 = /^[#?0]+/.exec(a3))) n2[r2 + "_pattern"].push(d2[0]), s2 = { type: r2, num: d2[0] }, F(s2, t2);
            else if ((d2 = /^\//.exec(a3)) && n2[r2 + "_pattern"].length) {
              if (!s2) throw new SyntaxError("Missing a numerator in pattern ".concat(e2));
              n2.fractions = true, n2.num_pattern.push(n2[r2 + "_pattern"].pop()), s2.type = "num", r2 = "den", F({ type: "div" }, t2);
            } else if (d2 = /^,+/.exec(a3)) {
              const e3 = a3.charAt(1) in y;
              m2.slice(-1) in y && (d2[0].length > 1 || !e3) ? n2.scale = 1e-3 ** d2[0].length : n2.dec_fractions || F(d2[0], t2);
            } else {
              if (d2 = /^;/.exec(a3)) {
                i2 = true;
                break;
              }
              if (d2 = /^[@+-]/.exec(a3)) "@" === d2[0] && (n2.text = true), F({ type: _[d2[0]] }, t2);
              else if (d2 = /^(?:\[(h+|m+|s+)\])/i.exec(a3)) {
                const e3 = d2[1].toLowerCase(), a4 = e3[0], r3 = { type: "", size: 0, date: 1, raw: d2[0], pad: e3.length };
                "h" === a4 ? (r3.size = 16, r3.type = "hour-elap") : "m" === a4 ? (r3.size = 32, r3.type = "min-elap") : (r3.size = 64, r3.type = "sec-elap"), n2.date = n2.date | r3.size, l2.push(r3), F(r3, t2);
              } else if (d2 = /^(?:B2)/i.exec(a3)) u2 || (n2.date_system = 6);
              else if (d2 = /^(?:B1)/i.exec(a3)) u2 || (n2.date_system = 1);
              else if (d2 = /^(?:([hHmMsSyYbBdDegG])\1*)/.exec(a3)) {
                const e3 = { type: "", size: 0, date: 1, raw: d2[0] }, a4 = d2[0].toLowerCase(), r3 = a4[0];
                if ("y" === a4 || "yy" === a4) e3.size = 2, e3.type = "year-short";
                else if ("y" === r3 || "e" === r3) e3.size = 2, e3.type = "year";
                else if ("b" === a4 || "bb" === a4) e3.size = 2, e3.type = "b-year-short";
                else if ("b" === r3) e3.size = 2, e3.type = "b-year";
                else if ("d" === a4 || "dd" === a4) e3.size = 8, e3.type = "day", e3.pad = /dd/.test(a4);
                else if ("ddd" === a4) e3.size = 8, e3.type = "weekday-short";
                else if ("d" === r3) e3.size = 8, e3.type = "weekday";
                else if ("h" === r3) e3.size = 16, e3.type = "hour", e3.pad = /hh/i.test(a4);
                else if ("m" === r3) {
                  3 === a4.length ? (e3.size = 4, e3.type = "monthname-short") : 5 === a4.length ? (e3.size = 4, e3.type = "monthname-single") : a4.length >= 4 && (e3.size = 4, e3.type = "monthname");
                  const t3 = l2[l2.length - 1];
                  !e3.type && t3 && !t3.used && 80 & t3.size && (t3.used = true, e3.size = 32, e3.type = "min", e3.pad = /mm/.test(a4)), e3.type || (e3.size = 4, e3.type = "month", e3.pad = /mm/.test(a4), e3.indeterminate = true);
                } else if ("s" === r3) {
                  e3.size = 64, e3.type = "sec", e3.pad = /ss/.test(a4);
                  const t3 = l2[l2.length - 1];
                  t3 && 32 & t3.size ? e3.used = true : t3 && t3.indeterminate && (delete t3.indeterminate, t3.size = 32, t3.type = "min", e3.used = true);
                }
                n2.date = n2.date | e3.size, n2.date_eval = true, l2.push(e3), F(e3, t2);
              } else if (d2 = /^(?:AM\/PM|am\/pm|A\/P)/.exec(a3)) n2.clock = 12, n2.date = 16 | n2.date, n2.date_eval = true, F({ type: "am", short: "A/P" === d2[0] }, t2);
              else if (n2.date && (d2 = /^\.0{1,3}/i.exec(a3))) {
                const e3 = d2[0].length - 1, a4 = [64, 128, 256, 512][e3];
                n2.date = n2.date | a4, n2.date_eval = true, n2.sec_decimals = Math.max(n2.sec_decimals, e3), F({ type: "subsec", size: a4, decimals: e3, date: 1, raw: d2[0] }, t2);
              } else if ((d2 = /^\\(.)/.exec(a3)) || (d2 = /^"([^"]*?)"/.exec(a3))) F(d2[1], t2);
              else if (d2 = /^\[(<[=>]?|>=?|=)\s*(-?[.\d]+)\]/.exec(a3)) n2.condition = [d2[1], parseFloat(d2[2], 10)];
              else if (d2 = /^\[\$([^\]]+)\]/.exec(a3)) {
                const e3 = d2[1].split("-"), a4 = e3.length < 2 ? "" : e3[e3.length - 1], r3 = e3[0];
                r3 && F(r3, t2);
                const i3 = o(a4);
                i3 && (n2.locale = i3);
                const s3 = parseInt(a4, 16);
                if (isFinite(s3) && 16711680 & s3) {
                  6 === (s3 >> 16 & 255) && (n2.date_system = 6);
                }
                u2 = true;
              } else if (d2 = /^\[(black|blue|cyan|green|magenta|red|white|yellow|color\s*(\d+))\]/i.exec(a3)) n2.color = d2[2] ? b[parseInt(d2[2], 10)] || "#000" : d2[1].toLowerCase();
              else if (d2 = /^\[(DBNum1|ENG|HIJ|JPN|TWN)\]/i.exec(a3)) ;
              else if (d2 = /^%/.exec(a3)) n2.scale = 100, n2.percent = true, F("%", t2);
              else if (d2 = /^_(\\.|.)/.exec(a3)) F(" ", t2);
              else if (d2 = /^\./.exec(a3)) F({ type: "point", value: d2[0] }, t2), n2.dec_fractions = true, r2 = "frac";
              else if (d2 = /^[Ee]([+-]?|(?=[0#?]))/.exec(a3)) n2.exponential = true, n2.exp_plus = "+" === d2[1], r2 = "man", F({ type: "exp", plus: "+" === d2[1] }, t2);
              else if (d2 = /^\*(\\.|.)/.exec(a3)) ;
              else {
                if (d2 = /^[BENn[]/.exec(a3)) throw new SyntaxError("Unexpected char ".concat(a3.charAt(0), " in pattern ").concat(e2));
                "(" === a3[0] && (n2.parens = true), d2 = [a3[0]], F(d2[0], t2);
              }
            }
            m2 = d2[0], a3 = a3.slice(d2 ? d2[0].length : 1);
          }
          if (n2.pattern = e2.slice(0, e2.length - a3.length), /^((?:\[[^\]]+\])+)(;|$)/.test(n2.pattern) && !/^\[(?:h+|m+|s+)\]/.test(n2.pattern) && F({ type: "text" }, t2), n2.fractions && n2.dec_fractions || n2.fractions && n2.exponential) throw new SyntaxError("Invalid pattern: ".concat(n2.pattern));
          const c2 = n2.int_pattern.join("");
          if (n2.grouping = c2.indexOf(",") >= 0, n2.grouping) {
            const e3 = c2.split(","), t3 = e3.length;
            2 === t3 ? (n2.group_pri = e3[1].length, n2.group_sec = n2.group_pri) : t3 > 2 && (n2.group_pri = e3[t3 - 1].length, n2.group_sec = e3[t3 - 2].length);
          } else n2.group_pri = 0, n2.group_sec = 0;
          M(c2.replace(/[,]/g, ""), n2, "int"), M(n2.frac_pattern.join(""), n2, "frac"), M(n2.man_pattern.join(""), n2, "man");
          let p2 = n2.num_pattern.join(""), f2 = n2.den_pattern.join("");
          const g2 = /\?/.test(f2) || /\?/.test(p2);
          return f2 = f2.replace(/\d/g, g2 ? "?" : "#"), g2 && (f2 = f2.replace(/#$/g, "?")), M(p2, n2, "num"), M(f2, n2, "den"), g2 && (p2 = p2.replace(/#$/g, "?")), n2.int_padding = x(n2.int_pattern.join("")), n2.man_padding = x(n2.man_pattern.join("")), n2.num_padding = x(p2), n2.den_padding = x(f2), n2.den_pattern.length && (n2.denominator = parseInt(n2.den_pattern.join("").replace(/\D/g, ""), 10)), n2.integer = !!n2.int_pattern.join("").length, n2.fractions && t2.forEach((e3, n3) => {
            const a4 = t2[n3 + 1];
            "string" === e3.type && a4 && ("num" === a4.type ? e3.rule = "num+int" : "div" === a4.type ? e3.rule = "num" : "den" === a4.type && (e3.rule = "den"));
          }), n2;
        }
        const w = (e2) => {
          const t2 = e2.condition;
          t2 && t2[1] < 0 && ("<" === t2[0] || "<=" === t2[0] || "=" === t2[0]) || e2.tokens.unshift({ type: "minus", volatile: true });
        };
        function D2(e2) {
          const t2 = [];
          let n2, a3 = false, r2 = null, i2 = e2, s2 = 0, l2 = false, d2 = 0, m2 = 0;
          do {
            if (l2 = z(i2), (l2.date || l2.general) && (l2.int_pattern.length || l2.frac_pattern.length || 1 !== l2.scale || l2.text)) throw new Error("Illegal format");
            if (l2.condition && (m2++, a3 = true), l2.text) {
              if (r2) throw new Error("Unexpected partition");
              r2 = l2;
            }
            l2.locale && (n2 = o(l2.locale)), t2.push(l2), s2 = ";" === i2.charAt(l2.pattern.length) ? 1 : 0, i2 = i2.slice(l2.pattern.length + s2), d2++;
          } while (s2 && d2 < 4 && m2 < 3);
          if (s2) throw new Error("Unexpected partition");
          if (m2 > 2) throw new Error("Unexpected condition");
          const u2 = t2[3];
          if (u2 && (u2.int_pattern.length || u2.frac_pattern.length || u2.date)) throw new Error("Unexpected partition");
          if (a3) {
            const e3 = t2.length;
            if (1 === e3 && (t2[1] = z("General"), t2[1].generated = true), e3 < 3) {
              const e4 = t2[0], n3 = t2[1];
              if (w(e4), n3.condition) w(n3);
              else {
                const t3 = e4.condition;
                ("=" === t3[0] || t3[1] >= 0 && (">" === t3[0] || ">=" === t3[0])) && n3.tokens.unshift({ type: "minus", volatile: true });
              }
            } else t2.forEach(w);
          } else {
            if (t2.length < 4 && r2) for (let e3 = 0, n3 = t2.length; e3 < n3; e3++) t2[e3] === r2 && t2.splice(e3, 1);
            if (t2.length < 1 && r2 && (t2[0] = z("General"), t2[0].generated = true), t2.length < 2) {
              const e3 = z(t2[0].pattern);
              e3.tokens.unshift({ type: "minus", volatile: true }), e3.generated = true, t2.push(e3);
            }
            if (t2.length < 3) {
              const e3 = z(t2[0].pattern);
              e3.generated = true, t2.push(e3);
            }
            if (t2.length < 4) if (r2) t2.push(r2);
            else {
              const e3 = z("@");
              e3.generated = true, t2.push(e3);
            }
            t2[0].condition = [">", 0], t2[1].condition = ["<", 0], t2[2].condition = null;
          }
          return { pattern: e2, partitions: t2, locale: n2 };
        }
        const S2 = Math.floor;
        function C(e2) {
          let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
          if (t2 && e2 >= 0) {
            if (0 === e2) return [1900, 1, 0];
            if (60 === e2) return [1900, 2, 29];
            if (e2 < 60) return [1900, e2 < 32 ? 1 : 2, (e2 - 1) % 31 + 1];
          }
          let n2 = e2 + 68569 + 2415019;
          const a3 = S2(4 * n2 / 146097);
          n2 -= S2((146097 * a3 + 3) / 4);
          const r2 = S2(4e3 * (n2 + 1) / 1461001);
          n2 = n2 - S2(1461 * r2 / 4) + 31;
          const i2 = S2(80 * n2 / 2447), s2 = n2 - S2(2447 * i2 / 80);
          n2 = S2(i2 / 11);
          const o2 = i2 + 2 - 12 * n2, l2 = 100 * (a3 - 49) + r2 + n2;
          return [0 | l2, 0 | o2, 0 | s2];
        }
        function E(e2) {
          return C(e2 + 1462);
        }
        function A(e2) {
          if (60 === e2) throw new Error("#VALUE!");
          if (e2 <= 1) return [1317, 8, 29];
          if (e2 < 60) return [1317, e2 < 32 ? 9 : 10, 1 + (e2 - 2) % 30];
          const t2 = 10631 / 30, n2 = 0.1335;
          let a3 = e2 + 466935;
          const r2 = S2(a3 / 10631);
          a3 -= 10631 * r2;
          const i2 = S2((a3 - n2) / t2);
          a3 -= S2(i2 * t2 + n2);
          const s2 = S2((a3 + 28.5001) / 29.5);
          return 13 === s2 ? [30 * r2 + i2, 12, 30] : [30 * r2 + i2, s2, a3 - S2(29.5001 * s2 - 29)];
        }
        function Y(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
          const a3 = S2(e2);
          return 6 === t2 ? A(a3) : -1 === t2 ? E(a3) : C(a3, n2);
        }
        const T2 = Math.floor, N2 = 86400;
        function P2(e2, t2) {
          let n2 = null;
          if (Array.isArray(e2)) {
            const [t3, a3, r2, i2, s2, o2] = e2;
            n2 = Date.UTC(t3, null == a3 ? 0 : a3 - 1, null != r2 ? r2 : 1, i2 || 0, s2 || 0, o2 || 0);
          } else if (e2 instanceof Date && (n2 = 1 * e2, !t2 || !t2.ignoreTimezone)) {
            const t3 = /* @__PURE__ */ new Date();
            t3.setUTCFullYear(e2.getFullYear(), e2.getMonth(), e2.getDate()), t3.setUTCHours(e2.getHours(), e2.getMinutes(), e2.getSeconds(), e2.getMilliseconds()), n2 = 1 * t3;
          }
          if (null != n2 && isFinite(n2)) {
            const e3 = n2 / 864e5;
            return e3 - (e3 <= -25509 ? -25568 : -25569);
          }
          return e2;
        }
        function I(e2, t2) {
          let n2 = 0 | e2;
          const a3 = N2 * (e2 - n2);
          let r2 = T2(a3);
          a3 - r2 > 0.9999 && (r2 += 1, r2 === N2 && (r2 = 0, n2 += 1));
          const i2 = r2 < 0 ? N2 + r2 : r2, [s2, o2, l2] = Y(e2, 0, t2 && t2.leap1900), d2 = T2(i2 / 60 / 60) % 60, m2 = T2(i2 / 60) % 60, u2 = T2(i2) % 60;
          if (t2 && t2.nativeDate) {
            const e3 = /* @__PURE__ */ new Date(0);
            return e3.setUTCFullYear(s2, o2 - 1, l2), e3.setUTCHours(d2, m2, u2), e3;
          }
          return [s2, o2, l2, d2, m2, u2];
        }
        function O2(e2) {
          return !!(e2[0] && e2[0].percent || e2[1] && e2[1].percent || e2[2] && e2[2].percent || e2[3] && e2[3].percent);
        }
        function J(e2) {
          return !!(e2[0] && e2[0].date || e2[1] && e2[1].date || e2[2] && e2[2].date || e2[3] && e2[3].date);
        }
        function L(e2) {
          const [t2, n2, a3, r2] = e2;
          return !(t2 && !t2.generated || n2 && !n2.generated || a3 && !a3.generated || !r2 || !r2.text || r2.generated);
        }
        const U = { text: 15, datetime: 10.8, date: 10.8, time: 10.8, percent: 10.6, currency: 10.4, grouped: 10.2, scientific: 6, number: 4, fraction: 2, general: 0, error: 0 }, R = [["DMY", 1], ["DM", 2], ["MY", 3], ["MDY", 4], ["MD", 5], ["hmsa", 6], ["hma", 7], ["hms", 8], ["hm", 9]];
        const G2 = { total: 1, sign: 0, period: 0, int: 1, frac: 0 };
        const H = (e2, t2) => e2.replace(/\./, t2.decimal);
        function B(e2, t2, n2, a3) {
          const r2 = 0 | n2;
          if ("string" == typeof n2) e2.push(n2);
          else if (n2 === r2) e2.push(Math.abs(r2));
          else {
            const t3 = Math.abs(n2);
            let r3 = t3 ? Math.floor(Math.log10(t3)) : 0, i2 = r3 < 0 ? t3 * 10 ** -r3 : t3 / 10 ** r3;
            10 === i2 && (i2 = 1, r3++);
            const s2 = function(e3) {
              let t4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
              const n3 = Math.abs(e3);
              if (!n3) return G2;
              const a4 = t4 && e3 < 0 ? 1 : 0, r4 = Math.floor(n3), i3 = Math.floor(Math.log10(n3) + 1);
              let s3 = 0, o3 = 0;
              if (r4 !== n3) {
                s3 = 1;
                const e4 = String(c(i3 < 0 ? n3 * 10 ** -i3 : n3 / 10 ** i3, 15));
                let t5 = e4.length, a5 = true, r5 = 0;
                for (; r5 <= e4.length; ) {
                  if ("." === e4[r5]) {
                    t5--;
                    break;
                  }
                  "0" === e4[r5] && a5 ? t5-- : a5 = false, r5++;
                }
                o3 = t5 - i3, o3 < 0 && (o3 = 0, s3 = 0);
              }
              return { total: a4 + Math.max(i3, 1) + s3 + o3, digits: Math.max(i3, 0) + o3, sign: a4, period: s3, int: Math.max(i3, 1), frac: o3 };
            }(t3), o2 = () => {
              const t4 = Math.abs(r3);
              let n3;
              n3 = 1 === i2 ? i2 : c(i2, 5), e2.push(H(n3 + "", a3), a3.exponent, r3 < 0 ? a3.negative : a3.positive, t4 < 10 ? "0" : "", t4);
            };
            if (r3 >= -4 && r3 <= -1) {
              const n3 = t3.toPrecision(10 + r3).replace(/\.?0+$/, "");
              e2.push(H(n3, a3));
            } else if (10 === r3) {
              const n3 = t3.toFixed(10).slice(0, 12).replace(/\.$/, "");
              e2.push(H(n3, a3));
            } else if (Math.abs(r3) <= 9) if (s2.total <= 11) {
              const n3 = c(t3, 9).toFixed(s2.frac);
              e2.push(H(n3, a3));
            } else 9 === r3 ? e2.push(Math.floor(t3)) : r3 >= 0 && r3 < 9 ? e2.push(c(t3, 9 - r3)) : o2();
            else s2.total >= 12 ? o2() : Math.floor(t3) === t3 ? e2.push(Math.floor(t3)) : e2.push(H(c(t3, 9).toFixed(s2.frac), a3));
          }
          return e2;
        }
        const $ = 86400, W = { int: "integer", frac: "fraction", man: "mantissa", num: "numerator", den: "denominator" }, Z = function(e2) {
          let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          const n2 = Math.floor(Math.log10(e2));
          return t2 > 1 ? Math.floor(n2 / t2) * t2 : n2;
        };
        function K(e2, t2, n2, a3) {
          let r2 = "", i2 = "", s2 = "", o2 = "", l2 = "", d2 = 0, m2 = 0 | e2, f2 = 0, g2 = 0, h2 = 1, _2 = 0, b2 = 0, j2 = 0, v2 = 0, M2 = 0, k2 = 0;
          const x2 = a3 || u;
          if (!t2.text && isFinite(t2.scale) && 1 !== t2.scale && (e2 = function(e3) {
            if (0 === e3) return e3;
            const t3 = Math.ceil(Math.log10(e3 < 0 ? -e3 : e3)), n3 = 10 ** (16 - Math.floor(t3));
            return Math.round(e3 * n3) / n3;
          }(e2 * t2.scale)), t2.exponential) {
            let n3 = Math.abs(e2);
            if (n3) {
              const e3 = 10 ** -Z(n3, t2.int_max), a4 = c(n3 * e3, t2.frac_max) / e3;
              d2 = Z(a4, t2.int_max);
            }
            n3 /= 10 ** d2, e2 = e2 < 0 ? -n3 : n3, r2 += Math.abs(d2);
          }
          if (t2.integer) {
            const n3 = Math.abs(c(e2, t2.fractions ? 1 : t2.frac_max));
            l2 += n3 < 1 ? "" : Math.floor(n3);
          }
          if (t2.grouping) {
            let e3 = "", n3 = l2.length;
            for (n3 > t2.group_pri && (n3 -= t2.group_pri, e3 = x2.group + l2.slice(n3, n3 + t2.group_pri) + e3); n3 > t2.group_sec; ) n3 -= t2.group_sec, e3 = x2.group + l2.slice(n3, n3 + t2.group_sec) + e3;
            l2 = n3 ? l2.slice(0, n3) + e3 : e3;
          }
          t2.dec_fractions && (o2 = String(c(e2, t2.frac_max)).split(".")[1] || "");
          let F2 = false;
          if (t2.fractions) {
            const n3 = Math.abs(t2.integer ? e2 % 1 : e2);
            if (n3) if (F2 = true, isFinite(t2.denominator)) s2 += t2.denominator, i2 += c(n3 * t2.denominator), "0" === i2 && (i2 = "", s2 = "", F2 = false, l2 || (l2 = "0"));
            else {
              const e3 = p(n3, t2.integer ? t2.num_max : 1 / 0, t2.den_max);
              i2 += e3[0], s2 += e3[1], t2.integer && "0" === i2 && (l2 || (l2 = "0"), i2 = "", s2 = "", F2 = false);
            }
          }
          if (t2.date) {
            m2 = Math.trunc(e2);
            const a4 = $ * (e2 - m2);
            if (f2 = Math.floor(a4), k2 = a4 - f2, Math.abs(k2) < 1e-6 ? k2 = 0 : k2 > 0.9999 && (k2 = 0, f2 += 1, f2 === $ && (f2 = 0, m2 += 1)), k2) {
              const e3 = 512 & t2.date || 256 & t2.date || 128 & t2.date;
              (512 === e3 && k2 > 0.9995 || 256 === e3 && k2 > 0.995 || 128 === e3 && k2 > 0.95 || !e3 && k2 >= 0.5) && (f2++, k2 = 0);
            }
            if (m2 || t2.date_system) {
              const a5 = Y(e2, t2.date_system, n2.leap1900);
              g2 = a5[0], h2 = a5[1], _2 = a5[2];
            }
            if (f2) {
              const e3 = f2 < 0 ? $ + f2 : f2;
              M2 = Math.floor(e3) % 60, v2 = Math.floor(e3 / 60) % 60, j2 = Math.floor(e3 / 60 / 60) % 60;
            }
            if (b2 = (6 + m2) % 7, t2.date_eval && (z2 = e2, w2 = m2 + f2 / $, n2.dateSpanLarge ? z2 < -694324 || w2 >= 35830291 : z2 < 0 || w2 >= 2958466)) {
              if (n2.dateErrorThrows) throw new Error("Date out of bounds");
              if (n2.dateErrorNumber) {
                return B(e2 < 0 ? [x2.negative] : [], 0, e2, x2).join("");
              }
              return n2.overflow;
            }
          }
          var z2, w2;
          if (t2.int_padding && (l2 = 1 === t2.int_padding.length ? l2 || t2.int_padding : t2.int_padding.substring(0, t2.int_padding.length - l2.length) + l2), t2.num_padding && (i2 = 1 === t2.num_padding.length ? i2 || t2.num_padding : t2.num_padding.substring(0, t2.num_padding.length - i2.length) + i2), t2.den_padding && (s2 = 1 === t2.den_padding.length ? s2 || t2.den_padding : s2 + t2.den_padding.slice(s2.length)), t2.man_padding) {
            const e3 = t2.exp_plus ? "+" : "";
            r2 = 1 === t2.man_padding.length ? (d2 < 0 ? "-" : e3) + (r2 || t2.man_padding) : (d2 < 0 ? "-" : e3) + t2.man_padding.slice(0, t2.man_padding.length - r2.length) + r2;
          }
          const D3 = [];
          let S3 = 0;
          const C2 = { int: 0, frac: 0, man: 0, num: 0, den: 0 };
          for (let d3 = 0, u2 = t2.tokens.length; d3 < u2; d3++) {
            const u3 = t2.tokens[d3], c2 = u3.num ? u3.num.length : 0;
            if ("string" === u3.type) u3.rule ? "num" === u3.rule ? F2 ? D3.push(u3.value) : (t2.num_min > 0 || t2.den_min > 0) && D3.push(u3.value.replace(/./g, y["?"])) : "num+int" === u3.rule ? F2 && l2 ? D3.push(u3.value) : t2.den_min > 0 && (l2 || t2.num_min) && D3.push(u3.value.replace(/./g, y["?"])) : "den" === u3.rule && (F2 ? D3.push(u3.value) : (t2.den_min > 0 || t2.den_min > 0) && D3.push(u3.value.replace(/./g, y["?"]))) : D3.push(u3.value);
            else if ("error" === u3.type) D3.push(n2.invalid);
            else if ("point" === u3.type) D3.push(t2.date ? u3.value : x2.decimal);
            else if ("general" === u3.type) B(D3, 0, e2, x2);
            else if ("exp" === u3.type) D3.push(x2.exponent);
            else if ("minus" === u3.type) u3.volatile && t2.date || u3.volatile && (e2 >= 0 || "number" != typeof e2) || (u3.volatile && !t2.fractions && (t2.integer || t2.dec_fractions) ? (e2 < 0 && l2 && "0" !== l2 || o2) && D3.push(x2.negative) : D3.push(x2.negative));
            else if ("plus" === u3.type) D3.push(x2.positive);
            else if ("text" === u3.type) D3.push(e2);
            else if ("div" === u3.type) F2 ? D3.push("/") : t2.num_min > 0 || t2.den_min > 0 ? D3.push(y["?"]) : D3.push(y["#"]);
            else if ("int" === u3.type) if (1 === t2.int_pattern.length) D3.push(l2);
            else {
              const e3 = S3 ? t2.int_pattern.join("").length - C2.int : 1 / 0, n3 = S3 === t2.int_pattern.length - 1 ? 0 : t2.int_pattern.join("").length - (C2.int + u3.num.length);
              D3.push(l2.substring(l2.length - e3, l2.length - n3)), S3++, C2.int += u3.num.length;
            }
            else if ("frac" === u3.type) {
              const e3 = C2.frac;
              for (let t3 = 0; t3 < c2; t3++) D3.push(o2[t3 + e3] || y[u3.num[t3]]);
              C2.frac += c2;
            } else if (u3.type in W) 1 === t2[u3.type + "_pattern"].length ? ("int" === u3.type && D3.push(l2), "frac" === u3.type && D3.push(o2), "man" === u3.type && D3.push(r2), "num" === u3.type && D3.push(i2), "den" === u3.type && D3.push(s2)) : (D3.push(W[u3.type].slice(C2[u3.type], C2[u3.type] + c2)), C2[u3.type] += c2);
            else if ("year" === u3.type) g2 < 0 && D3.push(x2.negative), D3.push(String(Math.abs(g2)).padStart(4, "0"));
            else if ("year-short" === u3.type) {
              const e3 = g2 % 100;
              D3.push(e3 < 10 ? "0" : "", e3);
            } else if ("month" === u3.type) D3.push(u3.pad && h2 < 10 ? "0" : "", h2);
            else if ("monthname-single" === u3.type) 6 === t2.date_system ? D3.push(x2.mmmm6[h2 - 1].charAt(0)) : D3.push(x2.mmmm[h2 - 1].charAt(0));
            else if ("monthname-short" === u3.type) 6 === t2.date_system ? D3.push(x2.mmm6[h2 - 1]) : D3.push(x2.mmm[h2 - 1]);
            else if ("monthname" === u3.type) 6 === t2.date_system ? D3.push(x2.mmmm6[h2 - 1]) : D3.push(x2.mmmm[h2 - 1]);
            else if ("weekday-short" === u3.type) D3.push(x2.ddd[b2]);
            else if ("weekday" === u3.type) D3.push(x2.dddd[b2]);
            else if ("day" === u3.type) D3.push(u3.pad && _2 < 10 ? "0" : "", _2);
            else if ("hour" === u3.type) {
              const e3 = j2 % t2.clock || (t2.clock < 24 ? t2.clock : 0);
              D3.push(u3.pad && e3 < 10 ? "0" : "", e3);
            } else if ("min" === u3.type) D3.push(u3.pad && v2 < 10 ? "0" : "", v2);
            else if ("sec" === u3.type) D3.push(u3.pad && M2 < 10 ? "0" : "", M2);
            else if ("subsec" === u3.type) {
              D3.push(x2.decimal);
              const e3 = k2.toFixed(t2.sec_decimals);
              D3.push(e3.slice(2, 2 + u3.decimals));
            } else if ("am" === u3.type) {
              const e3 = j2 < 12 ? 0 : 1;
              u3.short && !a3 ? D3.push("AP"[e3]) : D3.push(x2.ampm[e3]);
            } else if ("hour-elap" === u3.type) {
              e2 < 0 && D3.push(x2.negative);
              const t3 = 24 * m2 + Math.floor(Math.abs(f2) / 3600);
              D3.push(String(Math.abs(t3)).padStart(u3.pad, "0"));
            } else if ("min-elap" === u3.type) {
              e2 < 0 && D3.push(x2.negative);
              const t3 = 1440 * m2 + Math.floor(Math.abs(f2) / 60);
              D3.push(String(Math.abs(t3)).padStart(u3.pad, "0"));
            } else if ("sec-elap" === u3.type) {
              e2 < 0 && D3.push(x2.negative);
              const t3 = m2 * $ + Math.abs(f2);
              D3.push(String(Math.abs(t3)).padStart(u3.pad, "0"));
            } else if ("b-year" === u3.type) D3.push(g2 + 543);
            else if ("b-year-short" === u3.type) {
              const e3 = (g2 + 543) % 100;
              D3.push(e3 < 10 ? "0" : "", e3);
            }
          }
          return n2.nbsp ? D3.join("") : D3.join("").replace(/\u00a0/g, " ");
        }
        function q(e2, t2) {
          for (let n2 = 0; n2 < 3; n2++) {
            const a3 = t2[n2];
            if (a3) {
              let t3;
              if (a3.condition) {
                const n3 = a3.condition[0], r2 = a3.condition[1];
                "=" === n3 ? t3 = e2 === r2 : ">" === n3 ? t3 = e2 > r2 : "<" === n3 ? t3 = e2 < r2 : ">=" === n3 ? t3 = e2 >= r2 : "<=" === n3 ? t3 = e2 <= r2 : "<>" === n3 && (t3 = e2 !== r2);
              } else t3 = true;
              if (t3) return a3;
            }
          }
        }
        const V = z("@"), Q = "black";
        const X = {};
        function ee(e2, t2) {
          if (e2) {
            const n2 = e2[0];
            t2[n2] = t2[n2] || {}, ee(e2.slice(1), t2[n2]);
          } else t2.$ = true;
        }
        ["d-F-y", "d-F-Y", "d-M-y", "d-M-Y", "F-d-y", "F-d-Y", "F-j-y", "F-j-Y", "j-F-y", "j-F-Y", "j-M-y", "j-M-Y", "M-d-y", "M-d-Y", "M-j-y", "M-j-Y", "m-d-y", "m-d-Y", "m-j-y", "m-j-Y", "n-d-y", "n-d-Y", "n-j-y", "n-j-Y", "y-F-d", "y-F-j", "y-M-d", "y-M-j", "Y-F-d", "Y-F-j", "Y-M-d", "Y-m-d", "Y-M-j", "Y-m-j", "Y-n-d", "Y-n-j", "j-F", "j-M", "d-F", "d-M", "n-d", "n-j", "n-Y", "m-d", "m-j", "m-Y", "M-Y", "M-y", "F-y", "F-Y", "Y-M", "Y-n", "Y-m", "Y-F", "Y-M"].forEach((e2) => {
          ee(e2, X), ee(e2 + " x", X), ee(e2 + " l", X), ee(e2 + " l x", X), ee("l " + e2, X), ee("l " + e2 + " x", X), ee(e2 + " D", X), ee(e2 + " D x", X), ee("D " + e2, X), ee("D " + e2 + " x", X);
        });
        const te = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 }, ne = { january: 1, february: 2, march: 3, april: 4, june: 6, july: 7, august: 8, september: 9, october: 10, november: 11, december: 12 }, ae = { sunday: "l", monday: "l", tuesday: "l", wednesday: "l", thursday: "l", friday: "l", saturday: "l", sun: "D", mon: "D", tue: "D", wed: "D", thu: "D", fri: "D", sat: "D" }, re = (/* @__PURE__ */ new Date()).getUTCFullYear();
        function ie(e2) {
          const t2 = new RegExp("^([\\s+%" + j.join("") + "(-]*)(((?:(?:\\d[\\d,]*)(?:\\.\\d*)?|(?:\\.\\d+)))([eE][+-]?\\d+)?)([\\s%" + j.join("") + ")]*)$").exec(e2);
          if (t2) {
            const [, e3, n2, a3, r2, i2] = t2;
            let s2 = 1, o2 = "", l2 = false, d2 = false, m2 = false, u2 = false, c2 = false, p2 = null, f2 = false, g2 = parseFloat(n2.replace(/,/g, ""));
            if (!isFinite(g2)) return null;
            for (let t3 = 0; t3 < e3.length; t3++) {
              const n3 = e3[t3];
              if ("-" === n3) {
                if (l2 || d2) return null;
                l2 = true, s2 = -1;
              } else if (v.test(n3)) {
                if (c2) return null;
                c2 = true, p2 = n3;
              } else if ("(" === n3) {
                if (d2 || l2) return null;
                d2 = true, s2 = -1;
              } else if ("%" === n3) {
                if (u2) return null;
                u2 = true;
              }
            }
            for (let e4 = 0; e4 < i2.length; e4++) {
              const t3 = i2[e4];
              if (v.test(t3)) {
                if (c2) return null;
                c2 = true, p2 = t3, f2 = true;
              } else if (")" === t3) {
                if (m2 || !d2) return null;
                m2 = true;
              } else if ("%" === t3) {
                if (u2) return null;
                u2 = true;
              }
            }
            if (r2) {
              if (u2 || c2) return null;
              o2 = "0.00E+00";
            } else if (u2) {
              if (c2) return null;
              o2 = a3.includes(".") ? "0.00%" : "0%", g2 *= 0.01;
            } else if (c2) {
              const e4 = a3.includes(".") ? "#,##0.00" : "#,##0";
              o2 = f2 ? e4 + p2 : p2 + e4;
            } else a3.includes(",") && (o2 = a3.includes(".") ? "#,##0.00" : "#,##0");
            const h2 = { v: g2 * s2 };
            return o2 && (h2.z = o2), h2;
          }
        }
        const se = (e2, t2, n2) => {
          const a3 = n2.path || "", r2 = Object.keys(t2);
          for (let i2 = 0; i2 < r2.length; i2++) {
            let s2;
            const o2 = r2[i2];
            if (t2[o2]) {
              if ("$" === o2 || "\u20AC" === o2) e2 || (s2 = n2);
              else if ("-" === o2) {
                const r3 = /^(\s*([./-]|,\s)\s*|\s+)/.exec(e2);
                if (r3) {
                  const i3 = "-" === r3[1] || "/" === r3[1] || "." === r3[1] ? r3[1] : " ";
                  if (!n2.sep || n2.sep === i3) {
                    const l2 = r3[0].replace(/\s+/g, " ");
                    s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, sep: i3, path: a3 + l2 });
                  }
                }
              } else if (" " === o2) {
                const r3 = /^[,.]?\s+/.exec(e2);
                if (r3) {
                  const i3 = r3[0].replace(/\s+/g, " ");
                  s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, path: a3 + i3 });
                }
              } else if ("j" === o2 || "d" === o2) {
                const r3 = /^(0?[1-9]|1\d|2\d|3[01])\b/.exec(e2);
                r3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, day: r3[0], path: a3 + o2 }));
              } else if ("n" === o2 || "m" === o2) {
                const r3 = /^(0?[1-9]|1[012])\b/.exec(e2);
                r3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, month: +r3[0], _mon: r3[0], path: a3 + o2 }));
              } else if ("F" === o2 || "M" === o2) {
                const r3 = /^([a-z]{3,9})\b/i.exec(e2), i3 = r3 && ("F" === o2 ? ne : te)[r3[0].toLowerCase()];
                i3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, month: i3, _mon: r3[0], path: a3 + o2 }));
              } else if ("l" === o2 || "D" === o2) {
                const r3 = /^([a-z]{3,9})\b/i.exec(e2);
                (r3 && ae[r3[0].toLowerCase()]) === o2 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, path: a3 + o2 }));
              } else if ("y" === o2) {
                const r3 = /^\d\d\b/.exec(e2);
                if (r3) {
                  const i3 = +r3[0] >= 30 ? +r3[0] + 1900 : +r3[0] + 2e3;
                  s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, year: i3, path: a3 + o2 });
                }
              } else if ("Y" === o2) {
                const r3 = /^\d\d\d\d\b/.exec(e2);
                r3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, year: +r3[0], path: a3 + o2 }));
              } else {
                if ("x" !== o2) throw new Error('Unknown date token "'.concat(o2, '"'));
                {
                  const r3 = le(e2);
                  r3 && (s2 = se("", t2[o2], { ...n2, time: r3.v, tf: r3.z, path: a3 + o2 }));
                }
              }
              if (s2) return s2;
            }
          }
        };
        function oe(e2, t2) {
          const n2 = se(e2.trim(), X, { path: "" });
          if (n2) {
            var a3;
            if ("." === n2.sep && 3 === n2.path.length) return null;
            const e3 = +(null !== (a3 = n2.year) && void 0 !== a3 ? a3 : re);
            if (n2.day || (n2.day = 1), !function(e4, t3, n3) {
              if (n3 < 1) return false;
              if (t3 < 1 || t3 > 12) return false;
              if (2 === t3) {
                if (n3 > (e4 % 4 == 0 && e4 % 100 != 0 || e4 % 400 == 0 || 1900 === e4 ? 29 : 28)) return false;
              } else if ((4 === t3 || 6 === t3 || 9 === t3 || 11 === t3) && n3 > 30 || (1 === t3 || 3 === t3 || 5 === t3 || 7 === t3 || 8 === t3 || 10 === t3 || 12 === t3) && n3 > 31) return false;
              return true;
            }(e3, n2.month, n2.day)) return null;
            let r2 = -1 / 0;
            if (e3 < 1900) return null;
            e3 <= 1900 && n2.month <= 2 ? r2 = 25568 : e3 < 1e4 && (r2 = 25569);
            const i2 = Date.UTC(e3, n2.month - 1, n2.day) / 864e5 + r2 + (n2.time || 0);
            if (i2 >= 0 && i2 <= 2958465) {
              const e4 = "0" === n2._mon[0] || "0" === n2.day[0] || 2 === n2._mon.length && 2 === n2.day.length, a4 = n2.path.replace(/[jdlDnmMFyYx-]/g, (t3) => "j" === t3 || "d" === t3 ? e4 ? "dd" : "d" : "D" === t3 ? "ddd" : "l" === t3 ? "dddd" : "n" === t3 || "m" === t3 ? e4 ? "mm" : "m" : "M" === t3 ? "mmm" : "F" === t3 ? "mmmm" : "y" === t3 ? "yy" : "x" === t3 ? n2.tf || "" : "Y" === t3 ? "yyyy" : t3);
              return t2 && t2.nativeDate ? { v: I(i2, t2), z: a4 } : { v: i2, z: a4 };
            }
          }
          return null;
        }
        function le(e2) {
          const t2 = /^\s*([10]?\d|2[0-4])(?::([0-5]\d|\d))?(?::([0-5]\d|\d))?(\.\d{1,10})?(?:\s*([AP])M?)?\s*$/i.exec(e2);
          if (t2) {
            const [, e3, n2, a3, r2, i2] = t2;
            if (r2 && !a3) return null;
            if (!i2 && !n2 && !a3) return null;
            let s2 = 1 * (e3 || 0);
            if (i2) {
              if (s2 >= 13) return null;
              "p" !== i2[0] && "P" !== i2[0] || (s2 += 12);
            }
            return { v: (60 * s2 * 60 + 60 * (1 * (n2 || 0)) + 1 * (a3 || 0) + 1 * (r2 || 0)) / 86400, z: (2 === e3.length ? "hh" : "h") + ":mm" + (a3 ? ":ss" : "") + (i2 ? " AM/PM" : "") };
          }
          return null;
        }
        function de(e2) {
          return /^\s*true\s*$/i.test(e2) ? { v: true } : /^\s*false\s*$/i.test(e2) ? { v: false } : null;
        }
        const me = {};
        function ue(e2, t2) {
          const { pattern: n2, partitions: a3, locale: r2 } = e2, i2 = (e3) => {
            const n3 = Object.assign({}, h(), t2, e3);
            return r2 && (n3.locale = r2), n3;
          }, s2 = (e3, t3) => {
            const n3 = i2(t3);
            return function(e4, t4, n4) {
              const a4 = l(n4.locale), r3 = t4[3] ? t4[3] : V;
              if ("boolean" == typeof e4 && (e4 = e4 ? "TRUE" : "FALSE"), null == e4) return "";
              if ("number" != typeof e4) return K(e4, r3, n4, a4);
              if (!isFinite(e4)) {
                const t5 = a4 || u;
                return isNaN(e4) ? t5.nan : (e4 < 0 ? t5.negative : "") + t5.infinity;
              }
              const i3 = q(e4, t4);
              return i3 ? K(e4, i3, n4, a4) : n4.overflow;
            }(P2(e3, n3), a3, n3);
          };
          s2.color = (e3, t3) => function(e4, t4) {
            if ("number" != typeof e4 || !isFinite(e4)) return (t4[3] ? t4[3].color : V.color) || Q;
            const n3 = q(e4, t4);
            return n3 && n3.color || Q;
          }(P2(e3, i2(t3)), a3);
          const o2 = function(e3) {
            var t3;
            let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            const [a4, r3] = e3, i3 = a4.frac_max, s3 = { type: "general", isDate: J(e3), isText: L(e3), isPercent: O2(e3), maxDecimals: a4.general ? 9 : i3, scale: null !== (t3 = a4.scale) && void 0 !== t3 ? t3 : 1, color: 0, parentheses: 0, grouped: a4.grouping ? 1 : 0, _partitions: e3 }, o3 = !s3.isDate && !s3.isText && !a4.error && a4.tokens.some((e4) => "string" === e4.type && (n3 ? e4.value === n3 : v.test(e4.value)));
            let l2 = "G", d2 = i3 >= 0 ? Math.min(15, i3) : "", m2 = "", u2 = "";
            if (r3 && r3.color && (u2 = "-", s3.color = 1), a4.parens && (m2 = "()", s3.parentheses = 1), o3) l2 = "C", s3.type = "currency";
            else if (a4.error) s3.type = "error", s3.maxDecimals = 0;
            else if (s3.isDate) {
              let e4 = 0, t4 = 0, n4 = "";
              a4.tokens.forEach((a5) => {
                const r5 = a5.type;
                /^(b-)?year/.test(r5) ? (n4 += "Y", t4++) : r5.startsWith("month") ? (n4 += "M", t4++) : /^(week)?day/.test(r5) ? (n4 += "D", t4++) : "hour" !== r5 && "min" !== r5 && "sec" !== r5 && "am" !== r5 || (n4 += r5[0], e4++);
              }), s3.type = "date", t4 && e4 ? s3.type = "datetime" : !t4 && e4 && (s3.type = "time");
              const r4 = R.find((e5) => n4.startsWith(e5[0]));
              l2 = r4 ? "D" : "G", d2 = r4 ? r4[1] : "";
            } else s3.isText ? (l2 = "G", s3.type = "text", d2 = "", s3.maxDecimals = 0) : a4.general ? (l2 = "G", s3.type = "general", d2 = "") : a4.fractions ? (l2 = "G", s3.type = "fraction", d2 = "") : a4.exponential ? (l2 = "S", s3.type = "scientific") : s3.isPercent ? (l2 = "P", s3.type = "percent") : a4.grouping ? (l2 = ",", s3.type = "grouped") : (a4.int_max || i3) && (l2 = "F", s3.type = "number");
            return s3.code = l2 + d2 + u2 + m2, s3.level = U[s3.type], Object.freeze(s3);
          }(a3, (t2 || {}).currency) || new SyntaxError();
          return s2.info = o2, s2.dateInfo = function(e3) {
            const [t3] = e3;
            return { year: !!(2 & t3.date), month: !!(4 & t3.date), day: !!(8 & t3.date), hours: !!(16 & t3.date), minutes: !!(32 & t3.date), seconds: !!(64 & t3.date), clockType: 12 === t3.clock ? 12 : 24 };
          }(a3), s2.isPercent = () => !!o2.isPercent, s2.isDate = () => !!o2.isDate, s2.isText = () => !!o2.isText, s2.pattern = n2, e2.error && (s2.error = e2.error), s2.options = i2, s2.locale = r2 || t2 && t2.locale || "", Object.freeze(s2);
        }
        function ce(e2, t2) {
          e2 || (e2 = "General");
          let n2 = null;
          if (me[e2]) n2 = me[e2];
          else {
            n2 = Object.assign({}, h(), t2).throws ? D2(e2) : function(e3) {
              try {
                return D2(e3);
              } catch (t3) {
                const n3 = { tokens: [{ type: "error" }], error: t3.message };
                return { pattern: e3, partitions: [n3, n3, n3, n3], error: t3.message, locale: null };
              }
            }(e2), n2.error || (me[e2] = n2);
          }
          return ue(n2, t2);
        }
        ce.isDate = (e2) => ce(e2, { throws: false }).isDate(), ce.isPercent = (e2) => ce(e2, { throws: false }).isPercent(), ce.isText = (e2) => ce(e2, { throws: false }).isText(), ce.getInfo = (e2, t2) => ce(e2, { ...t2, throws: false }).info, ce.getDateInfo = (e2, t2) => ce(e2, { ...t2, throws: false }).dateInfo, ce.dateToSerial = P2, ce.dateFromSerial = I, ce.options = h, ce.dec2frac = p, ce.round = c, ce.codeToLocale = n, ce.parseLocale = s, ce.getLocale = l, ce.addLocale = (e2, t2) => {
          const n2 = s(t2);
          return delete me[n2.lang], delete me[n2.language], m(e2, n2);
        }, ce.format = function(e2, t2, n2) {
          let a3 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
          const r2 = n2 && "object" == typeof n2 ? n2 : { locale: n2, throws: !a3 };
          return ce(e2, r2)(P2(t2, r2), r2);
        }, ce.is_date = ce.isDate, ce.parseNumber = ie, ce.parseDate = oe, ce.parseTime = le, ce.parseBool = de, ce.parseValue = function(e2, t2) {
          var n2, a3, r2;
          return null !== (n2 = null !== (a3 = null !== (r2 = ie(e2)) && void 0 !== r2 ? r2 : oe(e2, t2)) && void 0 !== a3 ? a3 : le(e2)) && void 0 !== n2 ? n2 : de(e2);
        };
        var pe = ce;
        return t = t.default;
      }();
    });
  }
});

// ../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/index.js
var require_numfmt2 = __commonJS({
  "../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/index.js"(exports2, module2) {
    module2.exports = require_numfmt();
  }
});

// ../node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "../node_modules/.pnpm/fast-diff@1.3.0/node_modules/fast-diff/diff.js"(exports2, module2) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      if (cleanup) {
        diff_cleanupSemantic(diffs);
      }
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [
        [DIFF_DELETE, text1],
        [DIFF_INSERT, text2]
      ];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonOverlap_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 4)
      );
      var hm2 = diff_halfMatchI_(
        longtext,
        shorttext,
        Math.ceil(longtext.length / 2)
      );
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupSemantic(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastequality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastequality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, [
              DIFF_DELETE,
              lastequality
            ]);
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs);
      }
      diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                insertion.substring(0, overlap_length1)
              ]);
              diffs[pointer - 1][1] = deletion.substring(
                0,
                deletion.length - overlap_length1
              );
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, [
                DIFF_EQUAL,
                deletion.substring(0, overlap_length2)
              ]);
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(
                0,
                insertion.length - overlap_length2
              );
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    }
    var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    var whitespaceRegex_ = /\s/;
    var linebreakRegex_ = /[\r\n]/;
    var blanklineEndRegex_ = /\n\r?\n$/;
    var blanklineStartRegex_ = /^\r?\n\r?\n/;
    function diff_cleanupSemanticLossless(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                  0,
                  -1
                );
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(
                      0,
                      commonlength
                    );
                  } else {
                    diffs.splice(0, 0, [
                      DIFF_EQUAL,
                      text_insert.substring(0, commonlength)
                    ]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(
                    0,
                    text_insert.length - commonlength
                  );
                  text_delete = text_delete.substring(
                    0,
                    text_delete.length - commonlength
                  );
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(
                  pointer - n,
                  n,
                  [DIFF_DELETE, text_delete],
                  [DIFF_INSERT, text_insert]
                );
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(
            diffs[pointer][1].length - diffs[pointer - 1][1].length
          ) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
              0,
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            );
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos, cleanup) {
      return diff_main(text1, text2, cursor_pos, cleanup, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module2.exports = diff;
  }
});

// ../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/deepEqual.js
var require_deepEqual = __commonJS({
  "../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/deepEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function eqObj(a2, b) {
      if (Array.isArray(b))
        return false;
      for (let k in a2) {
        if (!deepEqual(a2[k], b[k]))
          return false;
      }
      for (let k in b) {
        if (a2[k] === void 0)
          return false;
      }
      return true;
    }
    function eqArr(a2, b) {
      if (!Array.isArray(b))
        return false;
      if (a2.length !== b.length)
        return false;
      for (let i = 0; i < a2.length; i++) {
        if (!deepEqual(a2[i], b[i]))
          return false;
      }
      return true;
    }
    function deepEqual(a2, b) {
      if (a2 === b)
        return true;
      if (a2 === null || b === null)
        return false;
      if (typeof a2 !== "object" || typeof b !== "object")
        return false;
      return Array.isArray(a2) ? eqArr(a2, b) : eqObj(a2, b);
    }
    exports2.default = deepEqual;
  }
});

// ../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/deepClone.js
var require_deepClone = __commonJS({
  "../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/deepClone.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function deepClone(old) {
      if (old === null)
        return null;
      if (Array.isArray(old)) {
        return old.map(deepClone);
      } else if (typeof old === "object") {
        const o = {};
        for (let k in old)
          o[k] = deepClone(old[k]);
        return o;
      } else {
        return old;
      }
    }
    exports2.default = deepClone;
  }
});

// ../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/cursor.js
var require_cursor = __commonJS({
  "../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/cursor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.eachChildOf = exports2.advancer = exports2.readCursor = exports2.writeCursor = exports2.WriteCursor = exports2.ReadCursor = exports2.isValidPathItem = void 0;
    function assert(pred, msg) {
      if (!pred)
        throw new Error(msg);
    }
    var isObject2 = (o) => o != null && typeof o === "object" && !Array.isArray(o);
    var isGreaterKey = (a2, b) => (
      // All the numbers, then all the letters. Just as the gods of ascii intended.
      typeof a2 === typeof b ? a2 > b : typeof a2 === "string" && typeof b === "number"
    );
    function copyAll(c, w) {
      for (let _k in c) {
        const k = _k;
        w.write(k, c[k]);
      }
    }
    exports2.isValidPathItem = (k) => typeof k === "number" || typeof k === "string" && k !== "__proto__";
    var Cursor = class {
      constructor(op = null) {
        this.parents = [];
        this.indexes = [];
        this.lcIdx = -1;
        this.idx = -1;
        this.container = op;
      }
      ascend() {
        assert(this.parents.length === this.indexes.length / 2);
        if (this.idx === 0) {
          if (this.parents.length) {
            this.lcIdx = this.indexes.pop();
            this.container = this.parents.pop();
            this.idx = this.indexes.pop();
          } else {
            this.lcIdx = 0;
            this.idx = -1;
          }
        } else {
          assert(this.idx > 0);
          this.idx--;
          if (isObject2(this.container[this.idx]))
            this.idx--;
        }
      }
      getPath() {
        const path = [];
        let c = this.container;
        let p = this.parents.length - 1;
        let i = this.idx;
        while (i >= 0) {
          path.unshift(c[i]);
          if (i === 0) {
            i = this.indexes[p * 2];
            c = this.parents[p--];
          } else {
            i -= isObject2(c[i - 1]) ? 2 : 1;
          }
        }
        return path;
      }
    };
    var ReadCursor = class _ReadCursor extends Cursor {
      get() {
        return this.container ? this.container.slice(this.idx + 1) : null;
      }
      // Its only valid to call this after descending into a child.
      getKey() {
        assert(this.container != null, "Invalid call to getKey before cursor descended");
        return this.container[this.idx];
      }
      getComponent() {
        let c;
        if (this.container && this.container.length > this.idx + 1 && isObject2(c = this.container[this.idx + 1])) {
          return c;
        } else {
          return null;
        }
      }
      descendFirst() {
        let i = this.idx + 1;
        if (!this.container || i >= this.container.length || isObject2(this.container[i]) && i + 1 >= this.container.length) {
          return false;
        }
        if (isObject2(this.container[i]))
          i++;
        const firstChild = this.container[i];
        if (Array.isArray(firstChild)) {
          this.indexes.push(this.idx);
          this.parents.push(this.container);
          this.indexes.push(i);
          this.idx = 0;
          this.container = firstChild;
        } else {
          this.idx = i;
        }
        return true;
      }
      nextSibling() {
        assert(this.parents.length === this.indexes.length / 2);
        if (this.idx > 0 || this.parents.length === 0)
          return false;
        const i = this.indexes[this.indexes.length - 1] + 1;
        const c = this.parents[this.parents.length - 1];
        if (i >= c.length)
          return false;
        assert(!isNaN(i));
        this.indexes[this.indexes.length - 1] = i;
        this.container = c[i];
        return true;
      }
      _init(_container, _idx, _parents, _indexes) {
        this.container = _container;
        this.idx = _idx;
        this.parents = _parents.slice();
        this.indexes = _indexes.slice();
      }
      clone() {
        const c = new _ReadCursor();
        c._init(this.container, this.idx, this.parents, this.indexes);
        return c;
      }
      *[Symbol.iterator]() {
        if (!this.descendFirst())
          return;
        do
          yield this.getKey();
        while (this.nextSibling());
        this.ascend();
      }
      // TODO(cleanup): Consider moving these functions out of cursor, since
      // they're really just helper methods.
      // It'd be really nice to do this using generators.
      traverse(w, fn) {
        const c = this.getComponent();
        if (c)
          fn(c, w);
        for (const key of this) {
          if (w)
            w.descend(key);
          this.traverse(w, fn);
          if (w)
            w.ascend();
        }
      }
      eachPick(w, fn) {
        this.traverse(w, (c, w2) => {
          if (c.p != null)
            fn(c.p, w2);
        });
      }
      eachDrop(w, fn) {
        this.traverse(w, (c, w2) => {
          if (c.d != null)
            fn(c.d, w2);
        });
      }
    };
    exports2.ReadCursor = ReadCursor;
    var WriteCursor = class extends Cursor {
      constructor(op = null) {
        super(op);
        this.pendingDescent = [];
        this._op = op;
      }
      flushDescent() {
        assert(this.parents.length === this.indexes.length / 2);
        if (this.container === null)
          this._op = this.container = [];
        for (let j = 0; j < this.pendingDescent.length; j++) {
          const k = this.pendingDescent[j];
          let i = this.idx + 1;
          if (i < this.container.length && isObject2(this.container[i]))
            i++;
          assert(i === this.container.length || !isObject2(this.container[i]));
          if (i === this.container.length) {
            this.container.push(k);
            this.idx = i;
          } else if (this.container[i] === k) {
            this.idx = i;
          } else {
            if (!Array.isArray(this.container[i])) {
              const oldChild = this.container.splice(i, this.container.length - i);
              this.container.push(oldChild);
              if (this.lcIdx > -1)
                this.lcIdx = i;
            }
            this.indexes.push(this.idx);
            this.parents.push(this.container);
            if (this.lcIdx !== -1) {
              assert(isGreaterKey(k, this.container[this.lcIdx][0]));
              i = this.lcIdx + 1;
              this.lcIdx = -1;
            }
            while (i < this.container.length && isGreaterKey(k, this.container[i][0]))
              i++;
            this.indexes.push(i);
            this.idx = 0;
            if (i < this.container.length && this.container[i][0] === k) {
              this.container = this.container[i];
            } else {
              const child = [k];
              this.container.splice(i, 0, child);
              this.container = child;
            }
          }
        }
        this.pendingDescent.length = 0;
      }
      reset() {
        this.lcIdx = -1;
      }
      // Creates and returns a component, creating one if need be. You should
      // probably write to it immediately - ops are not valid with empty
      // components.
      getComponent() {
        this.flushDescent();
        const i = this.idx + 1;
        if (i < this.container.length && isObject2(this.container[i])) {
          return this.container[i];
        } else {
          const component = {};
          this.container.splice(i, 0, component);
          return component;
        }
      }
      write(key, value) {
        const component = this.getComponent();
        assert(component[key] == null || component[key] === value, "Internal consistency error: Overwritten component. File a bug");
        component[key] = value;
      }
      get() {
        return this._op;
      }
      descend(key) {
        if (!exports2.isValidPathItem(key))
          throw Error("Invalid JSON key");
        this.pendingDescent.push(key);
      }
      descendPath(path) {
        this.pendingDescent.push(...path);
        return this;
      }
      ascend() {
        if (this.pendingDescent.length)
          this.pendingDescent.pop();
        else
          super.ascend();
      }
      mergeTree(data, mergeFn = copyAll) {
        if (data === null)
          return;
        assert(Array.isArray(data));
        if (data === this._op)
          throw Error("Cannot merge into my own tree");
        const _lcIdx = this.lcIdx;
        const oldDepth = this.parents.length;
        let depth = 0;
        for (let i = 0; i < data.length; i++) {
          const c = data[i];
          if (typeof c === "string" || typeof c === "number") {
            depth++;
            this.descend(c);
          } else if (Array.isArray(c)) {
            this.mergeTree(c, mergeFn);
          } else if (typeof c === "object") {
            mergeFn(c, this);
          }
        }
        while (depth--)
          this.ascend();
        this.lcIdx = this.parents.length === oldDepth ? _lcIdx : -1;
      }
      at(path, fn) {
        this.descendPath(path);
        fn(this);
        for (let i = 0; i < path.length; i++)
          this.ascend();
        return this;
      }
      // This is used by helpers, so the strict ordering guarantees are
      // relaxed.
      writeAtPath(path, key, value) {
        this.at(path, () => this.write(key, value));
        this.reset();
        return this;
      }
      writeMove(path1, path2, slot = 0) {
        return this.writeAtPath(path1, "p", slot).writeAtPath(path2, "d", slot);
      }
      getPath() {
        const path = super.getPath();
        path.push(...this.pendingDescent);
        return path;
      }
    };
    exports2.WriteCursor = WriteCursor;
    exports2.writeCursor = () => new WriteCursor();
    exports2.readCursor = (op) => new ReadCursor(op);
    function advancer(r, listMap, listAdv) {
      let didDescend, valid;
      valid = didDescend = r ? r.descendFirst() : false;
      function adv(ktarget) {
        let k2_;
        while (valid) {
          const k2 = k2_ = r.getKey();
          if (ktarget != null) {
            let skip5 = false;
            if (listMap && typeof k2 === "number") {
              k2_ = listMap(k2, r.getComponent());
              if (k2_ < 0) {
                k2_ = ~k2_;
                skip5 = true;
              }
            }
            if (isGreaterKey(k2_, ktarget))
              return null;
            else if (k2_ === ktarget && !skip5)
              return r;
          }
          if (listAdv && typeof k2_ === "number")
            listAdv(k2_, r.getComponent());
          valid = r.nextSibling();
        }
        return null;
      }
      adv.end = () => {
        if (didDescend)
          r.ascend();
      };
      return adv;
    }
    exports2.advancer = advancer;
    function eachChildOf(r1, r2, fn) {
      let hasChild1, descended1, hasChild2, descended2;
      hasChild1 = descended1 = r1 && r1.descendFirst();
      hasChild2 = descended2 = r2 && r2.descendFirst();
      while (hasChild1 || hasChild2) {
        let k1 = hasChild1 ? r1.getKey() : null;
        let k2 = hasChild2 ? r2.getKey() : null;
        if (k1 !== null && k2 !== null) {
          if (isGreaterKey(k2, k1))
            k2 = null;
          else if (k1 !== k2)
            k1 = null;
        }
        fn(k1 == null ? k2 : k1, k1 != null ? r1 : null, k2 != null ? r2 : null);
        if (k1 != null && hasChild1) {
          hasChild1 = r1.nextSibling();
        }
        if (k2 != null && hasChild2) {
          hasChild2 = r2.nextSibling();
        }
      }
      if (descended1)
        r1.ascend();
      if (descended2)
        r2.ascend();
    }
    exports2.eachChildOf = eachChildOf;
  }
});

// ../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/types.js
var require_types2 = __commonJS({
  "../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConflictType = void 0;
    var ConflictType;
    (function(ConflictType2) {
      ConflictType2[ConflictType2["RM_UNEXPECTED_CONTENT"] = 1] = "RM_UNEXPECTED_CONTENT";
      ConflictType2[ConflictType2["DROP_COLLISION"] = 2] = "DROP_COLLISION";
      ConflictType2[ConflictType2["BLACKHOLE"] = 3] = "BLACKHOLE";
    })(ConflictType = exports2.ConflictType || (exports2.ConflictType = {}));
  }
});

// ../node_modules/.pnpm/unicount@1.1.0/node_modules/unicount/index.js
var require_unicount = __commonJS({
  "../node_modules/.pnpm/unicount@1.1.0/node_modules/unicount/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uniToStrPos = exports2.strPosToUni = void 0;
    exports2.strPosToUni = (s, strOffset = s.length) => {
      let pairs = 0;
      let i = 0;
      for (; i < strOffset; i++) {
        const code = s.charCodeAt(i);
        if (code >= 55296 && code <= 57343) {
          pairs++;
          i++;
        }
      }
      if (i !== strOffset)
        throw Error("Invalid offset - splits unicode bytes");
      return i - pairs;
    };
    exports2.uniToStrPos = (s, uniOffset) => {
      let pos = 0;
      for (; uniOffset > 0; uniOffset--) {
        const code = s.charCodeAt(pos);
        pos += code >= 55296 && code <= 57343 ? 2 : 1;
      }
      return pos;
    };
  }
});

// ../node_modules/.pnpm/ot-text-unicode@4.0.0/node_modules/ot-text-unicode/dist/type.js
var require_type = __commonJS({
  "../node_modules/.pnpm/ot-text-unicode@4.0.0/node_modules/ot-text-unicode/dist/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uniSlice = exports2.dlen = exports2.eachOp = void 0;
    var unicount_1 = require_unicount();
    var debugMode = false;
    var checkOp = (op) => {
      if (!Array.isArray(op))
        throw Error("Op must be an array of components");
      let last = null;
      for (let i = 0; i < op.length; i++) {
        const c = op[i];
        switch (typeof c) {
          case "object":
            if (typeof c.d !== "number" && typeof c.d !== "string")
              throw Error("Delete must be number or string");
            if (exports2.dlen(c.d) <= 0)
              throw Error("Deletes must not be empty");
            break;
          case "string":
            if (!(c.length > 0))
              throw Error("Inserts cannot be empty");
            break;
          case "number":
            if (!(c > 0))
              throw Error("Skip components must be >0");
            if (typeof last === "number")
              throw Error("Adjacent skip components should be combined");
            break;
        }
        last = c;
      }
      if (typeof last === "number")
        throw Error("Op has a trailing skip");
    };
    function eachOp(op, fn) {
      let prePos = 0, postPos = 0;
      for (let i = 0; i < op.length; i++) {
        const c = op[i];
        fn(c, prePos, postPos);
        switch (typeof c) {
          case "object":
            prePos += exports2.dlen(c.d);
            break;
          case "string":
            postPos += unicount_1.strPosToUni(c);
            break;
          case "number":
            prePos += c;
            postPos += c;
            break;
        }
      }
    }
    exports2.eachOp = eachOp;
    function mapOp(op, fn) {
      const newOp = [];
      const append = makeAppend(newOp);
      eachOp(op, (c, prePos, postPos) => {
        append(fn(c, prePos, postPos));
      });
      return trim(newOp);
    }
    var id = (x) => x;
    var normalize = (op) => {
      return mapOp(op, id);
    };
    exports2.dlen = (d) => typeof d === "number" ? d : unicount_1.strPosToUni(d);
    var makeAppend = (op) => (component) => {
      if (!component || component.d === 0 || component.d === "") {
      } else if (op.length === 0) {
        op.push(component);
      } else if (typeof component === typeof op[op.length - 1]) {
        if (typeof component === "object") {
          const last = op[op.length - 1];
          last.d = typeof last.d === "string" && typeof component.d === "string" ? last.d + component.d : exports2.dlen(last.d) + exports2.dlen(component.d);
        } else {
          op[op.length - 1] += component;
        }
      } else {
        op.push(component);
      }
    };
    var componentLength = (c) => typeof c === "number" ? c : typeof c === "string" ? unicount_1.strPosToUni(c) : typeof c.d === "number" ? c.d : unicount_1.strPosToUni(c.d);
    exports2.uniSlice = (s, startUni, endUni) => {
      const start = unicount_1.uniToStrPos(s, startUni);
      const end = endUni == null ? Infinity : unicount_1.uniToStrPos(s, endUni);
      return s.slice(start, end);
    };
    var dslice = (d, start, end) => typeof d === "number" ? end == null ? d - start : Math.min(d, end) - start : exports2.uniSlice(d, start, end);
    var makeTake = (op) => {
      let idx = 0;
      let offset = 0;
      const take3 = (n, indivisableField) => {
        if (idx === op.length)
          return n === -1 ? null : n;
        const c = op[idx];
        let part;
        if (typeof c === "number") {
          if (n === -1 || c - offset <= n) {
            part = c - offset;
            ++idx;
            offset = 0;
            return part;
          } else {
            offset += n;
            return n;
          }
        } else if (typeof c === "string") {
          if (n === -1 || indivisableField === "i" || unicount_1.strPosToUni(c.slice(offset)) <= n) {
            part = c.slice(offset);
            ++idx;
            offset = 0;
            return part;
          } else {
            const offset2 = offset + unicount_1.uniToStrPos(c.slice(offset), n);
            part = c.slice(offset, offset2);
            offset = offset2;
            return part;
          }
        } else {
          if (n === -1 || indivisableField === "d" || exports2.dlen(c.d) - offset <= n) {
            part = { d: dslice(c.d, offset) };
            ++idx;
            offset = 0;
            return part;
          } else {
            let result = dslice(c.d, offset, offset + n);
            offset += n;
            return { d: result };
          }
        }
      };
      const peek = () => op[idx];
      return { take: take3, peek };
    };
    var trim = (op) => {
      if (op.length > 0 && typeof op[op.length - 1] === "number") {
        op.pop();
      }
      return op;
    };
    function transform(op1, op2, side) {
      if (side !== "left" && side !== "right") {
        throw Error("side (" + side + ") must be 'left' or 'right'");
      }
      checkOp(op1);
      checkOp(op2);
      const newOp = [];
      const append = makeAppend(newOp);
      const { take: take3, peek } = makeTake(op1);
      for (let i = 0; i < op2.length; i++) {
        const c2 = op2[i];
        let length, c1;
        switch (typeof c2) {
          case "number":
            length = c2;
            while (length > 0) {
              c1 = take3(length, "i");
              append(c1);
              if (typeof c1 !== "string") {
                length -= componentLength(c1);
              }
            }
            break;
          case "string":
            if (side === "left") {
              if (typeof peek() === "string") {
                append(take3(-1));
              }
            }
            append(unicount_1.strPosToUni(c2));
            break;
          case "object":
            length = exports2.dlen(c2.d);
            while (length > 0) {
              c1 = take3(length, "i");
              switch (typeof c1) {
                case "number":
                  length -= c1;
                  break;
                case "string":
                  append(c1);
                  break;
                case "object":
                  length -= exports2.dlen(c1.d);
              }
            }
            break;
        }
      }
      let c;
      while (c = take3(-1))
        append(c);
      if (debugMode && isInvertible(op1) && isInvertible(op2) && !isInvertible(newOp)) {
        throw Error("Internal error - composed operation should also be invertible");
      }
      return trim(newOp);
    }
    function compose(op1, op2) {
      checkOp(op1);
      checkOp(op2);
      const result = [];
      const append = makeAppend(result);
      const { take: take3 } = makeTake(op1);
      for (let i = 0; i < op2.length; i++) {
        const component = op2[i];
        let length, chunk;
        switch (typeof component) {
          case "number":
            length = component;
            while (length > 0) {
              chunk = take3(length, "d");
              append(chunk);
              if (typeof chunk !== "object") {
                length -= componentLength(chunk);
              }
            }
            break;
          case "string":
            append(component);
            break;
          case "object":
            length = exports2.dlen(component.d);
            let offset = 0;
            while (offset < length) {
              chunk = take3(length - offset, "d");
              switch (typeof chunk) {
                case "number":
                  append({ d: dslice(component.d, offset, offset + chunk) });
                  offset += chunk;
                  break;
                case "string":
                  offset += unicount_1.strPosToUni(chunk);
                  break;
                case "object":
                  append(chunk);
              }
            }
            break;
        }
      }
      let c;
      while (c = take3(-1))
        append(c);
      if (debugMode && isInvertible(op1) && isInvertible(op2) && !isInvertible(result)) {
        throw Error("Internal error - composed operation should also be invertible");
      }
      return trim(result);
    }
    var transformPosition = (cursor, op) => {
      let pos = 0;
      for (let i = 0; i < op.length && cursor > pos; i++) {
        const c = op[i];
        switch (typeof c) {
          case "number": {
            pos += c;
            break;
          }
          case "string":
            const offset = unicount_1.strPosToUni(c);
            pos += offset;
            cursor += offset;
            break;
          case "object":
            cursor -= Math.min(exports2.dlen(c.d), cursor - pos);
            break;
        }
      }
      return cursor;
    };
    var transformSelection = (selection, op) => typeof selection === "number" ? transformPosition(selection, op) : selection.map((s) => transformPosition(s, op));
    function makeInvertible(op, doc, ropeImpl) {
      return mapOp(op, (c, prePos) => typeof c === "object" && typeof c.d === "number" ? { d: ropeImpl.slice(doc, prePos, prePos + c.d) } : c);
    }
    function invert(op) {
      return mapOp(op, (c) => {
        switch (typeof c) {
          case "object":
            if (typeof c.d === "number") {
              throw Error("Cannot invert text op: Deleted characters missing from operation. makeInvertible must be called first.");
            } else
              return c.d;
          // delete -> insert
          case "string":
            return { d: c };
          // Insert -> delete
          case "number":
            return c;
        }
      });
    }
    function stripInvertible(op) {
      return mapOp(op, (c) => typeof c === "object" && typeof c.d === "string" ? { d: unicount_1.strPosToUni(c.d) } : c);
    }
    function isInvertible(op) {
      let invertible = true;
      eachOp(op, (c) => {
        if (typeof c === "object" && typeof c.d === "number")
          invertible = false;
      });
      return invertible;
    }
    function makeType(ropeImpl) {
      return {
        name: "text-unicode",
        uri: "http://sharejs.org/types/text-unicode",
        trim,
        normalize,
        checkOp,
        /** Create a new text snapshot.
         *
         * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
         * @returns {Snap} Initial document snapshot object
         */
        create(initial = "") {
          if (typeof initial !== "string") {
            throw Error("Initial data must be a string");
          }
          return ropeImpl.create(initial);
        },
        /** Apply an operation to a document snapshot
         */
        apply(str, op) {
          checkOp(op);
          const builder = ropeImpl.builder(str);
          for (let i = 0; i < op.length; i++) {
            const component = op[i];
            switch (typeof component) {
              case "number":
                builder.skip(component);
                break;
              case "string":
                builder.append(component);
                break;
              case "object":
                builder.del(exports2.dlen(component.d));
                break;
            }
          }
          return builder.build();
        },
        transform,
        compose,
        transformPosition,
        transformSelection,
        isInvertible,
        makeInvertible(op, doc) {
          return makeInvertible(op, doc, ropeImpl);
        },
        stripInvertible,
        invert,
        invertWithDoc(op, doc) {
          return invert(makeInvertible(op, doc, ropeImpl));
        },
        isNoop: (op) => op.length === 0
      };
    }
    exports2.default = makeType;
  }
});

// ../node_modules/.pnpm/ot-text-unicode@4.0.0/node_modules/ot-text-unicode/dist/api.js
var require_api = __commonJS({
  "../node_modules/.pnpm/ot-text-unicode@4.0.0/node_modules/ot-text-unicode/dist/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var type_1 = require_type();
    var unicount_1 = require_unicount();
    function api(getSnapshot, submitOp) {
      return {
        // Returns the text content of the document
        get: getSnapshot,
        // Returns the number of characters in the string
        getLength() {
          return getSnapshot().length;
        },
        // Insert the specified text at the given position in the document
        insert(pos, text, callback) {
          const uniPos = unicount_1.strPosToUni(getSnapshot(), pos);
          return submitOp([uniPos, text], callback);
        },
        remove(pos, lengthOrContent, callback) {
          const uniPos = unicount_1.strPosToUni(getSnapshot(), pos);
          return submitOp([uniPos, { d: lengthOrContent }], callback);
        },
        // When you use this API, you should implement these two methods
        // in your editing context.
        //onInsert: function(pos, text) {},
        //onRemove: function(pos, removedLength) {},
        _onOp(op) {
          type_1.eachOp(op, (component, prePos, postPos) => {
            switch (typeof component) {
              case "string":
                if (this.onInsert)
                  this.onInsert(postPos, component);
                break;
              case "object":
                const dl = type_1.dlen(component.d);
                if (this.onRemove)
                  this.onRemove(postPos, dl);
            }
          });
        },
        onInsert: null,
        onRemove: null
      };
    }
    exports2.default = api;
    api.provides = { text: true };
  }
});

// ../node_modules/.pnpm/ot-text-unicode@4.0.0/node_modules/ot-text-unicode/dist/index.js
var require_dist = __commonJS({
  "../node_modules/.pnpm/ot-text-unicode@4.0.0/node_modules/ot-text-unicode/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule) return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3) if (Object.hasOwnProperty.call(mod3, k)) __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.type = exports2.remove = exports2.insert = void 0;
    var unicount_1 = require_unicount();
    var type_1 = __importStar(require_type());
    var api_1 = __importDefault(require_api());
    var ropeImplUnicodeString = {
      create(s) {
        return s;
      },
      toString(s) {
        return s;
      },
      builder(oldDoc) {
        if (typeof oldDoc !== "string")
          throw Error("Invalid document snapshot: " + oldDoc);
        const newDoc = [];
        return {
          skip(n) {
            let offset = unicount_1.uniToStrPos(oldDoc, n);
            if (offset > oldDoc.length)
              throw Error("The op is too long for this document");
            newDoc.push(oldDoc.slice(0, offset));
            oldDoc = oldDoc.slice(offset);
          },
          append(s) {
            newDoc.push(s);
          },
          del(n) {
            oldDoc = oldDoc.slice(unicount_1.uniToStrPos(oldDoc, n));
          },
          build() {
            return newDoc.join("") + oldDoc;
          }
        };
      },
      slice: type_1.uniSlice
    };
    var textString = type_1.default(ropeImplUnicodeString);
    var type2 = Object.assign(Object.assign({}, textString), { api: api_1.default });
    exports2.type = type2;
    exports2.insert = (pos, text) => text.length === 0 ? [] : pos === 0 ? [text] : [pos, text];
    exports2.remove = (pos, textOrLen) => type_1.dlen(textOrLen) === 0 ? [] : pos === 0 ? [{ d: textOrLen }] : [pos, { d: textOrLen }];
    var type_2 = require_type();
    Object.defineProperty(exports2, "makeType", { enumerable: true, get: function() {
      return type_2.default;
    } });
  }
});

// ../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/json1.release.js
var require_json1_release = __commonJS({
  "../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/json1.release.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : {
        default: mod3
      };
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    }), exports2.editOp = exports2.replaceOp = exports2.insertOp = exports2.moveOp = exports2.removeOp = exports2.type = void 0;
    var deepEqual_js_1 = __importDefault(require_deepEqual());
    var deepClone_js_1 = __importDefault(require_deepClone());
    var cursor_js_1 = require_cursor();
    var types_js_1 = require_types2();
    var log3 = () => {
    };
    function assert(pred, msg) {
      if (!pred) throw new Error(msg);
    }
    var debugMode = false;
    exports2.type = {
      name: "json1",
      uri: "http://sharejs.org/types/JSONv1",
      readCursor: cursor_js_1.readCursor,
      writeCursor: cursor_js_1.writeCursor,
      create: (data) => data,
      isNoop: (op) => null == op,
      setDebug(val) {
        debugMode = val, log3.quiet = !val;
      },
      registerSubtype,
      checkValidOp,
      normalize,
      apply: apply2,
      transformPosition,
      compose,
      tryTransform,
      transform,
      makeInvertible,
      invert,
      invertWithDoc,
      RM_UNEXPECTED_CONTENT: types_js_1.ConflictType.RM_UNEXPECTED_CONTENT,
      DROP_COLLISION: types_js_1.ConflictType.DROP_COLLISION,
      BLACKHOLE: types_js_1.ConflictType.BLACKHOLE,
      transformNoConflict: (op1, op2, side) => transformWithConflictsPred(() => true, op1, op2, side),
      typeAllowingConflictsPred: (allowConflict) => Object.assign(Object.assign({}, exports2.type), {
        transform: (op1, op2, side) => transformWithConflictsPred(allowConflict, op1, op2, side)
      })
    };
    var getComponent = (r) => r ? r.getComponent() : null;
    function isObject2(o) {
      return o && "object" == typeof o && !Array.isArray(o);
    }
    var shallowClone = (obj) => Array.isArray(obj) ? obj.slice() : null !== obj && "object" == typeof obj ? Object.assign({}, obj) : obj;
    var hasPick = (c) => c && (null != c.p || void 0 !== c.r);
    var hasDrop = (c) => c && (null != c.d || void 0 !== c.i);
    function removeChild(container, key) {
      return assert(null != container), "number" == typeof key ? (assert(Array.isArray(container), "Invalid key - child is not an array"), (container = container.slice()).splice(key, 1)) : (assert(isObject2(container), "Invalid key - child is not an object"), delete (container = Object.assign({}, container))[key]), container;
    }
    function insertChildMut(container, key, value) {
      return "number" == typeof key ? (assert(null != container, "Container is missing for key"), assert(Array.isArray(container), "Cannot use numerical key for object container"), assert(container.length >= key, "Cannot insert into out of bounds index"), container.splice(key, 0, value)) : (assert(isObject2(container), "Cannot insert into missing item"), assert(void 0 === container[key], "Trying to overwrite value at key. Your op needs to remove it first"), container[key] = value), value;
    }
    exports2.removeOp = (path, value = true) => cursor_js_1.writeCursor().writeAtPath(path, "r", value).get(), exports2.moveOp = (from, to) => cursor_js_1.writeCursor().writeMove(from, to).get(), exports2.insertOp = (path, value) => cursor_js_1.writeCursor().writeAtPath(path, "i", value).get(), exports2.replaceOp = (path, oldVal, newVal) => cursor_js_1.writeCursor().at(path, (w) => {
      w.write("r", oldVal), w.write("i", newVal);
    }).get(), exports2.editOp = (path, type2, subOp, preserveNoop = false) => cursor_js_1.writeCursor().at(path, (w) => writeEdit(w, type2, subOp, preserveNoop)).get();
    var isValidKey = (container, key) => null != container && ("number" == typeof key ? Array.isArray(container) : "object" == typeof container);
    var maybeGetChild = (container, key) => isValidKey(container, key) ? container[key] : void 0;
    var subtypes = {};
    function registerSubtype(subtype) {
      let _subtype = subtype.type ? subtype.type : subtype;
      _subtype.name && (subtypes[_subtype.name] = _subtype), _subtype.uri && (subtypes[_subtype.uri] = _subtype);
    }
    var typeOrThrow = (name) => {
      const type2 = subtypes[name];
      if (type2) return type2;
      throw Error("Missing type: " + name);
    };
    registerSubtype(require_dist());
    var add2 = (a2, b) => a2 + b;
    registerSubtype({
      name: "number",
      apply: add2,
      compose: add2,
      invert: (n) => -n,
      transform: (a2) => a2
    });
    var getEditType = (c) => null == c ? null : c.et ? typeOrThrow(c.et) : c.es ? subtypes["text-unicode"] : null != c.ena ? subtypes.number : null;
    var getEdit = (c) => c.es ? c.es : null != c.ena ? c.ena : c.e;
    var writeEdit = (w, typeOrName, edit, preserveNoop = false) => {
      const [type2, name] = "string" == typeof typeOrName ? [typeOrThrow(typeOrName), typeOrName] : [typeOrName, typeOrName.name];
      !preserveNoop && type2.isNoop && type2.isNoop(edit) || ("number" === name ? w.write("ena", edit) : "text-unicode" === name ? w.write("es", edit) : (w.write("et", name), w.write("e", edit)));
    };
    function checkNonNegInteger(n) {
      assert("number" == typeof n), assert(n >= 0), assert(n === (0 | n));
    }
    function checkScalar(s) {
      "number" == typeof s ? checkNonNegInteger(s) : assert("string" == typeof s);
    }
    function checkValidOp(op) {
      if (null === op) return;
      const pickedSlots = /* @__PURE__ */ new Set(), droppedSlots = /* @__PURE__ */ new Set(), checkComponent = (e) => {
        let empty = true, hasEdit = false;
        for (let k in e) {
          const v = e[k];
          if (empty = false, assert("p" === k || "r" === k || "d" === k || "i" === k || "e" === k || "es" === k || "ena" === k || "et" === k, "Invalid component item '" + k + "'"), "p" === k) checkNonNegInteger(v), assert(!pickedSlots.has(v)), pickedSlots.add(v), assert(void 0 === e.r);
          else if ("d" === k) checkNonNegInteger(v), assert(!droppedSlots.has(v)), droppedSlots.add(v), assert(void 0 === e.i);
          else if ("e" === k || "es" === k || "ena" === k) {
            assert(!hasEdit), hasEdit = true;
            const t = getEditType(e);
            assert(t, "Missing type in edit"), t.checkValidOp && t.checkValidOp(getEdit(e));
          }
        }
        assert(!empty);
      }, checkDescent = (descent, isRoot, removed) => {
        if (!Array.isArray(descent)) throw Error("Op must be null or a list");
        if (0 === descent.length) throw Error("Empty descent");
        isRoot || checkScalar(descent[0]);
        let last = 1, numDescents = 0, lastKey = 0;
        for (let i = 0; i < descent.length; i++) {
          const d = descent[i];
          if (assert(null != d), Array.isArray(d)) {
            const key = checkDescent(d, false, removed);
            if (numDescents) {
              const t1 = typeof lastKey, t2 = typeof key;
              t1 === t2 ? assert(lastKey < key, "descent keys are not in order") : assert("number" === t1 && "string" === t2);
            }
            lastKey = key, numDescents++, last = 3;
          } else "object" == typeof d ? (assert(1 === last, `Prev not scalar - instead ${last}`), checkComponent(d), last = 2) : (assert(3 !== last), checkScalar(d), assert(cursor_js_1.isValidPathItem(d), "Invalid path key"), last = 1);
        }
        return assert(1 !== numDescents, "Operation makes multiple descents. Remove some []"), assert(2 === last || 3 === last), descent[0];
      };
      checkDescent(op, true, false), assert(pickedSlots.size === droppedSlots.size, "Mismatched picks and drops in op");
      for (let i = 0; i < pickedSlots.size; i++) assert(pickedSlots.has(i)), assert(droppedSlots.has(i));
    }
    function normalize(op) {
      let nextSlot = 0, slotMap = [];
      const w = cursor_js_1.writeCursor();
      return w.mergeTree(op, (c, w2) => {
        const t = getEditType(c);
        if (t) {
          const op2 = getEdit(c);
          writeEdit(w2, t, t.normalize ? t.normalize(op2) : op2);
        }
        for (const k of ["r", "p", "i", "d"]) if (void 0 !== c[k]) {
          const r = "p" === k || "d" === k ? (inSlot = c[k], null == slotMap[inSlot] && (slotMap[inSlot] = nextSlot++), slotMap[inSlot]) : c[k];
          w2.write(k, r);
        }
        var inSlot;
      }), w.get();
    }
    function apply2(snapshot, op) {
      if (log3.quiet = !debugMode, checkValidOp(op), null === op) return snapshot;
      const held = [];
      return function drop(root2, descent) {
        let subDoc = root2, i = 0, rootContainer = {
          root: root2
        }, m = 0, container = rootContainer, key = "root";
        function mut() {
          for (; m < i; m++) {
            let d = descent[m];
            "object" != typeof d && (assert(isValidKey(container, key)), container = container[key] = shallowClone(container[key]), key = d);
          }
        }
        for (; i < descent.length; i++) {
          const d = descent[i];
          if (Array.isArray(d)) {
            const child = drop(subDoc, d);
            child !== subDoc && void 0 !== child && (mut(), subDoc = container[key] = child);
          } else if ("object" == typeof d) {
            null != d.d ? (mut(), subDoc = insertChildMut(container, key, held[d.d])) : void 0 !== d.i && (mut(), subDoc = insertChildMut(container, key, d.i));
            const t = getEditType(d);
            if (t) mut(), subDoc = container[key] = t.apply(subDoc, getEdit(d));
            else if (void 0 !== d.e) throw Error("Subtype " + d.et + " undefined");
          } else subDoc = maybeGetChild(subDoc, d);
        }
        return rootContainer.root;
      }(snapshot = function pick(subDoc, descent) {
        const stack = [];
        let i = 0;
        for (; i < descent.length; i++) {
          const d = descent[i];
          if (Array.isArray(d)) break;
          "object" != typeof d && (stack.push(subDoc), subDoc = maybeGetChild(subDoc, d));
        }
        for (let j = descent.length - 1; j >= i; j--) subDoc = pick(subDoc, descent[j]);
        for (--i; i >= 0; i--) {
          const d = descent[i];
          if ("object" != typeof d) {
            const container = stack.pop();
            subDoc = subDoc === maybeGetChild(container, d) ? container : void 0 === subDoc ? removeChild(container, d) : (k = d, v = subDoc, (obj = shallowClone(obj = container))[k] = v, obj);
          } else hasPick(d) && (assert(void 0 !== subDoc, "Cannot pick up or remove undefined"), null != d.p && (held[d.p] = subDoc), subDoc = void 0);
        }
        var obj, k, v;
        return subDoc;
      }(snapshot, op), op);
    }
    function transformPosition(path, op) {
      path = path.slice(), checkValidOp(op);
      const r = cursor_js_1.readCursor(op);
      let pickedAtSlot, pickIndex, removed = false;
      const advStack = [];
      for (let i = 0; ; i++) {
        const k = path[i], c = r.getComponent();
        if (c && (void 0 !== c.r ? removed = true : null != c.p && (removed = false, pickedAtSlot = c.p, pickIndex = i)), i >= path.length) break;
        let pickOffset = 0;
        const pickAdv = cursor_js_1.advancer(r, void 0, (k2, c2) => {
          hasPick(c2) && pickOffset++;
        });
        advStack.unshift(pickAdv);
        const hasNext = pickAdv(k);
        if ("number" == typeof k && (path[i] -= pickOffset), !hasNext) break;
      }
      if (advStack.forEach((pickAdv) => pickAdv.end()), removed) return null;
      const handleDrop = () => {
        let i = 0;
        if (null != pickedAtSlot) {
          const rPath = r.getPath();
          i = rPath.length, path = rPath.concat(path.slice(pickIndex));
        }
        for (; i < path.length; i++) {
          const k = path[i], c = getComponent(r), et = getEditType(c);
          if (et) {
            const e = getEdit(c);
            et.transformPosition && (path[i] = et.transformPosition(path[i], e));
            break;
          }
          let dropOffset = 0;
          const hasNext = cursor_js_1.advancer(r, (k2, c2) => hasDrop(c2) ? ~(k2 - dropOffset) : k2 - dropOffset, (k2, c2) => {
            hasDrop(c2) && dropOffset++;
          })(k);
          if ("number" == typeof k && (path[i] += dropOffset), !hasNext) break;
        }
      };
      return null != pickedAtSlot ? r.eachDrop(null, (slot) => {
        slot === pickedAtSlot && handleDrop();
      }) : handleDrop(), path;
    }
    function compose(op1, op2) {
      if (checkValidOp(op1), checkValidOp(op2), null == op1) return op2;
      if (null == op2) return op1;
      let nextSlot = 0;
      const r1 = cursor_js_1.readCursor(op1), r2 = cursor_js_1.readCursor(op2), w = cursor_js_1.writeCursor(), heldPickWrites = [], heldDropWrites = [], held1Pick = [], held2Drop = [], p1SlotMap = [], p2SlotMap = [], visitedOp2EditCs = /* @__PURE__ */ new Set();
      r1.traverse(null, (c) => {
        null != c.p && (held1Pick[c.p] = r1.clone());
      }), r2.traverse(null, (c) => {
        null != c.d && (held2Drop[c.d] = r2.clone());
      });
      const w2 = cursor_js_1.writeCursor();
      return function xfBoundary(r1Pick, r1Drop, r2Pick, r2Drop, litIn, rmParent, wd, wp) {
        assert(r1Drop || r2Pick);
        const c1d = getComponent(r1Drop), c2p = getComponent(r2Pick), rmHere = !!c2p && void 0 !== c2p.r, insHere = !!c1d && void 0 !== c1d.i, drop1Slot = c1d ? c1d.d : null, pick2Slot = c2p ? c2p.p : null, rmChildren = (rmParent || rmHere) && null == pick2Slot;
        if (null != pick2Slot) r2Drop = held2Drop[pick2Slot], wd = heldDropWrites[pick2Slot] = new cursor_js_1.WriteCursor();
        else if (c2p && void 0 !== c2p.r) r2Drop = null;
        else {
          const c2d2 = getComponent(r2Drop);
          c2d2 && null != c2d2.d && (r2Drop = null);
        }
        const c2d = getComponent(r2Drop);
        if (null != drop1Slot) if (r1Pick = held1Pick[drop1Slot], wp = heldPickWrites[drop1Slot] = new cursor_js_1.WriteCursor(), rmChildren) rmParent && !rmHere && wp.write("r", true);
        else {
          const slot = p1SlotMap[drop1Slot] = nextSlot++;
          wd.write("d", slot);
        }
        else if (c1d && void 0 !== c1d.i) r1Pick = null;
        else {
          const c1p = getComponent(r1Pick);
          c1p && null != c1p.p && (r1Pick = null);
        }
        let litOut;
        insHere ? (assert(void 0 === litIn), litOut = c1d.i) : litOut = litIn;
        const insComponent = (null == pick2Slot ? !insHere || rmParent || rmHere : void 0 === litOut) ? null : wd.getComponent();
        if (null != pick2Slot) if (void 0 !== litIn || insHere) ;
        else {
          const slot = null != drop1Slot ? p1SlotMap[drop1Slot] : nextSlot++;
          p2SlotMap[pick2Slot] = slot, wp.write("p", slot);
        }
        else rmHere && (insHere || void 0 !== litIn || (c2p.r, wp.write("r", c2p.r)));
        const type1 = rmChildren ? null : getEditType(c1d), type2 = getEditType(c2d);
        if ((type1 || type2) && (type1 && type1.name, type2 && type2.name), type1 && type2) {
          assert(type1 === type2);
          const e1 = getEdit(c1d), e2 = getEdit(c2d), r = type1.compose(e1, e2);
          writeEdit(wd, type1, r), visitedOp2EditCs.add(c2d);
        } else type1 ? writeEdit(wd, type1, getEdit(c1d)) : type2 && (writeEdit(wd, type2, getEdit(c2d)), visitedOp2EditCs.add(c2d));
        const hasContainerLiteral = "object" == typeof litOut && null != litOut;
        let isCloned = false, p1PickOff = 0, p1DropOff = 0, p2PickOff = 0, p2DropOff = 0, litOff = 0;
        const p2DropAdv = cursor_js_1.advancer(r2Drop, (k, c) => hasDrop(c) ? p2DropOff - k - 1 : k - p2DropOff, (k, c) => {
          hasDrop(c) && p2DropOff++;
        }), p1PickAdv = cursor_js_1.advancer(r1Pick, (k, c) => hasPick(c) ? p1PickOff - k - 1 : k - p1PickOff, (k, c) => {
          hasPick(c) && p1PickOff++;
        });
        if (cursor_js_1.eachChildOf(r1Drop, r2Pick, (inKey, _p1Drop, _p2Pick) => {
          let _p1Pick, _p2Drop, p1PickKey = inKey, p2DropKey = inKey, litKey = inKey;
          if ("number" == typeof inKey) {
            let p2Mid = inKey + p2PickOff;
            _p2Drop = p2DropAdv(p2Mid), p2DropKey = p2Mid + p2DropOff;
            let p1Mid = inKey + p1DropOff;
            _p1Pick = p1PickAdv(p1Mid), hasDrop(getComponent(_p2Drop)) && (_p1Pick = null), p1PickKey = p1Mid + p1PickOff, litKey = inKey + litOff, assert(p1PickKey >= 0, "p1PickKey is negative"), assert(p2DropKey >= 0, "p2DropKey is negative");
            const hd1 = hasDrop(getComponent(_p1Drop)), hp2 = hasPick(getComponent(_p2Pick));
            (hd1 || hp2 && !rmChildren) && litOff--, hd1 && p1DropOff--, hp2 && p2PickOff--;
          } else _p1Pick = p1PickAdv(inKey), _p2Drop = p2DropAdv(inKey);
          wp.descend(p1PickKey), wd.descend(p2DropKey);
          const _lit = hasContainerLiteral && !hasDrop(getComponent(_p1Drop)) ? litOut[litKey] : void 0, _litResult = xfBoundary(_p1Pick, _p1Drop, _p2Pick, _p2Drop, _lit, rmChildren, wd, wp);
          var container, key, child;
          hasContainerLiteral && !rmChildren ? _lit !== _litResult && (isCloned || (litOut = Array.isArray(litOut) ? litOut.slice() : Object.assign({}, litOut), isCloned = true), container = litOut, child = _litResult, "number" == typeof (key = litKey) ? (assert(Array.isArray(container)), assert(key < container.length)) : (assert(!Array.isArray(container)), assert(void 0 !== container[key])), void 0 === child ? "number" == typeof key ? container.splice(key, 1) : delete container[key] : container[key] = child) : assert(void 0 === _litResult), wd.ascend(), wp.ascend();
        }), p1PickAdv.end(), p2DropAdv.end(), null != insComponent) insComponent.i = litOut;
        else if (!rmParent && !rmHere && null == pick2Slot) return litOut;
      }(r1, r1.clone(), r2, r2.clone(), void 0, false, w, w2), w.reset(), w.mergeTree(w2.get()), w.reset(), w.get(), heldPickWrites.map((w3) => w3.get()), heldDropWrites.map((w3) => w3.get()), r1.traverse(w, (c, w3) => {
        const slot1 = c.p;
        if (null != slot1) {
          const slot = p1SlotMap[slot1];
          null != slot && w3.write("p", slot);
          const _w = heldPickWrites[slot1];
          _w && _w.get(), _w && w3.mergeTree(_w.get());
        } else void 0 !== c.r && w3.write("r", c.r);
      }), w.reset(), w.get(), r2.traverse(w, (c, w3) => {
        const slot2 = c.d;
        if (null != slot2) {
          const slot = p2SlotMap[slot2];
          null != slot && w3.write("d", slot);
          const _w = heldDropWrites[slot2];
          _w && w3.mergeTree(_w.get());
        } else void 0 !== c.i && w3.write("i", c.i);
        const t = getEditType(c);
        t && !visitedOp2EditCs.has(c) && writeEdit(w3, t, getEdit(c));
      }), w.get();
    }
    function invert(op) {
      if (null == op) return null;
      const r = new cursor_js_1.ReadCursor(op), w = new cursor_js_1.WriteCursor();
      let editsToTransform;
      const heldPick = [], heldWrites = [];
      return function invertSimple(r2, w2, subDoc) {
        const c = r2.getComponent();
        let insertHere, subdocModified = false;
        if (c) {
          null != c.p && (w2.write("d", c.p), heldPick[c.p] = r2.clone()), void 0 !== c.r && w2.write("i", c.r), null != c.d && (w2.write("p", c.d), subDoc = void 0), void 0 !== c.i && (subDoc = insertHere = c.i);
          const t = getEditType(c);
          t && (void 0 === subDoc ? (editsToTransform || (editsToTransform = /* @__PURE__ */ new Set()), editsToTransform.add(c)) : (getEdit(c), subDoc = t.apply(subDoc, getEdit(c)), subdocModified = true));
        }
        let dropOff = 0;
        for (const key of r2) {
          w2.descend(key);
          const raw = "number" == typeof key ? key - dropOff : key, childIn = maybeGetChild(subDoc, raw);
          hasDrop(r2.getComponent()) && dropOff++;
          const childOut = invertSimple(r2, w2, childIn);
          if (void 0 !== subDoc && void 0 !== childOut) {
            if (subdocModified || (subdocModified = true, subDoc = shallowClone(subDoc)), !isValidKey(subDoc, raw)) throw Error("Cannot modify child - invalid operation");
            subDoc[raw] = childOut;
          }
          w2.ascend();
        }
        if (void 0 === insertHere) return subdocModified ? subDoc : void 0;
        w2.write("r", subDoc);
      }(r, w, void 0), editsToTransform && (w.reset(), function transformEdits(rPick, rDrop, w2) {
        const cd = rDrop.getComponent();
        if (cd) {
          const dropSlot = cd.d;
          if (null != dropSlot && (rPick = heldPick[dropSlot], w2 = heldWrites[dropSlot] = cursor_js_1.writeCursor()), editsToTransform.has(cd)) {
            const t = getEditType(cd);
            if (!t.invert) throw Error(`Cannot invert subtype ${t.name}`);
            writeEdit(w2, t, t.invert(getEdit(cd)));
          }
        }
        let pickOff = 0, dropOff = 0;
        const ap = cursor_js_1.advancer(rPick, (k, c) => hasPick(c) ? pickOff - k - 1 : k - pickOff, (k, c) => {
          hasPick(c) && pickOff++;
        });
        for (const key of rDrop) if ("number" == typeof key) {
          const mid = key - dropOff, _rPick = ap(mid), raw = mid + pickOff;
          w2.descend(raw), transformEdits(_rPick, rDrop, w2), hasDrop(rDrop.getComponent()) && dropOff++, w2.ascend();
        } else w2.descend(key), transformEdits(ap(key), rDrop, w2), w2.ascend();
        ap.end();
      }(r.clone(), r, w), heldWrites.length && (w.reset(), r.traverse(w, (c, w2) => {
        const slot = c.p;
        if (null != slot) {
          const _w = heldWrites[slot];
          _w && _w.get(), _w && w2.mergeTree(_w.get());
        }
      }))), w.get();
    }
    var anyComponent = (op, fn) => op.some((c) => "object" == typeof c && (Array.isArray(c) ? anyComponent(c, fn) : fn(c)));
    function makeInvertible(op, doc) {
      if (null == op || !anyComponent(op, (c) => {
        var _a2;
        return void 0 !== c.r || null != (null === (_a2 = getEditType(c)) || void 0 === _a2 ? void 0 : _a2.makeInvertible);
      })) return op;
      const r = new cursor_js_1.ReadCursor(op), w = new cursor_js_1.WriteCursor();
      let hasEdits = false;
      const heldPick = [], heldDoc = [], traversePick = (r2, w2, subDoc) => {
        const c = r2.getComponent();
        let modified = false;
        if (c) {
          null != c.d && w2.write("d", c.d), void 0 !== c.i && w2.write("i", c.i);
          const pickSlot = c.p;
          if (null != pickSlot && (heldPick[pickSlot] = r2.clone(), assert(void 0 !== subDoc, "Operation picks up at an invalid key"), heldDoc[pickSlot] = subDoc, w2.write("p", c.p)), void 0 !== c.r && void 0 === subDoc) throw Error("Invalid doc / op in makeInvertible: removed item missing from doc");
          const t = getEditType(c);
          t && (t.makeInvertible ? hasEdits = true : writeEdit(w2, t, getEdit(c), true));
        }
        let listOff = 0;
        for (const key of r2) {
          w2.descend(key);
          const keyRaw = "number" == typeof key ? key - listOff : key, childIn = maybeGetChild(subDoc, keyRaw), childOut = traversePick(r2, w2, childIn);
          childIn !== childOut && (modified || (modified = true, subDoc = shallowClone(subDoc)), void 0 === childOut ? (subDoc = removeChild(subDoc, keyRaw), "number" == typeof key && listOff++) : subDoc[keyRaw] = childOut), w2.ascend();
        }
        return c && (void 0 !== c.r ? (w2.write("r", deepClone_js_1.default(subDoc)), subDoc = void 0) : null != c.p && (subDoc = void 0)), subDoc;
      };
      return traversePick(r, w, doc), w.get(), hasEdits && (w.reset(), function traverseDrop(rPick, rDrop, w2, subDoc, isLiteral) {
        const c = rDrop.getComponent();
        if (c) {
          void 0 !== c.i ? (subDoc = c.i, isLiteral = true) : null != c.d && (subDoc = heldDoc[c.d], rPick = heldPick[c.d], isLiteral = false, c.d);
          let t = getEditType(c);
          if (t && t.makeInvertible) {
            const edit = getEdit(c);
            writeEdit(w2, t, t.makeInvertible(edit, subDoc), true);
          }
        }
        let pickOff = 0, dropOff = 0;
        const ap = cursor_js_1.advancer(rPick, (k, c2) => hasPick(c2) ? pickOff - k - 1 : k - pickOff, (k, c2) => {
          hasPick(c2) && pickOff++;
        });
        for (const key of rDrop) if ("number" == typeof key) {
          const mid = key - dropOff, _rPick = ap(mid), raw = mid + pickOff, child = maybeGetChild(subDoc, isLiteral ? mid : raw);
          w2.descend(key), traverseDrop(_rPick, rDrop, w2, child, isLiteral), hasDrop(rDrop.getComponent()) && dropOff++, w2.ascend();
        } else {
          const child = maybeGetChild(subDoc, key);
          w2.descend(key), traverseDrop(ap(key), rDrop, w2, child, isLiteral), w2.ascend();
        }
        ap.end();
      }(r.clone(), r, w, doc, false)), w.get();
    }
    function invertWithDoc(op, doc) {
      return invert(makeInvertible(op, doc));
    }
    var shallowCloneOp = (op) => {
      if (null == op) return null;
      const result = op.slice();
      for (let i = 0; i < op.length; i++) {
        const c = result[i];
        Array.isArray(c) && (result[i] = shallowCloneOp(c));
      }
      return result;
    };
    function tryTransform(op1, op2, direction) {
      assert("left" === direction || "right" === direction, "Direction must be left or right");
      const side = "left" === direction ? 0 : 1;
      if (log3.quiet = !debugMode, log3.prefix = 0, null == op2) return {
        ok: true,
        result: op1
      };
      checkValidOp(op1), checkValidOp(op2);
      let conflict = null;
      const heldOp1PickByOp1 = [], heldOp1DropByOp1 = [], heldOp2PickByOp2 = [], heldOp2DropByOp2 = [], heldOp1PickByOp2 = [], heldOp2PickByOp1 = [], heldOp2DropByOp1 = [], heldOp2RmForOp1 = [], heldOp1RmForOp2 = [], cancelledOp2 = [], discardedOp2Drop = [], heldPickWrites = [], heldDropWrites = [], op1PickAtOp2Pick = [], op1PicksOp2DropSlots = [];
      let nextSlot = 0;
      const r1 = cursor_js_1.readCursor(op1), r2 = cursor_js_1.readCursor(op2), w = cursor_js_1.writeCursor();
      if (function scanOp2Pick(r2Pick, r1Pick = null, removed1) {
        const c1 = getComponent(r1Pick);
        c1 && (void 0 !== c1.r ? removed1 = r1Pick.clone() : null != c1.p && (removed1 = null, heldOp2PickByOp1[c1.p] = r2Pick.clone()));
        const c2 = r2Pick.getComponent();
        let slot2;
        c2 && null != (slot2 = c2.p) && (heldOp1PickByOp2[slot2] = r1Pick ? r1Pick.clone() : null, heldOp2PickByOp2[slot2] = r2Pick.clone(), removed1 && (cancelledOp2[slot2] = true, heldOp1RmForOp2[slot2] = removed1), c1 && null != c1.p && (op1PickAtOp2Pick[slot2] = c1.p));
        const ap1 = cursor_js_1.advancer(r1Pick);
        for (const key of r2Pick) scanOp2Pick(r2Pick, ap1(key), removed1);
        ap1.end();
      }(r2, r1, null), function scanOp2Drop(r1Pick, r2Pick, r2Drop, pickSlot1, removed1) {
        const c2d = r2Drop.getComponent();
        let slot2, droppedHere = false;
        c2d && (null != (slot2 = c2d.d) ? (heldOp2DropByOp2[slot2] = r2Drop.clone(), null != pickSlot1 && (null == op1PicksOp2DropSlots[pickSlot1] && (op1PicksOp2DropSlots[pickSlot1] = []), op1PicksOp2DropSlots[pickSlot1].push(slot2)), cancelledOp2[slot2], r1Pick = heldOp1PickByOp2[slot2] || null, r2Pick = heldOp2PickByOp2[slot2] || null, cancelledOp2[slot2] ? (removed1 && (discardedOp2Drop[slot2] = true), removed1 = heldOp1RmForOp2[slot2] || null) : !removed1 || 1 !== side && null != op1PickAtOp2Pick[slot2] || null == conflict && (conflict = {
          type: types_js_1.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: exports2.removeOp(removed1.getPath()),
          op2: exports2.moveOp(r2Pick.getPath(), r2Drop.getPath())
        }), droppedHere = true) : void 0 !== c2d.i && (r1Pick = r2Pick = null, droppedHere = true, removed1 && null == conflict && (conflict = {
          type: types_js_1.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: exports2.removeOp(removed1.getPath()),
          op2: exports2.insertOp(r2Drop.getPath(), c2d.i)
        })));
        const c1p = getComponent(r1Pick);
        c1p && (void 0 !== c1p.r ? removed1 = r1Pick.clone() : null != c1p.p && (c1p.p, pickSlot1 = c1p.p, removed1 = null));
        const t2 = getEditType(c2d);
        t2 && removed1 && null == conflict && (conflict = {
          type: types_js_1.ConflictType.RM_UNEXPECTED_CONTENT,
          op1: exports2.removeOp(removed1.getPath()),
          op2: exports2.editOp(r2Drop.getPath(), t2, getEdit(c2d), true)
        });
        let p2PickOff = 0, p2DropOff = 0;
        const ap2 = cursor_js_1.advancer(r2Pick, (k, c) => hasPick(c) ? p2PickOff - k - 1 : k - p2PickOff, (k, c) => {
          hasPick(c) && p2PickOff++;
        }), ap1 = cursor_js_1.advancer(r1Pick);
        for (const key of r2Drop) if ("number" == typeof key) {
          const p2Mid = key - p2DropOff, _p2Pick = ap2(p2Mid);
          p2DropOff += +scanOp2Drop(ap1(p2Mid + p2PickOff), _p2Pick, r2Drop, pickSlot1, removed1);
        } else {
          const _p2Pick = ap2(key);
          scanOp2Drop(ap1(key), _p2Pick, r2Drop, pickSlot1, removed1);
        }
        return ap2.end(), ap1.end(), droppedHere;
      }(r1, r2, r2.clone(), null, null), heldOp2DropByOp2.map((x) => x && x.get()), conflict) return {
        ok: false,
        conflict
      };
      discardedOp2Drop.map((x) => !!x);
      const pickComponents = [];
      let cancelledRemoves = null;
      !function writeOp1Pick(r1Pick, r2Pick, r2Drop, w2, removed2) {
        let iAmMoved = false;
        const c2p = getComponent(r2Pick);
        if (hasPick(c2p)) {
          const slot2 = c2p.p;
          null != slot2 ? (r2Drop = heldOp2DropByOp2[slot2], w2 = heldPickWrites[slot2] = cursor_js_1.writeCursor(), iAmMoved = true, removed2 = null) : (r2Drop = null, removed2 = r2Pick.clone());
        } else hasDrop(getComponent(r2Drop)) && (r2Drop = null);
        const c1 = r1Pick.getComponent();
        if (c1) {
          const slot1 = c1.p;
          null != slot1 ? (removed2 && (heldOp2RmForOp1[slot1] = removed2), pickComponents[slot1] = removed2 || 1 === side && iAmMoved ? null : w2.getComponent(), heldOp1PickByOp1[slot1] = r1Pick.clone(), r2Drop && (heldOp2DropByOp1[slot1] = r2Drop.clone())) : void 0 !== c1.r && (removed2 || w2.write("r", true), (removed2 || iAmMoved) && (null == cancelledRemoves && (cancelledRemoves = /* @__PURE__ */ new Set()), cancelledRemoves.add(c1)));
        }
        let p2PickOff = 0, p2DropOff = 0;
        const ap2Pick = cursor_js_1.advancer(r2Pick, void 0, (k, c) => {
          hasPick(c) && p2PickOff++;
        }), ap2Drop = cursor_js_1.advancer(r2Drop, (k, c) => hasDrop(c) ? ~(k - p2DropOff) : k - p2DropOff, (k, c) => {
          hasDrop(c) && p2DropOff++;
        });
        if (r1Pick) for (const key of r1Pick) if ("string" == typeof key) {
          const p2Pick_ = ap2Pick(key), p2Drop_ = ap2Drop(key);
          w2.descend(key), writeOp1Pick(r1Pick, p2Pick_, p2Drop_, w2, removed2), w2.ascend();
        } else {
          const p2Pick_ = ap2Pick(key), p2Mid = key - p2PickOff, p2Drop_ = hasPick(getComponent(p2Pick_)) ? null : ap2Drop(p2Mid), finalKey = p2Mid + p2DropOff;
          assert(finalKey >= 0), w2.descend(finalKey), writeOp1Pick(r1Pick, p2Pick_, p2Drop_, w2, removed2), w2.ascend();
        }
        ap2Pick.end(), ap2Drop.end();
      }(r1, r2, r2.clone(), w, null), w.reset();
      let outputSlotMap = [];
      if (function writeOp1Drop(p1Pick, p1Drop, p2Pick, p2Drop, w2, removed2) {
        assert(p1Drop);
        const c1d = p1Drop.getComponent();
        let c2d = getComponent(p2Drop), droppedHere = false;
        const insOrMv = (r12, r22, c) => r12 ? exports2.moveOp(r12.getPath(), r22.getPath()) : exports2.insertOp(r22.getPath(), c.i);
        if (hasDrop(c1d)) {
          const slot1 = c1d.d;
          null != slot1 && (heldOp1DropByOp1[slot1] = p1Drop.clone());
          const pc = null != slot1 ? pickComponents[slot1] : null;
          let identical = false;
          if (void 0 !== c1d.i || null != slot1 && pc) {
            let slot2;
            c2d && (void 0 !== c2d.i || null != (slot2 = c2d.d) && !cancelledOp2[slot2]) && (identical = null != slot2 ? null != slot1 && slot1 === op1PickAtOp2Pick[slot2] : deepEqual_js_1.default(c2d.i, c1d.i), identical || null != slot2 && 1 !== side && null != op1PickAtOp2Pick[slot2] || null == conflict && (conflict = {
              type: types_js_1.ConflictType.DROP_COLLISION,
              op1: insOrMv(null != slot1 ? heldOp1PickByOp1[slot1] : null, p1Drop, c1d),
              op2: insOrMv(null != slot2 ? heldOp2PickByOp2[slot2] : null, p2Drop, c2d)
            })), identical || (removed2 ? null == conflict && (conflict = {
              type: types_js_1.ConflictType.RM_UNEXPECTED_CONTENT,
              op1: insOrMv(null != slot1 ? heldOp1PickByOp1[slot1] : null, p1Drop, c1d),
              op2: exports2.removeOp(removed2.getPath())
            }) : (null != slot1 ? (outputSlotMap[nextSlot] = slot1, w2.write("d", pc.p = nextSlot++)) : w2.write("i", deepClone_js_1.default(c1d.i)), droppedHere = true));
          } else if (null != slot1 && !pc) {
            const h = heldOp2RmForOp1[slot1];
            h && (removed2 = h.clone());
          }
          null != slot1 ? (p1Pick = heldOp1PickByOp1[slot1], p2Pick = heldOp2PickByOp1[slot1], p2Drop = heldOp2DropByOp1[slot1]) : void 0 !== c1d.i && (p1Pick = p2Pick = null, identical || (p2Drop = null));
        } else hasPick(getComponent(p1Pick)) && (p1Pick = p2Pick = p2Drop = null);
        const c1p = getComponent(p1Pick), c2p = getComponent(p2Pick);
        if (hasPick(c2p)) {
          const slot2 = c2p.p;
          void 0 !== c2p.r && (!c1p || void 0 === c1p.r) || cancelledOp2[slot2] ? (p2Drop = null, removed2 = p2Pick.clone()) : null != slot2 && (p2Drop = heldOp2DropByOp2[slot2], 1 !== side && null != op1PickAtOp2Pick[slot2] || ((w2 = heldDropWrites[slot2]) || (w2 = heldDropWrites[slot2] = cursor_js_1.writeCursor()), w2.reset(), removed2 = null));
        } else !hasDrop(c1d) && hasDrop(c2d) && (p2Drop = null);
        c2d = null != p2Drop ? p2Drop.getComponent() : null;
        const t1 = getEditType(c1d);
        if (t1) {
          const e1 = getEdit(c1d);
          if (removed2) null == conflict && (conflict = {
            type: types_js_1.ConflictType.RM_UNEXPECTED_CONTENT,
            op1: exports2.editOp(p1Drop.getPath(), t1, e1, true),
            op2: exports2.removeOp(removed2.getPath())
          });
          else {
            const t2 = getEditType(c2d);
            let e;
            if (t2) {
              if (t1 !== t2) throw Error("Transforming incompatible types");
              const e2 = getEdit(c2d);
              e = t1.transform(e1, e2, direction);
            } else e = deepClone_js_1.default(e1);
            writeEdit(w2, t1, e);
          }
        }
        let p1PickOff = 0, p1DropOff = 0, p2PickOff = 0, p2DropOff = 0, outPickOff = 0, outDropOff = 0, p1pValid = null != p1Pick && p1Pick.descendFirst(), p1pDidDescend = p1pValid;
        const ap2p = cursor_js_1.advancer(p2Pick, void 0, (k, c) => {
          hasPick(c) && p2PickOff++;
        });
        let p2dValid = null != p2Drop && p2Drop.descendFirst(), p2dDidDescend = p2dValid;
        for (const key of p1Drop) if ("number" == typeof key) {
          let _p1Pick;
          const hd1 = hasDrop(p1Drop.getComponent()), k1Mid = key - p1DropOff;
          {
            let p1k;
            for (; p1pValid && "number" == typeof (p1k = p1Pick.getKey()); ) {
              p1k += p1PickOff;
              const c = p1Pick.getComponent(), hp = hasPick(c);
              if (p1k > k1Mid || p1k === k1Mid && (!hp || 0 === side && hd1)) break;
              if (hp) {
                p1PickOff--;
                const slot1 = c.p;
                pickComponents[slot1], op1PickAtOp2Pick.includes(slot1), c.d, getComponent(heldDropWrites[c.d]), hasPick(getComponent(heldDropWrites[c.d])), (void 0 === c.r || cancelledRemoves && cancelledRemoves.has(c)) && (null == slot1 || !pickComponents[slot1] || 1 !== side && op1PickAtOp2Pick.includes(slot1)) || outPickOff--;
              }
              p1pValid = p1Pick.nextSibling();
            }
            _p1Pick = p1pValid && p1k === k1Mid ? p1Pick : null;
          }
          const raw = k1Mid - p1PickOff;
          let _p2Pick = ap2p(raw);
          const k2Mid = raw - p2PickOff;
          let _p2Drop = null;
          {
            let p2dk, op2Mid;
            for (; p2dValid && "number" == typeof (p2dk = p2Drop.getKey()); ) {
              op2Mid = p2dk - p2DropOff;
              const c = p2Drop.getComponent(), hd2 = hasDrop(c);
              if (op2Mid > k2Mid) break;
              if (op2Mid === k2Mid) {
                if (!hd2) {
                  _p2Drop = p2Drop;
                  break;
                }
                {
                  if (0 === side && hd1) {
                    _p2Drop = p2Drop;
                    break;
                  }
                  const hp2 = _p2Pick && hasPick(_p2Pick.getComponent());
                  if (0 === side && hp2) break;
                }
              }
              if (hd2) {
                const slot2 = c.d;
                cancelledOp2[slot2], op1PickAtOp2Pick[slot2], void 0 === c.i && (cancelledOp2[slot2] || null != op1PickAtOp2Pick[slot2] && 1 !== side) ? (cancelledOp2[slot2] || null != op1PickAtOp2Pick[slot2] && 0 === side) && (p2DropOff++, outDropOff--) : p2DropOff++;
              }
              p2dValid = p2Drop.nextSibling();
            }
          }
          const descend = k2Mid + p2DropOff + outPickOff + outDropOff;
          assert(descend >= 0, "trying to descend to a negative index"), w2.descend(descend), hd1 && (_p1Pick = _p2Pick = _p2Drop = null, p1DropOff++), writeOp1Drop(_p1Pick, p1Drop, _p2Pick, _p2Drop, w2, removed2) && outDropOff++, w2.ascend();
        } else {
          let p1k;
          for (; p1pValid && (p1k = p1Pick.getKey(), "string" != typeof p1k || !(p1k > key || p1k === key)); ) p1pValid = p1Pick.nextSibling();
          const _p1Pick = p1pValid && p1k === key ? p1Pick : null, _p2Pick = ap2p(key);
          let p2dk;
          for (; p2dValid && (p2dk = p2Drop.getKey(), "string" != typeof p2dk || !(p2dk > key || p2dk === key)); ) p2dValid = p2Drop.nextSibling();
          const _p2Drop = p2dValid && p2dk === key ? p2Drop : null;
          w2.descend(key), writeOp1Drop(_p1Pick, p1Drop, _p2Pick, _p2Drop, w2, removed2), w2.ascend();
        }
        return ap2p.end(), p1pDidDescend && p1Pick.ascend(), p2dDidDescend && p2Drop.ascend(), droppedHere;
      }(r1, r1.clone(), r2, r2.clone(), w, null), conflict) return {
        ok: false,
        conflict
      };
      w.reset();
      const eachDrop = (r, w2, fn) => r.traverse(w2, (c, w3) => {
        null != c.d && fn(c.d, r, w3);
      });
      (cancelledOp2.length || heldPickWrites.length) && (eachDrop(r2, w, (slot2, r, w2) => {
        cancelledOp2[slot2] && !discardedOp2Drop[slot2] && w2.write("r", true), heldPickWrites[slot2] && w2.mergeTree(heldPickWrites[slot2].get());
      }), w.reset());
      const heldOutDropRead = [], heldOutDropWrites = [];
      if ((heldDropWrites.length || cancelledOp2.length) && !conflict) {
        const rOut = cursor_js_1.readCursor(shallowCloneOp(w.get()));
        if (eachDrop(rOut, null, (slotOut, r) => {
          heldOutDropRead[slotOut] = r.clone();
        }), heldDropWrites.forEach((hdw) => {
          hdw && eachDrop(cursor_js_1.readCursor(hdw.get()), null, (slotOut, r) => {
            heldOutDropRead[slotOut] = r.clone();
          });
        }), function writeHeldOp2Drop(p2Drop, outPick, outDrop, w2, parentC, removedOut) {
          log3.prefix++;
          const coutp = getComponent(outPick);
          if (coutp && hasPick(coutp)) if (null != coutp.p) {
            parentC = coutp;
            const slot = coutp.p;
            heldOutDropRead[slot].getPath(), outDrop = heldOutDropRead[slot], w2 = heldOutDropWrites[slot] = cursor_js_1.writeCursor();
          } else void 0 !== coutp.r && (outDrop = null, removedOut = true);
          else hasDrop(getComponent(outDrop)) && (outDrop = null);
          const c2 = p2Drop.getComponent();
          if (c2) {
            let slot2;
            if (null != (slot2 = c2.d)) {
              const _w = heldDropWrites[slot2];
              _w && (_w.get(), w2.mergeTree(_w.get()), outDrop = cursor_js_1.readCursor(_w.get()));
            }
          }
          let outPickOff = 0, outDropOff = 0;
          const oPickAdv = cursor_js_1.advancer(outPick, void 0, (k, c) => {
            hasPick(c) && outPickOff--;
          }), oDropAdv = cursor_js_1.advancer(outDrop, (k, c) => hasDrop(c) ? -(k - outDropOff) - 1 : k - outDropOff, (k, c) => {
            hasDrop(c) && outDropOff++;
          });
          for (const o2dk of p2Drop) if ("number" == typeof o2dk) {
            const _outPick = oPickAdv(o2dk), rmid = o2dk + outPickOff, _outDrop = oDropAdv(rmid), rfinal = rmid + outDropOff;
            w2.descend(rfinal), writeHeldOp2Drop(p2Drop, _outPick, _outDrop, w2, parentC, removedOut), w2.ascend();
          } else w2.descend(o2dk), writeHeldOp2Drop(p2Drop, oPickAdv(o2dk), oDropAdv(o2dk), w2, parentC, removedOut), w2.ascend();
          oPickAdv.end(), oDropAdv.end();
        }(r2, rOut, rOut.clone(), w, null, false), w.reset(), conflict) return {
          ok: false,
          conflict
        };
        if (w.get(), heldOutDropWrites.length) {
          const heldOutDropContent = heldOutDropWrites.map((w2) => w2 ? w2.get() : null), rOut2 = cursor_js_1.readCursor(shallowCloneOp(w.get()));
          if (eachDrop(rOut2, w, (slotOut, r, w2) => {
            const data = heldOutDropContent[slotOut];
            data && (w2.mergeTree(data), heldOutDropContent[slotOut] = null);
          }), heldOutDropContent.find((x) => x)) {
            const w1 = cursor_js_1.writeCursor(), w2 = cursor_js_1.writeCursor();
            let nextSlot1 = 0, nextSlot2 = 0;
            heldOutDropContent.forEach((data) => {
              null != data && eachDrop(cursor_js_1.readCursor(data), null, (c) => {
                const slot1 = outputSlotMap[c];
                w1.writeMove(heldOp1PickByOp1[slot1].getPath(), heldOp1DropByOp1[slot1].getPath(), nextSlot1++);
                const slot2s = op1PicksOp2DropSlots[slot1];
                slot2s && slot2s.forEach((slot2) => {
                  cancelledOp2[slot2] || 1 !== side && null != op1PickAtOp2Pick[slot2] || w2.writeMove(heldOp2PickByOp2[slot2].getPath(), heldOp2DropByOp2[slot2].getPath(), nextSlot2++);
                });
              });
            }), conflict = {
              type: types_js_1.ConflictType.BLACKHOLE,
              op1: w1.get(),
              op2: w2.get()
            };
          }
        }
      }
      if (conflict) return {
        ok: false,
        conflict
      };
      return {
        ok: true,
        result: w.get()
      };
    }
    var throwConflictErr = (conflict) => {
      const err = new Error("Transform detected write conflict");
      throw err.conflict = conflict, err.type = err.name = "writeConflict", err;
    };
    function transform(op1, op2, side) {
      const res = tryTransform(op1, op2, side);
      if (res.ok) return res.result;
      throwConflictErr(res.conflict);
    }
    var opThatRemovesDE = (op) => {
      const w = cursor_js_1.writeCursor();
      return cursor_js_1.readCursor(op).traverse(w, (c, w2) => {
        (hasDrop(c) || getEditType(c)) && w2.write("r", true);
      }), w.get();
    };
    var resolveConflict = (conflict, side) => {
      const { type: type2, op1, op2 } = conflict;
      switch (type2) {
        case types_js_1.ConflictType.DROP_COLLISION:
          return "left" === side ? [null, opThatRemovesDE(op2)] : [opThatRemovesDE(op1), null];
        case types_js_1.ConflictType.RM_UNEXPECTED_CONTENT:
          let op1HasRemove = false;
          return cursor_js_1.readCursor(op1).traverse(null, (c) => {
            void 0 !== c.r && (op1HasRemove = true);
          }), op1HasRemove ? [null, opThatRemovesDE(op2)] : [opThatRemovesDE(op1), null];
        case types_js_1.ConflictType.BLACKHOLE:
          return [opThatRemovesDE(op1), opThatRemovesDE(op2)];
        default:
          throw Error("Unrecognised conflict: " + type2);
      }
    };
    function transformWithConflictsPred(allowConflict, op1, op2, side) {
      let r2Aggregate = null;
      for (; ; ) {
        const res = tryTransform(op1, op2, side);
        if (res.ok) return compose(r2Aggregate, res.result);
        {
          const { conflict } = res;
          allowConflict(conflict) || throwConflictErr(conflict);
          const [r1, r2] = resolveConflict(conflict, side);
          op1 = compose(normalize(op1), r1), op2 = compose(normalize(op2), r2), r2Aggregate = compose(r2Aggregate, r2);
        }
      }
    }
  }
});

// ../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/.pnpm/ot-json1@1.0.2/node_modules/ot-json1/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !exports3.hasOwnProperty(p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_json1_release(), exports2);
    var cursor_js_1 = require_cursor();
    Object.defineProperty(exports2, "ReadCursor", { enumerable: true, get: function() {
      return cursor_js_1.ReadCursor;
    } });
    Object.defineProperty(exports2, "WriteCursor", { enumerable: true, get: function() {
      return cursor_js_1.WriteCursor;
    } });
    var types_1 = require_types2();
    Object.defineProperty(exports2, "ConflictType", { enumerable: true, get: function() {
      return types_1.ConflictType;
    } });
  }
});

// ../packages/core/src/common/shims.ts
var glob = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : window;
function installRequestIdleCallback() {
  const TIME_WINDOW = 50;
  const idleCallbacks = /* @__PURE__ */ new Map();
  let currentId = 0;
  if (typeof glob.requestIdleCallback !== "function") {
    glob.requestIdleCallback = function shimRIC(callback) {
      const start = Date.now();
      const id = ++currentId;
      const timeoutId = setTimeout(function rICCallback() {
        idleCallbacks.delete(id);
        const remaining = Math.max(0, TIME_WINDOW - (Date.now() - start));
        callback({
          didTimeout: remaining === 0,
          timeRemaining() {
            return remaining;
          }
        });
      }, 1);
      idleCallbacks.set(id, timeoutId);
      return id;
    };
  }
  if (typeof glob.cancelIdleCallback !== "function") {
    glob.cancelIdleCallback = function shimCancelRIC(id) {
      const timeoutId = idleCallbacks.get(id);
      if (timeoutId !== void 0) {
        clearTimeout(timeoutId);
        idleCallbacks.delete(id);
      }
    };
  }
}
function installShims() {
  installRequestIdleCallback();
}

// ../packages/core/src/common/array.ts
function remove(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1) {
    arr.splice(index, 1);
    return true;
  }
  return false;
}
function findLast(arr, callback) {
  for (let i = arr.length - 1; i > -1; i--) {
    const item = arr[i];
    if (callback(item, i)) {
      return item;
    }
  }
  return null;
}

// ../node_modules/.pnpm/@wendellhu+redi@0.17.1/node_modules/@wendellhu/redi/fesm/redi.mjs
var IdentifierDecoratorSymbol = Symbol("$$IDENTIFIER_DECORATOR");
function isIdentifierDecorator(thing) {
  return thing && thing[IdentifierDecoratorSymbol] === true;
}
function isCtor(thing) {
  return typeof thing === "function";
}
function isClassDependencyItem(thing) {
  if (thing && typeof thing.useClass !== "undefined") {
    return true;
  }
  return false;
}
function isFactoryDependencyItem(thing) {
  if (thing && typeof thing.useFactory !== "undefined") {
    return true;
  }
  return false;
}
function isValueDependencyItem(thing) {
  if (thing && typeof thing.useValue !== "undefined") {
    return true;
  }
  return false;
}
function isExistingDependencyItem(thing) {
  if (thing && typeof thing.useExisting !== "undefined") {
    return true;
  }
  return false;
}
function isAsyncDependencyItem(thing) {
  if (thing && typeof thing.useAsync !== "undefined") {
    return true;
  }
  return false;
}
var AsyncHookSymbol = Symbol("AsyncHook");
function isAsyncHook(thing) {
  if (thing && thing.__symbol === AsyncHookSymbol) {
    return true;
  }
  return false;
}
function prettyPrintIdentifier(id) {
  if (typeof id === "undefined") {
    return "undefined";
  }
  return isCtor(id) && !id[IdentifierDecoratorSymbol] ? id.name : id.toString();
}
var __extends$4 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RediError = (
  /** @class */
  function(_super) {
    __extends$4(RediError2, _super);
    function RediError2(message) {
      return _super.call(this, "[redi]: ".concat(message)) || this;
    }
    return RediError2;
  }(Error)
);
var Quantity;
(function(Quantity2) {
  Quantity2["MANY"] = "many";
  Quantity2["OPTIONAL"] = "optional";
  Quantity2["REQUIRED"] = "required";
})(Quantity || (Quantity = {}));
var LookUp;
(function(LookUp2) {
  LookUp2["SELF"] = "self";
  LookUp2["SKIP_SELF"] = "skipSelf";
})(LookUp || (LookUp = {}));
var __extends$3 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TARGET = Symbol("$$TARGET");
var DEPENDENCIES = Symbol("$$DEPENDENCIES");
var DependencyDescriptorNotFoundError = (
  /** @class */
  function(_super) {
    __extends$3(DependencyDescriptorNotFoundError2, _super);
    function DependencyDescriptorNotFoundError2(index, target) {
      var msg = "Could not find dependency registered on the ".concat(index, ' (indexed) parameter of the constructor of "').concat(prettyPrintIdentifier(target), '".');
      return _super.call(this, msg) || this;
    }
    return DependencyDescriptorNotFoundError2;
  }(RediError)
);
var IdentifierUndefinedError = (
  /** @class */
  function(_super) {
    __extends$3(IdentifierUndefinedError2, _super);
    function IdentifierUndefinedError2(target, index) {
      var msg = 'It seems that you register "undefined" as dependency on the '.concat(index + 1, ' parameter of "').concat(prettyPrintIdentifier(target), '". Please make sure that there is not cyclic dependency among your TypeScript files, or consider using "forwardRef". For more info please visit our website https://redi.wendell.fun/docs/debug#could-not-find-dependency-registered-on');
      return _super.call(this, msg) || this;
    }
    return IdentifierUndefinedError2;
  }(RediError)
);
function getDependencies(registerTarget) {
  var target = registerTarget;
  return target[DEPENDENCIES] || [];
}
function getDependencyByIndex(registerTarget, index) {
  var allDependencies = getDependencies(registerTarget);
  var dep = allDependencies.find(function(descriptor) {
    return descriptor.paramIndex === index;
  });
  if (!dep) {
    throw new DependencyDescriptorNotFoundError(index, registerTarget);
  }
  return dep;
}
function setDependency(registerTarget, identifier, paramIndex, quantity, lookUp) {
  if (quantity === void 0) {
    quantity = Quantity.REQUIRED;
  }
  var descriptor = {
    paramIndex,
    identifier,
    quantity,
    lookUp,
    withNew: false
  };
  if (typeof identifier === "undefined") {
    throw new IdentifierUndefinedError(registerTarget, paramIndex);
  }
  var target = registerTarget;
  if (target[TARGET] === target) {
    target[DEPENDENCIES].push(descriptor);
  } else {
    target[DEPENDENCIES] = [descriptor];
    target[TARGET] = target;
  }
}
var knownIdentifiers = /* @__PURE__ */ new Set();
function createIdentifier(id) {
  if (knownIdentifiers.has(id)) {
    throw new RediError('Identifier "'.concat(id, '" already exists.'));
  } else {
    knownIdentifiers.add(id);
  }
  var decorator = function(registerTarget, _key, index) {
    setDependency(registerTarget, decorator, index);
  };
  decorator.toString = function() {
    return id;
  };
  decorator[IdentifierDecoratorSymbol] = true;
  return decorator;
}
function changeLookup(target, index, lookUp) {
  var descriptor = getDependencyByIndex(target, index);
  descriptor.lookUp = lookUp;
}
function lookupDecoratorFactoryProducer(lookUp) {
  return function DecoratorFactory() {
    if (this instanceof DecoratorFactory) {
      return this;
    }
    return function(target, _key, index) {
      changeLookup(target, index, lookUp);
    };
  };
}
var SkipSelf = lookupDecoratorFactoryProducer(LookUp.SKIP_SELF);
var Self = lookupDecoratorFactoryProducer(LookUp.SELF);
var __extends$2 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function mapQuantityToNumber(quantity) {
  switch (quantity) {
    case Quantity.OPTIONAL:
      return "0 or 1";
    case Quantity.REQUIRED:
      return "1";
    case Quantity.MANY:
      return "0 or more";
  }
}
var QuantityCheckError = (
  /** @class */
  function(_super) {
    __extends$2(QuantityCheckError2, _super);
    function QuantityCheckError2(id, quantity, actual) {
      var _this = this;
      var msg = "Expect ".concat(mapQuantityToNumber(quantity), ' dependency item(s) for id "').concat(prettyPrintIdentifier(id), '" but get ').concat(actual, ".");
      if (actual === 0) {
        msg += " Did you forget to register it?";
      }
      if (actual > 1) {
        msg += " You register it more than once.";
      }
      _this = _super.call(this, msg) || this;
      _this.quantity = quantity;
      _this.actual = actual;
      return _this;
    }
    return QuantityCheckError2;
  }(RediError)
);
function checkQuantity(id, quantity, length) {
  if (quantity === Quantity.OPTIONAL && length > 1 || quantity === Quantity.REQUIRED && length !== 1) {
    throw new QuantityCheckError(id, quantity, length);
  }
}
function retrieveQuantity(quantity, arr) {
  if (quantity === Quantity.MANY) {
    return arr;
  } else {
    return arr[0];
  }
}
function changeQuantity(target, index, quantity) {
  var descriptor = getDependencyByIndex(target, index);
  descriptor.quantity = quantity;
}
function quantifyDecoratorFactoryProducer(quantity) {
  return function decoratorFactory(id) {
    if (this instanceof decoratorFactory) {
      return this;
    }
    return function(registerTarget, _key, index) {
      if (id) {
        setDependency(registerTarget, id, index, quantity);
      } else {
        if (quantity === Quantity.REQUIRED) {
          throw new IdentifierUndefinedError(registerTarget, index);
        }
        changeQuantity(registerTarget, index, quantity);
      }
    };
  };
}
var Many = quantifyDecoratorFactoryProducer(Quantity.MANY);
var Optional = quantifyDecoratorFactoryProducer(Quantity.OPTIONAL);
var Inject = quantifyDecoratorFactoryProducer(Quantity.REQUIRED);
function changeToSelf(target, index, withNew) {
  var descriptor = getDependencyByIndex(target, index);
  descriptor.withNew = withNew;
}
function withNewDecoratorFactoryProducer(withNew) {
  return function DecoratorFactory() {
    if (this instanceof DecoratorFactory) {
      return this;
    }
    return function(target, _key, index) {
      changeToSelf(target, index, withNew);
    };
  };
}
var WithNew = withNewDecoratorFactoryProducer(true);
function normalizeFactoryDeps(deps, startIndex) {
  if (startIndex === void 0) {
    startIndex = 0;
  }
  if (!deps) {
    return [];
  }
  return deps.map(function(dep, index) {
    index += startIndex;
    if (!Array.isArray(dep)) {
      return {
        paramIndex: index,
        identifier: dep,
        quantity: Quantity.REQUIRED,
        withNew: false
      };
    }
    var modifiers = dep.slice(0, dep.length - 1);
    var identifier = dep[dep.length - 1];
    var lookUp;
    var quantity = Quantity.REQUIRED;
    var withNew = false;
    modifiers.forEach(function(modifier) {
      if (modifier instanceof Self) {
        lookUp = LookUp.SELF;
      } else if (modifier instanceof SkipSelf) {
        lookUp = LookUp.SKIP_SELF;
      } else if (modifier instanceof Optional) {
        quantity = Quantity.OPTIONAL;
      } else if (modifier instanceof Many) {
        quantity = Quantity.MANY;
      } else if (modifier instanceof WithNew) {
        withNew = true;
      } else {
        throw new RediError("unknown dep modifier ".concat(modifier, "."));
      }
    });
    return {
      paramIndex: index,
      identifier,
      quantity,
      lookUp,
      withNew
    };
  });
}
function isForwardRef(thing) {
  return !!thing && typeof thing.unwrap === "function";
}
function normalizeForwardRef(id) {
  if (isForwardRef(id)) {
    return id.unwrap();
  }
  return id;
}
function isDisposable(thing) {
  return !!thing && typeof thing.dispose === "function";
}
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function isBareClassDependency(thing) {
  return thing.length === 1;
}
var ResolvingStack = [];
function pushResolvingStack(id) {
  ResolvingStack.push(id);
}
function popupResolvingStack() {
  ResolvingStack.pop();
}
function clearResolvingStack() {
  ResolvingStack.length = 0;
}
var DependencyNotFoundForModuleError = (
  /** @class */
  function(_super) {
    __extends$1(DependencyNotFoundForModuleError2, _super);
    function DependencyNotFoundForModuleError2(toInstantiate, id, index) {
      var msg = 'Cannot find "'.concat(prettyPrintIdentifier(id), '" registered by any injector. It is the ').concat(index, 'th param of "').concat(isIdentifierDecorator(toInstantiate) ? prettyPrintIdentifier(toInstantiate) : toInstantiate.name, '".');
      return _super.call(this, msg) || this;
    }
    return DependencyNotFoundForModuleError2;
  }(RediError)
);
var DependencyNotFoundError = (
  /** @class */
  function(_super) {
    __extends$1(DependencyNotFoundError2, _super);
    function DependencyNotFoundError2(id) {
      var _this = this;
      var msg = 'Cannot find "'.concat(prettyPrintIdentifier(id), '" registered by any injector. The stack of dependencies is: "').concat(ResolvingStack.map(function(id2) {
        return prettyPrintIdentifier(id2);
      }).join(" -> "), '".');
      _this = _super.call(this, msg) || this;
      clearResolvingStack();
      return _this;
    }
    return DependencyNotFoundError2;
  }(RediError)
);
var DependencyCollection = (
  /** @class */
  function() {
    function DependencyCollection2(dependencies) {
      var _this = this;
      this.dependencyMap = /* @__PURE__ */ new Map();
      this.normalizeDependencies(dependencies).map(function(pair) {
        return _this.add(pair[0], pair[1]);
      });
    }
    DependencyCollection2.prototype.add = function(ctorOrId, val) {
      if (typeof val === "undefined") {
        val = { useClass: ctorOrId, lazy: false };
      }
      var arr = this.dependencyMap.get(ctorOrId);
      if (typeof arr === "undefined") {
        arr = [];
        this.dependencyMap.set(ctorOrId, arr);
      }
      arr.push(val);
    };
    DependencyCollection2.prototype.delete = function(id) {
      this.dependencyMap.delete(id);
    };
    DependencyCollection2.prototype.get = function(id, quantity) {
      if (quantity === void 0) {
        quantity = Quantity.REQUIRED;
      }
      var ret = this.dependencyMap.get(id);
      checkQuantity(id, quantity, ret.length);
      return retrieveQuantity(quantity, ret);
    };
    DependencyCollection2.prototype.has = function(id) {
      return this.dependencyMap.has(id);
    };
    DependencyCollection2.prototype.append = function(dependencies) {
      var _this = this;
      this.normalizeDependencies(dependencies).forEach(function(pair) {
        return _this.add(pair[0], pair[1]);
      });
    };
    DependencyCollection2.prototype.dispose = function() {
      this.dependencyMap.clear();
    };
    DependencyCollection2.prototype.normalizeDependencies = function(dependencies) {
      return dependencies.map(function(dependency) {
        var id = dependency[0];
        var val;
        if (isBareClassDependency(dependency)) {
          val = {
            useClass: dependency[0],
            lazy: false
          };
        } else {
          val = dependency[1];
        }
        return [id, val];
      });
    };
    return DependencyCollection2;
  }()
);
var ResolvedDependencyCollection = (
  /** @class */
  function() {
    function ResolvedDependencyCollection2() {
      this.resolvedDependencies = /* @__PURE__ */ new Map();
    }
    ResolvedDependencyCollection2.prototype.add = function(id, val) {
      var arr = this.resolvedDependencies.get(id);
      if (typeof arr === "undefined") {
        arr = [];
        this.resolvedDependencies.set(id, arr);
      }
      arr.push(val);
    };
    ResolvedDependencyCollection2.prototype.has = function(id) {
      return this.resolvedDependencies.has(id);
    };
    ResolvedDependencyCollection2.prototype.delete = function(id) {
      if (this.resolvedDependencies.has(id)) {
        var things = this.resolvedDependencies.get(id);
        things.forEach(function(t) {
          return isDisposable(t) ? t.dispose() : void 0;
        });
        this.resolvedDependencies.delete(id);
      }
    };
    ResolvedDependencyCollection2.prototype.get = function(id, quantity) {
      if (quantity === void 0) {
        quantity = Quantity.REQUIRED;
      }
      var ret = this.resolvedDependencies.get(id);
      if (!ret) {
        throw new DependencyNotFoundError(id);
      }
      checkQuantity(id, quantity, ret.length);
      if (quantity === Quantity.MANY) {
        return ret;
      } else {
        return ret[0];
      }
    };
    ResolvedDependencyCollection2.prototype.dispose = function() {
      Array.from(this.resolvedDependencies.values()).forEach(function(items) {
        items.forEach(function(item) {
          return isDisposable(item) ? item.dispose() : void 0;
        });
      });
      this.resolvedDependencies.clear();
    };
    return ResolvedDependencyCollection2;
  }()
);
var runWhenIdle;
(function() {
  if (typeof requestIdleCallback !== "undefined" && typeof cancelIdleCallback !== "undefined") {
    runWhenIdle = function(runner, timeout) {
      var handle = requestIdleCallback(runner, typeof timeout === "number" ? { timeout } : void 0);
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        cancelIdleCallback(handle);
      };
    };
  } else {
    var dummyIdle_1 = Object.freeze({
      didTimeout: true,
      timeRemaining: function() {
        return 15;
      }
    });
    runWhenIdle = function(runner) {
      var handle = setTimeout(function() {
        return runner(dummyIdle_1);
      });
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        clearTimeout(handle);
      };
    };
  }
})();
var IdleValue = (
  /** @class */
  function() {
    function IdleValue2(executor) {
      var _this = this;
      this.didRun = false;
      this.selfExecutor = function() {
        try {
          _this.value = executor();
        } catch (err) {
          _this.error = err;
        } finally {
          _this.didRun = true;
        }
      };
      this.disposeCallback = runWhenIdle(function() {
        return _this.selfExecutor();
      });
    }
    IdleValue2.prototype.hasRun = function() {
      return this.didRun;
    };
    IdleValue2.prototype.dispose = function() {
      this.disposeCallback();
    };
    IdleValue2.prototype.getValue = function() {
      if (!this.didRun) {
        this.dispose();
        this.selfExecutor();
      }
      if (this.error) {
        throw this.error;
      }
      return this.value;
    };
    return IdleValue2;
  }()
);
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var MAX_RESOLUTIONS_QUEUED = 300;
var NotInstantiatedSymbol = Symbol("$$NOT_INSTANTIATED_SYMBOL");
var CircularDependencyError = (
  /** @class */
  function(_super) {
    __extends(CircularDependencyError2, _super);
    function CircularDependencyError2(id) {
      return _super.call(this, 'Detecting cyclic dependency. The last identifier is "'.concat(prettyPrintIdentifier(id), '".')) || this;
    }
    return CircularDependencyError2;
  }(RediError)
);
var InjectorAlreadyDisposedError = (
  /** @class */
  function(_super) {
    __extends(InjectorAlreadyDisposedError2, _super);
    function InjectorAlreadyDisposedError2() {
      return _super.call(this, "Injector cannot be accessed after it was disposed.") || this;
    }
    return InjectorAlreadyDisposedError2;
  }(RediError)
);
var AsyncItemReturnAsyncItemError = (
  /** @class */
  function(_super) {
    __extends(AsyncItemReturnAsyncItemError2, _super);
    function AsyncItemReturnAsyncItemError2(id) {
      return _super.call(this, 'Async item "'.concat(prettyPrintIdentifier(id), '" returns another async item.')) || this;
    }
    return AsyncItemReturnAsyncItemError2;
  }(RediError)
);
var GetAsyncItemFromSyncApiError = (
  /** @class */
  function(_super) {
    __extends(GetAsyncItemFromSyncApiError2, _super);
    function GetAsyncItemFromSyncApiError2(id) {
      return _super.call(this, 'Cannot get async item "'.concat(prettyPrintIdentifier(id), '" from sync api.')) || this;
    }
    return GetAsyncItemFromSyncApiError2;
  }(RediError)
);
var AddDependencyAfterResolutionError = (
  /** @class */
  function(_super) {
    __extends(AddDependencyAfterResolutionError2, _super);
    function AddDependencyAfterResolutionError2(id) {
      return _super.call(this, 'Cannot add dependency "'.concat(prettyPrintIdentifier(id), '" after it is already resolved.')) || this;
    }
    return AddDependencyAfterResolutionError2;
  }(RediError)
);
var DeleteDependencyAfterResolutionError = (
  /** @class */
  function(_super) {
    __extends(DeleteDependencyAfterResolutionError2, _super);
    function DeleteDependencyAfterResolutionError2(id) {
      return _super.call(this, 'Cannot dependency dependency "'.concat(prettyPrintIdentifier(id), '" after it is already resolved.')) || this;
    }
    return DeleteDependencyAfterResolutionError2;
  }(RediError)
);
var Injector = (
  /** @class */
  function() {
    function Injector2(dependencies, parent) {
      if (parent === void 0) {
        parent = null;
      }
      this.parent = parent;
      this.children = [];
      this.resolutionOngoing = 0;
      this.disposingCallbacks = /* @__PURE__ */ new Set();
      this.disposed = false;
      this.dependencyCollection = new DependencyCollection(dependencies || []);
      this.resolvedDependencyCollection = new ResolvedDependencyCollection();
      if (parent) {
        parent.children.push(this);
      }
    }
    Injector2.prototype.onDispose = function(callback) {
      var _this = this;
      this.disposingCallbacks.add(callback);
      return { dispose: function() {
        return _this.disposingCallbacks.delete(callback);
      } };
    };
    Injector2.prototype.createChild = function(dependencies) {
      this._ensureInjectorNotDisposed();
      return new Injector2(dependencies, this);
    };
    Injector2.prototype.dispose = function() {
      this.children.forEach(function(c) {
        return c.dispose();
      });
      this.children.length = 0;
      this.dependencyCollection.dispose();
      this.resolvedDependencyCollection.dispose();
      this.deleteSelfFromParent();
      this.disposed = true;
      this.disposingCallbacks.forEach(function(callback) {
        return callback();
      });
      this.disposingCallbacks.clear();
    };
    Injector2.prototype.deleteSelfFromParent = function() {
      if (this.parent) {
        var index = this.parent.children.indexOf(this);
        if (index > -1) {
          this.parent.children.splice(index, 1);
        }
      }
    };
    Injector2.prototype.add = function(dependency) {
      this._ensureInjectorNotDisposed();
      var identifierOrCtor = dependency[0];
      var item = dependency[1];
      if (this.resolvedDependencyCollection.has(identifierOrCtor)) {
        throw new AddDependencyAfterResolutionError(identifierOrCtor);
      }
      if (typeof item === "undefined") {
        this.dependencyCollection.add(identifierOrCtor);
      } else if (isAsyncDependencyItem(item) || isClassDependencyItem(item) || isValueDependencyItem(item) || isFactoryDependencyItem(item)) {
        this.dependencyCollection.add(identifierOrCtor, item);
      } else {
        this.resolvedDependencyCollection.add(identifierOrCtor, item);
      }
    };
    Injector2.prototype.replace = function(dependency) {
      this._ensureInjectorNotDisposed();
      var identifier = dependency[0];
      if (this.resolvedDependencyCollection.has(identifier)) {
        throw new AddDependencyAfterResolutionError(identifier);
      }
      this.dependencyCollection.delete(identifier);
      if (dependency.length === 1) {
        this.dependencyCollection.add(identifier);
      } else {
        this.dependencyCollection.add(identifier, dependency[1]);
      }
    };
    Injector2.prototype.delete = function(identifier) {
      this._ensureInjectorNotDisposed();
      if (this.resolvedDependencyCollection.has(identifier)) {
        throw new DeleteDependencyAfterResolutionError(identifier);
      }
      this.dependencyCollection.delete(identifier);
    };
    Injector2.prototype.invoke = function(cb) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      this._ensureInjectorNotDisposed();
      var accessor = {
        get: function(id, quantityOrLookup, lookUp) {
          return _this._get(id, quantityOrLookup, lookUp);
        },
        has: function(id) {
          return _this.has(id);
        }
      };
      return cb.apply(void 0, __spreadArray([accessor], args, false));
    };
    Injector2.prototype.has = function(id) {
      var _a2;
      return this.dependencyCollection.has(id) || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.has(id)) || false;
    };
    Injector2.prototype.get = function(id, quantityOrLookup, lookUp) {
      this._ensureInjectorNotDisposed();
      var newResult = this._get(id, quantityOrLookup, lookUp);
      if (Array.isArray(newResult) && newResult.some(function(r) {
        return isAsyncHook(r);
      }) || isAsyncHook(newResult)) {
        throw new GetAsyncItemFromSyncApiError(id);
      }
      return newResult;
    };
    Injector2.prototype._get = function(id, quantityOrLookup, lookUp, toSelf) {
      var quantity = Quantity.REQUIRED;
      if (quantityOrLookup === Quantity.REQUIRED || quantityOrLookup === Quantity.OPTIONAL || quantityOrLookup === Quantity.MANY) {
        quantity = quantityOrLookup;
      } else {
        lookUp = quantityOrLookup;
      }
      if (!toSelf) {
        var cachedResult = this.getValue(id, quantity, lookUp);
        if (cachedResult !== NotInstantiatedSymbol) {
          return cachedResult;
        }
      }
      return this.createDependency(id, quantity, lookUp, !toSelf);
    };
    Injector2.prototype.getAsync = function(id) {
      this._ensureInjectorNotDisposed();
      var cachedResult = this.getValue(id, Quantity.REQUIRED);
      if (cachedResult !== NotInstantiatedSymbol) {
        return Promise.resolve(cachedResult);
      }
      var newResult = this.createDependency(id, Quantity.REQUIRED);
      if (!isAsyncHook(newResult)) {
        return Promise.resolve(newResult);
      }
      return newResult.whenReady();
    };
    Injector2.prototype.createInstance = function(ctor) {
      var customArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        customArgs[_i - 1] = arguments[_i];
      }
      this._ensureInjectorNotDisposed();
      return this._resolveClassImpl.apply(this, __spreadArray([{
        useClass: ctor
      }], customArgs, false));
    };
    Injector2.prototype._resolveDependency = function(id, item, shouldCache) {
      if (shouldCache === void 0) {
        shouldCache = true;
      }
      var result;
      pushResolvingStack(id);
      try {
        if (isValueDependencyItem(item)) {
          result = this._resolveValueDependency(id, item);
        } else if (isFactoryDependencyItem(item)) {
          result = this._resolveFactory(id, item, shouldCache);
        } else if (isClassDependencyItem(item)) {
          result = this._resolveClass(id, item, shouldCache);
        } else if (isExistingDependencyItem(item)) {
          result = this._resolveExisting(id, item);
        } else {
          result = this._resolveAsync(id, item);
        }
        popupResolvingStack();
      } catch (e) {
        popupResolvingStack();
        throw e;
      }
      return result;
    };
    Injector2.prototype._resolveExisting = function(id, item) {
      var thing = this.get(item.useExisting);
      this.resolvedDependencyCollection.add(id, thing);
      return thing;
    };
    Injector2.prototype._resolveValueDependency = function(id, item) {
      var thing = item.useValue;
      this.resolvedDependencyCollection.add(id, thing);
      return thing;
    };
    Injector2.prototype._resolveClass = function(id, item, shouldCache) {
      var _this = this;
      if (shouldCache === void 0) {
        shouldCache = true;
      }
      var thing;
      if (item.lazy) {
        var idle_1 = new IdleValue(function() {
          _this._ensureInjectorNotDisposed();
          return _this._resolveClassImpl(item);
        });
        thing = new Proxy(/* @__PURE__ */ Object.create(null), {
          get: function(target, key) {
            if (key in target) {
              return target[key];
            }
            if (key === "whenReady") {
              return void 0;
            }
            var thing2 = idle_1.getValue();
            var property = thing2[key];
            if (typeof property !== "function") {
              return property;
            }
            property = property.bind(thing2);
            target[key] = property;
            return property;
          },
          set: function(_target, key, value) {
            ;
            idle_1.getValue()[key] = value;
            return true;
          }
        });
      } else {
        thing = this._resolveClassImpl(item);
      }
      if (id && shouldCache) {
        this.resolvedDependencyCollection.add(id, thing);
      }
      return thing;
    };
    Injector2.prototype._resolveClassImpl = function(item) {
      var _a2;
      var extraParams = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        extraParams[_i - 1] = arguments[_i];
      }
      var Ctor = item.useClass;
      this.markNewResolution(Ctor);
      var declaredDependencies = getDependencies(Ctor).sort(function(a2, b) {
        return a2.paramIndex - b.paramIndex;
      }).map(function(descriptor) {
        return __assign(__assign({}, descriptor), { identifier: normalizeForwardRef(descriptor.identifier) });
      });
      var resolvedArgs = [];
      for (var _b2 = 0, declaredDependencies_1 = declaredDependencies; _b2 < declaredDependencies_1.length; _b2++) {
        var dep = declaredDependencies_1[_b2];
        try {
          var thing_1 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
          resolvedArgs.push(thing_1);
        } catch (error) {
          if (error instanceof DependencyNotFoundError || error instanceof QuantityCheckError && error.actual === 0) {
            throw new DependencyNotFoundForModuleError(Ctor, dep.identifier, dep.paramIndex);
          }
          throw error;
        }
      }
      var args = __spreadArray([], extraParams, true);
      var firstDependencyArgIndex = declaredDependencies.length > 0 ? declaredDependencies[0].paramIndex : args.length;
      if (args.length !== firstDependencyArgIndex) {
        console.warn("[redi]: Expect ".concat(firstDependencyArgIndex, " custom parameter(s) of ").concat(prettyPrintIdentifier(Ctor), " but get ").concat(args.length, "."));
        var delta = firstDependencyArgIndex - args.length;
        if (delta > 0) {
          args = __spreadArray(__spreadArray([], args, true), Array.from({ length: delta }).fill(void 0), true);
        } else {
          args = args.slice(0, firstDependencyArgIndex);
        }
      }
      var thing = new (Ctor.bind.apply(Ctor, __spreadArray(__spreadArray([void 0], args, false), resolvedArgs, false)))();
      (_a2 = item === null || item === void 0 ? void 0 : item.onInstantiation) === null || _a2 === void 0 ? void 0 : _a2.call(item, thing);
      this.markResolutionCompleted();
      return thing;
    };
    Injector2.prototype._resolveFactory = function(id, item, shouldCache) {
      var _a2;
      this.markNewResolution(id);
      var declaredDependencies = normalizeFactoryDeps(item.deps);
      var resolvedArgs = [];
      for (var _i = 0, declaredDependencies_2 = declaredDependencies; _i < declaredDependencies_2.length; _i++) {
        var dep = declaredDependencies_2[_i];
        try {
          var thing_2 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
          resolvedArgs.push(thing_2);
        } catch (error) {
          if (error instanceof DependencyNotFoundError || error instanceof QuantityCheckError && error.actual === 0) {
            throw new DependencyNotFoundForModuleError(id, dep.identifier, dep.paramIndex);
          }
          throw error;
        }
      }
      var thing = item.useFactory.apply(null, resolvedArgs);
      if (shouldCache) {
        this.resolvedDependencyCollection.add(id, thing);
      }
      this.markResolutionCompleted();
      (_a2 = item === null || item === void 0 ? void 0 : item.onInstantiation) === null || _a2 === void 0 ? void 0 : _a2.call(item, thing);
      return thing;
    };
    Injector2.prototype._resolveAsync = function(id, item) {
      var _this = this;
      var asyncLoader = {
        __symbol: AsyncHookSymbol,
        whenReady: function() {
          return _this._resolveAsyncImpl(id, item);
        }
      };
      return asyncLoader;
    };
    Injector2.prototype._resolveAsyncImpl = function(id, item) {
      var _this = this;
      return item.useAsync().then(function(thing) {
        var resolvedCheck = _this.getValue(id);
        if (resolvedCheck !== NotInstantiatedSymbol) {
          return resolvedCheck;
        }
        var ret;
        if (Array.isArray(thing)) {
          var item_1 = thing[1];
          if (isAsyncDependencyItem(item_1)) {
            throw new AsyncItemReturnAsyncItemError(id);
          } else {
            ret = _this._resolveDependency(id, item_1);
          }
        } else if (isCtor(thing)) {
          ret = _this._resolveClassImpl({
            useClass: thing,
            onInstantiation: item.onInstantiation
          });
        } else {
          ret = thing;
        }
        _this.resolvedDependencyCollection.add(id, ret);
        return ret;
      });
    };
    Injector2.prototype.getValue = function(id, quantity, lookUp) {
      var _this = this;
      if (quantity === void 0) {
        quantity = Quantity.REQUIRED;
      }
      var onSelf = function() {
        if (_this.dependencyCollection.has(id) && !_this.resolvedDependencyCollection.has(id)) {
          return NotInstantiatedSymbol;
        }
        return _this.resolvedDependencyCollection.get(id, quantity);
      };
      var onParent = function() {
        if (_this.parent) {
          return _this.parent.getValue(id, quantity);
        } else {
          checkQuantity(id, quantity, 0);
          if (quantity === Quantity.MANY) {
            return [];
          } else {
            return null;
          }
        }
      };
      if (lookUp === LookUp.SKIP_SELF) {
        return onParent();
      }
      if (id === Injector2) {
        return this;
      }
      if (lookUp === LookUp.SELF) {
        return onSelf();
      }
      if (this.resolvedDependencyCollection.has(id) || this.dependencyCollection.has(id)) {
        return onSelf();
      }
      return onParent();
    };
    Injector2.prototype.createDependency = function(id, quantity, lookUp, shouldCache) {
      var _this = this;
      if (quantity === void 0) {
        quantity = Quantity.REQUIRED;
      }
      if (shouldCache === void 0) {
        shouldCache = true;
      }
      var onSelf = function() {
        var registrations = _this.dependencyCollection.get(id, quantity);
        var ret = null;
        if (Array.isArray(registrations)) {
          ret = registrations.map(function(dependencyItem) {
            return _this._resolveDependency(id, dependencyItem, shouldCache);
          });
        } else if (registrations) {
          ret = _this._resolveDependency(id, registrations, shouldCache);
        }
        return ret;
      };
      var onParent = function() {
        if (_this.parent) {
          return _this.parent.createDependency(id, quantity, void 0, shouldCache);
        } else {
          if (quantity === Quantity.OPTIONAL) {
            return null;
          }
          pushResolvingStack(id);
          throw new DependencyNotFoundError(id);
        }
      };
      if (lookUp === LookUp.SKIP_SELF) {
        return onParent();
      }
      if (this.dependencyCollection.has(id)) {
        return onSelf();
      }
      return onParent();
    };
    Injector2.prototype.markNewResolution = function(id) {
      this.resolutionOngoing += 1;
      if (this.resolutionOngoing >= MAX_RESOLUTIONS_QUEUED) {
        throw new CircularDependencyError(id);
      }
    };
    Injector2.prototype.markResolutionCompleted = function() {
      this.resolutionOngoing -= 1;
    };
    Injector2.prototype._ensureInjectorNotDisposed = function() {
      if (this.disposed) {
        throw new InjectorAlreadyDisposedError();
      }
    };
    return Injector2;
  }()
);
var globalObject = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || typeof global !== "undefined" && global;
var __REDI_GLOBAL_LOCK__ = "REDI_GLOBAL_LOCK";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
if (globalObject[__REDI_GLOBAL_LOCK__]) {
  if (!isNode) {
    console.error("[redi]: You are loading scripts of redi more than once! This may cause undesired behavior in your application.\nMaybe your dependencies added redi as its dependency and bundled redi to its dist files. Or you import different versions of redi.\nFor more info please visit our website: https://redi.wendell.fun/en-US/docs/debug#import-scripts-of-redi-more-than-once");
  }
} else {
  globalObject[__REDI_GLOBAL_LOCK__] = true;
}

// ../packages/core/src/common/di.ts
function registerDependencies(injector, dependencies) {
  dependencies.forEach((d) => injector.add(d));
}
function touchDependencies(injector, dependencies) {
  dependencies.forEach(([d]) => {
    if (injector.has(d)) {
      injector.get(d);
    }
  });
}

// ../packages/core/src/common/error.ts
var CustomCommandExecutionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "CustomCommandExecutionError";
  }
};

// ../packages/core/src/common/sequence.ts
function sequence(tasks) {
  for (const [index, task] of tasks.entries()) {
    try {
      const result = task();
      if (!result) {
        return {
          index,
          result: false
        };
      }
    } catch (e) {
      return {
        index,
        result: false,
        error: e
      };
    }
  }
  return {
    result: true,
    index: -1
  };
}

// ../packages/core/src/shared/lifecycle.ts
var import_rxjs = __toESM(require_cjs());
var import_Subscription = __toESM(require_Subscription());
function toDisposable(v) {
  let disposed = false;
  if (!v) {
    return toDisposable(() => {
    });
  }
  if ((0, import_Subscription.isSubscription)(v)) {
    return {
      dispose: () => v.unsubscribe()
    };
  }
  if (typeof v === "function") {
    return {
      dispose: () => {
        if (disposed) {
          return;
        }
        disposed = true;
        v();
      }
    };
  }
  return v;
}
var DisposableCollection = class {
  constructor() {
    __publicField(this, "_disposables", /* @__PURE__ */ new Set());
  }
  add(disposable) {
    const d = toDisposable(disposable);
    this._disposables.add(d);
    return {
      dispose: (notDisposeSelf = false) => {
        if (!notDisposeSelf) {
          d.dispose();
        }
        this._disposables.delete(d);
      }
    };
  }
  dispose() {
    this._disposables.forEach((item) => {
      item.dispose();
    });
    this._disposables.clear();
  }
};
var Disposable = class {
  constructor() {
    __publicField(this, "_disposed", false);
    __publicField(this, "_collection", new DisposableCollection());
  }
  disposeWithMe(disposable) {
    return this._collection.add(disposable);
  }
  ensureNotDisposed() {
    if (this._disposed) {
      throw new Error("[Disposable]: object is disposed!");
    }
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    this._collection.dispose();
  }
};
var RxDisposable = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "dispose$", new import_rxjs.Subject());
  }
  dispose() {
    super.dispose();
    this.dispose$.next();
    this.dispose$.complete();
  }
};

// ../packages/core/src/services/context/context.service.ts
var import_rxjs2 = __toESM(require_cjs());
var IContextService = createIdentifier("univer.context-service");
var ContextService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_contextChanged$", new import_rxjs2.Subject());
    __publicField(this, "contextChanged$", this._contextChanged$.asObservable());
    __publicField(this, "_contextMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose();
    this._contextChanged$.complete();
  }
  getContextValue(key) {
    var _a2;
    return (_a2 = this._contextMap.get(key)) != null ? _a2 : false;
  }
  setContextValue(key, value) {
    this._contextMap.set(key, value);
    this._contextChanged$.next({ [key]: value });
  }
  subscribeContextValue$(key) {
    return new import_rxjs2.Observable((observer) => {
      const contextChangeSubscription = this._contextChanged$.pipe((0, import_rxjs2.filter)((event) => typeof event[key] !== "undefined")).subscribe((event) => observer.next(event[key]));
      if (this._contextMap.has(key)) {
        observer.next(this._contextMap.get(key));
      }
      return () => contextChangeSubscription.unsubscribe();
    });
  }
};

// ../packages/core/src/services/log/log.service.ts
var ILogService = createIdentifier("univer.log");
var DesktopLogService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_logLevel", 3 /* INFO */);
    __publicField(this, "_deduction", /* @__PURE__ */ new Set());
  }
  debug(...args) {
    if (this._logLevel >= 4 /* VERBOSE */) {
      this._log(console.debug, ...args);
    }
  }
  log(...args) {
    if (this._logLevel >= 3 /* INFO */) {
      this._log(console.log, ...args);
    }
  }
  warn(...args) {
    if (this._logLevel >= 2 /* WARN */) {
      this._log(console.warn, ...args);
    }
  }
  error(...args) {
    if (this._logLevel >= 1 /* ERROR */) {
      this._log(console.error, ...args);
    }
  }
  deprecate(...args) {
    if (this._logLevel >= 2 /* WARN */) {
      this._logWithDeduplication(console.error, ...args);
    }
  }
  setLogLevel(logLevel) {
    this._logLevel = logLevel;
  }
  _log(method, ...args) {
    const firstArg = args[0];
    const withTag = /^\[(.*?)\]/g.test(firstArg);
    if (withTag) {
      method(`\x1B[97;104m${firstArg}\x1B[0m`, ...args.slice(1));
    } else {
      method(...args);
    }
  }
  _logWithDeduplication(method, ...args) {
    const hashed = hashLogContent(...args);
    if (this._deduction.has(hashed)) {
      return;
    }
    this._deduction.add(hashed);
    this._log(method, ...args);
  }
};
function hashLogContent(...args) {
  return args.map((a2) => JSON.stringify(a2)).join("");
}

// ../packages/core/src/services/command/command.service.ts
var ICommandService = createIdentifier("anywhere.command-service");
var CommandRegistry = class {
  constructor() {
    __publicField(this, "_commands", /* @__PURE__ */ new Map());
    __publicField(this, "_commandTypes", /* @__PURE__ */ new Map());
  }
  registerCommand(command) {
    if (this._commands.has(command.id)) {
      throw new Error(`[CommandRegistry]: command "${command.id}" has been registered before.`);
    }
    this._commands.set(command.id, command);
    this._commandTypes.set(command.id, command.type);
    return toDisposable(() => {
      this._commands.delete(command.id);
      this._commandTypes.delete(command.id);
    });
  }
  hasCommand(id) {
    return this._commands.has(id);
  }
  getCommand(id) {
    if (!this._commands.has(id)) {
      return null;
    }
    return [this._commands.get(id)];
  }
  getCommandType(id) {
    return this._commandTypes.get(id);
  }
};
var NilCommand = {
  id: "nil",
  type: 0 /* COMMAND */,
  handler: () => true
};
var CommandService = class extends Disposable {
  constructor(_injector, _logService) {
    super();
    this._injector = _injector;
    this._logService = _logService;
    __publicField(this, "_commandRegistry");
    __publicField(this, "_beforeCommandExecutionListeners", []);
    __publicField(this, "_commandExecutedListeners", []);
    __publicField(this, "_multiCommandDisposables", /* @__PURE__ */ new Map());
    __publicField(this, "_commandExecutingLevel", 0);
    __publicField(this, "_commandExecutionStack", []);
    this._commandRegistry = new CommandRegistry();
    this._registerCommand(NilCommand);
  }
  dispose() {
    super.dispose();
    this._commandExecutedListeners.length = 0;
    this._beforeCommandExecutionListeners.length = 0;
  }
  hasCommand(commandId) {
    return this._commandRegistry.hasCommand(commandId);
  }
  registerCommand(command) {
    return this._registerCommand(command);
  }
  registerMultipleCommand(command) {
    return this._registerMultiCommand(command);
  }
  beforeCommandExecuted(listener) {
    if (this._beforeCommandExecutionListeners.indexOf(listener) === -1) {
      this._beforeCommandExecutionListeners.push(listener);
      return toDisposable(() => {
        const index = this._beforeCommandExecutionListeners.indexOf(listener);
        this._beforeCommandExecutionListeners.splice(index, 1);
      });
    }
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  onCommandExecuted(listener) {
    if (this._commandExecutedListeners.indexOf(listener) === -1) {
      this._commandExecutedListeners.push(listener);
      return toDisposable(() => {
        const index = this._commandExecutedListeners.indexOf(listener);
        this._commandExecutedListeners.splice(index, 1);
      });
    }
    throw new Error("[CommandService]: could not add a listener twice.");
  }
  async executeCommand(id, params, options) {
    try {
      const item = this._commandRegistry.getCommand(id);
      if (item) {
        const [command] = item;
        const commandInfo = {
          id: command.id,
          type: command.type,
          params
        };
        const stackItemDisposable = this._pushCommandExecutionStack(commandInfo);
        this._beforeCommandExecutionListeners.forEach((listener) => listener(commandInfo, options));
        const result = await this._execute(command, params, options);
        this._commandExecutedListeners.forEach((listener) => listener(commandInfo, options));
        stackItemDisposable.dispose();
        return result;
      }
      throw new Error(`[CommandService]: command "${id}" is not registered.`);
    } catch (error) {
      if (error instanceof CustomCommandExecutionError) {
        return false;
      } else {
        throw error;
      }
    }
  }
  syncExecuteCommand(id, params, options) {
    var _a2;
    try {
      const item = this._commandRegistry.getCommand(id);
      if (item) {
        const [command] = item;
        const commandInfo = {
          id: command.id,
          type: command.type,
          params
        };
        if (command.type === 2 /* MUTATION */) {
          const triggerCommand = findLast(
            this._commandExecutionStack,
            (item2) => item2.type === 0 /* COMMAND */
          );
          if (triggerCommand) {
            commandInfo.params = (_a2 = commandInfo.params) != null ? _a2 : {};
            commandInfo.params.trigger = triggerCommand.id;
          }
        }
        const stackItemDisposable = this._pushCommandExecutionStack(commandInfo);
        this._beforeCommandExecutionListeners.forEach((listener) => listener(commandInfo, options));
        const result = this._syncExecute(command, params, options);
        this._commandExecutedListeners.forEach((listener) => listener(commandInfo, options));
        stackItemDisposable.dispose();
        return result;
      }
      throw new Error(`[CommandService]: command "${id}" is not registered.`);
    } catch (error) {
      if (error instanceof CustomCommandExecutionError) {
        return false;
      } else {
        throw error;
      }
    }
  }
  _pushCommandExecutionStack(stackItem) {
    this._commandExecutionStack.push(stackItem);
    return toDisposable(() => remove(this._commandExecutionStack, stackItem));
  }
  _registerCommand(command) {
    return this._commandRegistry.registerCommand(command);
  }
  _registerMultiCommand(command) {
    const registry = this._commandRegistry.getCommand(command.id);
    let multiCommand;
    if (!registry) {
      const disposableCollection = new DisposableCollection();
      multiCommand = new MultiCommand(command.id);
      disposableCollection.add(this._commandRegistry.registerCommand(multiCommand));
      disposableCollection.add(
        toDisposable(() => {
          this._multiCommandDisposables.delete(command.id);
        })
      );
      this._multiCommandDisposables.set(command.id, disposableCollection);
    } else {
      if (registry[0].multi !== true) {
        throw new Error("Command has registered as a single command.");
      } else {
        multiCommand = registry[0];
      }
    }
    const implementationDisposable = multiCommand.registerImplementation(command);
    return toDisposable(() => {
      var _a2;
      implementationDisposable.dispose();
      if (!multiCommand.hasImplementations()) {
        (_a2 = this._multiCommandDisposables.get(command.id)) == null ? void 0 : _a2.dispose();
      }
    });
  }
  async _execute(command, params, options) {
    this._logService.debug(
      "[CommandService]",
      `${"|-".repeat(Math.max(this._commandExecutingLevel, 0))}executing command "${command.id}"`
    );
    this._commandExecutingLevel++;
    let result;
    try {
      result = await this._injector.invoke(command.handler, params, options);
      this._commandExecutingLevel--;
    } catch (e) {
      result = false;
      this._commandExecutingLevel = 0;
      throw e;
    }
    return result;
  }
  _syncExecute(command, params, options) {
    this._logService.debug(
      "[CommandService]",
      `${"|-".repeat(Math.max(0, this._commandExecutingLevel))}executing command "${command.id}".`
    );
    this._commandExecutingLevel++;
    let result;
    try {
      result = this._injector.invoke(command.handler, params, options);
      if (result instanceof Promise) {
        throw new TypeError("[CommandService]: Command handler should not return a promise.");
      }
      this._commandExecutingLevel--;
    } catch (e) {
      result = false;
      this._commandExecutingLevel = 0;
      throw e;
    }
    return result;
  }
};
CommandService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, ILogService)
], CommandService);
var MultiCommand = class {
  constructor(id) {
    this.id = id;
    __publicField(this, "name");
    __publicField(this, "multi", true);
    __publicField(this, "type", 0 /* COMMAND */);
    __publicField(this, "priority", 0);
    __publicField(this, "_implementations", []);
    __publicField(this, "handler", async (accessor, params) => {
      if (!this._implementations.length) {
        return false;
      }
      const logService = accessor.get(ILogService);
      const contextService = accessor.get(IContextService);
      const injector = accessor.get(Injector);
      for (const item of this._implementations) {
        const preconditions = item.command.preconditions;
        if (!preconditions || preconditions && preconditions(contextService)) {
          logService.debug("[MultiCommand]", `executing implementation "${item.command.name}".`);
          const result = await injector.invoke(item.command.handler, params);
          if (result) {
            return true;
          }
        }
      }
      return false;
    });
    this.name = id;
  }
  registerImplementation(implementation) {
    const registry = { command: implementation };
    this._implementations.push(registry);
    this._implementations.sort((a2, b) => b.command.priority - a2.command.priority);
    return toDisposable(() => {
      const index = this._implementations.indexOf(registry);
      this._implementations.splice(index, 1);
    });
  }
  hasImplementations() {
    return this._implementations.length > 0;
  }
};
function sequenceExecute(tasks, commandService, options) {
  const taskFns = tasks.map((task) => () => commandService.syncExecuteCommand(task.id, task.params, options));
  return sequence(taskFns);
}

// ../packages/core/src/shared/rxjs.ts
var import_rxjs3 = __toESM(require_cjs());
function takeAfter(callback) {
  return function complateAfter(source) {
    return new import_rxjs3.Observable((subscriber) => {
      source.subscribe({
        next: (v) => {
          subscriber.next(v);
          if (callback(v)) {
            subscriber.complete();
          }
        },
        complete: () => subscriber.complete(),
        error: (error) => subscriber.error(error)
      });
      return () => subscriber.unsubscribe();
    });
  };
}

// ../packages/core/src/shared/array-search.ts
function searchInOrderedArray(arr, target) {
  let left = 0;
  let right = arr.length - 1;
  if (target < arr[0]) return 0;
  if (target >= arr[arr.length - 1]) return arr.length - 1;
  while (left <= right) {
    if (arr[left] === target) {
      while (left < arr.length && arr[left] === target) {
        left++;
      }
      return left;
    }
    if (target > arr[left] && target < arr[left + 1]) {
      return left + 1;
    }
    if (arr[right] === target) {
      while (right < arr.length && arr[right] === target) {
        right++;
      }
      return right;
    }
    if (target > arr[right - 1] && target < arr[right]) {
      return right;
    }
    left++;
    right--;
  }
  return -1;
}
function binSearchFirstGreaterThanTarget(arr, target) {
  let left = 0;
  let right = arr.length;
  while (left < right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] <= target) {
      left = mid + 1;
    } else {
      right = mid;
    }
  }
  return left < arr.length ? left : arr.length - 1;
}
function searchArray(arr, target, firstMatch = false) {
  let index = arr.length - 1;
  if (target < 0 || target < arr[0]) {
    return 0;
  }
  if (arr.length < 40 || target <= arr[20] || target >= arr[index - 20]) {
    index = searchInOrderedArray(arr, target);
  } else {
    index = binSearchFirstGreaterThanTarget(arr, target);
  }
  if (firstMatch) {
    const val = arr[index];
    return arr.indexOf(val);
  }
  return index;
}

// ../node_modules/.pnpm/nanoid@5.1.3/node_modules/nanoid/index.js
var import_node_crypto = require("crypto");

// ../node_modules/.pnpm/nanoid@5.1.3/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// ../node_modules/.pnpm/nanoid@5.1.3/node_modules/nanoid/index.js
var POOL_SIZE_MULTIPLIER = 128;
var pool;
var poolOffset;
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    import_node_crypto.webcrypto.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    import_node_crypto.webcrypto.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function random(bytes) {
  fillPool(bytes |= 0);
  return pool.subarray(poolOffset - bytes, poolOffset);
}
function customRandom(alphabet, defaultSize, getRandom) {
  let mask = (2 << 31 - Math.clz32(alphabet.length - 1 | 1)) - 1;
  let step = Math.ceil(1.6 * mask * defaultSize / alphabet.length);
  return (size = defaultSize) => {
    let id = "";
    while (true) {
      let bytes = getRandom(step);
      let i = step;
      while (i--) {
        id += alphabet[bytes[i] & mask] || "";
        if (id.length >= size) return id;
      }
    }
  };
}
function customAlphabet(alphabet, size = 21) {
  return customRandom(alphabet, size, random);
}
function nanoid(size = 21) {
  fillPool(size |= 0);
  let id = "";
  for (let i = poolOffset - size; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63];
  }
  return id;
}

// ../packages/core/src/common/url.ts
var topLevelDomainSet = /* @__PURE__ */ new Set([
  "ac",
  "ad",
  "ae",
  "aero",
  "af",
  "ag",
  "ai",
  "al",
  "am",
  "ao",
  "aq",
  "ar",
  "arpa",
  "as",
  "asia",
  "at",
  "au",
  "aw",
  "ax",
  "az",
  "ba",
  "bb",
  "bd",
  "be",
  "bf",
  "bg",
  "bh",
  "bi",
  "biz",
  "bj",
  "bm",
  "bn",
  "bo",
  "br",
  "bs",
  "bt",
  "bv",
  "bw",
  "by",
  "bz",
  "ca",
  "cat",
  "cc",
  "cd",
  "cf",
  "cg",
  "ch",
  "ci",
  "ck",
  "cl",
  "cm",
  "cn",
  "co",
  "com",
  "coop",
  "cr",
  "cu",
  "cv",
  "cw",
  "cx",
  "cy",
  "cz",
  "de",
  "dj",
  "dk",
  "dm",
  "do",
  "dz",
  "ec",
  "edu",
  "ee",
  "eg",
  "er",
  "es",
  "et",
  "eu",
  "fi",
  "fj",
  "fk",
  "fm",
  "fo",
  "fr",
  "ga",
  "gb",
  "gd",
  "ge",
  "gf",
  "gg",
  "gh",
  "gi",
  "gl",
  "gm",
  "gn",
  "gov",
  "gp",
  "gq",
  "gr",
  "gs",
  "gt",
  "gu",
  "gw",
  "gy",
  "hk",
  "hm",
  "hn",
  "hr",
  "ht",
  "hu",
  "id",
  "ie",
  "il",
  "im",
  "in",
  "info",
  "int",
  "io",
  "iq",
  "ir",
  "is",
  "it",
  "je",
  "jm",
  "jo",
  "jobs",
  "jp",
  "ke",
  "kg",
  "kh",
  "ki",
  "km",
  "kn",
  "kp",
  "kr",
  "kw",
  "ky",
  "kz",
  "la",
  "lb",
  "lc",
  "li",
  "lk",
  "lr",
  "ls",
  "lt",
  "lu",
  "lv",
  "ly",
  "ma",
  "mc",
  "md",
  "me",
  "mg",
  "mh",
  "mil",
  "mk",
  "ml",
  "mm",
  "mn",
  "mo",
  "mobi",
  "mp",
  "mq",
  "mr",
  "ms",
  "mt",
  "mu",
  "museum",
  "mv",
  "mw",
  "mx",
  "my",
  "mz",
  "na",
  "name",
  "nc",
  "ne",
  "net",
  "nf",
  "ng",
  "ni",
  "nl",
  "no",
  "np",
  "nr",
  "nu",
  "nz",
  "om",
  "onion",
  "org",
  "pa",
  "pe",
  "pf",
  "pg",
  "ph",
  "pk",
  "pl",
  "pm",
  "pn",
  "post",
  "pr",
  "pro",
  "ps",
  "pt",
  "pw",
  "py",
  "qa",
  "re",
  "ro",
  "rs",
  "ru",
  "rw",
  "sa",
  "sb",
  "sc",
  "sd",
  "se",
  "sg",
  "sh",
  "si",
  "sj",
  "sk",
  "sl",
  "sm",
  "sn",
  "so",
  "sr",
  "ss",
  "st",
  "su",
  "sv",
  "sx",
  "sy",
  "sz",
  "tc",
  "td",
  "tel",
  "tf",
  "tg",
  "th",
  "tj",
  "tk",
  "tl",
  "tm",
  "tn",
  "to",
  "tr",
  "tt",
  "tv",
  "tw",
  "tz",
  "ua",
  "ug",
  "uk",
  "us",
  "uy",
  "uz",
  "va",
  "vc",
  "ve",
  "vg",
  "vi",
  "vn",
  "vu",
  "wf",
  "ws",
  "yt",
  "za",
  "zm",
  "zw"
]);
var re_weburl = new RegExp(
  "^(?:(?:(?:https?|ftp):)?\\/\\/)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u00a1-\\uffff][a-z0-9\\u00a1-\\uffff_-]{0,62})?[a-z0-9\\u00a1-\\uffff]\\.)+(?:[a-z\\u00a1-\\uffff]{2,}\\.?))(?::\\d{2,5})?(?:[/?#]\\S*)?$",
  "i"
);
function isLegalUrl(url) {
  if (!Number.isNaN(+url)) {
    return false;
  }
  if (url.startsWith("http://localhost:3002") || url.startsWith("localhost:3002")) {
    return true;
  }
  const legal = re_weburl.test(url);
  if (legal) {
    if (hasProtocol(url)) {
      return true;
    } else {
      try {
        const urlObj = new URL(normalizeUrl(url));
        const topLevelDomain = urlObj.hostname.split(".").pop();
        if (topLevelDomain && topLevelDomainSet.has(topLevelDomain)) {
          return true;
        }
        ;
      } catch (error) {
        return false;
      }
    }
  }
  return false;
}
function hasProtocol(urlString) {
  const pattern = /^[a-zA-Z]+:\/\//;
  return pattern.test(urlString);
}
function isEmail(url) {
  const pattern = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;
  return pattern.test(url);
}
function normalizeUrl(urlStr) {
  return hasProtocol(urlStr) ? urlStr : isEmail(urlStr) ? `mailto://${urlStr}` : `https://${urlStr}`;
}

// ../packages/core/src/shared/tools.ts
var rmsPrefix = /^-ms-/;
var rDashAlpha = /-([a-z])/g;
var alphabets = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z"
];
function isValueEqual(oneValue, twoValue) {
  const oneType = Tools.getValueType(oneValue);
  const twoType = Tools.getValueType(twoValue);
  if (oneType !== twoType) {
    return false;
  }
  if (Tools.isArray(oneValue)) {
    return diffArrays(oneValue, twoValue);
  }
  if (Tools.isObject(oneValue)) {
    return diffObject(oneValue, twoValue);
  }
  if (Tools.isDate(oneValue)) {
    return oneValue.getTime() === twoValue.getTime();
  }
  if (Tools.isRegExp(oneValue)) {
    return oneValue.toString() === twoValue.toString();
  }
  return oneValue === twoValue;
}
function diffArrays(oneArray, twoArray) {
  if (oneArray.length !== twoArray.length) {
    return false;
  }
  for (let i = 0, len = oneArray.length; i < len; i++) {
    const oneValue = oneArray[i];
    const twoValue = twoArray[i];
    if (!isValueEqual(oneValue, twoValue)) {
      return false;
    }
  }
  return true;
}
function diffObject(oneObject, twoObject) {
  const oneKeys = Object.keys(oneObject);
  const twoKeys = Object.keys(twoObject);
  if (oneKeys.length !== twoKeys.length) {
    return false;
  }
  for (const key of oneKeys) {
    if (!twoKeys.includes(key)) {
      return false;
    }
    const oneValue = oneObject[key];
    const twoValue = twoObject[key];
    if (!isValueEqual(oneValue, twoValue)) {
      return false;
    }
  }
  return true;
}
var Tools = class _Tools {
  static stringAt(index) {
    let str = "";
    let idx = index;
    while (idx >= alphabets.length) {
      idx /= alphabets.length;
      idx -= 1;
      str += alphabets[idx % alphabets.length];
    }
    const last = index % alphabets.length;
    str += alphabets[last];
    return str;
  }
  static indexAt(code) {
    let ret = 0;
    for (let i = 0; i < code.length - 1; i += 1) {
      const idx = code.charCodeAt(i) - 65;
      const expoNet = code.length - 1 - i;
      ret += alphabets.length ** expoNet + alphabets.length * idx;
    }
    ret += code.charCodeAt(code.length - 1) - 65;
    return ret;
  }
  static deleteBlank(value) {
    if (_Tools.isString(value)) {
      return value.replace(/\s/g, "");
    }
    return value;
  }
  // eslint-disable-next-line complexity
  static getSystemType() {
    const sUserAgent = navigator.userAgent;
    const isWin = navigator.platform === "Win32" || navigator.platform === "Windows";
    const isMac = navigator.platform === "Mac68K" || navigator.platform === "MacPPC" || navigator.platform === "Macintosh" || navigator.platform === "MacIntel";
    if (isMac) return "Mac";
    const isUnix = navigator.platform === "X11" && !isWin && !isMac;
    if (isUnix) return "Unix";
    const isLinux = String(navigator.platform).indexOf("Linux") > -1;
    if (isLinux) return "Linux";
    if (isWin) {
      const isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
      if (isWin2K) return "Windows 2000";
      const isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
      if (isWinXP) return "Windows XP";
      const isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
      if (isWin2003) return "Windows 2003";
      const isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
      if (isWinVista) return "Windows Vista";
      const isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
      if (isWin7) return "Windows 7";
      const isWin10 = sUserAgent.indexOf("Windows NT 10") > -1 || sUserAgent.indexOf("Windows 10") > -1;
      if (isWin10) return "Windows 10";
      const isWin11 = sUserAgent.indexOf("Windows NT 11") > -1 || sUserAgent.indexOf("Windows 11") > -1;
      if (isWin11) return "Windows 11";
    }
    return "Unknown system";
  }
  static getBrowserType() {
    const userAgent = navigator.userAgent;
    const isOpera = userAgent.indexOf("Opera") > -1;
    const isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera;
    const isIE11 = userAgent.indexOf("Trident") > -1 && userAgent.indexOf("rv:11.0") > -1;
    const isEdge = userAgent.indexOf("Edge") > -1;
    const isFF = userAgent.indexOf("Firefox") > -1;
    const isSafari = userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1;
    const isChrome = userAgent.indexOf("Chrome") > -1 && userAgent.indexOf("Safari") > -1;
    if (isIE) {
      const reIE = new RegExp("MSIE (\\d+\\.\\d+);");
      reIE.test(userAgent);
      const fIEVersion = Number.parseFloat(RegExp.$1);
      if (fIEVersion === 7) {
        return "IE7";
      }
      if (fIEVersion === 8) {
        return "IE8";
      }
      if (fIEVersion === 9) {
        return "IE9";
      }
      if (fIEVersion === 10) {
        return "IE10";
      }
      return "0";
    }
    if (isFF) {
      return "FF";
    }
    if (isOpera) {
      return "Opera";
    }
    if (isSafari) {
      return "Safari";
    }
    if (isChrome) {
      return "Chrome";
    }
    if (isEdge) {
      return "Edge";
    }
    if (isIE11) {
      return "IE11";
    }
    return "Unknown browser";
  }
  /**
   * Use this method without `Tools`.
   *
   * @deprecated
   */
  static generateRandomId(n = 21, alphabet) {
    return generateRandomId(n, alphabet);
  }
  static getClassName(instance) {
    return instance.constructor.name;
  }
  /** @deprecated This method is deprecated, please use `import { merge } from '@univerjs/core` instead */
  static deepMerge(target, ...sources) {
    sources.forEach((item) => item && deepItem(item));
    function deepArray(array, to) {
      array.forEach((value, key) => {
        var _a2, _b2;
        if (_Tools.isArray(value)) {
          const origin = (_a2 = to[key]) != null ? _a2 : [];
          to[key] = origin;
          deepArray(value, origin);
          return;
        }
        if (_Tools.isObject(value)) {
          const origin = (_b2 = to[key]) != null ? _b2 : {};
          to[key] = origin;
          deepObject(value, origin);
          return;
        }
        to[key] = value;
      });
    }
    function deepObject(object, to) {
      Object.keys(object).forEach((key) => {
        var _a2, _b2;
        const value = object[key];
        if (_Tools.isObject(value)) {
          const origin = (_a2 = to[key]) != null ? _a2 : {};
          to[key] = origin;
          deepObject(value, origin);
          return;
        }
        if (_Tools.isArray(value)) {
          const origin = (_b2 = to[key]) != null ? _b2 : [];
          to[key] = origin;
          deepArray(value, origin);
          return;
        }
        to[key] = value;
      });
    }
    function deepItem(item) {
      Object.keys(item).forEach((key) => {
        var _a2, _b2;
        const value = item[key];
        if (_Tools.isArray(value)) {
          const origin = (_a2 = target[key]) != null ? _a2 : [];
          target[key] = origin;
          deepArray(value, origin);
          return;
        }
        if (_Tools.isObject(value)) {
          const origin = (_b2 = target[key]) != null ? _b2 : {};
          target[key] = origin;
          deepObject(value, origin);
          return;
        }
        target[key] = value;
      });
    }
    return target;
  }
  static numberFixed(value, digit) {
    return Number(Number(value).toFixed(digit));
  }
  static diffValue(one, two) {
    return isValueEqual(one, two);
  }
  static deepClone(value) {
    if (!this.isDefine(value)) {
      return value;
    }
    if (this.isRegExp(value)) {
      return new RegExp(value);
    }
    if (this.isDate(value)) {
      return new Date(value);
    }
    if (this.isArray(value)) {
      const clone2 = [];
      value.forEach((item, index) => {
        clone2[index] = _Tools.deepClone(item);
      });
      return clone2;
    }
    if (this.isObject(value)) {
      const clone2 = {};
      Object.keys(value).forEach((key) => {
        const item = value[key];
        clone2[key] = _Tools.deepClone(item);
      });
      Object.setPrototypeOf(clone2, Object.getPrototypeOf(value));
      return clone2;
    }
    return value;
  }
  static getLanguage() {
    const defaultValue = "en-US";
    if (globalThis.navigator) {
      return navigator.languages && navigator.languages[0] || navigator.language || defaultValue;
    }
    return defaultValue;
  }
  static getValueType(value) {
    return Object.prototype.toString.apply(value);
  }
  static isDefine(value) {
    return value !== void 0 && value !== null;
  }
  static isBlank(value) {
    if (!this.isDefine(value)) {
      return true;
    }
    if (this.isString(value)) {
      return value.trim() === "";
    }
    return false;
  }
  static isBoolean(value) {
    return this.getValueType(value) === "[object Boolean]";
  }
  static isPlainObject(value) {
    if (!this.isDefine(value)) {
      return false;
    }
    return Object.getPrototypeOf(value) === Object.getPrototypeOf({});
  }
  static isFunction(value) {
    return this.getValueType(value) === "[object Function]";
  }
  static isDate(value) {
    return this.getValueType(value) === "[object Date]";
  }
  static isRegExp(value) {
    return this.getValueType(value) === "[object RegExp]";
  }
  static isArray(value) {
    return this.getValueType(value) === "[object Array]";
  }
  static isString(value) {
    return this.getValueType(value) === "[object String]";
  }
  static isNumber(value) {
    return this.getValueType(value) === "[object Number]";
  }
  static isStringNumber(value) {
    return !isNaN(Number.parseFloat(value)) && isFinite(value);
  }
  static isObject(value) {
    return this.getValueType(value) === "[object Object]";
  }
  static isEmptyObject(value) {
    for (const _key in value) {
      return false;
    }
    return true;
  }
  static isMobile() {
    let clientWidth = 0;
    let clientHeight = 0;
    if (document.body.clientWidth) {
      clientWidth = document.body.clientWidth;
    }
    if (document.body.clientHeight) {
      clientHeight = document.body.clientHeight;
    }
    return this.isAndroid() || this.isIPhone() || this.isTablet() || clientWidth < 350 && clientHeight < 500;
  }
  static isTablet() {
    return /ipad|android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase());
  }
  static isWeChat() {
    const userAgent = navigator.userAgent.toLowerCase();
    return String(userAgent.match(/MicroMessenger/i)) === "micromessenger" ? true : false;
  }
  static isAndroid() {
    const userAgent = navigator.userAgent;
    return userAgent.indexOf("Android") > -1 || userAgent.indexOf("Linux") > -1;
  }
  static isIPhone() {
    return /iPhone/i.test(navigator.userAgent);
  }
  static isLegalUrl(url) {
    return isLegalUrl(url);
  }
  static normalizeUrl(url) {
    return normalizeUrl(url);
  }
  static topLevelDomainCombiningString() {
    return [...topLevelDomainSet].join("|");
  }
  static itCount(count) {
    return (callback) => {
      for (let i = 0; i < count; i++) {
        callback && callback();
      }
    };
  }
  static hasLength(target, length) {
    if (_Tools.isDefine(target)) {
      if (_Tools.isDefine(length)) {
        return target.length === length;
      }
      return target.length > 0;
    }
    return false;
  }
  static capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  // Used by camelCase as callback to replace()
  static fCamelCase(_all, letter) {
    return letter.toUpperCase();
  }
  // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)
  static camelCase(str) {
    return str.replace(rmsPrefix, "ms-").replace(rDashAlpha, this.fCamelCase);
  }
  /**
   * remove all null from object
   * @param obj
   * @returns
   */
  static removeNull(value) {
    if (this.isObject(value)) {
      Object.keys(value).forEach((key) => {
        const item = value[key];
        if (item == null) {
          delete value[key];
        } else {
          _Tools.removeNull(item);
        }
      });
    }
    return value;
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  static fillTwoDimensionalArray(rows, columns, value) {
    return new Array(rows).fill(value).map((item) => new Array(columns).fill(value));
  }
  /**
   * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
   * @param rows row length
   * @param columns column length
   * @param value value to be set
   * @returns
   */
  // static fillObjectMatrix<T>(rows: number, columns: number, value: T): IObjectMatrixPrimitiveType<T> {
  //     const matrix = new ObjectMatrix<T>();
  //     for (let r = 0; r < rows; r++) {
  //         for (let c = 0; c < columns; c++) {
  //             matrix.setValue(r, c, value);
  //         }
  //     }
  //     return matrix.getData();
  // }
  static numToWord(x) {
    let s = "";
    while (x > 0) {
      let m = x % 26;
      m = m === 0 ? m = 26 : m;
      s = String.fromCharCode(96 + m) + s;
      x = (x - m) / 26;
    }
    return s.toLocaleUpperCase();
  }
  /**
   *
   * Column subscript letter to number
   *
   * @privateRemarks
   * zh: 列下标  字母转数字
   *
   * @param a - Column subscript letter,e.g.,"A1"
   * @returns Column subscript number,e.g.,0
   *
   */
  static ABCatNum(a2) {
    if (a2 == null || a2.length === 0) {
      return Number.NaN;
    }
    const str = a2.toLowerCase().split("");
    const al = str.length;
    let numOut = 0;
    let charnum = 0;
    for (let i = 0; i < al; i++) {
      charnum = str[i].charCodeAt(0) - 96;
      numOut += charnum * 26 ** (al - i - 1);
    }
    if (numOut === 0) {
      return Number.NaN;
    }
    return numOut - 1;
  }
  /**
   * en: Column subscript number to letter
   *
   * zh: 列下标  数字转字母
   *
   * @param n Column subscript number,e.g.,0
   * @returns Column subscript letter,e.g.,"A1"
   */
  static chatAtABC(n) {
    const ord_a = "a".charCodeAt(0);
    const ord_z = "z".charCodeAt(0);
    const len = ord_z - ord_a + 1;
    let s = "";
    while (n >= 0) {
      s = String.fromCharCode(n % len + ord_a) + s;
      n = Math.floor(n / len) - 1;
    }
    return s.toUpperCase();
  }
  static randSort(arr) {
    for (let i = 0, len = arr.length; i < len; i++) {
      const rand = Number.parseInt((Math.random() * len).toString());
      const temp = arr[rand];
      arr[rand] = arr[i];
      arr[i] = temp;
    }
    return arr;
  }
  /**
   * extend two objects
   * @param originJson
   * @param extendJson
   * @returns
   */
  static commonExtend(originJson, extendJson) {
    const resultJsonObject = {};
    for (const attr in originJson) {
      resultJsonObject[attr] = originJson[attr];
    }
    for (const attr in extendJson) {
      if (extendJson[attr] == null) {
        continue;
      }
      resultJsonObject[attr] = extendJson[attr];
    }
    return resultJsonObject;
  }
  static commonExtend1(originJson, extendJson) {
    for (const attr in originJson) {
      if (extendJson[attr] == null) {
        extendJson[attr] = originJson[attr];
      }
    }
    return extendJson;
  }
  static arrayToObject(array) {
    const obj = {};
    array.forEach((row, i) => {
      obj[i] = {};
      row.forEach((column, j) => {
        obj[i][j] = column;
      });
    });
    return obj;
  }
  static hasIntersectionBetweenTwoRanges(range1Start, range1End, range2Start, range2End) {
    return range1End >= range2Start && range2End >= range1Start;
  }
  static isStartValidPosition(name) {
    const startsWithLetterOrUnderscore = /^[A-Za-z_]/.test(name);
    return startsWithLetterOrUnderscore;
  }
  static isValidParameter(name) {
    const containsInvalidChars = /[~!@#$%^&*()+=\-{}\[\]\|:;"'<>,?\/ ]+/.test(name);
    const isValidLength = name.length <= 255;
    return !containsInvalidChars && isValidLength;
  }
  static clamp(value, min2, max2) {
    return Math.max(min2, Math.min(max2, value));
  }
  static now() {
    if (performance && performance.now) {
      return performance.now();
    }
    return Date.now();
  }
};
function generateRandomId(n = 21, alphabet) {
  if (alphabet) {
    return customAlphabet(alphabet, n)();
  }
  return nanoid(n);
}
function composeStyles(...styles) {
  const result = {};
  const length = styles.length;
  for (let i = length - 1; i >= 0; i--) {
    const style = styles[i];
    if (style) {
      const keys = Object.keys(style);
      for (const key of keys) {
        if (result[key] === void 0) {
          result[key] = style[key];
        }
      }
    }
  }
  return result;
}

// ../packages/core/src/types/const/theme-color-map.ts
var THEME_COLORS = {
  ["Office" /* OFFICE */]: {
    [4 /* ACCENT1 */]: "#4472C4",
    [5 /* ACCENT2 */]: "#ED7D31",
    [6 /* ACCENT3 */]: "#A5A5A5",
    [7 /* ACCENT4 */]: "#70AD47",
    [8 /* ACCENT5 */]: "#5B9BD5",
    [9 /* ACCENT6 */]: "#70AD47",
    [0 /* DARK1 */]: "#000000",
    [2 /* DARK2 */]: "#44546A",
    [1 /* LIGHT1 */]: "#FFFFFF",
    [3 /* LIGHT2 */]: "#E7E6E6",
    [10 /* HYPERLINK */]: "#0563C1",
    [11 /* FOLLOWED_HYPERLINK */]: "#954F72"
  }
};

// ../packages/core/src/shared/color/color.ts
var ColorBuilder = class {
  constructor() {
    __publicField(this, "_themeValue", 1 /* LIGHT1 */);
    __publicField(this, "_themeColors");
    __publicField(this, "_themeTint");
    __publicField(this, "_rgbValue", "");
    __publicField(this, "_colorType");
    this._colorType = 0 /* UNSUPPORTED */;
    this._themeColors = "Office" /* OFFICE */;
    this._themeTint = 0;
  }
  asRgbColor() {
    return new RgbColor(this._rgbValue, this);
  }
  asThemeColor() {
    return new ThemeColor(this._themeValue, this._themeTint, this._themeColors, this);
  }
  build() {
    switch (this._colorType) {
      case 3 /* THEME */: {
        return this.asThemeColor();
      }
      case 1 /* RGB */: {
        return this.asRgbColor();
      }
      case 0 /* UNSUPPORTED */: {
        throw new Error("unsupported color type");
      }
    }
  }
  setRgbColor(cssString) {
    this._colorType = 1 /* RGB */;
    this._rgbValue = cssString;
    return this;
  }
  setThemeColors(value) {
    this._colorType = 3 /* THEME */;
    this._themeColors = value;
  }
  setThemeTint(value) {
    this._colorType = 3 /* THEME */;
    this._themeTint = value;
  }
  setThemeColor(theme) {
    this._colorType = 3 /* THEME */;
    this._themeValue = theme;
    return this;
  }
  getColorType() {
    return this._colorType;
  }
};
var Color = class _Color {
  constructor(builder) {
    __publicField(this, "_builder");
    this._builder = builder;
  }
  static rgbColorToHexValue(color) {
    return `#${((1 << 24) + (color.getRed() << 16) + (color.getGreen() << 8) + color.getBlue()).toString(16).slice(1)}`;
  }
  static hexValueToRgbColor(hexValue) {
    if (hexValue) {
      if (hexValue.indexOf("#") > -1) {
        hexValue = hexValue.substring(1);
      }
    } else {
      hexValue = "#000000";
    }
    const r = +`0x${hexValue[0]}${hexValue[1]}`;
    const g = +`0x${hexValue[2]}${hexValue[3]}`;
    const b = +`0x${hexValue[4]}${hexValue[5]}`;
    return new ColorBuilder().setRgbColor(`rgb(${r},${g},${b})`).asRgbColor();
  }
  static hexToRgbString(hex) {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    let string = null;
    if (result) {
      const r = Number.parseInt(result[1], 16);
      const g = Number.parseInt(result[2], 16);
      const b = Number.parseInt(result[3], 16);
      string = `rgba(${r},${g},${b})`;
    }
    return string;
  }
  asRgbColor() {
    return this._builder.asRgbColor();
  }
  asThemeColor() {
    return this._builder.asThemeColor();
  }
  getColorType() {
    return this._builder.getColorType();
  }
  clone() {
    return new _Color(this._builder);
  }
  equals(color) {
    return false;
  }
};
var HLSColor = class {
  constructor(rgbColor) {
    __publicField(this, "_saturation", 0);
    __publicField(this, "_hue", 0);
    __publicField(this, "_lightness", 0);
    __publicField(this, "_alpha", 0);
    const red = rgbColor.getRed() / 255;
    const green = rgbColor.getGreen() / 255;
    const blue = rgbColor.getBlue() / 255;
    const alpha = rgbColor.getAlpha() / 255;
    const min2 = Math.min(red, Math.min(green, blue));
    const max2 = Math.max(red, Math.max(green, blue));
    const delta = max2 - min2;
    if (max2 === min2) {
      this._hue = 0;
      this._saturation = 0;
      this._lightness = max2;
      return;
    }
    this._lightness = (min2 + max2) / 2;
    if (this._lightness < 0.5) {
      this._saturation = delta / (max2 + min2);
    } else {
      this._saturation = delta / (2 - max2 - min2);
    }
    if (red === max2) {
      this._hue = (green - blue) / delta;
    }
    if (green === max2) {
      this._hue = 2 + (blue - red) / delta;
    }
    if (blue === max2) {
      this._hue = 4 + (red - green) / delta;
    }
    this._hue *= 60;
    if (this._hue < 0) {
      this._hue += 360;
    }
    this._alpha = alpha;
  }
  asRgbColor() {
    const builder = new ColorBuilder();
    if (this._saturation === 0) {
      builder.setRgbColor(
        `rgba(${this._lightness * 255},${this._lightness * 255},${this._lightness * 255},${this._alpha * 255})`
      );
      return builder.asRgbColor();
    }
    let t1;
    if (this._lightness < 0.5) {
      t1 = this._lightness * (1 + this._saturation);
    } else {
      t1 = this._lightness + this._saturation - this._lightness * this._saturation;
    }
    const t2 = 2 * this._lightness - t1;
    const hue = this._hue / 360;
    const tR = hue + 1 / 3;
    const red = this.setColor(t1, t2, tR);
    const green = this.setColor(t1, t2, hue);
    const tB = hue - 1 / 3;
    const blue = this.setColor(t1, t2, tB);
    builder.setRgbColor(
      `rgba(${Math.round(red * 255)},${Math.round(green * 255)},${Math.round(blue * 255)},${this._alpha * 255})`
    );
    return builder.asRgbColor();
  }
  getLightness() {
    return this._lightness;
  }
  getHue() {
    return this._hue;
  }
  getSaturation() {
    return this._saturation;
  }
  getAlpha() {
    return this._alpha;
  }
  setColor(t1, t2, t3) {
    if (t3 < 0) {
      t3 += 1;
    }
    if (t3 > 1) {
      t3 -= 1;
    }
    let color;
    if (6 * t3 < 1) {
      color = t2 + (t1 - t2) * 6 * t3;
    } else if (2 * t3 < 1) {
      color = t1;
    } else if (3 * t3 < 2) {
      color = t2 + (t1 - t2) * (2 / 3 - t3) * 6;
    } else {
      color = t2;
    }
    return color;
  }
  setLightness(lightness) {
    this._lightness = lightness;
  }
};
var _RgbColor = class _RgbColor extends Color {
  constructor(cssString, builder) {
    super(builder);
    __publicField(this, "_cssString");
    __publicField(this, "_red");
    __publicField(this, "_green");
    __publicField(this, "_blue");
    __publicField(this, "_alpha");
    let match = cssString.match(_RgbColor.RGBA_EXTRACT);
    if (match) {
      const red = +match[1];
      const green = +match[2];
      const blue = +match[3];
      const alpha = +match[4];
      this._cssString = cssString;
      this._red = red;
      this._green = green;
      this._blue = blue;
      this._alpha = alpha;
      return;
    }
    match = cssString.match(_RgbColor.RGB_EXTRACT);
    if (match) {
      const red = +match[1];
      const green = +match[2];
      const blue = +match[3];
      this._cssString = cssString;
      this._red = red;
      this._green = green;
      this._blue = blue;
      this._alpha = 1;
      return;
    }
    throw new Error("Invalid rgba or rgb color");
  }
  asHexString() {
    return Color.rgbColorToHexValue(this);
  }
  getRed() {
    let r = this._red + _RgbColor.RGB_COLOR_AMT;
    if (r > 255) {
      r = 255;
    } else if (r < 0) {
      r = 0;
    }
    return r;
  }
  getGreen() {
    let g = this._green + _RgbColor.RGB_COLOR_AMT;
    if (g > 255) {
      g = 255;
    } else if (g < 0) {
      g = 0;
    }
    return g;
  }
  getBlue() {
    let b = this._blue + _RgbColor.RGB_COLOR_AMT;
    if (b > 255) {
      b = 255;
    } else if (b < 0) {
      b = 0;
    }
    return b;
  }
  getAlpha() {
    return this._alpha;
  }
  getColorType() {
    return 1 /* RGB */;
  }
  clone() {
    return new _RgbColor(this._cssString, this._builder);
  }
  asThemeColor() {
    throw new Error("rgb color not support to themeColor");
  }
  equals(color) {
    if (color instanceof _RgbColor) {
      return color._red === this._red && color._blue === this._blue && color._green === this._green && color._alpha === this._alpha;
    }
    return false;
  }
  getCssString() {
    return this._cssString;
  }
};
__publicField(_RgbColor, "RGB_COLOR_AMT", 0);
__publicField(_RgbColor, "RGBA_EXTRACT", new RegExp(
  "\\s*rgba\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d.\\d|\\d\\s*)\\)\\s*"
));
__publicField(_RgbColor, "RGB_EXTRACT", new RegExp("\\s*rgb\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*)\\)\\s*"));
var RgbColor = _RgbColor;
var _ThemeColor = class _ThemeColor extends Color {
  constructor(theme, themeTint, themeColors, builder) {
    super(builder);
    __publicField(this, "_themeColorType");
    __publicField(this, "_themeTint");
    __publicField(this, "_themeColors");
    this._themeColorType = theme;
    this._themeTint = themeTint;
    this._themeColors = themeColors;
  }
  lumValue(tint, lum) {
    if (tint == null) {
      return lum;
    }
    let value;
    if (tint < 0) {
      value = lum * (1 + tint);
    } else {
      value = lum * (1 - tint) + (255 - 255 * (1 - tint));
    }
    return value;
  }
  asRgbColor() {
    const themeColors = THEME_COLORS[this._themeColors];
    if (themeColors == null) {
      throw new Error("not find themeColors type");
    }
    const hexValue = themeColors[this._themeColorType];
    if (hexValue == null) {
      throw new Error("not find themeColors value");
    }
    let themeCache;
    if (_ThemeColor._cacheThemeColor.has(this._themeColors)) {
      themeCache = _ThemeColor._cacheThemeColor.get(this._themeColors);
      if (themeCache.has(this._themeColorType)) {
        return themeCache.get(this._themeColorType);
      }
    } else {
      themeCache = /* @__PURE__ */ new Map();
      _ThemeColor._cacheThemeColor.set(this._themeColors, themeCache);
    }
    const hlsColor = new HLSColor(Color.hexValueToRgbColor(hexValue));
    hlsColor.setLightness(this.lumValue(this._themeTint, hlsColor.getLightness() * 255) / 255);
    const rgbColor = hlsColor.asRgbColor();
    themeCache.set(this._themeColorType, rgbColor);
    return rgbColor;
  }
  clone() {
    return new _ThemeColor(this._themeColorType, this._themeTint, this._themeColors, this._builder);
  }
  equals(color) {
    if (color instanceof _ThemeColor) {
      return color._themeColorType === this._themeColorType;
    }
    return false;
  }
  getColorType() {
    return 3 /* THEME */;
  }
  getThemeColorType() {
    return this._themeColorType;
  }
};
__publicField(_ThemeColor, "_cacheThemeColor", /* @__PURE__ */ new Map());
var ThemeColor = _ThemeColor;

// ../packages/core/src/sheets/typedef.ts
function isICellData(value) {
  return value && (value.s !== void 0 || value.p !== void 0 || value.v !== void 0 || value.t !== void 0 || value.f !== void 0 || value.si !== void 0 || value.custom !== void 0);
}
function selectionToArray(range) {
  return [range.startRow, range.startColumn, range.endRow, range.endColumn];
}

// ../packages/core/src/shared/common.ts
function isEmptyCell(cell) {
  var _a2;
  if (!cell) {
    return true;
  }
  const content = ((_a2 = cell == null ? void 0 : cell.v) == null ? void 0 : _a2.toString()) || "";
  if (content.length === 0 && !cell.p) {
    return true;
  }
  return false;
}
function isCellCoverable(cell) {
  return isEmptyCell(cell) && (cell == null ? void 0 : cell.coverable) !== false;
}
function isFormulaString(value) {
  return Tools.isString(value) && value.substring(0, 1) === "=" && value.length > 1;
}
function isFormulaId(value) {
  return Tools.isString(value) && value.length > 0;
}
function isValidRange(range, worksheet) {
  const { startRow, endRow, startColumn, endColumn, rangeType } = range;
  if (startRow < 0 || startColumn < 0 || endRow < 0 || endColumn < 0) {
    return false;
  }
  if (!(Number.isNaN(startRow) && Number.isNaN(endRow)) && rangeType === 2 /* COLUMN */) {
    return false;
  }
  if (!(Number.isNaN(startColumn) && Number.isNaN(endColumn)) && rangeType === 1 /* ROW */) {
    return false;
  }
  if (rangeType !== 1 /* ROW */ && rangeType !== 2 /* COLUMN */ && (Number.isNaN(startColumn) || Number.isNaN(startRow) || Number.isNaN(endColumn) || Number.isNaN(endRow))) {
    return false;
  }
  if (worksheet) {
    const rowCount = worksheet.getRowCount();
    const colCount = worksheet.getColumnCount();
    if (endRow >= rowCount || endColumn >= colCount) {
      return false;
    }
  }
  return true;
}
function cellToRange(row, col) {
  return { startRow: row, endRow: row, startColumn: col, endColumn: col };
}

// ../packages/core/src/shared/compare.ts
function deepCompare(arg1, arg2) {
  if (Object.prototype.toString.call(arg1) === Object.prototype.toString.call(arg2)) {
    if (Object.prototype.toString.call(arg1) === "[object Object]" || Object.prototype.toString.call(arg1) === "[object Array]") {
      if (Object.keys(arg1).length !== Object.keys(arg2).length) {
        return false;
      }
      return Object.keys(arg1).every((key) => deepCompare(arg1[key], arg2[key]));
    }
    return arg1 === arg2;
  }
  return false;
}
function isSameStyleTextRun(tr1, tr2) {
  const ts1 = tr1.ts || {};
  const ts2 = tr2.ts || {};
  if (tr1.sId !== tr2.sId) {
    return false;
  }
  return deepCompare(ts1, ts2);
}

// ../packages/core/src/shared/dayjs.ts
var import_dayjs = __toESM(require_dayjs_min());
var import_advancedFormat = __toESM(require_advancedFormat());
var import_customParseFormat = __toESM(require_customParseFormat());
var import_localeData = __toESM(require_localeData());
var import_localizedFormat = __toESM(require_localizedFormat());
var import_utc = __toESM(require_utc());
var import_weekday = __toESM(require_weekday());
var import_weekOfYear = __toESM(require_weekOfYear());
var import_weekYear = __toESM(require_weekYear());
import_dayjs.default.extend(import_customParseFormat.default);
import_dayjs.default.extend(import_advancedFormat.default);
import_dayjs.default.extend(import_weekday.default);
import_dayjs.default.extend(import_localeData.default);
import_dayjs.default.extend(import_weekOfYear.default);
import_dayjs.default.extend(import_weekYear.default);
import_dayjs.default.extend(import_utc.default);
import_dayjs.default.extend(import_localizedFormat.default);

// ../packages/core/src/shared/doc-tool.ts
function horizontalLineSegmentsSubtraction(aStart, aEnd, bStart, bEnd) {
  if (aStart > aEnd) {
    throw new Error("a1 should be less than a2");
  }
  if (bStart > bEnd) {
    throw new Error("b1 should be less than b2");
  }
  if (aEnd < bStart || bEnd < aStart) {
    return [aStart, aEnd];
  }
  if (bStart <= aStart && bEnd >= aEnd) {
    return [];
  }
  const subLength = bEnd - bStart + 1;
  if (aStart < bStart && aEnd > bEnd) {
    return [aStart, aEnd - subLength];
  }
  if (bStart <= aStart && bEnd < aEnd) {
    return [bEnd + 1 - subLength, aEnd - subLength];
  }
  if (bStart > aStart && bEnd >= aEnd) {
    return [aStart, bStart - 1];
  }
  return [aStart, aEnd];
}
function insertTextToContent(content, start, text) {
  return content.slice(0, start) + text + content.slice(start);
}
function deleteContent(content, start, end) {
  if (start > end) {
    return content;
  }
  return content.slice(0, start) + content.slice(end);
}

// ../packages/core/src/shared/generate.ts
function isRealNum(val) {
  if (val === null || val === void 0) {
    return false;
  }
  if (typeof val === "boolean") {
    return false;
  }
  if (typeof val === "number") {
    return !isNaN(val);
  }
  if (typeof val === "string") {
    const trimmedVal = val.trim();
    if (trimmedVal === "") {
      return false;
    }
    return !isNaN(Number(trimmedVal));
  }
  return false;
}

// ../packages/core/src/shared/hash-algorithm.ts
function hashAlgorithm(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;
  }
  return hash >>> 0;
}

// ../packages/core/src/shared/lru/lru-map.ts
var NEWER = Symbol("newer");
var OLDER = Symbol("older");
var KeyIterator = class {
  constructor(oldestEntry) {
    __publicField(this, "entry");
    this.entry = oldestEntry;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const ent = this.entry;
    if (ent) {
      this.entry = ent[NEWER];
      return { done: false, value: ent.key };
    }
    return { done: true, value: void 0 };
  }
};
var ValueIterator = class {
  constructor(oldestEntry) {
    __publicField(this, "entry");
    this.entry = oldestEntry;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const ent = this.entry;
    if (ent) {
      this.entry = ent[NEWER];
      return { done: false, value: ent.value };
    }
    return { done: true, value: void 0 };
  }
};
var EntryIterator = class {
  constructor(oldestEntry) {
    __publicField(this, "entry");
    this.entry = oldestEntry;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const ent = this.entry;
    if (ent) {
      this.entry = ent[NEWER];
      return { done: false, value: [ent.key, ent.value] };
    }
    return { done: true, value: void 0 };
  }
};
var _a, _b;
_b = NEWER, _a = OLDER;
var Entry = class {
  constructor(key, value) {
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, _b);
    __publicField(this, _a);
    this.key = key;
    this.value = value;
    this[NEWER] = void 0;
    this[OLDER] = void 0;
  }
  toJSON() {
    return {
      key: this.key,
      value: this.value
    };
  }
};
var LRUMap = class {
  constructor(...parameter) {
    __publicField(this, "_keymap");
    __publicField(this, "size", 0);
    __publicField(this, "limit");
    __publicField(this, "oldest");
    __publicField(this, "newest");
    __publicField(this, "_onShiftListeners", []);
    if (LRUHelper.hasLength(parameter, 1)) {
      if (LRUHelper.isNumber(parameter[0])) {
        const limit = parameter[0];
        this._initialize(limit, void 0);
        return;
      }
      if (LRUHelper.isIterable(parameter[0])) {
        const entries = parameter[0];
        this._initialize(0, entries);
        return;
      }
      return;
    }
    if (LRUHelper.hasLength(parameter, 2)) {
      const limit = parameter[0];
      const entries = parameter[1];
      this._initialize(limit, entries);
    }
  }
  onShift(callback) {
    if (this._onShiftListeners.indexOf(callback) === -1) {
      this._onShiftListeners.push(callback);
      return toDisposable(() => remove(this._onShiftListeners, callback));
    }
    throw new Error("[LRUMap]: the listener has been registered!");
  }
  _initialize(limit, entries) {
    this.oldest = void 0;
    this.newest = void 0;
    this.size = 0;
    this.limit = limit;
    this._keymap = /* @__PURE__ */ new Map();
    if (entries) {
      this.assign(entries);
      if (limit < 1) {
        this.limit = this.size;
      }
    }
  }
  _markEntryAsUsed(entry) {
    if (entry === this.newest) {
      return;
    }
    if (entry[NEWER]) {
      if (entry === this.oldest) {
        this.oldest = entry[NEWER];
      }
      entry[NEWER][OLDER] = entry[OLDER];
    }
    if (entry[OLDER]) {
      entry[OLDER][NEWER] = entry[NEWER];
    }
    entry[NEWER] = void 0;
    entry[OLDER] = this.newest;
    if (this.newest) {
      this.newest[NEWER] = entry;
    }
    this.newest = entry;
  }
  assign(entries) {
    let entry;
    let limit = this.limit || Number.MAX_VALUE;
    this._keymap.clear();
    const it = entries[Symbol.iterator]();
    for (let itv = it.next(); !itv.done; itv = it.next()) {
      const e = new Entry(itv.value[0], itv.value[1]);
      this._keymap.set(e.key, e);
      if (!entry) {
        this.oldest = e;
      } else {
        entry[NEWER] = e;
        e[OLDER] = entry;
      }
      entry = e;
      if (limit-- === 0) {
        throw new Error("overflow");
      }
    }
    this.newest = entry;
    this.size = this._keymap.size;
  }
  set(key, value) {
    let entry = this._keymap.get(key);
    if (entry) {
      entry.value = value;
      this._markEntryAsUsed(entry);
      return this;
    }
    this._keymap.set(key, entry = new Entry(key, value));
    if (this.newest) {
      this.newest[NEWER] = entry;
      entry[OLDER] = this.newest;
    } else {
      this.oldest = entry;
    }
    this.newest = entry;
    ++this.size;
    if (this.size > this.limit) {
      this.shift();
    }
    return this;
  }
  shift() {
    const entry = this.oldest;
    if (entry) {
      if (this.oldest && this.oldest[NEWER]) {
        this.oldest = this.oldest[NEWER];
        this.oldest[OLDER] = void 0;
      } else {
        this.oldest = void 0;
        this.newest = void 0;
      }
      entry[NEWER] = entry[OLDER] = void 0;
      this._keymap.delete(entry.key);
      --this.size;
      this._onShiftListeners.forEach((callback) => callback(entry));
      return [entry.key, entry.value];
    }
  }
  get(key) {
    const entry = this._keymap.get(key);
    if (!entry) return;
    this._markEntryAsUsed(entry);
    return entry.value;
  }
  has(key) {
    return this._keymap.has(key);
  }
  find(key) {
    const e = this._keymap.get(key);
    return e ? e.value : void 0;
  }
  delete(key) {
    const entry = this._keymap.get(key);
    if (!entry) return;
    this._keymap.delete(entry.key);
    if (entry[NEWER] && entry[OLDER]) {
      entry[OLDER][NEWER] = entry[NEWER];
      entry[NEWER][OLDER] = entry[OLDER];
    } else if (entry[NEWER]) {
      entry[NEWER][OLDER] = void 0;
      this.oldest = entry[NEWER];
    } else if (entry[OLDER]) {
      entry[OLDER][NEWER] = void 0;
      this.newest = entry[OLDER];
    } else {
      this.oldest = this.newest = void 0;
    }
    this.size--;
    return entry.value;
  }
  clear() {
    this.oldest = void 0;
    this.newest = void 0;
    this.size = 0;
    this._keymap.clear();
  }
  keys() {
    return new KeyIterator(this.oldest);
  }
  values() {
    return new ValueIterator(this.oldest);
  }
  entries() {
    return this[Symbol.iterator]();
  }
  [Symbol.iterator]() {
    return new EntryIterator(this.oldest);
  }
  forEach(fun, thisObj) {
    if (typeof thisObj !== "object") {
      thisObj = this;
    }
    let entry = this.oldest;
    while (entry) {
      fun.call(thisObj, entry.value, entry.key, this);
      entry = entry[NEWER];
    }
  }
  toJSON() {
    const s = new Array(this.size);
    let i = 0;
    let entry = this.oldest;
    while (entry) {
      s[i++] = { key: entry.key, value: entry.value };
      entry = entry[NEWER];
    }
    return s;
  }
  toString() {
    let s = String();
    let entry = this.oldest;
    while (entry) {
      s += `${String(entry.key)}:${entry.value}`;
      entry = entry[NEWER];
      if (entry) {
        s += " < ";
      }
    }
    return s;
  }
};
var LRUHelper = class {
  static hasLength(array, size) {
    return array.length === size;
  }
  static getValueType(value) {
    return Object.prototype.toString.apply(value);
  }
  static isObject(value) {
    return this.getValueType(value) === "[object Object]";
  }
  static isIterable(value) {
    return value[Symbol.iterator] != null;
  }
  static isNumber(value) {
    return this.getValueType(value) === "[object Number]";
  }
};

// ../packages/core/src/shared/numfmt.ts
var import_numfmt = __toESM(require_numfmt2());
var numfmt = import_numfmt.default;

// ../packages/core/src/shared/object-matrix.ts
function getArrayLength(o) {
  let maxIndex = 0;
  const keys = Object.keys(o);
  for (const key of keys) {
    const rowIndex = Number(key);
    maxIndex = Math.max(maxIndex, rowIndex);
  }
  return maxIndex + 1;
}
function insertMatrixArray(index, value, o) {
  const length = getArrayLength(o);
  const array = o;
  for (let i = length - 1; i >= index; i--) {
    array[i + 1] = array[i];
  }
  array[index] = value;
}
function spliceArray(start, count, o) {
  const length = Object.keys(o).reduce((max2, key) => Math.max(max2, Number.parseInt(key)), 0) + 1;
  for (let i = start; i < length; i++) {
    if (i < start + count) {
      delete o[i];
    } else {
      if (o[i] !== void 0) {
        o[i - count] = o[i];
        delete o[i];
      }
    }
  }
}
function concatMatrixArray(source, target) {
  const srcArray = source;
  const srcKeys = Object.keys(srcArray);
  const srcLength = srcKeys.length;
  const targetArray = target;
  const targetKeys = Object.keys(targetArray);
  const targetLength = targetKeys.length;
  const containerArray = {};
  let master = 0;
  for (let i = 0; i < srcLength; i++, master++) {
    const key = srcKeys[i];
    containerArray[master] = srcArray[key];
  }
  for (let i = 0; i < targetLength; i++, master++) {
    const key = targetKeys[i];
    containerArray[master] = targetArray[key];
  }
  return containerArray;
}
function sliceMatrixArray(start, end, matrixArray) {
  const array = matrixArray;
  const length = getArrayLength(matrixArray);
  if (length > 0) {
    const fragment = {};
    let effective = 0;
    for (let i = start; i <= end; i++) {
      const item = array[i];
      if (item) {
        fragment[effective] = array[i];
        effective++;
      }
    }
    return fragment;
  }
  return {};
}
function moveMatrixArray(fromIndex, count, toIndex, o) {
  const moveBackward = fromIndex > toIndex;
  if (!moveBackward && fromIndex + count > toIndex) {
    throw new Error("Invalid move operation");
  }
  if (moveBackward) {
    _moveBackward(fromIndex, count, toIndex, o);
  } else {
    _moveForward(fromIndex, count, toIndex, o);
  }
}
function _moveBackward(fromIndex, count, toIndex, o) {
  const array = o;
  const toMove = [];
  for (let i = fromIndex; i < fromIndex + count; i++) {
    toMove.push(array[i]);
  }
  for (let i = fromIndex - 1; i >= toIndex; i--) {
    const item = array[i];
    array[i + count] = item;
    if (item === void 0) {
      delete array[i + count];
    }
  }
  toMove.forEach((item, index) => {
    array[toIndex + index] = item;
    if (item === void 0) {
      delete array[toIndex + index];
    }
  });
}
function _moveForward(fromIndex, count, toIndex, o) {
  const array = o;
  const toMove = [];
  for (let i = fromIndex; i < fromIndex + count; i++) {
    toMove.push(array[i]);
  }
  for (let i = fromIndex + count; i < toIndex; i++) {
    const item = array[i];
    array[i - count] = item;
    if (item === void 0) {
      delete array[i - count];
    }
  }
  toMove.forEach((item, index) => {
    array[toIndex + index - count] = item;
    if (item === void 0) {
      delete array[toIndex + index - count];
    }
  });
}
var ObjectMatrix = class _ObjectMatrix {
  constructor(matrix = {}) {
    __publicField(this, "_matrix");
    this._setOriginValue(matrix);
  }
  static MakeObjectMatrixSize(size) {
    return new _ObjectMatrix({
      [size - 1]: {}
    });
  }
  getMatrix() {
    return this._matrix;
  }
  forEach(callback) {
    const matrix = this._matrix;
    const matrixRow = Object.keys(matrix);
    for (const row of matrixRow) {
      const rowNumber = Number(row);
      const columns = matrix[rowNumber];
      const result = callback(rowNumber, columns);
      if (result === false) {
        return this;
      }
    }
    return this;
  }
  forRow(callback) {
    const matrix = this._matrix;
    const matrixRow = Object.keys(matrix);
    for (const row of matrixRow) {
      const rowNumber = Number(row);
      const columns = matrix[rowNumber];
      const result = callback(
        rowNumber,
        Object.keys(columns).map((col) => {
          return Number(col);
        })
      );
      if (result === false) {
        return this;
      }
    }
    return this;
  }
  /**
   * Iterate the object matrix with row priority, which means it scan the whole range row by row.
   */
  forValue(callback) {
    const matrix = this._matrix;
    for (const row in matrix) {
      const rowNumber = Number(row);
      const columns = matrix[rowNumber];
      if (!columns) continue;
      for (const column in columns) {
        const colNumber = Number(column);
        const value = columns[colNumber];
        const result = callback(rowNumber, colNumber, value);
        if (result === false) {
          return this;
        }
      }
    }
    return this;
  }
  swapRow(src, target) {
    const srcRow = this._matrix[src];
    const targetRow = this._matrix[target];
    this._matrix[src] = targetRow;
    this._matrix[target] = srcRow;
  }
  getRow(rowIndex) {
    return this._matrix[rowIndex];
  }
  getRowOrCreate(rowIndex) {
    let row = this.getRow(rowIndex);
    if (row == null) {
      row = {};
      this._matrix[rowIndex] = row;
    }
    return row;
  }
  reset() {
    this._setOriginValue({});
  }
  hasValue() {
    const matrix = this._matrix;
    const matrixRow = Object.keys(matrix);
    if (matrixRow.length === 0) {
      return false;
    }
    for (const row of matrixRow) {
      const rowNumber = Number(row);
      const columns = matrix[rowNumber];
      const columnKeys = Object.keys(columns);
      if (columnKeys.length > 0) {
        return true;
      }
    }
    return false;
  }
  getValue(row, column) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._matrix) == null ? void 0 : _a2[row]) == null ? void 0 : _b2[column];
  }
  setValue(row, column, value) {
    const objectArray = this.getRowOrCreate(row);
    objectArray[column] = value;
  }
  /**
   * ！！
   * Please +1 ‘！’, who fell into this pit.
   * @deprecated use `realDelete` or `splice`
   */
  deleteValue(row, column) {
    var _a2, _b2;
    (_b2 = (_a2 = this._matrix) == null ? void 0 : _a2[row]) == null ? true : delete _b2[column];
  }
  realDeleteValue(row, column) {
    var _a2, _b2, _c;
    (_b2 = (_a2 = this._matrix) == null ? void 0 : _a2[row]) == null ? true : delete _b2[column];
    if (this.getRow(row)) {
      const objectArray = this.getRow(row);
      if (objectArray == null) {
        return;
      }
      const keys = Object.keys(objectArray);
      if (keys.length === 0) {
        (_c = this._matrix) == null ? true : delete _c[row];
      }
    }
  }
  setRow(rowNumber, row) {
    this._matrix[rowNumber] = row;
  }
  moveRows(start, count, target) {
    moveMatrixArray(start, count, target, this._matrix);
  }
  moveColumns(start, count, target) {
    this.forEach((row, value) => {
      moveMatrixArray(start, count, target, value);
    });
  }
  insertRows(start, count) {
    for (let r = start; r < start + count; r++) {
      const initial = {};
      insertMatrixArray(r, initial, this._matrix);
    }
  }
  insertColumns(start, count) {
    for (let c = start; c < start + count; c++) {
      this.forEach((row, data) => {
        if (data) {
          insertMatrixArray(c, void 0, data);
        }
      });
    }
  }
  removeRows(start, count) {
    spliceArray(start, count, this._matrix);
  }
  removeColumns(start, count) {
    this.forEach((row, value) => {
      if (value) {
        spliceArray(start, count, value);
      }
    });
  }
  /**
   * Return a fragment of the original data matrix. Note that the returned matrix's row matrix would start from
   * 0 not `startRow`. Neither does its column matrix. If you want to get the original matrix, use `getSlice`.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getFragment(startRow, endRow, startColumn, endColumn) {
    const objectMatrix = new _ObjectMatrix();
    let insertRow = 0;
    for (let r = startRow; r <= endRow; r++) {
      const row = {};
      let insertColumn = 0;
      for (let c = startColumn; c <= endColumn; c++) {
        const value = this.getValue(r, c);
        row[insertColumn] = value;
        insertColumn++;
      }
      objectMatrix.setRow(insertRow, row);
      insertRow++;
    }
    return objectMatrix;
  }
  /**
   * Return a slice of the original data matrix. Note that the returned matrix's row matrix would start from
   * `startRow` not 0, and the same does its column index. You may be looking for `getFragment` if you want
   * both of the indexes start from 0.
   *
   * @param startRow
   * @param endRow
   * @param startColumn
   * @param endColumn
   * @returns
   */
  getSlice(startRow, endRow, startColumn, endColumn) {
    const objectMatrix = new _ObjectMatrix();
    for (let r = startRow; r <= endRow; r++) {
      for (let c = startColumn; c <= endColumn; c++) {
        const value = this.getValue(r, c);
        if (value) {
          objectMatrix.setValue(r, c, Tools.deepClone(value));
        }
      }
    }
    return objectMatrix;
  }
  getSizeOf() {
    const keys = Object.keys(this._matrix);
    return keys.length;
  }
  getLength() {
    return getArrayLength(this._matrix);
  }
  getRange() {
    const startRow = 0;
    const startColumn = 0;
    const endRow = this.getLength() - 1;
    let endColumn = 0;
    const length = this.getLength();
    for (let i = 0; i < length; i++) {
      const row = this.getRow(i);
      if (row) {
        const columnLength = getArrayLength(row) - 1;
        endColumn = columnLength > endColumn ? columnLength : endColumn;
      }
    }
    return {
      startRow,
      startColumn,
      endRow,
      endColumn
    };
  }
  toNativeArray() {
    const native = new Array();
    this.forValue((row, col, value) => {
      native.push(value);
    });
    return native;
  }
  toArray() {
    const array = [];
    this.forRow((row, cols) => {
      if (array[row] == null) {
        array[row] = [];
      }
      cols.forEach((column) => {
        array[row][column] = this.getValue(row, column);
      });
    });
    return array;
  }
  toFullArray() {
    const range = this.getRange();
    const { endColumn, endRow } = range;
    const array = [];
    for (let i = 0; i <= endRow; i++) {
      const subArr = new Array(endColumn + 1).fill(void 0);
      array.push(subArr);
    }
    this.forValue((row, col, value) => {
      array[row][col] = value;
    });
    return array;
  }
  /**
   * @deprecated Use getMatrix as a substitute.
   */
  toJSON() {
    return this._matrix;
  }
  clone() {
    const json = JSON.stringify(this._matrix);
    return JSON.parse(json);
  }
  /**
   * @deprecated Use clone as a substitute.
   */
  getData() {
    const json = JSON.stringify(this._matrix);
    return JSON.parse(json);
  }
  getArrayData() {
    let startRow = 0;
    let startColumn = 0;
    let initRow = false;
    let initColumn = false;
    const objectMatrix = new _ObjectMatrix();
    this.forEach((rowIndex, rowObject) => {
      if (!initRow) {
        initRow = true;
        startRow = rowIndex;
      }
      Object.keys(rowObject).forEach((column) => {
        const columnIndex = Number(column);
        if (!initColumn) {
          initColumn = true;
          startColumn = columnIndex;
        } else if (columnIndex < startColumn) {
          startColumn = columnIndex;
        }
        const value = this.getValue(rowIndex, columnIndex);
        objectMatrix.setValue(rowIndex - startRow, columnIndex - startColumn, value);
      });
    });
    return objectMatrix.getData();
  }
  /**
   * the function can only be used in all the row and column are positive integer
   * @description the positive integer in V8 Object is stored in a fast memory space and it is sorted  when we get the keys
   * @returns {IRange} the start and end scope of the matrix
   */
  getStartEndScope() {
    let startRow = Infinity;
    let endRow = -Infinity;
    let startColumn = Infinity;
    let endColumn = -Infinity;
    const rows = Object.keys(this._matrix);
    if (rows.length > 0) {
      startRow = +rows[0];
      endRow = +rows[rows.length - 1];
    }
    for (const row of rows) {
      const columns = Object.keys(this._matrix[row]);
      if (columns.length > 0) {
        startColumn = Math.min(startColumn, +columns[0]);
        endColumn = Math.max(endColumn, +columns[columns.length - 1]);
      }
    }
    return { startRow, endRow, startColumn, endColumn };
  }
  getDataRange() {
    let startRow = 0;
    let startColumn = 0;
    let endColumn = 0;
    let endRow = -1;
    let initRow = false;
    let initColumn = false;
    this.forEach((rowIndex, row) => {
      if (!initRow) {
        initRow = true;
        startRow = rowIndex;
      }
      if (row == null) {
        return;
      }
      const rowSize = getArrayLength(row) - 1;
      if (rowSize > endColumn) {
        endColumn = rowSize;
      }
      Object.keys(row).forEach((column) => {
        const columnIndex = Number(column);
        if (!initColumn) {
          initColumn = true;
          startColumn = columnIndex;
        } else if (columnIndex < startColumn) {
          startColumn = columnIndex;
        }
      });
      if (rowIndex > endRow) {
        endRow = rowIndex;
      }
    });
    return {
      startRow,
      startColumn,
      endRow,
      endColumn
    };
  }
  getDiscreteRanges() {
    const ranges = [];
    this.forEach((r, row) => {
      Object.keys(row).forEach((col) => {
        const c = Number(col);
        let merged = false;
        for (const range of ranges) {
          if (r >= range.startRow && r <= range.endRow + 1 && c >= range.startColumn && c <= range.endColumn + 1) {
            range.endRow = Math.max(r, range.endRow);
            range.endColumn = Math.max(c, range.endColumn);
            merged = true;
            break;
          }
        }
        if (!merged) {
          ranges.push({
            startRow: r,
            endRow: r,
            startColumn: c,
            endColumn: c
          });
        }
      });
    });
    return ranges;
  }
  _setOriginValue(matrix = {}) {
    this._matrix = matrix;
  }
};

// ../packages/core/src/common/const.ts
var PREFIX = "__INTERNAL_EDITOR__";
var DOCS_NORMAL_EDITOR_UNIT_ID_KEY = `${PREFIX}DOCS_NORMAL`;
var DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY = `${PREFIX}DOCS_FORMULA_BAR`;
var DOCS_ZEN_EDITOR_UNIT_ID_KEY = `${PREFIX}ZEN_EDITOR`;
var DEFAULT_EMPTY_DOCUMENT_VALUE = "\r\n";
var IS_ROW_STYLE_PRECEDE_COLUMN_STYLE = "isRowStylePrecedeColumnStyle";
var AUTO_HEIGHT_FOR_MERGED_CELLS = Symbol("AUTO_HEIGHT_FOR_MERGED_CELLS");
function isInternalEditorID(id) {
  return id.startsWith(PREFIX);
}

// ../packages/core/src/types/const/const.ts
var DEFAULT_STYLES = {
  /**
   * fontFamily
   */
  ff: "Arial",
  /**
   * fontSize
   */
  fs: 11,
  /**
   * italic
   * 0: false
   * 1: true
   */
  it: 0 /* FALSE */,
  /**
   * bold
   * 0: false
   * 1: true
   */
  bl: 0 /* FALSE */,
  /**
   * underline
   */
  ul: {
    s: 0 /* FALSE */
  },
  /**
   * strikethrough
   */
  st: {
    s: 0 /* FALSE */
  },
  /**
   * overline
   */
  ol: {
    s: 0 /* FALSE */
  },
  /**
   * textRotation
   */
  tr: {
    a: 0,
    /**
     * true : 1
     * false : 0
     */
    v: 0 /* FALSE */
  },
  /**
   * textDirection
   */
  td: 0 /* UNSPECIFIED */,
  /**
   * color
   */
  cl: {
    rgb: "#000"
  },
  /**
   * background
   */
  bg: {
    rgb: "#fff"
  },
  /**
   * horizontalAlignment
   */
  ht: 0 /* UNSPECIFIED */,
  /**
   * verticalAlignment
   */
  vt: 0 /* UNSPECIFIED */,
  /**
   * wrapStrategy
   */
  tb: 0 /* UNSPECIFIED */,
  /**
   * padding
   */
  pd: {
    t: 0,
    r: 0,
    b: 0,
    l: 0
  },
  n: null,
  /**
   * border
   */
  bd: {
    b: null,
    l: null,
    r: null,
    t: null
  }
};
var DEFAULT_SLIDE = {
  id: "default_slide",
  title: "defaultSlide",
  pageSize: {
    width: 300,
    height: 300
  }
};

// ../packages/core/src/sheets/range.ts
function isAllFormatInTextRuns(key, body) {
  const { textRuns = [] } = body;
  let len = 0;
  for (const textRun of textRuns) {
    const { ts = {}, st, ed } = textRun;
    if (ts[key] == null) {
      return 0 /* FALSE */;
    }
    switch (key) {
      case "bl":
      // fallthrough
      case "it": {
        if (ts[key] === 0 /* FALSE */) {
          return 0 /* FALSE */;
        }
        break;
      }
      case "ul":
      // fallthrough
      case "st": {
        if (ts[key].s === 0 /* FALSE */) {
          return 0 /* FALSE */;
        }
        break;
      }
      default:
        throw new Error(`unknown style key: ${key} in IStyleBase`);
    }
    len += ed - st;
  }
  const index = body.dataStream.indexOf("\r\n");
  return index === len ? 1 /* TRUE */ : 0 /* FALSE */;
}
var _Range = class _Range {
  constructor(workSheet, range, _deps) {
    this._deps = _deps;
    __publicField(this, "_range");
    __publicField(this, "_worksheet");
    this._range = range;
    this._worksheet = workSheet;
  }
  static foreach(range, action) {
    const { startRow, startColumn, endRow, endColumn } = range;
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        action(i, j);
      }
    }
  }
  /**
   * get current range data
   *
   * @returns current range
   */
  getRangeData() {
    return this._range;
  }
  /**
   * Returns the value of the top-left cell in the range. The value may be of type Number, Boolean, Date, or String
   * depending on the value of the cell. Empty cells return an empty string.
   * @returns  The value in this cell
   */
  getValue() {
    return this.getValues()[0][0];
  }
  /**
   * Returns the rectangular grid of values for this range.
   *
   * Returns a two-dimensional array of values, indexed by row, then by column. The values may be of type Number,
   * Boolean, Date, or String, depending on the value of the cell. Empty cells are represented by an empty string
   * in the array. Remember that while a range index starts at 0, 0, same as the JavaScript array is indexed from [0][0].
   *
   * In web apps, a Date value isn't a legal parameter. getValues() fails to return data to a web app if the range
   * contains a cell with a Date value. Instead, transform all the values retrieved from the sheet to a supported
   * JavaScript primitive like a Number, Boolean, or String.
   *
   * @returns  A two-dimensional array of values.
   */
  getValues() {
    const { startRow, endRow, startColumn, endColumn } = this._range;
    const range = [];
    for (let r = startRow; r <= endRow; r++) {
      const row = [];
      for (let c = startColumn; c <= endColumn; c++) {
        row.push(this.getMatrix().getValue(r, c) || null);
      }
      range.push(row);
    }
    return range;
  }
  /**
   * get range matrix
   *
   * @returns range matrix
   */
  getMatrix() {
    const { startRow, endRow, startColumn, endColumn } = this._range;
    const sheetMatrix = this._worksheet.getCellMatrix();
    const rangeMatrix = new ObjectMatrix();
    for (let r = startRow; r <= endRow; r++) {
      for (let c = startColumn; c <= endColumn; c++) {
        rangeMatrix.setValue(r, c, sheetMatrix.getValue(r, c) || null);
      }
    }
    return rangeMatrix;
  }
  /**
   * get range matrix object
   *
   * @returns range matrix object
   */
  getMatrixObject() {
    const { startRow, endRow, startColumn, endColumn } = this._range;
    const sheetMatrix = this._worksheet.getCellMatrix();
    const rangeMatrix = new ObjectMatrix();
    for (let r = startRow; r <= endRow; r++) {
      for (let c = startColumn; c <= endColumn; c++) {
        rangeMatrix.setValue(r - startRow, c - startColumn, sheetMatrix.getValue(r, c) || {});
      }
    }
    return rangeMatrix;
  }
  /**
   * Returns a string description of the range, in A1 notation.
   *
   * @returns The string description of the range in A1 notation.
   */
  getA1Notation() {
    const { startRow, endRow, startColumn, endColumn } = this._range;
    let start;
    let end;
    if (startColumn < endColumn) {
      start = Tools.numToWord(startColumn + 1) + (startRow + 1);
      end = Tools.numToWord(endColumn + 1) + (endRow + 1);
    } else {
      start = Tools.numToWord(endColumn + 1) + (endRow + 1);
      end = Tools.numToWord(startColumn + 1) + (startRow + 1);
    }
    if (start === end) return `${start}`;
    return `${start}:${end}`;
  }
  /**
   * Returns the background color of the top-left cell in the range (for example, '#ffffff').
   *
   * @returns — The color code of the background.
   */
  getBackground() {
    return this.getBackgrounds()[0][0];
  }
  /**
   * Returns the background colors of the cells in the range (for example, '#ffffff').
   *
   * @returns  — A two-dimensional array of color codes of the backgrounds.
   */
  getBackgrounds() {
    const styles = this._deps.getStyles();
    return this.getValues().map(
      (row) => row.map((cell) => {
        var _a2;
        const rgbColor = styles.getStyleByCell(cell);
        return ((_a2 = rgbColor == null ? void 0 : rgbColor.bg) == null ? void 0 : _a2.rgb) || DEFAULT_STYLES.bg.rgb;
      })
    );
  }
  /**
   * Returns a given cell within a range.
   *
   * The row and column here are relative to the range
   * e.g. "B2:D4", getCell(0,0) in this code returns the cell at B2
   * @returns  — A range containing a single cell at the specified coordinates.
   */
  getCell(row, column) {
    const { startRow, startColumn } = this._range;
    const cell = {
      startRow: startRow + row,
      endRow: startRow + row,
      startColumn: startColumn + column,
      endColumn: startColumn + column
    };
    return new _Range(this._worksheet, cell, this._deps);
  }
  /**
   * Returns the starting column position for this range
   *
   * @returns  — The range's starting column position in the spreadsheet.
   */
  getColumn() {
    return this._range.startColumn;
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   */
  getObjectValue(options = {}) {
    return this.getObjectValues(options)[0][0];
  }
  /**
   * Returns the data of the object structure, and can set whether to bring styles
   *
   * @param options set whether to include style
   * @returns Returns a value in object format
   */
  getObjectValues(options = {}) {
    var _a2;
    const { startRow, endRow, startColumn, endColumn } = this._range;
    const values = this._worksheet.getCellMatrix().getFragment(startRow, endRow, startColumn, endColumn).getData();
    if (options.isIncludeStyle) {
      const style = this._deps.getStyles();
      for (let r = 0; r <= endRow - startRow; r++) {
        for (let c = 0; c <= endColumn - startColumn; c++) {
          if (values == null || ((_a2 = values == null ? void 0 : values[r]) == null ? void 0 : _a2[c]) == null) {
            continue;
          }
          const s = values[r][c].s;
          if (s) {
            values[r][c].s = style.get(s);
          }
        }
      }
    }
    return values;
  }
  /**
   * Returns the font color of the cell in the top-left corner of the range, in CSS notation
   */
  getFontColor() {
    return this.getFontColors()[0][0];
  }
  /**
   * Returns the font colors of the cells in the range in CSS notation (such as '#ffffff' or 'white').
   */
  getFontColors() {
    const styles = this._deps.getStyles();
    return this.getValues().map(
      (row) => row.map((cell) => {
        var _a2;
        const cellStyle = styles.getStyleByCell(cell);
        return ((_a2 = cellStyle == null ? void 0 : cellStyle.cl) == null ? void 0 : _a2.rgb) || DEFAULT_STYLES.cl.rgb;
      })
    );
  }
  /**
   * Returns the font families of the cells in the range.
   */
  getFontFamilies() {
    return this._getStyles("ff");
  }
  /**
   * Returns the font family of the cell in the top-left corner of the range.
   */
  getFontFamily() {
    return this.getFontFamilies()[0][0];
  }
  /**
   * Returns the underlines of the cells in the range.
   */
  getUnderlines() {
    return this._getStyles("ul");
  }
  /**
   * Returns the underline of the cells in the range.
   */
  getUnderline() {
    var _a2, _b2;
    const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
    if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
      return isAllFormatInTextRuns("ul", p.body) === 1 /* TRUE */ ? {
        s: 1 /* TRUE */
      } : {
        s: 0 /* FALSE */
      };
    }
    return this.getUnderlines()[0][0];
  }
  /**
   * Returns the overlines of the cells in the range.
   */
  getOverlines() {
    return this._getStyles("ol");
  }
  /**
   * Returns the overline of the cells in the range.
   */
  getOverline() {
    return this.getOverlines()[0][0];
  }
  /**
   * Returns the strikeThrough of the cells in the range.
   */
  getStrikeThrough() {
    var _a2, _b2;
    const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
    if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
      return isAllFormatInTextRuns("st", p.body) === 1 /* TRUE */ ? {
        s: 1 /* TRUE */
      } : {
        s: 0 /* FALSE */
      };
    }
    return this.getStrikeThroughs()[0][0];
  }
  /**
   * Returns the strikeThroughs of the cells in the range.
   */
  getStrikeThroughs() {
    return this._getStyles("st");
  }
  /**
   * Returns the font size in point size of the cell in the top-left corner of the range.
   */
  getFontSize() {
    var _a2, _b2;
    const p = ((_a2 = this.getValue()) == null ? void 0 : _a2.p) || {};
    if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
      if (p.body.textRuns.some((textRun) => {
        var _a3;
        return ((_a3 = textRun == null ? void 0 : textRun.ts) == null ? void 0 : _a3.fs) != null;
      })) {
        return Math.max(...p.body.textRuns.map((textRun) => {
          var _a3;
          return ((_a3 = textRun == null ? void 0 : textRun.ts) == null ? void 0 : _a3.fs) || 0;
        }));
      } else {
        return this.getFontSizes()[0][0];
      }
    }
    return this.getFontSizes()[0][0];
  }
  /**
   * Returns the font sizes of the cells in the range.
   */
  getFontSizes() {
    return this._getStyles("fs");
  }
  /**
   * Returns the border info of the cells in the range.
   */
  getBorder() {
    return this.getBorders()[0][0];
  }
  getBorders() {
    return this._getStyles("bd");
  }
  /**
   * Returns the font style ('italic' or 'normal') of the cell in the top-left corner of the range.
   */
  getFontStyle() {
    var _a2, _b2;
    const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
    if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
      return isAllFormatInTextRuns("it", p.body) === 1 /* TRUE */ ? 1 /* ITALIC */ : 0 /* NORMAL */;
    }
    return this._getFontStyles()[0][0];
  }
  /**
   * Returns the font styles of the cells in the range.
   */
  _getFontStyles() {
    return this._getStyles("it");
  }
  /**
   * Returns the font weight (normal/bold) of the cell in the top-left corner of the range.
   * If the cell has rich text, the return value according to the textRuns of the rich text,
   * when all styles of textRuns are bold, it will return FontWeight.BOLD,
   * otherwise return FontWeight.NORMAL.
   */
  getFontWeight() {
    var _a2, _b2;
    const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
    if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
      return isAllFormatInTextRuns("bl", p.body) === 1 /* TRUE */ ? 1 /* BOLD */ : 0 /* NORMAL */;
    }
    return this._getFontWeights()[0][0];
  }
  /**
   * Returns the font weights of the cells in the range.
   */
  _getFontWeights() {
    return this._getStyles("bl");
  }
  /**
   * Returns the grid ID of the range's parent sheet.
   */
  getGridId() {
    return this._worksheet.getSheetId();
  }
  /**
   * Returns the height of the range.
   */
  getHeight() {
    const { _range: _rangeData, _worksheet } = this;
    const { startRow, endRow } = _rangeData;
    let h = 0;
    for (let i = 0; i <= endRow - startRow; i++) {
      const hh = _worksheet.getRowHeight(i);
      h += hh;
    }
    return h;
  }
  /**
   *     Returns the horizontal alignment of the text (left/center/right) of the cell in the top-left corner of the range.
   */
  getHorizontalAlignment() {
    return this.getHorizontalAlignments()[0][0];
  }
  /**
   *Returns the horizontal alignments of the cells in the range.
   */
  getHorizontalAlignments() {
    return this._getStyles("ht");
  }
  /**
   * Returns the end column position.
   */
  getLastColumn() {
    return this._range.endColumn;
  }
  /**
   *     Returns the end row position.
   */
  getLastRow() {
    return this._range.endRow;
  }
  /**
   * Returns the number of columns in this range.
   */
  getNumColumns() {
    const { startColumn, endColumn } = this._range;
    return endColumn - startColumn + 1;
  }
  /**
   * Returns the number of rows in this range.
   */
  getNumRows() {
    const { startRow, endRow } = this._range;
    return endRow - startRow + 1;
  }
  /**
   * Returns the Rich Text value for the top left cell of the range, or null if the cell value is not text.
   */
  getRichTextValue() {
    return this.getRichTextValues()[0][0];
  }
  /**
   * Returns the Rich Text values for the cells in the range.
   */
  getRichTextValues() {
    return this.getValues().map((row) => row.map((cell) => (cell == null ? void 0 : cell.p) || ""));
  }
  /**
   * Returns the row position for this range.
   */
  getRowIndex() {
    return this._range.startRow;
  }
  /**
   * Returns the sheet this range belongs to.
   */
  getSheet() {
    return this._worksheet;
  }
  /**
   * Returns the text direction for the top left cell of the range.
   */
  getTextDirection() {
    return this.getTextDirections()[0][0];
  }
  /**
   * Returns the text directions for the cells in the range.
   */
  getTextDirections() {
    return this._getStyles("td");
  }
  /**
   * Returns the text rotation settings for the top left cell of the range.
   */
  // getTextRotation(): number {
  getTextRotation() {
    return this.getTextRotations()[0][0];
  }
  /**
   * Returns the text rotation settings for the cells in the range.
   */
  // getTextRotations(): number[][] {
  getTextRotations() {
    return this._getStyles("tr");
  }
  /**
   *     Returns the text style for the top left cell of the range.
   */
  getTextStyle() {
    return this.getTextStyles()[0][0];
  }
  /**
   * Returns the text styles for the cells in the range.
   */
  getTextStyles() {
    const styles = this._deps.getStyles();
    return this.getValues().map((row) => row.map((cell) => styles.getStyleByCell(cell)));
  }
  /**
   * Returns the vertical alignment (top/middle/bottom) of the cell in the top-left corner of the range.
   */
  getVerticalAlignment() {
    return this.getVerticalAlignments()[0][0];
  }
  /**
   * Returns the vertical alignments of the cells in the range.
   */
  getVerticalAlignments() {
    return this._getStyles("vt");
  }
  /**
   * Returns the width of the range in columns.
   */
  getWidth() {
    const { _range: _rangeData, _worksheet } = this;
    const { startColumn, endColumn } = _rangeData;
    let w = 0;
    for (let i = 0; i <= endColumn - startColumn; i++) {
      w += _worksheet.getColumnWidth(i);
    }
    return w;
  }
  /**
   * Returns whether the text in the cell wraps.
   */
  getWrap() {
    return this.getWrapStrategy() === 3 /* WRAP */ ? 1 /* TRUE */ : 0 /* FALSE */;
  }
  /**
   * Returns the text wrapping strategies for the cells in the range.
   */
  getWrapStrategies() {
    return this._getStyles("tb");
  }
  /**
   * Returns the text wrapping strategy for the top left cell of the range.
   */
  getWrapStrategy() {
    return this.getWrapStrategies()[0][0];
  }
  forEach(action) {
    _Range.foreach(this._range, action);
  }
  /**
   *
   * @param arg Shorthand for the style that gets
   * @returns style value
   */
  _getStyles(styleKey) {
    const styles = this._deps.getStyles();
    return this.getValues().map(
      (row) => row.map((cell) => {
        const style = styles && styles.getStyleByCell(cell);
        return style && style[styleKey] || DEFAULT_STYLES[styleKey];
      })
    );
  }
};
__publicField(_Range, "transformRange", (range, worksheet) => {
  const maxColumns = worksheet.getMaxColumns() - 1;
  const maxRows = worksheet.getMaxRows() - 1;
  if (range.rangeType === 3 /* ALL */) {
    return {
      startColumn: 0,
      startRow: 0,
      endColumn: maxColumns,
      endRow: maxRows
    };
  }
  if (range.rangeType === 2 /* COLUMN */) {
    return {
      startRow: 0,
      endRow: maxRows,
      startColumn: range.startColumn,
      endColumn: range.endColumn
    };
  }
  if (range.rangeType === 1 /* ROW */) {
    return {
      startColumn: 0,
      endColumn: maxColumns,
      startRow: range.startRow,
      endRow: range.endRow
    };
  }
  return {
    startColumn: range.startColumn,
    endColumn: Math.min(range.endColumn, maxColumns),
    startRow: range.startRow,
    endRow: Math.min(range.endRow, maxRows)
  };
});
var Range = _Range;

// ../node_modules/.pnpm/quickselect@3.0.0/node_modules/quickselect/index.js
function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight, compare);
    }
    const t = arr[k];
    let i = left;
    let j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0) i++;
      while (compare(arr[j], t) > 0) j--;
    }
    if (compare(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : 0;
}

// ../node_modules/.pnpm/rbush@4.0.1/node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox, node)) return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf) result.push(child);
          else if (contains(bbox, childBBox)) this._all(child, result);
          else nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects(bbox, node)) return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length)) return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item) return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a2, b) {
    return a2.minX - b.minX;
  }
  compareMinY(a2, b) {
    return a2.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf) result.push(...node.children);
      else nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N2 = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N2 <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N2) / Math.log(M));
      M = Math.ceil(N2 / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N22 = Math.ceil(N2 / M);
    const N1 = N22 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N22, this.compareMinY);
      for (let j = i; j <= right2; j += N22) {
        const right3 = Math.min(j + N22 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level) break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode2) {
    const bbox = isNode2 ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level) insertPath[level - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin) node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level) {
    for (let i = level; i >= 0; i--) {
      extend(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a2, b) {
  a2.minX = Math.min(a2.minX, b.minX);
  a2.minY = Math.min(a2.minY, b.minY);
  a2.maxX = Math.max(a2.maxX, b.maxX);
  a2.maxY = Math.max(a2.maxY, b.maxY);
  return a2;
}
function compareNodeMinX(a2, b) {
  return a2.minX - b.minX;
}
function compareNodeMinY(a2, b) {
  return a2.minY - b.minY;
}
function bboxArea(a2) {
  return (a2.maxX - a2.minX) * (a2.maxY - a2.minY);
}
function bboxMargin(a2) {
  return a2.maxX - a2.minX + (a2.maxY - a2.minY);
}
function enlargedArea(a2, b) {
  return (Math.max(b.maxX, a2.maxX) - Math.min(b.minX, a2.minX)) * (Math.max(b.maxY, a2.maxY) - Math.min(b.minY, a2.minY));
}
function intersectionArea(a2, b) {
  const minX = Math.max(a2.minX, b.minX);
  const minY = Math.max(a2.minY, b.minY);
  const maxX = Math.min(a2.maxX, b.maxX);
  const maxY = Math.min(a2.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a2, b) {
  return a2.minX <= b.minX && a2.minY <= b.minY && b.maxX <= a2.maxX && b.maxY <= a2.maxY;
}
function intersects(a2, b) {
  return b.minX <= a2.maxX && b.minY <= a2.maxY && b.maxX >= a2.minX && b.maxY >= a2.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

// ../packages/core/src/shared/range.ts
function moveRangeByOffset(range, refOffsetX, refOffsetY, ignoreAbsolute = false) {
  if (refOffsetX === 0 && refOffsetY === 0) {
    return range;
  }
  let newRange = { ...range };
  const startAbsoluteRefType = newRange.startAbsoluteRefType || 0 /* NONE */;
  const endAbsoluteRefType = newRange.endAbsoluteRefType || 0 /* NONE */;
  const rangeType = newRange.rangeType || 0 /* NORMAL */;
  if (!ignoreAbsolute && startAbsoluteRefType === 3 /* ALL */ && endAbsoluteRefType === 3 /* ALL */) {
    return newRange;
  }
  const start = moveRangeByRangeType(newRange.startRow, refOffsetY, newRange.startColumn, refOffsetX, rangeType);
  const end = moveRangeByRangeType(newRange.endRow, refOffsetY, newRange.endColumn, refOffsetX, rangeType);
  if (ignoreAbsolute || startAbsoluteRefType === 0 /* NONE */ && endAbsoluteRefType === 0 /* NONE */) {
    return newRange = {
      ...newRange,
      startRow: start.row,
      startColumn: start.column,
      endRow: end.row,
      endColumn: end.column
    };
  }
  if (startAbsoluteRefType === 0 /* NONE */) {
    newRange = { ...newRange, startRow: start.row, startColumn: start.column };
  } else if (startAbsoluteRefType === 2 /* COLUMN */) {
    newRange = { ...newRange, startRow: start.row };
  } else if (startAbsoluteRefType === 1 /* ROW */) {
    newRange = { ...newRange, startColumn: start.column };
  }
  if (endAbsoluteRefType === 0 /* NONE */) {
    newRange = { ...newRange, endRow: end.row, endColumn: end.column };
  } else if (endAbsoluteRefType === 2 /* COLUMN */) {
    newRange = { ...newRange, endRow: end.row };
  } else if (endAbsoluteRefType === 1 /* ROW */) {
    newRange = { ...newRange, endColumn: end.column };
  }
  return newRange;
}
function moveRangeByRangeType(row, rowOffset, column, columnOffset, rangeType) {
  if (rangeType === 0 /* NORMAL */) {
    return { row: row + rowOffset, column: column + columnOffset };
  } else if (rangeType === 1 /* ROW */) {
    return { row: row + rowOffset, column };
  } else if (rangeType === 2 /* COLUMN */) {
    return { row, column: column + columnOffset };
  } else {
    return { row, column };
  }
}
function splitIntoGrid(ranges) {
  const columns = /* @__PURE__ */ new Set();
  const rows = /* @__PURE__ */ new Set();
  for (const range of ranges) {
    columns.add(range.startColumn);
    columns.add(range.endColumn + 1);
    rows.add(range.startRow);
    rows.add(range.endRow + 1);
  }
  const sortedColumns = Array.from(columns).sort((a2, b) => a2 - b);
  const sortedRows = Array.from(rows).sort((a2, b) => a2 - b);
  ranges.sort((a2, b) => a2.startRow - b.startRow || a2.startColumn - b.startColumn);
  const result = [];
  for (let i = 0; i < sortedRows.length - 1; i++) {
    for (let j = 0; j < sortedColumns.length - 1; j++) {
      const startColumn = sortedColumns[j];
      const endColumn = sortedColumns[j + 1] - 1;
      const startRow = sortedRows[i];
      const endRow = sortedRows[i + 1] - 1;
      for (const range of ranges) {
        if (range.startRow > endRow) {
          break;
        }
        if (range.startRow <= startRow && range.endRow >= endRow && range.startColumn <= startColumn && range.endColumn >= endColumn) {
          result.push({
            startColumn,
            endColumn,
            startRow,
            endRow
          });
          break;
        }
      }
    }
  }
  return result;
}
function mergeHorizontalRanges(ranges) {
  ranges.sort((a2, b) => a2.startRow - b.startRow || a2.startColumn - b.startColumn);
  const rowGroups = {};
  for (const range of ranges) {
    if (!rowGroups[range.startRow]) {
      rowGroups[range.startRow] = [];
    }
    rowGroups[range.startRow].push(range);
  }
  const mergedRanges = [];
  for (const row in rowGroups) {
    const rangesInRow = rowGroups[+row];
    rangesInRow.sort((a2, b) => a2.startColumn - b.startColumn);
    let currentRange = rangesInRow[0];
    for (let i = 1; i < rangesInRow.length; i++) {
      const nextRange = rangesInRow[i];
      if (nextRange.startColumn <= currentRange.endColumn + 1 && nextRange.startRow === currentRange.startRow && nextRange.endRow === currentRange.endRow) {
        currentRange.endColumn = Math.max(currentRange.endColumn, nextRange.endColumn);
      } else {
        mergedRanges.push(currentRange);
        currentRange = nextRange;
      }
    }
    mergedRanges.push(currentRange);
  }
  return mergedRanges;
}
function mergeVerticalRanges(ranges) {
  ranges.sort((a2, b) => a2.startColumn - b.startColumn || a2.startRow - b.startRow);
  const columnGroups = {};
  for (const range of ranges) {
    if (!columnGroups[range.startColumn]) {
      columnGroups[range.startColumn] = [];
    }
    columnGroups[range.startColumn].push(range);
  }
  const mergedRanges = [];
  for (const col in columnGroups) {
    const rangesInCol = columnGroups[+col];
    rangesInCol.sort((a2, b) => a2.startRow - b.startRow);
    let currentRange = rangesInCol[0];
    for (let i = 1; i < rangesInCol.length; i++) {
      const nextRange = rangesInCol[i];
      if (nextRange.startRow <= currentRange.endRow + 1 && nextRange.startColumn === currentRange.startColumn && nextRange.endColumn === currentRange.endColumn) {
        currentRange.endRow = Math.max(currentRange.endRow, nextRange.endRow);
      } else {
        mergedRanges.push(currentRange);
        currentRange = nextRange;
      }
    }
    mergedRanges.push(currentRange);
  }
  return mergedRanges;
}
function mergeRanges(ranges) {
  const split = splitIntoGrid(ranges);
  const horizontalMerged = mergeHorizontalRanges(split);
  return mergeVerticalRanges(horizontalMerged);
}
function multiSubtractSingleRange(ranges, toDelete) {
  const res = [];
  ranges.forEach((range) => {
    res.push(...Rectangle.subtract(range, toDelete));
  });
  return Rectangle.mergeRanges(res);
}
function getIntersectRange(src, target) {
  const rowOverlap = getOverlap1D(
    src.startRow,
    src.endRow,
    target.startRow,
    target.endRow
  );
  const colOverlap = getOverlap1D(
    src.startColumn,
    src.endColumn,
    target.startColumn,
    target.endColumn
  );
  if (!rowOverlap || !colOverlap) {
    return null;
  }
  const [startRow, endRow] = rowOverlap;
  const [startColumn, endColumn] = colOverlap;
  const rangeType = determineRangeType(
    src.rangeType,
    target.rangeType,
    startRow,
    endRow,
    startColumn,
    endColumn
  );
  return {
    startRow,
    endRow,
    startColumn,
    endColumn,
    rangeType
  };
}
function getOverlap1D(start1, end1, start2, end2) {
  const s1 = isNaN(start1) ? -Infinity : start1;
  const e1 = isNaN(end1) ? Infinity : end1;
  const s2 = isNaN(start2) ? -Infinity : start2;
  const e2 = isNaN(end2) ? Infinity : end2;
  const start = Math.max(s1, s2);
  const end = Math.min(e1, e2);
  if (start <= end) {
    const resultStart = start === -Infinity ? Number.NaN : start;
    const resultEnd = end === Infinity ? Number.NaN : end;
    return [resultStart, resultEnd];
  } else {
    return null;
  }
}
function determineRangeType(srcType, targetType, startRow, endRow, startColumn, endColumn) {
  const resolvedSrcType = srcType !== void 0 ? srcType : inferRangeType(startRow, endRow, startColumn, endColumn);
  const resolvedTargetType = targetType !== void 0 ? targetType : inferRangeType(startRow, endRow, startColumn, endColumn);
  if (resolvedSrcType === 3 /* ALL */ || resolvedTargetType === 3 /* ALL */) {
    if (resolvedSrcType === resolvedTargetType) {
      return resolvedSrcType;
    }
    return resolvedSrcType === 3 /* ALL */ ? resolvedTargetType : resolvedSrcType;
  } else if (resolvedSrcType === resolvedTargetType) {
    return resolvedSrcType;
  } else if (resolvedSrcType === 0 /* NORMAL */ || resolvedTargetType === 0 /* NORMAL */) {
    return 0 /* NORMAL */;
  } else {
    return 0 /* NORMAL */;
  }
}
function inferRangeType(startRow, endRow, startColumn, endColumn) {
  const hasRow = !isNaN(startRow) && !isNaN(endRow);
  const hasColumn = !isNaN(startColumn) && !isNaN(endColumn);
  if (hasRow && hasColumn) {
    return 0 /* NORMAL */;
  } else if (hasRow) {
    return 1 /* ROW */;
  } else if (hasColumn) {
    return 2 /* COLUMN */;
  } else {
    return 3 /* ALL */;
  }
}

// ../packages/core/src/shared/rectangle.ts
var _Rectangle = class _Rectangle {
  /**
   * Creates a deep copy of an IRange object
   * @param src
   * @example
   * ```typescript
   * const original = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const copy = Rectangle.clone(original);
   * // copy = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ```
   */
  static clone(src) {
    if (src.rangeType !== void 0) {
      return {
        startRow: src.startRow,
        startColumn: src.startColumn,
        endRow: src.endRow,
        endColumn: src.endColumn,
        rangeType: src.rangeType
      };
    }
    return {
      startRow: src.startRow,
      startColumn: src.startColumn,
      endRow: src.endRow,
      endColumn: src.endColumn
    };
  }
  /**
   * Checks if two ranges are equal by comparing their properties
   * @param src
   * @param target
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const areEqual = Rectangle.equals(range1, range2); // true
   * ```
   */
  static equals(src, target) {
    if (src == null || target == null) {
      return false;
    }
    return src.endRow === target.endRow && src.endColumn === target.endColumn && src.startRow === target.startRow && src.startColumn === target.startColumn && (src.rangeType === target.rangeType || src.rangeType === void 0 && target.rangeType === 0 /* NORMAL */ || target.rangeType === void 0 && src.rangeType === 0 /* NORMAL */);
  }
  /**
   * Quickly checks if two normal ranges intersect. For specialized range types,
   * use the intersects() method instead.
   * @param rangeA
   * @param rangeB
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const doIntersect = Rectangle.simpleRangesIntersect(range1, range2); // true
   * ```
   */
  static simpleRangesIntersect(rangeA, rangeB) {
    const { startRow: startRowA, endRow: endRowA, startColumn: startColumnA, endColumn: endColumnA } = rangeA;
    const { startRow: startRowB, endRow: endRowB, startColumn: startColumnB, endColumn: endColumnB } = rangeB;
    const rowsOverlap = startRowA <= endRowB && endRowA >= startRowB;
    const columnsOverlap = startColumnA <= endColumnB && endColumnA >= startColumnB;
    return rowsOverlap && columnsOverlap;
  }
  /**
   * Checks if two ranges intersect, handling special range types (ROW, COLUMN)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   startColumn: NaN, endColumn: NaN,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const colRange = {
   *   startRow: NaN, endRow: NaN,
   *   startColumn: 0, endColumn: 2,
   *   rangeType: RANGE_TYPE.COLUMN
   * };
   * const doIntersect = Rectangle.intersects(rowRange, colRange); // true
   * ```
   */
  static intersects(src, target) {
    if (src.rangeType === 1 /* ROW */ && target.rangeType === 2 /* COLUMN */) {
      return true;
    }
    if (src.rangeType === 2 /* COLUMN */ && target.rangeType === 1 /* ROW */) {
      return true;
    }
    if (src.rangeType === 1 /* ROW */ && target.rangeType === 1 /* ROW */) {
      return src.startRow <= target.endRow && src.endRow >= target.startRow;
    }
    if (src.rangeType === 2 /* COLUMN */ && target.rangeType === 2 /* COLUMN */) {
      return src.startColumn <= target.endColumn && src.endColumn >= target.startColumn;
    }
    const MAX = Math.floor(Number.MAX_SAFE_INTEGER / 10);
    const currentStartRow = Number.isNaN(src.startRow) ? 0 : src.startRow;
    const currentEndRow = Number.isNaN(src.endRow) ? MAX : src.endRow;
    const currentStartColumn = Number.isNaN(src.startColumn) ? 0 : src.startColumn;
    const currentEndColumn = Number.isNaN(src.endColumn) ? MAX : src.endColumn;
    const incomingStartRow = Number.isNaN(target.startRow) ? 0 : target.startRow;
    const incomingEndRow = Number.isNaN(target.endRow) ? MAX : target.endRow;
    const incomingStartColumn = Number.isNaN(target.startColumn) ? 0 : target.startColumn;
    const incomingEndColumn = Number.isNaN(target.endColumn) ? MAX : target.endColumn;
    const zx = Math.abs(currentStartColumn + currentEndColumn - incomingStartColumn - incomingEndColumn);
    const x = Math.abs(currentStartColumn - currentEndColumn) + Math.abs(incomingStartColumn - incomingEndColumn);
    const zy = Math.abs(currentStartRow + currentEndRow - incomingStartRow - incomingEndRow);
    const y = Math.abs(currentStartRow - currentEndRow) + Math.abs(incomingStartRow - incomingEndRow);
    return zx <= x && zy <= y;
  }
  /**
   * Checks if any of the ranges in the target array intersect with any of the ranges in the source array.
   * Attention! Please make sure there is no NaN in the ranges.
   * @param src
   * @param target
   * @example
   * ```typescript
   * const ranges1 = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 3, startColumn: 3, endRow: 5, endColumn: 5 }
   * ];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 4, endColumn: 4 },
   *   { startRow: 6, startColumn: 6, endRow: 8, endColumn: 8 }
   * ];
   * const doIntersect = Rectangle.doAnyRangesIntersect(ranges1, ranges2); // true
   * ```
   */
  static doAnyRangesIntersect(src, target) {
    const rbush = new RBush();
    rbush.load(src.map((r) => ({ minX: r.startColumn, minY: r.startRow, maxX: r.endColumn, maxY: r.endRow })));
    return target.some((r) => rbush.search({ minX: r.startColumn, minY: r.startRow, maxX: r.endColumn, maxY: r.endRow }).length > 0);
  }
  /**
   * Gets the intersection range between two ranges
   * @param src
   * @param target
   * @deprecated use `getIntersectRange` instead
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 };
   * const intersection = Rectangle.getIntersects(range1, range2);
   * // intersection = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ```
   */
  static getIntersects(src, target) {
    const currentStartRow = src.startRow;
    const currentEndRow = src.endRow;
    const currentStartColumn = src.startColumn;
    const currentEndColumn = src.endColumn;
    const incomingStartRow = target.startRow;
    const incomingEndRow = target.endRow;
    const incomingStartColumn = target.startColumn;
    const incomingEndColumn = target.endColumn;
    let startColumn;
    let startRow;
    let endColumn;
    let endRow;
    if (incomingStartRow <= currentEndRow) {
      if (incomingStartRow >= currentStartRow) {
        startRow = incomingStartRow;
      } else {
        startRow = currentStartRow;
      }
    } else {
      return null;
    }
    if (incomingEndRow >= currentStartRow) {
      if (incomingEndRow >= currentEndRow) {
        endRow = currentEndRow;
      } else {
        endRow = incomingEndRow;
      }
    } else {
      return null;
    }
    if (incomingStartColumn <= currentEndColumn) {
      if (incomingStartColumn > currentStartColumn) {
        startColumn = incomingStartColumn;
      } else {
        startColumn = currentStartColumn;
      }
    } else {
      return null;
    }
    if (incomingEndColumn >= currentStartColumn) {
      if (incomingEndColumn >= currentEndColumn) {
        endColumn = currentEndColumn;
      } else {
        endColumn = incomingEndColumn;
      }
    } else {
      return null;
    }
    return {
      startRow,
      endRow,
      startColumn,
      endColumn,
      rangeType: 0 /* NORMAL */
      // TODO: this may not be accurate
    };
  }
  /**
   * Checks if one range completely contains another range
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const inner = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const contains = Rectangle.contains(outer, inner); // true
   * ```
   */
  static contains(src, target) {
    return src.startRow <= target.startRow && src.endRow >= target.endRow && src.startColumn <= target.startColumn && src.endColumn >= target.endColumn;
  }
  /**
   * Checks if one range strictly contains another range (not equal)
   * @param src
   * @param target
   * @example
   * ```typescript
   * const outer = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const same = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const realContains = Rectangle.realContain(outer, same); // false
   * ```
   */
  static realContain(src, target) {
    return _Rectangle.contains(src, target) && (src.startRow < target.startRow || src.endRow > target.endRow || src.startColumn < target.startColumn || src.endColumn > target.endColumn);
  }
  /**
   * Creates a union range that encompasses all input ranges
   * @param {...any} ranges
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
   * const range2 = { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 };
   * const union = Rectangle.union(range1, range2);
   * // union = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }
   * ```
   */
  static union(...ranges) {
    return ranges.reduce(
      (acc, current) => ({
        startRow: Math.min(acc.startRow, current.startRow),
        startColumn: Math.min(acc.startColumn, current.startColumn),
        endRow: Math.max(acc.endRow, current.endRow),
        endColumn: Math.max(acc.endColumn, current.endColumn),
        rangeType: 0 /* NORMAL */
      }),
      ranges[0]
    );
  }
  /**
   * Creates a union range considering special range types (ROW, COLUMN)
   * @param {...any} ranges
   * @example
   * ```typescript
   * const rowRange = {
   *   startRow: 0, endRow: 2,
   *   rangeType: RANGE_TYPE.ROW
   * };
   * const normalRange = {
   *   startRow: 1, startColumn: 1,
   *   endRow: 3, endColumn: 3
   * };
   * const union = Rectangle.realUnion(rowRange, normalRange);
   * // Result will have NaN for columns due to ROW type
   * ```
   */
  static realUnion(...ranges) {
    const hasColRange = ranges.some((range) => range.rangeType === 2 /* COLUMN */);
    const hasRowRange = ranges.some((range) => range.rangeType === 1 /* ROW */);
    const res = _Rectangle.union(...ranges);
    return {
      startColumn: hasRowRange ? Number.NaN : res.startColumn,
      endColumn: hasRowRange ? Number.NaN : res.endColumn,
      startRow: hasColRange ? Number.NaN : res.startRow,
      endRow: hasColRange ? Number.NaN : res.endRow,
      rangeType: hasRowRange ? 1 /* ROW */ : hasColRange ? 2 /* COLUMN */ : 0 /* NORMAL */
    };
  }
  /**
   * Subtracts one range from another, returning the remaining areas as separate ranges
   * @param range1
   * @param range2
   * @example
   * ```typescript
   * const range1 = { startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 };
   * const range2 = { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 };
   * const result = Rectangle.subtract(range1, range2);
   * // Results in up to 4 ranges representing the non-overlapping areas
   * ```
   */
  static subtract(range1, range2) {
    if (range2.startRow > range1.endRow || range2.endRow < range1.startRow || range2.startColumn > range1.endColumn || range2.endColumn < range1.startColumn) {
      return [range1];
    }
    const ranges = [];
    if (range2.startRow >= range1.startRow) {
      ranges.push({
        startRow: range1.startRow,
        startColumn: range1.startColumn,
        endRow: range2.startRow - 1,
        endColumn: range1.endColumn
      });
    }
    if (range2.endRow <= range1.endRow) {
      ranges.push({
        startRow: range2.endRow + 1,
        startColumn: range1.startColumn,
        endRow: range1.endRow,
        endColumn: range1.endColumn
      });
    }
    const topBoundary = Math.max(range1.startRow, range2.startRow);
    const bottomBoundary = Math.min(range1.endRow, range2.endRow);
    if (range2.startColumn >= range1.startColumn) {
      ranges.push({
        startRow: topBoundary,
        startColumn: range1.startColumn,
        endRow: bottomBoundary,
        endColumn: range2.startColumn - 1
      });
    }
    if (range2.endColumn <= range1.endColumn) {
      ranges.push({
        startRow: topBoundary,
        startColumn: range2.endColumn + 1,
        endRow: bottomBoundary,
        endColumn: range1.endColumn
      });
    }
    const result = ranges.filter((range) => range.startRow <= range.endRow && range.startColumn <= range.endColumn);
    return result;
  }
  /**
   * Merges overlapping or adjacent ranges into larger ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 },
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 }
   * ];
   * const merged = Rectangle.mergeRanges(ranges);
   * // Combines overlapping ranges into larger ones
   * ```
   */
  static mergeRanges(ranges) {
    return mergeRanges(ranges);
  }
  /**
   * Splits overlapping ranges into a grid of non-overlapping ranges
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 0, startColumn: 0, endRow: 2, endColumn: 2 },
   *   { startRow: 1, startColumn: 1, endRow: 3, endColumn: 3 }
   * ];
   * const grid = Rectangle.splitIntoGrid(ranges);
   * // Splits into non-overlapping grid sections
   * ```
   */
  static splitIntoGrid(ranges) {
    return splitIntoGrid(ranges);
  }
  /**
   * Subtracts multiple ranges from multiple ranges
   * @param ranges1
   * @param ranges2
   * @example
   * ```typescript
   * const ranges1 = [{ startRow: 0, startColumn: 0, endRow: 3, endColumn: 3 }];
   * const ranges2 = [
   *   { startRow: 1, startColumn: 1, endRow: 2, endColumn: 2 },
   *   { startRow: 2, startColumn: 2, endRow: 3, endColumn: 3 }
   * ];
   * const result = Rectangle.subtractMulti(ranges1, ranges2);
   * // Returns remaining non-overlapping areas
   * ```
   */
  static subtractMulti(ranges1, ranges2) {
    if (!ranges2.length) {
      return ranges1;
    }
    let res = ranges1;
    ranges2.forEach((range) => {
      res = multiSubtractSingleRange(res, range);
    });
    return res;
  }
  /**
   * Checks if two rectangles defined by left, top, right, bottom coordinates intersect
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersects = Rectangle.hasIntersectionBetweenTwoRect(rect1, rect2); // true
   * ```
   */
  static hasIntersectionBetweenTwoRect(rect1, rect2) {
    if (rect1.left > rect2.right || // rect1 在 rect2 右侧
    rect1.right < rect2.left || // rect1 在 rect2 左侧
    rect1.top > rect2.bottom || // rect1 在 rect2 下方
    rect1.bottom < rect2.top) {
      return false;
    }
    return true;
  }
  /**
   * Gets the intersection area between two rectangles defined by LTRB coordinates
   * @param rect1
   * @param rect2
   * @example
   * ```typescript
   * const rect1 = { left: 0, top: 0, right: 10, bottom: 10 };
   * const rect2 = { left: 5, top: 5, right: 15, bottom: 15 };
   * const intersection = Rectangle.getIntersectionBetweenTwoRect(rect1, rect2);
   * // Returns { left: 5, top: 5, right: 10, bottom: 10, width: 5, height: 5 }
   * ```
   */
  static getIntersectionBetweenTwoRect(rect1, rect2) {
    const left = Math.max(rect1.left, rect2.left);
    const right = Math.min(rect1.right, rect2.right);
    const top = Math.max(rect1.top, rect2.top);
    const bottom = Math.min(rect1.bottom, rect2.bottom);
    if (right <= left || bottom <= top) {
      return null;
    }
    return {
      left,
      right,
      top,
      bottom,
      width: right - left,
      height: bottom - top
    };
  }
  /**
   * Sorts an array of ranges by startRow, then by startColumn
   * @param ranges
   * @example
   * ```typescript
   * const ranges = [
   *   { startRow: 1, startColumn: 0, endRow: 2, endColumn: 1 },
   *   { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 }
   * ];
   * const sorted = Rectangle.sort(ranges);
   * // Ranges will be sorted by startRow first, then startColumn
   * ```
   */
  static sort(ranges) {
    return ranges.sort((a2, b) => a2.startRow - b.startRow || a2.startColumn - b.startColumn);
  }
};
/**
 * Converts an absolute range to a relative range based on an origin range
 * @param range
 * @param originRange
 * @example
 * ```typescript
 * const range = { startRow: 5, startColumn: 5, endRow: 7, endColumn: 7 };
 * const origin = { startRow: 3, startColumn: 3, endRow: 8, endColumn: 8 };
 * const relative = Rectangle.getRelativeRange(range, origin);
 * // relative = { startRow: 2, startColumn: 2, endRow: 2, endColumn: 2 }
 * ```
 */
__publicField(_Rectangle, "getRelativeRange", (range, originRange) => ({
  startRow: range.startRow - originRange.startRow,
  endRow: range.endRow - range.startRow,
  startColumn: range.startColumn - originRange.startColumn,
  endColumn: range.endColumn - range.startColumn
}));
/**
 * Converts a relative range back to an absolute range based on origin
 * @param relativeRange
 * @param originRange
 * @param absoluteRange
 * @example
 * ```typescript
 * const relative = { startRow: 2, startColumn: 2, endRow: 2, endColumn: 2 };
 * const origin = { startRow: 3, startColumn: 3, endRow: 8, endColumn: 8 };
 * const absolute = Rectangle.getPositionRange(relative, origin);
 * // absolute = { startRow: 5, startColumn: 5, endRow: 7, endColumn: 7 }
 * ```
 */
__publicField(_Rectangle, "getPositionRange", (relativeRange, originRange, absoluteRange) => ({
  ...absoluteRange || {},
  startRow: absoluteRange ? [1 /* ROW */, 3 /* ALL */].includes(absoluteRange.startAbsoluteRefType || 0) ? absoluteRange.startRow : relativeRange.startRow + originRange.startRow : relativeRange.startRow + originRange.startRow,
  endRow: absoluteRange ? [1 /* ROW */, 3 /* ALL */].includes(absoluteRange.endAbsoluteRefType || 0) ? absoluteRange.endRow : relativeRange.endRow + relativeRange.startRow + originRange.startRow : relativeRange.endRow + relativeRange.startRow + originRange.startRow,
  startColumn: absoluteRange ? [2 /* COLUMN */, 3 /* ALL */].includes(absoluteRange.startAbsoluteRefType || 0) ? absoluteRange.startColumn : relativeRange.startColumn + originRange.startColumn : relativeRange.startColumn + originRange.startColumn,
  endColumn: absoluteRange ? [2 /* COLUMN */, 3 /* ALL */].includes(absoluteRange.endAbsoluteRefType || 0) ? absoluteRange.endColumn : relativeRange.endColumn + relativeRange.startColumn + originRange.startColumn : relativeRange.endColumn + relativeRange.startColumn + originRange.startColumn
}));
/**
 * Moves a range horizontally by a specified step and optionally extends it
 * @param range
 * @param step
 * @param length
 * @example
 * ```typescript
 * const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
 * const moved = Rectangle.moveHorizontal(range, 2, 1);
 * // moved = { startRow: 0, startColumn: 2, endRow: 1, endColumn: 4 }
 * ```
 */
__publicField(_Rectangle, "moveHorizontal", (range, step = 0, length = 0) => ({
  ...range,
  startColumn: range.startColumn + step,
  endColumn: range.endColumn + step + length
}));
/**
 * Moves a range vertically by a specified step and optionally extends it
 * @param range
 * @param step
 * @param length
 * @example
 * ```typescript
 * const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
 * const moved = Rectangle.moveVertical(range, 2, 1);
 * // moved = { startRow: 2, startColumn: 0, endRow: 4, endColumn: 1 }
 * ```
 */
__publicField(_Rectangle, "moveVertical", (range, step = 0, length = 0) => ({
  ...range,
  startRow: range.startRow + step,
  endRow: range.endRow + step + length
}));
/**
 * Moves a range by specified offsets in both directions
 * @param range
 * @param offsetX
 * @param offsetY
 * @example
 * ```typescript
 * const range = { startRow: 0, startColumn: 0, endRow: 1, endColumn: 1 };
 * const moved = Rectangle.moveOffset(range, 2, 3);
 * // moved = { startRow: 3, startColumn: 2, endRow: 4, endColumn: 3 }
 * ```
 */
__publicField(_Rectangle, "moveOffset", (range, offsetX, offsetY) => ({
  ...range,
  startRow: range.startRow + offsetY,
  endRow: range.endRow + offsetY,
  startColumn: range.startColumn + offsetX,
  endColumn: range.endColumn + offsetX
}));
var Rectangle = _Rectangle;

// ../packages/core/src/shared/row-col-iter.ts
function createRowColIter(rowStart, rowEnd, colStart, colEnd) {
  return {
    forEach(cb) {
      for (let r = rowStart; r <= rowEnd; r++) {
        for (let c = colStart; c <= colEnd; c++) {
          cb(r, c);
        }
      }
    }
  };
}

// ../packages/core/src/shared/sequence.ts
var orderA = "A".charCodeAt(0);
var orderZ = "Z".charCodeAt(0);
var order_a = "a".charCodeAt(0);
var order_z = "z".charCodeAt(0);

// ../packages/core/src/shared/sort-rules.ts
function sortRules(oa, ob) {
  if (oa.zIndex > ob.zIndex) {
    return 1;
  }
  if (oa.zIndex === ob.zIndex) {
    return 0;
  }
  return -1;
}
function sortRulesFactory(key = "index", ruler = 1) {
  return (oa, ob) => {
    if (oa[key] > ob[key]) {
      return ruler;
    }
    if (oa[key] === ob[key]) {
      return 0;
    }
    return -ruler;
  };
}

// ../packages/core/src/docs/data-model/types.ts
var DataStreamTreeTokenType = /* @__PURE__ */ ((DataStreamTreeTokenType2) => {
  DataStreamTreeTokenType2["PARAGRAPH"] = "\r";
  DataStreamTreeTokenType2["SECTION_BREAK"] = "\n";
  DataStreamTreeTokenType2["TABLE_START"] = "";
  DataStreamTreeTokenType2["TABLE_ROW_START"] = "\x1B";
  DataStreamTreeTokenType2["TABLE_CELL_START"] = "";
  DataStreamTreeTokenType2["TABLE_CELL_END"] = "";
  DataStreamTreeTokenType2["TABLE_ROW_END"] = "";
  DataStreamTreeTokenType2["TABLE_END"] = "";
  DataStreamTreeTokenType2["CUSTOM_RANGE_START"] = "";
  DataStreamTreeTokenType2["CUSTOM_RANGE_END"] = "";
  DataStreamTreeTokenType2["COLUMN_BREAK"] = "\v";
  DataStreamTreeTokenType2["PAGE_BREAK"] = "\f";
  DataStreamTreeTokenType2["DOCS_END"] = "\0";
  DataStreamTreeTokenType2["TAB"] = "	";
  DataStreamTreeTokenType2["CUSTOM_BLOCK"] = "\b";
  DataStreamTreeTokenType2["LETTER"] = "";
  DataStreamTreeTokenType2["SPACE"] = " ";
  return DataStreamTreeTokenType2;
})(DataStreamTreeTokenType || {});

// ../packages/core/src/docs/data-model/text-x/build-utils/parse.ts
var tags = [
  // DataStreamTreeTokenType.PARAGRAPH, // 段落
  // DataStreamTreeTokenType.SECTION_BREAK, // 章节
  "" /* TABLE_START */,
  // 表格开始
  "\x1B" /* TABLE_ROW_START */,
  // 表格开始
  "" /* TABLE_CELL_START */,
  // 表格开始
  "" /* TABLE_CELL_END */,
  // 表格开始
  "" /* TABLE_ROW_END */,
  // 表格开始
  "" /* TABLE_END */
  // 表格结束
  // DataStreamTreeTokenType.COLUMN_BREAK, // 换列
  // DataStreamTreeTokenType.PAGE_BREAK, // 换页
  // DataStreamTreeTokenType.DOCS_END, // 文档结尾
  // DataStreamTreeTokenType.TAB, // 制表符
  // DataStreamTreeTokenType.CUSTOM_BLOCK, // 图片 mention 等不参与文档流的场景
];
var getPlainText = (dataStream) => {
  const text = dataStream.endsWith("\r\n") ? dataStream.slice(0, -2) : dataStream;
  return tags.reduce((res, curr) => res.replaceAll(curr, ""), text);
};
var isEmptyDocument = (dataStream) => {
  if (!dataStream) {
    return true;
  }
  const text = getPlainText(dataStream).replaceAll("\r", "");
  return text === "";
};
var fromPlainText = (text) => {
  const dataStream = text.replace(/\n/g, "\r");
  const paragraphs = [];
  const customRanges = [];
  let cursor = 0;
  let newDataStream = "";
  const loopParagraph = (i, insertP = true) => {
    const paragraphText = dataStream.slice(cursor, i);
    if (Tools.isLegalUrl(paragraphText)) {
      const id = generateRandomId();
      const urlText = `${paragraphText}`;
      const range = {
        startIndex: cursor,
        endIndex: cursor + urlText.length - 1,
        rangeId: id,
        rangeType: 0 /* HYPERLINK */,
        properties: {
          url: text
        }
      };
      customRanges.push(range);
      newDataStream += urlText;
      cursor = i + 1;
      if (insertP) {
        newDataStream += "\r";
        paragraphs.push({ startIndex: i });
      }
    } else {
      newDataStream += dataStream.slice(cursor, i + 1);
      cursor = i + 1;
      if (insertP) {
        paragraphs.push({ startIndex: i });
      }
    }
  };
  let end = 0;
  for (let i = 0; i < dataStream.length; i++) {
    if (dataStream[i] === "\r") {
      loopParagraph(i);
      end = i;
    }
  }
  if (end !== dataStream.length - 1 || dataStream.length === 1) {
    loopParagraph(dataStream.length, false);
  }
  return {
    dataStream: newDataStream,
    paragraphs,
    customRanges
  };
};

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag2;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_default = isObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag2 = baseGetTag_default(value);
  return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
}
var isFunction_default = isFunction;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type2 = typeof index;
  if (type2 == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type2 == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeysIn.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty6.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty7.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashHas.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty8.call(data, key);
}
var hashHas_default = hashHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getMapData.js
function getMapData(map9, key) {
  var data = map9.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto11 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty9.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// ../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// ../packages/core/src/shared/text-diff.ts
var import_fast_diff = __toESM(require_diff());

// ../packages/core/src/common/boolean.ts
var BooleanStringSet = /* @__PURE__ */ new Set(["true", "false"]);
function isBooleanString(str) {
  return BooleanStringSet.has(str.toLowerCase());
}

// ../packages/core/src/common/equal.ts
function shallowEqual(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (let idx = 0; idx < keysA.length; idx++) {
    const key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    const valueA = objA[key];
    const valueB = objB[key];
    if (valueA !== valueB) {
      return false;
    }
  }
  return true;
}

// ../packages/core/src/docs/data-model/document-data-model.ts
var import_rxjs5 = __toESM(require_cjs());

// ../node_modules/.pnpm/@univerjs+protocol@0.1.44_@grpc+grpc-js@1.10.9_rxjs@7.8.1/node_modules/@univerjs/protocol/lib/es/index.js
var O = /* @__PURE__ */ ((N2) => (N2[N2.UNIVER_UNKNOWN = 0] = "UNIVER_UNKNOWN", N2[N2.UNIVER_DOC = 1] = "UNIVER_DOC", N2[N2.UNIVER_SHEET = 2] = "UNIVER_SHEET", N2[N2.UNIVER_SLIDE = 3] = "UNIVER_SLIDE", N2[N2.UNIVER_PROJECT = 4] = "UNIVER_PROJECT", N2[N2.UNRECOGNIZED = -1] = "UNRECOGNIZED", N2))(O || {});
var D = /* @__PURE__ */ ((N2) => (N2[N2.View = 0] = "View", N2[N2.Edit = 1] = "Edit", N2[N2.ManageCollaborator = 2] = "ManageCollaborator", N2[N2.Print = 3] = "Print", N2[N2.Duplicate = 4] = "Duplicate", N2[N2.Comment = 5] = "Comment", N2[N2.Copy = 6] = "Copy", N2[N2.Share = 7] = "Share", N2[N2.Export = 8] = "Export", N2[N2.MoveWorksheet = 9] = "MoveWorksheet", N2[N2.DeleteWorksheet = 10] = "DeleteWorksheet", N2[N2.HideWorksheet = 11] = "HideWorksheet", N2[N2.RenameWorksheet = 12] = "RenameWorksheet", N2[N2.CreateWorksheet = 13] = "CreateWorksheet", N2[N2.SetWorksheetStyle = 14] = "SetWorksheetStyle", N2[N2.EditWorksheetCell = 15] = "EditWorksheetCell", N2[N2.InsertHyperlink = 16] = "InsertHyperlink", N2[N2.Sort = 17] = "Sort", N2[N2.Filter = 18] = "Filter", N2[N2.PivotTable = 19] = "PivotTable", N2[N2.FloatImg = 20] = "FloatImg", N2[N2.History = 21] = "History", N2[N2.RwHgtClWdt = 22] = "RwHgtClWdt", N2[N2.ViemRwHgtClWdt = 23] = "ViemRwHgtClWdt", N2[N2.ViewFilter = 24] = "ViewFilter", N2[N2.MoveSheet = 25] = "MoveSheet", N2[N2.DeleteSheet = 26] = "DeleteSheet", N2[N2.HideSheet = 27] = "HideSheet", N2[N2.CopySheet = 28] = "CopySheet", N2[N2.RenameSheet = 29] = "RenameSheet", N2[N2.CreateSheet = 30] = "CreateSheet", N2[N2.SelectProtectedCells = 31] = "SelectProtectedCells", N2[N2.SelectUnProtectedCells = 32] = "SelectUnProtectedCells", N2[N2.SetCellStyle = 33] = "SetCellStyle", N2[N2.SetCellValue = 34] = "SetCellValue", N2[N2.SetRowStyle = 35] = "SetRowStyle", N2[N2.SetColumnStyle = 36] = "SetColumnStyle", N2[N2.InsertRow = 37] = "InsertRow", N2[N2.InsertColumn = 38] = "InsertColumn", N2[N2.DeleteRow = 39] = "DeleteRow", N2[N2.DeleteColumn = 40] = "DeleteColumn", N2[N2.EditExtraObject = 41] = "EditExtraObject", N2[N2.Delete = 42] = "Delete", N2[N2.RecoverHistory = 43] = "RecoverHistory", N2[N2.ViewHistory = 44] = "ViewHistory", N2[N2.CreatePermissionObject = 45] = "CreatePermissionObject", N2[N2.UNRECOGNIZED = -1] = "UNRECOGNIZED", N2))(D || {});
var S = /* @__PURE__ */ ((N2) => (N2[N2.Reader = 0] = "Reader", N2[N2.Editor = 1] = "Editor", N2[N2.Owner = 2] = "Owner", N2[N2.UNRECOGNIZED = -1] = "UNRECOGNIZED", N2))(S || {});
var a = /* @__PURE__ */ ((N2) => (N2[N2.Unkonwn = 0] = "Unkonwn", N2[N2.Workbook = 1] = "Workbook", N2[N2.Worksheet = 2] = "Worksheet", N2[N2.SelectRange = 3] = "SelectRange", N2[N2.Document = 4] = "Document", N2[N2.Slide = 5] = "Slide", N2[N2.UNRECOGNIZED = -1] = "UNRECOGNIZED", N2))(a || {});
var G = /* @__PURE__ */ ((N2) => (N2[N2.SomeCollaborator = 0] = "SomeCollaborator", N2[N2.AllCollaborator = 1] = "AllCollaborator", N2[N2.OneSelf = 2] = "OneSelf", N2[N2.UNRECOGNIZED = -1] = "UNRECOGNIZED", N2))(G || {});

// ../packages/core/src/common/unit.ts
var UnitModel = class extends Disposable {
};

// ../packages/core/src/docs/data-model/empty-snapshot.ts
function getEmptySnapshot(unitID = Tools.generateRandomId(6), locale = "enUS" /* EN_US */, title = "") {
  const EMPTY_DOCUMENT_DATA = {
    id: unitID,
    locale,
    title,
    // title should get from request.
    tableSource: {},
    drawings: {},
    drawingsOrder: [],
    headers: {},
    footers: {},
    body: {
      dataStream: "\r\n",
      textRuns: [],
      customBlocks: [],
      tables: [],
      paragraphs: [
        {
          startIndex: 0,
          paragraphStyle: {
            spaceAbove: { v: 5 },
            lineSpacing: 1,
            spaceBelow: { v: 0 }
          }
        }
      ],
      sectionBreaks: [
        {
          startIndex: 1
        }
      ]
    },
    documentStyle: {
      pageSize: {
        width: 595 / 0.75,
        height: 842 / 0.75
      },
      documentFlavor: 1 /* TRADITIONAL */,
      marginTop: 50,
      marginBottom: 50,
      marginRight: 50,
      marginLeft: 50,
      renderConfig: {
        zeroWidthParagraphBreak: 0 /* FALSE */,
        vertexAngle: 0,
        centerAngle: 0,
        background: {
          rgb: "#ccc"
        }
      },
      autoHyphenation: 1 /* TRUE */,
      doNotHyphenateCaps: 0 /* FALSE */,
      consecutiveHyphenLimit: 2,
      defaultHeaderId: "",
      defaultFooterId: "",
      evenPageHeaderId: "",
      evenPageFooterId: "",
      firstPageHeaderId: "",
      firstPageFooterId: "",
      evenAndOddHeaders: 0 /* FALSE */,
      useFirstPageHeaderFooter: 0 /* FALSE */,
      marginHeader: 30,
      marginFooter: 30
    },
    settings: {}
  };
  return EMPTY_DOCUMENT_DATA;
}

// ../packages/core/src/docs/data-model/json-x/json-x.ts
var json1 = __toESM(require_dist2());

// ../packages/core/src/docs/data-model/text-x/apply-utils/common.ts
function normalizeTextRuns(textRuns, reserveEmptyTextRun = false) {
  const results = [];
  for (const textRun of textRuns) {
    const { st, ed, ts } = textRun;
    if (textRun.sId === void 0) {
      delete textRun.sId;
    }
    if (st === ed) {
      continue;
    }
    if (!reserveEmptyTextRun && Tools.isEmptyObject(ts) && textRun.sId == null) {
      continue;
    }
    if (results.length === 0) {
      results.push(textRun);
      continue;
    }
    const peak = results.pop();
    if (isSameStyleTextRun(textRun, peak) && Tools.hasIntersectionBetweenTwoRanges(peak.st, peak.ed, textRun.st, textRun.ed)) {
      results.push({
        ...textRun,
        st: peak.st,
        ed
      });
    } else {
      results.push(peak, textRun);
    }
  }
  return results;
}
function insertTextRuns(body, insertBody, textLength, currentIndex) {
  var _a2;
  const { textRuns } = body;
  if (textRuns == null) {
    return;
  }
  const newTextRuns = [];
  const len = textRuns.length;
  let hasInserted = false;
  const insertTextRuns2 = (_a2 = insertBody.textRuns) != null ? _a2 : [];
  if (insertTextRuns2.length) {
    for (const insertTextRun of insertTextRuns2) {
      insertTextRun.st += currentIndex;
      insertTextRun.ed += currentIndex;
    }
  }
  for (let i = 0; i < len; i++) {
    const textRun = textRuns[i];
    const { st, ed } = textRun;
    if (ed <= currentIndex) {
      newTextRuns.push(textRun);
    } else if (currentIndex > st && currentIndex < ed) {
      hasInserted = true;
      const firstSplitTextRun = {
        ...textRun,
        ed: currentIndex
      };
      newTextRuns.push(firstSplitTextRun);
      if (insertTextRuns2.length) {
        newTextRuns.push(...insertTextRuns2);
      }
      const lastSplitTextRun = {
        ...textRun,
        st: currentIndex + textLength,
        ed: ed + textLength
      };
      newTextRuns.push(lastSplitTextRun);
    } else {
      textRun.st += textLength;
      textRun.ed += textLength;
      if (!hasInserted) {
        hasInserted = true;
        newTextRuns.push(...insertTextRuns2);
      }
      newTextRuns.push(textRun);
    }
  }
  if (!hasInserted) {
    hasInserted = true;
    newTextRuns.push(...insertTextRuns2);
  }
  body.textRuns = normalizeTextRuns(newTextRuns);
}
function insertParagraphs(body, insertBody, textLength, currentIndex) {
  const { paragraphs } = body;
  if (paragraphs == null) {
    return;
  }
  const { paragraphs: insertParagraphs2 } = insertBody;
  const paragraphIndexList = [];
  let firstInsertParagraphNextIndex = -1;
  for (let i = 0, len = paragraphs.length; i < len; i++) {
    const paragraph = paragraphs[i];
    const { startIndex } = paragraph;
    if (startIndex >= currentIndex) {
      paragraph.startIndex += textLength;
    }
    if (firstInsertParagraphNextIndex === -1 && startIndex >= currentIndex) {
      firstInsertParagraphNextIndex = i;
    }
    paragraphIndexList.push(paragraph.startIndex);
  }
  let deleteReptIndex = -1;
  if (insertParagraphs2) {
    for (let i = 0, len = insertParagraphs2.length; i < len; i++) {
      const insertParagraph = insertParagraphs2[i];
      insertParagraph.startIndex += currentIndex;
      const insertIndex = insertParagraph.startIndex;
      deleteReptIndex = paragraphIndexList.indexOf(insertIndex);
    }
    if (deleteReptIndex !== -1) {
      paragraphs.splice(deleteReptIndex, 1);
    }
    paragraphs.push(...insertParagraphs2);
    paragraphs.sort(sortRulesFactory("startIndex"));
  }
}
function insertSectionBreaks(body, insertBody, textLength, currentIndex) {
  const { sectionBreaks } = body;
  if (sectionBreaks == null) {
    return;
  }
  for (let i = 0, len = sectionBreaks.length; i < len; i++) {
    const sectionBreak = sectionBreaks[i];
    const { startIndex } = sectionBreak;
    if (startIndex >= currentIndex) {
      sectionBreak.startIndex += textLength;
    }
  }
  const insertSectionBreaks2 = insertBody.sectionBreaks;
  if (insertSectionBreaks2) {
    for (let i = 0, len = insertSectionBreaks2.length; i < len; i++) {
      const sectionBreak = insertSectionBreaks2[i];
      sectionBreak.startIndex += currentIndex;
    }
    sectionBreaks.push(...insertSectionBreaks2);
    sectionBreaks.sort(sortRulesFactory("startIndex"));
  }
}
function insertCustomBlocks(body, insertBody, textLength, currentIndex) {
  const { customBlocks = [] } = body;
  for (let i = 0, len = customBlocks.length; i < len; i++) {
    const customBlock = customBlocks[i];
    const { startIndex } = customBlock;
    if (startIndex >= currentIndex) {
      customBlock.startIndex += textLength;
    }
  }
  const insertCustomBlocks2 = insertBody.customBlocks;
  if (insertCustomBlocks2) {
    for (let i = 0, len = insertCustomBlocks2.length; i < len; i++) {
      const customBlock = insertCustomBlocks2[i];
      customBlock.startIndex += currentIndex;
    }
    customBlocks.push(...insertCustomBlocks2);
    customBlocks.sort(sortRulesFactory("startIndex"));
  }
  if (customBlocks.length && !body.customBlocks) {
    body.customBlocks = customBlocks;
  }
}
function insertTables(body, insertBody, textLength, currentIndex) {
  const { tables } = body;
  if (tables == null) {
    return;
  }
  for (let i = 0, len = tables.length; i < len; i++) {
    const table = tables[i];
    const { startIndex, endIndex } = table;
    if (startIndex > currentIndex) {
      table.startIndex += textLength;
      table.endIndex += textLength;
    } else if (endIndex > currentIndex) {
      table.endIndex += textLength;
    }
  }
  const insertTables2 = insertBody.tables;
  if (insertTables2) {
    for (let i = 0, len = insertTables2.length; i < len; i++) {
      const table = insertTables2[i];
      table.startIndex += currentIndex;
      table.endIndex += currentIndex;
    }
    tables.push(...insertTables2);
    tables.sort(sortRulesFactory("startIndex"));
  }
}
var ID_SPLIT_SYMBOL = "$";
var getRootId = (id) => id.split(ID_SPLIT_SYMBOL)[0];
function mergeContinuousRanges(ranges) {
  if (ranges.length <= 1) return ranges;
  ranges.sort((a2, b) => a2.startIndex - b.startIndex);
  const mergedRanges = [];
  let currentRange = { ...ranges[0] };
  currentRange.rangeId = getRootId(currentRange.rangeId);
  for (let i = 1; i < ranges.length; i++) {
    const nextRange = ranges[i];
    nextRange.rangeId = getRootId(nextRange.rangeId);
    if (nextRange.rangeId === currentRange.rangeId && shallowEqual(currentRange.properties, nextRange.properties) && currentRange.endIndex + 1 >= nextRange.startIndex) {
      currentRange.endIndex = nextRange.endIndex;
    } else {
      mergedRanges.push(currentRange);
      currentRange = { ...nextRange };
    }
  }
  mergedRanges.push(currentRange);
  const idMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, len = mergedRanges.length; i < len; i++) {
    const range = mergedRanges[i];
    const id = range.rangeId;
    if (idMap[id]) {
      range.rangeId = `${id}${ID_SPLIT_SYMBOL}${idMap[id]}`;
      idMap[id] = idMap[id] + 1;
    } else {
      idMap[id] = 1;
    }
  }
  return mergedRanges;
}
function splitCustomRangesByIndex(customRanges, currentIndex) {
  const matchedCustomRangeIndex = customRanges.findIndex((c) => c.startIndex < currentIndex && c.endIndex >= currentIndex);
  const matchedCustomRange = customRanges[matchedCustomRangeIndex];
  if (matchedCustomRange) {
    customRanges.splice(matchedCustomRangeIndex, 1, {
      rangeId: matchedCustomRange.rangeId,
      rangeType: matchedCustomRange.rangeType,
      startIndex: matchedCustomRange.startIndex,
      endIndex: currentIndex - 1,
      properties: { ...matchedCustomRange.properties }
    }, {
      rangeId: matchedCustomRange.rangeId,
      rangeType: matchedCustomRange.rangeType,
      startIndex: currentIndex,
      endIndex: matchedCustomRange.endIndex,
      properties: { ...matchedCustomRange.properties }
    });
  }
}
function mergeContinuousDecorations(ranges) {
  if (ranges.length <= 1) return ranges;
  ranges.sort((a2, b) => a2.startIndex - b.startIndex);
  const mergedRanges = [];
  let currentRange = { ...ranges[0] };
  for (let i = 1; i < ranges.length; i++) {
    const nextRange = ranges[i];
    if (nextRange.id === currentRange.id && currentRange.endIndex + 1 >= nextRange.startIndex) {
      currentRange.endIndex = nextRange.endIndex;
    } else {
      mergedRanges.push(currentRange);
      currentRange = { ...nextRange };
    }
  }
  mergedRanges.push(currentRange);
  return mergedRanges;
}
function splitCustomDecoratesByIndex(customDecorations, currentIndex) {
  const matches = customDecorations.filter((c) => c.startIndex < currentIndex && c.endIndex >= currentIndex);
  matches.forEach((matched) => {
    const index = customDecorations.indexOf(matched);
    customDecorations.splice(index, 1, {
      id: matched.id,
      type: matched.type,
      startIndex: matched.startIndex,
      endIndex: currentIndex - 1
    }, {
      id: matched.id,
      type: matched.type,
      startIndex: currentIndex,
      endIndex: matched.endIndex
    });
  });
}
function insertCustomRanges(body, insertBody, textLength, currentIndex) {
  if (!body.customRanges) {
    body.customRanges = [];
  }
  const { customRanges } = body;
  splitCustomRangesByIndex(customRanges, currentIndex);
  for (let i = 0, len = customRanges.length; i < len; i++) {
    const customRange = customRanges[i];
    const { startIndex } = customRange;
    if (startIndex >= currentIndex) {
      customRange.startIndex += textLength;
      customRange.endIndex += textLength;
    }
  }
  const insertRanges = [];
  if (insertBody.customRanges) {
    for (let i = 0, len = insertBody.customRanges.length; i < len; i++) {
      const customRange = insertBody.customRanges[i];
      customRange.startIndex += currentIndex;
      customRange.endIndex += currentIndex;
      insertRanges.push(customRange);
    }
    customRanges.push(...insertRanges);
  }
  body.customRanges = mergeContinuousRanges(customRanges);
}
function insertCustomDecorations(body, insertBody, textLength, currentIndex) {
  if (!body.customDecorations) {
    body.customDecorations = [];
  }
  const { customDecorations } = body;
  splitCustomDecoratesByIndex(customDecorations, currentIndex);
  for (let i = 0, len = customDecorations.length; i < len; i++) {
    const customDecoration = customDecorations[i];
    const { startIndex } = customDecoration;
    if (startIndex >= currentIndex) {
      customDecoration.startIndex += textLength;
      customDecoration.endIndex += textLength;
    }
  }
  const insertRanges = [];
  if (insertBody.customDecorations) {
    for (let i = 0, len = insertBody.customDecorations.length; i < len; i++) {
      const customDecoration = insertBody.customDecorations[i];
      customDecoration.startIndex += currentIndex;
      customDecoration.endIndex += currentIndex;
      insertRanges.push(customDecoration);
    }
    customDecorations.push(...insertRanges);
  }
  body.customDecorations = mergeContinuousDecorations(customDecorations);
}
function deleteTextRuns(body, textLength, currentIndex) {
  const { textRuns } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength;
  const removeTextRuns = [];
  if (textRuns) {
    const newTextRuns = [];
    for (let i = 0, len = textRuns.length; i < len; i++) {
      const textRun = textRuns[i];
      const { st, ed } = textRun;
      if (startIndex <= st && endIndex >= ed) {
        removeTextRuns.push({
          ...textRun,
          st: st - startIndex,
          ed: ed - startIndex
        });
        continue;
      } else if (st <= startIndex && ed >= endIndex) {
        removeTextRuns.push({
          ...textRun,
          st: startIndex - startIndex,
          ed: endIndex - startIndex
        });
        textRun.ed -= textLength;
      } else if (startIndex >= st && startIndex < ed) {
        removeTextRuns.push({
          ...textRun,
          st: startIndex - startIndex,
          ed: ed - startIndex
        });
        textRun.ed = startIndex;
      } else if (endIndex > st && endIndex <= ed) {
        removeTextRuns.push({
          ...textRun,
          st: st - startIndex,
          ed: endIndex - startIndex
        });
        textRun.st = endIndex - textLength;
        textRun.ed -= textLength;
      } else if (st >= endIndex) {
        textRun.st -= textLength;
        textRun.ed -= textLength;
      }
      newTextRuns.push(textRun);
    }
    body.textRuns = newTextRuns;
  }
  if (removeTextRuns.length === 0) {
    removeTextRuns.push({
      st: 0,
      ed: textLength,
      ts: {}
    });
  }
  return removeTextRuns;
}
function deleteParagraphs(body, textLength, currentIndex) {
  const { paragraphs } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength;
  const removeParagraphs = [];
  let removeAfterFirstNew = null;
  let isRemove = false;
  if (paragraphs) {
    const newParagraphs = [];
    for (let i = 0, len = paragraphs.length; i < len; i++) {
      const paragraph = paragraphs[i];
      const { startIndex: index } = paragraph;
      if (index >= startIndex && index < endIndex) {
        removeParagraphs.push({
          ...paragraph,
          startIndex: index - currentIndex
        });
        isRemove = true;
        continue;
      } else if (index >= endIndex) {
        paragraph.startIndex -= textLength;
      }
      newParagraphs.push(paragraph);
      if (removeAfterFirstNew == null && isRemove) {
        removeAfterFirstNew = paragraph;
      }
    }
    body.paragraphs = newParagraphs;
  }
  return removeParagraphs;
}
function deleteSectionBreaks(body, textLength, currentIndex) {
  const { sectionBreaks } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength - 1;
  const removeSectionBreaks = [];
  if (sectionBreaks) {
    const newSectionBreaks = [];
    for (let i = 0, len = sectionBreaks.length; i < len; i++) {
      const sectionBreak = sectionBreaks[i];
      const { startIndex: index } = sectionBreak;
      if (index >= startIndex && index <= endIndex) {
        removeSectionBreaks.push({
          ...sectionBreak,
          startIndex: index - currentIndex
        });
        continue;
      } else if (index > endIndex) {
        sectionBreak.startIndex -= textLength;
      }
      newSectionBreaks.push(sectionBreak);
    }
    body.sectionBreaks = newSectionBreaks;
  }
  return removeSectionBreaks;
}
function deleteCustomBlocks(body, textLength, currentIndex) {
  const { customBlocks = [] } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength - 1;
  const removeCustomBlocks = [];
  if (customBlocks) {
    const newCustomBlocks = [];
    for (let i = 0, len = customBlocks.length; i < len; i++) {
      const customBlock = customBlocks[i];
      const { startIndex: index } = customBlock;
      if (index >= startIndex && index <= endIndex) {
        removeCustomBlocks.push({
          ...customBlock,
          startIndex: index - currentIndex
        });
        continue;
      } else if (index > endIndex) {
        customBlock.startIndex -= textLength;
      }
      newCustomBlocks.push(customBlock);
    }
    body.customBlocks = newCustomBlocks;
  }
  if (customBlocks.length && !body.customBlocks) {
    body.customBlocks = customBlocks;
  }
  return removeCustomBlocks;
}
function deleteTables(body, textLength, currentIndex) {
  const { tables } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength - 1;
  const removeTables = [];
  if (tables) {
    const newTables = [];
    for (let i = 0, len = tables.length; i < len; i++) {
      const table = tables[i];
      const { startIndex: st, endIndex: ed } = table;
      if (startIndex <= st && endIndex >= ed) {
        removeTables.push({
          ...table,
          startIndex: st - currentIndex,
          endIndex: ed - currentIndex
        });
        continue;
      } else if (st <= startIndex && ed >= endIndex) {
        const segments = horizontalLineSegmentsSubtraction(st, ed, startIndex, endIndex);
        if (segments.length === 0) {
          continue;
        }
        table.startIndex = segments[0];
        table.endIndex = segments[1];
        if (table.startIndex === table.endIndex) {
          continue;
        }
      } else if (endIndex < st) {
        table.startIndex -= textLength;
        table.endIndex -= textLength;
      }
      newTables.push(table);
    }
    body.tables = newTables;
  }
  return removeTables;
}
function deleteCustomRanges(body, textLength, currentIndex) {
  const { customRanges } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength - 1;
  const removeCustomRanges = [];
  if (customRanges) {
    const newCustomRanges = [];
    for (let i = 0, len = customRanges.length; i < len; i++) {
      const customRange = customRanges[i];
      const { startIndex: st, endIndex: ed } = customRange;
      if (st >= startIndex && ed <= endIndex) {
        removeCustomRanges.push(customRange);
        continue;
      } else if (Math.max(startIndex, st) <= Math.min(endIndex, ed)) {
        const segments = horizontalLineSegmentsSubtraction(st, ed, startIndex, endIndex);
        if (segments.length === 0) {
          continue;
        }
        customRange.startIndex = segments[0];
        customRange.endIndex = segments[1];
      } else if (endIndex < st) {
        customRange.startIndex -= textLength;
        customRange.endIndex -= textLength;
      }
      newCustomRanges.push(customRange);
    }
    body.customRanges = mergeContinuousRanges(newCustomRanges);
  }
  return removeCustomRanges;
}
function deleteCustomDecorations(body, textLength, currentIndex, needOffset = true) {
  const { customDecorations } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength - 1;
  const removeCustomDecorations = [];
  if (customDecorations) {
    const newCustomDecorations = [];
    for (let i = 0, len = customDecorations.length; i < len; i++) {
      const customDecoration = customDecorations[i];
      const { startIndex: st, endIndex: ed } = customDecoration;
      if (st >= startIndex && ed <= endIndex) {
        removeCustomDecorations.push(customDecoration);
        continue;
      } else if (Math.max(startIndex, st) <= Math.min(endIndex, ed)) {
        const segments = horizontalLineSegmentsSubtraction(st, ed, startIndex, endIndex);
        if (segments.length === 0) {
          continue;
        }
        customDecoration.startIndex = segments[0];
        customDecoration.endIndex = segments[1];
      } else if (endIndex < st) {
        if (needOffset) {
          customDecoration.startIndex -= textLength;
          customDecoration.endIndex -= textLength;
        }
      }
      newCustomDecorations.push(customDecoration);
    }
    body.customDecorations = newCustomDecorations;
  }
  return removeCustomDecorations;
}

// ../packages/core/src/docs/data-model/preset-list-type.ts
var orderListSymbolMap = {
  "a)": { glyphFormat: "%1)", glyphType: 2 /* DECIMAL */ },
  "1.": { glyphFormat: "%1.", glyphType: 2 /* DECIMAL */ },
  "a.": { glyphFormat: "%1.", glyphType: 5 /* LOWER_LETTER */ },
  "A.": { glyphFormat: "%1.", glyphType: 4 /* UPPER_LETTER */ },
  "i.": { glyphFormat: "%1.", glyphType: 7 /* LOWER_ROMAN */ },
  "I.": { glyphFormat: "%1.", glyphType: 4 /* UPPER_LETTER */ }
};
var bulletListFactory = (symbols) => {
  return [
    ...symbols,
    ...symbols,
    ...symbols
  ].map((templateSymbol, i) => ({
    glyphFormat: ` %${i + 1}`,
    glyphSymbol: templateSymbol,
    bulletAlignment: 1 /* START */,
    textStyle: {
      fs: 12
    },
    startNumber: 0,
    paragraphProperties: {
      hanging: { v: 21 },
      indentStart: { v: 21 * i }
    }
  }));
};
var orderListFactory = (options) => {
  return options.map((format, i) => ({
    ...format,
    bulletAlignment: 1 /* START */,
    textStyle: {
      fs: 12
    },
    startNumber: 0,
    paragraphProperties: {
      hanging: { v: 21 },
      indentStart: { v: 21 * i }
    }
  }));
};
var checkListFactory = (symbol, textStyle) => {
  return new Array(9).fill(0).map((_, i) => ({
    glyphFormat: ` %${i + 1}`,
    glyphSymbol: symbol,
    bulletAlignment: 1 /* START */,
    textStyle: {
      fs: 16
    },
    startNumber: 0,
    paragraphProperties: {
      hanging: { v: 21 },
      indentStart: { v: 21 * i },
      textStyle
    }
  }));
};
var PRESET_LIST_TYPE = {
  ["BULLET_LIST" /* BULLET_LIST */]: {
    listType: "BULLET_LIST" /* BULLET_LIST */,
    nestingLevel: bulletListFactory(["\u25CF", "\u25CB", "\u25A0"])
  },
  ["BULLET_LIST_1" /* BULLET_LIST_1 */]: {
    listType: "BULLET_LIST" /* BULLET_LIST */,
    nestingLevel: bulletListFactory(["\u2756", "\u27A2", "\u25A0"])
  },
  ["BULLET_LIST_2" /* BULLET_LIST_2 */]: {
    listType: "BULLET_LIST" /* BULLET_LIST */,
    nestingLevel: bulletListFactory(["\u2714", "\u25CF", "\u25C6"])
  },
  ["BULLET_LIST_3" /* BULLET_LIST_3 */]: {
    listType: "BULLET_LIST" /* BULLET_LIST */,
    nestingLevel: bulletListFactory(["\u25A0", "\u25C6", "\u25CB"])
  },
  ["BULLET_LIST_4" /* BULLET_LIST_4 */]: {
    listType: "BULLET_LIST" /* BULLET_LIST */,
    nestingLevel: bulletListFactory(["\u2727", "\u25CB", "\u25A0"])
  },
  ["BULLET_LIST_5" /* BULLET_LIST_5 */]: {
    listType: "BULLET_LIST" /* BULLET_LIST */,
    nestingLevel: bulletListFactory(["\u27A2", "\u25CB", "\u25C6"])
  },
  ["ORDER_LIST" /* ORDER_LIST */]: {
    listType: "ORDER_LIST" /* ORDER_LIST */,
    nestingLevel: orderListFactory([
      { glyphFormat: "%1.", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%2.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%3.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%4.", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%5.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%6.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%7.", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%8.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%9.", glyphType: 7 /* LOWER_ROMAN */ }
    ])
  },
  ["ORDER_LIST_1" /* ORDER_LIST_1 */]: {
    listType: "ORDER_LIST" /* ORDER_LIST */,
    nestingLevel: orderListFactory([
      { glyphFormat: "%1)", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%2)", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%3)", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%4)", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%5)", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%6)", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%7)", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%8)", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%9)", glyphType: 7 /* LOWER_ROMAN */ }
    ])
  },
  ["ORDER_LIST_2" /* ORDER_LIST_2 */]: {
    listType: "ORDER_LIST" /* ORDER_LIST */,
    nestingLevel: orderListFactory([
      "%1.",
      "%1.%2.",
      "%1.%2.%3.",
      "%1.%2.%3.%4.",
      "%1.%2.%3.%4.%5.",
      "%1.%2.%3.%4.%5.%6.",
      "%1.%2.%3.%4.%5.%6.%7."
    ].map((format) => ({ glyphFormat: format, glyphType: 2 /* DECIMAL */ })))
  },
  ["ORDER_LIST_3" /* ORDER_LIST_3 */]: {
    listType: "ORDER_LIST" /* ORDER_LIST */,
    nestingLevel: orderListFactory([
      { glyphFormat: "%1.", glyphType: 4 /* UPPER_LETTER */ },
      { glyphFormat: "%2.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%3.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%4.", glyphType: 4 /* UPPER_LETTER */ },
      { glyphFormat: "%5.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%6.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%7.", glyphType: 4 /* UPPER_LETTER */ },
      { glyphFormat: "%8.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%9.", glyphType: 7 /* LOWER_ROMAN */ }
    ])
  },
  ["ORDER_LIST_4" /* ORDER_LIST_4 */]: {
    listType: "ORDER_LIST" /* ORDER_LIST */,
    nestingLevel: orderListFactory([
      { glyphFormat: "%1.", glyphType: 4 /* UPPER_LETTER */ },
      { glyphFormat: "%2.", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%3.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%4.", glyphType: 4 /* UPPER_LETTER */ },
      { glyphFormat: "%5.", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%6.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%7.", glyphType: 4 /* UPPER_LETTER */ },
      { glyphFormat: "%8.", glyphType: 2 /* DECIMAL */ },
      { glyphFormat: "%9.", glyphType: 7 /* LOWER_ROMAN */ }
    ])
  },
  ["ORDER_LIST_5" /* ORDER_LIST_5 */]: {
    listType: "ORDER_LIST" /* ORDER_LIST */,
    nestingLevel: orderListFactory([
      { glyphFormat: "%1.", glyphType: 3 /* DECIMAL_ZERO */ },
      { glyphFormat: "%2.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%3.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%4.", glyphType: 3 /* DECIMAL_ZERO */ },
      { glyphFormat: "%5.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%6.", glyphType: 7 /* LOWER_ROMAN */ },
      { glyphFormat: "%7.", glyphType: 3 /* DECIMAL_ZERO */ },
      { glyphFormat: "%8.", glyphType: 5 /* LOWER_LETTER */ },
      { glyphFormat: "%9.", glyphType: 7 /* LOWER_ROMAN */ }
    ])
  },
  ["CHECK_LIST" /* CHECK_LIST */]: {
    listType: "CHECK_LIST" /* CHECK_LIST */,
    nestingLevel: checkListFactory("\u2610")
  },
  ["CHECK_LIST_CHECKED" /* CHECK_LIST_CHECKED */]: {
    listType: "CHECK_LIST_CHECKED" /* CHECK_LIST_CHECKED */,
    nestingLevel: checkListFactory(
      "\u2611",
      {
        st: {
          s: 1 /* TRUE */
        }
      }
    )
  }
};
var generateOrderList = (opt) => {
  const { glyphFormat, glyphType } = opt;
  const data = Tools.deepClone(PRESET_LIST_TYPE["ORDER_LIST" /* ORDER_LIST */]);
  data.nestingLevel[0].glyphFormat = glyphFormat;
  data.nestingLevel[0].glyphType = glyphType;
  return data;
};
var QUICK_LIST_TYPE = {
  ["ORDER_LIST_QUICK_2" /* ORDER_LIST_QUICK_2 */]: generateOrderList(orderListSymbolMap["a)" /* ORDER_LIST_QUICK_2 */]),
  ["ORDER_LIST_QUICK_3" /* ORDER_LIST_QUICK_3 */]: generateOrderList(orderListSymbolMap["a." /* ORDER_LIST_QUICK_3 */]),
  ["ORDER_LIST_QUICK_4" /* ORDER_LIST_QUICK_4 */]: generateOrderList(orderListSymbolMap["i." /* ORDER_LIST_QUICK_4 */]),
  ["ORDER_LIST_QUICK_6" /* ORDER_LIST_QUICK_6 */]: generateOrderList(orderListSymbolMap["I." /* ORDER_LIST_QUICK_6 */])
};
Object.assign(PRESET_LIST_TYPE, QUICK_LIST_TYPE);

// ../packages/core/src/docs/data-model/text-x/apply-utils/update-apply.ts
function updateAttribute(body, updateBody, textLength, currentIndex, coverType) {
  const removeTextRuns = updateTextRuns(body, updateBody, textLength, currentIndex, coverType);
  const removeParagraphs = updateParagraphs(body, updateBody, textLength, currentIndex, coverType);
  const removeSectionBreaks = updateSectionBreaks(body, updateBody, textLength, currentIndex, coverType);
  const removeCustomBlocks = updateCustomBlocks(body, updateBody, textLength, currentIndex, coverType);
  const removeTables = updateTables(body, updateBody, textLength, currentIndex, coverType);
  const removeCustomRanges = updateCustomRanges(body, updateBody, textLength, currentIndex, coverType);
  const removeCustomDecorations = updateCustomDecorations(body, updateBody, textLength, currentIndex, coverType);
  return {
    dataStream: "",
    textRuns: removeTextRuns,
    paragraphs: removeParagraphs,
    sectionBreaks: removeSectionBreaks,
    customBlocks: removeCustomBlocks,
    tables: removeTables,
    customRanges: removeCustomRanges,
    customDecorations: removeCustomDecorations
  };
}
function updateTextRuns(body, updateBody, textLength, currentIndex, coverType) {
  const { textRuns } = body;
  const { textRuns: updateTextRuns2 } = updateBody;
  if (textRuns == null || updateTextRuns2 == null) {
    return;
  }
  const removeTextRuns = deleteTextRuns(body, textLength, currentIndex);
  if (coverType !== 1 /* REPLACE */) {
    const newUpdateTextRun = coverTextRuns(updateTextRuns2, removeTextRuns, coverType);
    updateBody.textRuns = newUpdateTextRun;
  }
  insertTextRuns(body, updateBody, textLength, currentIndex);
  return removeTextRuns;
}
function coverTextRuns(updateDataTextRuns, originTextRuns, coverType) {
  if (originTextRuns.length === 0) {
    return updateDataTextRuns;
  }
  updateDataTextRuns = Tools.deepClone(updateDataTextRuns);
  originTextRuns = Tools.deepClone(originTextRuns);
  const newUpdateTextRuns = [];
  const updateLength = updateDataTextRuns.length;
  const removeLength = originTextRuns.length;
  let updateIndex = 0;
  let removeIndex = 0;
  let pending = null;
  function pushPendingAndReturnStatus() {
    if (pending) {
      newUpdateTextRuns.push(pending);
      pending = null;
      return true;
    }
    return false;
  }
  while (updateIndex < updateLength && removeIndex < removeLength) {
    const { st: updateSt, ed: updateEd, ts: updateStyle } = updateDataTextRuns[updateIndex];
    const { st: removeSt, ed: removeEd, ts: originStyle, sId } = originTextRuns[removeIndex];
    let newTs;
    if (coverType === 0 /* COVER */) {
      newTs = { ...originStyle, ...updateStyle };
    } else {
      newTs = { ...updateStyle };
    }
    if (updateEd < removeSt) {
      if (!pushPendingAndReturnStatus()) {
        newUpdateTextRuns.push(updateDataTextRuns[updateIndex]);
      }
      updateIndex++;
    } else if (removeEd < updateSt) {
      if (!pushPendingAndReturnStatus()) {
        newUpdateTextRuns.push(originTextRuns[removeIndex]);
      }
      removeIndex++;
    } else {
      const newTextRun = {
        st: Math.min(updateSt, removeSt),
        ed: Math.max(updateSt, removeSt),
        ts: updateSt < removeSt ? { ...updateStyle } : { ...originStyle },
        sId: updateSt < removeSt ? void 0 : sId
      };
      if (newTextRun.ed > newTextRun.st) {
        newUpdateTextRuns.push(newTextRun);
      }
      newUpdateTextRuns.push({
        st: Math.max(updateSt, removeSt),
        ed: Math.min(updateEd, removeEd),
        ts: newTs,
        sId
      });
      if (updateEd < removeEd) {
        updateIndex++;
        originTextRuns[removeIndex].st = updateEd;
        if (originTextRuns[removeIndex].st === originTextRuns[removeIndex].ed) {
          removeIndex++;
        }
      } else {
        removeIndex++;
        updateDataTextRuns[updateIndex].st = removeEd;
        if (updateDataTextRuns[updateIndex].st === updateDataTextRuns[updateIndex].ed) {
          updateIndex++;
        }
      }
      const pendingTextRun = {
        st: Math.min(updateEd, removeEd),
        ed: Math.max(updateEd, removeEd),
        ts: updateEd < removeEd ? { ...originStyle } : { ...updateStyle },
        sId: updateEd < removeEd ? sId : void 0
      };
      pending = pendingTextRun.ed > pendingTextRun.st ? pendingTextRun : null;
    }
  }
  pushPendingAndReturnStatus();
  const tempTopTextRun = newUpdateTextRuns[newUpdateTextRuns.length - 1];
  const updateLastTextRun = updateDataTextRuns[updateLength - 1];
  const removeLastTextRun = originTextRuns[removeLength - 1];
  if (tempTopTextRun && tempTopTextRun.ed !== Math.max(updateLastTextRun.ed, removeLastTextRun.ed)) {
    if (updateLastTextRun.ed > removeLastTextRun.ed) {
      newUpdateTextRuns.push(updateLastTextRun);
    } else {
      newUpdateTextRuns.push(removeLastTextRun);
    }
  }
  return normalizeTextRuns(newUpdateTextRuns);
}
function updateParagraphs(body, updateBody, textLength, currentIndex, coverType) {
  const { paragraphs } = body;
  const { paragraphs: updateDataParagraphs } = updateBody;
  if (paragraphs == null || updateDataParagraphs == null) {
    return;
  }
  const removeParagraphs = deleteParagraphs(body, textLength, currentIndex);
  if (coverType !== 1 /* REPLACE */) {
    const newUpdateParagraphs = [];
    for (const updateParagraph of updateDataParagraphs) {
      const {
        startIndex: updateStartIndex,
        paragraphStyle: updateParagraphStyle,
        bullet: updateBullet
      } = updateParagraph;
      let splitUpdateParagraphs = [];
      for (const removeParagraph of removeParagraphs) {
        const {
          startIndex: removeStartIndex,
          paragraphStyle: removeParagraphStyle,
          bullet: removeBullet
        } = removeParagraph;
        let newParagraphStyle;
        let newBullet;
        if (coverType === 0 /* COVER */) {
          newParagraphStyle = { ...removeParagraphStyle, ...updateParagraphStyle };
          newBullet = {
            listId: "",
            listType: "BULLET_LIST" /* BULLET_LIST */,
            nestingLevel: 0,
            textStyle: {},
            ...removeBullet,
            ...updateBullet
          };
        } else {
          newParagraphStyle = { ...updateParagraphStyle, ...removeParagraphStyle };
          newBullet = {
            listId: "",
            listType: "BULLET_LIST" /* BULLET_LIST */,
            nestingLevel: 0,
            textStyle: {},
            ...updateBullet,
            ...removeBullet
          };
        }
        if (updateStartIndex === removeStartIndex) {
          splitUpdateParagraphs.push({
            startIndex: updateStartIndex,
            paragraphStyle: newParagraphStyle,
            bullet: newBullet
          });
          break;
        }
      }
      newUpdateParagraphs.push(...splitUpdateParagraphs);
      splitUpdateParagraphs = [];
    }
    updateBody.paragraphs = newUpdateParagraphs;
  }
  insertParagraphs(body, updateBody, textLength, currentIndex);
  return removeParagraphs;
}
function updateSectionBreaks(body, updateBody, textLength, currentIndex, coverType) {
  const { sectionBreaks } = body;
  const { sectionBreaks: updateDataSectionBreaks } = updateBody;
  if (sectionBreaks == null || updateDataSectionBreaks == null) {
    return;
  }
  const removeSectionBreaks = deleteSectionBreaks(body, textLength, currentIndex);
  if (coverType !== 1 /* REPLACE */) {
    const newUpdateSectionBreaks = [];
    for (const updateSectionBreak of updateDataSectionBreaks) {
      const { startIndex: updateStartIndex } = updateSectionBreak;
      let splitUpdateSectionBreaks = [];
      for (const removeSectionBreak of removeSectionBreaks) {
        const { startIndex: removeStartIndex } = removeSectionBreak;
        if (updateStartIndex === removeStartIndex) {
          if (coverType === 0 /* COVER */) {
            splitUpdateSectionBreaks.push({
              ...removeSectionBreak,
              ...updateSectionBreak
            });
          } else {
            splitUpdateSectionBreaks.push({
              ...updateSectionBreak,
              ...removeSectionBreak
            });
          }
          break;
        }
      }
      newUpdateSectionBreaks.push(...splitUpdateSectionBreaks);
      splitUpdateSectionBreaks = [];
    }
    updateBody.sectionBreaks = newUpdateSectionBreaks;
  }
  insertSectionBreaks(body, updateBody, textLength, currentIndex);
  return removeSectionBreaks;
}
function updateCustomBlocks(body, updateBody, textLength, currentIndex, coverType) {
  const { customBlocks = [] } = body;
  const { customBlocks: updateDataCustomBlocks } = updateBody;
  if (customBlocks == null || updateDataCustomBlocks == null) {
    return;
  }
  const removeCustomBlocks = deleteCustomBlocks(body, textLength, currentIndex);
  if (coverType !== 1 /* REPLACE */) {
    const newUpdateCustomBlocks = [];
    for (const updateCustomBlock of updateDataCustomBlocks) {
      const { startIndex: updateStartIndex } = updateCustomBlock;
      let splitUpdateCustomBlocks = [];
      for (const removeCustomBlock of removeCustomBlocks) {
        const { startIndex: removeStartIndex } = removeCustomBlock;
        if (updateStartIndex === removeStartIndex) {
          if (coverType === 0 /* COVER */) {
            splitUpdateCustomBlocks.push({
              ...removeCustomBlock,
              ...updateCustomBlock
            });
          } else {
            splitUpdateCustomBlocks.push({
              ...updateCustomBlock,
              ...removeCustomBlock
            });
          }
          break;
        }
      }
      newUpdateCustomBlocks.push(...splitUpdateCustomBlocks);
      splitUpdateCustomBlocks = [];
    }
    updateBody.customBlocks = newUpdateCustomBlocks;
  }
  insertCustomBlocks(body, updateBody, textLength, currentIndex);
  if (customBlocks.length && !body.customBlocks) {
    body.customBlocks = customBlocks;
  }
  return removeCustomBlocks;
}
function updateTables(body, updateBody, textLength, currentIndex, coverType) {
  const { tables } = body;
  const { tables: updateDataTables } = updateBody;
  if (tables == null || updateDataTables == null) {
    return;
  }
  const removeTables = deleteTables(body, textLength, currentIndex);
  if (coverType !== 1 /* REPLACE */) {
    const newUpdateTables = [];
    for (const updateTable of updateDataTables) {
      const { startIndex: updateStartIndex, endIndex: updateEndIndex } = updateTable;
      let splitUpdateTables = [];
      for (const removeTable of removeTables) {
        const { startIndex: removeStartIndex, endIndex: removeEndIndex } = removeTable;
        if (removeStartIndex >= updateStartIndex && removeEndIndex <= updateEndIndex) {
          if (coverType === 0 /* COVER */) {
            splitUpdateTables.push({
              ...removeTable,
              ...updateTable
            });
          } else {
            splitUpdateTables.push({
              ...updateTable,
              ...removeTable
            });
          }
          break;
        }
      }
      newUpdateTables.push(...splitUpdateTables);
      splitUpdateTables = [];
    }
    updateBody.tables = newUpdateTables;
  }
  insertTables(body, updateBody, textLength, currentIndex);
  return removeTables;
}
function updateCustomRanges(body, updateBody, textLength, currentIndex, _coverType) {
  if (!body.customRanges) {
    body.customRanges = [];
  }
  splitCustomRangesByIndex(body.customRanges, currentIndex);
  splitCustomRangesByIndex(body.customRanges, currentIndex + textLength);
  const start = currentIndex;
  const end = currentIndex + textLength - 1;
  const { customRanges: updateDataCustomRanges } = updateBody;
  const newCustomRanges = [];
  const relativeCustomRanges = /* @__PURE__ */ new Map();
  body.customRanges.forEach((customRange) => {
    const { startIndex, endIndex } = customRange;
    if (startIndex >= start && endIndex <= end) {
      relativeCustomRanges.set(customRange.rangeId, customRange);
    } else {
      newCustomRanges.push(customRange);
    }
  });
  const removeCustomRanges = [];
  if (!updateDataCustomRanges) {
    return [];
  }
  updateDataCustomRanges.forEach((customRange) => {
    const { startIndex, endIndex } = customRange;
    newCustomRanges.push({
      ...customRange,
      startIndex: startIndex + currentIndex,
      endIndex: endIndex + currentIndex
    });
  });
  body.customRanges = mergeContinuousRanges(newCustomRanges);
  return removeCustomRanges;
}
function updateCustomDecorations(body, updateBody, textLength, currentIndex, coverType) {
  if (!body.customDecorations) {
    body.customDecorations = [];
  }
  splitCustomDecoratesByIndex(body.customDecorations, currentIndex);
  splitCustomDecoratesByIndex(body.customDecorations, currentIndex + textLength);
  const removeCustomDecorations = [];
  const { customDecorations } = body;
  const { customDecorations: updateDataCustomDecorations = [] } = updateBody;
  if (coverType === 1 /* REPLACE */) {
    for (let index = 0; index < customDecorations.length; index++) {
      const customDecoration = customDecorations[index];
      const { startIndex, endIndex } = customDecoration;
      if (startIndex >= currentIndex && endIndex <= currentIndex + textLength - 1) {
        removeCustomDecorations.push(customDecoration);
      }
    }
    updateDataCustomDecorations.forEach((customDecoration) => {
      const { startIndex, endIndex } = customDecoration;
      customDecorations.push({
        ...customDecoration,
        startIndex: startIndex + currentIndex,
        endIndex: endIndex + currentIndex
      });
    });
  } else {
    for (const updateCustomDecoration of updateDataCustomDecorations) {
      const { id } = updateCustomDecoration;
      if (updateCustomDecoration.type === 9999 /* DELETED */) {
        const oldCustomDecorations = customDecorations.filter((d) => d.id === id);
        if (oldCustomDecorations.length) {
          removeCustomDecorations.push(...oldCustomDecorations);
        }
      } else {
        customDecorations.push({
          ...updateCustomDecoration,
          startIndex: updateCustomDecoration.startIndex + currentIndex,
          endIndex: updateCustomDecoration.endIndex + currentIndex
        });
      }
    }
  }
  for (const removeCustomDecoration of removeCustomDecorations) {
    const { id } = removeCustomDecoration;
    const index = customDecorations.findIndex((d) => d.id === id);
    if (index !== -1) {
      customDecorations.splice(index, 1);
    }
  }
  body.customDecorations = mergeContinuousDecorations(customDecorations);
  return removeCustomDecorations;
}

// ../packages/core/src/docs/data-model/text-x/utils.ts
function getTextRunSlice(body, startOffset, endOffset, returnEmptyTextRuns = true) {
  const { textRuns } = body;
  if (textRuns) {
    const newTextRuns = [];
    for (const textRun of textRuns) {
      const clonedTextRun = Tools.deepClone(textRun);
      const { st, ed } = clonedTextRun;
      if (Tools.hasIntersectionBetweenTwoRanges(st, ed, startOffset, endOffset)) {
        if (startOffset >= st && startOffset <= ed) {
          newTextRuns.push({
            ...clonedTextRun,
            st: startOffset,
            ed: Math.min(endOffset, ed)
          });
        } else if (endOffset >= st && endOffset <= ed) {
          newTextRuns.push({
            ...clonedTextRun,
            st: Math.max(startOffset, st),
            ed: endOffset
          });
        } else {
          newTextRuns.push(clonedTextRun);
        }
      }
    }
    return normalizeTextRuns(
      newTextRuns.map((tr) => {
        const { st, ed } = tr;
        return {
          ...tr,
          st: st - startOffset,
          ed: ed - startOffset
        };
      })
    );
  } else if (returnEmptyTextRuns) {
    return [{
      st: 0,
      ed: endOffset - startOffset,
      ts: {}
    }];
  }
}
function getTableSlice(body, startOffset, endOffset) {
  const { tables = [] } = body;
  const newTables = [];
  for (const table of tables) {
    const clonedTable = Tools.deepClone(table);
    const { startIndex, endIndex } = clonedTable;
    if (startIndex >= startOffset && endIndex <= endOffset) {
      newTables.push({
        ...clonedTable,
        startIndex: startIndex - startOffset,
        endIndex: endIndex - startOffset
      });
    }
  }
  return newTables;
}
function getParagraphsSlice(body, startOffset, endOffset) {
  const { paragraphs = [] } = body;
  const newParagraphs = [];
  for (const paragraph of paragraphs) {
    const { startIndex } = paragraph;
    if (startIndex >= startOffset && startIndex < endOffset) {
      newParagraphs.push(Tools.deepClone(paragraph));
    }
  }
  if (newParagraphs.length) {
    return newParagraphs.map((p) => ({
      ...p,
      startIndex: p.startIndex - startOffset
    }));
  }
}
function getCustomBlockSlice(body, startOffset, endOffset) {
  const { customBlocks = [] } = body;
  const newCustomBlocks = [];
  for (const block of customBlocks) {
    const { startIndex } = block;
    if (startIndex >= startOffset && startIndex <= endOffset) {
      newCustomBlocks.push(Tools.deepClone(block));
    }
  }
  if (newCustomBlocks.length) {
    return newCustomBlocks.map((b) => ({
      ...b,
      startIndex: b.startIndex - startOffset
    }));
  }
}
function getBodySlice(body, startOffset, endOffset, returnEmptyArray = true, type2 = 1 /* cut */) {
  const { dataStream } = body;
  const docBody = {
    dataStream: dataStream.slice(startOffset, endOffset)
  };
  docBody.textRuns = getTextRunSlice(body, startOffset, endOffset, returnEmptyArray);
  const newTables = getTableSlice(body, startOffset, endOffset);
  if (newTables.length) {
    docBody.tables = newTables;
  }
  docBody.paragraphs = getParagraphsSlice(body, startOffset, endOffset);
  if (type2 === 1 /* cut */) {
    const customDecorations = getCustomDecorationSlice(body, startOffset, endOffset);
    if (customDecorations) {
      docBody.customDecorations = customDecorations;
    } else if (returnEmptyArray) {
      docBody.customDecorations = [];
    }
  }
  const { customRanges } = getCustomRangeSlice(body, startOffset, endOffset);
  if (customRanges) {
    docBody.customRanges = customRanges;
  } else if (returnEmptyArray) {
    docBody.customRanges = [];
  }
  docBody.customBlocks = getCustomBlockSlice(body, startOffset, endOffset);
  return docBody;
}
function getCustomRangeSlice(body, startOffset, endOffset) {
  if (body.customRanges == null) {
    return {};
  }
  const { customRanges } = body;
  const leftOffset = 0;
  const rightOffset = 0;
  const relativeCustomRanges = customRanges.filter((customRange) => Math.max(customRange.startIndex, startOffset) <= Math.min(customRange.endIndex, endOffset - 1)).map((range) => ({
    ...range,
    startIndex: Math.max(range.startIndex, startOffset),
    endIndex: Math.min(range.endIndex, endOffset - 1)
  }));
  return {
    customRanges: relativeCustomRanges.map((range) => ({
      ...range,
      startIndex: range.startIndex - startOffset,
      endIndex: range.endIndex - startOffset
    })),
    leftOffset,
    rightOffset
  };
}
function getCustomDecorationSlice(body, startOffset, endOffset) {
  if (body.customDecorations == null) {
    return;
  }
  const { customDecorations = [] } = body;
  const customDecorationSlice = [];
  customDecorations.forEach((range) => {
    if (Math.max(range.startIndex, startOffset) <= Math.min(range.endIndex, endOffset - 1)) {
      const copy = Tools.deepClone(range);
      customDecorationSlice.push({
        ...copy,
        startIndex: Math.max(copy.startIndex - startOffset, 0),
        endIndex: Math.min(copy.endIndex, endOffset - 1) - startOffset
      });
    }
  });
  return customDecorationSlice;
}
function composeTextRuns(updateDataTextRuns, originTextRuns, coverType) {
  if (updateDataTextRuns == null || originTextRuns == null) {
    return updateDataTextRuns != null ? updateDataTextRuns : originTextRuns;
  }
  return coverTextRuns(updateDataTextRuns, originTextRuns, coverType);
}
function composeCustomRanges(updateDataCustomRanges, originCustomRanges, coverType) {
  if (updateDataCustomRanges == null || originCustomRanges == null) {
    return updateDataCustomRanges != null ? updateDataCustomRanges : originCustomRanges;
  }
  if (originCustomRanges.length === 0 || updateDataCustomRanges.length === 0) {
    return updateDataCustomRanges;
  }
  if (originCustomRanges.length > 1 || updateDataCustomRanges.length > 1) {
    throw new Error("Cannot cover multiple customRanges");
  }
  if (coverType === 1 /* REPLACE */) {
    return [{
      ...updateDataCustomRanges[0]
    }];
  } else {
    return [{
      ...originCustomRanges[0],
      ...updateDataCustomRanges[0]
    }];
  }
}
function composeCustomDecorations(updateDataCustomDecorations, originCustomDecorations, coverType) {
  if (originCustomDecorations.length === 0 || updateDataCustomDecorations.length === 0) {
    return updateDataCustomDecorations;
  }
  if (coverType === 1 /* REPLACE */) {
    return updateDataCustomDecorations;
  } else {
    return [
      ...updateDataCustomDecorations,
      ...originCustomDecorations.filter((originCustomDecoration) => {
        return !updateDataCustomDecorations.some((updateDataCustomDecoration) => {
          return originCustomDecoration.id === updateDataCustomDecoration.id;
        });
      })
    ];
  }
}
function composeBody(thisBody, otherBody, coverType = 0 /* COVER */) {
  if (otherBody.dataStream !== "") {
    throw new Error("Cannot compose other body with non-empty dataStream");
  }
  const retBody = {
    dataStream: thisBody.dataStream
  };
  const {
    textRuns: thisTextRuns,
    paragraphs: thisParagraphs = [],
    customRanges: thisCustomRanges,
    customDecorations: thisCustomDecorations = []
  } = thisBody;
  const {
    textRuns: otherTextRuns,
    paragraphs: otherParagraphs = [],
    customRanges: otherCustomRanges,
    customDecorations: otherCustomDecorations = []
  } = otherBody;
  retBody.textRuns = composeTextRuns(otherTextRuns, thisTextRuns, coverType);
  retBody.customRanges = composeCustomRanges(otherCustomRanges, thisCustomRanges, coverType);
  const customDecorations = composeCustomDecorations(otherCustomDecorations, thisCustomDecorations, coverType);
  if (customDecorations.length) {
    retBody.customDecorations = customDecorations;
  }
  const paragraphs = [];
  let thisIndex = 0;
  let otherIndex = 0;
  while (thisIndex < thisParagraphs.length && otherIndex < otherParagraphs.length) {
    const thisParagraph = thisParagraphs[thisIndex];
    const otherParagraph = otherParagraphs[otherIndex];
    const { startIndex: thisStart } = thisParagraph;
    const { startIndex: otherStart } = otherParagraph;
    if (thisStart === otherStart) {
      paragraphs.push(Tools.deepMerge(thisParagraph, otherParagraph));
      thisIndex++;
      otherIndex++;
    } else if (thisStart < otherStart) {
      paragraphs.push(Tools.deepClone(thisParagraph));
      thisIndex++;
    } else {
      paragraphs.push(Tools.deepClone(otherParagraph));
      otherIndex++;
    }
  }
  if (thisIndex < thisParagraphs.length) {
    paragraphs.push(...thisParagraphs.slice(thisIndex));
  }
  if (otherIndex < otherParagraphs.length) {
    paragraphs.push(...otherParagraphs.slice(otherIndex));
  }
  if (paragraphs.length) {
    retBody.paragraphs = paragraphs;
  }
  return retBody;
}
function isUselessRetainAction(action) {
  const { body } = action;
  if (body == null) {
    return true;
  }
  const { textRuns, paragraphs, customRanges, customBlocks, customDecorations, tables } = body;
  if (textRuns == null && paragraphs == null && customRanges == null && customBlocks == null && customDecorations == null && tables == null) {
    return true;
  }
  return false;
}

// ../packages/core/src/docs/data-model/text-x/action-iterator.ts
var ActionIterator = class {
  constructor(_actions) {
    this._actions = _actions;
    __publicField(this, "_index", 0);
    __publicField(this, "_offset", 0);
  }
  hasNext() {
    return this.peekLength() < Number.POSITIVE_INFINITY;
  }
  next(length) {
    if (!length) {
      length = Number.POSITIVE_INFINITY;
    }
    const nextAction = this._actions[this._index];
    if (nextAction) {
      const offset = this._offset;
      const actionLength = nextAction.len;
      if (length >= actionLength - offset) {
        length = actionLength - offset;
        this._index += 1;
        this._offset = 0;
      } else {
        this._offset += length;
      }
      if (nextAction.t === "d" /* DELETE */ || nextAction.t === "r" /* RETAIN */ && nextAction.body == null) {
        return Tools.deepClone({
          ...nextAction,
          len: length
        });
      } else {
        return Tools.deepClone({
          ...nextAction,
          len: length,
          body: getBodySlice(nextAction.body, offset, offset + length, false)
        });
      }
    } else {
      return {
        t: "r" /* RETAIN */,
        len: Number.POSITIVE_INFINITY
      };
    }
  }
  peek() {
    return this._actions[this._index];
  }
  peekLength() {
    if (this._actions[this._index]) {
      return this._actions[this._index].len - this._offset;
    } else {
      return Number.POSITIVE_INFINITY;
    }
  }
  peekType() {
    const action = this._actions[this._index];
    if (action) {
      return action.t;
    }
    return "r" /* RETAIN */;
  }
  rest() {
    if (!this.hasNext()) {
      return [];
    } else if (this._offset === 0) {
      return this._actions.slice(this._index);
    } else {
      const offset = this._offset;
      const index = this._index;
      const next = this.next();
      const restActions = this._actions.slice(this._index);
      this._offset = offset;
      this._index = index;
      return [next].concat(restActions);
    }
  }
};

// ../packages/core/src/common/memory-cursor.ts
var MemoryCursor = class {
  constructor() {
    __publicField(this, "cursor", 0);
  }
  reset() {
    this.cursor = 0;
    return this;
  }
  moveCursor(pos) {
    this.cursor += pos;
  }
  moveCursorTo(pos) {
    this.cursor = pos;
  }
};

// ../packages/core/src/docs/data-model/text-x/apply-utils/delete-apply.ts
function updateAttributeByDelete(body, textLength, currentIndex) {
  const { dataStream } = body;
  const startIndex = currentIndex;
  const endIndex = currentIndex + textLength;
  const removeTextRuns = deleteTextRuns(body, textLength, currentIndex);
  const removeParagraphs = deleteParagraphs(body, textLength, currentIndex);
  const removeSectionBreaks = deleteSectionBreaks(body, textLength, currentIndex);
  const removeCustomBlocks = deleteCustomBlocks(body, textLength, currentIndex);
  const removeTables = deleteTables(body, textLength, currentIndex);
  const removeCustomRanges = deleteCustomRanges(body, textLength, currentIndex);
  const removeCustomDecorations = deleteCustomDecorations(body, textLength, currentIndex);
  let removeDataStream = "";
  if (dataStream) {
    body.dataStream = deleteContent(dataStream, startIndex, endIndex);
    removeDataStream = dataStream.slice(startIndex, endIndex);
  }
  return {
    dataStream: removeDataStream,
    textRuns: removeTextRuns,
    paragraphs: removeParagraphs,
    sectionBreaks: removeSectionBreaks,
    customBlocks: removeCustomBlocks,
    tables: removeTables,
    customRanges: removeCustomRanges,
    customDecorations: removeCustomDecorations
  };
}

// ../packages/core/src/docs/data-model/text-x/apply-utils/insert-apply.ts
function updateAttributeByInsert(body, insertBody, textLength, currentIndex) {
  body.dataStream = insertTextToContent(body.dataStream, currentIndex, insertBody.dataStream);
  insertTextRuns(body, insertBody, textLength, currentIndex);
  insertParagraphs(body, insertBody, textLength, currentIndex);
  insertSectionBreaks(body, insertBody, textLength, currentIndex);
  insertCustomBlocks(body, insertBody, textLength, currentIndex);
  insertTables(body, insertBody, textLength, currentIndex);
  insertCustomRanges(body, insertBody, textLength, currentIndex);
  insertCustomDecorations(body, insertBody, textLength, currentIndex);
}

// ../packages/core/src/docs/data-model/text-x/apply.ts
function updateApply(doc, updateBody, textLength, currentIndex, coverType = 0 /* COVER */) {
  return updateAttribute(doc, updateBody, textLength, currentIndex, coverType);
}
function deleteApply(doc, textLength, currentIndex) {
  if (textLength <= 0) {
    return { dataStream: "" };
  }
  return updateAttributeByDelete(doc, textLength, currentIndex);
}
function insertApply(doc, insertBody, textLength, currentIndex) {
  if (textLength === 0) {
    return;
  }
  updateAttributeByInsert(doc, insertBody, textLength, currentIndex);
}
function textXApply(doc, actions) {
  const memoryCursor = new MemoryCursor();
  memoryCursor.reset();
  actions.forEach((action) => {
    const clonedAction = Tools.deepClone(action);
    switch (clonedAction.t) {
      case "r" /* RETAIN */: {
        const { coverType, body, len } = clonedAction;
        if (body != null) {
          updateApply(doc, body, len, memoryCursor.cursor, coverType);
        }
        memoryCursor.moveCursor(len);
        break;
      }
      case "i" /* INSERT */: {
        const { body, len } = clonedAction;
        insertApply(doc, body, len, memoryCursor.cursor);
        memoryCursor.moveCursor(len);
        break;
      }
      case "d" /* DELETE */: {
        const { len } = clonedAction;
        deleteApply(doc, len, memoryCursor.cursor);
        break;
      }
      default:
        throw new Error(`Unknown action type for action: ${clonedAction}.`);
    }
  });
  return doc;
}

// ../packages/core/src/docs/data-model/text-x/transform-utils.ts
function transformTextRuns(originTextRuns, targetTextRuns, originCoverType, targetCoverType, transformType) {
  if (originTextRuns == null || targetTextRuns == null) {
    return targetTextRuns;
  }
  if (originTextRuns.length === 0 || targetTextRuns.length === 0) {
    return [];
  }
  targetTextRuns = Tools.deepClone(targetTextRuns);
  originTextRuns = Tools.deepClone(originTextRuns);
  const newUpdateTextRuns = [];
  const updateLength = targetTextRuns.length;
  const removeLength = originTextRuns.length;
  let updateIndex = 0;
  let removeIndex = 0;
  let pending = null;
  function pushPendingAndReturnStatus() {
    if (pending) {
      newUpdateTextRuns.push(pending);
      pending = null;
      return true;
    }
    return false;
  }
  while (updateIndex < updateLength && removeIndex < removeLength) {
    const { st: updateSt, ed: updateEd, ts: targetStyle } = targetTextRuns[updateIndex];
    const { st: removeSt, ed: removeEd, ts: originStyle, sId } = originTextRuns[removeIndex];
    let newTs = {};
    if (transformType === 0 /* COVER */) {
      newTs = { ...targetStyle };
      if (originCoverType === 0 /* COVER */ && targetCoverType === 1 /* REPLACE */ && originStyle) {
        newTs = Object.assign({}, originStyle, newTs);
      }
    } else {
      newTs = { ...targetStyle };
      if (originCoverType === 1 /* REPLACE */) {
        if (targetCoverType === 1 /* REPLACE */) {
          newTs = { ...originStyle };
        } else {
          if (targetStyle && originStyle) {
            const keys = Object.keys(targetStyle);
            for (const key of keys) {
              if (originStyle[key]) {
                delete newTs[key];
              }
            }
          }
        }
      } else {
        if (targetCoverType === 1 /* REPLACE */) {
          if (originStyle) {
            const keys = Object.keys(originStyle);
            for (const key of keys) {
              if (originStyle[key] !== void 0) {
                newTs[key] = originStyle[key];
              }
            }
          }
        } else {
          if (originStyle) {
            const keys = Object.keys(originStyle);
            for (const key of keys) {
              if (newTs[key] !== void 0) {
                delete newTs[key];
              }
            }
          }
        }
      }
    }
    if (updateEd < removeSt) {
      if (!pushPendingAndReturnStatus()) {
        newUpdateTextRuns.push(targetTextRuns[updateIndex]);
      }
      updateIndex++;
    } else if (removeEd < updateSt) {
      if (!pushPendingAndReturnStatus()) {
        newUpdateTextRuns.push(originTextRuns[removeIndex]);
      }
      removeIndex++;
    } else {
      const newTextRun = {
        st: Math.min(updateSt, removeSt),
        ed: Math.max(updateSt, removeSt),
        ts: updateSt < removeSt ? { ...targetStyle } : { ...originStyle },
        sId: updateSt < removeSt ? void 0 : sId
      };
      if (newTextRun.ed > newTextRun.st) {
        newUpdateTextRuns.push();
      }
      newUpdateTextRuns.push({
        st: Math.max(updateSt, removeSt),
        ed: Math.min(updateEd, removeEd),
        ts: newTs,
        sId
      });
      if (updateEd < removeEd) {
        updateIndex++;
        originTextRuns[removeIndex].st = updateEd;
        if (originTextRuns[removeIndex].st === originTextRuns[removeIndex].ed) {
          removeIndex++;
        }
      } else {
        removeIndex++;
        targetTextRuns[updateIndex].st = removeEd;
        if (targetTextRuns[updateIndex].st === targetTextRuns[updateIndex].ed) {
          updateIndex++;
        }
      }
      const pendingTextRun = {
        st: Math.min(updateEd, removeEd),
        ed: Math.max(updateEd, removeEd),
        ts: updateEd < removeEd ? { ...originStyle } : { ...targetStyle },
        sId: updateEd < removeEd ? sId : void 0
      };
      pending = pendingTextRun.ed > pendingTextRun.st ? pendingTextRun : null;
    }
  }
  pushPendingAndReturnStatus();
  const tempTopTextRun = newUpdateTextRuns[newUpdateTextRuns.length - 1];
  const updateLastTextRun = targetTextRuns[updateLength - 1];
  const removeLastTextRun = originTextRuns[removeLength - 1];
  if (tempTopTextRun.ed !== Math.max(updateLastTextRun.ed, removeLastTextRun.ed)) {
    if (updateLastTextRun.ed > removeLastTextRun.ed) {
      newUpdateTextRuns.push(updateLastTextRun);
    } else {
      newUpdateTextRuns.push(removeLastTextRun);
    }
  }
  return normalizeTextRuns(newUpdateTextRuns, true);
}
function transformCustomRanges(originCustomRanges, targetCustomRanges, originCoverType, targetCoverType, transformType) {
  if (originCustomRanges == null || targetCustomRanges == null) {
    return targetCustomRanges;
  }
  if (originCustomRanges.length === 0 || targetCustomRanges.length === 0) {
    return [];
  }
  if (originCustomRanges.length > 1 || targetCustomRanges.length > 1) {
    throw new Error("CustomRanges is only supported transform for length one now.");
  }
  const originCustomRange = originCustomRanges[0];
  const targetCustomRange = targetCustomRanges[0];
  if (originCoverType === 1 /* REPLACE */) {
    return transformType === 1 /* COVER_ONLY_NOT_EXISTED */ ? [Tools.deepClone(originCustomRange)] : [Tools.deepClone(targetCustomRange)];
  } else {
    if (targetCoverType === 1 /* REPLACE */) {
      const customRange = Tools.deepClone(targetCustomRange);
      if (transformType === 1 /* COVER_ONLY_NOT_EXISTED */) {
        Object.assign(customRange, Tools.deepClone(originCustomRange));
      }
      return [customRange];
    } else {
      const customRange = Tools.deepClone(targetCustomRange);
      if (transformType === 1 /* COVER_ONLY_NOT_EXISTED */) {
        Object.assign(customRange, Tools.deepClone(originCustomRange));
      }
      return [customRange];
    }
  }
}
function transformParagraph(originParagraph, targetParagraph, originCoverType, targetCoverType, transformType) {
  const paragraph = {
    startIndex: targetParagraph.startIndex
  };
  if (targetParagraph.paragraphStyle) {
    paragraph.paragraphStyle = Tools.deepClone(targetParagraph.paragraphStyle);
    if (originParagraph.paragraphStyle) {
      if (originCoverType === 1 /* REPLACE */) {
        if (targetCoverType === 1 /* REPLACE */) {
          if (transformType === 1 /* COVER_ONLY_NOT_EXISTED */) {
            paragraph.paragraphStyle = {
              ...originParagraph.paragraphStyle
            };
          }
        } else {
          if (transformType === 1 /* COVER_ONLY_NOT_EXISTED */) {
            const keys = Object.keys(originParagraph.paragraphStyle);
            for (const key of keys) {
              if (originParagraph.paragraphStyle[key] !== void 0) {
                paragraph.paragraphStyle[key] = originParagraph.paragraphStyle[key];
              }
            }
          } else {
            const keys = Object.keys(originParagraph.paragraphStyle);
            for (const key of keys) {
              if (paragraph.paragraphStyle[key] === void 0) {
                paragraph.paragraphStyle[key] = originParagraph.paragraphStyle[key];
              }
            }
          }
        }
      } else {
        if (targetCoverType === 1 /* REPLACE */) {
          if (transformType === 1 /* COVER_ONLY_NOT_EXISTED */) {
            const keys = Object.keys(originParagraph.paragraphStyle);
            for (const key of keys) {
              if (originParagraph.paragraphStyle[key] !== void 0) {
                paragraph.paragraphStyle[key] = originParagraph.paragraphStyle[key];
              }
            }
          } else {
            const keys = Object.keys(originParagraph.paragraphStyle);
            for (const key of keys) {
              if (paragraph.paragraphStyle[key] === void 0) {
                paragraph.paragraphStyle[key] = originParagraph.paragraphStyle[key];
              }
            }
          }
        } else {
          if (transformType === 1 /* COVER_ONLY_NOT_EXISTED */) {
            const keys = Object.keys(originParagraph.paragraphStyle);
            for (const key of keys) {
              if (paragraph.paragraphStyle[key]) {
                delete paragraph.paragraphStyle[key];
              }
            }
          }
        }
      }
    }
  }
  if (originCoverType === 1 /* REPLACE */ && targetCoverType === 1 /* REPLACE */) {
    paragraph.bullet = transformType === 1 /* COVER_ONLY_NOT_EXISTED */ ? Tools.deepClone(originParagraph.bullet) : Tools.deepClone(targetParagraph.bullet);
  } else {
    if (originParagraph.bullet === void 0) {
      paragraph.bullet = Tools.deepClone(targetParagraph.bullet);
    } else {
      if (originCoverType === 1 /* REPLACE */ || targetCoverType === 1 /* REPLACE */) {
        paragraph.bullet = transformType === 0 /* COVER */ && targetParagraph.bullet ? Tools.deepClone(targetParagraph.bullet) : Tools.deepClone(originParagraph.bullet);
      } else {
        if (transformType === 0 /* COVER */ && targetParagraph.bullet !== void 0) {
          paragraph.bullet = Tools.deepClone(targetParagraph.bullet);
        }
      }
    }
  }
  return paragraph;
}
function transformCustomDecorations(originCustomDecorations, targetCustomDecorations) {
  if (originCustomDecorations == null || targetCustomDecorations == null) {
    return targetCustomDecorations;
  }
  if (originCustomDecorations.length === 0 || targetCustomDecorations.length === 0) {
    return Tools.deepClone(targetCustomDecorations);
  }
  const customDecorations = [];
  for (const decoration of targetCustomDecorations) {
    const { id, type: type2 } = decoration;
    let pushed = false;
    for (const originDecoration of originCustomDecorations) {
      if (originDecoration.id === id) {
        if (originDecoration.type === 9999 /* DELETED */ || type2 === 9999 /* DELETED */) {
          pushed = true;
          customDecorations.push({
            ...decoration,
            type: 9999 /* DELETED */
          });
        }
        break;
      }
    }
    if (!pushed) {
      customDecorations.push(decoration);
    }
  }
  return customDecorations;
}
function transformBody(thisAction, otherAction, priority = false) {
  const { body: thisBody, coverType: thisCoverType = 0 /* COVER */ } = thisAction;
  const { body: otherBody, coverType: otherCoverType = 0 /* COVER */ } = otherAction;
  if (thisBody == null || thisBody.dataStream !== "" || otherBody == null || otherBody.dataStream !== "") {
    throw new Error("Data stream is not supported in retain transform.");
  }
  const retBody = {
    dataStream: ""
  };
  const coverType = otherCoverType;
  const {
    textRuns: thisTextRuns,
    paragraphs: thisParagraphs = [],
    customRanges: thisCustomRanges,
    customDecorations: thisCustomDecorations
  } = thisBody;
  const {
    textRuns: otherTextRuns,
    paragraphs: otherParagraphs = [],
    customRanges: otherCustomRanges,
    customDecorations: otherCustomDecorations
  } = otherBody;
  const textRuns = transformTextRuns(
    thisTextRuns,
    otherTextRuns,
    thisCoverType,
    otherCoverType,
    priority ? 1 /* COVER_ONLY_NOT_EXISTED */ : 0 /* COVER */
  );
  if (textRuns) {
    retBody.textRuns = textRuns;
  }
  const customRanges = transformCustomRanges(
    thisCustomRanges,
    otherCustomRanges,
    thisCoverType,
    otherCoverType,
    priority ? 1 /* COVER_ONLY_NOT_EXISTED */ : 0 /* COVER */
  );
  if (customRanges) {
    retBody.customRanges = customRanges;
  }
  const customDecorations = transformCustomDecorations(
    thisCustomDecorations,
    otherCustomDecorations
  );
  if (customDecorations) {
    retBody.customDecorations = customDecorations;
  }
  const paragraphs = [];
  let thisIndex = 0;
  let otherIndex = 0;
  while (thisIndex < thisParagraphs.length && otherIndex < otherParagraphs.length) {
    const thisParagraph = thisParagraphs[thisIndex];
    const otherParagraph = otherParagraphs[otherIndex];
    const { startIndex: thisStart } = thisParagraph;
    const { startIndex: otherStart } = otherParagraph;
    if (thisStart === otherStart) {
      let paragraph = {
        startIndex: thisStart
      };
      if (priority) {
        paragraph = transformParagraph(
          thisParagraph,
          otherParagraph,
          thisCoverType,
          otherCoverType,
          1 /* COVER_ONLY_NOT_EXISTED */
        );
      } else {
        paragraph = transformParagraph(
          thisParagraph,
          otherParagraph,
          thisCoverType,
          otherCoverType,
          0 /* COVER */
        );
      }
      paragraphs.push(paragraph);
      thisIndex++;
      otherIndex++;
    } else if (thisStart < otherStart) {
      thisIndex++;
    } else {
      paragraphs.push(Tools.deepClone(otherParagraph));
      otherIndex++;
    }
  }
  if (otherIndex < otherParagraphs.length) {
    paragraphs.push(...otherParagraphs.slice(otherIndex));
  }
  if (paragraphs.length) {
    retBody.paragraphs = paragraphs;
  }
  return {
    coverType,
    body: retBody
  };
}

// ../packages/core/src/docs/data-model/text-x/text-x.ts
function onlyHasDataStream(body) {
  return Object.keys(body).length === 1;
}
var _TextX = class _TextX {
  constructor() {
    __publicField(this, "_actions", []);
  }
  static apply(doc, actions) {
    return textXApply(doc, actions);
  }
  // eslint-disable-next-line complexity
  static compose(thisActions, otherActions) {
    const thisIter = new ActionIterator(thisActions);
    const otherIter = new ActionIterator(otherActions);
    const textX = new _TextX();
    while (thisIter.hasNext() || otherIter.hasNext()) {
      if (otherIter.peekType() === "i" /* INSERT */) {
        textX.push(otherIter.next());
      } else if (thisIter.peekType() === "d" /* DELETE */) {
        textX.push(thisIter.next());
      } else {
        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
        const thisAction = thisIter.next(length);
        const otherAction = otherIter.next(length);
        if (thisAction.t === "i" /* INSERT */ && otherAction.t === "r" /* RETAIN */) {
          if (otherAction.body == null) {
            textX.push(thisAction);
          } else {
            textX.push({
              ...thisAction,
              body: composeBody(thisAction.body, otherAction.body, otherAction.coverType)
            });
          }
        } else if (thisAction.t === "r" /* RETAIN */ && otherAction.t === "r" /* RETAIN */) {
          if (thisAction.body == null && otherAction.body == null) {
            textX.push(thisAction.len !== Number.POSITIVE_INFINITY ? thisAction : otherAction);
          } else if (thisAction.body && otherAction.body) {
            const coverType = thisAction.coverType === 1 /* REPLACE */ || otherAction.coverType === 1 /* REPLACE */ ? 1 /* REPLACE */ : 0 /* COVER */;
            textX.push({
              ...thisAction,
              t: "r" /* RETAIN */,
              coverType,
              body: composeBody(thisAction.body, otherAction.body, otherAction.coverType)
            });
          } else {
            textX.push(thisAction.body ? thisAction : otherAction);
          }
        } else if (thisAction.t === "r" /* RETAIN */ && otherAction.t === "d" /* DELETE */) {
          textX.push(otherAction);
        } else if (thisAction.t === "i" /* INSERT */ && otherAction.t === "d" /* DELETE */) {
        }
      }
    }
    textX.trimEndUselessRetainAction();
    return textX.serialize();
  }
  /**
   * |(this↓ \| other→) | **insert** | **retain** | **delete** |
   * | ---------------- | ---------- | ---------- | ---------- |
   * |    **insert**    |   Case 1   |   Case 2   |   Case 2   |
   * |    **retain**    |   Case 1   |   Case 5   |   Case 4   |
   * |    **delete**    |   Case 1   |   Case 3   |   Case 3   |
   *
   * Case 1: When the other action type is an insert operation,
   *         the insert operation is retained regardless of the type of action this action
   * Case 2: When this action type is an insert operation and the other action type is a
   *         non-insert operation, you need to retain the length of this action insert
   * Case 3: When this action is a delete operation, there are two scenarios:
   *      1) When other is a delete operation, since it is a delete operation, this has
   *         already been deleted, so the target does not need to be in delete, and it can
   *         be continued directly
   *      2) When other is the retain operation, although this action delete occurs first,
   *         the delete priority is higher, so the delete operation is retained, and the origin
   *         delete has been applied, so it is directly continued
   * Case 4: other is the delete operation, this is the retain operation, and the target delete operation
   *         is kept
   * Case 5: When both other and this are retain operations
   *      1) If the other body attribute does not exist, directly retain length
   *      2) If the other body property exists, then execute the TransformBody logic to override it
   */
  // priority - if true, this actions takes priority over other, that is, this actions are considered to happen "first".
  // thisActions is the target action.
  static transform(thisActions, otherActions, priority = "right") {
    return this._transform(otherActions, thisActions, priority === "left" ? "right" : "left");
  }
  // otherActions is the actions to be transformed.
  static _transform(thisActions, otherActions, priority = "right") {
    const thisIter = new ActionIterator(thisActions);
    const otherIter = new ActionIterator(otherActions);
    const textX = new _TextX();
    while (thisIter.hasNext() || otherIter.hasNext()) {
      if (thisIter.peekType() === "i" /* INSERT */ && (priority === "left" || otherIter.peekType() !== "i" /* INSERT */)) {
        const thisAction = thisIter.next();
        textX.retain(thisAction.len);
      } else if (otherIter.peekType() === "i" /* INSERT */) {
        textX.push(otherIter.next());
      } else {
        const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
        const thisAction = thisIter.next(length);
        const otherAction = otherIter.next(length);
        if (thisAction.t === "d" /* DELETE */) {
          continue;
        }
        if (otherAction.t === "d" /* DELETE */) {
          textX.push(otherAction);
          continue;
        }
        if (thisAction.body == null || otherAction.body == null) {
          textX.push(otherAction);
        } else {
          const { coverType, body } = transformBody(thisAction, otherAction, priority === "left");
          textX.push({
            ...otherAction,
            t: "r" /* RETAIN */,
            coverType,
            body
          });
        }
      }
    }
    textX.trimEndUselessRetainAction();
    return textX.serialize();
  }
  /**
   * Used to transform selection. Why not named transformSelection?
   * Because Univer Doc supports multiple Selections in one document, user need to encapsulate transformSelections at the application layer.
   */
  static transformPosition(thisActions, index, priority = false) {
    const thisIter = new ActionIterator(thisActions);
    let offset = 0;
    while (thisIter.hasNext() && offset <= index) {
      const length = thisIter.peekLength();
      const nextType = thisIter.peekType();
      thisIter.next();
      if (nextType === "d" /* DELETE */) {
        index -= Math.min(length, index - offset);
        continue;
      } else if (nextType === "i" /* INSERT */ && (offset < index || !priority)) {
        index += length;
      }
      offset += length;
    }
    return index;
  }
  static isNoop(actions) {
    return actions.length === 0;
  }
  static invert(actions) {
    const invertedActions = [];
    for (const action of actions) {
      if (action.t === "i" /* INSERT */) {
        invertedActions.push({
          t: "d" /* DELETE */,
          len: action.len,
          body: action.body
        });
      } else if (action.t === "d" /* DELETE */) {
        if (action.body == null) {
          throw new Error("Can not invert DELETE action without body property, makeInvertible must be called first.");
        }
        invertedActions.push({
          t: "i" /* INSERT */,
          body: action.body,
          len: action.len
        });
      } else {
        if (action.body != null) {
          if (action.oldBody == null) {
            throw new Error("Can not invert RETAIN action without oldBody property, makeInvertible must be called first.");
          }
          invertedActions.push({
            t: "r" /* RETAIN */,
            body: action.oldBody,
            oldBody: action.body,
            len: action.len,
            coverType: 1 /* REPLACE */
          });
        } else {
          invertedActions.push(action);
        }
      }
    }
    return invertedActions;
  }
  static makeInvertible(actions, doc) {
    const invertibleActions = [];
    let index = 0;
    for (const action of actions) {
      if (action.t === "d" /* DELETE */ && (action.body == null || action.body && action.body.dataStream.length !== action.len)) {
        const body = getBodySlice(doc, index, index + action.len, false);
        action.len = body.dataStream.length;
        action.body = body;
      }
      if (action.t === "r" /* RETAIN */ && action.body != null) {
        const body = getBodySlice(doc, index, index + action.len, true);
        action.oldBody = {
          ...body,
          dataStream: ""
        };
        action.len = body.dataStream.length;
      }
      invertibleActions.push(action);
      if (action.t !== "i" /* INSERT */) {
        index += action.len;
      }
    }
    return invertibleActions;
  }
  insert(len, body) {
    const insertAction = {
      t: "i" /* INSERT */,
      body,
      len
    };
    this.push(insertAction);
    return this;
  }
  retain(len, body, coverType) {
    const retainAction = {
      t: "r" /* RETAIN */,
      len
    };
    if (body != null) {
      retainAction.body = body;
    }
    if (coverType != null) {
      retainAction.coverType = coverType;
    }
    this.push(retainAction);
    return this;
  }
  delete(len) {
    const deleteAction = {
      t: "d" /* DELETE */,
      len
    };
    this.push(deleteAction);
    return this;
  }
  empty() {
    this._actions = [];
    return this;
  }
  serialize() {
    return this._actions;
  }
  // eslint-disable-next-line complexity
  push(...args) {
    if (args.length > 1) {
      for (const ac of args) {
        this.push(ac);
      }
      return this;
    }
    let index = this._actions.length;
    let lastAction = this._actions[index - 1];
    const newAction = Tools.deepClone(args[0]);
    if (newAction.t === "r" /* RETAIN */ && newAction.len === 0 && newAction.body == null) {
      return this;
    }
    if (typeof lastAction === "object") {
      if (lastAction.t === "d" /* DELETE */ && newAction.t === "d" /* DELETE */) {
        lastAction.len += newAction.len;
        return this;
      }
      if (lastAction.t === "d" /* DELETE */ && newAction.t === "i" /* INSERT */) {
        index -= 1;
        lastAction = this._actions[index - 1];
        if (lastAction == null) {
          this._actions.unshift(newAction);
          return this;
        }
      }
      if (lastAction.t === "r" /* RETAIN */ && newAction.t === "r" /* RETAIN */ && lastAction.body == null && newAction.body == null) {
        lastAction.len += newAction.len;
        return this;
      }
      if (lastAction.t === "i" /* INSERT */ && onlyHasDataStream(lastAction.body) && newAction.t === "i" /* INSERT */ && onlyHasDataStream(newAction.body)) {
        lastAction.len += newAction.len;
        lastAction.body.dataStream += newAction.body.dataStream;
        return this;
      }
    }
    if (index === this._actions.length) {
      this._actions.push(newAction);
    } else {
      this._actions.splice(index, 0, newAction);
    }
    return this;
  }
  trimEndUselessRetainAction() {
    let lastAction = this._actions[this._actions.length - 1];
    while (lastAction && lastAction.t === "r" /* RETAIN */ && isUselessRetainAction(lastAction)) {
      this._actions.pop();
      lastAction = this._actions[this._actions.length - 1];
    }
    return this;
  }
};
// static name = 'text-x';
__publicField(_TextX, "id", "text-x");
__publicField(_TextX, "uri", "https://github.com/dream-num/univer#text-x");
var TextX = _TextX;
Object.defineProperty(TextX, "name", {
  value: "text-x"
});

// ../packages/core/src/docs/data-model/json-x/json-x.ts
var _JSONX = class _JSONX {
  static registerSubtype(subType) {
    var _a2;
    if (subType == null || this._subTypes.has(subType.name) && ((_a2 = this._subTypes.get(subType.name)) == null ? void 0 : _a2.id) !== TextX.id) {
      return;
    }
    this._subTypes.set(subType.name, subType);
    json1.type.registerSubtype(subType);
  }
  static apply(doc, actions) {
    if (json1.type.isNoop(actions)) {
      return;
    }
    return json1.type.apply(doc, actions);
  }
  static compose(thisActions, otherActions) {
    return json1.type.compose(thisActions, otherActions);
  }
  static transform(thisActions, otherActions, priority) {
    return json1.type.transform(thisActions, otherActions, priority);
  }
  // Use to transform cursor position, just call TextXPro.transformPosition.
  static transformPosition(thisActions, index, priority = "right") {
    if (thisActions && thisActions.length === 2 && thisActions[0] === "body" && thisActions[1].et === TextX.name) {
      return TextX.transformPosition(thisActions[1].e, index, priority === "left");
    }
    return index;
  }
  static invertWithDoc(actions, doc) {
    return json1.type.invertWithDoc(actions, doc);
  }
  static isNoop(actions) {
    return json1.type.isNoop(actions);
  }
  static getInstance() {
    if (this._instance == null) {
      this._instance = new _JSONX();
    }
    return this._instance;
  }
  // eslint-disable-next-line ts/no-explicit-any
  removeOp(path, value) {
    return json1.removeOp(path, value);
  }
  moveOp(from, to) {
    return json1.moveOp(from, to);
  }
  // eslint-disable-next-line ts/no-explicit-any
  insertOp(path, value) {
    return json1.insertOp(path, value);
  }
  // eslint-disable-next-line ts/no-explicit-any
  replaceOp(path, oldVal, newVal) {
    return json1.replaceOp(path, oldVal, newVal);
  }
  editOp(subOp, path = ["body"]) {
    return json1.editOp(path, TextX.name, subOp);
  }
};
// static name = 'json-x';
__publicField(_JSONX, "uri", "https://github.com/dream-num/univer#json-x");
__publicField(_JSONX, "_subTypes", /* @__PURE__ */ new Map());
__publicField(_JSONX, "_instance", null);
var JSONX = _JSONX;
JSONX.registerSubtype(TextX);

// ../packages/core/src/docs/data-model/document-data-model.ts
var DEFAULT_DOC = {
  id: "default_doc",
  documentStyle: {}
};
var DocumentDataModelSimple = class extends UnitModel {
  constructor(snapshot) {
    var _a2;
    super();
    __publicField(this, "type", O.UNIVER_DOC);
    __publicField(this, "_name$", new import_rxjs5.BehaviorSubject(""));
    __publicField(this, "name$", this._name$.asObservable());
    __publicField(this, "snapshot");
    this.snapshot = { ...DEFAULT_DOC, ...snapshot };
    this._name$.next((_a2 = this.snapshot.title) != null ? _a2 : "No Title");
  }
  getUnitId() {
    throw new Error("Method not implemented.");
  }
  getRev() {
    var _a2;
    return (_a2 = this.snapshot.rev) != null ? _a2 : 1;
  }
  incrementRev() {
    this.snapshot.rev = this.getRev() + 1;
  }
  setRev(rev) {
    this.snapshot.rev = rev;
  }
  setName(name) {
    this.snapshot.title = name;
    this._name$.next(name);
  }
  get drawings() {
    return this.snapshot.drawings;
  }
  get documentStyle() {
    return this.snapshot.documentStyle;
  }
  get lists() {
    return this.snapshot.lists;
  }
  get zoomRatio() {
    var _a2;
    return ((_a2 = this.snapshot.settings) == null ? void 0 : _a2.zoomRatio) || 1;
  }
  resetDrawing(drawings, drawingsOrder) {
    this.snapshot.drawings = drawings;
    this.snapshot.drawingsOrder = drawingsOrder;
  }
  getBody() {
    return this.snapshot.body;
  }
  getSnapshot() {
    return this.snapshot;
  }
  getBulletPresetList() {
    var _a2;
    const customLists = (_a2 = this.snapshot.lists) != null ? _a2 : {};
    const lists = {
      ...PRESET_LIST_TYPE,
      ...customLists
    };
    return lists;
  }
  updateDocumentId(unitId) {
    this.snapshot.id = unitId;
  }
  updateDocumentRenderConfig(config2) {
    const { documentStyle } = this.snapshot;
    if (documentStyle.renderConfig == null) {
      documentStyle.renderConfig = config2;
    } else {
      documentStyle.renderConfig = {
        ...documentStyle.renderConfig,
        ...config2
      };
    }
  }
  updateDocumentStyle(config2) {
    if (this.snapshot.documentStyle == null) {
      this.snapshot.documentStyle = config2;
    } else {
      this.snapshot.documentStyle = {
        ...this.snapshot.documentStyle,
        ...config2
      };
    }
  }
  updateDocumentDataMargin(data) {
    const { t, l, b, r } = data;
    const { documentStyle } = this.snapshot;
    if (t != null) {
      documentStyle.marginTop = t;
    }
    if (l != null) {
      documentStyle.marginLeft = l;
    }
    if (b != null) {
      documentStyle.marginBottom = b;
    }
    if (r != null) {
      documentStyle.marginRight = r;
    }
  }
  updateDocumentDataPageSize(width, height) {
    const { documentStyle } = this.snapshot;
    if (!documentStyle.pageSize) {
      width = width != null ? width : Number.POSITIVE_INFINITY;
      height = height != null ? height : Number.POSITIVE_INFINITY;
      documentStyle.pageSize = {
        width,
        height
      };
      return;
    }
    if (width !== void 0) {
      documentStyle.pageSize.width = width;
    }
    if (height !== void 0) {
      documentStyle.pageSize.height = height;
    }
  }
  updateDrawing(id, config2) {
    const { drawings } = this;
    const { width, height, left, top } = config2;
    const drawing = drawings == null ? void 0 : drawings[id];
    if (!drawing) {
      return;
    }
    const objectTransform = drawing.docTransform;
    objectTransform.size.width = width;
    objectTransform.size.height = height;
    objectTransform.positionH.posOffset = left;
    objectTransform.positionV.posOffset = top;
  }
  setZoomRatio(zoomRatio = 1) {
    if (this.snapshot.settings == null) {
      this.snapshot.settings = {
        zoomRatio
      };
    } else {
      this.snapshot.settings.zoomRatio = 1;
    }
  }
  setDisabled(disabled) {
    this.snapshot.disabled = disabled;
  }
  getDisabled() {
    return this.snapshot.disabled;
  }
};
var DocumentDataModel = class _DocumentDataModel extends DocumentDataModelSimple {
  constructor(snapshot) {
    var _a2, _b2;
    super(Tools.isEmptyObject(snapshot) ? getEmptySnapshot() : snapshot);
    __publicField(this, "_unitId");
    __publicField(this, "headerModelMap", /* @__PURE__ */ new Map());
    __publicField(this, "footerModelMap", /* @__PURE__ */ new Map());
    __publicField(this, "change$", new import_rxjs5.BehaviorSubject(0));
    const UNIT_ID_LENGTH = 6;
    this._unitId = (_a2 = this.snapshot.id) != null ? _a2 : Tools.generateRandomId(UNIT_ID_LENGTH);
    this._initializeHeaderFooterModel();
    this._name$.next((_b2 = this.snapshot.title) != null ? _b2 : "");
  }
  dispose() {
    super.dispose();
    this.headerModelMap.forEach((header) => {
      header.dispose();
    });
    this.footerModelMap.forEach((footer) => {
      footer.dispose();
    });
    this._name$.complete();
  }
  getDrawings() {
    return this.snapshot.drawings;
  }
  getDrawingsOrder() {
    return this.snapshot.drawingsOrder;
  }
  getCustomRanges() {
    var _a2;
    return (_a2 = this.snapshot.body) == null ? void 0 : _a2.customRanges;
  }
  getCustomDecorations() {
    var _a2;
    return (_a2 = this.snapshot.body) == null ? void 0 : _a2.customDecorations;
  }
  getSettings() {
    return this.snapshot.settings;
  }
  // TODO: @JOCS do not use reset, please use apply to modify the snapshot.
  reset(snapshot) {
    if (snapshot.id && snapshot.id !== this._unitId) {
      throw new Error("Cannot reset a document model with a different unit id!");
    }
    this.snapshot = { ...DEFAULT_DOC, ...snapshot };
    this._initializeHeaderFooterModel();
    this.change$.next(this.change$.value + 1);
  }
  getSelfOrHeaderFooterModel(segmentId) {
    if (segmentId != null) {
      if (this.headerModelMap.has(segmentId)) {
        return this.headerModelMap.get(segmentId);
      }
      if (this.footerModelMap.has(segmentId)) {
        return this.footerModelMap.get(segmentId);
      }
    }
    return this;
  }
  getUnitId() {
    return this._unitId;
  }
  apply(actions) {
    if (JSONX.isNoop(actions)) {
      return;
    }
    this.snapshot = JSONX.apply(this.snapshot, actions);
    if (actions == null ? void 0 : actions.some((a2) => Array.isArray(a2) && ((a2 == null ? void 0 : a2[0]) === "headers" || (a2 == null ? void 0 : a2[0]) === "footers"))) {
      this.headerModelMap.clear();
      this.footerModelMap.clear();
      this._initializeHeaderFooterModel();
    }
    this.change$.next(this.change$.value + 1);
    return this.snapshot;
  }
  sliceBody(startOffset, endOffset, type2 = 0 /* copy */) {
    const body = this.getBody();
    if (body == null) {
      return;
    }
    return getBodySlice(body, startOffset, endOffset, false, type2);
  }
  _initializeHeaderFooterModel() {
    const { headers, footers } = this.getSnapshot();
    if (headers) {
      for (const headerId in headers) {
        const header = headers[headerId];
        this.headerModelMap.set(headerId, new _DocumentDataModel(header));
        this.headerModelMap.get(headerId).updateDocumentId(this.getUnitId());
      }
    }
    if (footers) {
      for (const footerId in footers) {
        const footer = footers[footerId];
        this.footerModelMap.set(footerId, new _DocumentDataModel(footer));
        this.footerModelMap.get(footerId).updateDocumentId(this.getUnitId());
      }
    }
  }
  updateDocumentId(unitId) {
    super.updateDocumentId(unitId);
    this._unitId = unitId;
  }
  getPlainText() {
    var _a2, _b2;
    return getPlainText((_b2 = (_a2 = this.getBody()) == null ? void 0 : _a2.dataStream) != null ? _b2 : "");
  }
};

// ../packages/core/src/docs/data-model/text-x/build-utils/custom-decoration.ts
function addCustomDecorationTextX(param) {
  const { ranges, id, type: type2 } = param;
  const textX = new TextX();
  let cursor = 0;
  for (let i = 0; i < ranges.length; i++) {
    const range = ranges[i];
    const { startOffset: start, endOffset: end } = range;
    if (start > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: start - cursor
      });
    }
    textX.push({
      t: "r" /* RETAIN */,
      body: {
        dataStream: "",
        customDecorations: [{
          id,
          type: type2,
          startIndex: 0,
          endIndex: end - start - 1
        }]
      },
      len: end - start
    });
    cursor = end;
  }
  return textX;
}
function deleteCustomDecorationTextX(params) {
  var _a2, _b2, _c;
  const { id, segmentId, documentDataModel } = params;
  const body = documentDataModel == null ? void 0 : documentDataModel.getBody();
  if (!documentDataModel || !body) {
    return false;
  }
  const decoration = (_c = (_b2 = (_a2 = documentDataModel.getSelfOrHeaderFooterModel(segmentId)) == null ? void 0 : _a2.getBody()) == null ? void 0 : _b2.customDecorations) == null ? void 0 : _c.find((d) => d.id === id);
  if (!decoration) {
    return false;
  }
  const textX = new TextX();
  const { startIndex, endIndex } = decoration;
  const len = endIndex - startIndex + 1;
  textX.push({
    t: "r" /* RETAIN */,
    len: startIndex
  });
  textX.push({
    t: "r" /* RETAIN */,
    len,
    body: {
      dataStream: "",
      customDecorations: [
        {
          startIndex: 0,
          endIndex: len - 1,
          id,
          type: 9999 /* DELETED */
        }
      ]
    }
  });
  return textX;
}

// ../packages/core/src/docs/data-model/text-x/build-utils/custom-range.ts
function isIntersecting(line1Start, line1End, line2Start, line2End) {
  if (line1Start <= line2Start && line1End >= line2Start || line1Start >= line2Start && line1Start <= line2End) {
    return true;
  }
  return false;
}
function getCustomRangesInterestsWithSelection(range, customRanges) {
  const result = [];
  for (let i = 0, len = customRanges.length; i < len; i++) {
    const customRange = customRanges[i];
    if (range.collapsed) {
      if (customRange.startIndex < range.startOffset && range.startOffset <= customRange.endIndex) {
        result.push(customRange);
      }
    } else {
      if (isIntersecting(range.startOffset, range.endOffset - 1, customRange.startIndex, customRange.endIndex)) {
        result.push(customRange);
      }
    }
  }
  return result;
}
function copyCustomRange(range) {
  return {
    ...Tools.deepClone(range),
    rangeId: generateRandomId()
  };
}
function excludePointsFromRange(range, points) {
  const newRanges = [];
  let start = range[0];
  for (const point of points) {
    if (point < range[0] || point > range[1]) {
      continue;
    }
    if (start < point) {
      newRanges.push([start, point - 1]);
    }
    start = point + 1;
  }
  if (start <= range[1]) {
    newRanges.push([start, range[1]]);
  }
  return newRanges;
}
function getIntersectingCustomRanges(startIndex, endIndex, customRanges, rangeType) {
  const relativeCustomRanges = [];
  for (let i = 0, len = customRanges.length; i < len; i++) {
    const customRange = customRanges[i];
    if ((rangeType === void 0 || customRange.rangeType === rangeType) && Math.max(customRange.startIndex, startIndex) <= Math.min(customRange.endIndex, endIndex)) {
      relativeCustomRanges.push({ ...customRange });
    }
    if (customRange.startIndex > endIndex) {
      break;
    }
  }
  return relativeCustomRanges;
}
function getSelectionForAddCustomRange(range, body) {
  var _a2, _b2, _c, _d, _e;
  const ranges = getIntersectingCustomRanges(range.startOffset, range.collapsed ? range.startOffset : range.endOffset - 1, (_a2 = body.customRanges) != null ? _a2 : []);
  const startOffset = Math.min(range.startOffset, (_c = (_b2 = ranges[0]) == null ? void 0 : _b2.startIndex) != null ? _c : Infinity);
  const endOffset = Math.max(range.endOffset, ((_e = (_d = ranges[ranges.length - 1]) == null ? void 0 : _d.endIndex) != null ? _e : -Infinity) + 1);
  return {
    startOffset,
    endOffset,
    collapsed: startOffset === endOffset
  };
}

// ../packages/core/src/docs/data-model/text-x/build-utils/text-x-utils.ts
function deleteCustomRangeTextX(params) {
  var _a2, _b2, _c;
  const { rangeId, segmentId, documentDataModel, insert } = params;
  const range = (_b2 = (_a2 = documentDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a2.customRanges) == null ? void 0 : _b2.find((r) => r.rangeId === rangeId);
  if (!range) {
    return false;
  }
  const { startIndex, endIndex } = range;
  const textX = new TextX();
  const len = endIndex - startIndex + 1;
  textX.push({
    t: "r" /* RETAIN */,
    len: startIndex
  });
  textX.push({
    t: "r" /* RETAIN */,
    len,
    body: {
      dataStream: "",
      customRanges: []
    }
  });
  if (insert) {
    textX.push({
      t: "i" /* INSERT */,
      body: insert,
      len: insert.dataStream.length
    });
  }
  const end = endIndex + 1 + ((_c = insert == null ? void 0 : insert.dataStream.length) != null ? _c : 0);
  textX.selections = [{
    startOffset: end,
    endOffset: end,
    collapsed: true
  }];
  return textX;
}
function addCustomRangeTextX(param) {
  const { ranges, rangeId, rangeType, wholeEntity, properties, body } = param;
  let cursor = 0;
  const textX = new TextX();
  let changed = false;
  ranges.forEach((range) => {
    var _a2, _b2, _c;
    const actualRange = getSelectionForAddCustomRange(range, body);
    if (!actualRange) {
      return false;
    }
    if (!body) {
      return false;
    }
    const { startOffset, endOffset } = actualRange;
    const customRanges = (_a2 = body.customRanges) != null ? _a2 : [];
    const addCustomRange = (startIndex, endIndex, index) => {
      var _a3, _b3, _c2, _d;
      const relativeCustomRanges = getIntersectingCustomRanges(startIndex, endIndex, customRanges, rangeType);
      const rangeStartIndex = Math.min((_b3 = (_a3 = relativeCustomRanges[0]) == null ? void 0 : _a3.startIndex) != null ? _b3 : Infinity, startIndex);
      const rangeEndIndex = Math.max((_d = (_c2 = relativeCustomRanges[relativeCustomRanges.length - 1]) == null ? void 0 : _c2.endIndex) != null ? _d : -Infinity, endIndex);
      const customRange = {
        rangeId: index ? `${rangeId}$${index}` : rangeId,
        rangeType,
        startIndex: 0,
        endIndex: rangeEndIndex - rangeStartIndex,
        wholeEntity,
        properties: {
          ...properties
        }
      };
      textX.push({
        t: "r" /* RETAIN */,
        len: rangeStartIndex - cursor
      });
      textX.push({
        t: "r" /* RETAIN */,
        len: rangeEndIndex - rangeStartIndex + 1,
        body: {
          dataStream: "",
          customRanges: [customRange]
        },
        coverType: 0 /* COVER */
      });
      cursor = rangeEndIndex + 1;
    };
    const relativeParagraphs = ((_b2 = body.paragraphs) != null ? _b2 : []).filter((p) => p.startIndex < endOffset && p.startIndex > startOffset);
    const customBlocks = ((_c = body.customBlocks) != null ? _c : []).filter((block) => block.startIndex < endOffset && block.startIndex > startOffset);
    const newRanges = excludePointsFromRange([startOffset, endOffset - 1], [...relativeParagraphs.map((p) => p.startIndex), ...customBlocks.map((b) => b.startIndex)]);
    newRanges.forEach(([start, end], i) => addCustomRange(start, end, i));
    changed = true;
    textX.selections = [{
      startOffset: actualRange.endOffset,
      endOffset: actualRange.endOffset,
      collapsed: true
    }];
  });
  return changed ? textX : false;
}
function deleteSelectionTextX(selections, body, memoryCursor = 0, insertBody = null, keepBullet = true) {
  selections.sort((a2, b) => a2.startOffset - b.startOffset);
  const dos = [];
  const { paragraphs = [] } = body;
  const paragraphInRange = paragraphs == null ? void 0 : paragraphs.find(
    (p) => p.startIndex >= selections[0].startOffset && p.startIndex < selections[0].endOffset
  );
  let cursor = memoryCursor;
  selections.forEach((selection) => {
    const { startOffset, endOffset } = selection;
    if (startOffset > cursor) {
      dos.push({
        t: "r" /* RETAIN */,
        len: startOffset - cursor
      });
      cursor = startOffset;
    }
    if (cursor < endOffset) {
      dos.push({
        t: "d" /* DELETE */,
        len: endOffset - cursor
      });
      cursor = endOffset;
    }
  });
  if (insertBody) {
    dos.push({
      t: "i" /* INSERT */,
      body: insertBody,
      len: insertBody.dataStream.length
    });
  }
  if (paragraphInRange && keepBullet) {
    const nextParagraph = paragraphs.find((p) => p.startIndex - memoryCursor >= selections[selections.length - 1].endOffset - 1);
    if (nextParagraph) {
      if (nextParagraph.startIndex > cursor) {
        dos.push({
          t: "r" /* RETAIN */,
          len: nextParagraph.startIndex - cursor
        });
        cursor = nextParagraph.startIndex;
      }
      dos.push({
        t: "r" /* RETAIN */,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              ...nextParagraph,
              startIndex: 0,
              bullet: paragraphInRange == null ? void 0 : paragraphInRange.bullet
            }
          ]
        },
        coverType: 1 /* REPLACE */
      });
    }
  }
  return dos;
}
function retainSelectionTextX(selections, body, memoryCursor = 0) {
  const dos = [];
  let cursor = memoryCursor;
  selections.forEach((selection) => {
    const { startOffset, endOffset } = selection;
    if (startOffset > cursor) {
      dos.push({
        t: "r" /* RETAIN */,
        len: startOffset - cursor
      });
      cursor = startOffset;
    }
    if (endOffset > cursor) {
      dos.push({
        t: "r" /* RETAIN */,
        len: endOffset - cursor,
        body: {
          ...Tools.deepClone(body),
          dataStream: ""
        }
      });
      cursor = endOffset;
    }
  });
  return dos;
}
var replaceSelectionTextX = (params) => {
  var _a2;
  const { selection, body: insertBody, doc } = params;
  const segmentId = selection.segmentId;
  const body = (_a2 = doc.getSelfOrHeaderFooterModel(segmentId)) == null ? void 0 : _a2.getBody();
  if (!body) return false;
  const oldBody = selection.collapsed ? null : getBodySlice(body, selection.startOffset, selection.endOffset);
  const diffs = (0, import_fast_diff.default)(oldBody ? oldBody.dataStream : "", insertBody.dataStream);
  let cursor = 0;
  const actions = diffs.map(([type2, text]) => {
    switch (type2) {
      // retain
      case 0: {
        const action = {
          t: "r" /* RETAIN */,
          body: {
            ...getBodySlice(insertBody, cursor, cursor + text.length, false),
            dataStream: ""
          },
          len: text.length
        };
        cursor += text.length;
        return action;
      }
      // insert
      case 1: {
        const action = {
          t: "i" /* INSERT */,
          body: getBodySlice(insertBody, cursor, cursor + text.length),
          len: text.length
        };
        cursor += text.length;
        return action;
      }
      // delete
      default: {
        const action = {
          t: "d" /* DELETE */,
          len: text.length
        };
        return action;
      }
    }
  });
  const textX = new TextX();
  textX.push({
    t: "r" /* RETAIN */,
    len: selection.startOffset
  });
  textX.push(...actions);
  return textX;
};
function isTextRunsEqual(textRuns, oldTextRuns) {
  if ((textRuns == null ? void 0 : textRuns.length) === (oldTextRuns == null ? void 0 : oldTextRuns.length) && (textRuns == null ? void 0 : textRuns.every((textRun, index) => JSON.stringify(textRun) === JSON.stringify(oldTextRuns == null ? void 0 : oldTextRuns[index])))) {
    return true;
  }
  return false;
}
var replaceSelectionTextRuns = (params) => {
  var _a2;
  const { selection, body: insertBody, doc } = params;
  const segmentId = selection.segmentId;
  const body = (_a2 = doc.getSelfOrHeaderFooterModel(segmentId)) == null ? void 0 : _a2.getBody();
  if (!body) return false;
  const oldBody = selection.collapsed ? null : getBodySlice(body, selection.startOffset, selection.endOffset);
  const diffs = (0, import_fast_diff.default)(oldBody ? oldBody.dataStream : "", insertBody.dataStream);
  let cursor = 0;
  const actions = diffs.map(([type2, text]) => {
    switch (type2) {
      // retain
      case 0: {
        const textRunsSlice = getTextRunSlice(insertBody, cursor, cursor + text.length, false);
        const oldTextRunsSlice = getTextRunSlice(oldBody, cursor, cursor + text.length, false);
        const action = {
          t: "r" /* RETAIN */,
          body: isTextRunsEqual(textRunsSlice, oldTextRunsSlice) ? void 0 : {
            textRuns: textRunsSlice,
            dataStream: ""
          },
          len: text.length
        };
        cursor += text.length;
        return action;
      }
      // insert
      case 1: {
        const action = {
          t: "i" /* INSERT */,
          body: getBodySlice(insertBody, cursor, cursor + text.length),
          len: text.length
        };
        cursor += text.length;
        return action;
      }
      // delete
      default: {
        const action = {
          t: "d" /* DELETE */,
          len: text.length
        };
        return action;
      }
    }
  });
  if (actions.every((action) => action.t === "r" /* RETAIN */ && !action.body)) {
    return false;
  }
  const textX = new TextX();
  textX.push({
    t: "r" /* RETAIN */,
    len: selection.startOffset
  });
  textX.push(...actions);
  return textX;
};

// ../packages/core/src/docs/data-model/text-x/build-utils/drawings.ts
function getCustomBlockIdsInSelections(body, selections) {
  const customBlockIds = [];
  const { customBlocks = [] } = body;
  for (const selection of selections) {
    const { startOffset, endOffset } = selection;
    if (startOffset == null || endOffset == null) {
      continue;
    }
    for (const customBlock of customBlocks) {
      const { startIndex } = customBlock;
      if (startIndex >= startOffset && startIndex < endOffset) {
        customBlockIds.push(customBlock.blockId);
      }
    }
  }
  return customBlockIds;
}
function getRichTextEditPath(docDataModel, segmentId = "") {
  if (!segmentId) {
    return ["body"];
  }
  const { headers, footers } = docDataModel.getSnapshot();
  if (headers == null && footers == null) {
    throw new Error("Document data model must have headers or footers when update by segment id");
  }
  if ((headers == null ? void 0 : headers[segmentId]) != null) {
    return ["headers", segmentId, "body"];
  } else if ((footers == null ? void 0 : footers[segmentId]) != null) {
    return ["footers", segmentId, "body"];
  } else {
    throw new Error("Segment id not found in headers or footers");
  }
}
var addDrawing = (param) => {
  var _a2, _b2, _c, _d;
  const { selection, documentDataModel, drawings } = param;
  const { collapsed, startOffset, segmentId } = selection;
  const textX = new TextX();
  const jsonX = JSONX.getInstance();
  const rawActions = [];
  const body = documentDataModel.getSelfOrHeaderFooterModel(segmentId).getBody();
  if (!body) {
    return false;
  }
  const drawingOrderLength = (_b2 = (_a2 = documentDataModel.getSnapshot().drawingsOrder) == null ? void 0 : _a2.length) != null ? _b2 : 0;
  let removeDrawingLen = 0;
  if (collapsed) {
    if (startOffset > 0) {
      textX.push({
        t: "r" /* RETAIN */,
        len: startOffset
      });
    }
  } else {
    const dos = deleteSelectionTextX([selection], body, 0, null, false);
    textX.push(...dos);
    const removedCustomBlockIds = getCustomBlockIdsInSelections(body, [selection]);
    const drawings2 = (_c = documentDataModel.getDrawings()) != null ? _c : {};
    const drawingOrder = (_d = documentDataModel.getDrawingsOrder()) != null ? _d : [];
    const sortedRemovedCustomBlockIds = removedCustomBlockIds.sort((a2, b) => {
      if (drawingOrder.indexOf(a2) > drawingOrder.indexOf(b)) {
        return -1;
      } else if (drawingOrder.indexOf(a2) < drawingOrder.indexOf(b)) {
        return 1;
      }
      return 0;
    });
    if (sortedRemovedCustomBlockIds.length > 0) {
      for (const blockId of sortedRemovedCustomBlockIds) {
        const drawing = drawings2[blockId];
        const drawingIndex = drawingOrder.indexOf(blockId);
        if (drawing == null || drawingIndex < 0) {
          continue;
        }
        const removeDrawingAction = jsonX.removeOp(["drawings", blockId], drawing);
        const removeDrawingOrderAction = jsonX.removeOp(["drawingsOrder", drawingIndex], blockId);
        rawActions.push(removeDrawingAction);
        rawActions.push(removeDrawingOrderAction);
        removeDrawingLen++;
      }
    }
  }
  textX.push({
    t: "i" /* INSERT */,
    body: {
      dataStream: "\b".repeat(drawings.length),
      customBlocks: drawings.map((drawing, i) => ({
        startIndex: i,
        blockId: drawing.drawingId
      }))
    },
    len: drawings.length
  });
  const path = getRichTextEditPath(documentDataModel, segmentId);
  const placeHolderAction = jsonX.editOp(textX.serialize(), path);
  rawActions.push(placeHolderAction);
  for (const drawing of drawings) {
    const { drawingId } = drawing;
    const addDrawingAction = jsonX.insertOp(["drawings", drawingId], drawing);
    const addDrawingOrderAction = jsonX.insertOp(["drawingsOrder", drawingOrderLength - removeDrawingLen], drawingId);
    rawActions.push(addDrawingAction);
    rawActions.push(addDrawingOrderAction);
  }
  return rawActions.reduce((acc, cur) => {
    return JSONX.compose(acc, cur);
  }, null);
};

// ../packages/core/src/docs/data-model/text-x/build-utils/paragraph.ts
var switchParagraphBullet = (params) => {
  var _a2, _b2, _c;
  const { paragraphs: currentParagraphs, segmentId, document: docDataModel } = params;
  let listType = params.listType;
  const paragraphs = (_b2 = (_a2 = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a2.paragraphs) != null ? _b2 : [];
  const isAlreadyList = currentParagraphs.every((paragraph) => {
    var _a3;
    return ((_a3 = paragraph.bullet) == null ? void 0 : _a3.listType.indexOf(listType)) === 0;
  });
  const ID_LENGTH = 6;
  let listId = Tools.generateRandomId(ID_LENGTH);
  if (currentParagraphs.length === 1) {
    const curIndex = paragraphs.indexOf(currentParagraphs[0]);
    const prevParagraph = paragraphs[curIndex - 1];
    const nextParagraph = paragraphs[curIndex + 1];
    if (prevParagraph && prevParagraph.bullet && prevParagraph.bullet.listType.indexOf(listType) === 0) {
      listId = prevParagraph.bullet.listId;
      if (listType !== "CHECK_LIST" /* CHECK_LIST */) {
        listType = prevParagraph.bullet.listType;
      }
    } else if (nextParagraph && nextParagraph.bullet && nextParagraph.bullet.listType.indexOf(listType) === 0) {
      listId = nextParagraph.bullet.listId;
      if (listType !== "CHECK_LIST" /* CHECK_LIST */) {
        listType = nextParagraph.bullet.listType;
      }
    }
  }
  const memoryCursor = new MemoryCursor();
  memoryCursor.reset();
  const textX = new TextX();
  for (const paragraph of currentParagraphs) {
    const { startIndex, paragraphStyle = {}, bullet } = paragraph;
    textX.push({
      t: "r" /* RETAIN */,
      len: startIndex - memoryCursor.cursor
    });
    textX.push({
      t: "r" /* RETAIN */,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          isAlreadyList ? {
            paragraphStyle,
            startIndex: 0
          } : {
            startIndex: 0,
            paragraphStyle: {
              ...paragraphStyle
            },
            bullet: {
              nestingLevel: (_c = bullet == null ? void 0 : bullet.nestingLevel) != null ? _c : 0,
              textStyle: {
                fs: 20
              },
              listType,
              listId
            }
          }
        ]
      },
      coverType: 1 /* REPLACE */
    });
    memoryCursor.moveCursorTo(startIndex + 1);
  }
  return textX;
};
var toggleChecklistParagraph = (params) => {
  var _a2;
  const { paragraphIndex, segmentId, document: docDataModel } = params;
  const paragraphs = (_a2 = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a2.paragraphs;
  if (paragraphs == null) {
    return false;
  }
  const currentParagraph = paragraphs.find((p) => p.startIndex === paragraphIndex);
  if (!(currentParagraph == null ? void 0 : currentParagraph.bullet) || currentParagraph.bullet.listType.indexOf("CHECK_LIST" /* CHECK_LIST */) === -1) {
    return false;
  }
  const memoryCursor = new MemoryCursor();
  memoryCursor.reset();
  const textX = new TextX();
  const { startIndex, paragraphStyle = {} } = currentParagraph;
  const listType = currentParagraph.bullet.listType === "CHECK_LIST" /* CHECK_LIST */ ? "CHECK_LIST_CHECKED" /* CHECK_LIST_CHECKED */ : "CHECK_LIST" /* CHECK_LIST */;
  textX.push({
    t: "r" /* RETAIN */,
    len: startIndex - memoryCursor.cursor
  });
  textX.push({
    t: "r" /* RETAIN */,
    len: 1,
    body: {
      dataStream: "",
      paragraphs: [
        {
          ...currentParagraph,
          paragraphStyle,
          startIndex: 0,
          bullet: {
            ...currentParagraph.bullet,
            listType
          }
        }
      ]
    },
    coverType: 1 /* REPLACE */
  });
  memoryCursor.moveCursorTo(startIndex + 1);
  return textX;
};
var setParagraphBullet = (params) => {
  var _a2, _b2;
  const { paragraphs: currentParagraphs, listType, segmentId, document: docDataModel } = params;
  const paragraphs = (_a2 = docDataModel.getSelfOrHeaderFooterModel(segmentId).getBody()) == null ? void 0 : _a2.paragraphs;
  if (paragraphs == null) {
    return false;
  }
  const ID_LENGTH = 6;
  const listId = Tools.generateRandomId(ID_LENGTH);
  const memoryCursor = new MemoryCursor();
  memoryCursor.reset();
  const textX = new TextX();
  for (const paragraph of currentParagraphs) {
    const { startIndex, paragraphStyle = {}, bullet } = paragraph;
    textX.push({
      t: "r" /* RETAIN */,
      len: startIndex - memoryCursor.cursor
    });
    textX.push({
      t: "r" /* RETAIN */,
      len: 1,
      body: {
        dataStream: "",
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle,
            bullet: {
              nestingLevel: (_b2 = bullet == null ? void 0 : bullet.nestingLevel) != null ? _b2 : 0,
              textStyle: (bullet == null ? void 0 : bullet.listType) === listType ? bullet.textStyle : {
                fs: 20
              },
              listType,
              listId
            }
          }
        ]
      },
      coverType: 1 /* REPLACE */
    });
    memoryCursor.moveCursorTo(startIndex + 1);
  }
  return textX;
};
function hasParagraphInTable(paragraph, tables) {
  return tables.some((table) => paragraph.startIndex > table.startIndex && paragraph.startIndex < table.endIndex);
}
var changeParagraphBulletNestLevel = (params) => {
  var _a2, _b2, _c;
  const { paragraphs: currentParagraphs, segmentId, document: docDataModel, type: type2 } = params;
  const memoryCursor = new MemoryCursor();
  memoryCursor.reset();
  const textX = new TextX();
  const customLists = (_a2 = docDataModel.getSnapshot().lists) != null ? _a2 : {};
  const tables = (_c = (_b2 = docDataModel.getBody()) == null ? void 0 : _b2.tables) != null ? _c : [];
  const lists = {
    ...PRESET_LIST_TYPE,
    ...customLists
  };
  for (const paragraph of currentParagraphs) {
    const { startIndex, paragraphStyle = {}, bullet } = paragraph;
    const isInTable = hasParagraphInTable(paragraph, tables);
    textX.push({
      t: "r" /* RETAIN */,
      len: startIndex - memoryCursor.cursor
    });
    if (bullet) {
      const listType = bullet.listType;
      let maxLevel = lists[listType].nestingLevel.length - 1;
      if (isInTable) {
        maxLevel = Math.min(maxLevel, 2);
      }
      textX.push({
        t: "r" /* RETAIN */,
        len: 1,
        body: {
          dataStream: "",
          paragraphs: [
            {
              startIndex: 0,
              paragraphStyle: {
                ...paragraphStyle
              },
              bullet: {
                ...bullet,
                nestingLevel: Math.max(Math.min(bullet.nestingLevel + type2, maxLevel), 0)
              }
            }
          ]
        },
        coverType: 1 /* REPLACE */
      });
    } else {
      textX.push({
        t: "r" /* RETAIN */,
        len: 1
      });
    }
    memoryCursor.moveCursorTo(startIndex + 1);
  }
  return textX;
};

// ../packages/core/src/docs/data-model/text-x/build-utils/selection.ts
function makeSelection(startOffset, endOffset) {
  if (typeof endOffset === "undefined") {
    return { startOffset, endOffset: startOffset, collapsed: true };
  }
  if (endOffset < startOffset) {
    throw new Error(`Cannot make a doc selection when endOffset ${endOffset} is less than startOffset ${startOffset}.`);
  }
  return { startOffset, endOffset, collapsed: startOffset === endOffset };
}
function normalizeSelection(selection) {
  const { startOffset, endOffset, collapsed } = selection;
  const start = Math.min(startOffset, endOffset);
  const end = Math.max(startOffset, endOffset);
  return {
    startOffset: start,
    endOffset: end,
    collapsed
  };
}
function isSegmentIntersects(start, end, start2, end2) {
  return Math.max(start, start2) <= Math.min(end, end2);
}

// ../packages/core/src/docs/data-model/text-x/build-utils/index.ts
var BuildTextUtils = class {
};
__publicField(BuildTextUtils, "customRange", {
  add: addCustomRangeTextX,
  delete: deleteCustomRangeTextX,
  copyCustomRange,
  getCustomRangesInterestsWithSelection,
  isIntersecting
});
__publicField(BuildTextUtils, "customDecoration", {
  add: addCustomDecorationTextX,
  delete: deleteCustomDecorationTextX
});
__publicField(BuildTextUtils, "selection", {
  replace: replaceSelectionTextX,
  makeSelection,
  normalizeSelection,
  delete: deleteSelectionTextX,
  replaceTextRuns: replaceSelectionTextRuns,
  retain: retainSelectionTextX
});
__publicField(BuildTextUtils, "range", {
  isIntersects: isSegmentIntersects
});
__publicField(BuildTextUtils, "transform", {
  getPlainText,
  fromPlainText,
  isEmptyDocument
});
__publicField(BuildTextUtils, "paragraph", {
  bullet: {
    set: setParagraphBullet,
    switch: switchParagraphBullet,
    toggleChecklist: toggleChecklistParagraph,
    changeNestLevel: changeParagraphBulletNestLevel
  }
});
__publicField(BuildTextUtils, "drawing", {
  add: addDrawing
});

// ../packages/core/src/common/interceptor.ts
function createInterceptorKey(key) {
  const symbol = `sheet_interceptor_${key}`;
  return symbol;
}
var composeInterceptors = (interceptors) => function(initialValue, context) {
  let index = -1;
  let value = initialValue;
  for (let i = 0; i <= interceptors.length; i++) {
    if (i <= index) {
      throw new Error("[SheetInterceptorService]: next() called multiple times!");
    }
    index = i;
    if (i === interceptors.length) {
      return value;
    }
    const interceptor = interceptors[i];
    let nextCalled = false;
    value = interceptor.handler(value, context, (nextValue) => {
      nextCalled = true;
      return nextValue;
    });
    if (!nextCalled) {
      break;
    }
  }
  return value;
};
var InterceptorManager = class {
  constructor(interceptorPoints) {
    __publicField(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    __publicField(this, "_interceptorPoints");
    this._interceptorPoints = interceptorPoints;
  }
  /**
   * Get the interceptors.
   * @param name Name of the intercepted point.
   * @param filter A callback function to filter the interceptors.
   * @returns It will return a composed interceptor function. If you will perform the interceptor repeatedly,
   * you should cache the result instead of calling this function multiple times.
   */
  fetchThroughInterceptors(name, filter8) {
    const key = name;
    let interceptors = this._interceptorsByName.get(key);
    if (filter8) {
      interceptors = interceptors.filter(filter8);
    }
    return composeInterceptors(interceptors || []);
  }
  intercept(name, interceptor) {
    const key = name;
    if (!this._interceptorsByName.has(key)) {
      this._interceptorsByName.set(key, []);
    }
    const interceptors = this._interceptorsByName.get(key);
    interceptors.push(interceptor);
    this._interceptorsByName.set(
      key,
      interceptors.sort((a2, b) => {
        var _a2, _b2;
        return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a2.priority) != null ? _b2 : 0);
      })
      // from large to small
    );
    return () => remove(this._interceptorsByName.get(key), interceptor);
  }
  getInterceptPoints() {
    return this._interceptorPoints;
  }
  dispose() {
    this._interceptorsByName.clear();
  }
};

// ../packages/core/src/common/number.ts
function isNumeric(str) {
  return /^-?\d+(\.\d+)?$/.test(str);
}
function isSafeNumeric(str) {
  const numeric = isNumeric(str);
  if (!numeric) {
    return false;
  }
  return Number(str) <= Number.MAX_SAFE_INTEGER;
}

// ../packages/core/src/common/request-immediate-macro-task.ts
function requestImmediateMacroTask(callback) {
  const channel = new MessageChannel();
  let cancelled = false;
  const handler = () => {
    if (!cancelled) {
      callback();
    }
  };
  channel.port1.onmessage = handler;
  channel.port2.postMessage(null);
  return () => {
    cancelled = true;
    channel.port1.onmessage = null;
    channel.port1.close();
    channel.port2.close();
  };
}

// ../packages/core/src/services/resource-manager/type.ts
var IResourceManagerService = createIdentifier("core.resource-manager.service");

// ../packages/core/src/services/user-manager/user-manager.service.ts
var import_rxjs6 = __toESM(require_cjs());

// ../packages/core/src/services/user-manager/const.ts
var nameMap = {
  [S.Editor]: "Editor",
  [S.Owner]: "Owner",
  [S.Reader]: "Reader",
  [S.UNRECOGNIZED]: "UNRECOGNIZED"
};
var createDefaultUser = (type2) => {
  if (!type2) {
    return {
      userID: "",
      name: "",
      avatar: "",
      anonymous: true,
      canBindAnonymous: false
    };
  }
  const user = {
    userID: `${nameMap[type2]}_${Tools.generateRandomId(8)}`,
    name: nameMap[type2],
    avatar: ""
  };
  return user;
};
var isDevRole = (userId, type2) => {
  return userId.startsWith(nameMap[type2]);
};

// ../packages/core/src/services/user-manager/user-manager.service.ts
var UserManagerService = class {
  constructor() {
    __publicField(this, "_model", /* @__PURE__ */ new Map());
    __publicField(this, "_userChange$", new import_rxjs6.Subject());
    __publicField(this, "userChange$", this._userChange$.asObservable());
    __publicField(this, "_currentUser$", new import_rxjs6.BehaviorSubject(createDefaultUser()));
    /**
     * When the current user undergoes a switch or change
     * @memberof UserManagerService
     */
    __publicField(this, "currentUser$", this._currentUser$.asObservable());
  }
  getCurrentUser() {
    return this._currentUser$.getValue();
  }
  setCurrentUser(user) {
    this.addUser(user);
    this._currentUser$.next(user);
  }
  addUser(user) {
    this._model.set(user.userID, user);
    this._userChange$.next({ type: "add", user });
  }
  getUser(userId, callBack) {
    const user = this._model.get(userId);
    if (user) {
      return user;
    }
    callBack && callBack();
  }
  delete(userId) {
    const user = this.getUser(userId);
    this._model.delete(userId);
    user && this._userChange$.next({ type: "delete", user });
  }
  clear() {
    this._model.clear();
    this._userChange$.next({ type: "clear" });
  }
  list() {
    return Array.from(this._model.values());
  }
};

// ../packages/core/src/services/authz-io/authz-io-local.service.ts
var AuthzIoLocalService = class {
  // private _sheetPermissionPointMap: Map<string, { action: UnitAction; allowed: boolean }[]> = new Map();
  constructor(_resourceManagerService, _userManagerService) {
    this._resourceManagerService = _resourceManagerService;
    this._userManagerService = _userManagerService;
    __publicField(this, "_permissionMap", /* @__PURE__ */ new Map([]));
    this._initSnapshot();
    this._initDefaultUser();
  }
  _initDefaultUser() {
    const currentUser = this._userManagerService.getCurrentUser();
    const currentUserIsValid = currentUser && currentUser.userID;
    if (!currentUserIsValid) {
      this._userManagerService.setCurrentUser(createDefaultUser(S.Owner));
    }
  }
  _getRole(type2) {
    const user = this._userManagerService.getCurrentUser();
    if (!user) {
      return false;
    }
    return isDevRole(user.userID, type2);
  }
  _initSnapshot() {
    this._resourceManagerService.registerPluginResource({
      toJson: (_unitId) => {
        const obj = [...this._permissionMap.keys()].reduce((r, k) => {
          const v = this._permissionMap.get(k);
          r[k] = v;
          return r;
        }, {});
        return JSON.stringify(obj);
      },
      parseJson: (json) => {
        return JSON.parse(json);
      },
      pluginName: "SHEET_AuthzIoMockService_PLUGIN",
      businesses: [O.UNIVER_SHEET, O.UNIVER_DOC, O.UNIVER_SLIDE],
      onLoad: (_unitId, resource) => {
        for (const key in resource) {
          this._permissionMap.set(key, resource[key]);
        }
      },
      onUnLoad: () => {
        this._permissionMap.clear();
      }
    });
  }
  async create(config2) {
    return generateRandomId(8);
  }
  async allowed(_config) {
    return Promise.resolve([]);
  }
  async batchAllowed(_config) {
    return Promise.resolve([]);
  }
  // eslint-disable-next-line max-lines-per-function
  async list(config2) {
    const result = [];
    config2.objectIDs.forEach((objectID) => {
      const rule = this._permissionMap.get(objectID);
      if (rule) {
        const item = {
          objectID,
          unitID: config2.unitID,
          objectType: rule.objectType,
          name: rule.name,
          shareOn: false,
          shareRole: S.Owner,
          shareScope: -1,
          scope: {
            read: G.AllCollaborator,
            edit: G.AllCollaborator
          },
          creator: createDefaultUser(S.Owner),
          strategies: [
            {
              action: 6,
              role: 1
            },
            {
              action: 16,
              role: 1
            },
            {
              action: 17,
              role: 1
            },
            {
              action: 18,
              role: 1
            },
            {
              action: 19,
              role: 1
            },
            {
              action: 33,
              role: 1
            },
            {
              action: 34,
              role: 1
            },
            {
              action: 35,
              role: 1
            },
            {
              action: 36,
              role: 1
            },
            {
              action: 37,
              role: 1
            },
            {
              action: 38,
              role: 1
            },
            {
              action: 39,
              role: 1
            },
            {
              action: 40,
              role: 1
            }
          ],
          actions: config2.actions.map((a2) => {
            return { action: a2, allowed: this._getRole(S.Owner) || this._getRole(S.Editor) };
          })
        };
        result.push(item);
      }
    });
    return result;
  }
  async listCollaborators() {
    return [];
  }
  async listRoles() {
    return {
      roles: [],
      actions: []
    };
  }
  async deleteCollaborator() {
    return void 0;
  }
  async update(config2) {
  }
  async updateCollaborator() {
    return void 0;
  }
  async createCollaborator() {
    return void 0;
  }
  async putCollaborators(config2) {
    return void 0;
  }
};
AuthzIoLocalService = __decorateClass([
  __decorateParam(0, IResourceManagerService),
  __decorateParam(1, Inject(UserManagerService))
], AuthzIoLocalService);

// ../packages/core/src/services/authz-io/type.ts
var IAuthzIoService = createIdentifier("IAuthzIoIoService");

// ../packages/core/src/services/mention-io/mention-io-local.service.ts
var MentionIOLocalService = class {
  constructor(_userManagerService) {
    this._userManagerService = _userManagerService;
  }
  async list(params) {
    return {
      list: [{
        type: 0 /* PERSON */,
        mentions: [
          {
            objectType: 0 /* PERSON */,
            objectId: this._userManagerService.getCurrentUser().userID,
            label: this._userManagerService.getCurrentUser().name,
            metadata: {
              icon: this._userManagerService.getCurrentUser().avatar
            }
          }
        ],
        metadata: {},
        title: "PEOPLE"
      }],
      page: params.page,
      size: params.size,
      total: 1
    };
  }
};
MentionIOLocalService = __decorateClass([
  __decorateParam(0, Inject(UserManagerService))
], MentionIOLocalService);

// ../packages/core/src/services/mention-io/type.ts
var IMentionIOService = createIdentifier("univer.service.mention-io");

// ../packages/core/src/services/config/config.service.ts
var import_rxjs7 = __toESM(require_cjs());
var IConfigService = createIdentifier("univer.config-service");
var ConfigService = class {
  constructor() {
    __publicField(this, "_configChanged$", new import_rxjs7.Subject());
    __publicField(this, "configChanged$", this._configChanged$.asObservable());
    __publicField(this, "_config", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._configChanged$.complete();
  }
  getConfig(id) {
    return this._config.get(id);
  }
  setConfig(id, value, options) {
    var _a2;
    const { merge: isMerge = false } = options || {};
    let nextValue = (_a2 = this._config.get(id)) != null ? _a2 : {};
    if (isMerge) {
      nextValue = merge_default(nextValue, value);
    } else {
      nextValue = value;
    }
    this._config.set(id, nextValue);
    this._configChanged$.next({ [id]: nextValue });
  }
  deleteConfig(id) {
    return this._config.delete(id);
  }
  subscribeConfigValue$(key) {
    return new import_rxjs7.Observable((observer) => {
      if (Object.prototype.hasOwnProperty.call(this._config, key)) {
        observer.next(this._config.get(key));
      }
      const sub2 = this.configChanged$.pipe((0, import_rxjs7.filter)((c) => Object.prototype.hasOwnProperty.call(c, key))).subscribe((c) => observer.next(c[key]));
      return () => sub2.unsubscribe();
    });
  }
};

// ../packages/core/src/services/context/context.ts
var FOCUSING_UNIT = "FOCUSING_UNIT";
var FOCUSING_SHEET = "FOCUSING_SHEET";
var FOCUSING_DOC = "FOCUSING_DOC";
var FOCUSING_SLIDE = "FOCUSING_SLIDE";
var EDITOR_ACTIVATED = "EDITOR_ACTIVATED";
var FOCUSING_FX_BAR_EDITOR = "FOCUSING_FX_BAR_EDITOR";

// ../packages/core/src/services/error/error.service.ts
var import_rxjs8 = __toESM(require_cjs());
var ErrorService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_error$", new import_rxjs8.Subject());
    __publicField(this, "error$", this._error$.asObservable());
  }
  dispose() {
    this._error$.complete();
  }
  emit(key) {
    this._error$.next({ errorKey: key });
  }
};

// ../packages/core/src/services/instance/instance.service.ts
var import_rxjs11 = __toESM(require_cjs());

// ../packages/core/src/sheets/workbook.ts
var import_rxjs9 = __toESM(require_cjs());

// ../packages/core/package.json
var package_default = {
  name: "@univerjs/core",
  version: "0.6.6",
  private: false,
  description: "Core library for Univer.",
  author: "DreamNum <developer@univer.ai>",
  license: "Apache-2.0",
  funding: {
    type: "opencollective",
    url: "https://opencollective.com/univer"
  },
  homepage: "https://univer.ai",
  repository: {
    type: "git",
    url: "https://github.com/dream-num/univer"
  },
  bugs: {
    url: "https://github.com/dream-num/univer/issues"
  },
  keywords: [
    "univer"
  ],
  exports: {
    ".": "./src/index.ts",
    "./*": "./src/*",
    "./facade": "./src/facade/index.ts"
  },
  main: "./src/index.ts",
  types: "./lib/types/index.d.ts",
  publishConfig: {
    access: "public",
    main: "./lib/es/index.js",
    module: "./lib/es/index.js",
    exports: {
      ".": {
        import: "./lib/es/index.js",
        require: "./lib/cjs/index.js",
        types: "./lib/types/index.d.ts"
      },
      "./*": {
        import: "./lib/es/*",
        require: "./lib/cjs/*",
        types: "./lib/types/index.d.ts"
      },
      "./facade": {
        import: "./lib/es/facade.js",
        require: "./lib/cjs/facade.js",
        types: "./lib/types/facade/index.d.ts"
      },
      "./lib/*": "./lib/*"
    }
  },
  directories: {
    lib: "lib"
  },
  files: [
    "lib"
  ],
  scripts: {
    test: "vitest run",
    "test:watch": "vitest",
    coverage: "vitest run --coverage",
    "lint:types": "tsc --noEmit",
    build: "univer-cli build"
  },
  peerDependencies: {
    "@wendellhu/redi": "0.17.1",
    rxjs: ">=7.0.0"
  },
  dependencies: {
    "@univerjs/protocol": "0.1.44",
    "@wendellhu/redi": "0.17.1",
    dayjs: "^1.11.13",
    "fast-diff": "1.3.0",
    kdbush: "^4.0.2",
    "lodash-es": "^4.17.21",
    nanoid: "5.1.3",
    numeral: "^2.0.6",
    numfmt: "^2.5.2",
    "ot-json1": "^1.0.2",
    rbush: "^4.0.1"
  },
  devDependencies: {
    "@types/lodash-es": "^4.17.12",
    "@types/numeral": "^2.0.5",
    "@types/rbush": "^4.0.0",
    "@univerjs-infra/shared": "workspace:*",
    rxjs: "^7.8.1",
    typescript: "^5.8.2",
    vite: "^6.2.1",
    vitest: "^3.0.8"
  }
};

// ../packages/core/src/sheets/empty-snapshot.ts
function getEmptySnapshot2(unitID = "", locale = "zhCN" /* ZH_CN */, name = "") {
  const DEFAULT_WORKBOOK_DATA = {
    id: unitID,
    sheetOrder: [],
    name,
    appVersion: package_default.version,
    locale,
    styles: {},
    sheets: {},
    resources: []
  };
  return DEFAULT_WORKBOOK_DATA;
}

// ../packages/core/src/sheets/styles.ts
var Styles = class {
  constructor(styles = {}) {
    __publicField(this, "_styles");
    __publicField(this, "_cacheMap", new LRUMap(1e5));
    this._styles = styles;
    this._generateCacheMap();
  }
  each(callback) {
    Object.entries(this._styles).forEach(callback);
    return this;
  }
  search(data, styleObject) {
    if (this._cacheMap.has(styleObject)) {
      return this._cacheMap.get(styleObject);
    }
    const existingId = this._getExistingStyleId(data);
    if (existingId) {
      return existingId;
    }
    return "-1";
  }
  get(id) {
    if (typeof id !== "string") return id;
    id = String(id);
    return this._styles[id];
  }
  add(data, styleObject) {
    const id = Tools.generateRandomId(6);
    this._styles[id] = data;
    this._cacheMap.set(styleObject, id);
    return id;
  }
  setValue(data) {
    if (data == null) return;
    const styleObject = JSON.stringify(data);
    const result = this.search(data, styleObject);
    if (result !== "-1") {
      return result;
    }
    return this.add(data, styleObject);
  }
  toJSON() {
    return this._styles;
  }
  // TODO: this should be `deReuseStyle` to be more accurate.
  getStyleByCell(cell) {
    let style;
    if (cell && Tools.isObject(cell.s)) {
      style = cell.s;
    } else {
      style = (cell == null ? void 0 : cell.s) && this.get(cell.s);
    }
    const interceptStyle = cell == null ? void 0 : cell.interceptorStyle;
    if (interceptStyle) {
      return {
        ...style,
        ...interceptStyle
      };
    }
    return style;
  }
  _generateCacheMap() {
    const { _styles, _cacheMap } = this;
    for (const id in _styles) {
      const styleObject = JSON.stringify(_styles[id]);
      _cacheMap.set(styleObject, id);
    }
  }
  _getExistingStyleId(data) {
    const { _styles } = this;
    for (const id in _styles) {
      if (Tools.diffValue(_styles[id], data)) {
        return id;
      }
    }
    return null;
  }
};

// ../packages/core/src/sheets/util.ts
var DEFAULT_PADDING_DATA = {
  t: 0,
  b: 2,
  // must over 1, see https://github.com/dream-num/univer/issues/2727
  l: 2,
  r: 2
};
var getDefaultBaselineOffset = (fontSize) => ({
  sbr: 0.6,
  sbo: fontSize,
  spr: 0.6,
  spo: fontSize
});
var VERTICAL_ROTATE_ANGLE = 90;
function createDocumentModelWithStyle(content, textStyle, config2 = {}) {
  const contentLength = content.length;
  const {
    textRotation,
    paddingData,
    horizontalAlign = 0 /* UNSPECIFIED */,
    verticalAlign = 0 /* UNSPECIFIED */,
    wrapStrategy = 0 /* UNSPECIFIED */,
    cellValueType
  } = config2;
  const { t: marginTop, r: marginRight, b: marginBottom, l: marginLeft } = paddingData || DEFAULT_PADDING_DATA;
  const { vertexAngle, centerAngle } = convertTextRotation(textRotation);
  const documentData = {
    id: "d",
    body: {
      dataStream: `${content}${DEFAULT_EMPTY_DOCUMENT_VALUE}`,
      textRuns: [
        {
          ts: textStyle,
          st: 0,
          ed: contentLength
        }
      ],
      paragraphs: [
        {
          startIndex: contentLength,
          paragraphStyle: {
            horizontalAlign
          }
        }
      ],
      sectionBreaks: [{
        startIndex: contentLength + 1
      }]
    },
    documentStyle: {
      pageSize: {
        width: Number.POSITIVE_INFINITY,
        height: Number.POSITIVE_INFINITY
      },
      marginTop,
      marginBottom,
      marginRight,
      marginLeft,
      renderConfig: {
        horizontalAlign,
        verticalAlign,
        centerAngle,
        vertexAngle,
        wrapStrategy,
        cellValueType,
        zeroWidthParagraphBreak: 1
      }
    },
    drawings: {},
    drawingsOrder: []
  };
  return new DocumentDataModel(documentData);
}
function extractOtherStyle(style) {
  if (!style) return {};
  const {
    tr: textRotation,
    td: textDirection,
    ht: horizontalAlign,
    vt: verticalAlign,
    tb: wrapStrategy,
    pd: paddingData
  } = style;
  return {
    textRotation,
    textDirection,
    horizontalAlign,
    verticalAlign,
    wrapStrategy,
    paddingData
  };
}
function getFontFormat(format) {
  if (!format) {
    return {};
  }
  const { ff, fs, it, bl, ul, st, ol, cl } = format;
  const style = {};
  ff && (style.ff = ff);
  fs && (style.fs = fs);
  it && (style.it = it);
  bl && (style.bl = bl);
  ul && (style.ul = ul);
  st && (style.st = st);
  ol && (style.ol = ol);
  cl && (style.cl = cl);
  return style;
}
function addLinkToDocumentModel(documentModel, linkUrl, linkId) {
  var _a2;
  const body = documentModel.getBody();
  if ((_a2 = body.customRanges) == null ? void 0 : _a2.some((range) => range.rangeType === 0 /* HYPERLINK */)) {
    return;
  }
  const textX = BuildTextUtils.customRange.add({
    ranges: [
      {
        startOffset: 0,
        endOffset: body.dataStream.length - 1,
        collapsed: false
      }
    ],
    rangeId: linkId,
    rangeType: 0 /* HYPERLINK */,
    body,
    properties: {
      url: linkUrl,
      refId: linkId
    }
  });
  if (!textX) {
    return;
  }
  TextX.apply(body, textX.serialize());
}
function isNotNullOrUndefined(value) {
  return value !== null && value !== void 0;
}

// ../packages/core/src/docs/data-model/utils.ts
var DEFAULT_FONTFACE_PLANE = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
function getFontStyleString(textStyle) {
  const defaultFont = DEFAULT_STYLES.ff;
  const defaultFontSize = DEFAULT_STYLES.fs;
  if (!textStyle) {
    const fontString2 = `${defaultFontSize}pt  ${defaultFont}`;
    return {
      fontCache: fontString2,
      fontString: fontString2,
      fontSize: defaultFontSize,
      originFontSize: defaultFontSize,
      fontFamily: defaultFont
    };
  }
  let italic = "italic" /* ITALIC */;
  if (textStyle.it === 0 || textStyle.it === void 0) {
    italic = "normal" /* NORMAL */;
  }
  let bold = "bold" /* BOLD */;
  if (textStyle.bl === 0 || textStyle.bl === void 0) {
    bold = "normal" /* NORMAL */;
  }
  let originFontSize = defaultFontSize;
  if (textStyle.fs) {
    originFontSize = Math.ceil(textStyle.fs);
  }
  let fontFamilyResult = defaultFont;
  if (textStyle.ff) {
    let fontFamily = textStyle.ff;
    fontFamily = fontFamily.replace(/"/g, "").replace(/'/g, "");
    if (fontFamily.indexOf(" ") > -1) {
      fontFamily = `"${fontFamily}"`;
    }
    if (fontFamily == null) {
      fontFamily = defaultFont;
    }
    fontFamilyResult = fontFamily;
  }
  const { va: baselineOffset } = textStyle;
  let fontSize = originFontSize;
  if (baselineOffset === 2 /* SUBSCRIPT */ || baselineOffset === 3 /* SUPERSCRIPT */) {
    const baselineOffsetInfo = getBaselineOffsetInfo(fontFamilyResult, fontSize);
    const { sbr, spr } = baselineOffsetInfo;
    fontSize *= baselineOffset === 2 /* SUBSCRIPT */ ? sbr : spr;
  }
  const fontStringPure = `${italic} ${bold} ${fontSize}pt ${fontFamilyResult}`;
  const fontString = `${fontStringPure}, ${DEFAULT_FONTFACE_PLANE} `;
  return {
    fontCache: fontStringPure,
    fontString,
    fontSize,
    originFontSize,
    fontFamily: fontFamilyResult
  };
}
function getBaselineOffsetInfo(_fontFamily, fontSize) {
  return getDefaultBaselineOffset(fontSize);
}
function convertTextRotation(textRotation) {
  const { a: angle = 0, v: isVertical = 0 /* FALSE */ } = textRotation || { a: 0, v: 0 /* FALSE */ };
  let centerAngle = 0;
  let vertexAngle = angle;
  if (isVertical === 1 /* TRUE */) {
    centerAngle = VERTICAL_ROTATE_ANGLE;
    vertexAngle = VERTICAL_ROTATE_ANGLE;
  }
  return { centerAngle, vertexAngle };
}

// ../packages/core/src/sheets/column-manager.ts
var ColumnManager = class {
  constructor(_config, data) {
    this._config = _config;
    __publicField(this, "_columnData", {});
    this._columnData = data;
  }
  /**
   * Get width and hidden status of columns in the sheet
   * @returns
   */
  getColumnData() {
    return this._columnData;
  }
  getColVisible(colPos) {
    const { _columnData } = this;
    const col = _columnData[colPos];
    if (!col) {
      return true;
    }
    return col.hd !== 1 /* TRUE */;
  }
  /**
   * Get the column style
   * @param {number} col Column index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getColumnStyle(col) {
    var _a2;
    return (_a2 = this._columnData[col]) == null ? void 0 : _a2.s;
  }
  /**
   * Set the set column  default style
   * @param {number} col Column index
   * @param {string | Nullable<IStyleData>} style Style data
   */
  setColumnStyle(col, style) {
    const coldData = this.getColumnOrCreate(col);
    coldData.s = style;
  }
  /**
   * Get all hidden columns
   * @param start Start index
   * @param end End index
   * @returns Hidden columns range list
   */
  getHiddenCols(start = 0, end = this.getSize() - 1) {
    const hiddenCols = [];
    let inHiddenRange = false;
    let startColumn = -1;
    for (let i = start; i <= end; i++) {
      const visible = this.getColVisible(i);
      if (inHiddenRange && visible) {
        inHiddenRange = false;
        hiddenCols.push({
          rangeType: 2 /* COLUMN */,
          startColumn,
          endColumn: i - 1,
          startRow: 0,
          endRow: 0
        });
      } else if (!inHiddenRange && !visible) {
        inHiddenRange = true;
        startColumn = i;
      }
    }
    if (inHiddenRange) {
      hiddenCols.push({
        startRow: 0,
        endRow: 0,
        startColumn,
        endColumn: end,
        rangeType: 2 /* COLUMN */
      });
    }
    return hiddenCols;
  }
  /**
   * Get all visible columns
   * @param start Start index
   * @param end End index
   * @returns Visible columns range list
   */
  getVisibleCols(start = 0, end = this.getSize() - 1) {
    const visibleCols = [];
    let inVisibleRange = false;
    let startColumn = -1;
    for (let i = start; i <= end; i++) {
      const visible = this.getColVisible(i);
      if (inVisibleRange && !visible) {
        inVisibleRange = false;
        visibleCols.push({
          rangeType: 2 /* COLUMN */,
          startColumn,
          endColumn: i - 1,
          startRow: 0,
          endRow: 0
        });
      } else if (!inVisibleRange && visible) {
        inVisibleRange = true;
        startColumn = i;
      }
    }
    if (inVisibleRange) {
      visibleCols.push({
        startRow: 0,
        endRow: 0,
        startColumn,
        endColumn: end,
        rangeType: 2 /* COLUMN */
      });
    }
    return visibleCols;
  }
  getColumnDatas(columnPos, numColumns) {
    const columnData = {};
    let index = 0;
    for (let i = columnPos; i < columnPos + numColumns; i++) {
      const data = this.getColumnOrCreate(i);
      columnData[index] = data;
      index++;
    }
    return columnData;
  }
  /**
   * Get count of column in the sheet
   * @returns
   */
  getSize() {
    return getArrayLength(this._columnData);
  }
  /**
   * Get the width of column
   * @param columnPos column index
   * @returns
   */
  getColumnWidth(columnPos) {
    const { _columnData } = this;
    const config2 = this._config;
    let width = 0;
    const column = _columnData[columnPos] || {
      hd: 0 /* FALSE */,
      w: config2.defaultColumnWidth
    };
    width = column.w || config2.defaultColumnWidth;
    return width;
  }
  /**
   * get given column data
   * @param columnPos column index
   */
  getColumn(columnPos) {
    const column = this._columnData[columnPos];
    if (column) {
      return column;
    }
  }
  /**
   * Remove column data of given column
   * @param columnPos
   */
  removeColumn(columnPos) {
    delete this._columnData[columnPos];
  }
  /**
   * get given column data or create a column data when it's null
   * @param columnPos column index
   * @returns {Partial<IColumnData>} columnData
   */
  getColumnOrCreate(columnPos) {
    const { _columnData } = this;
    const column = _columnData[columnPos];
    if (column) {
      return column;
    }
    const create = {};
    this._columnData[columnPos] = create;
    return create;
  }
  setCustomMetadata(index, custom) {
    const row = this.getColumn(index);
    if (row) {
      row.custom = custom;
    }
  }
  getCustomMetadata(index) {
    var _a2;
    return (_a2 = this.getColumn(index)) == null ? void 0 : _a2.custom;
  }
};

// ../packages/core/src/sheets/row-manager.ts
var RowManager = class {
  constructor(_config, _viewModel, data) {
    this._config = _config;
    this._viewModel = _viewModel;
    __publicField(this, "_rowData");
    this._rowData = data;
  }
  /**
   * Get height and hidden status of columns in the sheet
   * @returns
   */
  getRowData() {
    return this._rowData;
  }
  /**
   * Get the row style
   * @param {number} row Row index
   * @returns {string | Nullable<IStyleData>} Style data, may be undefined
   */
  getRowStyle(row) {
    var _a2;
    return (_a2 = this._rowData[row]) == null ? void 0 : _a2.s;
  }
  /**
   * Set row default style
   * @param {number} row The row index
   * @param {string | Nullable<IStyleData>} style The style data
   */
  setRowStyle(row, style) {
    const rowData = this.getRowOrCreate(row);
    rowData.s = style;
  }
  getRowDatas(rowPos, numRows) {
    const rowData = {};
    let index = 0;
    for (let i = rowPos; i < rowPos + numRows; i++) {
      const data = this.getRowOrCreate(i);
      rowData[index] = data;
      index++;
    }
    return rowData;
  }
  getRowHeight(rowPos, count = 1) {
    const { _rowData } = this;
    const config2 = this._config;
    let height = 0;
    for (let i = 0; i < count; i++) {
      const row = _rowData[i + rowPos] || {
        hd: 0 /* FALSE */,
        h: config2.defaultRowHeight
      };
      const { ia, ah, h = config2.defaultRowHeight } = row;
      height += (ia == null || ia === 1 /* TRUE */) && typeof ah === "number" ? ah : h;
    }
    return height;
  }
  /**
   * Get row data of given row
   * @param rowPos row index
   * @returns {Nullable<Partial<IRowData>>} rowData
   */
  getRow(rowPos) {
    return this._rowData[rowPos];
  }
  /**
   * Remove row data of given row
   * @param rowPos
   */
  removeRow(rowPos) {
    delete this._rowData[rowPos];
  }
  /**
   * Get given row data or create a row data when it's null
   * @param rowPos row index
   * @returns {Partial<IRowData>} rowData
   */
  getRowOrCreate(rowPos) {
    const { _rowData } = this;
    const row = _rowData[rowPos];
    if (row) {
      return row;
    }
    const create = {};
    _rowData[rowPos] = create;
    return create;
  }
  /**
   * Get all hidden rows
   * @param start Start index
   * @param end End index
   * @returns Hidden rows range list
   */
  getHiddenRows(start = 0, end = this.getSize() - 1) {
    const hiddenRows = [];
    let inHiddenRange = false;
    let startRow = -1;
    for (let i = start; i <= end; i++) {
      const visible = this.getRowRawVisible(i);
      if (inHiddenRange && visible) {
        inHiddenRange = false;
        hiddenRows.push({
          startRow,
          endRow: i - 1,
          startColumn: 0,
          endColumn: 0,
          rangeType: 1 /* ROW */
        });
      } else if (!inHiddenRange && !visible) {
        inHiddenRange = true;
        startRow = i;
      }
    }
    if (inHiddenRange) {
      hiddenRows.push({ startRow, endRow: end, startColumn: 0, endColumn: 0, rangeType: 1 /* ROW */ });
    }
    return hiddenRows;
  }
  /**
   * Get all visible rows
   * @param start Start index
   * @param end End index
   * @returns Visible rows range list
   */
  getVisibleRows(start = 0, end = this.getSize() - 1) {
    const visibleRows = [];
    let inVisibleRange = false;
    let startRow = -1;
    for (let i = start; i <= end; i++) {
      const visible = this.getRowRawVisible(i);
      if (inVisibleRange && !visible) {
        inVisibleRange = false;
        visibleRows.push({
          startRow,
          endRow: i - 1,
          startColumn: 0,
          endColumn: 0,
          rangeType: 1 /* ROW */
        });
      } else if (!inVisibleRange && visible) {
        inVisibleRange = true;
        startRow = i;
      }
    }
    if (inVisibleRange) {
      visibleRows.push({ startRow, endRow: end, startColumn: 0, endColumn: 0, rangeType: 1 /* ROW */ });
    }
    return visibleRows;
  }
  getRowRawVisible(row) {
    const rowData = this.getRow(row);
    if (!rowData) {
      return true;
    }
    return rowData.hd !== 1 /* TRUE */;
  }
  /**
   * Get count of row in the sheet
   * @returns {number} row count
   */
  getSize() {
    return getArrayLength(this._rowData);
  }
  setCustomMetadata(index, custom) {
    const row = this.getRow(index);
    if (row) {
      row.custom = custom;
    }
  }
  getCustomMetadata(index) {
    var _a2;
    return (_a2 = this.getRow(index)) == null ? void 0 : _a2.custom;
  }
};

// ../packages/core/src/sheets/sheet-snapshot-utils.ts
var DEFAULT_WORKSHEET_ROW_COUNT = 1e3;
var DEFAULT_WORKSHEET_COLUMN_COUNT = 20;
var DEFAULT_WORKSHEET_ROW_HEIGHT = 24;
var DEFAULT_WORKSHEET_COLUMN_WIDTH = 88;
var DEFAULT_WORKSHEET_ROW_TITLE_WIDTH = 46;
var DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT = 20;
function mergeWorksheetSnapshotWithDefault(snapshot) {
  const defaultSnapshot = {
    name: "Sheet1",
    // TODO: name should have i18n
    id: "sheet-01",
    tabColor: "",
    hidden: 0 /* FALSE */,
    rowCount: DEFAULT_WORKSHEET_ROW_COUNT,
    columnCount: DEFAULT_WORKSHEET_COLUMN_COUNT,
    zoomRatio: 1,
    freeze: {
      xSplit: 0,
      ySplit: 0,
      startRow: -1,
      startColumn: -1
    },
    scrollTop: 0,
    scrollLeft: 0,
    defaultColumnWidth: DEFAULT_WORKSHEET_COLUMN_WIDTH,
    defaultRowHeight: DEFAULT_WORKSHEET_ROW_HEIGHT,
    mergeData: [],
    cellData: {},
    rowData: {},
    columnData: {},
    showGridlines: 1 /* TRUE */,
    rowHeader: {
      width: DEFAULT_WORKSHEET_ROW_TITLE_WIDTH,
      hidden: 0 /* FALSE */
    },
    columnHeader: {
      height: DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT,
      hidden: 0 /* FALSE */
    },
    rightToLeft: 0 /* FALSE */
  };
  Object.keys(defaultSnapshot).forEach((_key) => {
    const key = _key;
    if (typeof snapshot[key] === "undefined") {
      snapshot[key] = defaultSnapshot[key];
    }
  });
  return snapshot;
}

// ../packages/core/src/sheets/span-model.ts
var SpanModel = class extends Disposable {
  constructor(mergeData) {
    super();
    /**
     * @property Cache for RANGE_TYPE.NORMAL
     */
    __publicField(this, "_cellCache", /* @__PURE__ */ new Map());
    /**
     * @property Cache for RANGE_TYPE.ROW
     */
    __publicField(this, "_rowCache", /* @__PURE__ */ new Map());
    /**
     * @property Cache for RANGE_TYPE.COLUMN
     */
    __publicField(this, "_columnCache", /* @__PURE__ */ new Map());
    /**
     * @property Whether has RANGE_TYPE.ROW
     */
    __publicField(this, "_hasRow", false);
    /**
     * @property Whether has RANGE_TYPE.COLUMN
     */
    __publicField(this, "_hasColumn", false);
    /**
     * @property Whether has RANGE_TYPE.ALL
     */
    __publicField(this, "_hasAll", false);
    /**
     * @property Index for RANGE_TYPE.ALL
     */
    __publicField(this, "_allIndex", -1);
    /**
     * @property the original merge data
     */
    __publicField(this, "_mergeData");
    __publicField(this, "_rangeMap", new LRUMap(5e4));
    __publicField(this, "_skeletonCache", new LRUMap(5e4));
    this._init(mergeData.concat());
  }
  _init(mergeData) {
    this._mergeData = mergeData;
    this._createCache(mergeData);
  }
  _clearCache() {
    this._cellCache.clear();
    this._rowCache.clear();
    this._columnCache.clear();
    this._hasAll = false;
    this._allIndex = -1;
    this._rangeMap.clear();
    this._skeletonCache.clear();
    this._hasColumn = false;
    this._hasRow = false;
  }
  _createCache(mergeData) {
    let index = 0;
    for (const range of mergeData) {
      const { rangeType } = range;
      if (rangeType === 1 /* ROW */) {
        this._createRowCache(range, index);
      } else if (rangeType === 2 /* COLUMN */) {
        this._createColumnCache(range, index);
      } else if (rangeType === 3 /* ALL */) {
        this._createCellAllCache(index);
      } else {
        this._createCellCache(range, index);
      }
      index++;
    }
  }
  /**
   * Rebuild the merge data cache when the merge data is changed.
   * @param {IRange[]} mergeData
   */
  rebuild(mergeData) {
    this._clearCache();
    this._init(mergeData.concat());
  }
  _createRowCache(range, index) {
    const { startRow, endRow } = range;
    for (let i = startRow; i <= endRow; i++) {
      this._rowCache.set(i, index);
      this._hasRow = true;
    }
  }
  _createColumnCache(range, index) {
    const { startColumn, endColumn } = range;
    for (let i = startColumn; i <= endColumn; i++) {
      this._columnCache.set(i, index);
      this._hasColumn = true;
    }
  }
  _createCellAllCache(index) {
    this._hasAll = true;
    this._allIndex = index;
  }
  _createCellCache(range, index) {
    for (let i = range.startRow; i <= range.endRow; i++) {
      let columnCache = this._cellCache.get(i);
      if (columnCache == null) {
        columnCache = /* @__PURE__ */ new Map();
        this._cellCache.set(i, columnCache);
      }
      for (let j = range.startColumn; j <= range.endColumn; j++) {
        columnCache.set(j, index);
      }
    }
  }
  add(range) {
    this._mergeData.push(range);
    this._clearCache();
    this._createCache(this._mergeData);
  }
  remove(row, column) {
    const index = this._getMergeDataIndex(row, column);
    if (index !== -1) {
      this._mergeData.splice(index, 1);
      this._clearCache();
      this._createCache(this._mergeData);
    }
  }
  getMergedCell(row, column) {
    const index = this._getMergeDataIndex(row, column);
    if (index !== -1) {
      return this._mergeData[index];
    }
    return null;
  }
  /**
   * Return index of merge data if (row,col) is in merge range. -1 means not in merge range.
   * @param row
   * @param column
   * @returns {number} index of merge range.
   */
  getMergeDataIndex(row, column) {
    return this._getMergeDataIndex(row, column);
  }
  isRowContainsMergedCell(row) {
    if (this._hasAll) {
      return true;
    }
    if (!Tools.isEmptyObject(this._columnCache)) {
      return true;
    }
    return this._mergeData.some((mergedCell) => mergedCell.startRow <= row && row <= mergedCell.endRow);
  }
  isColumnContainsMergedCell(column) {
    if (this._hasAll) {
      return true;
    }
    if (!Tools.isEmptyObject(this._rowCache)) {
      return true;
    }
    return this._mergeData.some((mergedCell) => mergedCell.startColumn <= column && column <= mergedCell.endColumn);
  }
  getMergedCellRange(startRow, startColumn, endRow, endColumn) {
    const ranges = [];
    const key = `${startRow}-${startColumn}-${endRow}-${endColumn}`;
    if (this._rangeMap.has(key)) {
      return this._getRangeFromCache(key);
    }
    let index = 0;
    const indexes = [];
    for (const range of this._mergeData || []) {
      if (Rectangle.intersects(range, {
        startRow,
        endRow,
        startColumn,
        endColumn
      })) {
        ranges.push({
          ...range
        });
        indexes.push(index);
      }
      index++;
    }
    this._rangeMap.set(key, indexes);
    return ranges;
  }
  /**
   * @deprecated sigificant performance impact, use _getCellMergeInfo instead.
   * @param startRow
   * @param startColumn
   * @param endRow
   * @param endColumn
   */
  getMergedCellRangeForSkeleton(startRow, startColumn, endRow, endColumn) {
    const cacheDataMerge = [];
    const mergeData = this._mergeData;
    const key = `${startRow}-${startColumn}-${endRow}-${endColumn}`;
    if (this._skeletonCache.has(key)) {
      return this._getSkeletonRangeFromCache(key);
    }
    const indexes = [];
    for (let i = 0; i < mergeData.length; i++) {
      const {
        startRow: mergeStartRow,
        endRow: mergeEndRow,
        startColumn: mergeStartColumn,
        endColumn: mergeEndColumn
      } = mergeData[i];
      for (let r = startRow; r <= endRow; r++) {
        let isBreak = false;
        for (let c = startColumn; c <= endColumn; c++) {
          if (r >= mergeStartRow && r <= mergeEndRow && c >= mergeStartColumn && c <= mergeEndColumn) {
            cacheDataMerge.push({
              startRow: mergeStartRow,
              endRow: mergeEndRow,
              startColumn: mergeStartColumn,
              endColumn: mergeEndColumn
            });
            indexes.push(i);
            isBreak = true;
            break;
          }
        }
        if (isBreak) {
          break;
        }
      }
    }
    this._skeletonCache.set(key, indexes);
    return cacheDataMerge;
  }
  _getRangeFromCache(key) {
    const indexes = this._rangeMap.get(key) || [];
    const ranges = [];
    for (const index of indexes) {
      ranges.push({
        ...this._mergeData[index]
      });
    }
    return ranges;
  }
  _getSkeletonRangeFromCache(key) {
    const indexes = this._skeletonCache.get(key) || [];
    const ranges = [];
    for (const index of indexes) {
      ranges.push({
        ...this._mergeData[index]
      });
    }
    return ranges;
  }
  _getMergeDataIndex(row, column) {
    var _a2;
    if (this._hasAll) {
      return this._allIndex;
    }
    if (this._hasRow) {
      const rowValue = this._rowCache.get(row);
      if (rowValue !== void 0) {
        return rowValue;
      }
    }
    if (this._hasColumn) {
      const columnValue = this._columnCache.get(column);
      if (columnValue !== void 0) {
        return columnValue;
      }
    }
    const cellValue = (_a2 = this._cellCache.get(row)) == null ? void 0 : _a2.get(column);
    if (cellValue !== void 0) {
      return cellValue;
    }
    return -1;
  }
  getMergeDataSnapshot() {
    return this._mergeData;
  }
  dispose() {
    this._clearCache();
    this._mergeData = [];
  }
};

// ../packages/core/src/sheets/view-model.ts
var SheetViewModel = class extends Disposable {
  constructor(getRawCell) {
    super();
    this.getRawCell = getRawCell;
    __publicField(this, "_cellContentInterceptor", null);
    __publicField(this, "_rowFilteredInterceptor", null);
  }
  dispose() {
    super.dispose();
    this._cellContentInterceptor = null;
    this._rowFilteredInterceptor = null;
  }
  getCell(row, col, key, filter8) {
    if (this._cellContentInterceptor) {
      return this._cellContentInterceptor.getCell(row, col, 2 /* Value */ | 1 /* Style */, key, filter8);
    }
    return this.getRawCell(row, col);
  }
  getCellValueOnly(row, col) {
    if (this._cellContentInterceptor) {
      return this._cellContentInterceptor.getCell(row, col, 2 /* Value */);
    }
    return this.getRawCell(row, col);
  }
  getCellStyleOnly(row, col) {
    if (this._cellContentInterceptor) {
      return this._cellContentInterceptor.getCell(row, col, 1 /* Style */);
    }
    return this.getRawCell(row, col);
  }
  getRowFiltered(row) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._rowFilteredInterceptor) == null ? void 0 : _a2.getRowFiltered(row)) != null ? _b2 : false;
  }
  registerCellContentInterceptor(interceptor) {
    if (this._cellContentInterceptor) {
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    }
    this._cellContentInterceptor = interceptor;
    return toDisposable(() => this._cellContentInterceptor = null);
  }
  registerRowFilteredInterceptor(interceptor) {
    if (this._rowFilteredInterceptor) {
      throw new Error("[SheetViewModel]: Interceptor already registered.");
    }
    this._rowFilteredInterceptor = interceptor;
    return toDisposable(() => this._rowFilteredInterceptor = null);
  }
};

// ../packages/core/src/sheets/worksheet.ts
var DEFAULT_CELL_DOCUMENT_MODEL_OPTION = {
  isDeepClone: false,
  displayRawFormula: false,
  ignoreTextRotation: false
};
var Worksheet = class _Worksheet {
  constructor(unitId, snapshot, _styles) {
    this.unitId = unitId;
    this._styles = _styles;
    __publicField(this, "_sheetId");
    __publicField(this, "_snapshot");
    __publicField(this, "_cellData");
    __publicField(this, "_rowManager");
    __publicField(this, "_columnManager");
    __publicField(this, "_viewModel");
    __publicField(this, "_spanModel");
    var _a2;
    this._snapshot = mergeWorksheetSnapshotWithDefault(snapshot);
    const { columnData, rowData, cellData } = this._snapshot;
    this._sheetId = (_a2 = this._snapshot.id) != null ? _a2 : Tools.generateRandomId(6);
    this._cellData = new ObjectMatrix(cellData);
    this._viewModel = new SheetViewModel((row, col) => this.getCellRaw(row, col));
    this._rowManager = new RowManager(this._snapshot, this._viewModel, rowData);
    this._columnManager = new ColumnManager(this._snapshot, columnData);
    this._spanModel = new SpanModel(this._snapshot.mergeData);
  }
  /**
   * @internal
   * @param callback
   */
  __interceptViewModel(callback) {
    callback(this._viewModel);
  }
  getSnapshot() {
    return this._snapshot;
  }
  /**
   * Set the merge data of the sheet, all the merged cells will be rebuilt.
   * @param mergeData
   */
  setMergeData(mergeData) {
    this._snapshot.mergeData = mergeData;
    this.getSpanModel().rebuild(mergeData);
  }
  getSpanModel() {
    return this._spanModel;
  }
  getStyleDataByHash(hash) {
    const data = this._styles.get(hash);
    return { ...data };
  }
  setStyleData(style) {
    return this._styles.setValue(style);
  }
  getColumnStyle(column, keepRaw = false) {
    if (keepRaw) {
      return this._columnManager.getColumnStyle(column);
    }
    return this._styles.get(this._columnManager.getColumnStyle(column));
  }
  /**
   * Set the style of the column.
   * @param {number} column The column index
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setColumnStyle(column, style) {
    this._columnManager.setColumnStyle(column, style);
  }
  getRowStyle(row, keepRaw = false) {
    if (keepRaw) {
      return this._rowManager.getRowStyle(row);
    }
    return this._styles.get(this._rowManager.getRowStyle(row));
  }
  /**
   * Set the style of the row.
   * @param {number} row
   * @param {string|Nullable<IStyleData>} style The style to be set
   */
  setRowStyle(row, style) {
    this._rowManager.setRowStyle(row, style);
  }
  /**
   * this function is used to mixin default style to cell raw{number}
   * @param {number} row The row index
   * @param {number} col The column index
   * @param cellRaw The cell raw data
   * @param {boolean} isRowStylePrecedeColumnStyle The priority of row style and column style
   */
  mixinDefaultStyleToCellRaw(row, col, cellRaw, isRowStylePrecedeColumnStyle) {
    const columnStyle = this.getColumnStyle(col);
    const rowStyle = this.getRowStyle(row);
    const defaultStyle = this.getDefaultCellStyleInternal();
    if (defaultStyle || columnStyle || rowStyle) {
      let cellStyle = cellRaw == null ? void 0 : cellRaw.s;
      if (typeof cellStyle === "string") {
        cellStyle = this._styles.get(cellStyle);
      }
      const s = isRowStylePrecedeColumnStyle ? composeStyles(defaultStyle, columnStyle, rowStyle, cellStyle) : composeStyles(defaultStyle, rowStyle, columnStyle, cellStyle);
      if (!cellRaw) {
        cellRaw = {};
      }
      cellRaw.s = s;
    }
  }
  /**
   * Get the default style of the worksheet.
   * @returns {Nullable<IStyleData>} Default Style
   */
  getDefaultCellStyle() {
    return this._snapshot.defaultStyle;
  }
  getDefaultCellStyleInternal() {
    const style = this._snapshot.defaultStyle;
    return this._styles.get(style);
  }
  /**
   * Set Default Style, if the style has been set, all cells style will be base on this style.
   * @param {Nullable<IStyleData>} style The style to be set as default style
   */
  setDefaultCellStyle(style) {
    this._snapshot.defaultStyle = style;
  }
  getCellStyle(row, col) {
    const cell = this.getCell(row, col);
    if (cell) {
      const style = cell.s;
      if (typeof style === "string") {
        return this._styles.get(style);
      }
      return style;
    }
    return null;
  }
  /**
   * Returns WorkSheet Cell Data Matrix
   * @returns WorkSheet Cell Data Matrix
   */
  getCellMatrix() {
    return this._cellData;
  }
  /**
   * Get worksheet printable cell range.
   * @returns
   */
  // eslint-disable-next-line max-lines-per-function
  getCellMatrixPrintRange() {
    const matrix = this.getCellMatrix();
    const mergedCells = this.getMergeData();
    let startRow = -1;
    let endRow = -1;
    let startColumn = -1;
    let endColumn = -1;
    let rowInitd = false;
    let columnInitd = false;
    matrix.forEach((rowIndex, row) => {
      Object.keys(row).forEach((colIndexStr) => {
        const colIndex = +colIndexStr;
        const cellValue = matrix.getValue(rowIndex, colIndex);
        const style = (cellValue == null ? void 0 : cellValue.s) ? this._styles.get(cellValue.s) : null;
        const isLegalBorder = (style == null ? void 0 : style.bd) && (style.bd.b || style.bd.l || style.bd.r || style.bd.t || style.bd.bc_tr || style.bd.bl_tr || style.bd.ml_tr || style.bd.tl_bc || style.bd.tl_br || style.bd.tl_mr);
        if (cellValue && (cellValue.v || cellValue.p) || (style == null ? void 0 : style.bg) || isLegalBorder) {
          if (rowInitd) {
            startRow = Math.min(startRow, rowIndex);
          } else {
            startRow = rowIndex;
            rowInitd = true;
          }
          endRow = Math.max(endRow, rowIndex);
          if (columnInitd) {
            startColumn = Math.min(startColumn, colIndex);
          } else {
            columnInitd = true;
            startColumn = colIndex;
          }
          endColumn = Math.max(endColumn, colIndex);
        }
      });
    });
    mergedCells.forEach((mergedCell) => {
      if (rowInitd) {
        startRow = Math.min(startRow, mergedCell.startRow);
      } else {
        startRow = mergedCell.startRow;
        rowInitd = true;
      }
      endRow = Math.max(endRow, mergedCell.endRow);
      if (columnInitd) {
        startColumn = Math.min(startColumn, mergedCell.startColumn);
      } else {
        startColumn = mergedCell.startColumn;
        rowInitd = true;
      }
      endColumn = Math.max(endColumn, mergedCell.endColumn);
    });
    if (!rowInitd || !columnInitd) {
      return null;
    }
    return {
      startColumn,
      startRow,
      endColumn,
      endRow
    };
  }
  /**
   * Returns Row Manager
   * @returns Row Manager
   */
  getRowManager() {
    return this._rowManager;
  }
  /**
   * Returns the ID of its parent unit.
   */
  getUnitId() {
    return this.unitId;
  }
  /**
   * Returns the ID of the sheet represented by this object.
   * @returns ID of the sheet
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Returns Column Manager
   * @returns Column Manager
   */
  getColumnManager() {
    return this._columnManager;
  }
  /**
   * Returns the name of the sheet.
   * @returns name of the sheet
   */
  getName() {
    return this._snapshot.name;
  }
  /**
   * Returns WorkSheet Clone Object
   * @returns WorkSheet Clone Object
   * @deprecated
   */
  clone() {
    const { _snapshot: _config } = this;
    const copy = Tools.deepClone(_config);
    return new _Worksheet(this.unitId, copy, this._styles);
  }
  /**
   * Get the merged cell list of the sheet.
   * @returns {IRange[]} merged cell list
   */
  getMergeData() {
    return this._spanModel.getMergeDataSnapshot();
  }
  /**
   * Get the merged cell Range of the sheet cell.
   * If (row, col) is not in a merged cell, return null
   *
   * @param {number} row The row index of test cell
   * @param {number} col The column index of test cell
   * @returns {Nullable<IRange>} The merged cell range of the cell, if the cell is not in a merged cell, return null
   */
  getMergedCell(row, col) {
    return this._spanModel.getMergedCell(row, col);
  }
  /**
   * Get the merged cell info list which has intersection with the given range.
   * @param {number} startRow The start row index of the range
   * @param {number} startColumn The start column index of the range
   * @param {number} endRow The end row index of the range
   * @param {number} endColumn The end column index of the range
   * @returns {IRange} The merged cell info list which has intersection with the given range or empty array if no merged cell in the range
   */
  getMergedCellRange(startRow, startColumn, endRow, endColumn) {
    return this._spanModel.getMergedCellRange(startRow, startColumn, endRow, endColumn);
  }
  /**
   * Get if the row contains merged cell
   * @param {number} row The row index
   * @returns {boolean} Is merge cell across row
   */
  isRowContainsMergedCell(row) {
    return this._spanModel.isRowContainsMergedCell(row);
  }
  /**
   * Get if the column contains merged cell
   * @param {number} column The column index
   * @returns {boolean} Is merge cell across column
   */
  isColumnContainsMergedCell(column) {
    return this._spanModel.isColumnContainsMergedCell(column);
  }
  /**
   * Get cell info with merge data
   * @param {number} row - The row index of the cell.
   * @param {number} column - The column index of the cell.
   * @type {selectionCell}
   * @property {number} actualRow - The actual row index of the cell
   * @property {number} actualColumn - The actual column index of the cell
   * @property {boolean} isMergedMainCell - Whether the cell is the main cell of the merged cell, only the upper left cell in the merged cell returns true here
   * @property {boolean} isMerged - Whether the cell is in a merged cell, the upper left cell in the merged cell returns false here
   * @property {number} endRow - The end row index of the merged cell
   * @property {number} endColumn - The end column index of the merged cell
   * @property {number} startRow - The start row index of the merged cell
   * @property {number} startColumn - The start column index of the merged cell
   * @returns  {selectionCell} - The cell info with merge data
   */
  getCellInfoInMergeData(row, column) {
    const mergeRange = this.getMergedCell(row, column);
    let isMerged = false;
    let isMergedMainCell = false;
    let mergeEndRow = row;
    let mergeEndColumn = column;
    let mergeStartRow = row;
    let mergeStartColumn = column;
    if (mergeRange) {
      const {
        startRow: startRowMerge,
        endRow: endRowMerge,
        startColumn: startColumnMerge,
        endColumn: endColumnMerge
      } = mergeRange;
      if (row === startRowMerge && column === startColumnMerge) {
        mergeEndRow = endRowMerge;
        mergeEndColumn = endColumnMerge;
        mergeStartRow = startRowMerge;
        mergeStartColumn = startColumnMerge;
        isMergedMainCell = true;
      } else if (row >= startRowMerge && row <= endRowMerge && column >= startColumnMerge && column <= endColumnMerge) {
        mergeEndRow = endRowMerge;
        mergeEndColumn = endColumnMerge;
        mergeStartRow = startRowMerge;
        mergeStartColumn = startColumnMerge;
        isMerged = true;
      }
    }
    return {
      actualRow: row,
      actualColumn: column,
      isMergedMainCell,
      isMerged,
      endRow: mergeEndRow,
      endColumn: mergeEndColumn,
      startRow: mergeStartRow,
      startColumn: mergeStartColumn
    };
  }
  /**
   * Get cellData, includes cellData, customRender, markers, dataValidate, etc.
   *
   * WARNING: All sheet CELL_CONTENT interceptors will be called in this method, cause performance issue.
   * example: this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT);
   *
   * @param row
   * @param col
   * @returns ICellDataForSheetInterceptor
   */
  getCell(row, col) {
    if (row < 0 || col < 0) {
      return null;
    }
    return this._viewModel.getCell(row, col);
  }
  /**
   * Get cellData only use effect on value interceptor
   * @param {number} number row The row index of the cell.
   * @param {number} number col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on value interceptor
   */
  getCellValueOnly(row, col) {
    if (row < 0 || col < 0) {
      return null;
    }
    return this._viewModel.getCellValueOnly(row, col);
  }
  /**
   * Get cellData only use effect on style interceptor
   * @param {number} row The row index of the cell.
   * @param {number} col The column index of the cell.
   * @returns {Nullable<ICellDataForSheetInterceptor>} The cell data only use effect on style interceptor
   */
  getCellStyleOnly(row, col) {
    if (row < 0 || col < 0) {
      return null;
    }
    return this._viewModel.getCellStyleOnly(row, col);
  }
  getCellRaw(row, col) {
    return this.getCellMatrix().getValue(row, col);
  }
  // eslint-disable-next-line ts/no-explicit-any
  getCellWithFilteredInterceptors(row, col, key, filter8) {
    return this._viewModel.getCell(row, col, key, filter8);
  }
  getRowFiltered(row) {
    return this._viewModel.getRowFiltered(row);
  }
  getMatrixWithMergedCells(row, col, endRow, endCol, dataMode = "raw" /* Raw */) {
    const matrix = this.getCellMatrix();
    const mergedCellsInRange = this._spanModel.getMergedCellRange(row, col, endRow, endCol);
    const returnCellMatrix = new ObjectMatrix();
    createRowColIter(row, endRow, col, endCol).forEach((row2, col2) => {
      var _a2;
      let cellData;
      if (dataMode === "raw" /* Raw */) {
        cellData = this.getCellRaw(row2, col2);
      } else if (dataMode === "intercepted" /* Intercepted */) {
        cellData = this.getCell(row2, col2);
      } else if (dataMode === "both" /* Both */) {
        const cellDataRaw = this.getCellRaw(row2, col2);
        if (cellDataRaw) {
          cellData = { ...cellDataRaw };
          const displayV = (_a2 = this.getCell(row2, col2)) == null ? void 0 : _a2.v;
          if (isNotNullOrUndefined(displayV) && cellData) {
            cellData.displayV = String(displayV);
          }
        }
      }
      if (cellData) {
        returnCellMatrix.setValue(row2, col2, cellData);
      }
    });
    mergedCellsInRange.forEach((mergedCell) => {
      const { startColumn, startRow, endColumn, endRow: endRow2 } = mergedCell;
      createRowColIter(startRow, endRow2, startColumn, endColumn).forEach((row2, col2) => {
        if (row2 === startRow && col2 === startColumn) {
          returnCellMatrix.setValue(row2, col2, {
            ...matrix.getValue(row2, col2),
            rowSpan: endRow2 - startRow + 1,
            colSpan: endColumn - startColumn + 1
          });
        }
        if (row2 !== startRow || col2 !== startColumn) {
          returnCellMatrix.realDeleteValue(row2, col2);
        }
      });
    });
    return returnCellMatrix;
  }
  getRange(startRowOrRange, startColumn, endRow, endColumn) {
    if (typeof startRowOrRange === "object") {
      return new Range(this, startRowOrRange, {
        getStyles: () => this._styles
      });
    }
    return new Range(
      this,
      {
        startRow: startRowOrRange,
        startColumn,
        endColumn: endColumn || startColumn,
        endRow: endRow || startRowOrRange
      },
      {
        getStyles: () => this._styles
      }
    );
  }
  getScrollLeftTopFromSnapshot() {
    return {
      scrollLeft: this._snapshot.scrollLeft,
      scrollTop: this._snapshot.scrollTop
    };
  }
  /**
   * Return WorkSheetZoomRatio
   * @return zoomRatio
   */
  getZoomRatio() {
    return this._snapshot.zoomRatio || 1;
  }
  /**
   * Returns WorkSheet Configures
   * @returns WorkSheet Configures
   */
  getConfig() {
    return this._snapshot;
  }
  /**
   * Returns  frozen.
   * @returns  frozen
   */
  getFreeze() {
    return this._snapshot.freeze;
  }
  /**
   * Returns the current number of columns in the sheet, regardless of content.
   * @returns the current number of columns in the sheet, regardless of content
   */
  getMaxColumns() {
    const { _snapshot: _config } = this;
    const { columnCount } = _config;
    return columnCount;
  }
  /**
   * Returns the current number of rows in the sheet, regardless of content.
   * @returns the current number of rows in the sheet, regardless of content
   */
  getMaxRows() {
    const { _snapshot: _config } = this;
    const { rowCount } = _config;
    return rowCount;
  }
  getRowCount() {
    return this._snapshot.rowCount;
  }
  setRowCount(count) {
    this._snapshot.rowCount = count;
  }
  getColumnCount() {
    return this._snapshot.columnCount;
  }
  setColumnCount(count) {
    this._snapshot.columnCount = count;
  }
  /**
   * isSheetHidden
   * @returns hidden status of sheet
   */
  isSheetHidden() {
    return this._snapshot.hidden;
  }
  /**
   * Returns true if the sheet's gridlines are hidden; otherwise returns false. Gridlines are visible by default.
   * @returns {boolean} Gridlines Hidden Status.
   */
  hasHiddenGridlines() {
    const { _snapshot: _config } = this;
    const { showGridlines } = _config;
    if (showGridlines === 0) {
      return true;
    }
    return false;
  }
  /**
   * Returns the color of the gridlines, or undefined if the gridlines are not colored.
   * @returns {string | undefined} returns the color of the gridlines, or undefined if the gridlines are default.
   */
  getGridlinesColor() {
    return this.getConfig().gridlinesColor;
  }
  /**
   * Gets the sheet tab color, or null if the sheet tab has no color.
   * @returns the sheet tab color or null
   */
  getTabColor() {
    const { _snapshot: _config } = this;
    const { tabColor } = _config;
    return tabColor;
  }
  /**
   * Gets the width in pixels of the given column.
   * @param columnPosition column index
   * @returns Gets the width in pixels of the given column.
   */
  getColumnWidth(columnPosition) {
    return this.getColumnManager().getColumnWidth(columnPosition);
  }
  /**
   * Gets the height in pixels of the given row.
   * @param row row index
   * @returns Gets the height in pixels of the given row.
   */
  getRowHeight(row) {
    const filtered = this._viewModel.getRowFiltered(row);
    if (filtered) return 0;
    return this.getRowManager().getRowHeight(row);
  }
  /**
   * Row is filtered out, that means this row is invisible.
   * @param row
   * @returns {boolean} is row hidden by filter
   */
  isRowFiltered(row) {
    return this._viewModel.getRowFiltered(row);
  }
  /**
   * Get if the row is visible. It may be affected by features like filter and view.
   * @param row the row index
   * @returns {boolean} if the row in visible to the user
   */
  getRowVisible(row) {
    return !this.isRowFiltered(row) && this.getRowRawVisible(row);
  }
  /**
   * Get if the row does not have `hidden` property. This value won't affected by features like filter and view.
   * @param row the row index
   * @returns if the row does not have `hidden` property
   */
  getRowRawVisible(row) {
    return this.getRowManager().getRowRawVisible(row);
  }
  getHiddenRows(start, end) {
    const lastColumn = this.getMaxColumns() - 1;
    const ranges = this._rowManager.getHiddenRows(start, end);
    ranges.forEach((range) => range.endColumn = lastColumn);
    return ranges;
  }
  getColVisible(col) {
    return this._columnManager.getColVisible(col);
  }
  getHiddenCols(start, end) {
    const lastRow = this.getMaxRows() - 1;
    const ranges = this._columnManager.getHiddenCols(start, end);
    ranges.forEach((range) => range.endRow = lastRow);
    return ranges;
  }
  /**
   * Get all visible rows in the sheet.(not include filter & view, like getRawVisibleRows)
   * @returns Visible rows range list
   */
  getVisibleRows() {
    const rowCount = this.getRowCount();
    return this._rowManager.getVisibleRows(0, rowCount - 1);
  }
  /**
   * Get all visible columns in the sheet.(not include filter & view)
   * @returns Visible columns range list
   */
  getVisibleCols() {
    const columnCount = this.getColumnCount();
    return this._columnManager.getVisibleCols(0, columnCount - 1);
  }
  /**
   * Returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   * @returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
   */
  isRightToLeft() {
    const { _snapshot: _config } = this;
    const { rightToLeft } = _config;
    return rightToLeft;
  }
  /**
   * Returns the position of the last row that has content.
   * @returns the position of the last row that has content.
   */
  getLastRowWithContent() {
    return this._cellData.getLength() - 1;
  }
  /**
   * Returns the position of the last column that has content.
   * @returns the position of the last column that has content.
   */
  getLastColumnWithContent() {
    return this._cellData.getRange().endColumn;
  }
  getDataRangeScope() {
    return this._cellData.getStartEndScope();
  }
  cellHasValue(value) {
    return value && (value.v !== void 0 || value.f !== void 0 || value.p !== void 0);
  }
  // #region iterators
  // NOTE: performance intensive. Should keep an eye on methods in this region.
  /**
   * Iterate a range row by row.
   *
   * Performance intensive.
   *
   * @param range the iterate range
   * @param skipEmpty whether to skip empty cells, default to be `true`
   */
  iterateByRow(range, skipEmpty = true) {
    const { startRow, startColumn, endRow, endColumn } = range;
    const worksheet = this;
    return {
      [Symbol.iterator]: () => {
        let rowIndex = startRow;
        let columnIndex = startColumn;
        return {
          next() {
            while (true) {
              if (columnIndex > endColumn) {
                rowIndex += 1;
                columnIndex = startColumn;
              }
              if (rowIndex > endRow) {
                return { done: true, value: void 0 };
              }
              const cellValue = worksheet.getCell(rowIndex, columnIndex);
              const isEmptyCell2 = !cellValue;
              const mergedCell = worksheet.getMergedCell(rowIndex, columnIndex);
              if (mergedCell) {
                const isNotTopLeft = rowIndex !== mergedCell.startRow || columnIndex !== mergedCell.startColumn;
                if (isNotTopLeft) {
                  columnIndex = mergedCell.endColumn + 1;
                  continue;
                }
                if (isEmptyCell2 && skipEmpty) {
                  columnIndex = mergedCell.endColumn + 1;
                  continue;
                }
                const value = { row: rowIndex, col: columnIndex, value: cellValue };
                value.colSpan = mergedCell.endColumn - mergedCell.startColumn + 1;
                value.rowSpan = mergedCell.endRow - mergedCell.startRow + 1;
                columnIndex = mergedCell.endColumn + 1;
                return { done: false, value };
              }
              if (isEmptyCell2 && skipEmpty) {
                columnIndex += 1;
              } else {
                const value = { row: rowIndex, col: columnIndex, value: cellValue };
                columnIndex += 1;
                return { done: false, value };
              }
            }
          }
        };
      }
    };
  }
  /**
   * Iterate a range column by column. This is pretty similar to `iterateByRow` but with different order.
   *
   * Performance intensive.
   *
   * @param range The iterate range.
   * @param skipEmpty Whether to skip empty cells, default to be `true`.
   * @param skipNonTopLeft Whether to skip non-top-left cells of merged cells, default to be `true`. If the
   * parameter is set to `false`, the iterator will return cells in the top row.
   */
  iterateByColumn(range, skipEmpty = true, skipNonTopLeft = true) {
    const { startRow, startColumn, endRow, endColumn } = range;
    const worksheet = this;
    return {
      [Symbol.iterator]: () => {
        let rowIndex = startRow;
        let columnIndex = startColumn;
        return {
          next() {
            while (true) {
              if (rowIndex > endRow) {
                columnIndex += 1;
                rowIndex = startRow;
              }
              if (columnIndex > endColumn) {
                return { done: true, value: void 0 };
              }
              const mergedCell = worksheet.getMergedCell(rowIndex, columnIndex);
              if (mergedCell) {
                const isNotTop = rowIndex !== mergedCell.startRow;
                const isNotTopLeft = isNotTop || columnIndex !== mergedCell.startColumn;
                if (skipNonTopLeft && isNotTopLeft || !skipNonTopLeft && isNotTop) {
                  rowIndex = mergedCell.endRow + 1;
                  continue;
                }
                const cellValue2 = worksheet.getCell(mergedCell.startRow, mergedCell.startColumn);
                const isEmptyCell3 = !cellValue2;
                if (isEmptyCell3 && skipEmpty) {
                  rowIndex = mergedCell.endRow + 1;
                  continue;
                }
                const value = { row: rowIndex, col: mergedCell.startColumn, value: cellValue2 };
                value.colSpan = mergedCell.endColumn - mergedCell.startColumn + 1;
                value.rowSpan = mergedCell.endRow - mergedCell.startRow + 1;
                rowIndex = mergedCell.endRow + 1;
                return { done: false, value };
              }
              const cellValue = worksheet.getCell(rowIndex, columnIndex);
              const isEmptyCell2 = !cellValue;
              if (isEmptyCell2 && skipEmpty) {
                rowIndex += 1;
              } else {
                const value = { row: rowIndex, col: columnIndex, value: cellValue };
                rowIndex += 1;
                return { done: false, value };
              }
            }
          }
        };
      }
    };
  }
  /**
   * This method generates a document model based on the cell's properties and handles the associated styles and configurations.
   * If the cell does not exist, it will return null.
   * PS: This method has significant impact on performance.
   * @param cell
   * @param options
   */
  // eslint-disable-next-line complexity, max-lines-per-function
  _getCellDocumentModel(cell, options = DEFAULT_CELL_DOCUMENT_MODEL_OPTION) {
    var _a2;
    const { isDeepClone, displayRawFormula, ignoreTextRotation } = {
      ...DEFAULT_CELL_DOCUMENT_MODEL_OPTION,
      ...options
    };
    const style = this._styles.getStyleByCell(cell);
    if (!cell) {
      return;
    }
    let documentModel;
    let fontString = "document";
    const cellOtherConfig = extractOtherStyle(style);
    const textRotation = ignoreTextRotation ? DEFAULT_STYLES.tr : cellOtherConfig.textRotation || DEFAULT_STYLES.tr;
    let horizontalAlign = cellOtherConfig.horizontalAlign || DEFAULT_STYLES.ht;
    const verticalAlign = cellOtherConfig.verticalAlign || DEFAULT_STYLES.vt;
    const wrapStrategy = cellOtherConfig.wrapStrategy || DEFAULT_STYLES.tb;
    const paddingData = cellOtherConfig.paddingData || DEFAULT_PADDING_DATA;
    if (cell.f && displayRawFormula) {
      documentModel = createDocumentModelWithStyle(cell.f.toString(), {}, { verticalAlign });
      horizontalAlign = DEFAULT_STYLES.ht;
    } else if (cell.p) {
      const { centerAngle, vertexAngle } = convertTextRotation(textRotation);
      documentModel = this._updateConfigAndGetDocumentModel(
        isDeepClone ? Tools.deepClone(cell.p) : cell.p,
        horizontalAlign,
        paddingData,
        {
          horizontalAlign,
          verticalAlign,
          centerAngle,
          vertexAngle,
          wrapStrategy,
          zeroWidthParagraphBreak: 1
        }
      );
    } else if (cell.v != null) {
      const textStyle = getFontFormat(style);
      fontString = getFontStyleString(textStyle).fontCache;
      let cellText = extractPureTextFromCell(cell);
      if (cell.t === 4 /* FORCE_STRING */ && displayRawFormula) {
        cellText = `'${cellText}`;
      }
      documentModel = createDocumentModelWithStyle(cellText, textStyle, {
        ...cellOtherConfig,
        textRotation,
        cellValueType: cell.t
      });
    }
    if (documentModel && cell.linkUrl && cell.linkId) {
      addLinkToDocumentModel(documentModel, cell.linkUrl, cell.linkId);
    }
    return {
      documentModel,
      fontString,
      textRotation,
      wrapStrategy,
      verticalAlign,
      horizontalAlign,
      paddingData,
      fill: (_a2 = style == null ? void 0 : style.bg) == null ? void 0 : _a2.rgb
    };
  }
  _updateConfigAndGetDocumentModel(documentData, horizontalAlign, paddingData, renderConfig) {
    var _a2, _b2, _c, _d, _e;
    if (!renderConfig) {
      return;
    }
    if (!((_a2 = documentData.body) == null ? void 0 : _a2.dataStream)) {
      return;
    }
    if (!documentData.documentStyle) {
      documentData.documentStyle = {};
    }
    documentData.documentStyle.marginTop = (_b2 = paddingData.t) != null ? _b2 : 0;
    documentData.documentStyle.marginBottom = (_c = paddingData.b) != null ? _c : 2;
    documentData.documentStyle.marginLeft = (_d = paddingData.l) != null ? _d : 2;
    documentData.documentStyle.marginRight = (_e = paddingData.r) != null ? _e : 2;
    documentData.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    };
    documentData.documentStyle.renderConfig = {
      ...documentData.documentStyle.renderConfig,
      ...renderConfig
    };
    const paragraphs = documentData.body.paragraphs || [];
    for (const paragraph of paragraphs) {
      if (!paragraph.paragraphStyle) {
        paragraph.paragraphStyle = {};
      }
      paragraph.paragraphStyle.horizontalAlign = horizontalAlign;
    }
    return new DocumentDataModel(documentData);
  }
  /**
   * Only used for cell edit, and no need to rotate text when edit cell content!
   */
  getBlankCellDocumentModel(cell) {
    const documentModelObject = this._getCellDocumentModel(cell, { ignoreTextRotation: true });
    const style = this._styles.getStyleByCell(cell);
    const textStyle = getFontFormat(style);
    if (documentModelObject != null) {
      if (documentModelObject.documentModel == null) {
        documentModelObject.documentModel = createDocumentModelWithStyle("", textStyle);
      }
      return documentModelObject;
    }
    const content = "";
    let fontString = "document";
    const textRotation = DEFAULT_STYLES.tr;
    const horizontalAlign = DEFAULT_STYLES.ht;
    const verticalAlign = DEFAULT_STYLES.vt;
    const wrapStrategy = DEFAULT_STYLES.tb;
    const paddingData = DEFAULT_PADDING_DATA;
    fontString = getFontStyleString({}).fontCache;
    const documentModel = createDocumentModelWithStyle(content, textStyle);
    return {
      documentModel,
      fontString,
      textRotation,
      wrapStrategy,
      verticalAlign,
      horizontalAlign,
      paddingData
    };
  }
  // Only used for cell edit, and no need to rotate text when edit cell content!
  getCellDocumentModelWithFormula(cell) {
    return this._getCellDocumentModel(cell, {
      isDeepClone: true,
      displayRawFormula: true,
      ignoreTextRotation: true
    });
  }
  /**
   * Get custom metadata of worksheet
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(custom) {
    this._snapshot.custom = custom;
  }
};
function extractPureTextFromCell(cell) {
  var _a2, _b2;
  if (!cell) {
    return "";
  }
  const richTextValue = (_b2 = (_a2 = cell.p) == null ? void 0 : _a2.body) == null ? void 0 : _b2.dataStream;
  if (richTextValue) {
    return BuildTextUtils.transform.getPlainText(richTextValue);
  }
  const rawValue = cell.v;
  if (typeof rawValue === "string") {
    if (cell.t === 3 /* BOOLEAN */) {
      return rawValue.toUpperCase();
    }
    return rawValue.replace(/[\r\n]/g, "");
  }
  ;
  if (typeof rawValue === "number") {
    if (cell.t === 3 /* BOOLEAN */) return rawValue ? "TRUE" : "FALSE";
    return rawValue.toString();
  }
  ;
  if (typeof rawValue === "boolean") return rawValue ? "TRUE" : "FALSE";
  return "";
}

// ../packages/core/src/sheets/workbook.ts
var Workbook = class extends UnitModel {
  constructor(workbookData = {}, _logService) {
    super();
    this._logService = _logService;
    __publicField(this, "type", O.UNIVER_SHEET);
    __publicField(this, "_sheetCreated$", new import_rxjs9.Subject());
    __publicField(this, "sheetCreated$", this._sheetCreated$.asObservable());
    __publicField(this, "_sheetDisposed$", new import_rxjs9.Subject());
    __publicField(this, "sheetDisposed$", this._sheetDisposed$.asObservable());
    __publicField(this, "_activeSheet$", new import_rxjs9.BehaviorSubject(null));
    __publicField(this, "activeSheet$", this._activeSheet$.asObservable());
    /**
     * sheets list
     * @private
     */
    __publicField(this, "_worksheets");
    /**
     * Common style
     * @private
     */
    __publicField(this, "_styles");
    /**
     * number format
     * @private
     */
    // private _formatManage: FormatManager;
    __publicField(this, "_snapshot");
    __publicField(this, "_unitId");
    __publicField(this, "_count");
    __publicField(this, "_name$");
    __publicField(this, "name$");
    const DEFAULT_WORKBOOK = getEmptySnapshot2();
    if (Tools.isEmptyObject(workbookData)) {
      this._snapshot = DEFAULT_WORKBOOK;
    } else {
      this._snapshot = Tools.commonExtend(DEFAULT_WORKBOOK, workbookData);
    }
    const { styles } = this._snapshot;
    if (this._snapshot.id == null || this._snapshot.id.length === 0) {
      this._snapshot.id = Tools.generateRandomId(6);
    }
    this._unitId = this._snapshot.id;
    this._styles = new Styles(styles);
    this._count = 1;
    this._worksheets = /* @__PURE__ */ new Map();
    this._name$ = new import_rxjs9.BehaviorSubject(workbookData.name || "");
    this.name$ = this._name$.asObservable();
    this._parseWorksheetSnapshots();
  }
  get _activeSheet() {
    return this._activeSheet$.getValue();
  }
  get name() {
    return this._name$.getValue();
  }
  static isIRangeType(range) {
    return typeof range === "string" || "startRow" in range || "row" in range;
  }
  dispose() {
    super.dispose();
    this._sheetCreated$.complete();
    this._sheetDisposed$.complete();
    this._activeSheet$.complete();
    this._name$.complete();
  }
  /**
   * Create a clone of the current snapshot.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @memberof Workbook
   */
  save() {
    return Tools.deepClone(this._snapshot);
  }
  /**
   * Get current snapshot reference.
   * Call resourceLoaderService.saveWorkbook to save the data associated with the current plugin if needed.
   * @return {*}  {IWorkbookData}
   * @memberof Workbook
   */
  getSnapshot() {
    return this._snapshot;
  }
  /** @deprecated use use name property instead */
  getName() {
    return this._snapshot.name;
  }
  setName(name) {
    this._name$.next(name);
    this._snapshot.name = name;
  }
  getUnitId() {
    return this._unitId;
  }
  getRev() {
    var _a2;
    return (_a2 = this._snapshot.rev) != null ? _a2 : 1;
  }
  incrementRev() {
    this._snapshot.rev = this.getRev() + 1;
  }
  setRev(rev) {
    this._snapshot.rev = rev;
  }
  /**
   * Add a Worksheet into Workbook.
   */
  addWorksheet(id, index, worksheetSnapshot) {
    const { sheets, sheetOrder } = this._snapshot;
    if (sheets[id]) {
      return false;
    }
    sheets[id] = worksheetSnapshot;
    sheetOrder.splice(index, 0, id);
    const worksheet = new Worksheet(this._unitId, worksheetSnapshot, this._styles);
    this._worksheets.set(id, worksheet);
    this._sheetCreated$.next(worksheet);
    return true;
  }
  getSheetOrders() {
    return this._snapshot.sheetOrder;
  }
  getWorksheets() {
    return this._worksheets;
  }
  getActiveSpreadsheet() {
    return this;
  }
  getStyles() {
    return this._styles;
  }
  getConfig() {
    return this._snapshot;
  }
  getIndexBySheetId(sheetId) {
    const { sheetOrder } = this._snapshot;
    return sheetOrder.findIndex((id) => id === sheetId);
  }
  getActiveSheet(allowNull) {
    if (!this._activeSheet && typeof allowNull === "undefined") {
      throw new Error(`[Workbook]: no active Worksheet on Workbook ${this._unitId}!`);
    }
    return this._activeSheet;
  }
  /**
   * If there is no active sheet, the first sheet would
   * be set active.
   * @returns
   */
  ensureActiveSheet() {
    const currentActive = this._activeSheet;
    if (currentActive) {
      return currentActive;
    }
    const sheetOrder = this._snapshot.sheetOrder;
    for (let i = 0, len = sheetOrder.length; i < len; i++) {
      const worksheet2 = this._worksheets.get(sheetOrder[i]);
      if (worksheet2 && worksheet2.isSheetHidden() !== 1 /* TRUE */) {
        this.setActiveSheet(worksheet2);
        return worksheet2;
      }
    }
    const worksheet = this._worksheets.get(sheetOrder[0]);
    this.setActiveSheet(worksheet);
    return worksheet;
  }
  /**
   * ActiveSheet should not be null!
   * There is at least one sheet in a workbook. You can not delete all sheets in a workbook.
   * @param worksheet
   */
  setActiveSheet(worksheet) {
    this._activeSheet$.next(worksheet);
  }
  removeSheet(sheetId) {
    const sheetToRemove = this._worksheets.get(sheetId);
    if (!sheetToRemove) {
      return false;
    }
    this._worksheets.delete(sheetId);
    this._snapshot.sheetOrder.splice(this._snapshot.sheetOrder.indexOf(sheetId), 1);
    delete this._snapshot.sheets[sheetId];
    this._sheetDisposed$.next(sheetToRemove);
    return true;
  }
  getActiveSheetIndex() {
    const { sheetOrder } = this._snapshot;
    return sheetOrder.findIndex((sheetId) => {
      const worksheet = this._worksheets.get(sheetId);
      return worksheet === this._activeSheet;
    });
  }
  getSheetSize() {
    return this._snapshot.sheetOrder.length;
  }
  getSheets() {
    const { sheetOrder } = this._snapshot;
    return sheetOrder.map((sheetId) => this._worksheets.get(sheetId));
  }
  getSheetsName() {
    const { sheetOrder } = this._snapshot;
    const names = [];
    sheetOrder.forEach((sheetId) => {
      const worksheet = this._worksheets.get(sheetId);
      if (worksheet) {
        names.push(worksheet.getName());
      }
    });
    return names;
  }
  getSheetIndex(sheet) {
    const { sheetOrder } = this._snapshot;
    return sheetOrder.findIndex((sheetId) => {
      if (sheet.getSheetId() === sheetId) {
        return true;
      }
      return false;
    });
  }
  getSheetBySheetName(name) {
    const { sheetOrder } = this._snapshot;
    const sheetId = sheetOrder.find((sheetId2) => {
      const worksheet = this._worksheets.get(sheetId2);
      return worksheet.getName() === name;
    });
    return this._worksheets.get(sheetId);
  }
  getSheetBySheetId(sheetId) {
    return this._worksheets.get(sheetId);
  }
  getSheetByIndex(index) {
    const { sheetOrder } = this._snapshot;
    return this._worksheets.get(sheetOrder[index]);
  }
  getHiddenWorksheets() {
    return this.getSheets().filter((s) => s.getConfig().hidden === 1 /* TRUE */).map((s) => s.getConfig().id);
  }
  getUnhiddenWorksheets() {
    return this.getSheets().filter((s) => s.getConfig().hidden !== 1 /* TRUE */).map((s) => s.getConfig().id);
  }
  load(config2) {
    this._snapshot = config2;
  }
  /**
   * Check if sheet name is unique
   * @param name sheet name
   * @returns True if sheet name is unique
   */
  checkSheetName(name) {
    const sheetsName = this.getSheetsName();
    return sheetsName.includes(name);
  }
  /**
   *  Check whether the sheet name is unique and generate a new unique sheet name
   * @param name sheet name
   * @returns Unique sheet name
   */
  uniqueSheetName(name = "Sheet1") {
    let output = name;
    while (this.checkSheetName(output)) {
      output = name + this._count;
      this._count++;
    }
    return output;
  }
  /**
   * Automatically generate new sheet name
   * @param name sheet name
   * @returns New sheet name
   */
  generateNewSheetName(name) {
    let output = name + this._count;
    while (this.checkSheetName(output)) {
      output = name + this._count;
      this._count++;
    }
    return output;
  }
  // FIXME: now we always create worksheet from DEFAULT_WORKSHEET?
  /**
   * Get Default Sheet
   */
  _parseWorksheetSnapshots() {
    const { _snapshot, _worksheets } = this;
    const { sheets, sheetOrder } = _snapshot;
    if (Tools.isEmptyObject(sheets)) {
      const firstSheetId = Tools.generateRandomId();
      sheets[firstSheetId] = { id: firstSheetId };
    }
    for (const sheetId in sheets) {
      const worksheetSnapshot = sheets[sheetId];
      const { name } = worksheetSnapshot;
      worksheetSnapshot.name = this.uniqueSheetName(name);
      if (worksheetSnapshot.name !== name) {
        this._logService.debug("[Workbook]", `The worksheet name ${name} is duplicated, we changed it to ${worksheetSnapshot.name}. Please fix the problem in your snapshot.`);
      }
      const worksheet = new Worksheet(this._unitId, worksheetSnapshot, this._styles);
      _worksheets.set(sheetId, worksheet);
      if (!sheetOrder.includes(sheetId)) {
        sheetOrder.push(sheetId);
      }
    }
    this.ensureActiveSheet();
  }
  /**
   * Get custom metadata of workbook
   * @returns {CustomData | undefined} custom metadata
   */
  getCustomMetadata() {
    return this._snapshot.custom;
  }
  /**
   * Set custom metadata of workbook
   * @param {CustomData | undefined} custom custom metadata
   */
  setCustomMetadata(custom) {
    this._snapshot.custom = custom;
  }
};
Workbook = __decorateClass([
  __decorateParam(1, ILogService)
], Workbook);

// ../packages/core/src/slides/slide-model.ts
var import_rxjs10 = __toESM(require_cjs());
var SlideDataModel = class extends UnitModel {
  constructor(snapshot) {
    var _a2;
    super();
    __publicField(this, "type", O.UNIVER_SLIDE);
    __publicField(this, "_activePage$", new import_rxjs10.BehaviorSubject(null));
    __publicField(this, "activePage$", this._activePage$.asObservable());
    __publicField(this, "_name$");
    __publicField(this, "name$");
    __publicField(this, "_snapshot");
    __publicField(this, "_unitId");
    this._snapshot = { ...DEFAULT_SLIDE, ...snapshot };
    this._unitId = (_a2 = this._snapshot.id) != null ? _a2 : Tools.generateRandomId(6);
    this._name$ = new import_rxjs10.BehaviorSubject(this._snapshot.title);
    this.name$ = this._name$.asObservable();
  }
  get _activePage() {
    var _a2, _b2;
    const activePage = this._activePage$.getValue();
    if (!activePage) {
      const activePageId = (_a2 = this.getPageOrder()) == null ? void 0 : _a2[0];
      if (!activePageId) {
        return null;
      }
      return (_b2 = this.getPages()) == null ? void 0 : _b2[activePageId];
    }
    return activePage;
  }
  setName(name) {
    var _a2;
    this._snapshot.title = name;
    this._name$.next(name);
    this._unitId = (_a2 = this._snapshot.id) != null ? _a2 : generateRandomId(6);
  }
  getRev() {
    return 0;
  }
  incrementRev() {
  }
  setRev(_rev) {
  }
  getSnapshot() {
    return this._snapshot;
  }
  getUnitId() {
    return this._unitId;
  }
  getPages() {
    var _a2;
    return (_a2 = this._snapshot.body) == null ? void 0 : _a2.pages;
  }
  getPageOrder() {
    var _a2;
    return (_a2 = this._snapshot.body) == null ? void 0 : _a2.pageOrder;
  }
  getPage(pageId) {
    const pages = this.getPages();
    return pages == null ? void 0 : pages[pageId];
  }
  getElementsByPage(pageId) {
    var _a2;
    return (_a2 = this.getPage(pageId)) == null ? void 0 : _a2.pageElements;
  }
  getElement(pageId, elementId) {
    var _a2;
    return (_a2 = this.getElementsByPage(pageId)) == null ? void 0 : _a2[elementId];
  }
  getPageSize() {
    return this._snapshot.pageSize;
  }
  getBlankPage() {
    const id = generateRandomId(6);
    const page = {
      id,
      pageType: 0 /* SLIDE */,
      zIndex: 10,
      title: id,
      description: "",
      pageBackgroundFill: {
        rgb: "rgb(255,255,255)"
      },
      pageElements: {}
    };
    return page;
  }
  setActivePage(page) {
    this._activePage$.next(page);
  }
  getActivePage() {
    return this._activePage;
  }
  updatePage(pageId, page) {
    if (!this._snapshot.body) return;
    this._snapshot.body.pages[pageId] = page;
  }
  appendPage(page) {
    var _a2;
    if (!this._snapshot.body) return;
    this._snapshot.body.pages[page.id] = page;
    const activePage = this._activePage;
    const index = this._snapshot.body.pageOrder.indexOf((_a2 = activePage == null ? void 0 : activePage.id) != null ? _a2 : "");
    this._snapshot.body.pageOrder.splice(index + 1, 0, page.id);
  }
};

// ../packages/core/src/services/instance/instance.service.ts
var IUniverInstanceService = createIdentifier("univer.current");
var UniverInstanceService = class extends Disposable {
  constructor(_injector, _contextService) {
    super();
    this._injector = _injector;
    this._contextService = _contextService;
    __publicField(this, "_unitsByType", /* @__PURE__ */ new Map());
    __publicField(this, "_createHandler");
    __publicField(this, "_ctorByType", /* @__PURE__ */ new Map());
    __publicField(this, "_currentUnits", /* @__PURE__ */ new Map());
    __publicField(this, "_currentUnits$", new import_rxjs11.BehaviorSubject(this._currentUnits));
    __publicField(this, "currentUnits$", this._currentUnits$.asObservable());
    __publicField(this, "_unitAdded$", new import_rxjs11.Subject());
    __publicField(this, "unitAdded$", this._unitAdded$.asObservable());
    __publicField(this, "_unitDisposed$", new import_rxjs11.Subject());
    __publicField(this, "unitDisposed$", this._unitDisposed$.asObservable());
    __publicField(this, "_focused$", new import_rxjs11.BehaviorSubject(null));
    __publicField(this, "focused$", this._focused$.asObservable());
  }
  dispose() {
    super.dispose();
    this._focused$.complete();
  }
  __setCreateHandler(handler) {
    this._createHandler = handler;
  }
  createUnit(type2, data, options) {
    const model = this._createHandler(type2, data, this._ctorByType.get(type2), options);
    return model;
  }
  registerCtorForType(type2, ctor) {
    this._ctorByType.set(type2, ctor);
    return {
      dispose: () => {
        this._ctorByType.delete(type2);
      }
    };
  }
  getCurrentTypeOfUnit$(type2) {
    return this.currentUnits$.pipe((0, import_rxjs11.map)((units) => {
      var _a2;
      return (_a2 = units.get(type2)) != null ? _a2 : null;
    }), (0, import_rxjs11.distinctUntilChanged)());
  }
  getCurrentUnitForType(type2) {
    return this._currentUnits.get(type2);
  }
  getCurrentUnitOfType(type2) {
    return this.getCurrentUnitForType(type2);
  }
  setCurrentUnitForType(unitId) {
    const result = this._getUnitById(unitId);
    if (!result) throw new Error(`[UniverInstanceService]: no document with unitId ${unitId}!`);
    this._currentUnits.set(result[1], result[0]);
    this._currentUnits$.next(this._currentUnits);
  }
  getTypeOfUnitAdded$(type2) {
    return this._unitAdded$.pipe((0, import_rxjs11.filter)((unit) => unit.type === type2));
  }
  /**
   * Add a unit into Univer.
   *
   * @ignore
   *
   * @param unit The unit to be added.
   */
  __addUnit(unit, options) {
    var _a2;
    const type2 = unit.type;
    if (!this._unitsByType.has(type2)) {
      this._unitsByType.set(type2, []);
    }
    const units = this._unitsByType.get(type2);
    const newUnitId = unit.getUnitId();
    if (units.findIndex((u) => u.getUnitId() === newUnitId) !== -1) {
      throw new Error(`[UniverInstanceService]: cannot create a unit with the same unit id: ${newUnitId}.`);
    }
    units.push(unit);
    this._unitAdded$.next(unit);
    if ((_a2 = options == null ? void 0 : options.makeCurrent) != null ? _a2 : true) {
      this.setCurrentUnitForType(unit.getUnitId());
    }
  }
  getTypeOfUnitDisposed$(type2) {
    return this.unitDisposed$.pipe((0, import_rxjs11.filter)((unit) => unit.type === type2));
  }
  getUnit(id, type2) {
    var _a2;
    const unit = (_a2 = this._getUnitById(id)) == null ? void 0 : _a2[0];
    if (type2 && (unit == null ? void 0 : unit.type) !== type2) return null;
    return unit;
  }
  getCurrentUniverDocInstance() {
    return this.getCurrentUnitForType(O.UNIVER_DOC);
  }
  getUniverDocInstance(unitId) {
    return this.getUnit(unitId, O.UNIVER_DOC);
  }
  getUniverSheetInstance(unitId) {
    return this.getUnit(unitId, O.UNIVER_SHEET);
  }
  getAllUnitsForType(type2) {
    var _a2;
    return (_a2 = this._unitsByType.get(type2)) != null ? _a2 : [];
  }
  changeDoc(unitId, doc) {
    const allDocs = this.getAllUnitsForType(O.UNIVER_DOC);
    const oldDoc = allDocs.find((doc2) => doc2.getUnitId() === unitId);
    if (oldDoc != null) {
      const index = allDocs.indexOf(oldDoc);
      allDocs.splice(index, 1);
    }
    this.__addUnit(doc);
  }
  get focused() {
    var _a2;
    const id = this._focused$.getValue();
    if (!id) return null;
    return (_a2 = this._getUnitById(id)) == null ? void 0 : _a2[0];
  }
  focusUnit(id) {
    this._focused$.next(id);
    if (this.focused instanceof Workbook) {
      this._contextService.setContextValue(FOCUSING_UNIT, true);
      this._contextService.setContextValue(FOCUSING_DOC, false);
      this._contextService.setContextValue(FOCUSING_SHEET, true);
      this._contextService.setContextValue(FOCUSING_SLIDE, false);
      this.setCurrentUnitForType(id);
    } else if (this.focused instanceof DocumentDataModel) {
      this._contextService.setContextValue(FOCUSING_UNIT, true);
      this._contextService.setContextValue(FOCUSING_DOC, true);
      this._contextService.setContextValue(FOCUSING_SHEET, false);
      this._contextService.setContextValue(FOCUSING_SLIDE, false);
      this.setCurrentUnitForType(id);
    } else if (this.focused instanceof SlideDataModel) {
      this._contextService.setContextValue(FOCUSING_UNIT, true);
      this._contextService.setContextValue(FOCUSING_DOC, false);
      this._contextService.setContextValue(FOCUSING_SHEET, false);
      this._contextService.setContextValue(FOCUSING_SLIDE, true);
      this.setCurrentUnitForType(id);
    } else {
      this._contextService.setContextValue(FOCUSING_UNIT, false);
      this._contextService.setContextValue(FOCUSING_DOC, false);
      this._contextService.setContextValue(FOCUSING_SHEET, false);
      this._contextService.setContextValue(FOCUSING_SLIDE, false);
    }
  }
  getFocusedUnit() {
    return this.focused;
  }
  getUnitType(unitId) {
    const result = this._getUnitById(unitId);
    if (!result) return O.UNRECOGNIZED;
    return result[1];
  }
  disposeUnit(unitId) {
    const result = this._getUnitById(unitId);
    if (!result) return false;
    const [unit, type2] = result;
    const units = this._unitsByType.get(type2);
    const index = units.indexOf(unit);
    units.splice(index, 1);
    this._tryResetCurrentOnRemoval(unitId, type2);
    this._tryResetFocusOnRemoval(unitId);
    this._unitDisposed$.next(unit);
    return true;
  }
  _tryResetCurrentOnRemoval(unitId, type2) {
    const current = this.getCurrentUnitForType(type2);
    if ((current == null ? void 0 : current.getUnitId()) === unitId) {
      this._currentUnits.set(type2, null);
      this._currentUnits$.next(this._currentUnits);
    }
  }
  _tryResetFocusOnRemoval(unitId) {
    var _a2;
    if (((_a2 = this.focused) == null ? void 0 : _a2.getUnitId()) === unitId) {
      this._focused$.next(null);
    }
  }
  _getUnitById(unitId) {
    for (const [type2, units] of this._unitsByType) {
      const unit = units.find((unit2) => unit2.getUnitId() === unitId);
      if (unit) {
        return [unit, type2];
      }
    }
  }
};
UniverInstanceService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IContextService)
], UniverInstanceService);

// ../packages/core/src/services/lifecycle/lifecycle.ts
var LifecycleNameMap = {
  [0 /* Starting */]: "Starting",
  [1 /* Ready */]: "Ready",
  [2 /* Rendered */]: "Rendered",
  [3 /* Steady */]: "Steady"
};

// ../packages/core/src/services/lifecycle/lifecycle.service.ts
var import_rxjs12 = __toESM(require_cjs());
var LifecycleService = class extends Disposable {
  constructor(_logService) {
    super();
    this._logService = _logService;
    __publicField(this, "_lifecycle$", new import_rxjs12.BehaviorSubject(0 /* Starting */));
    __publicField(this, "lifecycle$", this._lifecycle$.asObservable());
    __publicField(this, "_lock", false);
    this._reportProgress(0 /* Starting */);
  }
  get stage() {
    return this._lifecycle$.getValue();
  }
  set stage(stage) {
    if (this._lock) throw new Error("[LifecycleService]: cannot set new stage when related logic is all handled!");
    if (stage < this.stage) throw new Error("[LifecycleService]: lifecycle stage cannot go backward!");
    if (stage === this.stage) return;
    this._lock = true;
    this._reportProgress(stage);
    this._lifecycle$.next(stage);
    this._lock = false;
  }
  dispose() {
    this._lifecycle$.complete();
    super.dispose();
  }
  onStage(stage) {
    return (0, import_rxjs12.firstValueFrom)(this.lifecycle$.pipe(
      (0, import_rxjs12.filter)((s) => s >= stage),
      takeAfter((s) => s === stage),
      (0, import_rxjs12.map)(() => void 0)
    ));
  }
  /**
   * Subscribe to lifecycle changes and all previous stages and the current
   * stage will be emitted immediately.
   * @returns
   */
  subscribeWithPrevious() {
    return (0, import_rxjs12.merge)(getLifecycleStagesAndBefore(this.stage), this._lifecycle$.pipe((0, import_rxjs12.skip)(1))).pipe(takeAfter((s) => s === 3 /* Steady */));
  }
  _reportProgress(stage) {
    this._logService.debug("[LifecycleService]", `lifecycle progressed to "${LifecycleNameMap[stage]}".`);
  }
};
LifecycleService = __decorateClass([
  __decorateParam(0, ILogService)
], LifecycleService);
function getLifecycleStagesAndBefore(lifecycleStage) {
  switch (lifecycleStage) {
    case 0 /* Starting */:
      return (0, import_rxjs12.of)(0 /* Starting */);
    case 1 /* Ready */:
      return (0, import_rxjs12.of)(0 /* Starting */, 1 /* Ready */);
    case 2 /* Rendered */:
      return (0, import_rxjs12.of)(0 /* Starting */, 1 /* Ready */, 2 /* Rendered */);
    default:
      return (0, import_rxjs12.of)(
        0 /* Starting */,
        1 /* Ready */,
        2 /* Rendered */,
        3 /* Steady */
      );
  }
}

// ../packages/core/src/services/local-storage/local-storage.service.ts
var ILocalStorageService = createIdentifier("ILocalStorageService");

// ../packages/core/src/services/locale/locale.service.ts
var import_rxjs14 = __toESM(require_cjs());
var LocaleService = class extends Disposable {
  constructor() {
    super();
    __publicField(this, "_currentLocale$", new import_rxjs14.BehaviorSubject("zhCN" /* ZH_CN */));
    __publicField(this, "currentLocale$", this._currentLocale$.asObservable());
    __publicField(this, "_locales", null);
    __publicField(this, "localeChanged$", new import_rxjs14.Subject());
    /**
     * Translate a key to the current locale
     *
     * @param {string} key the key to translate
     * @param {string[]} args optional arguments to replace in the translated string
     * @returns {string} the translated string
     *
     * @example
     * const locales = {
     *   [LocaleType.EN_US]: {
     *     foo: {
     *       bar: 'Hello'
     *    }
     * }
     * t('foo.bar') => 'Hello'
     *
     * @example
     * const locales = {
     *   [LocaleType.EN_US]: {
     *     foo: {
     *       bar: 'Hello {0}'
     *    }
     * }
     * t('foo.bar', 'World') => 'Hello World'
     */
    __publicField(this, "t", (key, ...args) => {
      if (!this._locales) throw new Error("[LocaleService]: Locale not initialized");
      const keys = key.split(".");
      const resolvedValue = this.resolveKeyPath(this._locales[this._currentLocale], keys);
      if (typeof resolvedValue === "string") {
        let result = resolvedValue;
        args.forEach((arg, index) => {
          result = result.replace(`{${index}}`, arg);
        });
        return result;
      } else {
        return key;
      }
    });
    this.disposeWithMe(toDisposable(() => this.localeChanged$.complete()));
  }
  get _currentLocale() {
    return this._currentLocale$.value;
  }
  /**
   * Load more locales after init.
   *
   * @param locales - Locale object
   */
  load(locales) {
    var _a2;
    this._locales = merge_default((_a2 = this._locales) != null ? _a2 : {}, locales);
  }
  setLocale(locale) {
    this._currentLocale$.next(locale);
    this.localeChanged$.next();
  }
  getLocales() {
    var _a2;
    return (_a2 = this._locales) == null ? void 0 : _a2[this._currentLocale];
  }
  getCurrentLocale() {
    return this._currentLocale;
  }
  resolveKeyPath(obj, keys) {
    const currentKey = keys.shift();
    if (currentKey && obj && currentKey in obj) {
      const nextObj = obj[currentKey];
      if (keys.length > 0 && (typeof nextObj === "object" || Array.isArray(nextObj))) {
        return this.resolveKeyPath(nextObj, keys);
      } else {
        return nextObj;
      }
    }
    return null;
  }
};

// ../packages/core/src/services/permission/permission.service.ts
var import_rxjs15 = __toESM(require_cjs());
var import_operators = __toESM(require_operators());

// ../packages/core/src/services/permission/type.ts
var IPermissionService = createIdentifier("univer.permission-service");

// ../packages/core/src/services/permission/permission.service.ts
var PermissionService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_permissionPointMap", /* @__PURE__ */ new Map());
    __publicField(this, "_permissionPointUpdate$", new import_rxjs15.Subject());
    __publicField(this, "permissionPointUpdate$", this._permissionPointUpdate$.asObservable());
    __publicField(this, "_showComponents", true);
  }
  setShowComponents(showComponents) {
    this._showComponents = showComponents;
  }
  getShowComponents() {
    return this._showComponents;
  }
  deletePermissionPoint(permissionId) {
    const permissionPoint = this._permissionPointMap.get(permissionId);
    if (permissionPoint) {
      permissionPoint.complete();
      this._permissionPointMap.delete(permissionId);
    }
  }
  addPermissionPoint(_item) {
    const isSubject = _item instanceof import_rxjs15.BehaviorSubject;
    const item = isSubject ? _item.getValue() : _item;
    if (!item.id) {
      return false;
    }
    const permissionPoint = this._permissionPointMap.get(item.id);
    if (permissionPoint) {
      throw new Error(`${item.id} PermissionPoint already exists`);
    }
    this._permissionPointMap.set(item.id, isSubject ? _item : new import_rxjs15.BehaviorSubject(item));
    this._permissionPointUpdate$.next(item);
    return true;
  }
  updatePermissionPoint(permissionId, value) {
    const permissionPoint = this._permissionPointMap.get(permissionId);
    if (!permissionPoint) {
      return;
    }
    const subject = permissionPoint.getValue();
    subject.value = value;
    subject.status = "done" /* DONE */;
    permissionPoint.next(subject);
    this._permissionPointUpdate$.next(subject);
  }
  clearPermissionMap() {
    this._permissionPointMap.clear();
  }
  getPermissionPoint(permissionId) {
    const permissionPoint = this._permissionPointMap.get(permissionId);
    if (!permissionPoint) return;
    return permissionPoint.getValue();
  }
  getPermissionPoint$(permissionId) {
    const permissionPoint = this._permissionPointMap.get(permissionId);
    if (!permissionPoint) return;
    return permissionPoint;
  }
  composePermission$(permissionIdList) {
    const subjectList = permissionIdList.map((id) => {
      var _a2;
      const subject = (_a2 = this._permissionPointMap) == null ? void 0 : _a2.get(id);
      if (!subject) {
        throw new Error(`[PermissionService]: ${id} permissionPoint does not exist!`);
      }
      return subject.asObservable();
    });
    return (0, import_rxjs15.combineLatest)(subjectList).pipe(
      // Check that all permissions exist
      (0, import_operators.map)((list) => {
        return list;
      })
    );
  }
  composePermission(permissionIdList) {
    const valueList = permissionIdList.map((id) => {
      var _a2;
      const subject = (_a2 = this._permissionPointMap) == null ? void 0 : _a2.get(id);
      if (!subject) {
        throw new Error(`[PermissionService]: ${id} permissionPoint does not exist!`);
      }
      return subject.getValue();
    });
    return valueList;
  }
  getAllPermissionPoint() {
    const cacheMap = /* @__PURE__ */ new Map();
    this._permissionPointMap.forEach((v, key) => {
      cacheMap.set(key, v);
    });
    return cacheMap;
  }
};

// ../packages/core/src/services/plugin/plugin.service.ts
var import_rxjs16 = __toESM(require_cjs());
var INIT_LAZY_PLUGINS_TIMEOUT = 4;
var DependentOnSymbol = Symbol("DependentOn");
var Plugin = class extends Disposable {
  onStarting() {
  }
  onReady() {
  }
  onRendered() {
  }
  onSteady() {
  }
  getUnitType() {
    return this.constructor.type;
  }
  getPluginName() {
    return this.constructor.pluginName;
  }
};
__publicField(Plugin, "pluginName");
__publicField(Plugin, "type", O.UNIVER_UNKNOWN);
var PluginStore = class {
  constructor() {
    __publicField(this, "_plugins", []);
  }
  addPlugin(plugin) {
    this._plugins.push(plugin);
  }
  removePlugins() {
    const plugins = this._plugins.slice();
    this._plugins.length = 0;
    return plugins;
  }
  forEachPlugin(callback) {
    this._plugins.forEach(callback);
  }
};
function DependentOn(...plugins) {
  return function(target) {
    target[DependentOnSymbol] = plugins;
  };
}
var PluginService = class {
  constructor(_injector, _lifecycleService, _logService) {
    this._injector = _injector;
    this._lifecycleService = _lifecycleService;
    this._logService = _logService;
    __publicField(this, "_pluginRegistry", /* @__PURE__ */ new Map());
    __publicField(this, "_pluginStore", new PluginStore());
    __publicField(this, "_seenPlugins", /* @__PURE__ */ new Set());
    __publicField(this, "_loadedPlugins", /* @__PURE__ */ new Set());
    __publicField(this, "_loadedPluginTypes", /* @__PURE__ */ new Set([O.UNIVER_UNKNOWN]));
    __publicField(this, "_flushTimerByType", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._pluginStore.removePlugins().forEach((p) => p.dispose());
    this._flushTimerByType.forEach((timer) => clearTimeout(timer));
  }
  /**
   * Register a plugin into univer.
   * @param {PluginCtor} ctor The plugin's constructor.
   * @param {ConstructorParameters} [config] The configuration for the plugin.
   */
  registerPlugin(ctor, config2) {
    this._assertPluginValid(ctor);
    const item = { plugin: ctor, options: config2 };
    this._pluginRegistry.set(ctor.pluginName, item);
    this._logService.debug("[PluginService]", `Plugin "${ctor.pluginName}" registered.`);
    const { type: type2 } = ctor;
    if (this._loadedPluginTypes.has(type2)) {
      if (type2 === O.UNIVER_UNKNOWN) {
        this._loadFromPlugins([item]);
      } else {
        this._flushType(type2);
      }
    }
  }
  startPluginsForType(type2) {
    if (this._loadedPluginTypes.has(type2)) {
      return;
    }
    this._loadPluginsForType(type2);
  }
  _loadPluginsForType(type2) {
    const keys = Array.from(this._pluginRegistry.keys());
    const allPluginsOfThisType = [];
    keys.forEach((key) => {
      const item = this._pluginRegistry.get(key);
      if (item.plugin.type === type2) {
        allPluginsOfThisType.push(item);
      }
    });
    this._loadFromPlugins(allPluginsOfThisType);
    this._loadedPluginTypes.add(type2);
  }
  _assertPluginValid(ctor) {
    const { type: type2, pluginName } = ctor;
    if (type2 === O.UNRECOGNIZED) {
      throw new Error(`[PluginService]: invalid plugin type for ${ctor.name}. Please assign a "type" to your plugin.`);
    }
    if (!pluginName) {
      throw new Error(`[PluginService]: no plugin name for ${ctor.name}. Please assign a "pluginName" to your plugin.`);
    }
    if (this._seenPlugins.has(pluginName)) {
      throw new Error(`[PluginService]: duplicated plugin name for "${pluginName}". Maybe a plugin that dependents on "${pluginName} has already registered it. In that case please register "${pluginName}" before the that plugin.`);
    }
    this._seenPlugins.add(ctor.pluginName);
  }
  _flushType(type2) {
    if (this._flushTimerByType.get(type2) === void 0) {
      this._flushTimerByType.set(type2, setTimeout(() => {
        this._loadPluginsForType(type2);
        this._flushTimerByType.delete(type2);
      }, INIT_LAZY_PLUGINS_TIMEOUT));
    }
  }
  _loadFromPlugins(plugins) {
    const finalPlugins = [];
    const visited = /* @__PURE__ */ new Set();
    const dfs = (item) => {
      const { plugin } = item;
      const { pluginName } = plugin;
      if (this._loadedPlugins.has(pluginName) || visited.has(pluginName)) {
        return;
      }
      visited.add(pluginName);
      this._pluginRegistry.delete(pluginName);
      const dependents = plugin[DependentOnSymbol];
      if (dependents) {
        dependents.forEach((d) => {
          const dItem = this._pluginRegistry.get(d.pluginName);
          if (dItem) {
            dfs(dItem);
          } else if (!this._seenPlugins.has(d.pluginName) && !visited.has(d.pluginName)) {
            if (plugin.type === O.UNIVER_UNKNOWN && d.type !== O.UNIVER_UNKNOWN) {
              throw new Error(
                `[PluginService]: cannot register a plugin with Univer type that depends on a plugin with other type. The dependent is ${plugin.pluginName} and the dependency is ${d.pluginName}.`
              );
            }
            if (plugin.type !== d.type && d.type !== O.UNIVER_UNKNOWN) {
              this._logService.debug(
                "[PluginService]",
                `Plugin "${pluginName}" depends on "${d.pluginName}" which has different type.`
              );
            }
            this._logService.debug(
              "[PluginService]",
              `Plugin "${pluginName}" depends on "${d.pluginName}" which is not registered. Univer will automatically register it with default configuration.`
            );
            this._assertPluginValid(d);
            dfs({ plugin: d, options: void 0 });
          }
        });
      }
      finalPlugins.push(item);
    };
    plugins.forEach((p) => dfs(p));
    const pluginInstances = finalPlugins.map((p) => this._initPlugin(p.plugin, p.options));
    this._pluginsRunLifecycle(pluginInstances);
  }
  _pluginsRunLifecycle(plugins) {
    const currentStage = this._lifecycleService.stage;
    getLifecycleStagesAndBefore(currentStage).subscribe((stage) => this._runStage(plugins, stage));
    if (currentStage !== 3 /* Steady */) {
      const subscription = this._lifecycleService.lifecycle$.pipe(
        (0, import_rxjs16.skip)(1)
      ).subscribe((stage) => {
        this._runStage(plugins, stage);
        if (stage === 3 /* Steady */) {
          subscription.unsubscribe();
        }
      });
    }
  }
  _runStage(plugins, stage) {
    plugins.forEach((p) => {
      switch (stage) {
        case 0 /* Starting */:
          p.onStarting();
          break;
        case 1 /* Ready */:
          p.onReady();
          break;
        case 2 /* Rendered */:
          p.onRendered();
          break;
        case 3 /* Steady */:
          p.onSteady();
          break;
      }
    });
  }
  _initPlugin(plugin, options) {
    const pluginInstance = this._injector.createInstance(plugin, options);
    this._pluginStore.addPlugin(pluginInstance);
    this._loadedPlugins.add(plugin.pluginName);
    this._logService.debug("[PluginService]", `Plugin "${pluginInstance.getPluginName()}" loaded.`);
    return pluginInstance;
  }
};
PluginService = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, Inject(LifecycleService)),
  __decorateParam(2, ILogService)
], PluginService);

// ../packages/core/src/services/plugin/plugin-override.ts
function mergeOverrideWithDependencies(dependencies, override) {
  if (!override) return dependencies;
  const result = [];
  for (const dependency of dependencies) {
    const overrideItem = override.find(([identifier]) => identifier === dependency[0]);
    if (overrideItem) {
      if (overrideItem[1] === null) continue;
      result.push([dependency[0], overrideItem[1]]);
    } else {
      result.push(dependency);
    }
  }
  return result;
}

// ../packages/core/src/services/resource-loader/type.ts
var IResourceLoaderService = createIdentifier("resource-loader-service");

// ../packages/core/src/services/resource-manager/resource-manager.service.ts
var import_rxjs17 = __toESM(require_cjs());
var ResourceManagerService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_resourceMap", /* @__PURE__ */ new Map());
    __publicField(this, "_register$", new import_rxjs17.Subject());
    __publicField(this, "register$", this._register$.asObservable());
  }
  getAllResourceHooks() {
    const list = [...this._resourceMap.values()];
    return list;
  }
  getResources(unitId, type2) {
    if (type2) {
      return this.getResourcesByType(unitId, type2);
    }
    const resourceHooks = this.getAllResourceHooks();
    const resources = resourceHooks.map((resourceHook) => {
      const data = resourceHook.toJson(unitId);
      return {
        name: resourceHook.pluginName,
        data
      };
    });
    return resources;
  }
  getResourcesByType(unitId, type2) {
    const resourceHooks = this.getAllResourceHooks().filter((hook) => hook.businesses.includes(type2));
    const resources = resourceHooks.map((resourceHook) => {
      const data = resourceHook.toJson(unitId);
      return {
        name: resourceHook.pluginName,
        data
      };
    });
    return resources;
  }
  registerPluginResource(hook) {
    const resourceName = hook.pluginName;
    if (this._resourceMap.has(resourceName)) {
      throw new Error(`the pluginName is registered {${resourceName}}`);
    }
    this._resourceMap.set(resourceName, hook);
    this._register$.next(hook);
    return toDisposable(() => this._resourceMap.delete(resourceName));
  }
  disposePluginResource(pluginName) {
    this._resourceMap.delete(pluginName);
  }
  loadResources(unitId, resources) {
    this.getAllResourceHooks().forEach((hook) => {
      var _a2;
      const data = (_a2 = resources == null ? void 0 : resources.find((resource) => resource.name === hook.pluginName)) == null ? void 0 : _a2.data;
      if (data) {
        try {
          const model = hook.parseJson(data);
          hook.onLoad(unitId, model);
        } catch (err) {
          console.error("LoadResources Error!");
        }
      }
    });
  }
  unloadResources(unitId) {
    this.getAllResourceHooks().forEach((hook) => {
      hook.onUnLoad(unitId);
    });
  }
  dispose() {
    this._register$.complete();
    this._resourceMap.clear();
  }
};

// ../packages/core/src/services/theme/theme.service.ts
var import_rxjs18 = __toESM(require_cjs());
var ThemeService = class extends Disposable {
  constructor() {
    super();
    __publicField(this, "_currentTheme");
    __publicField(this, "_currentTheme$", new import_rxjs18.BehaviorSubject({}));
    __publicField(this, "currentTheme$", this._currentTheme$.asObservable());
    this.disposeWithMe(toDisposable(() => this._currentTheme$.complete()));
  }
  getCurrentTheme() {
    if (!this._currentTheme) {
      throw new Error("[ThemeService]: current theme is not set!");
    }
    return this._currentTheme;
  }
  setTheme(theme) {
    this._currentTheme = theme;
    this._currentTheme$.next(theme);
  }
};

// ../packages/core/src/services/undoredo/undoredo.service.ts
var import_rxjs19 = __toESM(require_cjs());
var IUndoRedoService = createIdentifier("univer.undo-redo.service");
var STACK_CAPACITY = 20;
var MultiImplementationCommand = class {
  dispose() {
  }
  async dispatchToHandlers() {
    return false;
  }
};
var RedoCommandId = "univer.command.redo";
var UndoCommandId = "univer.command.undo";
var UndoCommand = new class extends MultiImplementationCommand {
  constructor() {
    super(...arguments);
    __publicField(this, "type", 0 /* COMMAND */);
    __publicField(this, "id", UndoCommandId);
  }
  handler(accessor) {
    const undoRedoService = accessor.get(IUndoRedoService);
    const element = undoRedoService.pitchTopUndoElement();
    if (!element) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const result = sequenceExecute(element.undoMutations, commandService);
    if (result) {
      undoRedoService.popUndoToRedo();
      return true;
    }
    return false;
  }
}();
var RedoCommand = new class extends MultiImplementationCommand {
  constructor() {
    super(...arguments);
    __publicField(this, "type", 0 /* COMMAND */);
    __publicField(this, "id", RedoCommandId);
  }
  handler(accessor) {
    const undoRedoService = accessor.get(IUndoRedoService);
    const element = undoRedoService.pitchTopRedoElement();
    if (!element) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const result = sequenceExecute(element.redoMutations, commandService);
    if (result) {
      undoRedoService.popRedoToUndo();
      return true;
    }
    return false;
  }
}();
var LocalUndoRedoService = class extends Disposable {
  constructor(_univerInstanceService, _commandService, _contextService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._commandService = _commandService;
    this._contextService = _contextService;
    __publicField(this, "undoRedoStatus$");
    __publicField(this, "_undoRedoStatus$", new import_rxjs19.BehaviorSubject({ undos: 0, redos: 0 }));
    // Undo and redo stacks are per unit.
    __publicField(this, "_undoStacks", /* @__PURE__ */ new Map());
    __publicField(this, "_redoStacks", /* @__PURE__ */ new Map());
    __publicField(this, "_batchingStatus", /* @__PURE__ */ new Map());
    this.undoRedoStatus$ = this._undoRedoStatus$.asObservable();
    this.disposeWithMe(this._commandService.registerCommand(UndoCommand));
    this.disposeWithMe(this._commandService.registerCommand(RedoCommand));
    this.disposeWithMe(toDisposable(() => this._undoRedoStatus$.complete()));
    this.disposeWithMe(toDisposable(this._univerInstanceService.focused$.subscribe(() => this._updateStatus())));
  }
  pushUndoRedo(item) {
    const { unitID } = item;
    const redoStack = this._getRedoStack(unitID, true);
    const undoStack = this._getUndoStack(unitID, true);
    redoStack.length = 0;
    if (this._batchingStatus.has(item.unitID)) {
      const batchingStatus = this._batchingStatus.get(item.unitID);
      const lastItem = this._pitchUndoElement(item.unitID);
      if (batchingStatus === 0 /* WAITING */ || !lastItem) {
        appendNewItem(item);
        this._batchingStatus.set(item.unitID, 1 /* CREATED */);
      } else {
        this._tryBatchingElements(lastItem, item);
      }
    } else {
      appendNewItem(item);
    }
    function appendNewItem(item2) {
      undoStack.push(item2);
      if (undoStack.length > STACK_CAPACITY) {
        undoStack.splice(0, 1);
      }
    }
    this._updateStatus();
  }
  clearUndoRedo(unitID) {
    const redoStack = this._getRedoStack(unitID);
    if (redoStack) {
      redoStack.length = 0;
    }
    const undoStack = this._getUndoStack(unitID);
    if (undoStack) {
      undoStack.length = 0;
    }
    this._updateStatus();
  }
  pitchTopUndoElement() {
    const unitID = this._getFocusedUnitId();
    return this._pitchUndoElement(unitID);
  }
  pitchTopRedoElement() {
    const unitID = this._getFocusedUnitId();
    return this._pitchRedoElement(unitID);
  }
  _pitchUndoElement(unitId) {
    const stack = this._getUndoStack(unitId);
    return (stack == null ? void 0 : stack.length) ? stack[stack.length - 1] : null;
  }
  _pitchRedoElement(unitId) {
    const stack = this._getRedoStack(unitId);
    return (stack == null ? void 0 : stack.length) ? stack[stack.length - 1] : null;
  }
  popUndoToRedo() {
    const undoStack = this._getUndoStackForFocused();
    const element = undoStack.pop();
    if (element) {
      const redoStack = this._getRedoStackForFocused();
      redoStack.push(element);
      this._updateStatus();
    }
  }
  popRedoToUndo() {
    const redoStack = this._getRedoStackForFocused();
    const element = redoStack.pop();
    if (element) {
      const undoStack = this._getUndoStackForFocused();
      undoStack.push(element);
      this._updateStatus();
    }
  }
  rollback(id, unitID) {
    const unitId = unitID || this._getFocusedUnitId();
    const stack = this._getUndoStack(unitId);
    const item = stack == null ? void 0 : stack[(stack == null ? void 0 : stack.length) - 1];
    if (item && item.id === id) {
      stack.pop();
      sequenceExecute(item.undoMutations, this._commandService);
    }
  }
  __tempBatchingUndoRedo(unitId) {
    if (this._batchingStatus.has(unitId)) {
      throw new Error("[LocalUndoRedoService]: cannot batching undo redo twice at the same time!");
    }
    this._batchingStatus.set(unitId, 0 /* WAITING */);
    return toDisposable(() => this._batchingStatus.delete(unitId));
  }
  _updateStatus() {
    var _a2, _b2;
    const unitID = this._getFocusedUnitId();
    const undos = unitID && ((_a2 = this._undoStacks.get(unitID)) == null ? void 0 : _a2.length) || 0;
    const redos = unitID && ((_b2 = this._redoStacks.get(unitID)) == null ? void 0 : _b2.length) || 0;
    this._undoRedoStatus$.next({
      undos,
      redos
    });
  }
  _getUndoStack(unitId, createAsNeeded = false) {
    let stack = this._undoStacks.get(unitId);
    if (!stack && createAsNeeded) {
      stack = [];
      this._undoStacks.set(unitId, stack);
    }
    return stack || null;
  }
  _getRedoStack(unitId, createAsNeeded = false) {
    let stack = this._redoStacks.get(unitId);
    if (!stack && createAsNeeded) {
      stack = [];
      this._redoStacks.set(unitId, stack);
    }
    return stack || null;
  }
  _getUndoStackForFocused() {
    const unitID = this._getFocusedUnitId();
    if (!unitID) {
      throw new Error("No focused univer instance!");
    }
    return this._getUndoStack(unitID, true);
  }
  _getRedoStackForFocused() {
    const unitID = this._getFocusedUnitId();
    if (!unitID) {
      throw new Error("No focused univer instance!");
    }
    return this._getRedoStack(unitID, true);
  }
  _tryBatchingElements(item, newItem) {
    item.redoMutations.push(...newItem.redoMutations);
    item.undoMutations.push(...newItem.undoMutations);
  }
  _getFocusedUnitId() {
    var _a2, _b2, _c, _d;
    let unitID = "";
    const isFocusSheet = this._contextService.getContextValue(FOCUSING_SHEET);
    const isFocusFormulaEditor = this._contextService.getContextValue(FOCUSING_FX_BAR_EDITOR);
    const isFocusEditor = this._contextService.getContextValue(EDITOR_ACTIVATED);
    if (isFocusSheet) {
      if (isFocusFormulaEditor) {
        unitID = DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY;
      } else if (isFocusEditor) {
        unitID = DOCS_NORMAL_EDITOR_UNIT_ID_KEY;
      } else {
        unitID = (_b2 = (_a2 = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : _a2.getUnitId()) != null ? _b2 : "";
      }
    } else {
      unitID = (_d = (_c = this._univerInstanceService.getFocusedUnit()) == null ? void 0 : _c.getUnitId()) != null ? _d : "";
    }
    return unitID;
  }
};
LocalUndoRedoService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, ICommandService),
  __decorateParam(2, IContextService)
], LocalUndoRedoService);

// ../packages/core/src/services/image-io/image-io.service.ts
var IImageIoService = createIdentifier("core.image-io.service");

// ../packages/core/src/shared/cache/image-cache.ts
var ImageCacheMap = class {
  constructor(_injector, maxSize = 100) {
    this._injector = _injector;
    __publicField(this, "_imageCacheMap");
    this._imageCacheMap = new LRUMap(maxSize);
  }
  _getImageCacheKey(imageSourceType, source) {
    return `${imageSourceType}-${source}`;
  }
  getImage(imageSourceType, source, onLoad, onError) {
    const imageCacheKey = this._getImageCacheKey(imageSourceType, source);
    let imageElement = this._imageCacheMap.get(imageCacheKey);
    if (imageElement) {
      return imageElement;
    } else {
      (async () => {
        imageElement = new Image();
        const imageIoService = this._injector.has(IImageIoService) ? this._injector.get(IImageIoService) : null;
        if (imageSourceType === "UUID" /* UUID */) {
          try {
            imageElement.src = await (imageIoService == null ? void 0 : imageIoService.getImage(source)) || "";
          } catch (error) {
            console.error(error);
          }
        } else {
          imageElement.src = source;
        }
        imageElement.onload = () => {
          onLoad == null ? void 0 : onLoad();
        };
        imageElement.onerror = () => {
          onError == null ? void 0 : onError();
        };
        this._imageCacheMap.set(imageCacheKey, imageElement);
      })();
      return null;
    }
  }
};

// ../packages/core/src/skeleton.ts
var Skeleton = class extends Disposable {
  constructor(_localeService) {
    super();
    this._localeService = _localeService;
    __publicField(this, "_fontLocale");
    __publicField(this, "_dirty", true);
    this._localeInitial();
  }
  get dirty() {
    return this._dirty;
  }
  getFontLocale() {
    return this._fontLocale;
  }
  makeDirty(state) {
    this._dirty = state;
  }
  dispose() {
    super.dispose();
    this._fontLocale = null;
  }
  _localeInitial() {
  }
};
Skeleton = __decorateClass([
  __decorateParam(0, Inject(LocaleService))
], Skeleton);

// ../packages/core/src/sheets/sheet-skeleton.ts
var SheetSkeleton = class extends Skeleton {
  constructor(worksheet, _styles, _localeService, _contextService, _configService, _injector) {
    super(_localeService);
    this.worksheet = worksheet;
    this._styles = _styles;
    this._contextService = _contextService;
    this._configService = _configService;
    this._injector = _injector;
    /**
     * @deprecated avoid use `IWorksheetData` directly, use API provided by `Worksheet`, otherwise
     * `ViewModel` will be not working.
     */
    __publicField(this, "_worksheetData");
    __publicField(this, "_renderRawFormula", false);
    __publicField(this, "_cellData");
    __publicField(this, "_imageCacheMap");
    /**
     * Whether the row style precedes the column style.
     */
    __publicField(this, "_isRowStylePrecedeColumnStyle", false);
    /**
     * Whether auto height for merged cells
     */
    __publicField(this, "_skipAutoHeightForMergedCells", true);
    __publicField(this, "_rowTotalHeight", 0);
    __publicField(this, "_columnTotalWidth", 0);
    __publicField(this, "_rowHeaderWidth", 0);
    __publicField(this, "_columnHeaderHeight", 0);
    __publicField(this, "_rowHeightAccumulation", []);
    __publicField(this, "_columnWidthAccumulation", []);
    __publicField(this, "_marginTop", 0);
    __publicField(this, "_marginLeft", 0);
    /** Scale of Scene */
    __publicField(this, "_scaleX");
    __publicField(this, "_scaleY");
    /** Viewport scrolled value */
    __publicField(this, "_scrollX");
    /** Viewport scrolled value */
    __publicField(this, "_scrollY");
    this._worksheetData = this.worksheet.getConfig();
    this._cellData = this.worksheet.getCellMatrix();
    this._imageCacheMap = new ImageCacheMap(this._injector);
    this.initConfig();
  }
  initConfig() {
    var _a2, _b2;
    this._skipAutoHeightForMergedCells = !((_a2 = this._configService.getConfig(AUTO_HEIGHT_FOR_MERGED_CELLS)) != null ? _a2 : false);
    this._isRowStylePrecedeColumnStyle = (_b2 = this._configService.getConfig(IS_ROW_STYLE_PRECEDE_COLUMN_STYLE)) != null ? _b2 : false;
  }
  resetCache() {
  }
  /**
   * @deprecated should never expose a property that is provided by another module!
   */
  getWorksheetConfig() {
    return this._worksheetData;
  }
  /**
   * Get which Workbook and Worksheet this skeleton is attached to.
   * @returns [unitId, sheetId]
   */
  getLocation() {
    return [this.worksheet.getUnitId(), this.worksheet.getSheetId()];
  }
  set columnHeaderHeight(value) {
    this._columnHeaderHeight = value;
    this._worksheetData.columnHeader.height = value;
  }
  set rowHeaderWidth(value) {
    this._rowHeaderWidth = value;
    this._worksheetData.rowHeader.width = value;
  }
  get rowHeightAccumulation() {
    return this._rowHeightAccumulation;
  }
  get rowTotalHeight() {
    return this._rowTotalHeight;
  }
  get columnWidthAccumulation() {
    return this._columnWidthAccumulation;
  }
  get columnTotalWidth() {
    return this._columnTotalWidth;
  }
  get rowHeaderWidth() {
    return this._rowHeaderWidth;
  }
  get columnHeaderHeight() {
    return this._columnHeaderHeight;
  }
  setMarginLeft(left) {
    this._marginLeft = left;
  }
  setMarginTop(top) {
    this._marginTop = top;
  }
  setScale(value, valueY) {
    this._updateLayout();
    this._scaleX = value;
    this._scaleY = valueY || value;
    this._updateLayout();
  }
  setScroll(scrollX, scrollY) {
    if (Tools.isDefine(scrollX)) {
      this._scrollX = scrollX;
    }
    if (Tools.isDefine(scrollY)) {
      this._scrollY = scrollY;
    }
  }
  get scrollX() {
    return this._scrollX;
  }
  get scrollY() {
    return this._scrollY;
  }
  get scaleX() {
    return this._scaleX;
  }
  get scaleY() {
    return this._scaleY;
  }
  get rowHeaderWidthAndMarginLeft() {
    return this.rowHeaderWidth + this._marginLeft;
  }
  get columnHeaderHeightAndMarginTop() {
    return this.columnHeaderHeight + this._marginTop;
  }
  get imageCacheMap() {
    return this._imageCacheMap;
  }
  _generateRowMatrixCache(rowCount, rowData, defaultRowHeight) {
    let rowTotalHeight = 0;
    const rowHeightAccumulation = [];
    const data = rowData;
    for (let r = 0; r < rowCount; r++) {
      let rowHeight = defaultRowHeight;
      if (this.worksheet.getRowFiltered(r)) {
        rowHeight = 0;
      } else if (data[r] != null) {
        const rowDataItem = data[r];
        if (!rowDataItem) {
          continue;
        }
        const { h = defaultRowHeight, ah, ia } = rowDataItem;
        if ((ia == null || ia === 1 /* TRUE */) && typeof ah === "number") {
          rowHeight = ah;
        } else {
          rowHeight = h;
        }
        if (rowDataItem.hd === 1 /* TRUE */) {
          rowHeight = 0;
        }
      }
      rowTotalHeight += rowHeight;
      rowHeightAccumulation.push(rowTotalHeight);
    }
    return {
      rowTotalHeight,
      rowHeightAccumulation
    };
  }
  /**
   * Calc columnWidthAccumulation by columnData
   * @param colCount
   * @param columnData
   * @param defaultColumnWidth
   */
  _generateColumnMatrixCache(colCount, columnData, defaultColumnWidth) {
    let columnTotalWidth = 0;
    const columnWidthAccumulation = [];
    const data = columnData;
    for (let c = 0; c < colCount; c++) {
      let columnWidth = defaultColumnWidth;
      if (data[c] != null) {
        const columnDataItem = data[c];
        if (!columnDataItem) {
          continue;
        }
        if (columnDataItem.w != null) {
          columnWidth = columnDataItem.w;
        }
        if (columnDataItem.hd === 1 /* TRUE */) {
          columnWidth = 0;
        }
      }
      columnTotalWidth += columnWidth;
      columnWidthAccumulation.push(columnTotalWidth);
    }
    return {
      columnTotalWidth,
      columnWidthAccumulation
    };
  }
  intersectMergeRange(row, column) {
    const mergedData = this.worksheet.getMergedCell(row, column);
    return Boolean(mergedData);
  }
  //eslint-disable-next-line complexity
  _getOverflowBound(row, startColumn, endColumn, contentWidth, horizontalAlign = 1 /* LEFT */) {
    let cumWidth = 0;
    if (startColumn > endColumn) {
      const columnCount = this._columnWidthAccumulation.length - 1;
      for (let i = startColumn; i >= endColumn; i--) {
        const column = i;
        const cell = this.worksheet.getCell(row, column);
        if (!isCellCoverable(cell) && column !== startColumn || this.intersectMergeRange(row, column)) {
          if (column === startColumn) {
            return column;
          }
          return column + 1 > columnCount ? columnCount : column + 1;
        }
        const { startX, endX } = getCellWithCoordByIndexCore(
          row,
          column,
          this.rowHeightAccumulation,
          this.columnWidthAccumulation
        );
        if (horizontalAlign === 2 /* CENTER */ && column === startColumn) {
          cumWidth += (endX - startX) / 2;
        } else {
          cumWidth += endX - startX;
        }
        if (contentWidth < cumWidth) {
          return column;
        }
      }
      return startColumn;
    }
    for (let i = startColumn; i <= endColumn; i++) {
      const column = i;
      const cell = this.worksheet.getCell(row, column);
      if (!isCellCoverable(cell) && column !== startColumn || this.intersectMergeRange(row, column)) {
        if (column === startColumn) {
          return column;
        }
        return column - 1 < 0 ? 0 : column - 1;
      }
      const { startX, endX } = getCellWithCoordByIndexCore(
        row,
        column,
        this.rowHeightAccumulation,
        this.columnWidthAccumulation
      );
      if (horizontalAlign === 2 /* CENTER */ && column === startColumn) {
        cumWidth += (endX - startX) / 2;
      } else {
        cumWidth += endX - startX;
      }
      if (contentWidth < cumWidth) {
        return column;
      }
    }
    return endColumn;
  }
  /**
   * Calculate data for row col & cell position.
   * This method should be called whenever a sheet is dirty.
   * Update position value to this._rowHeaderWidth & this._rowHeightAccumulation & this._columnHeaderHeight & this._columnWidthAccumulation.
   */
  _updateLayout() {
    if (!this.dirty) {
      return;
    }
    const {
      rowData,
      columnData,
      defaultRowHeight,
      defaultColumnWidth,
      rowCount,
      columnCount,
      rowHeader,
      columnHeader
    } = this._worksheetData;
    const { rowTotalHeight, rowHeightAccumulation } = this._generateRowMatrixCache(rowCount, rowData, defaultRowHeight);
    const { columnTotalWidth, columnWidthAccumulation } = this._generateColumnMatrixCache(
      columnCount,
      columnData,
      defaultColumnWidth
    );
    this._rowHeaderWidth = rowHeader.hidden !== 1 /* TRUE */ ? this._dynamicallyUpdateRowHeaderWidth(rowHeader) : 0;
    this._columnHeaderHeight = columnHeader.hidden !== 1 /* TRUE */ ? columnHeader.height : 0;
    this._rowTotalHeight = rowTotalHeight;
    this._rowHeightAccumulation = rowHeightAccumulation;
    this._columnTotalWidth = columnTotalWidth;
    this._columnWidthAccumulation = columnWidthAccumulation;
    this.makeDirty(false);
  }
  /**
   * Refresh cache after markDirty by SheetSkeletonManagerService.reCalculate()
   * @param bounds
   */
  calculate() {
    this.resetCache();
    this._updateLayout();
    return this;
  }
  resetRangeCache(_ranges) {
  }
  _dynamicallyUpdateRowHeaderWidth(rowHeader) {
    const SIZE_BY_EACH_CHARACTER = 8;
    const widthByComputation = `${this.worksheet.getRowCount()}`.length * SIZE_BY_EACH_CHARACTER;
    return Math.max(rowHeader.width, widthByComputation);
  }
  _hasUnMergedCellInRow(rowIndex, startColumn, endColumn) {
    const mergeData = this.worksheet.getMergeData();
    if (!mergeData) {
      return false;
    }
    for (let i = startColumn; i <= endColumn; i++) {
      const { isMerged, isMergedMainCell } = this.worksheet.getCellInfoInMergeData(rowIndex, i);
      if (!isMerged && !isMergedMainCell) {
        return true;
      }
    }
    return false;
  }
  /**
   * expand curr range if it's intersect with merge range.
   * @param range
   * @returns {IRange} expanded range because merge info.
   */
  expandRangeByMerge(range) {
    let { startRow, startColumn, endRow, endColumn } = range;
    const mergeData = this._worksheetData.mergeData;
    if (!mergeData) {
      return {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
    }
    let isSearching = true;
    const searchedMarge = new ObjectMatrix();
    while (isSearching) {
      isSearching = false;
      for (let i = 0; i < mergeData.length; i++) {
        const {
          startRow: mainStartRow,
          startColumn: mainStartColumn,
          endRow: mainEndRow,
          endColumn: mainEndColumn
        } = mergeData[i];
        if (searchedMarge.getValue(mainStartRow, mainStartColumn)) {
          continue;
        }
        const rect1 = {
          startColumn,
          startRow,
          endColumn,
          endRow
        };
        const rect2 = {
          startColumn: mainStartColumn,
          startRow: mainStartRow,
          endColumn: mainEndColumn,
          endRow: mainEndRow
        };
        if (getIntersectRange(rect1, rect2)) {
          startRow = Math.min(startRow, mainStartRow);
          startColumn = Math.min(startColumn, mainStartColumn);
          endRow = Math.max(endRow, mainEndRow);
          endColumn = Math.max(endColumn, mainEndColumn);
          searchedMarge.setValue(mainStartRow, mainStartColumn, true);
          isSearching = true;
        }
      }
    }
    return {
      startRow,
      startColumn,
      endRow,
      endColumn
    };
  }
  getColumnCount() {
    return this._columnWidthAccumulation.length;
  }
  getRowCount() {
    return this._rowHeightAccumulation.length;
  }
  /**
   * New version to get merge data.
   * @param row
   * @param column
   * @returns {ISelectionCell} The cell info with merge data
   */
  _getCellMergeInfo(row, column) {
    return this.worksheet.getCellInfoInMergeData(row, column);
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex instead.
   * @param rowIndex
   * @param columnIndex
   * @param header
   * @returns
   */
  getNoMergeCellPositionByIndex(rowIndex, columnIndex, header = true) {
    return this.getNoMergeCellWithCoordByIndex(rowIndex, columnIndex, header);
  }
  /**
   * Original name: getNoMergeCellPositionByIndex
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellWithCoordByIndex(rowIndex, columnIndex, header = true) {
    const {
      rowHeightAccumulation,
      columnWidthAccumulation,
      rowHeaderWidthAndMarginLeft,
      columnHeaderHeightAndMarginTop
    } = this;
    let { startY, endY, startX, endX } = getCellWithCoordByIndexCore(
      rowIndex,
      columnIndex,
      rowHeightAccumulation,
      columnWidthAccumulation
    );
    if (header) {
      startY += columnHeaderHeightAndMarginTop;
      endY += columnHeaderHeightAndMarginTop;
      startX += rowHeaderWidthAndMarginLeft;
      endX += rowHeaderWidthAndMarginLeft;
    }
    return {
      startY,
      endY,
      startX,
      endX
    };
  }
  /**
   * @deprecated use getNoMergeCellWithCoordByIndex(row, col, false)
   * @param rowIndex
   * @param columnIndex
   */
  getNoMergeCellPositionByIndexWithNoHeader(rowIndex, columnIndex) {
    const { rowHeightAccumulation, columnWidthAccumulation } = this;
    const { startY, endY, startX, endX } = getCellWithCoordByIndexCore(
      rowIndex,
      columnIndex,
      rowHeightAccumulation,
      columnWidthAccumulation
    );
    return {
      startY,
      endY,
      startX,
      endX
    };
  }
  /**
   *
   * @param offsetY scaled offset y
   * @param scaleY scale y
   * @param scrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   */
  getRowIndexByOffsetY(offsetY, scaleY, scrollXY, options) {
    var _a2;
    const { rowHeightAccumulation } = this;
    offsetY = getTransformOffsetY(
      offsetY,
      scaleY,
      scrollXY,
      this.columnHeaderHeightAndMarginTop
    );
    let row = searchArray(
      rowHeightAccumulation,
      offsetY,
      options == null ? void 0 : options.firstMatch
    );
    if (options == null ? void 0 : options.closeFirst) {
      if (Math.abs(rowHeightAccumulation[row] - offsetY) < Math.abs(offsetY - ((_a2 = rowHeightAccumulation[row - 1]) != null ? _a2 : 0))) {
        row = row + 1;
      }
    }
    return row;
  }
  /**
   * Get column index by offset x.
   * @param offsetX scaled offset x
   * @param scaleX scale x
   * @param scrollXY scrollXY
   * @returns column index
   */
  getColumnIndexByOffsetX(evtOffsetX, scaleX, scrollXY, options) {
    var _a2;
    const offsetX = getTransformOffsetX(
      evtOffsetX,
      scaleX,
      scrollXY,
      this.rowHeaderWidthAndMarginLeft
    );
    const { columnWidthAccumulation } = this;
    let column = searchArray(
      columnWidthAccumulation,
      offsetX,
      options == null ? void 0 : options.firstMatch
    );
    if (options == null ? void 0 : options.closeFirst) {
      if (Math.abs(columnWidthAccumulation[column] - offsetX) < Math.abs(offsetX - ((_a2 = columnWidthAccumulation[column - 1]) != null ? _a2 : 0))) {
        column = column + 1;
      }
    }
    return column;
  }
  /**
   * Get cell index by offset(o)
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY  render viewport scroll {x, y}, scene.getScrollXYByRelativeCoords, scene.getScrollXY
   * @param scrollXY.x
   * @param scrollXY.y
   * @returns {row, col}
   */
  getCellIndexByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY, options) {
    const row = this.getRowIndexByOffsetY(
      offsetY,
      scaleY,
      scrollXY,
      options
    );
    const column = this.getColumnIndexByOffsetX(
      offsetX,
      scaleX,
      scrollXY,
      options
    );
    return {
      row,
      column
    };
  }
  /**
   * Unlike getCellWithCoordByOffset, returning data doesn't include coord.
   * @param offsetX
   * @param offsetY
   * @param scaleX
   * @param scaleY
   * @param scrollXY
   */
  getCellByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY) {
    const cellIndex = this == null ? void 0 : this.getCellIndexByOffset(
      offsetX,
      offsetY,
      scaleX,
      scaleY,
      scrollXY,
      { firstMatch: true }
    );
    if (!cellIndex) return null;
    const selectionCell = this.worksheet.getCellInfoInMergeData(
      cellIndex.row,
      cellIndex.column
    );
    return selectionCell;
  }
  /**
   * Return cell information corresponding to the current coordinates, including the merged cell object.
   *
   * @param row Specified Row Coordinate
   * @param column Specified Column Coordinate
   */
  getCellWithCoordByIndex(row, column, header = true) {
    const {
      rowHeightAccumulation,
      columnWidthAccumulation,
      rowHeaderWidthAndMarginLeft,
      columnHeaderHeightAndMarginTop
    } = this;
    const primary = getCellWithCoordByIndexCore(
      row,
      column,
      rowHeightAccumulation,
      columnWidthAccumulation,
      this.worksheet.getCellInfoInMergeData(row, column)
    );
    const { isMerged, isMergedMainCell } = primary;
    let { startY, endY, startX, endX, mergeInfo } = primary;
    let offsetX = rowHeaderWidthAndMarginLeft;
    let offsetY = columnHeaderHeightAndMarginTop;
    if (header === false) {
      offsetX = 0;
      offsetY = 0;
    }
    startY += offsetY;
    endY += offsetY;
    startX += offsetX;
    endX += offsetX;
    mergeInfo.startY += offsetY;
    mergeInfo.endY += offsetY;
    mergeInfo.startX += offsetX;
    mergeInfo.endX += offsetX;
    return {
      actualRow: row,
      actualColumn: column,
      startX,
      startY,
      endX,
      endY,
      isMerged,
      isMergedMainCell,
      mergeInfo
    };
  }
  /**
   * Get cell by pos(offsetX, offsetY). Combine getCellIndexByOffset and then getCellWithCoordByIndex.
   *
   * options.matchFirst true means get cell would skip all invisible cells.
   * @param offsetX position X in viewport.
   * @param offsetY position Y in viewport.
   * @param scaleX render scene scale x-axis, scene.getAncestorScale
   * @param scaleY render scene scale y-axis, scene.getAncestorScale
   * @param scrollXY render viewportScroll {x, y}
   * @param options {IGetRowColByPosOptions}
   * @returns {ICellWithCoord} Selection data with coordinates
   */
  getCellWithCoordByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY, options) {
    const { row, column } = this.getCellIndexByOffset(
      offsetX,
      offsetY,
      scaleX,
      scaleY,
      scrollXY,
      options
    );
    return this.getCellWithCoordByIndex(row, column);
  }
  /**
   * Original name: getOffsetByPositionX
   * @param column
   * @returns
   */
  getOffsetByColumn(column) {
    const { columnWidthAccumulation, rowHeaderWidthAndMarginLeft } = this;
    const lastColumnIndex = columnWidthAccumulation.length - 1;
    const columnValue = columnWidthAccumulation[column];
    if (columnValue != null) {
      return columnValue + rowHeaderWidthAndMarginLeft;
    }
    if (column < 0) {
      return rowHeaderWidthAndMarginLeft;
    }
    return columnWidthAccumulation[lastColumnIndex] + rowHeaderWidthAndMarginLeft;
  }
  /**
   * Original name: getOffsetByPositionY
   * @param row
   */
  getOffsetByRow(row) {
    const { rowHeightAccumulation, columnHeaderHeightAndMarginTop } = this;
    const lastRowIndex = rowHeightAccumulation.length - 1;
    const rowValue = rowHeightAccumulation[row];
    if (rowValue != null) {
      return rowValue + columnHeaderHeightAndMarginTop;
    }
    if (row < 0) {
      return columnHeaderHeightAndMarginTop;
    }
    return rowHeightAccumulation[lastRowIndex] + columnHeaderHeightAndMarginTop;
  }
  /**
   * Original name: getDecomposedOffset
   * @param offsetX
   * @param offsetY
   */
  getOffsetRelativeToRowCol(offsetX, offsetY) {
    const column = searchArray(this.columnWidthAccumulation, offsetX);
    let columnOffset = 0;
    if (column === 0) {
      columnOffset = offsetX;
    } else {
      columnOffset = offsetX - this._columnWidthAccumulation[column - 1];
    }
    const row = searchArray(this.rowHeightAccumulation, offsetY);
    let rowOffset = 0;
    if (row === 0) {
      rowOffset = offsetY;
    } else {
      rowOffset = offsetY - this._rowHeightAccumulation[row - 1];
    }
    return {
      row,
      column,
      columnOffset,
      rowOffset
    };
  }
  _updateConfigAndGetDocumentModel(documentData, horizontalAlign, paddingData, renderConfig) {
    var _a2, _b2, _c, _d, _e;
    if (!renderConfig) {
      return;
    }
    if (!((_a2 = documentData.body) == null ? void 0 : _a2.dataStream)) {
      return;
    }
    if (!documentData.documentStyle) {
      documentData.documentStyle = {};
    }
    documentData.documentStyle.marginTop = (_b2 = paddingData.t) != null ? _b2 : 0;
    documentData.documentStyle.marginBottom = (_c = paddingData.b) != null ? _c : 2;
    documentData.documentStyle.marginLeft = (_d = paddingData.l) != null ? _d : 2;
    documentData.documentStyle.marginRight = (_e = paddingData.r) != null ? _e : 2;
    documentData.documentStyle.pageSize = {
      width: Number.POSITIVE_INFINITY,
      height: Number.POSITIVE_INFINITY
    };
    documentData.documentStyle.renderConfig = {
      ...documentData.documentStyle.renderConfig,
      ...renderConfig
    };
    const paragraphs = documentData.body.paragraphs || [];
    for (const paragraph of paragraphs) {
      if (!paragraph.paragraphStyle) {
        paragraph.paragraphStyle = {};
      }
      paragraph.paragraphStyle.horizontalAlign = horizontalAlign;
    }
    return new DocumentDataModel(documentData);
  }
  dispose() {
    super.dispose();
    this._rowHeightAccumulation = [];
    this._columnWidthAccumulation = [];
    this._rowTotalHeight = 0;
    this._columnTotalWidth = 0;
    this._rowHeaderWidth = 0;
    this._columnHeaderHeight = 0;
    this._worksheetData = null;
    this._cellData = null;
    this._styles = null;
  }
};
SheetSkeleton = __decorateClass([
  __decorateParam(2, Inject(LocaleService)),
  __decorateParam(3, IContextService),
  __decorateParam(4, IConfigService),
  __decorateParam(5, Inject(Injector))
], SheetSkeleton);
function getCellCoordByIndexSimple(row, column, rowHeightAccumulation, columnWidthAccumulation) {
  const startRow = row - 1;
  const startColumn = column - 1;
  const startY = rowHeightAccumulation[startRow] || 0;
  let endY = rowHeightAccumulation[row];
  if (endY == null) {
    endY = rowHeightAccumulation[rowHeightAccumulation.length - 1];
  }
  const startX = columnWidthAccumulation[startColumn] || 0;
  let endX = columnWidthAccumulation[column];
  if (endX == null) {
    endX = columnWidthAccumulation[columnWidthAccumulation.length - 1];
  }
  return {
    startY,
    endY,
    startX,
    endX
  };
}
function getCellWithCoordByIndexCore(row, column, rowHeightAccumulation, columnWidthAccumulation, mergeDataInfo) {
  row = Tools.clamp(row, 0, rowHeightAccumulation.length - 1);
  column = Tools.clamp(column, 0, columnWidthAccumulation.length - 1);
  let { startY, endY, startX, endX } = getCellCoordByIndexSimple(
    row,
    column,
    rowHeightAccumulation,
    columnWidthAccumulation
  );
  if (!mergeDataInfo) {
    return {
      startY,
      endY,
      startX,
      endX,
      isMerged: false,
      isMergedMainCell: false,
      actualRow: row,
      actualColumn: column,
      mergeInfo: {
        startY,
        endY,
        startX,
        endX,
        startRow: row,
        startColumn: column,
        endRow: row,
        endColumn: column
      }
    };
  }
  const {
    isMerged,
    isMergedMainCell,
    startRow,
    startColumn,
    endRow,
    endColumn
  } = mergeDataInfo;
  let mergeInfo = {
    startRow,
    startColumn,
    endRow,
    endColumn,
    startY,
    endY,
    startX,
    endX
  };
  const rowAccumulationCount = rowHeightAccumulation.length - 1;
  const columnAccumulationCount = columnWidthAccumulation.length - 1;
  if (isMerged && startRow !== -1 && startColumn !== -1) {
    const mergeStartY = rowHeightAccumulation[startRow - 1] || 0;
    const mergeEndY = rowHeightAccumulation[endRow] || rowHeightAccumulation[rowAccumulationCount];
    const mergeStartX = columnWidthAccumulation[startColumn - 1] || 0;
    const mergeEndX = columnWidthAccumulation[endColumn] || columnWidthAccumulation[columnAccumulationCount];
    mergeInfo = {
      ...mergeInfo,
      startY: mergeStartY,
      endY: mergeEndY,
      startX: mergeStartX,
      endX: mergeEndX
    };
  } else if (!isMerged && endRow !== -1 && endColumn !== -1) {
    const mergeEndY = rowHeightAccumulation[endRow] || rowHeightAccumulation[rowAccumulationCount];
    const mergeEndX = columnWidthAccumulation[endColumn] || columnWidthAccumulation[columnAccumulationCount];
    mergeInfo = {
      ...mergeInfo,
      startY,
      endY: mergeEndY,
      startX,
      endX: mergeEndX
    };
  }
  return {
    isMerged,
    isMergedMainCell,
    actualRow: row,
    actualColumn: column,
    startY,
    endY,
    startX,
    endX,
    mergeInfo
  };
}
function getTransformOffsetX(offsetX, scaleX, scrollXY, rowHeaderWidth) {
  const { x: scrollX } = scrollXY;
  const afterOffsetX = offsetX / scaleX + scrollX - rowHeaderWidth;
  return afterOffsetX;
}
function getTransformOffsetY(offsetY, scaleY, scrollXY, columnHeight) {
  const { y: scrollY } = scrollXY;
  offsetY = offsetY / scaleY + scrollY - columnHeight;
  return offsetY;
}

// ../node_modules/.pnpm/kdbush@4.0.2/node_modules/kdbush/index.js
var ARRAY_TYPES = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
];
var VERSION = 1;
var HEADER_SIZE = 8;
var KDBush = class _KDBush {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(data) {
    if (!(data instanceof ArrayBuffer)) {
      throw new Error("Data must be an instance of ArrayBuffer.");
    }
    const [magic, versionAndType] = new Uint8Array(data, 0, 2);
    if (magic !== 219) {
      throw new Error("Data does not appear to be in a KDBush format.");
    }
    const version = versionAndType >> 4;
    if (version !== VERSION) {
      throw new Error(`Got v${version} data when expected v${VERSION}.`);
    }
    const ArrayType = ARRAY_TYPES[versionAndType & 15];
    if (!ArrayType) {
      throw new Error("Unrecognized array type.");
    }
    const [nodeSize] = new Uint16Array(data, 2, 1);
    const [numItems] = new Uint32Array(data, 4, 1);
    return new _KDBush(numItems, nodeSize, ArrayType, data);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {
    if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);
    this.numItems = +numItems;
    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
    this.ArrayType = ArrayType;
    this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;
    const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);
    const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;
    const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;
    const padCoords = (8 - idsByteSize % 8) % 8;
    if (arrayTypeIndex < 0) {
      throw new Error(`Unexpected typed array class: ${ArrayType}.`);
    }
    if (data && data instanceof ArrayBuffer) {
      this.data = data;
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = numItems * 2;
      this._finished = true;
    } else {
      this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);
      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);
      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);
      this._pos = 0;
      this._finished = false;
      new Uint8Array(this.data, 0, 2).set([219, (VERSION << 4) + arrayTypeIndex]);
      new Uint16Array(this.data, 2, 1)[0] = nodeSize;
      new Uint32Array(this.data, 4, 1)[0] = numItems;
    }
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(x, y) {
    const index = this._pos >> 1;
    this.ids[index] = index;
    this.coords[this._pos++] = x;
    this.coords[this._pos++] = y;
    return index;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const numAdded = this._pos >> 1;
    if (numAdded !== this.numItems) {
      throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);
    }
    sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);
    this._finished = true;
    return this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(minX, minY, maxX, maxY) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          const x2 = coords[2 * i];
          const y2 = coords[2 * i + 1];
          if (x2 >= minX && x2 <= maxX && y2 >= minY && y2 <= maxY) result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x = coords[2 * m];
      const y = coords[2 * m + 1];
      if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);
      if (axis === 0 ? minX <= x : minY <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? maxX >= x : maxY >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(qx, qy, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids, coords, nodeSize } = this;
    const stack = [0, ids.length - 1, 0];
    const result = [];
    const r2 = r * r;
    while (stack.length) {
      const axis = stack.pop() || 0;
      const right = stack.pop() || 0;
      const left = stack.pop() || 0;
      if (right - left <= nodeSize) {
        for (let i = left; i <= right; i++) {
          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);
        }
        continue;
      }
      const m = left + right >> 1;
      const x = coords[2 * m];
      const y = coords[2 * m + 1];
      if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);
      if (axis === 0 ? qx - r <= x : qy - r <= y) {
        stack.push(left);
        stack.push(m - 1);
        stack.push(1 - axis);
      }
      if (axis === 0 ? qx + r >= x : qy + r >= y) {
        stack.push(m + 1);
        stack.push(right);
        stack.push(1 - axis);
      }
    }
    return result;
  }
};
function sort(ids, coords, nodeSize, left, right, axis) {
  if (right - left <= nodeSize) return;
  const m = left + right >> 1;
  select(ids, coords, m, left, right, axis);
  sort(ids, coords, nodeSize, left, m - 1, 1 - axis);
  sort(ids, coords, nodeSize, m + 1, right, 1 - axis);
}
function select(ids, coords, k, left, right, axis) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      select(ids, coords, k, newLeft, newRight, axis);
    }
    const t = coords[2 * k + axis];
    let i = left;
    let j = right;
    swapItem(ids, coords, left, k);
    if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);
    while (i < j) {
      swapItem(ids, coords, i, j);
      i++;
      j--;
      while (coords[2 * i + axis] < t) i++;
      while (coords[2 * j + axis] > t) j--;
    }
    if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);
    else {
      j++;
      swapItem(ids, coords, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swapItem(ids, coords, i, j) {
  swap2(ids, i, j);
  swap2(coords, 2 * i, 2 * j);
  swap2(coords, 2 * i + 1, 2 * j + 1);
}
function swap2(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function sqDist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}

// ../packages/core/src/shared/r-tree.ts
var RTree = class {
  constructor(_enableOneCellCache = false) {
    this._enableOneCellCache = _enableOneCellCache;
    __publicField(this, "_tree", /* @__PURE__ */ new Map());
    // unitId -> subUnitId -> row -> column -> ids
    __publicField(this, "_oneCellCache", /* @__PURE__ */ new Map());
    __publicField(this, "_kdTree", /* @__PURE__ */ new Map());
  }
  dispose() {
    this.clear();
  }
  getTree(unitId, subUnitId) {
    if (!this._tree.has(unitId)) {
      this._tree.set(unitId, /* @__PURE__ */ new Map());
    }
    if (!this._tree.get(unitId).has(subUnitId)) {
      this._tree.get(unitId).set(subUnitId, new RBush());
    }
    return this._tree.get(unitId).get(subUnitId);
  }
  _getOneCellCache(unitId, subUnitId, row, column) {
    if (!this._oneCellCache.has(unitId)) {
      this._oneCellCache.set(unitId, /* @__PURE__ */ new Map());
    }
    if (!this._oneCellCache.get(unitId).has(subUnitId)) {
      this._oneCellCache.get(unitId).set(subUnitId, /* @__PURE__ */ new Map());
    }
    if (!this._oneCellCache.get(unitId).get(subUnitId).has(row)) {
      this._oneCellCache.get(unitId).get(subUnitId).set(row, /* @__PURE__ */ new Map());
    }
    if (!this._oneCellCache.get(unitId).get(subUnitId).get(row).has(column)) {
      this._oneCellCache.get(unitId).get(subUnitId).get(row).set(column, /* @__PURE__ */ new Set());
    }
    return this._oneCellCache.get(unitId).get(subUnitId).get(row).get(column);
  }
  _removeOneCellCache(unitId, subUnitId, row, column, id) {
    const unitCache = this._oneCellCache.get(unitId);
    if (!unitCache) return;
    const subUnitCache = unitCache.get(subUnitId);
    if (!subUnitCache) return;
    const rowCache = subUnitCache.get(row);
    if (!rowCache) return;
    const cellCache = rowCache.get(column);
    if (!cellCache) return;
    cellCache.delete(id);
  }
  _removeCellCacheByRange(search) {
    const { unitId, sheetId: subUnitId, range, id } = search;
    const unitCache = this._oneCellCache.get(unitId);
    if (!unitCache) return;
    const subUnitCache = unitCache.get(subUnitId);
    if (!subUnitCache) return;
    const { startRow, startColumn, endRow, endColumn } = range;
    for (let row = startRow; row <= endRow; row++) {
      const rowCache = subUnitCache.get(row);
      if (!rowCache) continue;
      for (let column = startColumn; column <= endColumn; column++) {
        const cellCache = rowCache.get(column);
        if (!cellCache) continue;
        cellCache.delete(id);
      }
    }
  }
  _insertOneCellCache(unitId, subUnitId, row, column, id) {
    this._getOneCellCache(unitId, subUnitId, row, column).add(id);
  }
  _getRdTreeItems(map9) {
    const items = [];
    for (const [y, innerMap] of map9) {
      for (const [x, ids] of innerMap) {
        items.push({
          x,
          y,
          ids
        });
      }
    }
    return items;
  }
  _searchByOneCellCache(search) {
    var _a2;
    const { unitId, sheetId: subUnitId, range } = search;
    const { startRow, startColumn, endRow, endColumn } = range;
    const searchObject = (_a2 = this._kdTree.get(unitId)) == null ? void 0 : _a2.get(subUnitId);
    if (!searchObject) {
      return [];
    }
    const { tree, items } = searchObject;
    const indexes = tree.range(startColumn, startRow, endColumn, endRow);
    const result = [];
    for (const index of indexes) {
      const item = items[index];
      result.push(...Array.from(item.ids));
    }
    return result;
  }
  /**
   * Open the kd-tree search state.
   * The kd-tree is used to search for data in a single cell.
   */
  openKdTree() {
    var _a2;
    for (const [unitId, map1] of this._oneCellCache) {
      if (!this._kdTree.has(unitId)) {
        this._kdTree.set(unitId, /* @__PURE__ */ new Map());
      }
      for (const [subUnitId, map22] of map1) {
        const items = this._getRdTreeItems(map22);
        const tree = new KDBush(items.length);
        (_a2 = this._kdTree.get(unitId)) == null ? void 0 : _a2.set(subUnitId, {
          tree,
          items
        });
        for (const item of items) {
          tree.add(item.x, item.y);
        }
        tree.finish();
      }
    }
  }
  closeKdTree() {
    var _a2;
    for (const [unitId, map1] of this._oneCellCache) {
      for (const [subUnitId, map22] of map1) {
        (_a2 = this._kdTree.get(unitId)) == null ? void 0 : _a2.set(subUnitId, void 0);
      }
    }
  }
  insert(item) {
    const { unitId, sheetId: subUnitId, range, id } = item;
    if (!unitId || unitId.length === 0) {
      return;
    }
    let { startRow: rangeStartRow, endRow: rangeEndRow, startColumn: rangeStartColumn, endColumn: rangeEndColumn } = range;
    if (this._enableOneCellCache && rangeStartRow === rangeEndRow && rangeStartColumn === rangeEndColumn) {
      this._insertOneCellCache(unitId, subUnitId, rangeStartRow, rangeStartColumn, id);
      return;
    }
    const tree = this.getTree(unitId, subUnitId);
    if (Number.isNaN(rangeStartRow)) {
      rangeStartRow = 0;
    }
    if (Number.isNaN(rangeStartColumn)) {
      rangeStartColumn = 0;
    }
    if (Number.isNaN(rangeEndRow)) {
      rangeEndRow = Number.POSITIVE_INFINITY;
    }
    if (Number.isNaN(rangeEndColumn)) {
      rangeEndColumn = Number.POSITIVE_INFINITY;
    }
    tree.insert({
      minX: rangeStartColumn,
      minY: rangeStartRow,
      maxX: rangeEndColumn,
      maxY: rangeEndRow,
      id
    });
  }
  bulkInsert(items) {
    for (const item of items) {
      this.insert(item);
    }
  }
  *searchGenerator(search) {
    var _a2;
    const { unitId, sheetId: subUnitId, range } = search;
    if (this._enableOneCellCache) {
      const oneCellResults = this._searchByOneCellCache(search);
      for (const result of oneCellResults) {
        yield result;
      }
    }
    const tree = (_a2 = this._tree.get(unitId)) == null ? void 0 : _a2.get(subUnitId);
    if (!tree) {
      return;
    }
    const searchData = tree.search({
      minX: range.startColumn,
      minY: range.startRow,
      maxX: range.endColumn,
      maxY: range.endRow
    });
    for (const item of searchData) {
      yield item.id;
    }
  }
  bulkSearch(searchList, exceptTreeIds) {
    const result = /* @__PURE__ */ new Set();
    for (const search of searchList) {
      for (const item of this.searchGenerator(search)) {
        if ((exceptTreeIds == null ? void 0 : exceptTreeIds.has(item)) === true) {
          continue;
        }
        result.add(item);
      }
    }
    return result;
  }
  removeById(unitId, subUnitId) {
    var _a2, _b2;
    if (subUnitId) {
      (_a2 = this._tree.get(unitId)) == null ? void 0 : _a2.delete(subUnitId);
      (_b2 = this._oneCellCache.get(unitId)) == null ? void 0 : _b2.delete(subUnitId);
    } else {
      this._tree.delete(unitId);
      this._oneCellCache.delete(unitId);
    }
  }
  _removeRTreeItem(search) {
    const { unitId, sheetId: subUnitId, range, id } = search;
    const tree = this.getTree(unitId, subUnitId);
    const items = tree.search({
      minX: range.startColumn,
      minY: range.startRow,
      maxX: range.endColumn,
      maxY: range.endRow
    });
    for (let i = 0; i < items.length; i++) {
      if (items[i].id === id) {
        tree.remove(items[i]);
      }
    }
  }
  remove(search) {
    const { unitId, sheetId: subUnitId, range, id } = search;
    const { startRow, startColumn, endRow, endColumn } = range;
    if (this._enableOneCellCache) {
      if (startRow === endRow && startColumn === endColumn) {
        this._removeOneCellCache(unitId, subUnitId, range.startRow, range.startColumn, id);
      } else {
        this._removeCellCacheByRange(search);
        this._removeRTreeItem(search);
      }
    } else {
      this._removeRTreeItem(search);
    }
  }
  bulkRemove(searchList) {
    for (const search of searchList) {
      this.remove(search);
    }
  }
  clear() {
    this._tree.clear();
    this._oneCellCache.clear();
  }
  toJSON() {
    const result = {};
    this._tree.forEach((subTree, unitId) => {
      result[unitId] = {};
      subTree.forEach((tree, subUnitId) => {
        result[unitId][subUnitId] = tree.toJSON();
      });
    });
    return result;
  }
  fromJSON(data) {
    this._tree.clear();
    for (const unitId in data) {
      this._tree.set(unitId, /* @__PURE__ */ new Map());
      for (const subUnitId in data[unitId]) {
        const tree = new RBush();
        tree.fromJSON(data[unitId][subUnitId]);
        this._tree.get(unitId).set(subUnitId, tree);
      }
    }
  }
};

// ../packages/core/src/services/resource-loader/resource-loader.service.ts
var ResourceLoaderService = class extends Disposable {
  constructor(_resourceManagerService, _univerInstanceService) {
    super();
    this._resourceManagerService = _resourceManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._init();
  }
  _init() {
    const handleHookAdd = (hook) => {
      hook.businesses.forEach((business) => {
        switch (business) {
          case O.UNRECOGNIZED:
          case O.UNIVER_UNKNOWN:
          case O.UNIVER_SLIDE:
          case O.UNIVER_DOC: {
            this._univerInstanceService.getAllUnitsForType(O.UNIVER_DOC).forEach((doc) => {
              const snapshotResource = doc.getSnapshot().resources || [];
              const plugin = snapshotResource.find((r) => r.name === hook.pluginName);
              if (plugin) {
                try {
                  const data = hook.parseJson(plugin.data);
                  hook.onLoad(doc.getUnitId(), data);
                } catch (err) {
                  console.error(`Load Document{${doc.getUnitId()}} Resources{${hook.pluginName}} Data Error.`);
                }
              }
            });
            break;
          }
          case O.UNIVER_SHEET: {
            this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).forEach((workbook) => {
              const snapshotResource = workbook.getSnapshot().resources || [];
              const plugin = snapshotResource.find((r) => r.name === hook.pluginName);
              if (plugin) {
                try {
                  const data = hook.parseJson(plugin.data);
                  hook.onLoad(workbook.getUnitId(), data);
                } catch (err) {
                  console.error(`Load Workbook{${workbook.getUnitId()}} Resources{${hook.pluginName}} Data Error.`);
                }
              }
            });
          }
        }
      });
    };
    const allResourceHooks = this._resourceManagerService.getAllResourceHooks();
    allResourceHooks.forEach((hook) => handleHookAdd(hook));
    this.disposeWithMe(this._resourceManagerService.register$.subscribe((hook) => handleHookAdd(hook)));
    this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(O.UNIVER_SHEET).subscribe((workbook) => {
        this._resourceManagerService.loadResources(workbook.getUnitId(), workbook.getSnapshot().resources);
      })
    );
    this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitAdded$(O.UNIVER_DOC).subscribe((doc) => {
        const unitId = doc.getUnitId();
        if (!isInternalEditorID(unitId)) {
          this._resourceManagerService.loadResources(doc.getUnitId(), doc.getSnapshot().resources);
        }
      })
    );
    this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET).subscribe((workbook) => {
        this._resourceManagerService.unloadResources(workbook.getUnitId());
      })
    );
    this.disposeWithMe(
      this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_DOC).subscribe((doc) => {
        this._resourceManagerService.unloadResources(doc.getUnitId());
      })
    );
  }
  saveUnit(unitId) {
    const unit = this._univerInstanceService.getUnit(unitId);
    if (!unit) {
      return null;
    }
    const resources = this._resourceManagerService.getResources(unitId, unit.type);
    const snapshot = Tools.deepClone(unit.getSnapshot());
    snapshot.resources = resources;
    return snapshot;
  }
};
ResourceLoaderService = __decorateClass([
  __decorateParam(0, Inject(IResourceManagerService)),
  __decorateParam(1, Inject(IUniverInstanceService))
], ResourceLoaderService);

// ../packages/core/src/univer.ts
var Univer = class {
  /**
   * Create a Univer instance.
   * @param config Configuration data for Univer
   * @param parentInjector An optional parent injector of the Univer injector. For more information, see https://redi.wendell.fun/docs/hierarchy.
   */
  constructor(config2 = {}, parentInjector) {
    __publicField(this, "_startedTypes", /* @__PURE__ */ new Set());
    __publicField(this, "_injector");
    __publicField(this, "_disposingCallbacks", new DisposableCollection());
    const injector = this._injector = createUniverInjector(parentInjector, config2 == null ? void 0 : config2.override);
    const { theme, locale, locales, logLevel } = config2;
    if (theme) this._injector.get(ThemeService).setTheme(theme);
    if (locales) this._injector.get(LocaleService).load(locales);
    if (locale) this._injector.get(LocaleService).setLocale(locale);
    if (logLevel) this._injector.get(ILogService).setLogLevel(logLevel);
    this._init(injector);
  }
  get _univerInstanceService() {
    return this._injector.get(IUniverInstanceService);
  }
  get _pluginService() {
    return this._injector.get(PluginService);
  }
  /**
   * @ignore
   */
  __getInjector() {
    return this._injector;
  }
  /**
   * Register a callback function which will be called when this Univer instance is disposing.
   *
   * @ignore
   *
   * @param callback The callback function.
   * @returns To remove this callback function from this Univer instance's on disposing list.
   */
  onDispose(callback) {
    const d = this._disposingCallbacks.add(toDisposable(callback));
    return toDisposable(() => d.dispose(true));
  }
  dispose() {
    this._disposingCallbacks.dispose();
    this._injector.dispose();
  }
  setLocale(locale) {
    this._injector.get(LocaleService).setLocale(locale);
  }
  createUnit(type2, data) {
    return this._univerInstanceService.createUnit(type2, data);
  }
  /**
   * Create a univer sheet instance with internal dependency injection.
   *
   * @deprecated use `createUnit` instead
   */
  createUniverSheet(data) {
    this._injector.get(ILogService).warn("[Univer]", "Univer.createUniverSheet is deprecated, use createUnit instead");
    return this._univerInstanceService.createUnit(O.UNIVER_SHEET, data);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverDoc(data) {
    this._injector.get(ILogService).warn("[Univer]", "Univer.createUniverDoc is deprecated, use createUnit instead");
    return this._univerInstanceService.createUnit(O.UNIVER_DOC, data);
  }
  /**
   * @deprecated use `createUnit` instead
   */
  createUniverSlide(data) {
    this._injector.get(ILogService).warn("[Univer]", "Univer.createUniverSlide is deprecated, use createUnit instead");
    return this._univerInstanceService.createUnit(O.UNIVER_SLIDE, data);
  }
  _init(injector) {
    this._univerInstanceService.registerCtorForType(O.UNIVER_SHEET, Workbook);
    this._univerInstanceService.registerCtorForType(O.UNIVER_DOC, DocumentDataModel);
    this._univerInstanceService.registerCtorForType(O.UNIVER_SLIDE, SlideDataModel);
    const univerInstanceService = injector.get(IUniverInstanceService);
    univerInstanceService.__setCreateHandler(
      (type2, data, ctor, options) => {
        if (!this._startedTypes.has(type2)) {
          this._pluginService.startPluginsForType(type2);
          this._startedTypes.add(type2);
          const model2 = injector.createInstance(ctor, data);
          univerInstanceService.__addUnit(model2, options);
          this._tryProgressToReady();
          return model2;
        }
        const model = injector.createInstance(ctor, data);
        univerInstanceService.__addUnit(model, options);
        return model;
      }
    );
  }
  _tryProgressToReady() {
    const lifecycleService = this._injector.get(LifecycleService);
    if (lifecycleService.stage < 1 /* Ready */) {
      this._injector.get(LifecycleService).stage = 1 /* Ready */;
    }
  }
  /** Register a plugin into univer. */
  registerPlugin(plugin, config2) {
    this._pluginService.registerPlugin(plugin, config2);
  }
};
function createUniverInjector(parentInjector, override) {
  const dependencies = mergeOverrideWithDependencies([
    [ErrorService],
    [LocaleService],
    [ThemeService],
    [LifecycleService],
    [PluginService],
    [UserManagerService],
    // abstract services
    [IUniverInstanceService, { useClass: UniverInstanceService }],
    [IPermissionService, { useClass: PermissionService }],
    [ILogService, { useClass: DesktopLogService, lazy: true }],
    [ICommandService, { useClass: CommandService }],
    [IUndoRedoService, { useClass: LocalUndoRedoService, lazy: true }],
    [IConfigService, { useClass: ConfigService }],
    [IContextService, { useClass: ContextService }],
    [IResourceManagerService, { useClass: ResourceManagerService, lazy: true }],
    [IResourceLoaderService, { useClass: ResourceLoaderService, lazy: true }],
    [IAuthzIoService, { useClass: AuthzIoLocalService }],
    [IMentionIOService, { useClass: MentionIOLocalService, lazy: true }]
  ], override);
  const injector = parentInjector ? parentInjector.createChild(dependencies) : new Injector(dependencies);
  touchDependencies(injector, [
    [UserManagerService],
    [IResourceLoaderService]
  ]);
  return injector;
}

// ../packages/core/src/index.ts
installShims();

// ../packages/engine-formula/src/engine/utils/ast-node-tool.ts
function getAstNodeTopParent(node) {
  let parent = node;
  while (parent == null ? void 0 : parent.getParent()) {
    parent = parent.getParent();
  }
  return parent;
}
function generateExecuteAstNodeData(node, refOffsetX = 0, refOffsetY = 0) {
  return {
    node,
    refOffsetX,
    refOffsetY
  };
}

// ../packages/engine-formula/src/basics/dirty.ts
function isInDirtyRange(dirtyRanges, unitId, sheetId, row, column) {
  for (let i = 0, len = dirtyRanges.length; i < len; i++) {
    const dirtyRange = dirtyRanges[i];
    if (unitId !== dirtyRange.unitId) {
      continue;
    }
    if (sheetId !== dirtyRange.sheetId) {
      continue;
    }
    const { startRow, startColumn, endRow, endColumn } = dirtyRange.range;
    if (row >= startRow && row <= endRow && column >= startColumn && column <= endColumn) {
      return true;
    }
  }
  return false;
}

// ../packages/engine-formula/src/basics/error-type.ts
var ErrorType = /* @__PURE__ */ ((ErrorType3) => {
  ErrorType3["DIV_BY_ZERO"] = "#DIV/0!";
  ErrorType3["NAME"] = "#NAME?";
  ErrorType3["VALUE"] = "#VALUE!";
  ErrorType3["NUM"] = "#NUM!";
  ErrorType3["NA"] = "#N/A";
  ErrorType3["CYCLE"] = "#CYCLE!";
  ErrorType3["REF"] = "#REF!";
  ErrorType3["SPILL"] = "#SPILL!";
  ErrorType3["CALC"] = "#CALC!";
  ErrorType3["ERROR"] = "#ERROR!";
  ErrorType3["CONNECT"] = "#GETTING_DATA";
  ErrorType3["NULL"] = "#NULL!";
  return ErrorType3;
})(ErrorType || {});
var ERROR_TYPE_SET = new Set(Object.values(ErrorType));
var ERROR_TYPE_COUNT_ARRAY = [...new Set(Object.values(ErrorType).map((error) => error.length))];

// ../packages/engine-formula/src/basics/token.ts
var operatorToken = /* @__PURE__ */ ((operatorToken2) => {
  operatorToken2["PLUS"] = "+";
  operatorToken2["MINUS"] = "-";
  operatorToken2["MULTIPLY"] = "*";
  operatorToken2["DIVIDED"] = "/";
  operatorToken2["CONCATENATE"] = "&";
  operatorToken2["POWER"] = "^";
  operatorToken2["EQUALS"] = "=";
  operatorToken2["NOT_EQUAL"] = "<>";
  operatorToken2["GREATER_THAN"] = ">";
  operatorToken2["GREATER_THAN_OR_EQUAL"] = ">=";
  operatorToken2["LESS_THAN"] = "<";
  operatorToken2["LESS_THAN_OR_EQUAL"] = "<=";
  return operatorToken2;
})(operatorToken || {});
var compareToken = /* @__PURE__ */ ((compareToken2) => {
  compareToken2["EQUALS"] = "=";
  compareToken2["NOT_EQUAL"] = "<>";
  compareToken2["GREATER_THAN"] = ">";
  compareToken2["GREATER_THAN_OR_EQUAL"] = ">=";
  compareToken2["LESS_THAN"] = "<";
  compareToken2["LESS_THAN_OR_EQUAL"] = "<=";
  return compareToken2;
})(compareToken || {});
var OPERATOR_TOKEN_PRIORITY = /* @__PURE__ */ new Map([
  ["<>" /* NOT_EQUAL */, 4],
  ["<" /* LESS_THAN */, 4],
  [">=" /* GREATER_THAN_OR_EQUAL */, 4],
  ["=" /* EQUALS */, 4],
  [">" /* GREATER_THAN */, 4],
  ["<=" /* LESS_THAN_OR_EQUAL */, 4],
  ["&" /* CONCATENATE */, 3],
  ["+" /* PLUS */, 2],
  ["-" /* MINUS */, 2],
  ["/" /* DIVIDED */, 1],
  ["*" /* MULTIPLY */, 1],
  ["^" /* POWER */, 0]
]);
var OPERATOR_TOKEN_SET = new Set(OPERATOR_TOKEN_PRIORITY.keys());
var OPERATOR_TOKEN_COMPARE_SET = /* @__PURE__ */ new Set([
  "=" /* EQUALS */,
  "<>" /* NOT_EQUAL */,
  ">" /* GREATER_THAN */,
  ">=" /* GREATER_THAN_OR_EQUAL */,
  "<" /* LESS_THAN */,
  "<=" /* LESS_THAN_OR_EQUAL */
]);
var matchToken = /* @__PURE__ */ ((matchToken2) => {
  matchToken2["OPEN_BRACKET"] = "(";
  matchToken2["CLOSE_BRACKET"] = ")";
  matchToken2["COMMA"] = ",";
  matchToken2["SINGLE_QUOTATION"] = "'";
  matchToken2["DOUBLE_QUOTATION"] = '"';
  matchToken2["OPEN_BRACES"] = "{";
  matchToken2["CLOSE_BRACES"] = "}";
  matchToken2["COLON"] = ":";
  matchToken2["OPEN_SQUARE_BRACKET"] = "[";
  matchToken2["CLOSE_SQUARE_BRACKET"] = "]";
  return matchToken2;
})(matchToken || {});
var suffixToken = /* @__PURE__ */ ((suffixToken2) => {
  suffixToken2["PERCENTAGE"] = "%";
  suffixToken2["POUND"] = "#";
  return suffixToken2;
})(suffixToken || {});
var SUFFIX_TOKEN_SET = /* @__PURE__ */ new Set(["%" /* PERCENTAGE */, "#" /* POUND */]);
var prefixToken = /* @__PURE__ */ ((prefixToken2) => {
  prefixToken2["AT"] = "@";
  prefixToken2["MINUS"] = "-";
  prefixToken2["PLUS"] = "+";
  return prefixToken2;
})(prefixToken || {});
var SPACE_TOKEN = " ";

// ../packages/engine-formula/src/basics/match-token.ts
var FORMULA_LEXER_TOKENS = [
  ...Object.values(compareToken),
  ...Object.values(operatorToken),
  ...Object.values(matchToken),
  ...Object.values(suffixToken),
  ...Object.values(prefixToken)
];
function isFormulaLexerToken(str) {
  return FORMULA_LEXER_TOKENS.includes(str);
}
function includeFormulaLexerToken(str) {
  for (const token of FORMULA_LEXER_TOKENS) {
    if (str.indexOf(token) > -1) {
      return true;
    }
  }
  return false;
}
var TOKEN_CANNOT_BE_AT_END_SET = /* @__PURE__ */ new Set([
  "+" /* PLUS */,
  "-" /* MINUS */,
  "*" /* MULTIPLY */,
  "/" /* DIVIDED */,
  "&" /* CONCATENATE */,
  "^" /* POWER */,
  "=" /* EQUALS */,
  "<>" /* NOT_EQUAL */,
  ">" /* GREATER_THAN */,
  ">=" /* GREATER_THAN_OR_EQUAL */,
  "<" /* LESS_THAN */,
  "<=" /* LESS_THAN_OR_EQUAL */,
  "(" /* OPEN_BRACKET */,
  "," /* COMMA */,
  ":" /* COLON */,
  "{" /* OPEN_BRACES */,
  "[" /* OPEN_SQUARE_BRACKET */
]);
function isTokenCannotBeAtEnd(token) {
  return TOKEN_CANNOT_BE_AT_END_SET.has(token);
}
var TOKEN_CANNOT_PRECEDE_SUFFIX_TOKEN_SET = /* @__PURE__ */ new Set([
  "+" /* PLUS */,
  "-" /* MINUS */,
  "*" /* MULTIPLY */,
  "/" /* DIVIDED */,
  "&" /* CONCATENATE */,
  "^" /* POWER */,
  "=" /* EQUALS */,
  "<>" /* NOT_EQUAL */,
  ">" /* GREATER_THAN */,
  ">=" /* GREATER_THAN_OR_EQUAL */,
  "<" /* LESS_THAN */,
  "<=" /* LESS_THAN_OR_EQUAL */,
  "(" /* OPEN_BRACKET */,
  "," /* COMMA */,
  ":" /* COLON */,
  "{" /* OPEN_BRACES */,
  "[" /* OPEN_SQUARE_BRACKET */,
  "%" /* PERCENTAGE */,
  "#" /* POUND */
]);
function isTokenCannotPrecedeSuffixToken(token) {
  return TOKEN_CANNOT_PRECEDE_SUFFIX_TOKEN_SET.has(token);
}

// ../packages/engine-formula/src/basics/runtime.ts
function convertUnitDataToRuntime(unitData) {
  const arrayFormulaCellData = {};
  Object.keys(unitData).forEach((unitId) => {
    const sheetData = unitData[unitId];
    if (sheetData == null) {
      return true;
    }
    if (arrayFormulaCellData[unitId] == null) {
      arrayFormulaCellData[unitId] = {};
    }
    Object.keys(sheetData).forEach((sheetId) => {
      const cellData = sheetData[sheetId];
      arrayFormulaCellData[unitId][sheetId] = new ObjectMatrix(cellData);
    });
  });
  return arrayFormulaCellData;
}
function convertRuntimeToUnitData(unitData) {
  const unitPrimitiveData = {};
  for (const unitId in unitData) {
    const sheetData = unitData[unitId];
    if (sheetData == null) {
      continue;
    }
    if (unitPrimitiveData[unitId] == null) {
      unitPrimitiveData[unitId] = {};
    }
    for (const sheetId in sheetData) {
      const cellData = sheetData[sheetId];
      const primitiveData = {};
      cellData.forValue((row, column, value) => {
        if (primitiveData[row] === void 0) {
          primitiveData[row] = {};
        }
        primitiveData[row][column] = value;
      });
      unitPrimitiveData[unitId][sheetId] = primitiveData;
    }
  }
  return unitPrimitiveData;
}

// ../packages/engine-formula/src/basics/regex.ts
var UNIT_NAME_REGEX = '\\[([^\\[\\]\\/?:"<>|*\\\\]+)\\]';
var UNIT_NAME_REGEX_PRECOMPILING = new RegExp(UNIT_NAME_REGEX);
var SHEET_NAME_REGEX = "((?![\\[\\]\\/?*\\\\]).)*!";
var ABSOLUTE_SYMBOL = "$";
var RANGE_SYMBOL = "\\s*?:\\s*?";
var COLUMN_REGEX = "[A-Za-z]+";
var ROW_REGEX = "[1-9][0-9]*";
var UNIT_NAME_SHEET_NAME_REGEX = `'?(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?'?`;
var SIMPLE_SINGLE_RANGE_REGEX = `\\${ABSOLUTE_SYMBOL}?${COLUMN_REGEX}\\${ABSOLUTE_SYMBOL}?${ROW_REGEX}`;
var REFERENCE_MULTIPLE_RANGE_REGEX = `^(${"@" /* AT */})?${UNIT_NAME_SHEET_NAME_REGEX}${SIMPLE_SINGLE_RANGE_REGEX}${RANGE_SYMBOL}${SIMPLE_SINGLE_RANGE_REGEX}$`;
var REFERENCE_MULTIPLE_RANGE_REGEX_PRECOMPILING = new RegExp(REFERENCE_MULTIPLE_RANGE_REGEX);
var REFERENCE_SINGLE_RANGE_REGEX = `^${UNIT_NAME_SHEET_NAME_REGEX}\\s*?${SIMPLE_SINGLE_RANGE_REGEX}(${"#" /* POUND */})?$`;
var REFERENCE_SINGLE_RANGE_REGEX_PRECOMPILING = new RegExp(REFERENCE_SINGLE_RANGE_REGEX);
var REFERENCE_REGEX_ROW = `^${UNIT_NAME_SHEET_NAME_REGEX}\\${ABSOLUTE_SYMBOL}?${ROW_REGEX}${RANGE_SYMBOL}\\${ABSOLUTE_SYMBOL}?${ROW_REGEX}$`;
var REFERENCE_REGEX_ROW_PRECOMPILING = new RegExp(REFERENCE_REGEX_ROW);
var REFERENCE_REGEX_COLUMN = `^${UNIT_NAME_SHEET_NAME_REGEX}\\${ABSOLUTE_SYMBOL}?${COLUMN_REGEX}${RANGE_SYMBOL}\\${ABSOLUTE_SYMBOL}?${COLUMN_REGEX}$`;
var REFERENCE_REGEX_COLUMN_PRECOMPILING = new RegExp(REFERENCE_REGEX_COLUMN);
var REFERENCE_REGEX_SINGLE_ROW = `^${UNIT_NAME_SHEET_NAME_REGEX}\\s*?\\${ABSOLUTE_SYMBOL}?${ROW_REGEX}$`;
var REFERENCE_REGEX_SINGLE_ROW_PRECOMPILING = new RegExp(REFERENCE_REGEX_SINGLE_ROW);
var REFERENCE_REGEX_SINGLE_COLUMN = `^${UNIT_NAME_SHEET_NAME_REGEX}\\s*?\\${ABSOLUTE_SYMBOL}?${COLUMN_REGEX}$`;
var REFERENCE_REGEX_SINGLE_COLUMN_PRECOMPILING = new RegExp(REFERENCE_REGEX_SINGLE_COLUMN);
var TABLE_NAME_REGEX = "((?![~!@#$%^&*()_+<>?:,./;\u2019\uFF0C\u3002\u3001\u2018\uFF1A\u201C\u300A\u300B\uFF1F~\uFF01@#\uFFE5%\u2026\u2026\uFF08\uFF09\u3010\u3011\\[\\]\\/\\\\]).)+";
var TABLE_TITLE_REGEX = "\\[#.+\\]\\s*?,\\s*?";
var TABLE_CONTENT_REGEX = "\\[((?<!#).)*\\]";
var TABLE_MULTIPLE_COLUMN_REGEX = `${TABLE_CONTENT_REGEX}${RANGE_SYMBOL}${TABLE_CONTENT_REGEX}`;
var REFERENCE_TABLE_ALL_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}$`;
var REFERENCE_TABLE_SINGLE_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}(${TABLE_CONTENT_REGEX}|\\[${TABLE_TITLE_REGEX}${TABLE_CONTENT_REGEX}\\])+$`;
var REFERENCE_TABLE_MULTIPLE_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}(\\[${TABLE_MULTIPLE_COLUMN_REGEX}\\])?$|^${TABLE_NAME_REGEX}(\\[${TABLE_TITLE_REGEX}${TABLE_MULTIPLE_COLUMN_REGEX}\\])?$`;
var SUPER_TABLE_COLUMN_REGEX = "[.*?]";
var SUPER_TABLE_COLUMN_REGEX_PRECOMPILING = new RegExp(SUPER_TABLE_COLUMN_REGEX, "g");
var ARRAY_VALUE_REGEX = "{.*?}";
var ARRAY_VALUE_REGEX_PRECOMPILING = new RegExp(ARRAY_VALUE_REGEX, "g");
function regexTestSingeRange(token) {
  REFERENCE_SINGLE_RANGE_REGEX_PRECOMPILING.lastIndex = 0;
  return REFERENCE_SINGLE_RANGE_REGEX_PRECOMPILING.test(token);
}
function regexTestMultipleRange(token) {
  REFERENCE_MULTIPLE_RANGE_REGEX_PRECOMPILING.lastIndex = 0;
  return REFERENCE_MULTIPLE_RANGE_REGEX_PRECOMPILING.test(token);
}
function regexTestRow(token) {
  REFERENCE_REGEX_ROW_PRECOMPILING.lastIndex = 0;
  return REFERENCE_REGEX_ROW_PRECOMPILING.test(token);
}
function regexTestColumn(token) {
  REFERENCE_REGEX_COLUMN_PRECOMPILING.lastIndex = 0;
  return REFERENCE_REGEX_COLUMN_PRECOMPILING.test(token);
}
function regexTestSingleRow(token) {
  REFERENCE_REGEX_SINGLE_ROW_PRECOMPILING.lastIndex = 0;
  return REFERENCE_REGEX_SINGLE_ROW_PRECOMPILING.test(token);
}
function regexTestSingleColumn(token) {
  REFERENCE_REGEX_SINGLE_COLUMN_PRECOMPILING.lastIndex = 0;
  return REFERENCE_REGEX_SINGLE_COLUMN_PRECOMPILING.test(token);
}
function regexTestArrayValue(token) {
  ARRAY_VALUE_REGEX_PRECOMPILING.lastIndex = 0;
  return ARRAY_VALUE_REGEX_PRECOMPILING.test(token);
}
function isReferenceString(refString) {
  return regexTestSingeRange(refString) || regexTestMultipleRange(refString) || regexTestRow(refString) || regexTestColumn(refString);
}

// ../packages/engine-formula/src/commands/mutations/register-function.mutation.ts
var RegisterFunctionMutation = {
  id: "formula.mutation.register-function",
  type: 2 /* MUTATION */,
  handler: () => true
};

// ../packages/engine-formula/src/commands/mutations/set-array-formula-data.mutation.ts
var SetArrayFormulaDataMutation = {
  id: "formula.mutation.set-array-formula-data",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    return true;
  }
};

// ../packages/engine-formula/src/services/defined-names.service.ts
var import_rxjs21 = __toESM(require_cjs());

// ../packages/engine-formula/src/engine/utils/reference.ts
var $ROW_REGEX = /[^0-9]/g;
var $COLUMN_REGEX = /[^A-Za-z]/g;
function getAbsoluteRefTypeWithSingleString(singleRefString) {
  let isColumnAbsolute = singleRefString[0] === "$";
  const remainChar = singleRefString.substring(1);
  let isRowAbsolute = remainChar.indexOf("$") > -1;
  if (Tools.isStringNumber(remainChar) && isColumnAbsolute && !isRowAbsolute) {
    isColumnAbsolute = false;
    isRowAbsolute = true;
  }
  if (isColumnAbsolute && isRowAbsolute) {
    return 3 /* ALL */;
  }
  if (isColumnAbsolute) {
    return 2 /* COLUMN */;
  }
  if (isRowAbsolute) {
    return 1 /* ROW */;
  }
  return 0 /* NONE */;
}
function _getAbsoluteToken(absoluteRefType = 0 /* NONE */) {
  let rowAbsoluteString = "";
  let columnAbsoluteString = "";
  if (absoluteRefType === 1 /* ROW */) {
    rowAbsoluteString = "$";
  } else if (absoluteRefType === 2 /* COLUMN */) {
    columnAbsoluteString = "$";
  } else if (absoluteRefType === 3 /* ALL */) {
    rowAbsoluteString = "$";
    columnAbsoluteString = "$";
  }
  return {
    rowAbsoluteString,
    columnAbsoluteString
  };
}
function serializeRange(range) {
  const {
    startColumn,
    startRow,
    endColumn,
    endRow,
    startAbsoluteRefType,
    endAbsoluteRefType,
    rangeType = 0 /* NORMAL */
  } = range;
  const start = _getAbsoluteToken(startAbsoluteRefType);
  const end = _getAbsoluteToken(endAbsoluteRefType);
  if (rangeType === 1 /* ROW */ || rangeType === 3 /* ALL */) {
    const startStr2 = `${start.rowAbsoluteString}${startRow + 1}`;
    const endStr2 = `${end.rowAbsoluteString}${endRow + 1}`;
    return `${startStr2}:${endStr2}`;
  }
  if (rangeType === 2 /* COLUMN */) {
    const startStr2 = `${start.columnAbsoluteString}${Tools.chatAtABC(startColumn)}`;
    const endStr2 = `${end.columnAbsoluteString}${Tools.chatAtABC(endColumn)}`;
    return `${startStr2}:${endStr2}`;
  }
  const startStr = `${start.columnAbsoluteString}${Tools.chatAtABC(startColumn)}${start.rowAbsoluteString}${startRow + 1}`;
  const endStr = `${end.columnAbsoluteString}${Tools.chatAtABC(endColumn)}${end.rowAbsoluteString}${endRow + 1}`;
  if (startStr === endStr) {
    return startStr;
  }
  return `${startStr}:${endStr}`;
}
function serializeRangeWithSheet(sheetName, range) {
  return `${addQuotesBothSides(sheetName)}!${serializeRange(range)}`;
}
function serializeRangeWithSpreadsheet(unit, sheetName, range) {
  if (needsQuoting(unit) || needsQuoting(sheetName)) {
    return `'[${quoteSheetName(unit)}]${quoteSheetName(sheetName)}'!${serializeRange(range)}`;
  }
  return `[${unit}]${sheetName}!${serializeRange(range)}`;
}
function serializeRangeToRefString(gridRangeName) {
  const { unitId, sheetName, range } = gridRangeName;
  if (unitId != null && unitId.length > 0 && sheetName != null && sheetName.length > 0) {
    return serializeRangeWithSpreadsheet(unitId, sheetName, range);
  }
  if (sheetName != null && sheetName.length > 0) {
    return serializeRangeWithSheet(sheetName, range);
  }
  return serializeRange(range);
}
function singleReferenceToGrid(refBody) {
  const row = Number.parseInt(refBody.replace($ROW_REGEX, "")) - 1;
  const column = Tools.ABCatNum(refBody.replace($COLUMN_REGEX, ""));
  const absoluteRefType = getAbsoluteRefTypeWithSingleString(refBody);
  return {
    row,
    column,
    absoluteRefType
  };
}
function handleRefStringInfo(refString) {
  const unitIdMatch = UNIT_NAME_REGEX_PRECOMPILING.exec(refString);
  let unitId = "";
  if (unitIdMatch != null) {
    unitId = unitIdMatch[0].trim();
    unitId = unquoteSheetName(unitId.slice(1, unitId.length - 1));
    refString = refString.replace(UNIT_NAME_REGEX_PRECOMPILING, "");
  }
  const sheetNameIndex = refString.indexOf("!");
  let sheetName = "";
  let refBody = "";
  if (sheetNameIndex > -1) {
    sheetName = refString.substring(0, sheetNameIndex);
    if (sheetName[0] === "'" && sheetName[sheetName.length - 1] === "'") {
      sheetName = sheetName.substring(1, sheetName.length - 1);
    }
    sheetName = unquoteSheetName(sheetName);
    refBody = refString.substring(sheetNameIndex + 1);
  } else {
    refBody = refString;
  }
  return {
    refBody,
    sheetName,
    unitId
  };
}
function deserializeRangeWithSheet(refString) {
  const { refBody, sheetName, unitId } = handleRefStringInfo(refString);
  const colonIndex = refBody.indexOf(":");
  if (colonIndex === -1) {
    const grid = singleReferenceToGrid(refBody);
    const row = grid.row;
    const column = grid.column;
    const absoluteRefType = grid.absoluteRefType;
    const range = {
      startRow: row,
      startColumn: column,
      endRow: row,
      endColumn: column,
      startAbsoluteRefType: absoluteRefType,
      endAbsoluteRefType: absoluteRefType
    };
    return {
      unitId,
      sheetName,
      range
    };
  }
  const refStartString = refBody.substring(0, colonIndex);
  const refEndString = refBody.substring(colonIndex + 1);
  const startGrid = singleReferenceToGrid(refStartString);
  const endGrid = singleReferenceToGrid(refEndString);
  const startRow = startGrid.row > endGrid.row ? endGrid.row : startGrid.row;
  const startColumn = startGrid.column > endGrid.column ? endGrid.column : startGrid.column;
  const endRow = startGrid.row > endGrid.row ? startGrid.row : endGrid.row;
  const endColumn = startGrid.column > endGrid.column ? startGrid.column : endGrid.column;
  let rangeType = 0 /* NORMAL */;
  if (Number.isNaN(startRow) && Number.isNaN(endRow)) {
    rangeType = 2 /* COLUMN */;
  } else if (Number.isNaN(startColumn) && Number.isNaN(endColumn)) {
    rangeType = 1 /* ROW */;
  }
  return {
    unitId,
    sheetName,
    range: {
      startRow,
      startColumn,
      endRow,
      endColumn,
      startAbsoluteRefType: startGrid.absoluteRefType,
      endAbsoluteRefType: endGrid.absoluteRefType,
      rangeType
    }
  };
}
var EXCEPTION_REF_STRINGS = ["LOG10"];
function isReferenceStringWithEffectiveColumn(refString) {
  const noPrefixRefString = replaceRefPrefixString(refString);
  if (!isReferenceString(noPrefixRefString)) {
    return false;
  }
  if (EXCEPTION_REF_STRINGS.includes(noPrefixRefString.toUpperCase().trim())) {
    return false;
  }
  const { range } = deserializeRangeWithSheet(noPrefixRefString);
  if (range.endColumn >= 16384) {
    return false;
  }
  return true;
}
function replaceRefPrefixString(token) {
  const tokenArray = [];
  let isNotPreFix = false;
  for (let i = 0, len = token.length; i < len; i++) {
    const char = token[i];
    if (char === SPACE_TOKEN && !isNotPreFix) {
      tokenArray.push(char);
    } else if (!isNotPreFix && (char === "@" /* AT */ || char === "-" /* MINUS */ || char === "+" /* PLUS */)) {
      continue;
    } else {
      tokenArray.push(char);
      isNotPreFix = true;
    }
  }
  return tokenArray.join("");
}
function needsQuoting(name) {
  if (name.length === 0) {
    return false;
  }
  if (includeFormulaLexerToken(name)) {
    return true;
  }
  if (isA1Notation(name) || isR1C1Notation(name)) {
    return true;
  }
  if (startsWithNonAlphabetic(name)) {
    return true;
  }
  if (/[\s!$%^&*()+\-=\[\]{};':"\\|,.<>\/?（）]/.test(name)) {
    return true;
  }
  return false;
}
function addQuotesBothSides(name) {
  return needsQuoting(name) ? `'${quoteSheetName(name)}'` : name;
}
function quoteSheetName(name) {
  return name.replace(/'/g, "''");
}
function unquoteSheetName(name) {
  return name.replace(/''/g, "'");
}
function isA1Notation(name) {
  const match = name.match(/[1-9][0-9]{0,6}/);
  return /^[A-Z]+[1-9][0-9]{0,6}$/.test(name) && match !== null;
}
function isR1C1Notation(name) {
  return /^(R(-?[0-9]+)?C(-?[0-9]+)?|C(-?[0-9]+)?|R(-?[0-9]+)?)$/.test(name);
}
function startsWithNonAlphabetic(name) {
  return !new RegExp("^\\p{Letter}", "u").test(name.charAt(0));
}

// ../packages/engine-formula/src/services/defined-names.service.ts
var DefinedNamesService = class extends Disposable {
  constructor(_univerInstanceService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    // 18.2.6 definedNames (Defined Names)
    __publicField(this, "_definedNameMap", {});
    __publicField(this, "_nameCacheMap", {});
    // Cache for name-to-definition mapping
    __publicField(this, "_update$", new import_rxjs21.Subject());
    __publicField(this, "update$", this._update$.asObservable());
    __publicField(this, "_currentRange", {
      unitId: "",
      sheetId: "",
      range: {
        startRow: 0,
        endRow: 0,
        startColumn: 0,
        endColumn: 0
      }
    });
    __publicField(this, "_currentRange$", new import_rxjs21.Subject());
    __publicField(this, "currentRange$", this._currentRange$.asObservable());
    __publicField(this, "_focusRange$", new import_rxjs21.Subject());
    __publicField(this, "focusRange$", this._focusRange$.asObservable());
  }
  dispose() {
    super.dispose();
    this._definedNameMap = {};
    this._nameCacheMap = {};
    this._update$.complete();
    this._currentRange$.complete();
    this._focusRange$.complete();
  }
  getWorksheetByRef(unitId, ref) {
    var _a2;
    const { sheetName } = handleRefStringInfo(ref);
    return (_a2 = this._univerInstanceService.getUnit(unitId)) == null ? void 0 : _a2.getSheetBySheetName(sheetName);
  }
  focusRange(unitId, id) {
    const item = this.getValueById(unitId, id);
    if (item === void 0) {
      return;
    }
    this._focusRange$.next({ ...item, unitId });
  }
  setCurrentRange(range) {
    this._currentRange = range;
    this._currentRange$.next(range);
  }
  getCurrentRange() {
    return this._currentRange;
  }
  getCurrentRangeForString() {
    return serializeRange(this._currentRange.range);
  }
  registerDefinedNames(unitId, params) {
    this._definedNameMap[unitId] = params;
    this._updateCache(unitId);
    this._update();
  }
  registerDefinedName(unitId, param) {
    const unitMap = this._definedNameMap[unitId];
    if (unitMap === void 0) {
      this._definedNameMap[unitId] = {};
    }
    this._definedNameMap[unitId][param.id] = param;
    this._updateCache(unitId);
    this._update();
  }
  removeDefinedName(unitId, id) {
    var _a2;
    (_a2 = this._definedNameMap[unitId]) == null ? true : delete _a2[id];
    this._updateCache(unitId);
    this._update();
  }
  removeUnitDefinedName(unitId) {
    delete this._definedNameMap[unitId];
    this._updateCache(unitId);
    this._update();
  }
  getDefinedNameMap(unitId) {
    return this._definedNameMap[unitId];
  }
  getValueByName(unitId, name) {
    const cachedMap = this._nameCacheMap[unitId];
    if (cachedMap) {
      return cachedMap[name] || null;
    }
    const nameMap2 = this._definedNameMap[unitId];
    if (nameMap2 === void 0) {
      return null;
    }
    let result = null;
    for (const item of Object.values(nameMap2)) {
      if (item.name === name) {
        result = item;
        break;
      }
    }
    if (result) {
      this._nameCacheMap[unitId] = this._nameCacheMap[unitId] || {};
      this._nameCacheMap[unitId][name] = result;
    }
    return result;
  }
  getValueById(unitId, id) {
    var _a2;
    return (_a2 = this._definedNameMap[unitId]) == null ? void 0 : _a2[id];
  }
  hasDefinedName(unitId) {
    if (this._definedNameMap[unitId] === void 0) {
      return false;
    }
    const size = Array.from(Object.values(this._definedNameMap[unitId])).length || 0;
    return size !== 0;
  }
  _update() {
    this._update$.next(null);
  }
  _updateCache(unitId) {
    const nameMap2 = this._definedNameMap[unitId];
    if (nameMap2 === void 0) {
      delete this._nameCacheMap[unitId];
      return;
    }
    this._nameCacheMap[unitId] = {};
    for (const item of Object.values(nameMap2)) {
      this._nameCacheMap[unitId][item.name] = item;
    }
  }
};
DefinedNamesService = __decorateClass([
  __decorateParam(0, IUniverInstanceService)
], DefinedNamesService);
var IDefinedNamesService = createIdentifier("univer.formula.defined-names.service");

// ../packages/engine-formula/src/commands/mutations/set-defined-name.mutation.ts
var SetDefinedNameMutationFactory = (accessor, params) => {
  const { unitId, id } = params;
  const definedNamesService = accessor.get(IDefinedNamesService);
  const definedName = definedNamesService.getValueById(unitId, id);
  return {
    ...definedName,
    unitId
  };
};
var SetDefinedNameMutation = {
  id: "formula.mutation.set-defined-name",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    if (params == null) {
      return false;
    }
    const definedNamesService = accessor.get(IDefinedNamesService);
    const { id, unitId, name, formulaOrRefString, comment, hidden, localSheetId } = params;
    definedNamesService.registerDefinedName(unitId, {
      id,
      name: name.trim(),
      formulaOrRefString: formulaOrRefString.trim(),
      comment: comment == null ? void 0 : comment.trim(),
      hidden,
      localSheetId
    });
    return true;
  }
};
var RemoveDefinedNameMutation = {
  id: "formula.mutation.remove-defined-name",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    if (params == null) {
      return false;
    }
    const definedNamesService = accessor.get(IDefinedNamesService);
    const { unitId, id } = params;
    definedNamesService.removeDefinedName(unitId, id);
    return true;
  }
};

// ../packages/engine-formula/src/commands/mutations/set-feature-calculation.mutation.ts
var SetFeatureCalculationMutation = {
  id: "formula.mutation.set-feature-calculation",
  type: 2 /* MUTATION */,
  handler: () => true
};
var RemoveFeatureCalculationMutation = {
  id: "formula.mutation.remove-feature-calculation",
  type: 2 /* MUTATION */,
  handler: () => true
};

// ../packages/engine-formula/src/commands/mutations/set-formula-calculation.mutation.ts
var SetFormulaCalculationStartMutation = {
  id: "formula.mutation.set-formula-calculation-start",
  type: 2 /* MUTATION */,
  handler: () => true
};
var SetFormulaCalculationStopMutation = {
  id: "formula.mutation.set-formula-calculation-stop",
  type: 2 /* MUTATION */,
  handler: () => true
};
var SetFormulaCalculationNotificationMutation = {
  id: "formula.mutation.set-formula-calculation-notification",
  type: 2 /* MUTATION */,
  handler: () => true
};
var SetFormulaCalculationResultMutation = {
  id: "formula.mutation.set-formula-calculation-result",
  type: 2 /* MUTATION */,
  handler: () => true
};

// ../packages/engine-formula/src/commands/mutations/set-formula-data.mutation.ts
var SetFormulaDataMutation = {
  id: "formula.mutation.set-formula-data",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    return true;
  }
};

// ../packages/engine-formula/src/commands/mutations/set-other-formula.mutation.ts
var SetOtherFormulaMutation = {
  id: "formula.mutation.set-other-formula",
  type: 2 /* MUTATION */,
  handler: () => true
};
var RemoveOtherFormulaMutation = {
  id: "formula.mutation.remove-other-formula",
  type: 2 /* MUTATION */,
  handler: () => true
};

// ../packages/engine-formula/src/commands/mutations/set-super-table.mutation.ts
var SetSuperTableMutation = {
  id: "formula.mutation.set-super-table",
  type: 2 /* MUTATION */,
  handler: () => true
};
var RemoveSuperTableMutation = {
  id: "formula.mutation.remove-super-table",
  type: 2 /* MUTATION */,
  handler: () => true
};
var SetSuperTableOptionMutation = {
  id: "formula.mutation.set-super-table-option",
  type: 2 /* MUTATION */,
  handler: () => true
};

// ../packages/engine-formula/src/basics/cache-lru.ts
var FormulaAstLRU = class {
  constructor(cacheCount) {
    __publicField(this, "_cache");
    this._cache = new LRUMap(cacheCount);
  }
  set(formulaString, node) {
    const hash = this._hash(formulaString);
    this._cache.set(hash, node);
  }
  get(formulaString) {
    const hash = this._hash(formulaString);
    return this._cache.get(hash);
  }
  clear() {
    this._cache.clear();
  }
  delete(formulaString) {
    this._cache.delete(this._hash(formulaString));
  }
  forEach(callbackfn, thisArg) {
    this._cache.forEach(callbackfn, thisArg);
  }
  _hash(formulaString) {
    if (formulaString.length <= 64) {
      return formulaString;
    }
    return hashAlgorithm(formulaString).toString();
  }
};

// ../packages/engine-formula/src/basics/token-type.ts
var DEFAULT_TOKEN_TYPE_PARAMETER = "P_1";
var DEFAULT_TOKEN_TYPE_ROOT = "R_1";
var DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER = "L_1";
var DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER = "LR_1";
var DEFAULT_TOKEN_TYPE_LAMBDA_OMIT_PARAMETER = "LO_1";
var DEFAULT_TOKEN_LET_FUNCTION_NAME = "LET";
var DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME = "LAMBDA";
var DEFAULT_TOKEN_CUBE_FUNCTION_NAME = "CUBE";
var FORCED_RECALCULATION_FUNCTION_NAME = /* @__PURE__ */ new Set(["RAND", "RANDBETWEEN", "NOW", "TODAY"]);

// ../packages/engine-formula/src/engine/utils/reference-cache.ts
var referenceToRangeCache = new FormulaAstLRU(1e5);
function deserializeRangeWithSheetWithCache(refString) {
  const refCache = referenceToRangeCache.get(refString);
  if (refCache) {
    return refCache;
  }
  const result = deserializeRangeWithSheet(refString);
  referenceToRangeCache.set(refString, result);
  return deserializeRangeWithSheet(refString);
  ;
}
function clearReferenceToRangeCache() {
  referenceToRangeCache.clear();
}

// ../packages/engine-formula/src/engine/utils/sequence.ts
function generateStringWithSequence(newSequenceNodes) {
  let sequenceString = "";
  for (const node of newSequenceNodes) {
    if (typeof node === "string") {
      sequenceString += node;
    } else {
      sequenceString += node.token;
    }
  }
  return sequenceString;
}

// ../packages/engine-formula/src/engine/analysis/lexer-node.ts
var LexerNode = class _LexerNode {
  constructor() {
    __publicField(this, "_parent");
    __publicField(this, "_token", DEFAULT_TOKEN_TYPE_ROOT);
    __publicField(this, "_children", []);
    __publicField(this, "_lambdaId");
    __publicField(this, "_functionDefinitionPrivacyVar");
    __publicField(this, "_lambdaParameter", "");
    __publicField(this, "_startIndex", -1);
    __publicField(this, "_endIndex", -1);
    __publicField(this, "_definedNames", []);
  }
  dispose() {
    var _a2;
    this._children.forEach((node) => {
      if (!(typeof node === "string")) {
        node.dispose();
      }
    });
    (_a2 = this._functionDefinitionPrivacyVar) == null ? void 0 : _a2.clear();
    this._functionDefinitionPrivacyVar = null;
    this._children = [];
    this._parent = null;
    this._definedNames = [];
  }
  getDefinedNames() {
    return this._definedNames;
  }
  getStartIndex() {
    return this._startIndex;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  setLambdaId(lambdaId) {
    this._lambdaId = lambdaId;
  }
  getFunctionDefinitionPrivacyVar() {
    return this._functionDefinitionPrivacyVar;
  }
  setLambdaPrivacyVar(lambdaPrivacyVar) {
    this._functionDefinitionPrivacyVar = lambdaPrivacyVar;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  setLambdaParameter(lambdaParameter) {
    this._lambdaParameter = lambdaParameter;
  }
  getParent() {
    return this._parent;
  }
  setParent(lexerNode) {
    this._parent = lexerNode;
  }
  getChildren() {
    return this._children;
  }
  setChildren(children) {
    this._children = children;
  }
  addChildren(children) {
    this._children.push(children);
  }
  addChildrenFirst(children) {
    this._children.unshift(children);
  }
  getToken() {
    return this._token;
  }
  setToken(token) {
    this._token = token;
  }
  setIndex(st, ed) {
    this._startIndex = st;
    this._endIndex = ed;
  }
  setDefinedNames(definedNames) {
    this._definedNames = definedNames;
  }
  hasDefinedNames() {
    return this._definedNames.length > 0;
  }
  replaceChild(lexerNode, newLexerNode) {
    const i = this._getIndexInParent(lexerNode);
    if (i == null) {
      return;
    }
    this.getChildren().splice(i, 1, newLexerNode);
    newLexerNode.setParent(this);
  }
  changeToParent(newParentLexerNode) {
    const parentNode = this.getParent();
    if (parentNode) {
      parentNode.removeChild(this);
    }
    this.setParent(newParentLexerNode);
    const childrenNode = newParentLexerNode.getChildren();
    childrenNode.push(this);
  }
  removeChild(lexerNode) {
    const i = this._getIndexInParent(lexerNode);
    if (i == null) {
      return;
    }
    this.getChildren().splice(i, 1);
  }
  serialize() {
    const token = this.getToken();
    const children = this.getChildren();
    const childrenSerialization = [];
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      if (item instanceof _LexerNode) {
        childrenSerialization.push(item.serialize());
      } else {
        childrenSerialization.push(item);
      }
    }
    return {
      token,
      st: this._startIndex,
      ed: this._endIndex,
      children: childrenSerialization
    };
  }
  _getIndexInParent(lexerNode) {
    const childrenNode = this.getChildren();
    const childrenCount = childrenNode.length;
    for (let i = 0; i < childrenCount; i++) {
      const child = childrenNode[i];
      if (child === lexerNode) {
        return i;
      }
    }
  }
};

// ../packages/engine-formula/src/engine/analysis/lexer-tree-builder.ts
var FORMULA_CACHE_LRU_COUNT = 2e3;
var FormulaLexerNodeCache = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT);
var FormulaSequenceNodeCache = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT);
var LexerTreeBuilder = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_currentLexerNode", new LexerNode());
    __publicField(this, "_upLevel", 0);
    __publicField(this, "_segment", "");
    __publicField(this, "_bracketState", []);
    // ()
    __publicField(this, "_squareBracketState", 0);
    __publicField(this, "_bracesState", 0);
    // {}
    __publicField(this, "_singleQuotationState", 0);
    // ''
    __publicField(this, "_doubleQuotationState", 0);
    // ""
    __publicField(this, "_lambdaState", false);
    // Lambda
    __publicField(this, "_colonState", false);
    // :
    __publicField(this, "_formulaErrorCount", 0);
    __publicField(this, "_tableBracketState", false);
  }
  // Table3[[#All],[Column1]:[Column2]]
  dispose() {
    this._resetTemp();
    this._currentLexerNode.dispose();
    FormulaLexerNodeCache.clear();
    FormulaSequenceNodeCache.clear();
  }
  getUpLevel() {
    return this._upLevel;
  }
  isColonClose() {
    return this._colonState === false;
  }
  isColonOpen() {
    return this._colonState === true;
  }
  isDoubleQuotationClose() {
    return this._doubleQuotationState === 0;
  }
  isLambdaOpen() {
    return this._lambdaState === true;
  }
  isLambdaClose() {
    return this._lambdaState === false;
  }
  isSingleQuotationClose() {
    return this._singleQuotationState === 0;
  }
  isBracesClose() {
    return this._bracesState === 0;
  }
  isBracketClose() {
    return this._bracketState.length === 0;
  }
  isSquareBracketClose() {
    return this._squareBracketState === 0;
  }
  getCurrentLexerNode() {
    return this._currentLexerNode;
  }
  getFunctionAndParameter(formulaString, strIndex) {
    const current = this._getCurrentParamIndex(formulaString, strIndex);
    if (current == null || current === "#VALUE!" /* VALUE */) {
      return;
    }
    const lexerNode = current[0];
    if (typeof lexerNode === "string") {
      return;
    }
    let parent = lexerNode.getParent();
    let children = lexerNode;
    while (parent) {
      const token = parent.getToken();
      if (token !== DEFAULT_TOKEN_TYPE_PARAMETER && !isFormulaLexerToken(token) && parent.getStartIndex() !== -1) {
        const paramIndex = parent.getChildren().indexOf(children);
        return {
          functionName: token,
          paramIndex
        };
      }
      children = parent;
      parent = parent.getParent();
    }
  }
  /**
   * Estimate the number of right brackets that need to be automatically added to the end of the formula.
   * @param formulaString
   */
  checkIfAddBracket(formulaString) {
    let lastBracketCount = 0;
    let lastIndex = formulaString.length - 1;
    let lastString = formulaString[lastIndex];
    while ((lastString === ")" /* CLOSE_BRACKET */ || lastString === " ") && lastIndex >= 0) {
      if (lastString === ")" /* CLOSE_BRACKET */) {
        lastBracketCount++;
      }
      lastString = formulaString[--lastIndex];
    }
    const current = this._getCurrentParamIndex(formulaString, formulaString.length - 2);
    if (current == null || current === "#VALUE!" /* VALUE */) {
      return 0;
    }
    const lexerNode = current[0];
    if (typeof lexerNode === "string") {
      return 0;
    }
    let parent = lexerNode.getParent();
    let bracketCount = 0;
    if (current[1] === "(" /* OPEN_BRACKET */) {
      bracketCount++;
    }
    while (parent) {
      const token = parent.getToken();
      if (token !== DEFAULT_TOKEN_TYPE_PARAMETER && token !== ":" /* COLON */ && parent.getStartIndex() !== -1 && token.toUpperCase() !== DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME) {
        if (lastBracketCount === 0) {
          bracketCount += 1;
        } else {
          lastBracketCount--;
        }
      }
      parent = parent.getParent();
    }
    return bracketCount;
  }
  sequenceNodesBuilder(formulaString) {
    const sequenceNodesCache = FormulaSequenceNodeCache.get(formulaString);
    if (sequenceNodesCache) {
      return [...sequenceNodesCache];
    }
    const sequenceArray = this._getSequenceArray(formulaString);
    if (sequenceArray.length === 0) {
      return;
    }
    const newSequenceNodes = this.getSequenceNode(sequenceArray);
    FormulaSequenceNodeCache.set(formulaString, [...newSequenceNodes]);
    return newSequenceNodes;
  }
  convertRefersToAbsolute(formulaString, startAbsoluteRefType, endAbsoluteRefType, currentSheetName = "") {
    const nodes = this.sequenceNodesBuilder(formulaString);
    if (nodes == null) {
      return formulaString;
    }
    let prefixToken2 = "";
    if (formulaString.substring(0, 1) === "=" /* EQUALS */) {
      prefixToken2 = "=" /* EQUALS */;
    }
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      if (typeof node === "string") {
        continue;
      }
      if (node.nodeType === 4 /* REFERENCE */) {
        const { token, endIndex } = node;
        const sequenceGrid = deserializeRangeWithSheetWithCache(token);
        if (sequenceGrid == null) {
          continue;
        }
        const { range, sheetName, unitId } = sequenceGrid;
        const newRange = {
          ...range,
          startAbsoluteRefType,
          endAbsoluteRefType
        };
        const newToken = serializeRangeToRefString({
          range: newRange,
          unitId,
          sheetName: sheetName || currentSheetName
        });
        const minusCount = newToken.length - token.length;
        nodes[i] = {
          ...node,
          token: newToken,
          endIndex: endIndex + minusCount
        };
        for (let j = i + 1; j < len; j++) {
          const nextNode = nodes[j];
          if (typeof nextNode === "string") {
            continue;
          }
          nextNode.startIndex += minusCount;
          nextNode.endIndex += minusCount;
        }
      }
    }
    return `${prefixToken2}${generateStringWithSequence(nodes)}`;
  }
  moveFormulaRefOffset(formulaString, refOffsetX, refOffsetY, ignoreAbsolute = false) {
    const sequenceNodes = this.sequenceNodesBuilder(formulaString);
    if (sequenceNodes == null) {
      return formulaString;
    }
    const newSequenceNodes = [];
    for (let i = 0, len = sequenceNodes.length; i < len; i++) {
      const node = sequenceNodes[i];
      if (typeof node === "string" || node.nodeType !== 4 /* REFERENCE */) {
        newSequenceNodes.push(node);
        continue;
      }
      const { token } = node;
      const sequenceGrid = deserializeRangeWithSheetWithCache(token);
      const { sheetName, unitId: sequenceUnitId } = sequenceGrid;
      let newRange = sequenceGrid.range;
      if (!ignoreAbsolute && newRange.startAbsoluteRefType === 3 /* ALL */ && newRange.endAbsoluteRefType === 3 /* ALL */) {
        newSequenceNodes.push(node);
        continue;
      } else {
        newRange = moveRangeByOffset(newRange, refOffsetX, refOffsetY, ignoreAbsolute);
      }
      let newToken = "";
      if (isValidRange(newRange)) {
        newToken = serializeRangeToRefString({
          range: newRange,
          unitId: sequenceUnitId,
          sheetName
        });
      } else {
        newToken = "#REF!" /* REF */;
      }
      newSequenceNodes.push({
        ...node,
        token: newToken
      });
    }
    return `=${generateStringWithSequence(newSequenceNodes)}`;
  }
  /**
   * univer-pro/issues/1684
   * =sum({}{})
   */
  _formulaSpellCheck() {
    if (this._currentLexerNode.getChildren().length === 0) {
      return true;
    }
    const node = this._currentLexerNode.getChildren()[0];
    if (node instanceof LexerNode) {
      return true;
    }
    if (OPERATOR_TOKEN_SET.has(node) || SUFFIX_TOKEN_SET.has(node) || node === "@" /* AT */ || node === "," /* COMMA */ || node === ":" /* COLON */ || node === "(" /* OPEN_BRACKET */) {
      return true;
    }
    return false;
  }
  // eslint-disable-next-line complexity
  getSequenceNode(sequenceArray) {
    const sequenceNodes = [];
    let maybeString = false;
    for (let i = 0, len = sequenceArray.length; i < len; i++) {
      const item = sequenceArray[i];
      const preItem = sequenceArray[i - 1];
      const { segment, currentString } = item;
      if (currentString === '"' /* DOUBLE_QUOTATION */) {
        maybeString = true;
      }
      if ((segment !== "" || i === 0) && i !== len - 1) {
        sequenceNodes.push(currentString);
        continue;
      }
      let preSegment = (preItem == null ? void 0 : preItem.segment) || "";
      const startIndex = i - preSegment.length;
      let endIndex = i - 1;
      const deleteEndIndex = i - 1;
      if (i === len - 1 && this._isLastMergeString(currentString)) {
        preSegment += currentString;
        endIndex += 1;
      }
      if (preSegment === "" || OPERATOR_TOKEN_PRIORITY.has(preSegment)) {
        sequenceNodes.push(currentString);
        continue;
      }
      const preSegmentTrim = preSegment.trim();
      const preSegmentNotPrefixToken = replaceRefPrefixString(preSegmentTrim);
      if (maybeString === true && preSegmentTrim[preSegmentTrim.length - 1] === '"' /* DOUBLE_QUOTATION */ && preSegmentTrim[0] !== "{" /* OPEN_BRACES */) {
        maybeString = false;
        this._processPushSequenceNode(sequenceNodes, 2 /* STRING */, preSegment, startIndex, endIndex, deleteEndIndex);
      } else if (regexTestSingeRange(preSegmentNotPrefixToken) && isReferenceStringWithEffectiveColumn(preSegmentNotPrefixToken)) {
        this._processPushSequenceNode(sequenceNodes, 4 /* REFERENCE */, preSegment, startIndex, endIndex, deleteEndIndex);
      } else if (Tools.isStringNumber(preSegmentTrim)) {
        this._processPushSequenceNode(sequenceNodes, 1 /* NUMBER */, preSegment, startIndex, endIndex, deleteEndIndex);
      } else if (preSegmentTrim.length > 0) {
        this._processPushSequenceNode(sequenceNodes, 3 /* FUNCTION */, preSegment, startIndex, endIndex, deleteEndIndex);
      }
      if (i !== len - 1 || !this._isLastMergeString(currentString)) {
        sequenceNodes.push(currentString);
      }
    }
    return this._mergeSequenceNodeReference(sequenceNodes);
  }
  _processPushSequenceNode(sequenceNodes, nodeType, token, startIndex, endIndex, deleteEndIndex) {
    this._pushSequenceNode(
      sequenceNodes,
      {
        nodeType,
        token,
        startIndex,
        endIndex
      },
      deleteEndIndex
    );
  }
  _getCurrentParamIndex(formulaString, index) {
    return this._nodeMaker(formulaString, void 0, index);
  }
  _isLastMergeString(str) {
    return str === '"' /* DOUBLE_QUOTATION */ || Tools.isStringNumber(str) || !isFormulaLexerToken(str);
  }
  /**
   * Merge array and handle ref operations
   *
   */
  _mergeSequenceNodeReference(sequenceNodes) {
    const newSequenceNodes = [];
    const sequenceNodesCount = sequenceNodes.length;
    let i = 0;
    while (i < sequenceNodesCount) {
      const node = sequenceNodes[i];
      if (typeof node === "string") {
        const preNode = sequenceNodes[i - 1];
        if (node.trim() === "}" /* CLOSE_BRACES */ && preNode != null && typeof preNode !== "string" && preNode.nodeType === 3 /* FUNCTION */) {
          const firstChar = preNode.token.trim().substring(0, 1);
          if (firstChar === "{" /* OPEN_BRACES */) {
            preNode.nodeType = 5 /* ARRAY */;
            preNode.token += node;
            preNode.endIndex += node.length;
            i++;
            continue;
          }
        }
        newSequenceNodes.push(node);
      } else {
        const nextOneNode = sequenceNodes[i + 1];
        const nextTwoNode = sequenceNodes[i + 2];
        if (nextOneNode === ":" /* COLON */ && typeof node !== "string" && nextTwoNode != null && typeof nextTwoNode !== "string" && isReferenceStringWithEffectiveColumn((node.token + nextOneNode + nextTwoNode.token).trim())) {
          node.nodeType = 4 /* REFERENCE */;
          node.token += nextOneNode + nextTwoNode.token;
          node.endIndex = nextTwoNode.endIndex;
          i += 2;
        }
        newSequenceNodes.push(node);
      }
      i++;
    }
    return this._minusSplitSequenceNode(newSequenceNodes);
  }
  /**
   * =-A1  Separate the negative sign from the ref string.
   */
  _minusSplitSequenceNode(sequenceNodes) {
    const finalSequenceNodes = [];
    for (const node of sequenceNodes) {
      if (typeof node !== "string") {
        const token = node.token;
        const match = token.match(/^(\s*([-@+]\s*)+)(.*)$/);
        if (match) {
          const operatorPart = match[1];
          const referencePart = match[3];
          if (isReferenceStringWithEffectiveColumn(referencePart.trim())) {
            const operatorLength = operatorPart.length;
            const operatorStart = node.startIndex;
            const operatorEnd = node.startIndex + operatorLength - 1;
            const operatorNode = {
              nodeType: 0 /* NORMAL */,
              // Use appropriate nodeType for operators
              token: operatorPart,
              startIndex: operatorStart,
              endIndex: operatorEnd
            };
            const refNode = {
              nodeType: 4 /* REFERENCE */,
              token: referencePart,
              startIndex: operatorEnd + 1,
              endIndex: node.endIndex
            };
            finalSequenceNodes.push(operatorNode);
            finalSequenceNodes.push(refNode);
            continue;
          }
        }
      }
      finalSequenceNodes.push(node);
    }
    return finalSequenceNodes;
  }
  _pushSequenceNode(sequenceNodes, node, deleteEndIndex) {
    const segmentCount = deleteEndIndex - node.startIndex + 1;
    sequenceNodes.splice(sequenceNodes.length - segmentCount, segmentCount, node);
  }
  nodeMakerTest(formulaString) {
    return this._nodeMaker(formulaString);
  }
  treeBuilder(formulaString, transformSuffix = true, injectDefinedName, simpleCheckDefinedName) {
    if (transformSuffix === true) {
      const lexerNode = FormulaLexerNodeCache.get(formulaString);
      const simpleCheckDefinedNameResult = simpleCheckDefinedName == null ? void 0 : simpleCheckDefinedName(formulaString);
      if (lexerNode && !simpleCheckDefinedNameResult) {
        return lexerNode;
      }
    }
    this._resetCurrentLexerNode();
    this._currentLexerNode.setToken(DEFAULT_TOKEN_TYPE_ROOT);
    const sequenceArray = [];
    let state = this._nodeMaker(formulaString, sequenceArray);
    if (state === "#VALUE!" /* VALUE */ || sequenceArray.length === 0) {
      return state;
    }
    let currentHasDefinedName = false;
    let currentSequenceString = "";
    let currentDefinedNames = [];
    if (injectDefinedName) {
      const { hasDefinedName, sequenceString, definedNames } = injectDefinedName(sequenceArray);
      currentHasDefinedName = hasDefinedName;
      currentSequenceString = sequenceString;
      currentDefinedNames = definedNames;
    }
    if (currentHasDefinedName) {
      this._resetCurrentLexerNode();
      this._currentLexerNode.setToken(DEFAULT_TOKEN_TYPE_ROOT);
      state = this._nodeMaker(`=${currentSequenceString}`);
      if (state === "#VALUE!" /* VALUE */) {
        return state;
      }
    }
    const node = this._getTopNode(this._currentLexerNode);
    if (node) {
      this._currentLexerNode = node;
    }
    if (transformSuffix) {
      const isValid = this._suffixExpressionHandler(this._currentLexerNode);
      if (!isValid) {
        return "#VALUE!" /* VALUE */;
      }
      FormulaLexerNodeCache.set(formulaString, this._currentLexerNode);
    }
    if (currentHasDefinedName) {
      this._currentLexerNode.setDefinedNames(currentDefinedNames);
    }
    return this._currentLexerNode;
  }
  // eslint-disable-next-line complexity
  _suffixExpressionHandler(lexerNode) {
    var _a2;
    const children = lexerNode.getChildren();
    if (!children) {
      return false;
    }
    const childrenCount = children.length;
    const baseStack = [];
    const symbolStack = [];
    let isChildValid = true;
    for (let i = 0; i < childrenCount; i++) {
      const node = children[i];
      if (!(node instanceof LexerNode)) {
        const char = node.trim();
        if (char === "") {
          continue;
        }
        if (OPERATOR_TOKEN_SET.has(char)) {
          if (char === "+" /* PLUS */ && this._deletePlusForPreNode(children[i - 1])) {
            continue;
          }
          if (char !== "+" /* PLUS */ && char !== "-" /* MINUS */ && this._deletePlusForPreNode(children[i - 1])) {
            return false;
          }
          while (symbolStack.length > 0) {
            const lastSymbol = (_a2 = symbolStack[symbolStack.length - 1]) == null ? void 0 : _a2.trim();
            if (!lastSymbol || lastSymbol === "(" /* OPEN_BRACKET */) {
              break;
            }
            const lastSymbolPriority = OPERATOR_TOKEN_PRIORITY.get(lastSymbol);
            const charPriority = OPERATOR_TOKEN_PRIORITY.get(char);
            if (!lastSymbolPriority || !charPriority) {
              break;
            }
            if (charPriority >= lastSymbolPriority) {
              baseStack.push(symbolStack.pop());
            } else {
              break;
            }
          }
          symbolStack.push(node);
        } else if (char === "(" /* OPEN_BRACKET */) {
          symbolStack.push(node);
        } else if (char === ")" /* CLOSE_BRACKET */) {
          this._processSuffixExpressionCloseBracket(baseStack, symbolStack, children, i);
        } else {
          if (this._checkCloseBracket(children[i - 1])) {
            return false;
          }
          baseStack.push(node);
        }
      } else {
        isChildValid = this._suffixExpressionHandler(node);
        baseStack.push(node);
      }
    }
    if (!isChildValid) {
      return false;
    }
    return this._processSuffixExpressionRemain(baseStack, symbolStack, lexerNode);
  }
  _processSuffixExpressionRemain(baseStack, symbolStack, lexerNode) {
    const baseStackLength = baseStack.length;
    const lastBaseStack = baseStack[baseStackLength - 1];
    while (symbolStack.length > 0) {
      const symbol = symbolStack.pop();
      if (!(lastBaseStack instanceof LexerNode) && (symbol === "(" /* OPEN_BRACKET */ || symbol === ")" /* CLOSE_BRACKET */)) {
        return false;
      }
      baseStack.push(symbol);
    }
    lexerNode.setChildren(baseStack);
    return true;
  }
  _processSuffixExpressionCloseBracket(baseStack, symbolStack, children, i) {
    var _a2;
    if (this._checkOpenBracket(children[i - 1])) {
      return false;
    }
    if (this._checkOperator(children[i - 1])) {
      return false;
    }
    while (symbolStack.length > 0) {
      const lastSymbol = (_a2 = symbolStack[symbolStack.length - 1]) == null ? void 0 : _a2.trim();
      if (!lastSymbol) {
        break;
      }
      if (lastSymbol === "(" /* OPEN_BRACKET */) {
        symbolStack.pop();
        break;
      }
      baseStack.push(symbolStack.pop());
    }
  }
  _checkCloseBracket(node) {
    return node === ")" /* CLOSE_BRACKET */ || node instanceof LexerNode;
  }
  _checkOpenBracket(node) {
    return node === "(" /* OPEN_BRACKET */;
  }
  _checkOperator(node) {
    if (node == null) {
      return false;
    }
    if (node instanceof LexerNode) {
      return false;
    }
    return OPERATOR_TOKEN_SET.has(node);
  }
  _deletePlusForPreNode(preNode) {
    if (preNode == null) {
      return true;
    }
    if (!(preNode instanceof LexerNode)) {
      const preChar = preNode.trim();
      if (OPERATOR_TOKEN_SET.has(preChar) || preChar === "(" /* OPEN_BRACKET */) {
        return true;
      }
    }
    return false;
  }
  _resetCurrentLexerNode() {
    this._currentLexerNode = new LexerNode();
  }
  _resetSegment() {
    this._segment = "";
  }
  _openBracket(type2 = 0 /* NORMAL */) {
    this._bracketState.push(type2);
  }
  _closeBracket() {
    this._bracketState.pop();
  }
  _openSquareBracket() {
    this._squareBracketState += 1;
  }
  _closeSquareBracket() {
    this._squareBracketState -= 1;
  }
  _getCurrentBracket() {
    const bracketState = this._bracketState;
    return bracketState[bracketState.length - 1];
  }
  _changeCurrentBracket(type2) {
    const bracketState = this._bracketState;
    bracketState[bracketState.length - 1] = type2;
  }
  _openBraces() {
    this._bracesState += 1;
  }
  _closeBraces() {
    this._bracesState -= 1;
  }
  _openSingleQuotation() {
    this._singleQuotationState += 1;
  }
  _closeSingleQuotation() {
    this._singleQuotationState -= 1;
  }
  _openDoubleQuotation() {
    this._doubleQuotationState += 1;
  }
  _closeDoubleQuotation() {
    this._doubleQuotationState -= 1;
  }
  _openLambda() {
    this._lambdaState = true;
  }
  _closeLambda() {
    this._lambdaState = false;
  }
  _openColon(upLevel) {
    this._upLevel = upLevel;
    this._colonState = true;
  }
  _closeColon() {
    this._upLevel = 0;
    this._colonState = false;
  }
  _isTableBracket() {
    return this._tableBracketState;
  }
  _openTableBracket() {
    this._tableBracketState = true;
  }
  _closeTableBracket() {
    this._tableBracketState = false;
  }
  _formalErrorOccurred() {
    this._formulaErrorCount += 1;
  }
  _hasFormalError() {
    return this._formulaErrorCount > 0;
  }
  _getLastChildCurrentLexerNode() {
    const children = this._currentLexerNode.getChildren();
    if (children && children.length > 0) {
      const lastNode = children[children.length - 1];
      if (lastNode instanceof LexerNode) {
        return lastNode;
      }
    }
    return false;
  }
  _getLastChildCurrent() {
    const children = this._currentLexerNode.getChildren();
    if (children && children.length > 0) {
      const lastNode = children[children.length - 1];
      return lastNode;
    }
    return false;
  }
  _setParentCurrentLexerNode() {
    const parent = this._currentLexerNode.getParent();
    if (parent) {
      this._currentLexerNode = parent;
      return true;
    }
    return false;
  }
  _setAncestorCurrentLexerNode() {
    var _a2, _b2, _c, _d, _e, _f;
    const parent = (_a2 = this._currentLexerNode) == null ? void 0 : _a2.getParent();
    let state = false;
    if (parent && parent.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
      if ((_b2 = parent == null ? void 0 : parent.getParent()) == null ? void 0 : _b2.getParent()) {
        const node = (_d = (_c = this._currentLexerNode.getParent()) == null ? void 0 : _c.getParent()) == null ? void 0 : _d.getParent();
        if (node) {
          this._currentLexerNode = node;
        }
        state = true;
      }
    } else {
      if (parent == null ? void 0 : parent.getParent()) {
        const node = (_e = this._currentLexerNode.getParent()) == null ? void 0 : _e.getParent();
        if (node) {
          this._currentLexerNode = node;
        }
        state = true;
      }
    }
    for (let i = 0; i < this._upLevel; i++) {
      const node = (_f = this._currentLexerNode) == null ? void 0 : _f.getParent();
      if (node) {
        this._currentLexerNode = node;
      }
      if (this._currentLexerNode) {
        state = true;
      } else {
        state = false;
      }
    }
    return state;
  }
  _segmentCount() {
    return this._segment.trim().length;
  }
  _pushSegment(value) {
    this._segment += value;
  }
  _pushNodeToChildren(valueRaw, isUnshift = false) {
    let value = valueRaw;
    if (value !== "") {
      const children = this._currentLexerNode.getChildren();
      if (!(value instanceof LexerNode) && this.isColonOpen()) {
        const subLexerNode_ref = new LexerNode();
        subLexerNode_ref.setToken(value);
        subLexerNode_ref.setParent(this._currentLexerNode);
        value = subLexerNode_ref;
      }
      if (isUnshift) {
        children.unshift(value);
      } else {
        children.push(value);
      }
    }
    if (this.isColonOpen()) {
      this._setAncestorCurrentLexerNode();
      this._closeColon();
    }
  }
  _setCurrentLexerNode(subLexerNode, isUnshift = false) {
    this._pushNodeToChildren(subLexerNode, isUnshift);
    subLexerNode.setParent(this._currentLexerNode);
    this._currentLexerNode = subLexerNode;
  }
  _newAndPushCurrentLexerNode(token, current, isUnshift = false) {
    const subLexerNode = new LexerNode();
    subLexerNode.setToken(token);
    subLexerNode.setIndex(current - token.length, current - 1);
    this._setCurrentLexerNode(subLexerNode, isUnshift);
  }
  _getTopNode(lexerNode) {
    let parentNode = lexerNode;
    while (parentNode == null ? void 0 : parentNode.getParent()) {
      parentNode = parentNode.getParent();
    }
    return parentNode;
  }
  _removeLastChild() {
    const children = this._currentLexerNode.getChildren();
    children.splice(-1);
  }
  /**
   * fix univer-pro/issues/2447
   * =1/3+
   * =+
   * =sum(A1+)
   */
  _formulaErrorLastTokenCheck(formulaStringArray, indexRaw) {
    const lastToken = this._findPreviousToken(formulaStringArray, indexRaw) || "";
    const isFirstCheck = formulaStringArray.length - 1 === indexRaw;
    if (!isFirstCheck && this._isOperatorToken(lastToken)) {
      return true;
    }
    if (isFirstCheck && isTokenCannotBeAtEnd(lastToken)) {
      return true;
    }
    if (SUFFIX_TOKEN_SET.has(lastToken)) {
      const lastTwoToken = this._findSecondLastNonSpaceToken(formulaStringArray, indexRaw);
      if (lastTwoToken == null || isTokenCannotPrecedeSuffixToken(lastTwoToken)) {
        return true;
      }
    }
    return false;
  }
  _findPreviousToken(data, indexRaw) {
    let index = indexRaw;
    while (index >= 0) {
      const token = data[index];
      if (token !== " ") {
        return token;
      }
      index--;
    }
  }
  _findSecondLastNonSpaceToken(data, indexRaw) {
    let index = indexRaw;
    let nonSpaceTokenCount = 0;
    while (index >= 0) {
      const token = data[index];
      if (token !== " ") {
        nonSpaceTokenCount++;
        if (nonSpaceTokenCount === 2) {
          return token;
        }
      }
      index--;
    }
    return null;
  }
  _findNextToken(data, indexRaw) {
    let index = indexRaw;
    while (index >= 0) {
      const token = data[index];
      if (token !== " ") {
        return token;
      }
      index++;
    }
  }
  _unexpectedEndingTokenExcludeOperator(prevString) {
    if (
      // OPERATOR_TOKEN_SET.has(prevString) ||
      prevString === "(" /* OPEN_BRACKET */ || prevString === "," /* COMMA */ || prevString === "=" /* EQUALS */ || prevString === ""
    ) {
      return true;
    }
    return false;
  }
  _unexpectedEndingToken(prevString) {
    if (this._isOperatorToken(prevString) || this._unexpectedEndingTokenExcludeOperator(prevString)) {
      return true;
    }
    return false;
  }
  _isOperatorToken(prevString) {
    if (OPERATOR_TOKEN_SET.has(prevString)) {
      return true;
    }
    return false;
  }
  _getSequenceArray(formulaString) {
    const sequenceArray = [];
    this._nodeMaker(formulaString, sequenceArray);
    return sequenceArray;
  }
  _resetTemp() {
    this._currentLexerNode = new LexerNode();
    this._upLevel = 0;
    this._segment = "";
    this._bracketState = [];
    this._bracesState = 0;
    this._singleQuotationState = 0;
    this._doubleQuotationState = 0;
    this._lambdaState = false;
    this._colonState = false;
    this._formulaErrorCount = 0;
  }
  _checkErrorState() {
    if (this._bracketState.length > 0) {
      return true;
    }
    if (this._bracesState > 0) {
      return true;
    }
    if (this._singleQuotationState > 0) {
      return true;
    }
    if (this._doubleQuotationState > 0) {
      return true;
    }
    if (this._hasFormalError()) {
      return true;
    }
    return false;
  }
  _checkSimilarErrorToken(currentString, curRow, formulaStringArray) {
    let cur = curRow;
    if (currentString !== "#" /* POUND */) {
      return true;
    }
    let currentText = formulaStringArray[++cur];
    while (currentText === " ") {
      currentText = formulaStringArray[++cur];
    }
    if (isFormulaLexerToken(currentText)) {
      return true;
    }
    return false;
  }
  _checkIfErrorObject(cur, formulaStringArray) {
    const errorType = this._findErrorObject(cur, formulaStringArray);
    if (!errorType) {
      return false;
    }
    return true;
  }
  _findErrorObject(curRaw, formulaStringArray) {
    for (let i = 0; i < ERROR_TYPE_COUNT_ARRAY.length; i++) {
      const errorTypeCount = ERROR_TYPE_COUNT_ARRAY[i];
      const errorType = formulaStringArray.slice(curRaw, curRaw + errorTypeCount).join("").toUpperCase();
      if (ERROR_TYPE_SET.has(errorType)) {
        return errorType;
      }
    }
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _nodeMaker(formulaStringRaw, sequenceArray, matchCurrentNodeIndex) {
    let formulaString = formulaStringRaw.replace(/\r\n$/, "").replace(/\r/g, " ").replace(/\n/g, " ");
    if (formulaString.substring(0, 1) === "=" /* EQUALS */) {
      formulaString = formulaString.substring(1);
    }
    const formulaStringArray = formulaString.split("");
    const formulaStringArrayCount = formulaStringArray.length;
    let cur = 0;
    this._resetTemp();
    if (this._formulaErrorLastTokenCheck(formulaStringArray, formulaStringArrayCount - 1)) {
      this._formalErrorOccurred();
    }
    while (cur < formulaStringArrayCount) {
      const currentString = formulaStringArray[cur];
      if (matchCurrentNodeIndex === cur) {
        return [this._currentLexerNode, currentString];
      }
      if (currentString === "#" /* POUND */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose() && this._checkIfErrorObject(cur, formulaStringArray)) {
        const errorType = this._findErrorObject(cur, formulaStringArray);
        if (errorType == null) {
          return "#VALUE!" /* VALUE */;
        }
        this._pushNodeToChildren(errorType);
        for (let i = 0; i < errorType.length; i++) {
          const curStr = formulaStringArray[cur];
          this._pushSegment(curStr);
          this._addSequenceArray(sequenceArray, curStr, cur);
          cur++;
        }
        this._resetSegment();
        continue;
      } else if (currentString === "(" /* OPEN_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        if (this._segmentCount() > 0 || this.isLambdaOpen()) {
          if (this.isLambdaClose()) {
            this._newAndPushCurrentLexerNode(this._segment, cur);
            this._resetSegment();
          }
          this._openBracket(1 /* FUNCTION */);
          this._closeLambda();
          const nextCurrentString = formulaStringArray[cur + 1];
          if (nextCurrentString && nextCurrentString === ")" /* CLOSE_BRACKET */) {
            if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
              return "#VALUE!" /* VALUE */;
            }
            this._addSequenceArray(sequenceArray, currentString, cur);
            cur++;
            this._addSequenceArray(sequenceArray, nextCurrentString, cur);
            cur++;
            this._closeBracket();
            continue;
          } else if (nextCurrentString) {
            this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER, cur);
          }
        } else {
          this._pushNodeToChildren(currentString);
          this._openBracket(0 /* NORMAL */);
          this._resetSegment();
        }
      } else if (currentString === ")" /* CLOSE_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        if (this._formulaErrorLastTokenCheck(formulaStringArray, cur - 1)) {
          this._formalErrorOccurred();
        }
        this._pushNodeToChildren(this._segment);
        this._resetSegment();
        const currentBracket = this._getCurrentBracket();
        if (currentBracket === 0 /* NORMAL */) {
          this._pushNodeToChildren(currentString);
        } else if (currentBracket === 1 /* FUNCTION */) {
          const nextCurrentString = formulaStringArray[cur + 1];
          if (nextCurrentString && nextCurrentString === "(" /* OPEN_BRACKET */) {
            if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
              return "#VALUE!" /* VALUE */;
            }
            this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER, cur, true);
            this._openLambda();
          } else {
            if (!this._setAncestorCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
              return "#VALUE!" /* VALUE */;
            }
          }
        } else {
          return "#VALUE!" /* VALUE */;
        }
        this._closeBracket();
      } else if (currentString === "{" /* OPEN_BRACES */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        this._pushSegment(currentString);
        this._openBraces();
        if (!this._formulaSpellCheck()) {
          return "#VALUE!" /* VALUE */;
        }
      } else if (currentString === "}" /* CLOSE_BRACES */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        this._pushSegment(currentString);
        this._pushNodeToChildren(this._segment);
        this._resetSegment();
        this._closeBraces();
      } else if (currentString === "[" /* OPEN_SQUARE_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        if (this._segment.length > 0) {
          this._openTableBracket();
        }
        this._pushSegment(currentString);
        this._openSquareBracket();
      } else if (currentString === "]" /* CLOSE_SQUARE_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
        this._closeSquareBracket();
        if (this.isSquareBracketClose()) {
          this._pushSegment(currentString);
          if (this._isTableBracket()) {
            this._pushNodeToChildren(this._segment);
            this._resetSegment();
          }
          this._closeTableBracket();
        } else {
          this._pushSegment(currentString);
        }
      } else if (currentString === '"' /* DOUBLE_QUOTATION */ && this.isSingleQuotationClose() && this.isSquareBracketClose()) {
        if (this.isDoubleQuotationClose()) {
          this._openDoubleQuotation();
        } else {
          const nextCurrentString = formulaStringArray[cur + 1];
          if (nextCurrentString && nextCurrentString === '"' /* DOUBLE_QUOTATION */) {
            cur++;
          } else {
            this._closeDoubleQuotation();
          }
        }
        this._pushSegment(currentString);
      } else if (currentString === "'" /* SINGLE_QUOTATION */ && this.isDoubleQuotationClose()) {
        if (this.isSingleQuotationClose()) {
          this._openSingleQuotation();
          if (this._segmentCount() === 0) {
            this._resetSegment();
          }
        } else {
          const nextCurrentString = formulaStringArray[cur + 1];
          if (nextCurrentString && nextCurrentString === "'" /* SINGLE_QUOTATION */) {
            this._pushSegment(currentString);
            this._addSequenceArray(sequenceArray, currentString, cur);
            cur++;
            this._pushSegment(nextCurrentString);
            this._addSequenceArray(sequenceArray, nextCurrentString, cur);
            cur++;
            continue;
          } else {
            this._closeSingleQuotation();
          }
        }
        this._pushSegment(currentString);
      } else if (currentString === "," /* COMMA */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        if (this._formulaErrorLastTokenCheck(formulaStringArray, cur - 1)) {
          this._formalErrorOccurred();
        }
        const currentBracket = this._getCurrentBracket();
        if (currentBracket === 1 /* FUNCTION */ || currentBracket == null) {
          this._pushNodeToChildren(this._segment);
          this._resetSegment();
          if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1 && currentBracket != null) {
            return "#VALUE!" /* VALUE */;
          }
          this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER, cur);
        } else {
          const cubeNode = new LexerNode();
          cubeNode.setToken(DEFAULT_TOKEN_CUBE_FUNCTION_NAME);
          const cubeParamNode = new LexerNode();
          cubeParamNode.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
          cubeParamNode.changeToParent(cubeNode);
          const colonNode = this._currentLexerNode.getParent();
          if (colonNode && colonNode.getToken() === ":" /* COLON */) {
            const colonNodeParent = colonNode.getParent();
            if (!colonNodeParent) {
              return "#VALUE!" /* VALUE */;
            }
            colonNode.changeToParent(cubeParamNode);
            colonNodeParent.setChildren([]);
            cubeNode.changeToParent(colonNodeParent);
          } else {
            return "#VALUE!" /* VALUE */;
          }
          this._changeCurrentBracket(1 /* FUNCTION */);
          this._pushNodeToChildren(this._segment);
          this._resetSegment();
          this._currentLexerNode = cubeNode;
          this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER, cur);
        }
      } else if (currentString === ":" /* COLON */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
        const subLexerNode_op = new LexerNode();
        subLexerNode_op.setToken(currentString);
        const subLexerNode_left = new LexerNode();
        subLexerNode_left.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
        subLexerNode_left.setParent(subLexerNode_op);
        const subLexerNode_right = new LexerNode();
        subLexerNode_right.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
        subLexerNode_right.setParent(subLexerNode_op);
        subLexerNode_op.getChildren().push(subLexerNode_left, subLexerNode_right);
        let subLexerNode_main = subLexerNode_op;
        let upLevel = 0;
        if (this._segmentCount() > 0) {
          let subLexerNode_minus;
          let subLexerNode_at;
          let sliceLength = 0;
          const segmentTrim = this._segment.trim();
          const lastString = segmentTrim[0];
          const twoLastString = segmentTrim[1];
          if (lastString === "-" /* MINUS */) {
            subLexerNode_minus = new LexerNode();
            subLexerNode_minus.setToken("-" /* MINUS */);
            sliceLength++;
          }
          if (lastString === "@" /* AT */ || twoLastString === "@" /* AT */) {
            subLexerNode_at = new LexerNode();
            subLexerNode_at.setToken("@" /* AT */);
            if (subLexerNode_minus) {
              subLexerNode_minus.addChildren(subLexerNode_at);
              subLexerNode_at.setParent(subLexerNode_minus);
            }
            sliceLength++;
          }
          if (sliceLength > 0) {
            this._segment = segmentTrim.slice(sliceLength);
          }
          upLevel = sliceLength;
          if (subLexerNode_at) {
            subLexerNode_at.addChildren(subLexerNode_op);
            subLexerNode_op.setParent(subLexerNode_at);
            if (subLexerNode_at.getParent()) {
              const node = subLexerNode_at.getParent();
              if (node) {
                subLexerNode_main = node;
              }
            } else {
              subLexerNode_main = subLexerNode_at;
            }
          } else if (subLexerNode_minus) {
            subLexerNode_main = subLexerNode_minus;
            subLexerNode_minus.addChildren(subLexerNode_op);
            subLexerNode_op.setParent(subLexerNode_minus);
          }
          const subLexerNode_ref = new LexerNode();
          subLexerNode_ref.setToken(this._segment);
          subLexerNode_ref.setParent(subLexerNode_left);
          subLexerNode_left.getChildren().push(subLexerNode_ref);
          this._resetSegment();
        } else {
          const lastChildNode = this._getLastChildCurrentLexerNode();
          if (lastChildNode) {
            lastChildNode.changeToParent(subLexerNode_left);
          }
        }
        this._setCurrentLexerNode(subLexerNode_main);
        this._currentLexerNode = subLexerNode_right;
        this._openColon(upLevel);
      } else if (SUFFIX_TOKEN_SET.has(currentString) && this._checkSimilarErrorToken(currentString, cur, formulaStringArray) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        this._pushNodeToChildren(this._segment);
        const subLexerNode = new LexerNode();
        subLexerNode.setToken(currentString);
        const lastChildNode = this._getLastChildCurrent();
        if (lastChildNode instanceof LexerNode) {
          lastChildNode.changeToParent(subLexerNode);
        } else if (lastChildNode !== false) {
          subLexerNode.getChildren().push(lastChildNode);
          this._removeLastChild();
        }
        this._pushNodeToChildren(subLexerNode);
        subLexerNode.setParent(this._currentLexerNode);
        this._resetSegment();
      } else if (OPERATOR_TOKEN_SET.has(currentString) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose() && this.isBracesClose()) {
        let trimSegment = this._segment.trim();
        if (currentString === "-" /* MINUS */ && trimSegment === "") {
          const prevString = this._findPreviousToken(formulaStringArray, cur - 1) || "";
          const nextString = this._findNextToken(formulaStringArray, cur + 1) || "";
          if (this._unexpectedEndingTokenExcludeOperator(prevString) && this._isOperatorToken(nextString)) {
            this._pushNodeToChildren("0");
            this._pushNodeToChildren("-" /* MINUS */);
            this._addSequenceArray(sequenceArray, currentString, cur);
            this._resetSegment();
            cur++;
            continue;
          } else if (this._unexpectedEndingToken(prevString)) {
            if (nextString === "+" /* PLUS */) {
              this._pushSegment("-" /* MINUS */);
              this._addSequenceArray(sequenceArray, currentString, cur);
              this._addSequenceArray(sequenceArray, "+" /* PLUS */, cur + 1);
              cur += 2;
              continue;
            } else {
              this._pushSegment("-" /* MINUS */);
              this._addSequenceArray(sequenceArray, currentString, cur);
              cur++;
              continue;
            }
          }
        } else if (this._segment.length > 0 && this._isScientificNotation(formulaStringArray, cur, currentString)) {
          this._pushSegment(currentString);
          this._addSequenceArray(sequenceArray, currentString, cur);
          cur++;
          continue;
        } else if (this._segment.length > 0 && trimSegment === "") {
          trimSegment = this._segment;
        } else {
          this._pushNodeToChildren(this._segment);
          trimSegment = "";
        }
        if (currentString === "<" /* LESS_THAN */ || currentString === ">" /* GREATER_THAN */) {
          const nextCurrentString = formulaStringArray[cur + 1];
          if (nextCurrentString && OPERATOR_TOKEN_SET.has(currentString + nextCurrentString)) {
            this._pushNodeToChildren(trimSegment + currentString + nextCurrentString);
            this._resetSegment();
            this._addSequenceArray(sequenceArray, currentString, cur);
            cur++;
            this._addSequenceArray(sequenceArray, nextCurrentString, cur);
            cur++;
            continue;
          } else {
            this._pushNodeToChildren(trimSegment + currentString);
          }
        } else {
          this._pushNodeToChildren(trimSegment + currentString);
        }
        this._resetSegment();
      } else {
        this._pushSegment(currentString);
      }
      this._addSequenceArray(sequenceArray, currentString, cur);
      cur++;
    }
    this._pushNodeToChildren(this._segment);
    if (this._checkErrorState()) {
      return "#VALUE!" /* VALUE */;
    }
  }
  _isScientificNotation(formulaStringArray, cur, currentString) {
    const preTwoChar = formulaStringArray[cur - 2];
    if (preTwoChar && Number.isNaN(Number(preTwoChar))) {
      return false;
    }
    if (!(currentString === "-" /* MINUS */ || currentString === "+" /* PLUS */)) {
      return false;
    }
    const nextOneChar = formulaStringArray[cur + 1];
    if (nextOneChar && Number.isNaN(Number(nextOneChar))) {
      return false;
    }
    const preOneChar = formulaStringArray[cur - 1];
    return preOneChar && preOneChar.toUpperCase() === "E";
  }
  _addSequenceArray(sequenceArray, currentString, cur) {
    sequenceArray == null ? void 0 : sequenceArray.push({
      segment: this._segment,
      currentString,
      cur,
      currentLexerNode: this._currentLexerNode
    });
  }
};

// ../packages/engine-formula/src/models/utils/formula-data-util.ts
function updateFormulaDataByCellValue(sheetFormulaDataMatrix, newSheetFormulaDataMatrix, formulaIdMap, deleteFormulaIdMap, r, c, cell) {
  const formulaString = (cell == null ? void 0 : cell.f) || "";
  const formulaId = (cell == null ? void 0 : cell.si) || "";
  const checkFormulaString = isFormulaString(formulaString);
  const checkFormulaId = isFormulaId(formulaId);
  const currentFormulaInfo = sheetFormulaDataMatrix.getValue(r, c);
  const f = (currentFormulaInfo == null ? void 0 : currentFormulaInfo.f) || "";
  const si = (currentFormulaInfo == null ? void 0 : currentFormulaInfo.si) || "";
  function clearFormulaData() {
    var _a2;
    if (isFormulaString(f) && isFormulaId(si)) {
      const updatedFormula = (_a2 = formulaIdMap == null ? void 0 : formulaIdMap[si]) == null ? void 0 : _a2.f;
      if (updatedFormula) {
        deleteFormulaIdMap.set(si, updatedFormula);
      } else {
        deleteFormulaIdMap.set(si, f);
      }
    }
  }
  if (checkFormulaString && checkFormulaId) {
    if (si !== formulaId) {
      clearFormulaData();
    }
    sheetFormulaDataMatrix.setValue(r, c, {
      f: formulaString,
      si: formulaId
    });
    formulaIdMap[formulaId] = { f: formulaString, r, c };
    newSheetFormulaDataMatrix.setValue(r, c, {
      f: formulaString,
      si: formulaId
    });
  } else if (checkFormulaString && !checkFormulaId) {
    if (f !== formulaString) {
      clearFormulaData();
    }
    sheetFormulaDataMatrix.setValue(r, c, {
      f: formulaString
    });
    newSheetFormulaDataMatrix.setValue(r, c, {
      f: formulaString
    });
  } else if (!checkFormulaString && checkFormulaId) {
    if (si !== formulaId) {
      clearFormulaData();
    }
    sheetFormulaDataMatrix.setValue(r, c, {
      f: "",
      si: formulaId
    });
  } else if (!checkFormulaString && !checkFormulaId && sheetFormulaDataMatrix.getValue(r, c)) {
    clearFormulaData();
    sheetFormulaDataMatrix.realDeleteValue(r, c);
    newSheetFormulaDataMatrix.setValue(r, c, null);
  }
}
function clearArrayFormulaCellDataByCell(arrayFormulaRangeMatrix, arrayFormulaCellDataMatrix, r, c) {
  const arrayFormulaRangeValue = arrayFormulaRangeMatrix == null ? void 0 : arrayFormulaRangeMatrix.getValue(r, c);
  if (arrayFormulaRangeValue == null) {
    return true;
  }
  const intersection = [];
  arrayFormulaRangeMatrix.forValue((rangeRow, rangeCol, range) => {
    if (rangeRow === r && rangeCol === c) {
      return;
    }
    if (Rectangle.intersects(range, arrayFormulaRangeValue)) {
      intersection.push(range);
    }
  });
  const { startRow, startColumn, endRow, endColumn } = arrayFormulaRangeValue;
  for (let row = startRow; row <= endRow; row++) {
    for (let col = startColumn; col <= endColumn; col++) {
      let isOverlapping = false;
      const currentCell = cellToRange(row, col);
      intersection.some((range) => {
        if (Rectangle.contains(range, currentCell)) {
          isOverlapping = true;
          return true;
        }
        return false;
      });
      if (!isOverlapping) {
        arrayFormulaCellDataMatrix.realDeleteValue(row, col);
      }
    }
  }
}

// ../packages/engine-formula/src/models/formula-data.model.ts
var FormulaDataModel = class extends Disposable {
  constructor(_univerInstanceService, _lexerTreeBuilder) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._lexerTreeBuilder = _lexerTreeBuilder;
    __publicField(this, "_arrayFormulaRange", {});
    __publicField(this, "_arrayFormulaCellData", {});
  }
  dispose() {
    super.dispose();
    this._arrayFormulaRange = {};
    this._arrayFormulaCellData = {};
  }
  clearPreviousArrayFormulaCellData(clearArrayFormulaCellData) {
    Object.keys(clearArrayFormulaCellData).forEach((unitId) => {
      const clearSheetData = clearArrayFormulaCellData[unitId];
      if (clearSheetData == null) {
        return true;
      }
      Object.keys(clearSheetData).forEach((sheetId) => {
        var _a2, _b2, _c, _d;
        const clearCellMatrixData = clearSheetData[sheetId];
        const formulaRange = (_b2 = (_a2 = this._arrayFormulaRange) == null ? void 0 : _a2[unitId]) == null ? void 0 : _b2[sheetId];
        if (formulaRange == null) {
          return true;
        }
        const rangeMatrix = new ObjectMatrix(formulaRange);
        let arrayFormulaCellMatrixData = new ObjectMatrix();
        if (((_c = this._arrayFormulaCellData[unitId]) == null ? void 0 : _c[sheetId]) != null) {
          arrayFormulaCellMatrixData = new ObjectMatrix(
            (_d = this._arrayFormulaCellData[unitId]) == null ? void 0 : _d[sheetId]
          );
        }
        clearCellMatrixData.forValue((row, column) => {
          const range = rangeMatrix.getValue(row, column);
          if (range == null) {
            return true;
          }
          const { startRow, startColumn, endRow, endColumn } = range;
          for (let r = startRow; r <= endRow; r++) {
            for (let c = startColumn; c <= endColumn; c++) {
              arrayFormulaCellMatrixData.setValue(r, c, null);
            }
          }
          rangeMatrix.realDeleteValue(row, column);
        });
        if (this._arrayFormulaCellData[unitId]) {
          this._arrayFormulaCellData[unitId][sheetId] = arrayFormulaCellMatrixData.getData();
        }
      });
    });
  }
  mergeArrayFormulaCellData(unitData) {
    Object.keys(unitData).forEach((unitId) => {
      const sheetData = unitData[unitId];
      if (sheetData == null) {
        return true;
      }
      if (this._arrayFormulaRange[unitId] == null) {
        this._arrayFormulaRange[unitId] = {};
      }
      if (this._arrayFormulaCellData[unitId] == null) {
        this._arrayFormulaCellData[unitId] = {};
      }
      Object.keys(sheetData).forEach((sheetId) => {
        var _a2, _b2;
        const cellMatrixData = sheetData[sheetId];
        const arrayFormulaRangeMatrix = new ObjectMatrix((_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId]);
        const arrayFormulaCellMatrixData = new ObjectMatrix((_b2 = this._arrayFormulaCellData[unitId]) == null ? void 0 : _b2[sheetId]);
        cellMatrixData.forValue((row, column) => {
          const arrayFormulaRange = arrayFormulaRangeMatrix == null ? void 0 : arrayFormulaRangeMatrix.getValue(row, column);
          if (arrayFormulaRange == null) {
            return true;
          }
          const { startRow, startColumn, endRow, endColumn } = arrayFormulaRange;
          for (let r = startRow; r <= endRow; r++) {
            for (let c = startColumn; c <= endColumn; c++) {
              arrayFormulaCellMatrixData.setValue(r, c, null);
            }
          }
        });
        cellMatrixData.forValue((row, column, cellData) => {
          arrayFormulaCellMatrixData.setValue(row, column, cellData);
        });
        if (this._arrayFormulaCellData[unitId]) {
          this._arrayFormulaCellData[unitId][sheetId] = arrayFormulaCellMatrixData.getData();
        }
      });
    });
  }
  getFormulaData() {
    const formulaData = {};
    const allSheets = this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET);
    if (allSheets.length === 0) {
      return formulaData;
    }
    allSheets.forEach((workbook) => {
      const unitId = workbook.getUnitId();
      formulaData[unitId] = {};
      const worksheets = workbook.getSheets();
      worksheets.forEach((worksheet) => {
        const cellMatrix = worksheet.getCellMatrix();
        const sheetId = worksheet.getSheetId();
        initSheetFormulaData(formulaData, unitId, sheetId, cellMatrix);
      });
    });
    return formulaData;
  }
  getSheetFormulaData(unitId, sheetId) {
    const formulaData = {};
    const workbook = this._univerInstanceService.getUnit(unitId);
    if (workbook == null) {
      return {};
    }
    formulaData[unitId] = {};
    const worksheet = workbook.getSheetBySheetId(sheetId);
    if (worksheet == null) {
      return {};
    }
    const cellMatrix = worksheet.getCellMatrix();
    initSheetFormulaData(formulaData, unitId, sheetId, cellMatrix);
    return formulaData[unitId][sheetId];
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  setArrayFormulaRange(value) {
    this._arrayFormulaRange = value;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(value) {
    this._arrayFormulaCellData = value;
  }
  mergeArrayFormulaRange(formulaData) {
    Object.keys(formulaData).forEach((unitId) => {
      const sheetData = formulaData[unitId];
      if (sheetData == null) {
        return true;
      }
      if (!this._arrayFormulaRange[unitId]) {
        this._arrayFormulaRange[unitId] = {};
      }
      Object.keys(sheetData).forEach((sheetId) => {
        var _a2;
        const arrayFormula = new ObjectMatrix(sheetData[sheetId]);
        const rangeMatrix = new ObjectMatrix((_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId]);
        arrayFormula.forValue((r, c, v) => {
          rangeMatrix.setValue(r, c, v);
        });
        if (this._arrayFormulaRange[unitId]) {
          this._arrayFormulaRange[unitId][sheetId] = rangeMatrix.getData();
        }
      });
    });
  }
  deleteArrayFormulaRange(unitId, sheetId, row, column) {
    var _a2;
    const cellMatrixData = (_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId];
    if (cellMatrixData == null) {
      return;
    }
    const rangeMatrixData = new ObjectMatrix(cellMatrixData);
    if (rangeMatrixData.getValue(row, column)) {
      rangeMatrixData.realDeleteValue(row, column);
      if (this._arrayFormulaRange[unitId]) {
        this._arrayFormulaRange[unitId][sheetId] = rangeMatrixData.getData();
      }
    }
  }
  getCalculateData() {
    const unitAllSheet = this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET);
    const allUnitData = {};
    const unitStylesData = {};
    const unitSheetNameMap = {};
    for (const workbook of unitAllSheet) {
      const unitId = workbook.getUnitId();
      const sheets = workbook.getSheets();
      const sheetData = {};
      const sheetNameMap = {};
      for (const sheet of sheets) {
        const sheetId = sheet.getSheetId();
        const sheetConfig = sheet.getConfig();
        sheetData[sheetId] = {
          cellData: new ObjectMatrix(sheetConfig.cellData),
          rowCount: sheetConfig.rowCount,
          columnCount: sheetConfig.columnCount,
          rowData: sheetConfig.rowData,
          columnData: sheetConfig.columnData,
          defaultRowHeight: sheetConfig.defaultRowHeight,
          defaultColumnWidth: sheetConfig.defaultColumnWidth
        };
        sheetNameMap[sheet.getName()] = sheet.getSheetId();
      }
      allUnitData[unitId] = sheetData;
      unitStylesData[unitId] = workbook.getStyles();
      unitSheetNameMap[unitId] = sheetNameMap;
    }
    return {
      allUnitData,
      unitStylesData,
      unitSheetNameMap
    };
  }
  /**
   * Get the hidden rows that are filtered or manually hidden.
   *
   * For formulas that are sensitive to hidden rows.
   */
  getHiddenRowsFiltered() {
    const unitAllSheet = this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET);
    const rowData = {};
    for (const workbook of unitAllSheet) {
      const unitId = workbook.getUnitId();
      const sheets = workbook.getSheets();
      rowData[unitId] = {};
      for (const sheet of sheets) {
        const sheetId = sheet.getSheetId();
        rowData[unitId][sheetId] = {};
        const startRow = 0;
        const endRow = sheet.getRowCount() - 1;
        const sheetRowData = {};
        for (let i = startRow; i <= endRow; i++) {
          if (!sheet.getRowVisible(i)) {
            sheetRowData[i] = {
              hd: 1 /* TRUE */
            };
          }
        }
        rowData[unitId][sheetId] = sheetRowData;
      }
    }
    return rowData;
  }
  updateFormulaData(unitId, sheetId, cellValue) {
    const cellMatrix = new ObjectMatrix(cellValue);
    const formulaIdMap = this._getSheetFormulaIdMap(unitId, sheetId);
    const deleteFormulaIdMap = /* @__PURE__ */ new Map();
    const formulaData = this.getFormulaData();
    if (formulaData[unitId] == null) {
      formulaData[unitId] = {};
    }
    const workbookFormulaData = formulaData[unitId];
    if (workbookFormulaData[sheetId] == null) {
      workbookFormulaData[sheetId] = {};
    }
    const sheetFormulaDataMatrix = new ObjectMatrix(workbookFormulaData[sheetId] || {});
    const newSheetFormulaDataMatrix = new ObjectMatrix();
    cellMatrix.forValue((r, c, cell) => {
      updateFormulaDataByCellValue(sheetFormulaDataMatrix, newSheetFormulaDataMatrix, formulaIdMap, deleteFormulaIdMap, r, c, cell);
    });
    sheetFormulaDataMatrix.forValue((r, c, cell) => {
      const formulaString = (cell == null ? void 0 : cell.f) || "";
      const formulaId = (cell == null ? void 0 : cell.si) || "";
      if (isFormulaId(formulaId)) {
        const formulaInfo = formulaIdMap == null ? void 0 : formulaIdMap[formulaId];
        const deleteFormula = deleteFormulaIdMap.get(formulaId);
        if (formulaInfo && !isFormulaString(formulaString)) {
          const f = formulaInfo.f;
          const x = c - formulaInfo.c;
          const y = r - formulaInfo.r;
          sheetFormulaDataMatrix.setValue(r, c, { f, si: formulaId, x, y });
          newSheetFormulaDataMatrix.setValue(r, c, { f, si: formulaId, x, y });
        } else if (typeof deleteFormula === "string") {
          const x = (cell == null ? void 0 : cell.x) || 0;
          const y = (cell == null ? void 0 : cell.y) || 0;
          const offsetFormula = this._lexerTreeBuilder.moveFormulaRefOffset(deleteFormula, x, y);
          deleteFormulaIdMap.set(formulaId, { r, c, f: offsetFormula });
          sheetFormulaDataMatrix.setValue(r, c, { f: offsetFormula, si: formulaId });
          newSheetFormulaDataMatrix.setValue(r, c, { f: offsetFormula, si: formulaId });
        } else if (typeof deleteFormula === "object") {
          const x = c - deleteFormula.c;
          const y = r - deleteFormula.r;
          sheetFormulaDataMatrix.setValue(r, c, { f: deleteFormula.f, si: formulaId, x, y });
          newSheetFormulaDataMatrix.setValue(r, c, { f: deleteFormula.f, si: formulaId, x, y });
        }
      }
    });
    return newSheetFormulaDataMatrix.getMatrix();
  }
  updateArrayFormulaRange(unitId, sheetId, cellValue) {
    var _a2;
    const arrayFormulaRange = (_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId];
    if (!arrayFormulaRange) return;
    const arrayFormulaRangeMatrix = new ObjectMatrix(arrayFormulaRange);
    const cellMatrix = new ObjectMatrix(cellValue);
    cellMatrix.forValue((r, c, cell) => {
      arrayFormulaRangeMatrix.realDeleteValue(r, c);
    });
  }
  updateArrayFormulaCellData(unitId, sheetId, cellValue) {
    var _a2, _b2;
    const arrayFormulaRange = (_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId];
    if (!arrayFormulaRange) return;
    const arrayFormulaRangeMatrix = new ObjectMatrix(arrayFormulaRange);
    const arrayFormulaCellData = (_b2 = this._arrayFormulaCellData[unitId]) == null ? void 0 : _b2[sheetId];
    if (!arrayFormulaCellData) return;
    const arrayFormulaCellDataMatrix = new ObjectMatrix(arrayFormulaCellData);
    const cellMatrix = new ObjectMatrix(cellValue);
    cellMatrix.forValue((r, c, cell) => {
      clearArrayFormulaCellDataByCell(arrayFormulaRangeMatrix, arrayFormulaCellDataMatrix, r, c);
    });
  }
  getFormulaStringByCell(row, column, sheetId, unitId) {
    const workbook = this._univerInstanceService.getUnit(unitId);
    if (workbook == null) {
      return null;
    }
    const worksheet = workbook.getSheetBySheetId(sheetId);
    if (worksheet == null) {
      return null;
    }
    const cellMatrix = worksheet.getCellMatrix();
    const cell = cellMatrix.getValue(row, column);
    if (cell == null) {
      return null;
    }
    const { f, si } = cell;
    if (isFormulaString(f)) {
      return f;
    }
    if (isFormulaId(si)) {
      let formulaString = null;
      cellMatrix.forValue((r, c, cell2) => {
        if (cell2 == null) {
          return true;
        }
        const { f: f2, si: currentId } = cell2;
        if (isFormulaString(f2) && si === currentId) {
          formulaString = this._lexerTreeBuilder.moveFormulaRefOffset(
            f2,
            column - c,
            row - r
          );
          return false;
        }
      });
      return formulaString;
    }
    return null;
  }
  /**
   * Function to get all formula ranges
   * @returns
   */
  getFormulaDirtyRanges() {
    const formulaData = this.getFormulaData();
    const dirtyRanges = [];
    for (const unitId in formulaData) {
      const workbook = formulaData[unitId];
      if (!workbook) continue;
      const workbookInstance = this._univerInstanceService.getUnit(unitId);
      if (!workbookInstance) continue;
      for (const sheetId in workbook) {
        const sheet = workbook[sheetId];
        if (!sheet) continue;
        const sheetInstance = workbookInstance.getSheetBySheetId(sheetId);
        if (!sheetInstance) continue;
        const columnRanges = {};
        for (const rowStr of Object.keys(sheet)) {
          const row = Number(rowStr);
          for (const columnStr in sheet[row]) {
            const column = Number(columnStr);
            const currentCell = sheetInstance.getCellRaw(row, column);
            const isFormula = isFormulaString(currentCell == null ? void 0 : currentCell.f) || isFormulaId(currentCell == null ? void 0 : currentCell.si);
            const noValue = (currentCell == null ? void 0 : currentCell.v) === void 0;
            if (!(isFormula && noValue)) continue;
            if (!columnRanges[column]) columnRanges[column] = [];
            const lastRange = columnRanges[column].slice(-1)[0];
            if (lastRange && lastRange.endRow === row - 1) {
              lastRange.endRow = row;
            } else {
              columnRanges[column].push({ startRow: row, endRow: row });
            }
          }
        }
        for (const column in columnRanges) {
          const currentColumnRanges = columnRanges[column];
          for (let i = 0; i < currentColumnRanges.length; i++) {
            const range = currentColumnRanges[i];
            dirtyRanges.push({
              unitId,
              sheetId,
              range: {
                rangeType: 0 /* NORMAL */,
                startRow: range.startRow,
                endRow: range.endRow,
                // Use endRow as the inclusive end row
                startColumn: Number(column),
                endColumn: Number(column)
              }
            });
          }
        }
      }
    }
    return dirtyRanges;
  }
  _getSheetFormulaIdMap(unitId, sheetId) {
    const formulaIdMap = {};
    const workbook = this._univerInstanceService.getUnit(unitId);
    if (workbook == null) {
      return formulaIdMap;
    }
    const worksheet = workbook.getSheetBySheetId(sheetId);
    if (worksheet == null) {
      return formulaIdMap;
    }
    const cellMatrix = worksheet.getCellMatrix();
    cellMatrix.forValue((r, c, cell) => {
      if (cell == null) {
        return true;
      }
      const { f, si } = cell;
      if (isFormulaString(f) && isFormulaId(si)) {
        formulaIdMap[si] = { f, r, c };
      }
    });
    return formulaIdMap;
  }
};
FormulaDataModel = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, Inject(LexerTreeBuilder))
], FormulaDataModel);
function initSheetFormulaData(formulaData, unitId, sheetId, cellMatrix) {
  if (!formulaData[unitId]) {
    formulaData[unitId] = {};
  }
  if (!formulaData[unitId][sheetId]) {
    formulaData[unitId][sheetId] = {};
  }
  const formulaIdMap = /* @__PURE__ */ new Map();
  const sheetFormulaDataMatrix = new ObjectMatrix(formulaData[unitId][sheetId]);
  cellMatrix.forValue((r, c, cell) => {
    const formulaString = (cell == null ? void 0 : cell.f) || "";
    const formulaId = (cell == null ? void 0 : cell.si) || "";
    const checkFormulaString = isFormulaString(formulaString);
    const checkFormulaId = isFormulaId(formulaId);
    if (checkFormulaString && checkFormulaId) {
      sheetFormulaDataMatrix.setValue(r, c, {
        f: formulaString,
        si: formulaId
      });
      formulaIdMap.set(formulaId, { f: formulaString, r, c });
    } else if (checkFormulaString && !checkFormulaId) {
      sheetFormulaDataMatrix.setValue(r, c, {
        f: formulaString
      });
    } else if (!checkFormulaString && checkFormulaId) {
      sheetFormulaDataMatrix.setValue(r, c, {
        f: "",
        si: formulaId
      });
    }
  });
  sheetFormulaDataMatrix.forValue((r, c, cell) => {
    const formulaString = (cell == null ? void 0 : cell.f) || "";
    const formulaId = (cell == null ? void 0 : cell.si) || "";
    if (isFormulaId(formulaId) && !isFormulaString(formulaString)) {
      const formulaInfo = formulaIdMap.get(formulaId);
      if (formulaInfo) {
        const f = formulaInfo.f;
        const x = c - formulaInfo.c;
        const y = r - formulaInfo.r;
        sheetFormulaDataMatrix.setValue(r, c, { f, si: formulaId, x, y });
      } else {
        sheetFormulaDataMatrix.realDeleteValue(r, c);
      }
    }
  });
  const newSheetFormulaData = sheetFormulaDataMatrix.getMatrix();
  return {
    [unitId]: {
      [sheetId]: newSheetFormulaData
    }
  };
}

// ../packages/engine-formula/src/services/calculate-formula.service.ts
var import_rxjs23 = __toESM(require_cjs());

// ../node_modules/.pnpm/@flatten-js+interval-tree@1.1.3/node_modules/@flatten-js/interval-tree/dist/main.mjs
var Interval = class Interval2 {
  /**
   * Accept two comparable values and creates new instance of interval
   * Predicate Interval.comparable_less(low, high) supposed to return true on these values
   * @param low
   * @param high
   */
  constructor(low, high) {
    this.low = low;
    this.high = high;
  }
  /**
   * Clone interval
   * @returns {Interval}
   */
  clone() {
    return new Interval2(this.low, this.high);
  }
  /**
   * Propery max returns clone of this interval
   * @returns {Interval}
   */
  get max() {
    return this.clone();
  }
  /**
   * Predicate returns true is this interval less than other interval
   * @param other_interval
   * @returns {boolean}
   */
  less_than(other_interval) {
    return this.low < other_interval.low || this.low === other_interval.low && this.high < other_interval.high;
  }
  /**
   * Predicate returns true is this interval equals to other interval
   * @param other_interval
   * @returns {boolean}
   */
  equal_to(other_interval) {
    return this.low === other_interval.low && this.high === other_interval.high;
  }
  /**
   * Predicate returns true if this interval intersects other interval
   * @param other_interval
   * @returns {boolean}
   */
  intersect(other_interval) {
    return !this.not_intersect(other_interval);
  }
  /**
   * Predicate returns true if this interval does not intersect other interval
   * @param other_interval
   * @returns {boolean}
   */
  not_intersect(other_interval) {
    return this.high < other_interval.low || other_interval.high < this.low;
  }
  /**
   * Returns new interval merged with other interval
   * @param {Interval} other_interval - Other interval to merge with
   * @returns {Interval}
   */
  merge(other_interval) {
    return new Interval2(
      this.low === void 0 ? other_interval.low : this.low < other_interval.low ? this.low : other_interval.low,
      this.high === void 0 ? other_interval.high : this.high > other_interval.high ? this.high : other_interval.high
    );
  }
  /**
   * Returns how key should return
   */
  output() {
    return [this.low, this.high];
  }
  /**
   * Function returns maximum between two comparable values
   * @param interval1
   * @param interval2
   * @returns {Interval}
   */
  static comparable_max(interval1, interval2) {
    return interval1.merge(interval2);
  }
  /**
   * Predicate returns true if first value less than second value
   * @param val1
   * @param val2
   * @returns {boolean}
   */
  static comparable_less_than(val1, val2) {
    return val1 < val2;
  }
};
var RB_TREE_COLOR_RED = 0;
var RB_TREE_COLOR_BLACK = 1;
var Node = class {
  constructor(key = void 0, value = void 0, left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {
    this.left = left;
    this.right = right;
    this.parent = parent;
    this.color = color;
    this.item = { key, value };
    if (key && key instanceof Array && key.length === 2) {
      if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {
        let [low, high] = key;
        if (low > high) [low, high] = [high, low];
        this.item.key = new Interval(low, high);
      }
    }
    this.max = this.item.key ? this.item.key.max : void 0;
  }
  isNil() {
    return this.item.key === void 0 && this.item.value === void 0 && this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK;
  }
  _value_less_than(other_node) {
    return this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) : this.item.value < other_node.item.value;
  }
  less_than(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.less_than(other_node.item.key);
    } else {
      return this.item.key.less_than(other_node.item.key) || this.item.key.equal_to(other_node.item.key) && this._value_less_than(other_node);
    }
  }
  _value_equal(other_node) {
    return this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) : this.item.value === other_node.item.value;
  }
  equal_to(other_node) {
    if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {
      return this.item.key.equal_to(other_node.item.key);
    } else {
      return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);
    }
  }
  intersect(other_node) {
    return this.item.key.intersect(other_node.item.key);
  }
  copy_data(other_node) {
    this.item.key = other_node.item.key;
    this.item.value = other_node.item.value;
  }
  update_max() {
    this.max = this.item.key ? this.item.key.max : void 0;
    if (this.right && this.right.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.right.max);
    }
    if (this.left && this.left.max) {
      const comparable_max = this.item.key.constructor.comparable_max;
      this.max = comparable_max(this.max, this.left.max);
    }
  }
  // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low
  not_intersect_left_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let high = this.left.max.high !== void 0 ? this.left.max.high : this.left.max;
    return comparable_less_than(high, search_node.item.key.low);
  }
  // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low
  not_intersect_right_subtree(search_node) {
    const comparable_less_than = this.item.key.constructor.comparable_less_than;
    let low = this.right.max.low !== void 0 ? this.right.max.low : this.right.item.key.low;
    return comparable_less_than(search_node.item.key.high, low);
  }
};
var IntervalTree = class _IntervalTree {
  /**
   * Construct new empty instance of IntervalTree
   */
  constructor() {
    this.root = null;
    this.nil_node = new Node();
  }
  /**
   * Returns number of items stored in the interval tree
   * @returns {number}
   */
  get size() {
    let count = 0;
    this.tree_walk(this.root, () => count++);
    return count;
  }
  /**
   * Returns array of sorted keys in the ascending order
   * @returns {Array}
   */
  get keys() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(
      node.item.key.output ? node.item.key.output() : node.item.key
    ));
    return res;
  }
  /**
   * Return array of values in the ascending keys order
   * @returns {Array}
   */
  get values() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push(node.item.value));
    return res;
  }
  /**
   * Returns array of items (<key,value> pairs) in the ascended keys order
   * @returns {Array}
   */
  get items() {
    let res = [];
    this.tree_walk(this.root, (node) => res.push({
      key: node.item.key.output ? node.item.key.output() : node.item.key,
      value: node.item.value
    }));
    return res;
  }
  /**
   * Returns true if tree is empty
   * @returns {boolean}
   */
  isEmpty() {
    return this.root == null || this.root === this.nil_node;
  }
  /**
   * Clear tree
   */
  clear() {
    this.root = null;
  }
  /**
   * Insert new item into interval tree
   * @param {Interval} key - interval object or array of two numbers [low, high]
   * @param {any} value - value representing any object (optional)
   * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}
   */
  insert(key, value = key) {
    if (key === void 0) return;
    let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);
    this.tree_insert(insert_node);
    this.recalc_max(insert_node);
    return insert_node;
  }
  /**
   * Returns true if item {key,value} exist in the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object to be checked
   * @returns {boolean} true if item {key, value} exist in the tree, false otherwise
   */
  exist(key, value = key) {
    let search_node = new Node(key, value);
    return !!this.tree_search(this.root, search_node);
  }
  /**
   * Remove entry {key, value} from the tree
   * @param {Interval} key - interval correspondent to keys stored in the tree
   * @param {any} value - value object
   * @returns {boolean} true if item {key, value} deleted, false if not found
   */
  remove(key, value = key) {
    let search_node = new Node(key, value);
    let delete_node = this.tree_search(this.root, search_node);
    if (delete_node) {
      this.tree_delete(delete_node);
    }
    return delete_node;
  }
  /**
   * Returns array of entry values which keys intersect with given interval <br/>
   * If no values stored in the tree, returns array of keys which intersect given interval
   * @param {Interval} interval - search interval, or tuple [low, high]
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Array}
   */
  search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {
    let search_node = new Node(interval);
    let resp_nodes = [];
    this.tree_search_interval(this.root, search_node, resp_nodes);
    return resp_nodes.map((node) => outputMapperFn(node.item.value, node.item.key));
  }
  /**
   * Returns true if intersection between given and any interval stored in the tree found
   * @param {Interval} interval - search interval or tuple [low, high]
   * @returns {boolean}
   */
  intersect_any(interval) {
    let search_node = new Node(interval);
    return this.tree_find_any_interval(this.root, search_node);
  }
  /**
   * Tree visitor. For each node implement a callback function. <br/>
   * Method calls a callback function with two parameters (key, value)
   * @param visitor(key,value) - function to be called for each tree item
   */
  forEach(visitor) {
    this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));
  }
  /**
   * Value Mapper. Walk through every node and map node value to another value
   * @param callback(value,key) - function to be called for each tree item
   */
  map(callback) {
    const tree = new _IntervalTree();
    this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));
    return tree;
  }
  /**
   * @param {Interval} interval - optional if the iterator is intended to start from the beginning
   * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output
   * @returns {Iterator}
   */
  *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {
    let node;
    if (interval) {
      node = this.tree_search_nearest_forward(this.root, new Node(interval));
    } else if (this.root) {
      node = this.local_minimum(this.root);
    }
    while (node) {
      yield outputMapperFn(node.item.value, node.item.key);
      node = this.tree_successor(node);
    }
  }
  recalc_max(node) {
    let node_current = node;
    while (node_current.parent != null) {
      node_current.parent.update_max();
      node_current = node_current.parent;
    }
  }
  tree_insert(insert_node) {
    let current_node = this.root;
    let parent_node = null;
    if (this.root == null || this.root === this.nil_node) {
      this.root = insert_node;
    } else {
      while (current_node !== this.nil_node) {
        parent_node = current_node;
        if (insert_node.less_than(current_node)) {
          current_node = current_node.left;
        } else {
          current_node = current_node.right;
        }
      }
      insert_node.parent = parent_node;
      if (insert_node.less_than(parent_node)) {
        parent_node.left = insert_node;
      } else {
        parent_node.right = insert_node;
      }
    }
    this.insert_fixup(insert_node);
  }
  // After insertion insert_node may have red-colored parent, and this is a single possible violation
  // Go upwords to the root and re-color until violation will be resolved
  insert_fixup(insert_node) {
    let current_node;
    let uncle_node;
    current_node = insert_node;
    while (current_node !== this.root && current_node.parent.color === RB_TREE_COLOR_RED) {
      if (current_node.parent === current_node.parent.parent.left) {
        uncle_node = current_node.parent.parent.right;
        if (uncle_node.color === RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node === current_node.parent.right) {
            current_node = current_node.parent;
            this.rotate_left(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent.parent);
        }
      } else {
        uncle_node = current_node.parent.parent.left;
        if (uncle_node.color === RB_TREE_COLOR_RED) {
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          uncle_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent.parent;
        } else {
          if (current_node === current_node.parent.left) {
            current_node = current_node.parent;
            this.rotate_right(current_node);
          }
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          current_node.parent.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent.parent);
        }
      }
    }
    this.root.color = RB_TREE_COLOR_BLACK;
  }
  tree_delete(delete_node) {
    let cut_node;
    let fix_node;
    if (delete_node.left === this.nil_node || delete_node.right === this.nil_node) {
      cut_node = delete_node;
    } else {
      cut_node = this.tree_successor(delete_node);
    }
    if (cut_node.left !== this.nil_node) {
      fix_node = cut_node.left;
    } else {
      fix_node = cut_node.right;
    }
    fix_node.parent = cut_node.parent;
    if (cut_node === this.root) {
      this.root = fix_node;
    } else {
      if (cut_node === cut_node.parent.left) {
        cut_node.parent.left = fix_node;
      } else {
        cut_node.parent.right = fix_node;
      }
      cut_node.parent.update_max();
    }
    this.recalc_max(fix_node);
    if (cut_node !== delete_node) {
      delete_node.copy_data(cut_node);
      delete_node.update_max();
      this.recalc_max(delete_node);
    }
    if (
      /*fix_node != this.nil_node && */
      cut_node.color === RB_TREE_COLOR_BLACK
    ) {
      this.delete_fixup(fix_node);
    }
  }
  delete_fixup(fix_node) {
    let current_node = fix_node;
    let brother_node;
    while (current_node !== this.root && current_node.parent != null && current_node.color === RB_TREE_COLOR_BLACK) {
      if (current_node === current_node.parent.left) {
        brother_node = current_node.parent.right;
        if (brother_node.color === RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_left(current_node.parent);
          brother_node = current_node.parent.right;
        }
        if (brother_node.left.color === RB_TREE_COLOR_BLACK && brother_node.right.color === RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.right.color === RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.left.color = RB_TREE_COLOR_BLACK;
            this.rotate_right(brother_node);
            brother_node = current_node.parent.right;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.right.color = RB_TREE_COLOR_BLACK;
          this.rotate_left(current_node.parent);
          current_node = this.root;
        }
      } else {
        brother_node = current_node.parent.left;
        if (brother_node.color === RB_TREE_COLOR_RED) {
          brother_node.color = RB_TREE_COLOR_BLACK;
          current_node.parent.color = RB_TREE_COLOR_RED;
          this.rotate_right(current_node.parent);
          brother_node = current_node.parent.left;
        }
        if (brother_node.left.color === RB_TREE_COLOR_BLACK && brother_node.right.color === RB_TREE_COLOR_BLACK) {
          brother_node.color = RB_TREE_COLOR_RED;
          current_node = current_node.parent;
        } else {
          if (brother_node.left.color === RB_TREE_COLOR_BLACK) {
            brother_node.color = RB_TREE_COLOR_RED;
            brother_node.right.color = RB_TREE_COLOR_BLACK;
            this.rotate_left(brother_node);
            brother_node = current_node.parent.left;
          }
          brother_node.color = current_node.parent.color;
          current_node.parent.color = RB_TREE_COLOR_BLACK;
          brother_node.left.color = RB_TREE_COLOR_BLACK;
          this.rotate_right(current_node.parent);
          current_node = this.root;
        }
      }
    }
    current_node.color = RB_TREE_COLOR_BLACK;
  }
  tree_search(node, search_node) {
    if (node == null || node === this.nil_node)
      return void 0;
    if (search_node.equal_to(node)) {
      return node;
    }
    if (search_node.less_than(node)) {
      return this.tree_search(node.left, search_node);
    } else {
      return this.tree_search(node.right, search_node);
    }
  }
  tree_search_nearest_forward(node, search_node) {
    let best;
    let curr = node;
    while (curr && curr !== this.nil_node) {
      if (curr.less_than(search_node)) {
        if (curr.intersect(search_node)) {
          best = curr;
          curr = curr.left;
        } else {
          curr = curr.right;
        }
      } else {
        if (!best || curr.less_than(best)) best = curr;
        curr = curr.left;
      }
    }
    return best || null;
  }
  // Original search_interval method; container res support push() insertion
  // Search all intervals intersecting given one
  tree_search_interval(node, search_node, res) {
    if (node != null && node !== this.nil_node) {
      if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        this.tree_search_interval(node.left, search_node, res);
      }
      if (node.intersect(search_node)) {
        res.push(node);
      }
      if (node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        this.tree_search_interval(node.right, search_node, res);
      }
    }
  }
  tree_find_any_interval(node, search_node) {
    let found = false;
    if (node != null && node !== this.nil_node) {
      if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {
        found = this.tree_find_any_interval(node.left, search_node);
      }
      if (!found) {
        found = node.intersect(search_node);
      }
      if (!found && node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {
        found = this.tree_find_any_interval(node.right, search_node);
      }
    }
    return found;
  }
  local_minimum(node) {
    let node_min = node;
    while (node_min.left != null && node_min.left !== this.nil_node) {
      node_min = node_min.left;
    }
    return node_min;
  }
  // not in use
  local_maximum(node) {
    let node_max = node;
    while (node_max.right != null && node_max.right !== this.nil_node) {
      node_max = node_max.right;
    }
    return node_max;
  }
  tree_successor(node) {
    let node_successor;
    let current_node;
    let parent_node;
    if (node.right !== this.nil_node) {
      node_successor = this.local_minimum(node.right);
    } else {
      current_node = node;
      parent_node = node.parent;
      while (parent_node != null && parent_node.right === current_node) {
        current_node = parent_node;
        parent_node = parent_node.parent;
      }
      node_successor = parent_node;
    }
    return node_successor;
  }
  //           |            right-rotate(T,y)       |
  //           y            ---------------.       x
  //          / \                                  / \
  //         x   c          left-rotate(T,x)      a   y
  //        / \             <---------------         / \
  //       a   b                                    b   c
  rotate_left(x) {
    let y = x.right;
    x.right = y.left;
    if (y.left !== this.nil_node) {
      y.left.parent = x;
    }
    y.parent = x.parent;
    if (x === this.root) {
      this.root = y;
    } else {
      if (x === x.parent.left) {
        x.parent.left = y;
      } else {
        x.parent.right = y;
      }
    }
    y.left = x;
    x.parent = y;
    if (x != null && x !== this.nil_node) {
      x.update_max();
    }
    y = x.parent;
    if (y != null && y !== this.nil_node) {
      y.update_max();
    }
  }
  rotate_right(y) {
    let x = y.left;
    y.left = x.right;
    if (x.right !== this.nil_node) {
      x.right.parent = y;
    }
    x.parent = y.parent;
    if (y === this.root) {
      this.root = x;
    } else {
      if (y === y.parent.left) {
        y.parent.left = x;
      } else {
        y.parent.right = x;
      }
    }
    x.right = y;
    y.parent = x;
    if (y !== null && y !== this.nil_node) {
      y.update_max();
    }
    x = y.parent;
    if (x != null && x !== this.nil_node) {
      x.update_max();
    }
  }
  tree_walk(node, action) {
    if (node != null && node !== this.nil_node) {
      this.tree_walk(node.left, action);
      action(node);
      this.tree_walk(node.right, action);
    }
  }
  /* Return true if all red nodes have exactly two black child nodes */
  testRedBlackProperty() {
    let res = true;
    this.tree_walk(this.root, function(node) {
      if (node.color === RB_TREE_COLOR_RED) {
        if (!(node.left.color === RB_TREE_COLOR_BLACK && node.right.color === RB_TREE_COLOR_BLACK)) {
          res = false;
        }
      }
    });
    return res;
  }
  /* Throw error if not every path from root to bottom has same black height */
  testBlackHeightProperty(node) {
    let height = 0;
    let heightLeft = 0;
    let heightRight = 0;
    if (node.color === RB_TREE_COLOR_BLACK) {
      height++;
    }
    if (node.left !== this.nil_node) {
      heightLeft = this.testBlackHeightProperty(node.left);
    } else {
      heightLeft = 1;
    }
    if (node.right !== this.nil_node) {
      heightRight = this.testBlackHeightProperty(node.right);
    } else {
      heightRight = 1;
    }
    if (heightLeft !== heightRight) {
      throw new Error("Red-black height property violated");
    }
    height += heightLeft;
    return height;
  }
};

// ../packages/engine-formula/src/basics/inverted-index-cache.ts
var InvertedIndexCache = class {
  constructor() {
    /**
     * {
     *    unitId:{
     *       sheetId:{
     *          'columnIndex': {
     *              10:[1,3,4,5],
     *              5:[2,6,11,22]
     *          }
     *       }
     *    }
     * }
     */
    __publicField(this, "_cache", /* @__PURE__ */ new Map());
    __publicField(this, "_continueBuildingCache", /* @__PURE__ */ new Map());
  }
  set(unitId, sheetId, column, value, row) {
    if (!this.shouldContinueBuildingCache(unitId, sheetId, column, row)) {
      return;
    }
    let unitMap = this._cache.get(unitId);
    if (unitMap == null) {
      unitMap = /* @__PURE__ */ new Map();
      this._cache.set(unitId, unitMap);
    }
    let sheetMap = unitMap.get(sheetId);
    if (sheetMap == null) {
      sheetMap = /* @__PURE__ */ new Map();
      unitMap.set(sheetId, sheetMap);
    }
    let columnMap = sheetMap.get(column);
    if (columnMap == null) {
      columnMap = /* @__PURE__ */ new Map();
      sheetMap.set(column, columnMap);
    }
    let cellList = columnMap.get(value);
    if (cellList == null) {
      cellList = /* @__PURE__ */ new Set();
      columnMap.set(value, cellList);
    }
    cellList.add(row);
  }
  getCellValuePositions(unitId, sheetId, column) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._cache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column);
  }
  getCellPositions(unitId, sheetId, column, value, rowsInCache) {
    var _a2, _b2, _c;
    const rows = (_c = (_b2 = (_a2 = this._cache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column)) == null ? void 0 : _c.get(value);
    return rows && [...rows].filter((row) => rowsInCache.some(([start, end]) => row >= start && row <= end));
  }
  setContinueBuildingCache(unitId, sheetId, column, startRow, endRow) {
    if (column === -1 || startRow === -1 || endRow === -1) {
      return;
    }
    let unitMap = this._continueBuildingCache.get(unitId);
    if (unitMap == null) {
      unitMap = /* @__PURE__ */ new Map();
      this._continueBuildingCache.set(unitId, unitMap);
    }
    let sheetMap = unitMap.get(sheetId);
    if (sheetMap == null) {
      sheetMap = /* @__PURE__ */ new Map();
      unitMap.set(sheetId, sheetMap);
    }
    let columnMap = sheetMap.get(column);
    if (columnMap == null) {
      columnMap = new IntervalTree();
      columnMap.insert([startRow, endRow]);
      sheetMap.set(column, columnMap);
      return;
    }
    this._handleNewInterval(columnMap, startRow, endRow);
  }
  shouldContinueBuildingCache(unitId, sheetId, column, row) {
    var _a2, _b2;
    if (column === -1 || row === -1) {
      return false;
    }
    const columnMap = (_b2 = (_a2 = this._continueBuildingCache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column);
    if (!columnMap) {
      return true;
    }
    const result = columnMap.search([row, row]);
    return result.length === 0;
  }
  canUseCache(unitId, sheetId, column, rangeStartRow, rangeEndRow) {
    var _a2, _b2;
    const columnMap = (_b2 = (_a2 = this._continueBuildingCache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column);
    if (column === -1 || rangeStartRow === -1 || rangeEndRow === -1 || !columnMap) {
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    }
    const result = columnMap.search([rangeStartRow, rangeEndRow]);
    if (result.length === 0) {
      return {
        rowsInCache: [],
        rowsNotInCache: []
      };
    }
    result.sort((a2, b) => a2[0] - b[0]);
    const rowsInCache = [];
    const rowsNotInCache = [];
    let _rangeStartRow = rangeStartRow;
    for (let i = 0; i < result.length; i++) {
      const [start, end] = result[i];
      if (_rangeStartRow >= start) {
        if (rangeEndRow <= end) {
          rowsInCache.push([_rangeStartRow, rangeEndRow]);
          break;
        }
        rowsInCache.push([_rangeStartRow, end]);
        _rangeStartRow = end + 1;
        if (i === result.length - 1 && _rangeStartRow <= rangeEndRow) {
          rowsNotInCache.push([_rangeStartRow, rangeEndRow]);
        }
      } else {
        if (rangeEndRow > end) {
          rowsInCache.push([start, end]);
          rowsNotInCache.push([_rangeStartRow, start - 1]);
          _rangeStartRow = end + 1;
          if (i === result.length - 1 && _rangeStartRow <= rangeEndRow) {
            rowsNotInCache.push([_rangeStartRow, rangeEndRow]);
          }
          continue;
        }
        rowsInCache.push([start, rangeEndRow]);
        rowsNotInCache.push([_rangeStartRow, start - 1]);
      }
    }
    return {
      rowsInCache,
      rowsNotInCache
    };
  }
  clear() {
    this._cache.clear();
    this._continueBuildingCache.clear();
  }
  _handleNewInterval(columnMap, startRow, endRow) {
    let result = columnMap.search([startRow, endRow]);
    if (result.length === 0) {
      const adjacentRange = [startRow - 1 < 0 ? 0 : startRow - 1, endRow + 1];
      result = columnMap.search(adjacentRange);
      if (result.length === 0) {
        columnMap.insert([startRow, endRow]);
        return;
      }
    }
    let min2 = startRow;
    let max2 = endRow;
    for (const interval of result) {
      min2 = Math.min(min2, interval[0]);
      max2 = Math.max(max2, interval[1]);
      columnMap.remove(interval);
    }
    columnMap.insert([min2, max2]);
  }
};
var CELL_INVERTED_INDEX_CACHE = new InvertedIndexCache();

// ../packages/engine-formula/src/controller/config.schema.ts
var ENGINE_FORMULA_PLUGIN_CONFIG_KEY = "engine-formula.config";
var DEFAULT_CYCLE_REFERENCE_COUNT = 1;
var configSymbol = Symbol(ENGINE_FORMULA_PLUGIN_CONFIG_KEY);
var defaultPluginConfig = {};

// ../packages/engine-formula/src/services/sheet-row-filtered.service.ts
var SheetRowFilteredService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_getRowFilteredCallback");
  }
  register(callback) {
    this._getRowFilteredCallback = callback;
  }
  getRowFiltered(unitId, subUnitId, row) {
    var _a2;
    if (!this._getRowFilteredCallback) {
      return false;
    }
    return (_a2 = this._getRowFilteredCallback(unitId, subUnitId, row)) != null ? _a2 : false;
  }
};
var ISheetRowFilteredService = createIdentifier(
  "univer.formula.sheet-row-filtered.service"
);

// ../packages/engine-formula/src/services/current-data.service.ts
var FormulaCurrentConfigService = class extends Disposable {
  constructor(_univerInstanceService, _localeService, _formulaDataModel, _sheetRowFilteredService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._localeService = _localeService;
    this._formulaDataModel = _formulaDataModel;
    this._sheetRowFilteredService = _sheetRowFilteredService;
    __publicField(this, "_unitData", {});
    __publicField(this, "_unitStylesData", {});
    __publicField(this, "_arrayFormulaCellData", {});
    __publicField(this, "_arrayFormulaRange", {});
    __publicField(this, "_formulaData", {});
    __publicField(this, "_sheetNameMap", {});
    __publicField(this, "_forceCalculate", false);
    __publicField(this, "_clearDependencyTreeCache", {});
    __publicField(this, "_dirtyRanges", []);
    __publicField(this, "_dirtyNameMap", {});
    __publicField(this, "_dirtyDefinedNameMap", {});
    __publicField(this, "_dirtyUnitFeatureMap", {});
    __publicField(this, "_dirtyUnitOtherFormulaMap", {});
    __publicField(this, "_excludedCell");
    __publicField(this, "_sheetIdToNameMap", {});
    __publicField(this, "_executeUnitId", "");
    __publicField(this, "_executeSubUnitId", "");
  }
  dispose() {
    super.dispose();
    this._unitData = {};
    this._unitStylesData = {};
    this._arrayFormulaCellData = {};
    this._arrayFormulaRange = {};
    this._formulaData = {};
    this._sheetNameMap = {};
    this._clearDependencyTreeCache = {};
    this._dirtyRanges = [];
    this._dirtyNameMap = {};
    this._dirtyDefinedNameMap = {};
    this._dirtyUnitFeatureMap = {};
    this._dirtyUnitOtherFormulaMap = {};
    this._excludedCell = {};
    this._sheetIdToNameMap = {};
  }
  getExecuteUnitId() {
    return this._executeUnitId;
  }
  getExecuteSubUnitId() {
    return this._executeSubUnitId;
  }
  setExecuteUnitId(unitId) {
    this._executeUnitId = unitId;
  }
  setExecuteSubUnitId(subUnitId) {
    this._executeSubUnitId = subUnitId;
  }
  getExcludedRange() {
    return this._excludedCell;
  }
  getUnitData() {
    return this._unitData;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  getFormulaData() {
    return this._formulaData;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  getArrayFormulaRange() {
    return this._arrayFormulaRange;
  }
  getSheetNameMap() {
    return this._sheetNameMap;
  }
  isForceCalculate() {
    return this._forceCalculate;
  }
  getDirtyRanges() {
    return this._dirtyRanges;
  }
  getDirtyNameMap() {
    return this._dirtyNameMap;
  }
  getDirtyDefinedNameMap() {
    return this._dirtyDefinedNameMap;
  }
  getDirtyUnitFeatureMap() {
    return this._dirtyUnitFeatureMap;
  }
  getDirtyUnitOtherFormulaMap() {
    return this._dirtyUnitOtherFormulaMap;
  }
  getSheetName(unitId, sheetId) {
    if (this._sheetIdToNameMap[unitId] == null) {
      return "";
    }
    return this._sheetIdToNameMap[unitId][sheetId] || "";
  }
  getClearDependencyTreeCache() {
    return this._clearDependencyTreeCache;
  }
  getLocale() {
    return this._localeService.getCurrentLocale();
  }
  getSheetsInfo() {
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const { id, sheetOrder } = workbook.getSnapshot();
    return {
      sheetOrder,
      sheetNameMap: this._sheetIdToNameMap[id]
    };
  }
  getSheetRowColumnCount(unitId, sheetId) {
    const workbook = this._univerInstanceService.getUnit(unitId);
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(sheetId);
    const snapshot = worksheet == null ? void 0 : worksheet.getSnapshot();
    if (!snapshot) {
      return { rowCount: 0, columnCount: 0 };
    }
    const { rowCount, columnCount } = snapshot;
    return { rowCount, columnCount };
  }
  getFilteredOutRows(unitId, sheetId, startRow, endRow) {
    const filteredOutRows = [];
    for (let r = startRow; r <= endRow; r++) {
      if (this._sheetRowFilteredService.getRowFiltered(unitId, sheetId, r)) {
        filteredOutRows.push(r);
      }
    }
    return filteredOutRows;
  }
  load(config2) {
    if (config2.allUnitData && config2.unitSheetNameMap && config2.unitStylesData) {
      this._unitData = config2.allUnitData;
      this._unitStylesData = config2.unitStylesData;
      this._sheetNameMap = config2.unitSheetNameMap;
    } else {
      const { allUnitData, unitSheetNameMap, unitStylesData } = this._loadSheetData();
      this._unitData = allUnitData;
      this._unitStylesData = unitStylesData;
      this._sheetNameMap = unitSheetNameMap;
    }
    if (config2.rowData) {
      this._applyUnitRowData(config2.rowData);
    }
    this._formulaData = config2.formulaData;
    this._arrayFormulaCellData = convertUnitDataToRuntime(config2.arrayFormulaCellData);
    this._arrayFormulaRange = config2.arrayFormulaRange;
    this._forceCalculate = config2.forceCalculate;
    this._clearDependencyTreeCache = config2.clearDependencyTreeCache || {};
    this._dirtyRanges = config2.dirtyRanges;
    this._dirtyNameMap = config2.dirtyNameMap;
    this._dirtyDefinedNameMap = config2.dirtyDefinedNameMap;
    this._dirtyUnitFeatureMap = config2.dirtyUnitFeatureMap;
    this._dirtyUnitOtherFormulaMap = config2.dirtyUnitOtherFormulaMap;
    this._excludedCell = config2.excludedCell;
    this._mergeNameMap(this._sheetNameMap, this._dirtyNameMap);
  }
  getDirtyData() {
    return {
      forceCalculation: this._forceCalculate,
      dirtyRanges: this._dirtyRanges,
      dirtyNameMap: this._dirtyNameMap,
      dirtyDefinedNameMap: this._dirtyDefinedNameMap,
      dirtyUnitFeatureMap: this._dirtyUnitFeatureMap,
      dirtyUnitOtherFormulaMap: this._dirtyUnitOtherFormulaMap,
      clearDependencyTreeCache: this._clearDependencyTreeCache
    };
  }
  loadDirtyRangesAndExcludedCell(dirtyRanges, excludedCell) {
    this._dirtyRanges = dirtyRanges;
    this._excludedCell = excludedCell;
    this._dirtyNameMap = {};
  }
  registerUnitData(unitData) {
    this._unitData = unitData;
  }
  registerFormulaData(formulaData) {
    this._formulaData = formulaData;
  }
  registerSheetNameMap(sheetNameMap) {
    this._sheetNameMap = sheetNameMap;
  }
  // private _loadOtherFormulaData() {
  //     const unitAllDoc = this._univerInstanceService.getAllUniverDocsInstance();
  //     const unitAllSlide = this._univerInstanceService.getAllUniverSlidesInstance();
  //     const otherFormulaData: IOtherFormulaData = {};
  //     for (const documentDataModel of unitAllDoc) {
  //         const unitId = documentDataModel.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const subComponent = otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID];
  //         const customRanges = documentDataModel.getBody()?.customRanges;
  //         if (customRanges == null) {
  //             continue;
  //         }
  //         for (const customRange of customRanges) {
  //             subComponent[customRange.rangeId] = {
  //                 f: customRange.endIndex.toString(),
  //             };
  //         }
  //     }
  //     for (const slide of unitAllSlide) {
  //         const unitId = slide.getUnitId();
  //         if (otherFormulaData[unitId] == null) {
  //             otherFormulaData[unitId] = {};
  //         }
  //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
  //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
  //         }
  //         const pages = slide.getPages();
  //         if (pages == null) {
  //             continue;
  //         }
  //         const pageIds = Object.keys(pages);
  //         for (const pageId of pageIds) {
  //             const page = pages[pageId];
  //             const subComponent = otherFormulaData[unitId][pageId];
  //             const pageElements = page.pageElements;
  //             if (pageElements == null) {
  //                 continue;
  //             }
  //             const pageElementIds = Object.keys(pageElements);
  //             for (const pageElementId of pageElementIds) {
  //                 const pageElement = pageElements[pageElementId];
  //                 subComponent[pageElementId] = {
  //                     f: pageElement.title,
  //                 };
  //             }
  //         }
  //     }
  //     return otherFormulaData;
  // }
  _mergeNameMap(unitSheetNameMap, dirtyNameMap) {
    Object.keys(dirtyNameMap).forEach((unitId) => {
      if (dirtyNameMap[unitId]) {
        Object.keys(dirtyNameMap[unitId]).forEach((sheetId) => {
          if (unitSheetNameMap[unitId] == null) {
            unitSheetNameMap[unitId] = {};
          }
          unitSheetNameMap[unitId][dirtyNameMap[unitId][sheetId]] = sheetId;
        });
      }
    });
    this._sheetIdToNameMap = {};
    Object.keys(unitSheetNameMap).forEach((unitId) => {
      Object.keys(unitSheetNameMap[unitId]).forEach((sheetName) => {
        if (this._sheetIdToNameMap[unitId] == null) {
          this._sheetIdToNameMap[unitId] = {};
        }
        this._sheetIdToNameMap[unitId][unitSheetNameMap[unitId][sheetName]] = sheetName;
      });
    });
  }
  _loadSheetData() {
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
    this._executeUnitId = workbook == null ? void 0 : workbook.getUnitId();
    this._executeSubUnitId = worksheet == null ? void 0 : worksheet.getSheetId();
    return this._formulaDataModel.getCalculateData();
  }
  /**
   * There is no filter information in the worker, it must be passed in from the main thread after it is ready
   * @param rowData
   */
  _applyUnitRowData(rowData) {
    for (const unitId in rowData) {
      if (rowData[unitId] == null) {
        continue;
      }
      for (const sheetId in rowData[unitId]) {
        if (rowData[unitId][sheetId] == null) {
          continue;
        }
        if (this._unitData[unitId] == null) {
          this._unitData[unitId] = {};
        }
        if (this._unitData[unitId][sheetId] == null) {
          this._unitData[unitId][sheetId] = {
            cellData: new ObjectMatrix({}),
            rowCount: 0,
            columnCount: 0,
            rowData: {},
            columnData: {}
          };
        }
        this._unitData[unitId][sheetId].rowData = rowData[unitId][sheetId];
      }
    }
  }
};
FormulaCurrentConfigService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, Inject(LocaleService)),
  __decorateParam(2, Inject(FormulaDataModel)),
  __decorateParam(3, Inject(ISheetRowFilteredService))
], FormulaCurrentConfigService);
var IFormulaCurrentConfigService = createIdentifier(
  "univer.formula.current-data.service"
);

// ../packages/engine-formula/src/engine/analysis/lexer.ts
var Lexer = class extends Disposable {
  constructor(_definedNamesService, _lexerTreeBuilder, _formulaCurrentConfigService) {
    super();
    this._definedNamesService = _definedNamesService;
    this._lexerTreeBuilder = _lexerTreeBuilder;
    this._formulaCurrentConfigService = _formulaCurrentConfigService;
  }
  treeBuilder(formulaString, transformSuffix = true) {
    return this._lexerTreeBuilder.treeBuilder(formulaString, transformSuffix, this._injectDefinedName.bind(this), this._simpleCheckDefinedName.bind(this));
  }
  _simpleCheckDefinedName(formulaString) {
    const definedNameMap = this._formulaCurrentConfigService.getDirtyDefinedNameMap();
    const executeUnitId = this._formulaCurrentConfigService.getExecuteUnitId();
    if (executeUnitId != null && definedNameMap[executeUnitId] != null) {
      const names = Object.keys(definedNameMap[executeUnitId]);
      for (let i = 0, len = names.length; i < len; i++) {
        const name = names[i];
        if (formulaString.indexOf(name) > -1) {
          return true;
        }
      }
    }
    return false;
  }
  _checkDefinedNameDirty(token) {
    const definedNameMap = this._formulaCurrentConfigService.getDirtyDefinedNameMap();
    const executeUnitId = this._formulaCurrentConfigService.getExecuteUnitId();
    if (executeUnitId != null && definedNameMap[executeUnitId] != null) {
      const names = Object.keys(definedNameMap[executeUnitId]);
      for (let i = 0, len = names.length; i < len; i++) {
        const name = names[i];
        if (name === token) {
          return true;
        }
      }
    }
    return false;
  }
  _injectDefinedName(sequenceArray) {
    const unitId = this._formulaCurrentConfigService.getExecuteUnitId();
    if (unitId == null) {
      return {
        sequenceString: "",
        hasDefinedName: false,
        definedNames: []
      };
    }
    const sequenceNodes = this._lexerTreeBuilder.getSequenceNode(sequenceArray);
    let sequenceString = "";
    let hasDefinedName = false;
    const definedNames = [];
    for (let i = 0, len = sequenceNodes.length; i < len; i++) {
      const node = sequenceNodes[i];
      if (typeof node === "string") {
        sequenceString += node;
        continue;
      }
      const { nodeType, token } = node;
      if (nodeType === 4 /* REFERENCE */ || nodeType === 3 /* FUNCTION */) {
        const definedContent = this._definedNamesService.getValueByName(unitId, token);
        if (definedContent) {
          let refString = definedContent.formulaOrRefString;
          if (refString.substring(0, 1) === "=" /* EQUALS */) {
            refString = refString.substring(1);
          }
          sequenceString += refString;
          definedNames.push(definedContent.name);
          hasDefinedName = true;
        } else if (this._checkDefinedNameDirty(token)) {
          sequenceString += "#NAME?" /* NAME */;
          hasDefinedName = true;
          definedNames.push(token);
        } else {
          sequenceString += token;
        }
      } else {
        sequenceString += token;
      }
    }
    return {
      sequenceString,
      hasDefinedName,
      definedNames
    };
  }
};
Lexer = __decorateClass([
  __decorateParam(0, IDefinedNamesService),
  __decorateParam(1, Inject(LexerTreeBuilder)),
  __decorateParam(2, IFormulaCurrentConfigService)
], Lexer);

// ../packages/engine-formula/src/basics/is-null-cell.ts
function isNullCellForFormula(cell) {
  if (cell == null) {
    return true;
  }
  const { v, f, si, p } = cell;
  if (!(v == null || typeof v === "string" && v.length === 0)) {
    return false;
  }
  if (f != null && f.length > 0 || si != null && si.length > 0) {
    return false;
  }
  if (p != null) {
    return false;
  }
  return true;
}

// ../packages/engine-formula/src/engine/utils/get-runtime-feature-cell.ts
function getRuntimeFeatureCell(row, column, sheetId, unitId, runtimeFeatureCellData) {
  var _a2;
  const featureKeys = Object.keys(runtimeFeatureCellData);
  for (const featureId of featureKeys) {
    const data = runtimeFeatureCellData[featureId];
    const CellData = (_a2 = data == null ? void 0 : data[unitId]) == null ? void 0 : _a2[sheetId];
    if (CellData == null) {
      continue;
    }
    const value = CellData.getValue(row, column);
    if (value == null) {
      continue;
    }
    return value;
  }
}

// ../packages/engine-formula/src/engine/utils/numfmt-kit.ts
var currencySymbols = [
  "$",
  "\xA3",
  "\xA5",
  "\xA4",
  "\u058F",
  "\u060B",
  "\u09F3",
  "\u0E3F",
  "\u17DB",
  "\u20A1",
  "\u20A6",
  "\u20A9",
  "\u20AA",
  "\u20AB",
  "\u20AC",
  "\u20AD",
  "\u20AE",
  "\u20B1",
  "\u20B2",
  "\u20B4",
  "\u20B8",
  "\u20B9",
  "\u20BA",
  "\u20BC",
  "\u20BD",
  "\u20BE",
  "\u20BF"
];
var NumberFormatTypeMap = {
  currency: 2 /* Currency */,
  date: 4 /* Date */,
  datetime: 5 /* Time */,
  error: 11 /* Custom */,
  fraction: 7 /* Fraction */,
  general: 0 /* General */,
  grouped: 11 /* Custom */,
  number: 1 /* Number */,
  percent: 6 /* Percentage */,
  scientific: 8 /* Scientific */,
  text: 9 /* Text */,
  time: 5 /* Time */,
  unknown: 11 /* Custom */
};
function handleNumfmtInCell(oldCell, cell, styles) {
  var _a2, _b2;
  if (oldCell == null || cell == null) {
    return cell;
  }
  const oldCellStyle = (styles == null ? void 0 : styles.getStyleByCell(oldCell)) || oldCell.s;
  const cellStyle = (styles == null ? void 0 : styles.getStyleByCell(cell)) || cell.s;
  if (oldCellStyle == null || cellStyle == null || typeof oldCellStyle !== "object" || typeof cellStyle !== "object") {
    return cell;
  }
  const oldPattern = (_a2 = oldCellStyle == null ? void 0 : oldCellStyle.n) == null ? void 0 : _a2.pattern;
  const pattern = (_b2 = cellStyle == null ? void 0 : cellStyle.n) == null ? void 0 : _b2.pattern;
  if (oldPattern == null || pattern == null) {
    return cell;
  }
  const newPattern = oldPattern || pattern;
  cellStyle.n.pattern = newPattern;
  return cell;
}
var numberFormatTypeCache = new FormulaAstLRU(1e5);
function getNumberFormatType(pattern) {
  const patternTypeCache = numberFormatTypeCache.get(pattern);
  if (patternTypeCache !== void 0) {
    return patternTypeCache;
  }
  const type2 = getNumberFormatTypeRaw(pattern);
  numberFormatTypeCache.set(pattern, type2);
  return type2;
}
function clearNumberFormatTypeCache() {
  numberFormatTypeCache.clear();
}
function getNumberFormatTypeRaw(pattern) {
  if (isAccounting(pattern)) {
    return 3 /* Accounting */;
  }
  const type2 = numfmt.getInfo(pattern).type || "unknown";
  return NumberFormatTypeMap[type2];
}
function isAccounting(pattern) {
  return !!currencySymbols.find((code) => pattern.includes(code)) && pattern.startsWith("_(");
}
function comparePatternPriority(previousPattern, nextPattern, operator) {
  if (previousPattern === "") {
    return nextPattern;
  } else if (nextPattern === "") {
    return previousPattern;
  }
  const previousPatternType = getNumberFormatType(previousPattern);
  const nextPatternType = getNumberFormatType(nextPattern);
  if (operator === "+" /* PLUS */ || operator === "-" /* MINUS */) {
    if (previousPatternType === 4 /* Date */ && nextPatternType === 4 /* Date */ || previousPatternType === 11 /* Custom */ && nextPatternType === 11 /* Custom */) {
      return "";
    }
    return nextPattern;
  }
  if (operator === "*" /* MULTIPLY */ || operator === "/" /* DIVIDED */) {
    if (previousPatternType === 6 /* Percentage */ && nextPatternType === 6 /* Percentage */ || previousPatternType === 7 /* Fraction */ && nextPatternType === 7 /* Fraction */ || previousPatternType === 8 /* Scientific */ && nextPatternType === 8 /* Scientific */ || previousPatternType === 9 /* Text */ && nextPatternType === 9 /* Text */) {
      return nextPattern;
    }
    return "";
  }
  return previousPattern || nextPattern;
}
var countryCurrencySymbolMap = /* @__PURE__ */ new Map([
  ["enUS" /* EN_US */, "$"],
  // [LocaleType.JA_JP, '¥'],
  ["ruRU" /* RU_RU */, "\u20BD"],
  ["viVN" /* VI_VN */, "\u20AB"],
  ["zhCN" /* ZH_CN */, "\xA5"],
  ["zhTW" /* ZH_TW */, "NT$"]
]);
function getCurrencySymbol(locale) {
  return countryCurrencySymbolMap.get(locale) || "$";
}
function getCurrencyFormat(locale, numberDigits = 2) {
  let _numberDigits = numberDigits;
  if (numberDigits > 127) {
    _numberDigits = 127;
  }
  let decimal = "";
  if (_numberDigits > 0) {
    decimal = `.${"0".repeat(_numberDigits)}`;
  }
  return `"${getCurrencySymbol(locale)}"#,##0${decimal}_);[Red]("${getCurrencySymbol(locale)}"#,##0${decimal})`;
}
function applyCurrencyFormat(locale, number, numberDigits = 2) {
  return numfmt.format(getCurrencyFormat(locale, numberDigits), number);
}
var stringToNumberPatternCache = new FormulaAstLRU(1e5);
function stringIsNumberPattern(input) {
  let _input = input;
  if (_input.startsWith('"') && _input.endsWith('"')) {
    _input = _input.slice(1, -1);
  }
  const cacheValue = stringToNumberPatternCache.get(_input);
  if (cacheValue) {
    return {
      isNumberPattern: true,
      value: cacheValue.value,
      pattern: cacheValue.pattern
    };
  }
  const numberPattern = numfmt.parseNumber(_input);
  if (numberPattern && numberPattern.z) {
    return setNumberPatternCache(_input, numberPattern.v, numberPattern.z);
  }
  const datePattern = numfmt.parseDate(_input);
  if (datePattern && datePattern.z) {
    return setNumberPatternCache(_input, datePattern.v, datePattern.z);
  }
  const timePattern = numfmt.parseTime(_input);
  if (timePattern && timePattern.z) {
    return setNumberPatternCache(_input, timePattern.v, timePattern.z);
  }
  return {
    isNumberPattern: false
  };
}
function setNumberPatternCache(input, value, pattern) {
  stringToNumberPatternCache.set(input, {
    value,
    pattern
  });
  return {
    isNumberPattern: true,
    value,
    pattern
  };
}
function clearStringToNumberPatternCache() {
  stringToNumberPatternCache.clear();
}

// ../packages/engine-formula/src/basics/object-class-type.ts
var ObjectClassType = class {
  constructor() {
    __publicField(this, "pattern", "");
  }
  dispose() {
  }
  getPattern() {
    return this.pattern;
  }
  /**
   * Only used in NumberValueObject
   * @param pattern
   */
  setPattern(pattern) {
    this.pattern = pattern;
  }
  isError() {
    return false;
  }
  isAsyncObject() {
    return false;
  }
  isAsyncArrayObject() {
    return false;
  }
  isReferenceObject() {
    return false;
  }
  isArray() {
    return false;
  }
  isValueObject() {
    return false;
  }
  isEqualType(object) {
    return false;
  }
};

// ../packages/engine-formula/src/engine/value-object/base-value-object.ts
var BaseValueObject = class extends ObjectClassType {
  constructor(_rawValue) {
    super();
    this._rawValue = _rawValue;
    __publicField(this, "_customData");
  }
  isValueObject() {
    return true;
  }
  toUnitRange() {
    return {
      range: {
        startColumn: -1,
        startRow: -1,
        endRow: -1,
        endColumn: -1
      },
      sheetId: "",
      unitId: ""
    };
  }
  getValue() {
    return 0;
  }
  getArrayValue() {
    return [];
  }
  setValue(value) {
  }
  setArrayValue(value) {
  }
  withCustomData(data) {
    this._customData = data;
    return this;
  }
  getCustomData() {
    return this._customData;
  }
  isCube() {
    return false;
  }
  isString() {
    return false;
  }
  isNumber() {
    return false;
  }
  isBoolean() {
    return false;
  }
  isLambda() {
    return false;
  }
  isError() {
    return false;
  }
  isNull() {
    return false;
  }
  sum() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  max() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  min() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  count() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  countA() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  countBlank() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  getNegative() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  getReciprocal() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  plus(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  minus(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  multiply(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  divided(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  mod(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  /**
   * return every value in the array after the callback function, excluding the error value
   * @param callbackFn
   * @returns
   */
  map(callbackFn) {
    return ErrorValueObject.create("#NAME?" /* NAME */);
  }
  /**
   * return every value in the array after the callback function
   * @param callbackFn
   * @returns
   */
  mapValue(callbackFn) {
    return ErrorValueObject.create("#NAME?" /* NAME */);
  }
  compare(valueObject, operator, isCaseSensitive = false) {
    return ErrorValueObject.create("#NAME?" /* NAME */);
  }
  isEqual(valueObject) {
    return this.compare(valueObject, "=" /* EQUALS */);
  }
  isNotEqual(valueObject) {
    return this.compare(valueObject, "<>" /* NOT_EQUAL */);
  }
  isGreaterThanOrEqual(valueObject) {
    return this.compare(valueObject, ">=" /* GREATER_THAN_OR_EQUAL */);
  }
  isLessThanOrEqual(valueObject) {
    return this.compare(valueObject, "<=" /* LESS_THAN_OR_EQUAL */);
  }
  isLessThan(valueObject) {
    return this.compare(valueObject, "<" /* LESS_THAN */);
  }
  isGreaterThan(valueObject) {
    return this.compare(valueObject, ">" /* GREATER_THAN */);
  }
  concatenateFront(valueObject) {
    return ErrorValueObject.create("#NAME?" /* NAME */);
  }
  concatenateBack(valueObject) {
    return ErrorValueObject.create("#NAME?" /* NAME */);
  }
  plusBy(value) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  minusBy(value) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  multiplyBy(value) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  dividedBy(value) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  modInverse(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  compareBy(value, operator) {
    return ErrorValueObject.create("#NAME?" /* NAME */);
  }
  concatenate(value, concatenateType = 0 /* FRONT */) {
    let currentValue = this.getValue().toString();
    if (typeof value === "string") {
      if (concatenateType === 0 /* FRONT */) {
        currentValue = value + currentValue;
      } else {
        currentValue += value;
      }
    } else if (typeof value === "number") {
      if (concatenateType === 0 /* FRONT */) {
        currentValue = value.toString() + currentValue;
      } else {
        currentValue += value.toString();
      }
    } else if (typeof value === "boolean") {
      const booleanString = value ? "TRUE" : "FALSE";
      if (concatenateType === 0 /* FRONT */) {
        currentValue = booleanString + currentValue;
      } else {
        currentValue += booleanString;
      }
    }
    return currentValue;
  }
  pow(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  powInverse(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  sqrt() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  cbrt() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  cos() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  cosh() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  acos() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  acosh() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  sin() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  sinh() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  asin() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  asinh() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  tan() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  tanh() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  atan() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  atan2(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  atan2Inverse(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  atanh() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  /**
   * Calculate the mean of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean
   *
   */
  mean() {
    return this;
  }
  /**
   * Calculate the median of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.median.html
   *
   */
  median() {
    return this;
  }
  /**
   * Calculate the variance of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.var.html
   */
  var() {
    return this;
  }
  /**
   * Calculate the standard deviation of the entire array.
   *
   * reference https://numpy.org/doc/stable/reference/generated/numpy.std.html
   */
  std() {
    return this;
  }
  log() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  log10() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  exp() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  abs() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  round(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  roundInverse(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  floor(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  floorInverse(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  ceil(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  ceilInverse(valueObject) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  convertToNumberObjectValue() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  convertToBooleanObjectValue() {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};
var Error_CACHE_LRU_COUNT = 1e3;
var ErrorValueObjectCache = new FormulaAstLRU(Error_CACHE_LRU_COUNT);
var ErrorValueObject = class _ErrorValueObject extends BaseValueObject {
  constructor(_errorType, _errorContent = "") {
    super(_errorType);
    this._errorType = _errorType;
    this._errorContent = _errorContent;
  }
  static create(errorType, errorContent = "") {
    const key = `${errorType}-${errorContent}`;
    const cached = ErrorValueObjectCache.get(key);
    if (cached) {
      return cached;
    }
    const instance = new _ErrorValueObject(errorType, errorContent);
    ErrorValueObjectCache.set(key, instance);
    return instance;
  }
  getValue() {
    return this._errorType;
  }
  getErrorType() {
    return this._errorType;
  }
  getErrorContent() {
    return this._errorContent;
  }
  isEqualType(object) {
    if (object.getErrorType() === this.getErrorType()) {
      return true;
    }
    return false;
  }
  isError() {
    return true;
  }
};

// ../packages/engine-numfmt/src/const.ts
var DEFAULT_TEXT_FORMAT = "@@@";
var DEFAULT_TEXT_FORMAT_EXCEL = "@";

// ../packages/engine-numfmt/src/util.ts
function isTextFormat(pattern) {
  return pattern === DEFAULT_TEXT_FORMAT || pattern === DEFAULT_TEXT_FORMAT_EXCEL;
}

// ../packages/engine-formula/src/engine/utils/cell.ts
function getCellValue(cell) {
  if (cell === null) {
    return 0;
  }
  if (cell == null ? void 0 : cell.p) {
    const body = cell == null ? void 0 : cell.p.body;
    if (body == null) {
      return 0;
    }
    const data = body.dataStream;
    const newDataStream = BuildTextUtils.transform.getPlainText(data);
    return newDataStream;
  }
  return (cell == null ? void 0 : cell.v) || 0;
}

// ../packages/engine-formula/src/engine/utils/compare.ts
function getCompare() {
  if (Intl && Intl.Collator) {
    return new Intl.Collator(void 0, { numeric: false }).compare;
  }
  return (a2, b) => {
    return a2.localeCompare(b);
  };
}
function isWildcard(str) {
  return str.indexOf("*") > -1 || str.indexOf("?") > -1;
}
function isMatchWildcard(currentValue, value) {
  const pattern = escapeRegExp(value).replace(/~?[*?]/g, (match) => {
    if (match.startsWith("~")) {
      return `\\${match.substring(1)}`;
    }
    if (match === "*") {
      return ".*";
    }
    if (match === "?") {
      return ".";
    }
    return match;
  });
  const regex = new RegExp(`^${pattern}$`);
  return regex.test(currentValue);
}
function replaceWildcard(value) {
  return value.replace(/~?[*?]/g, (match) => {
    if (match.startsWith("~")) {
      return match.substring(1);
    }
    return " ";
  });
}
function compareWithWildcard(currentValue, value, operator) {
  let result = false;
  switch (operator) {
    case "=" /* EQUALS */:
      result = isMatchWildcard(currentValue, value);
      break;
    case "<>" /* NOT_EQUAL */:
      result = !isMatchWildcard(currentValue, value);
      break;
    case ">" /* GREATER_THAN */:
    case ">=" /* GREATER_THAN_OR_EQUAL */:
      result = isMatchWildcard(currentValue, value) || currentValue > replaceWildcard(value);
      break;
    case "<" /* LESS_THAN */:
    case "<=" /* LESS_THAN_OR_EQUAL */:
      result = currentValue < replaceWildcard(value);
      break;
    default:
      break;
  }
  return result;
}
function escapeRegExp(str) {
  return str.replace(/[.+^${}()|[\]\\]/g, "\\$&");
}
function getMatchModeValue(matchModeValue) {
  switch (matchModeValue) {
    case 1:
      return 2 /* MAX */;
    case 0:
      return 0 /* NORMAL */;
    case -1:
      return 1 /* MIN */;
    default:
      return 0 /* NORMAL */;
  }
}
function getSearchModeValue(searchModeValue) {
  return searchModeValue === -2 ? 1 /* MAX */ : 0 /* MIN */;
}

// ../packages/engine-formula/src/basics/calculate.ts
function reverseCompareOperator(operator) {
  let result;
  switch (operator) {
    case "=" /* EQUALS */:
      result = "=" /* EQUALS */;
      break;
    case ">" /* GREATER_THAN */:
      result = "<" /* LESS_THAN */;
      break;
    case ">=" /* GREATER_THAN_OR_EQUAL */:
      result = "<=" /* LESS_THAN_OR_EQUAL */;
      break;
    case "<" /* LESS_THAN */:
      result = ">" /* GREATER_THAN */;
      break;
    case "<=" /* LESS_THAN_OR_EQUAL */:
      result = ">=" /* GREATER_THAN_OR_EQUAL */;
      break;
    case "<>" /* NOT_EQUAL */:
      result = "<>" /* NOT_EQUAL */;
      break;
  }
  return result;
}

// ../node_modules/.pnpm/decimal.js@10.4.3/node_modules/decimal.js/decimal.mjs
var EXP_LIMIT = 9e15;
var MAX_DIGITS = 1e9;
var NUMERALS = "0123456789abcdef";
var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
var DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
};
var inexact;
var quadrant;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var precisionLimitExceeded = decimalError + "Precision limit exceeded";
var cryptoUnavailable = decimalError + "crypto unavailable";
var tag = "[object Decimal]";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER3 = 9007199254740991;
var LN10_PRECISION = LN10.length - 1;
var PI_PRECISION = PI.length - 1;
var P = { toStringTag: tag };
P.absoluteValue = P.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0) x.s = 1;
  return finalise(x);
};
P.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P.clampedTo = P.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s) return new Ctor(NaN);
  if (min2.gt(max2)) throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P.comparedTo = P.cmp = function(y) {
  var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys) return xs;
  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P.cosine = P.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d) return new Ctor(NaN);
  if (!x.d[0]) return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P.cubeRoot = P.cbrt = function() {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;
    if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.decimalPlaces = P.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n < 0) n = 0;
  }
  return n;
};
P.dividedBy = P.div = function(y) {
  return divide(this, new this.constructor(y));
};
P.dividedToIntegerBy = P.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P.equals = P.eq = function(y) {
  return this.cmp(y) === 0;
};
P.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P.greaterThan = P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P.hyperbolicCosine = P.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i = k, d8 = new Ctor(8);
  for (; i--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.hyperbolicSine = P.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P.hyperbolicTangent = P.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P.inverseCosine = P.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P.inverseHyperbolicCosine = P.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicSine = P.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P.inverseHyperbolicTangent = P.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P.inverseSine = P.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero()) return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P.inverseTangent = P.atan = function() {
  var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
  }
  if (k) r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P.isFinite = function() {
  return !!this.d;
};
P.isInteger = P.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P.isNaN = function() {
  return !this.s;
};
P.isNegative = P.isNeg = function() {
  return this.s < 0;
};
P.isPositive = P.isPos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P.lessThan = P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.logarithm = P.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg.d;
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; ) k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P.minus = P.sub = function(y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s) y = new Ctor(NaN);
    else if (x.d) y.s = -y.s;
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0]) y.s = -y.s;
    else if (xd[0]) y = new Ctor(x);
    else return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; ) d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; ) xd.pop();
  for (; xd[0] === 0; xd.shift()) --e;
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.modulo = P.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P.naturalExponential = P.exp = function() {
  return naturalExponential(this);
};
P.naturalLogarithm = P.ln = function() {
  return naturalLogarithm(this);
};
P.negated = P.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P.plus = P.add = function(y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s) y = new Ctor(NaN);
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0]) y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; ) d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; ) xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e);
  return external ? finalise(y, pr, rm) : y;
};
P.precision = P.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k) k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P.sine = P.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P.squareRoot = P.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e) % 2 == 0) n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e, Ctor.rounding, m);
};
P.tangent = P.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P.times = P.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; ) r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; ) r.pop();
  if (carry) ++e;
  else r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P.toDecimalPlaces = P.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0) return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toFraction = function(maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd) return new Ctor(x);
  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e > 0 ? d : n1 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P.toHexadecimal = P.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d) return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d) return y.s ? x : y;
    if (!y.d) {
      if (y.s) y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P.toNumber = function() {
  return +this;
};
P.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P.toPower = P.pow = function(y) {
  var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1)) return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1)) return finalise(x, pr, rm);
  e = mathfloor(y.e / LOG_BASE);
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER3) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e < y.d.length - 1) return new Ctor(NaN);
    if ((y.d[e] & 1) == 0) s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.toSignificantDigits = P.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P.truncated = P.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P.valueOf = P.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; ) w /= 10;
  return str + w;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10) --i;
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1e3 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i = 0, strL = str.length;
  for (; i < strL; ) {
    for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0) arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero()) return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i = k; i--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry) x.unshift(carry);
    return x;
  }
  function compare(a2, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a2[i] != b[i]) {
          r = a2[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract(a2, b, aL, base) {
    var i = 0;
    for (; aL--; ) {
      a2[aL] -= i;
      i = a2[aL] < b[aL] ? 1 : 0;
      a2[aL] = i * base + a2[aL] - b[aL];
    }
    for (; !a2[0] && a2.length > 1; ) a2.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); i++) ;
    if (yd[i] > (xd[i] || 0)) e--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; ) rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2) ++yd0;
        do {
          k = 0;
          cmp = compare(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base) k = base - 1;
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;
              cmp = compare(prod, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0) cmp = k = 1;
              prod = yd.slice();
            }
            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);
            subtract(rem, prod, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0]) qd.shift();
    }
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {
      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
      q.e = i + e * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out: if (sd != null) {
    xd = x.d;
    if (!xd) return x;
    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
    i = sd - digits;
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];
      rd = w / mathpow(10, digits - j - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd.length;
      if (xdi >= k) {
        if (isTruncated) {
          for (; k++ <= xdi; ) xd.push(0);
          w = rd = 0;
          digits = 1;
          i %= LOG_BASE;
          j = i - LOG_BASE + 1;
        } else {
          break out;
        }
      } else {
        w = k = xd[xdi];
        for (digits = 1; k >= 10; k /= 10) digits++;
        i %= LOG_BASE;
        j = i - LOG_BASE + digits;
        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
      }
    }
    isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
    roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {
        sd -= x.e + 1;
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x.e = -sd || 0;
      } else {
        xd[0] = x.e = 0;
      }
      return x;
    }
    if (i == 0) {
      xd.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);
      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
    }
    if (roundUp) {
      for (; ; ) {
        if (xdi == 0) {
          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
          j = xd[0] += k;
          for (k = 1; j >= 10; j /= 10) k++;
          if (i != k) {
            x.e++;
            if (xd[0] == BASE) xd[0] = 1;
          }
          break;
        } else {
          xd[xdi] += k;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k = 1;
        }
      }
    }
    for (i = xd.length; xd[--i] === 0; ) xd.pop();
  }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite()) return nonFiniteToString(x);
  var k, e = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits, e) {
  var w = digits[0];
  for (e *= LOG_BASE; w >= 10; w /= 10) e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits) {
  var w = digits.length - 1, len = w * LOG_BASE + 1;
  w = digits[w];
  if (w) {
    for (; w % 10 == 0; w /= 10) len--;
    for (w = digits[0]; w >= 10; w /= 10) len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; ) zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k)) isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0) ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i = 0;
  for (; ++i < args.length; ) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow3, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow3 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow3 = finalise(pow3.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum2.plus(divide(pow3, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow3 = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum2 = divide(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; i++) ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;
    if (i < len) {
      if (i) x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; ) str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str)) return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str) x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i = str.search(/p/i);
  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }
  i = str.indexOf(".");
  isFloat = i >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i = len - i;
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i = xe; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat) x = divide(x, divisor, len * 4);
  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; ) ;
      if (j == -1) break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
    i++;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e) {
  var n = b;
  while (--e) n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e = len = xd.length;
    for (; xd[--len] == 0; ) xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len) ;
      for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e < 0 ? "p" : "p+") + e;
      } else if (e < 0) {
        for (; ++e; ) str = "0" + str;
        str = "0." + str;
      } else {
        if (++e > len) for (e -= len; e--; ) str += "0";
        else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs(x) {
  return new this(x).abs();
}
function acos(x) {
  return new this(x).acos();
}
function acosh(x) {
  return new this(x).acosh();
}
function add(x, y) {
  return new this(x).plus(y);
}
function asin(x) {
  return new this(x).asin();
}
function asinh(x) {
  return new this(x).asinh();
}
function atan(x) {
  return new this(x).atan();
}
function atanh(x) {
  return new this(x).atanh();
}
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }
  return r;
}
function cbrt(x) {
  return new this(x).cbrt();
}
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config(obj) {
  if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
  var i, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos(x) {
  return new this(x).cos();
}
function cosh(x) {
  return new this(x).cosh();
}
function clone(obj) {
  var i, p, ps;
  function Decimal3(v) {
    var e, i2, t, x = this;
    if (!(x instanceof Decimal3)) return new Decimal3(v);
    x.constructor = Decimal3;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal3.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal3.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
        if (external) {
          if (e > Decimal3.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal3.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i2 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i2 === 43) v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal3.prototype = P;
  Decimal3.ROUND_UP = 0;
  Decimal3.ROUND_DOWN = 1;
  Decimal3.ROUND_CEIL = 2;
  Decimal3.ROUND_FLOOR = 3;
  Decimal3.ROUND_HALF_UP = 4;
  Decimal3.ROUND_HALF_DOWN = 5;
  Decimal3.ROUND_HALF_EVEN = 6;
  Decimal3.ROUND_HALF_CEIL = 7;
  Decimal3.ROUND_HALF_FLOOR = 8;
  Decimal3.EUCLID = 9;
  Decimal3.config = Decimal3.set = config;
  Decimal3.clone = clone;
  Decimal3.isDecimal = isDecimalInstance;
  Decimal3.abs = abs;
  Decimal3.acos = acos;
  Decimal3.acosh = acosh;
  Decimal3.add = add;
  Decimal3.asin = asin;
  Decimal3.asinh = asinh;
  Decimal3.atan = atan;
  Decimal3.atanh = atanh;
  Decimal3.atan2 = atan2;
  Decimal3.cbrt = cbrt;
  Decimal3.ceil = ceil;
  Decimal3.clamp = clamp;
  Decimal3.cos = cos;
  Decimal3.cosh = cosh;
  Decimal3.div = div;
  Decimal3.exp = exp;
  Decimal3.floor = floor;
  Decimal3.hypot = hypot;
  Decimal3.ln = ln;
  Decimal3.log = log;
  Decimal3.log10 = log10;
  Decimal3.log2 = log2;
  Decimal3.max = max;
  Decimal3.min = min;
  Decimal3.mod = mod;
  Decimal3.mul = mul;
  Decimal3.pow = pow;
  Decimal3.random = random2;
  Decimal3.round = round;
  Decimal3.sign = sign;
  Decimal3.sin = sin;
  Decimal3.sinh = sinh;
  Decimal3.sqrt = sqrt;
  Decimal3.sub = sub;
  Decimal3.sum = sum;
  Decimal3.tan = tan;
  Decimal3.tanh = tanh;
  Decimal3.trunc = trunc;
  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }
  Decimal3.config(obj);
  return Decimal3;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp(x) {
  return new this(x).exp();
}
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot() {
  var i, n, t = new this(0);
  external = false;
  for (i = 0; i < arguments.length; ) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log(x, y) {
  return new this(x).log(y);
}
function log2(x) {
  return new this(x).log(2);
}
function log10(x) {
  return new this(x).log(10);
}
function max() {
  return maxOrMin(this, arguments, "lt");
}
function min() {
  return maxOrMin(this, arguments, "gt");
}
function mod(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow(x, y) {
  return new this(x).pow(y);
}
function random2(sd) {
  var d, e, k, n, i = 0, r = new this(1), rd = [];
  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i < k; ) {
      n = d[i];
      if (n >= 429e7) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i < k; ) {
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i);
      } else {
        rd.push(n % 1e7);
        i += 4;
      }
    }
    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }
  for (; rd[i] === 0; i--) rd.pop();
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
    if (k < LOG_BASE) e -= LOG_BASE - k;
  }
  r.e = e;
  r.d = rd;
  return r;
}
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin(x) {
  return new this(x).sin();
}
function sinh(x) {
  return new this(x).sinh();
}
function sqrt(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum() {
  var i = 0, args = arguments, x = new this(args[i]);
  external = false;
  for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan(x) {
  return new this(x).tan();
}
function tanh(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
var decimal_default = Decimal;

// ../packages/engine-formula/src/engine/utils/math-kit.ts
function plus(a2, b) {
  const result = a2 + b;
  if (Number.isSafeInteger(result)) {
    return result;
  }
  return new decimal_default(a2).add(b).toNumber();
}
function minus(a2, b) {
  const result = a2 - b;
  if (Number.isSafeInteger(result)) {
    return result;
  }
  return new decimal_default(a2).sub(b).toNumber();
}
function multiply(a2, b) {
  const result = a2 * b;
  if (Number.isSafeInteger(result)) {
    return result;
  }
  return new decimal_default(a2).mul(b).toNumber();
}
function divide2(a2, b) {
  const result = a2 / b;
  if (Number.isSafeInteger(result)) {
    return result;
  }
  return new decimal_default(a2).div(b).toNumber();
}
function round2(base, precision) {
  const factor = 10 ** Math.trunc(precision);
  const epsilon = baseEpsilon(base, factor);
  return Math.round(multiply(base, factor) + epsilon) / factor;
}
function floor2(base, precision) {
  const factor = 10 ** Math.trunc(precision);
  const epsilon = baseEpsilon(base, factor);
  return Math.floor(multiply(base, factor) + epsilon) / factor;
}
function ceil2(base, precision) {
  const factor = 10 ** Math.trunc(precision);
  const epsilon = baseEpsilon(base, factor);
  return Math.ceil(multiply(base, factor) - epsilon) / factor;
}
function baseEpsilon(base, factor) {
  return Number.EPSILON * Math.max(1, Math.abs(multiply(base, factor)));
}
function mod2(base, divisor) {
  return base - divisor * Math.floor(base / divisor);
}
function pow2(base, exponent) {
  return base ** exponent;
}
function sqrt2(base) {
  return Math.sqrt(base);
}
function equals(a2, b) {
  return a2 === b;
}
function greaterThan(a2, b) {
  return a2 > b;
}
function greaterThanOrEquals(a2, b) {
  return a2 >= b;
}
function lessThan(a2, b) {
  return a2 < b;
}
function lessThanOrEquals(a2, b) {
  return a2 <= b;
}
function strip(num, precision = 15) {
  return Number.parseFloat(num.toPrecision(precision));
}
function withinErrorMargin(left, right, tolerance = Number.EPSILON) {
  return Math.abs(left - right) < tolerance;
}
function stripErrorMargin(num, precision = 12, tolerance = 1e-10) {
  const stripResult = strip(num, precision);
  return withinErrorMargin(num, stripResult, tolerance) ? stripResult : strip(num);
}
function getFractionalPart(num) {
  return num - Math.trunc(num);
}

// ../packages/engine-formula/src/engine/value-object/primitive-object.ts
var _NullValueObject = class _NullValueObject extends BaseValueObject {
  static create() {
    this._instance = this._instance || new _NullValueObject(0);
    return this._instance;
  }
  isNull() {
    return true;
  }
  plus(valueObject) {
    return NumberValueObject.create(0).plus(valueObject);
  }
  minus(valueObject) {
    return NumberValueObject.create(0).minus(valueObject);
  }
  multiply(valueObject) {
    return NumberValueObject.create(0).multiply(valueObject);
  }
  divided(valueObject) {
    return NumberValueObject.create(0).divided(valueObject);
  }
  mod(valueObject) {
    return NumberValueObject.create(0).mod(valueObject);
  }
  compare(valueObject, operator) {
    if (valueObject.isString()) {
      return StringValueObject.create("").compare(valueObject, operator);
    }
    if (valueObject.isBoolean()) {
      return BooleanValueObject.create(false).compare(valueObject, operator);
    }
    return NumberValueObject.create(0).compare(valueObject, operator);
  }
  concatenateFront(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.concatenateBack(StringValueObject.create(""));
    }
    return StringValueObject.create(this.concatenate(valueObject.getValue(), 0 /* FRONT */));
  }
  concatenateBack(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.concatenateFront(StringValueObject.create(""));
    }
    return StringValueObject.create(this.concatenate(valueObject.getValue(), 1 /* BACK */));
  }
  plusBy(value) {
    return NumberValueObject.create(0).plusBy(value);
  }
  minusBy(value) {
    return NumberValueObject.create(0).minusBy(value);
  }
  multiplyBy(value) {
    return NumberValueObject.create(0).multiplyBy(value);
  }
  dividedBy(value) {
    return NumberValueObject.create(0).dividedBy(value);
  }
  compareBy(value, operator) {
    if (typeof value === "string") {
      return StringValueObject.create("").compareBy(value, operator);
    }
    if (typeof value === "boolean") {
      return BooleanValueObject.create(false).compareBy(value, operator);
    }
    return NumberValueObject.create(0).compareBy(value, operator);
  }
  pow(valueObject) {
    return NumberValueObject.create(0).pow(valueObject);
  }
  sqrt() {
    return NumberValueObject.create(0).sqrt();
  }
  cbrt() {
    return NumberValueObject.create(0).cbrt();
  }
  cos() {
    return NumberValueObject.create(0).cos();
  }
  cosh() {
    return NumberValueObject.create(0).cosh();
  }
  acos() {
    return NumberValueObject.create(0).acos();
  }
  acosh() {
    return NumberValueObject.create(0).acosh();
  }
  sin() {
    return NumberValueObject.create(0).sin();
  }
  sinh() {
    return NumberValueObject.create(0).sinh();
  }
  asin() {
    return NumberValueObject.create(0).asin();
  }
  asinh() {
    return NumberValueObject.create(0).asinh();
  }
  tan() {
    return NumberValueObject.create(0).tan();
  }
  tanh() {
    return NumberValueObject.create(0).tanh();
  }
  atan() {
    return NumberValueObject.create(0).atan();
  }
  atan2(valueObject) {
    return NumberValueObject.create(0).atan2(valueObject);
  }
  atanh() {
    return NumberValueObject.create(0).atanh();
  }
  log() {
    return ErrorValueObject.create("#NUM!" /* NUM */);
  }
  log10() {
    return ErrorValueObject.create("#NUM!" /* NUM */);
  }
  exp() {
    return NumberValueObject.create(0).exp();
  }
  abs() {
    return NumberValueObject.create(0).abs();
  }
  round(valueObject) {
    return NumberValueObject.create(0).round(valueObject);
  }
  floor(valueObject) {
    return NumberValueObject.create(0).floor(valueObject);
  }
  ceil(valueObject) {
    return NumberValueObject.create(0).ceil(valueObject);
  }
  convertToNumberObjectValue() {
    return NumberValueObject.create(0);
  }
  convertToBooleanObjectValue() {
    return BooleanValueObject.create(false);
  }
};
__publicField(_NullValueObject, "_instance");
var NullValueObject = _NullValueObject;
var _BooleanValueObject = class _BooleanValueObject extends BaseValueObject {
  constructor(rawValue) {
    super(rawValue);
    __publicField(this, "_value", false);
    this._value = rawValue;
  }
  static create(value) {
    if (value) {
      this._instanceTrue = this._instanceTrue || new _BooleanValueObject(true);
      return this._instanceTrue;
    }
    this._instanceFalse = this._instanceFalse || new _BooleanValueObject(false);
    return this._instanceFalse;
  }
  getValue() {
    return this._value;
  }
  isBoolean() {
    return true;
  }
  getNegative() {
    const currentValue = this.getValue();
    let result = 0;
    if (currentValue) {
      result = 1;
    }
    return NumberValueObject.create(-result);
  }
  getReciprocal() {
    const currentValue = this.getValue();
    if (currentValue) {
      return NumberValueObject.create(1);
    }
    return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
  }
  plus(valueObject) {
    return this._convertToNumber().plus(valueObject);
  }
  minus(valueObject) {
    return this._convertToNumber().minus(valueObject);
  }
  multiply(valueObject) {
    return this._convertToNumber().multiply(valueObject);
  }
  divided(valueObject) {
    return this._convertToNumber().divided(valueObject);
  }
  mod(valueObject) {
    return this._convertToNumber().mod(valueObject);
  }
  compare(valueObject, operator) {
    if (valueObject.isArray()) {
      return valueObject.compare(this, reverseCompareOperator(operator));
    }
    if (valueObject.isNull()) {
      return this._convertToNumber().compare(valueObject, operator);
    }
    return this.compareBy(valueObject.getValue(), operator);
  }
  compareBy(value, operator) {
    let result = false;
    if (typeof value === "string" || typeof value === "number") {
      result = this._compareString(operator);
    } else if (typeof value === "boolean") {
      const booleanNumber = NumberValueObject.create(value ? 1 : 0);
      return this._convertToNumber().compare(booleanNumber, operator);
    }
    return _BooleanValueObject.create(result);
  }
  _compareString(operator) {
    switch (operator) {
      case ">" /* GREATER_THAN */:
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        return true;
      case "=" /* EQUALS */:
      case "<" /* LESS_THAN */:
      case "<=" /* LESS_THAN_OR_EQUAL */:
      case "<>" /* NOT_EQUAL */:
        return false;
    }
  }
  concatenateFront(valueObject) {
    return this._convertToNumber().concatenateFront(valueObject);
  }
  concatenateBack(valueObject) {
    return this._convertToNumber().concatenateBack(valueObject);
  }
  _convertToNumber() {
    const currentValue = this.getValue();
    let result = 0;
    if (currentValue) {
      result = 1;
    }
    return NumberValueObject.create(result);
  }
  pow(valueObject) {
    return this._convertToNumber().pow(valueObject);
  }
  sqrt() {
    return this._convertToNumber().sqrt();
  }
  cbrt() {
    return this._convertToNumber().cbrt();
  }
  cos() {
    return this._convertToNumber().cos();
  }
  cosh() {
    return this._convertToNumber().cosh();
  }
  acos() {
    return this._convertToNumber().acos();
  }
  acosh() {
    return this._convertToNumber().acosh();
  }
  sin() {
    return this._convertToNumber().sin();
  }
  sinh() {
    return this._convertToNumber().sinh();
  }
  asin() {
    return this._convertToNumber().asin();
  }
  asinh() {
    return this._convertToNumber().asinh();
  }
  tan() {
    return this._convertToNumber().tan();
  }
  tanh() {
    return this._convertToNumber().tanh();
  }
  atan() {
    return this._convertToNumber().atan();
  }
  atan2(valueObject) {
    return this._convertToNumber().atan2(valueObject);
  }
  atanh() {
    return this._convertToNumber().atanh();
  }
  log() {
    return this._convertToNumber().log();
  }
  log10() {
    return this._convertToNumber().log10();
  }
  exp() {
    return this._convertToNumber().exp();
  }
  abs() {
    return this._convertToNumber().abs();
  }
  round(valueObject) {
    return this._convertToNumber().round(valueObject);
  }
  floor(valueObject) {
    return this._convertToNumber().floor(valueObject);
  }
  ceil(valueObject) {
    return this._convertToNumber().ceil(valueObject);
  }
  convertToNumberObjectValue() {
    return createNumberValueObjectByRawValue(this.getValue());
  }
  convertToBooleanObjectValue() {
    return this;
  }
};
__publicField(_BooleanValueObject, "_instanceTrue");
__publicField(_BooleanValueObject, "_instanceFalse");
var BooleanValueObject = _BooleanValueObject;
var NumberValueObject = class _NumberValueObject extends BaseValueObject {
  constructor(rawValue) {
    super(rawValue);
    __publicField(this, "_value", 0);
    this._value = Number(rawValue);
  }
  static create(value, pattern = "") {
    const instance = new _NumberValueObject(value);
    if (pattern) {
      instance.setPattern(pattern);
    }
    return instance;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
  }
  isNumber() {
    return true;
  }
  getNegative() {
    return _NumberValueObject.create(0).minus(this);
  }
  getReciprocal() {
    return _NumberValueObject.create(1).divided(this);
  }
  plus(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.plus(this);
    }
    let object = this.plusBy(valueObject.getValue());
    if (object.isError()) {
      return object;
    }
    const pattern = comparePatternPriority(this.getPattern(), valueObject.getPattern(), "+" /* PLUS */);
    object = _NumberValueObject.create(Number(object.getValue()), pattern);
    return object;
  }
  equalZero() {
    return this._value === 0;
  }
  minus(valueObject) {
    if (valueObject.isArray()) {
      const o = valueObject.getNegative();
      if (o.isError()) {
        return o;
      }
      return o.plus(this);
    }
    let object = this.minusBy(valueObject.getValue());
    if (object.isError()) {
      return object;
    }
    const pattern = comparePatternPriority(this.getPattern(), valueObject.getPattern(), "-" /* MINUS */);
    object = _NumberValueObject.create(Number(object.getValue()), pattern);
    return object;
  }
  multiply(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.multiply(this);
    }
    let object = this.multiplyBy(valueObject.getValue());
    if (object.isError()) {
      return object;
    }
    const pattern = comparePatternPriority(this.getPattern(), valueObject.getPattern(), "*" /* MULTIPLY */);
    object = _NumberValueObject.create(Number(object.getValue()), pattern);
    return object;
  }
  divided(valueObject) {
    if (valueObject.isArray()) {
      const o = valueObject.getReciprocal();
      if (o.isError()) {
        return o;
      }
      return o.multiply(this);
    }
    let object = this.dividedBy(valueObject.getValue());
    if (object.isError()) {
      return object;
    }
    const pattern = comparePatternPriority(this.getPattern(), valueObject.getPattern(), "/" /* DIVIDED */);
    object = _NumberValueObject.create(Number(object.getValue()), pattern);
    return object;
  }
  mod(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.modInverse(this);
    }
    const currentValue = this.getValue();
    const value = valueObject.getValue();
    if (valueObject.isNull()) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    if (typeof value === "string") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (typeof value === "number") {
      if (value === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (Math.abs(value) * 11259e8 <= Math.abs(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = mod2(currentValue, value);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    if (typeof value === "boolean") {
      const booleanValue = value ? 1 : 0;
      if (booleanValue === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return _NumberValueObject.create(mod2(currentValue, booleanValue));
    }
    return this;
  }
  concatenateFront(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.concatenateBack(this);
    }
    return StringValueObject.create(this.concatenate(valueObject.getValue(), 0 /* FRONT */));
  }
  concatenateBack(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.concatenateFront(this);
    }
    return StringValueObject.create(this.concatenate(valueObject.getValue(), 1 /* BACK */));
  }
  compare(valueObject, operator) {
    if (valueObject.isArray()) {
      return valueObject.compare(this, reverseCompareOperator(operator));
    }
    return this.compareBy(valueObject.getValue(), operator);
  }
  plusBy(value) {
    const currentValue = +this.getValue();
    const _value = +value;
    if (Number.isNaN(currentValue) || Number.isNaN(_value)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!Number.isFinite(currentValue) || !Number.isFinite(_value)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = plus(currentValue, _value);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  minusBy(value) {
    const currentValue = +this.getValue();
    const _value = +value;
    if (Number.isNaN(currentValue) || Number.isNaN(_value)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!Number.isFinite(currentValue) || !Number.isFinite(_value)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = minus(currentValue, _value);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  multiplyBy(value) {
    const currentValue = +this.getValue();
    const _value = +value;
    if (Number.isNaN(currentValue) || Number.isNaN(_value)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!Number.isFinite(currentValue) || !Number.isFinite(_value)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = multiply(currentValue, _value);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  dividedBy(value) {
    const currentValue = +this.getValue();
    const _value = +value;
    if (Number.isNaN(currentValue) || Number.isNaN(_value)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!Number.isFinite(currentValue) || !Number.isFinite(_value)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (_value === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = divide2(currentValue, _value);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  compareBy(value, operator) {
    const currentValue = this.getValue();
    let result = false;
    if (typeof value === "string") {
      result = this._compareString(operator);
    } else if (typeof value === "number") {
      result = this._compareNumber(currentValue, value, operator);
    } else if (typeof value === "boolean") {
      result = this._compareBoolean(operator);
    }
    return BooleanValueObject.create(result);
  }
  _compareString(operator) {
    switch (operator) {
      case "=" /* EQUALS */:
      case ">" /* GREATER_THAN */:
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        return false;
      case "<" /* LESS_THAN */:
      case "<=" /* LESS_THAN_OR_EQUAL */:
      case "<>" /* NOT_EQUAL */:
        return true;
    }
  }
  _compareNumber(currentValue, value, operator) {
    if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
      return this._compareInfinity(currentValue, value, operator);
    } else {
      return this._compareFiniteNumber(currentValue, value, operator);
    }
  }
  _compareFiniteNumber(currentValue, value, operator) {
    switch (operator) {
      case "=" /* EQUALS */:
        return equals(currentValue, value);
      case ">" /* GREATER_THAN */:
        return greaterThan(currentValue, value);
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        return greaterThanOrEquals(currentValue, value);
      case "<" /* LESS_THAN */:
        return lessThan(currentValue, value);
      case "<=" /* LESS_THAN_OR_EQUAL */:
        return lessThanOrEquals(currentValue, value);
      case "<>" /* NOT_EQUAL */:
        return !equals(currentValue, value);
    }
  }
  _compareBoolean(operator) {
    switch (operator) {
      case "=" /* EQUALS */:
      case ">" /* GREATER_THAN */:
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        return false;
      case "<" /* LESS_THAN */:
      case "<=" /* LESS_THAN_OR_EQUAL */:
      case "<>" /* NOT_EQUAL */:
        return true;
    }
  }
  pow(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.powInverse(this);
    }
    if (this.isError()) {
      return this;
    }
    const currentValue = this.getValue();
    let _valueObject = valueObject;
    if (valueObject.isString()) {
      _valueObject = valueObject.convertToNumberObjectValue();
    }
    if (_valueObject.isError()) {
      return _valueObject;
    }
    const value = +_valueObject.getValue();
    if (Number.isNaN(value)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (currentValue === 0) {
      if (value < 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      if (value === 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(0);
    }
    const result = pow2(currentValue, value);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  sqrt() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = sqrt2(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  cbrt() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.cbrt(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  cos() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.cos(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  cosh() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.cosh(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  acos() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.acos(currentValue);
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  acosh() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.acosh(currentValue);
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  sin() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.sin(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  sinh() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.sinh(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  asin() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.asin(currentValue);
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  asinh() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.asinh(currentValue);
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  tan() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.tan(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  tanh() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.tanh(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  atan() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.atan(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  atan2(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.atan2Inverse(this);
    }
    const currentValue = this.getValue();
    const value = valueObject.getValue();
    if (typeof value === "string") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (typeof value === "number") {
      if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (currentValue === 0 && value === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = Math.atan2(currentValue, value);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    if (typeof value === "boolean") {
      return _NumberValueObject.create(Math.atan2(currentValue, value ? 1 : 0));
    }
    return this;
  }
  atanh() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.atanh(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  log() {
    const currentValue = this.getValue();
    if (typeof currentValue === "number" && currentValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.log(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  log10() {
    const currentValue = this.getValue();
    if (typeof currentValue === "number" && currentValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.log10(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  exp() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.exp(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  abs() {
    const currentValue = this.getValue();
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.abs(currentValue);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return _NumberValueObject.create(result);
  }
  round(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.roundInverse(this);
    }
    const currentValue = this.getValue();
    const value = valueObject.getValue();
    if (typeof value === "string") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (typeof value === "number") {
      if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = currentValue < 0 ? -round2(Math.abs(currentValue), value) : round2(currentValue, value);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    if (typeof value === "boolean") {
      return _NumberValueObject.create(round2(currentValue, value ? 1 : 0));
    }
    return this;
  }
  floor(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.floorInverse(this);
    }
    const currentValue = this.getValue();
    const value = valueObject.getValue();
    if (typeof value === "string") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (typeof value === "number") {
      if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = currentValue < 0 ? -floor2(Math.abs(currentValue), value) : floor2(currentValue, value);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    if (typeof value === "boolean") {
      return _NumberValueObject.create(floor2(currentValue, value ? 1 : 0));
    }
    return this;
  }
  ceil(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.ceilInverse(this);
    }
    const currentValue = this.getValue();
    const value = valueObject.getValue();
    if (typeof value === "string") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (typeof value === "number") {
      if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = currentValue < 0 ? -ceil2(Math.abs(currentValue), value) : ceil2(currentValue, value);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    if (typeof value === "boolean") {
      return _NumberValueObject.create(ceil2(currentValue, value ? 1 : 0));
    }
    return this;
  }
  convertToNumberObjectValue() {
    return this;
  }
  convertToBooleanObjectValue() {
    return createBooleanValueObjectByRawValue(true);
  }
  _compareInfinity(currentValue, value, operator) {
    let result = false;
    switch (operator) {
      case "=" /* EQUALS */:
        result = currentValue === value;
        break;
      case ">" /* GREATER_THAN */:
        result = currentValue > value;
        break;
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        result = currentValue >= value;
        break;
      case "<" /* LESS_THAN */:
        result = currentValue < value;
        break;
      case "<=" /* LESS_THAN_OR_EQUAL */:
        result = currentValue <= value;
        break;
      case "<>" /* NOT_EQUAL */:
        result = currentValue !== value;
        break;
    }
    return result;
  }
};
var STRING_CACHE_LRU_COUNT = 1e5;
var StringValueObjectCache = new FormulaAstLRU(STRING_CACHE_LRU_COUNT);
var StringValueObject = class _StringValueObject extends BaseValueObject {
  constructor(rawValue) {
    super(rawValue);
    __publicField(this, "_value");
    this._value = rawValue;
  }
  static create(value) {
    const cached = StringValueObjectCache.get(value);
    if (cached) {
      return cached;
    }
    const instance = new _StringValueObject(value);
    StringValueObjectCache.set(value, instance);
    return instance;
  }
  getValue() {
    return this._value;
  }
  isString() {
    return true;
  }
  concatenateFront(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.concatenateBack(this);
    }
    return _StringValueObject.create(this.concatenate(valueObject.getValue(), 0 /* FRONT */));
  }
  concatenateBack(valueObject) {
    if (valueObject.isArray()) {
      return valueObject.concatenateFront(this);
    }
    return _StringValueObject.create(this.concatenate(valueObject.getValue(), 1 /* BACK */));
  }
  plus(valueObject) {
    return this.convertToNumberObjectValue().plus(valueObject);
  }
  minus(valueObject) {
    return this.convertToNumberObjectValue().minus(valueObject);
  }
  multiply(valueObject) {
    return this.convertToNumberObjectValue().multiply(valueObject);
  }
  divided(valueObject) {
    return this.convertToNumberObjectValue().divided(valueObject);
  }
  compare(valueObject, operator, isCaseSensitive) {
    if (valueObject.isArray()) {
      return valueObject.compare(this, reverseCompareOperator(operator), isCaseSensitive);
    }
    return this.compareBy(valueObject.getValue(), operator, isCaseSensitive);
  }
  compareBy(value, operator, isCaseSensitive = false) {
    let currentValue = this.getValue();
    let result = false;
    if (typeof value === "string") {
      let _value = value;
      if (!isCaseSensitive) {
        currentValue = currentValue.toLocaleLowerCase();
        _value = _value.toLocaleLowerCase();
      }
      if (isWildcard(_value)) {
        return this._checkWildcard(_value, operator);
      }
      result = this._compareString(currentValue, _value, operator);
    } else if (typeof value === "number") {
      result = this._compareNumber(operator);
    } else if (typeof value === "boolean") {
      result = this._compareBoolean(operator);
    }
    return BooleanValueObject.create(result);
  }
  _compareString(currentValue, value, operator) {
    switch (operator) {
      case "=" /* EQUALS */:
        return currentValue === value;
      case ">" /* GREATER_THAN */:
        return currentValue > value;
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        return currentValue >= value;
      case "<" /* LESS_THAN */:
        return currentValue < value;
      case "<=" /* LESS_THAN_OR_EQUAL */:
        return currentValue <= value;
      case "<>" /* NOT_EQUAL */:
        return currentValue !== value;
    }
  }
  _compareNumber(operator) {
    switch (operator) {
      case "<>" /* NOT_EQUAL */:
      case ">" /* GREATER_THAN */:
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        return true;
      case "=" /* EQUALS */:
      case "<" /* LESS_THAN */:
      case "<=" /* LESS_THAN_OR_EQUAL */:
        return false;
    }
  }
  _compareBoolean(operator) {
    switch (operator) {
      case "=" /* EQUALS */:
      case ">" /* GREATER_THAN */:
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        return false;
      case "<" /* LESS_THAN */:
      case "<=" /* LESS_THAN_OR_EQUAL */:
      case "<>" /* NOT_EQUAL */:
        return true;
    }
  }
  convertToNumberObjectValue() {
    return createNumberValueObjectByRawValue(this.getValue());
  }
  convertToBooleanObjectValue() {
    return BooleanValueObject.create(true);
  }
  _checkWildcard(value, operator) {
    const currentValue = this.getValue().toLocaleLowerCase();
    const result = compareWithWildcard(currentValue, value, operator);
    return BooleanValueObject.create(result);
  }
};
function createBooleanValueObjectByRawValue(rawValue) {
  if (typeof rawValue === "boolean") {
    return BooleanValueObject.create(rawValue);
  }
  let value = false;
  if (typeof rawValue === "string") {
    const rawValueUpper = rawValue.toLocaleUpperCase();
    if (rawValueUpper === "TRUE" /* TRUE */) {
      value = true;
    } else if (rawValueUpper === "FALSE" /* FALSE */) {
      value = false;
    }
  } else {
    if (rawValue === 1) {
      value = true;
    } else {
      value = false;
    }
  }
  return BooleanValueObject.create(value);
}
function createStringValueObjectByRawValue(rawValue) {
  let value = rawValue.toString();
  if (value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
    value = value.slice(1, -1);
    value = value.replace(/""/g, '"');
  }
  return StringValueObject.create(value);
}
function createNumberValueObjectByRawValue(rawValue, pattern = "") {
  if (typeof rawValue === "boolean") {
    let result = 0;
    if (rawValue) {
      result = 1;
    }
    return NumberValueObject.create(result, pattern);
  } else if (typeof rawValue === "number") {
    if (!Number.isFinite(rawValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(rawValue, pattern);
  } else if (isRealNum(rawValue)) {
    return NumberValueObject.create(Number(rawValue), pattern);
  }
  return ErrorValueObject.create("#VALUE!" /* VALUE */);
}

// ../packages/engine-formula/src/engine/value-object/array-value-object.ts
function fromObjectToString(array) {
  return "";
}
function transformToValueObject(array = []) {
  const arrayValueList = [];
  for (let r = 0; r < array.length; r++) {
    const row = array[r];
    if (arrayValueList[r] == null) {
      arrayValueList[r] = [];
    }
    for (let c = 0; c < row.length; c++) {
      const cell = row[c];
      arrayValueList[r][c] = ValueObjectFactory.create(cell);
    }
  }
  return arrayValueList;
}
function transformToValue(array = []) {
  const arrayValueList = [];
  for (let r = 0; r < array.length; r++) {
    const row = array[r];
    if (arrayValueList[r] == null) {
      arrayValueList[r] = [];
    }
    for (let c = 0; c < row.length; c++) {
      const cell = row[c];
      if (cell == null) {
        arrayValueList[r][c] = null;
      } else if (cell.isError()) {
        arrayValueList[r][c] = cell.getErrorType();
      } else {
        arrayValueList[r][c] = cell.getValue();
      }
    }
  }
  return arrayValueList;
}
var ArrayValueObject = class _ArrayValueObject extends BaseValueObject {
  constructor(rawValue) {
    super(typeof rawValue === "string" ? rawValue : fromObjectToString(rawValue));
    __publicField(this, "_values", []);
    __publicField(this, "_rowCount", -1);
    __publicField(this, "_columnCount", -1);
    __publicField(this, "_unitId", "");
    __publicField(this, "_sheetId", "");
    __publicField(this, "_currentRow", -1);
    __publicField(this, "_currentColumn", -1);
    __publicField(this, "_sliceCache", /* @__PURE__ */ new Map());
    __publicField(this, "_flattenCache");
    /**
     * The default value of the array, null values in comparison results support setting to false
     */
    __publicField(this, "_defaultValue", null);
    __publicField(this, "_flattenPosition");
    this._values = this._formatValue(rawValue);
  }
  /**
   * Create an array value object based on the string or IArrayValueObject data.
   * @param rawValue
   * @returns
   */
  static create(rawValue) {
    return new _ArrayValueObject(rawValue);
  }
  /**
   * Create an array value object based on the array data.
   * @param array
   * @returns
   */
  static createByArray(array) {
    const calculateValueList = transformToValueObject(array);
    const arrayValueObjectData = {
      calculateValueList,
      rowCount: array.length,
      columnCount: array[0].length || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    };
    return new _ArrayValueObject(arrayValueObjectData);
  }
  dispose() {
    this._values = [];
    this._defaultValue = null;
    this._flattenPosition = null;
    this._clearCache();
  }
  clone() {
    return this.map((o) => {
      return o;
    });
  }
  getRowCount() {
    return this._rowCount;
  }
  setRowCount(rowCount) {
    this._rowCount = rowCount;
  }
  getColumnCount() {
    return this._columnCount;
  }
  setColumnCount(columnCount) {
    this._columnCount = columnCount;
  }
  setCurrent(row, column) {
    this._currentRow = row;
    this._currentColumn = column;
  }
  setUnitId(unitId) {
    this._unitId = unitId;
  }
  getUnitId() {
    return this._unitId;
  }
  setSheetId(sheetId) {
    this._sheetId = sheetId;
  }
  getSheetId() {
    return this._sheetId;
  }
  getCurrentRow() {
    return this._currentRow;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  getArrayValue() {
    return this._values;
  }
  setArrayValue(value) {
    this._clearCache();
    this._values = value;
  }
  isArray() {
    return true;
  }
  setDefaultValue(value) {
    this._defaultValue = value;
  }
  get(row, column) {
    var _a2;
    return ((_a2 = this._values[row]) == null ? void 0 : _a2[column]) || this._defaultValue;
  }
  getRealValue(row, column) {
    const rowValues = this._values[row];
    if (rowValues == null) {
      return null;
    }
    const v = rowValues[column];
    if (v == null) {
      return null;
    }
    return v;
  }
  getValueOrDefault(row, column) {
    return this.get(row, column) || this._defaultValue;
  }
  set(row, column, value) {
    if (row >= this._rowCount || column >= this._columnCount) {
      throw new Error("Exceeding array bounds.");
    }
    this._clearCache();
    this._values[row][column] = value;
  }
  getRangePosition() {
    const startRow = 0;
    const rowCount = this.getRowCount();
    const startColumn = 0;
    const columnCount = this.getColumnCount();
    return {
      startRow,
      endRow: rowCount - 1,
      startColumn,
      endColumn: columnCount - 1
    };
  }
  iterator(callback) {
    var _a2;
    const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
    const valueList = this.getArrayValue();
    for (let r = startRow; r <= endRow; r++) {
      for (let c = startColumn; c <= endColumn; c++) {
        if (callback(((_a2 = valueList[r]) == null ? void 0 : _a2[c]) || this._defaultValue, r, c) === false) {
          return;
        }
      }
    }
  }
  iteratorReverse(callback) {
    var _a2;
    const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
    const valueList = this.getArrayValue();
    for (let r = endRow; r >= startRow; r--) {
      for (let c = endColumn; c >= startColumn; c--) {
        if (callback(((_a2 = valueList[r]) == null ? void 0 : _a2[c]) || this._defaultValue, r, c) === false) {
          return;
        }
      }
    }
  }
  getLastTruePosition() {
    let rangeSingle;
    this.iteratorReverse((value, rowIndex, columnIndex) => {
      if ((value == null ? void 0 : value.isBoolean()) && value.getValue() === true) {
        rangeSingle = {
          row: rowIndex,
          column: columnIndex
        };
        return false;
      }
    });
    return rangeSingle;
  }
  getFirstTruePosition() {
    let rangeSingle;
    this.iterator((value, rowIndex, columnIndex) => {
      if ((value == null ? void 0 : value.isBoolean()) && value.getValue() === true) {
        rangeSingle = {
          row: rowIndex,
          column: columnIndex
        };
        return false;
      }
    });
    return rangeSingle;
  }
  getFirstCell() {
    const { startRow, startColumn } = this.getRangePosition();
    return this.get(startRow, startColumn) || this._defaultValue || NullValueObject.create();
  }
  getLastCell() {
    const { endRow, endColumn } = this.getRangePosition();
    return this.get(endRow, endColumn) || this._defaultValue || NullValueObject.create();
  }
  /**
   * Referring to matrix calculations,
   * extract the matching values from a true/false matrix based on parameters and store them in a two-dimensional array.
   * implement x[x<10]
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @param takeArray
   */
  pick(takeArray) {
    const newValue = this.pickRaw(takeArray);
    return this._createNewArray(newValue, 1, newValue[0].length);
  }
  pickRaw(takeArray) {
    const takeArrayRowCount = takeArray.getRowCount();
    const takeArrayColumnCount = takeArray.getColumnCount();
    if (takeArrayRowCount !== this._rowCount || takeArrayColumnCount !== this._columnCount) {
      return [[NullValueObject.create()]];
    }
    const newValue = [];
    newValue[0] = [];
    for (let r = 0; r < takeArrayRowCount; r++) {
      for (let c = 0; c < takeArrayColumnCount; c++) {
        const takeCell = takeArray.get(r, c);
        if (takeCell == null || takeCell.isError()) {
          continue;
        }
        if (takeCell.getValue() === true) {
          const value = this.get(r, c);
          newValue[0].push(value);
        }
      }
    }
    return newValue;
  }
  /**
   * Flatten a 2D array.
   * https://numpy.org/doc/stable/reference/generated/numpy.chararray.flatten.html#numpy.chararray.flatten
   */
  flatten() {
    if (this._flattenCache != null) {
      return this._flattenCache;
    }
    const newValue = [];
    newValue[0] = [];
    for (let r = 0; r < this._rowCount; r++) {
      for (let c = 0; c < this._columnCount; c++) {
        const value = this.get(r, c);
        newValue[0].push(value);
      }
    }
    const arrayV = this._createNewArray(newValue, 1, newValue[0].length);
    arrayV.setDefaultValue(this._defaultValue);
    this._flattenCache = arrayV;
    return arrayV;
  }
  /**
   * Flatten a 2D array.
   * In Excel, errors and blank cells are ignored, which results in a binary search that cannot strictly adhere to the number of cells.
   */
  flattenPosition() {
    if (this._flattenPosition != null) {
      return this._flattenPosition;
    }
    const stringValue = [];
    const numberValue = [];
    const stringPosition = [];
    const numberPosition = [];
    let index = 0;
    for (let r = 0; r < this._rowCount; r++) {
      for (let c = 0; c < this._columnCount; c++) {
        const value = this.get(r, c);
        if (value == null || value.isError() || value.isNull()) {
          index++;
          continue;
        }
        if (value.isString()) {
          stringValue.push(value);
          stringPosition.push(index++);
        } else {
          numberValue.push(value);
          numberPosition.push(index++);
        }
      }
    }
    const result = {
      stringArray: stringValue,
      numberArray: numberValue,
      stringPosition,
      numberPosition
    };
    this._flattenPosition = result;
    return result;
  }
  /**
   * I'm looking to perform slicing operations on 2D arrays, similar to the functionality provided by NumPy.
   * https://numpy.org/doc/stable/user/basics.indexing.html
   * @rowParam start:stop:step
   * @columnParam start:stop:step
   * @param takeArray
   */
  slice(rowParam, columnParam) {
    let rowStart = 0;
    let rowStop = this._rowCount;
    let rowStep = 1;
    let columnStart = 0;
    let columnStop = this._columnCount;
    let columnStep = 1;
    if (rowParam != null) {
      rowStart = rowParam[0] || 0;
      rowStop = rowParam[1] || this._rowCount;
      rowStep = rowParam[2] || 1;
    }
    if (columnParam != null) {
      columnStart = columnParam[0] || 0;
      columnStop = columnParam[1] || this._columnCount;
      columnStep = columnParam[2] || 1;
    }
    if (rowStart >= this._rowCount || columnStart >= this._columnCount) {
      return;
    }
    const cacheKey = `${rowStart}_${rowStop}_${rowStep}_${columnStart}_${columnStop}_${columnStep}`;
    const cache = this._sliceCache.get(cacheKey);
    if (cache != null) {
      return cache;
    }
    const result = [];
    const array = this._values;
    let result_row_index = 0;
    let result_column_index = 0;
    for (let r = rowStart; r < rowStop; r += rowStep) {
      result_column_index = 0;
      if (result[result_row_index] == null) {
        result[result_row_index] = [];
      }
      for (let c = columnStart; c < columnStop; c += columnStep) {
        if (!array[r]) {
          return;
        }
        ;
        let cell = array[r][c] || this._defaultValue;
        if (cell == null) {
          cell = NullValueObject.create();
        }
        result[result_row_index][result_column_index] = cell;
        result_column_index++;
      }
      result_row_index++;
    }
    if (result.length === 0 || result[0].length === 0) {
      return;
    }
    const startRow = rowStep > 1 ? -1 : rowStart + this._currentRow;
    const startColumn = columnStep > 1 ? -1 : columnStart + this._currentColumn;
    const newResultArray = this._createNewArray(result, result.length, result[0].length, startRow, startColumn);
    newResultArray.setDefaultValue(this._defaultValue);
    this._sliceCache.set(cacheKey, newResultArray);
    return newResultArray;
  }
  sortByRow(index) {
    const result = this._transposeArray(this._values);
    result.sort(this._sort(index));
    this._clearCache();
    this._values = this._transposeArray(result);
  }
  sortByColumn(index) {
    this._clearCache();
    this._values.sort(this._sort(index));
  }
  transpose() {
    const transposeArray = this._transposeArray(this._values);
    const rowCount = this._rowCount;
    const columnCount = this._columnCount;
    const newArray = this._createNewArray(transposeArray, columnCount, rowCount);
    newArray.setDefaultValue(this._defaultValue);
    return newArray;
  }
  /**
   * Due to the inability to effectively utilize the cache,
   * the sequential matching approach is only used for special matches in XLOOKUP and XMATCH.
   * For example, when match_mode is set to 1 and -1 for an exact match. If not found, it returns the next smaller item.
   */
  orderSearch(valueObject, searchType = 1 /* MIN */, isDesc = false, isFuzzyMatching = false) {
    let result;
    let maxOrMin2;
    let resultPosition;
    let maxOrMinPosition;
    const _handleMatch = (itemValue, row, column) => {
      if (itemValue == null) {
        return true;
      }
      let matchObject;
      if (isFuzzyMatching === true) {
        matchObject = itemValue.compare(valueObject, "=" /* EQUALS */);
      } else {
        matchObject = itemValue.isEqual(valueObject);
      }
      if ((matchObject == null ? void 0 : matchObject.getValue()) === true) {
        result = itemValue;
        resultPosition = { row, column };
        return false;
      }
      if (searchType === 2 /* MAX */) {
        if (itemValue.isGreaterThan(valueObject).getValue() === true) {
          if (maxOrMin2 == null || itemValue.minus(valueObject).abs().isLessThanOrEqual(maxOrMin2.minus(valueObject).abs()).getValue() === true) {
            maxOrMin2 = itemValue;
            maxOrMinPosition = { row, column };
          }
        }
      } else if (searchType === 1 /* MIN */) {
        if (itemValue.isLessThan(valueObject).getValue() === true) {
          if (maxOrMin2 == null || itemValue.minus(valueObject).abs().isLessThanOrEqual(maxOrMin2.minus(valueObject).abs()).getValue() === true) {
            maxOrMin2 = itemValue;
            maxOrMinPosition = { row, column };
          }
        }
      }
    };
    if (isDesc) {
      this.iteratorReverse((itemValue, r, c) => {
        return _handleMatch(itemValue, r, c);
      });
    } else {
      this.iterator((itemValue, r, c) => {
        return _handleMatch(itemValue, r, c);
      });
    }
    if (result != null) {
      return resultPosition;
    }
    if (maxOrMin2 != null) {
      return maxOrMinPosition;
    }
  }
  binarySearch(valueObject, searchType = 0 /* MIN */, matchType = 1 /* MIN */) {
    if (valueObject.isError()) {
      return;
    }
    const { stringArray, stringPosition, numberArray, numberPosition } = this.flattenPosition();
    if (valueObject.isString()) {
      return this._binarySearch(valueObject, stringArray, stringPosition, searchType, matchType);
    }
    const result = this._binarySearch(valueObject, numberArray, numberPosition, searchType, matchType);
    return result;
  }
  /**
   * searchType defaults to ascending order
   *
   * matchType defaults to the maximum value less than the search value, which is used for the default matching mode of VLOOKUP/LOOKUP/HLOOKUP.
   * @param valueObject
   * @param searchArray
   * @param positionArray
   * @param searchType
   * @param matchType
   * @returns
   */
  _binarySearch(valueObject, searchArray2, positionArray, searchType = 0 /* MIN */, matchType = 1 /* MIN */) {
    const compareFunc = getCompare();
    const value = Number(valueObject.getValue());
    const isValueNumber = !Number.isNaN(value);
    let start = 0;
    let end = searchArray2.length - 1;
    let exactMatchIndex = -1;
    let nearestSmallerIndex = -1;
    let nearestLargerIndex = -1;
    while (start <= end) {
      const middle = Math.floor((start + end) / 2);
      const compareTo = searchArray2[middle];
      let compareResult;
      if (compareTo.isNull()) {
        compareResult = searchType === 0 /* MIN */ ? 1 : -1;
      } else {
        const compareToValue = compareTo.getValue();
        if (isValueNumber) {
          const compareToNumber = Number(compareToValue);
          compareResult = Number.isNaN(compareToNumber) ? 1 : Math.sign(compareToNumber - value);
        } else {
          compareResult = compareFunc(compareToValue.toString().toLocaleLowerCase(), valueObject.getValue().toString().toLocaleLowerCase());
        }
      }
      if (searchType === 1 /* MAX */) {
        compareResult = -compareResult;
      }
      if (compareResult === 0) {
        exactMatchIndex = middle;
        break;
      }
      if (compareResult < 0) {
        nearestSmallerIndex = middle;
        start = middle + 1;
      } else {
        nearestLargerIndex = middle;
        end = middle - 1;
      }
    }
    if (matchType === 0 /* NORMAL */) {
      return exactMatchIndex !== -1 ? positionArray[exactMatchIndex] : void 0;
    }
    if (matchType === 1 /* MIN */) {
      if (exactMatchIndex !== -1) return positionArray[exactMatchIndex];
      return searchType === 0 /* MIN */ ? positionArray[nearestSmallerIndex] : positionArray[nearestLargerIndex];
    }
    if (matchType === 2 /* MAX */) {
      if (exactMatchIndex !== -1) return positionArray[exactMatchIndex];
      return searchType === 0 /* MIN */ ? positionArray[nearestLargerIndex] : positionArray[nearestSmallerIndex];
    }
    return void 0;
  }
  sum() {
    let accumulatorAll = NumberValueObject.create(0);
    this.iterator((valueObject) => {
      if (valueObject == null || valueObject.isString() || valueObject.isBoolean() || valueObject.isNull()) {
        return true;
      }
      if (valueObject.isError()) {
        accumulatorAll = valueObject;
        return false;
      }
      accumulatorAll = accumulatorAll.plus(
        valueObject
      );
    });
    return accumulatorAll;
  }
  max() {
    let accumulatorAll = NumberValueObject.create(Number.NEGATIVE_INFINITY);
    this.iterator((valueObject) => {
      if (valueObject == null) {
        return true;
      }
      if (valueObject.isError()) {
        accumulatorAll = valueObject;
        return false;
      }
      if (valueObject.isString() || valueObject.isNull() || valueObject.isBoolean()) {
        return true;
      }
      const result = accumulatorAll.isLessThan(valueObject);
      if (result.getValue()) {
        accumulatorAll = valueObject;
      }
    });
    return accumulatorAll;
  }
  min() {
    let accumulatorAll = NumberValueObject.create(Number.POSITIVE_INFINITY);
    this.iterator((valueObject) => {
      if (valueObject == null) {
        return true;
      }
      if (valueObject.isError()) {
        accumulatorAll = valueObject;
        return false;
      }
      if (valueObject.isString() || valueObject.isNull() || valueObject.isBoolean()) {
        return true;
      }
      const result = accumulatorAll.isGreaterThan(valueObject);
      if (result.getValue()) {
        accumulatorAll = valueObject;
      }
    });
    return accumulatorAll;
  }
  count() {
    let accumulatorAll = NumberValueObject.create(0);
    this.iterator((valueObject) => {
      if (valueObject == null || valueObject.isError() || valueObject.isString() || valueObject.isNull() || valueObject.isBoolean()) {
        return true;
      }
      accumulatorAll = accumulatorAll.plusBy(1);
    });
    return accumulatorAll;
  }
  countA() {
    let accumulatorAll = NumberValueObject.create(0);
    this.iterator((valueObject) => {
      if (valueObject == null || valueObject.isNull()) {
        return true;
      }
      accumulatorAll = accumulatorAll.plusBy(1);
    });
    return accumulatorAll;
  }
  countBlank() {
    let accumulatorAll = NumberValueObject.create(0);
    this.iterator((valueObject) => {
      if (valueObject == null || valueObject.isNull() || valueObject.getValue() === "") {
        accumulatorAll = accumulatorAll.plusBy(1);
      }
    });
    return accumulatorAll;
  }
  getNegative() {
    const arrayValueObject = _ArrayValueObject.create("{0}");
    return arrayValueObject.minus(this);
  }
  getReciprocal() {
    const arrayValueObject = _ArrayValueObject.create("{1}");
    return arrayValueObject.divided(this);
  }
  plus(valueObject) {
    return this._batchOperator(valueObject, 1 /* PLUS */);
  }
  minus(valueObject) {
    return this._batchOperator(valueObject, 0 /* MINUS */);
  }
  multiply(valueObject) {
    return this._batchOperator(valueObject, 2 /* MULTIPLY */);
  }
  divided(valueObject) {
    return this._batchOperator(valueObject, 3 /* DIVIDED */);
  }
  mod(valueObject) {
    return this._batchOperator(valueObject, 4 /* MOD */);
  }
  modInverse(valueObject) {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return valueObject.mod(currentValue);
    });
  }
  compare(valueObject, operator, isCaseSensitive) {
    return this._batchOperator(valueObject, 5 /* COMPARE */, operator, isCaseSensitive);
  }
  concatenateFront(valueObject) {
    return this._batchOperator(valueObject, 6 /* CONCATENATE_FRONT */);
  }
  concatenateBack(valueObject) {
    return this._batchOperator(valueObject, 7 /* CONCATENATE_BACK */);
  }
  map(callbackFn) {
    const wrappedCallbackFn = (currentValue, r, c) => {
      if (currentValue == null) {
        return NullValueObject.create();
      }
      if (currentValue.isError()) {
        return currentValue;
      } else {
        return callbackFn(currentValue, r, c);
      }
    };
    return this.mapValue(wrappedCallbackFn);
  }
  mapValue(callbackFn) {
    var _a2;
    const rowCount = this._rowCount;
    const columnCount = this._columnCount;
    const result = [];
    for (let r = 0; r < rowCount; r++) {
      const rowList = [];
      for (let c = 0; c < columnCount; c++) {
        const row = (_a2 = this._values) == null ? void 0 : _a2[r];
        if (row == null) {
          rowList[c] = ErrorValueObject.create("#VALUE!" /* VALUE */);
        } else {
          const currentValue = row[c] || this._defaultValue;
          if (currentValue) {
            rowList[c] = callbackFn(currentValue, r, c);
          } else {
            rowList[c] = NullValueObject.create();
          }
        }
      }
      result.push(rowList);
    }
    return this._createNewArray(result, rowCount, columnCount);
  }
  pow(valueObject) {
    return this._batchOperator(valueObject, 8 /* POW */);
  }
  /**
   *
   * @param valueObject In the case of an inverse, it is certainly not an array.
   * @returns
   */
  powInverse(valueObject) {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return valueObject.pow(currentValue);
    });
  }
  sqrt() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.sqrt();
    });
  }
  cbrt() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.cbrt();
    });
  }
  cos() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.cos();
    });
  }
  cosh() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.cosh();
    });
  }
  acos() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.acos();
    });
  }
  acosh() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.acosh();
    });
  }
  sin() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.sin();
    });
  }
  sinh() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.sinh();
    });
  }
  asin() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.asin();
    });
  }
  asinh() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.asinh();
    });
  }
  tan() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.tan();
    });
  }
  tanh() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.tanh();
    });
  }
  atan() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.atan();
    });
  }
  atanh() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.atanh();
    });
  }
  atan2(valueObject) {
    return this._batchOperator(valueObject, 12 /* ATAN2 */);
  }
  atan2Inverse(valueObject) {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return valueObject.atan2(currentValue);
    });
  }
  mean(ddof = 0) {
    const sum2 = this.sum();
    const count = this.count();
    return sum2.divided(ddof === 0 ? count : count.minusBy(1));
  }
  median() {
    const numberArray = this.flattenPosition().numberArray;
    const allValue = this._createNewArray([numberArray], 1, numberArray.length);
    const count = allValue.getColumnCount();
    if (count <= 1) {
      return allValue.get(0, 0) || NullValueObject.create();
    }
    allValue.sortByRow(0);
    if (count % 2 === 0) {
      const medianRight = allValue.get(0, count / 2) || NullValueObject.create();
      const medianLeft = allValue.get(0, count / 2 - 1) || NullValueObject.create();
      return medianRight.plus(medianLeft).divided(NumberValueObject.create(2));
    }
    return allValue.get(0, (count - 1) / 2) || NullValueObject.create();
  }
  /**
   * ┌──────────────┬────────────────────────────────┬───────────────────┐
   * │ Function     │ Ignore logical values and text │ Type              │
   * ├──────────────┼────────────────────────────────┼───────────────────┤
   * │ VAR.S (VAR)  │ TRUE                           │ sample            │
   * │ VAR.P (VARP) │ TRUE                           │ entire population │
   * │ VARA         │ FALSE                          │ sample            │
   * │ VARPA        │ FALSE                          │ entire population │
   * └──────────────┴────────────────────────────────┴───────────────────┘
   *
   * for VARPA and VARA, strings and FALSE are counted as 0, TRUE is counted as 1
   * for VAR.S/VAR, or VAR.P/VARP, strings,TRUE and FALSE are ignored
   * Since sum ignores strings and booleans, they are ignored here too, and VAR.S and VAR.P are used more
   *
   * VAR.S assumes that its arguments are a sample of the population, like numpy.var(data, ddof=1)
   * VAR.P assumes that its arguments are the entire population, like numpy.var(data, ddof=0)
   * numpy.var uses ddof=0 (Delta Degrees of Freedom) by default, so we use ddof=0 here
   *
   */
  var(ddof = 0) {
    const mean = this.mean();
    const squaredDifferences = [[]];
    this.iterator((valueObject) => {
      if (valueObject == null || valueObject.isError() || valueObject.isString() || valueObject.isBoolean() || valueObject.isNull()) {
        return;
      }
      const baseValueObject = valueObject.minus(mean).pow(NumberValueObject.create(2));
      if (baseValueObject.isError()) {
        return;
      }
      squaredDifferences[0].push(baseValueObject);
    });
    const { _unitId, _sheetId, _currentRow, _currentColumn } = this;
    const squaredDifferencesArrayObject = _ArrayValueObject.create({
      calculateValueList: squaredDifferences,
      rowCount: 1,
      columnCount: squaredDifferences[0].length,
      unitId: _unitId,
      sheetId: _sheetId,
      row: _currentRow,
      column: _currentColumn
    });
    return squaredDifferencesArrayObject.mean(ddof);
  }
  /**
   * STDEV.P (STDEVP): ddof=0, ignore strings and booleans
   * STDEV.S (STDEV): ddof=1, ignore strings and booleans
   *
   * STDEVPA: ddof=0,
   * STDEVA: ddof=1,
   * @returns
   */
  std(ddof = 0) {
    const variance = this.var(ddof);
    if (variance.isError()) {
      return variance;
    }
    return variance.sqrt();
  }
  log() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.log();
    });
  }
  log10() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.log10();
    });
  }
  exp() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.exp();
    });
  }
  abs() {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return currentValue.abs();
    });
  }
  round(valueObject) {
    return this._batchOperator(valueObject, 9 /* ROUND */);
  }
  roundInverse(valueObject) {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return valueObject.round(currentValue);
    });
  }
  floor(valueObject) {
    return this._batchOperator(valueObject, 10 /* FLOOR */);
  }
  floorInverse(valueObject) {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return valueObject.floor(currentValue);
    });
  }
  ceil(valueObject) {
    return this._batchOperator(valueObject, 11 /* CEIL */);
  }
  ceilInverse(valueObject) {
    return this.map((currentValue) => {
      if (currentValue.isError()) {
        return currentValue;
      }
      return valueObject.ceil(currentValue);
    });
  }
  toValue() {
    return transformToValue(this._values);
  }
  _clearCache() {
    this._flattenCache = null;
    this._sliceCache.clear();
  }
  _sort(index) {
    const compare = getCompare();
    return (a2, b) => {
      const columnA = a2[index];
      const columnB = b[index];
      if (columnA == null) {
        return 1;
      }
      if (columnB == null) {
        return -1;
      }
      if (columnA.isError() && columnA.isError()) {
        return 0;
      }
      if (columnA.isError()) {
        return 1;
      }
      if (columnB.isError()) {
        return -1;
      }
      return compare(
        columnA.getValue(),
        columnB.getValue()
      );
    };
  }
  _transposeArray(array) {
    const rows = array.length;
    const cols = array[0].length;
    const transposedArray = [];
    for (let col = 0; col < cols; col++) {
      transposedArray[col] = [];
      for (let row = 0; row < rows; row++) {
        transposedArray[col][row] = array[row][col];
      }
    }
    return transposedArray;
  }
  _batchOperator(valueObject, batchOperatorType, operator, isCaseSensitive) {
    const valueList = [];
    let rowCount = this._rowCount;
    let columnCount = this._columnCount;
    if (valueObject.isArray()) {
      const valueRowCount = valueObject.getRowCount();
      const valueColumnCount = valueObject.getColumnCount();
      rowCount = Math.max(valueRowCount, rowCount);
      columnCount = Math.max(valueColumnCount, columnCount);
      if (valueRowCount === 1 && valueColumnCount === 1) {
        const v = valueObject.getFirstCell();
        for (let c = 0; c < columnCount; c++) {
          valueList.push(v);
        }
      } else if (valueRowCount === 1 && this._columnCount > 1) {
        const list = valueObject.getArrayValue();
        for (let c = 0; c < columnCount; c++) {
          valueList.push(list[0][c]);
        }
      } else {
        return this._batchOperatorArray(valueObject, batchOperatorType, operator, isCaseSensitive);
      }
    } else {
      for (let c = 0; c < columnCount; c++) {
        valueList.push(valueObject);
      }
    }
    const result = [];
    for (let c = 0; c < columnCount; c++) {
      const value = valueList[c];
      this._batchOperatorValue(value, c, result, batchOperatorType, operator, isCaseSensitive);
    }
    const newArray = this._createNewArray(result, rowCount, columnCount);
    newArray.setDefaultValue(BooleanValueObject.create(false));
    return newArray;
  }
  // eslint-disable-next-line max-lines-per-function
  _batchOperatorValue(valueObject, column, result, batchOperatorType, operator, isCaseSensitive) {
    const rowCount = this._rowCount;
    const unitId = this.getUnitId();
    const sheetId = this.getSheetId();
    const startRow = this.getCurrentRow();
    const startColumn = this.getCurrentColumn();
    if (batchOperatorType === 5 /* COMPARE */) {
      const { rowsInCache, rowsNotInCache } = CELL_INVERTED_INDEX_CACHE.canUseCache(
        unitId,
        sheetId,
        column + startColumn,
        startRow,
        startRow + rowCount - 1
      );
      if (rowsInCache.length > 0) {
        if (operator === "=" /* EQUALS */) {
          const rowPositions = CELL_INVERTED_INDEX_CACHE.getCellPositions(
            unitId,
            sheetId,
            column + startColumn,
            valueObject.getValue(),
            rowsInCache
          );
          if (rowPositions != null) {
            rowPositions.forEach((row) => {
              if (row < startRow || row > startRow + rowCount - 1) {
                return;
              }
              const r = row - startRow;
              if (result[r] == null) {
                result[r] = [];
              }
              result[r][column] = BooleanValueObject.create(true);
            });
          }
        } else {
          const rowValuePositions = CELL_INVERTED_INDEX_CACHE.getCellValuePositions(
            unitId,
            sheetId,
            column + startColumn
          );
          if (rowValuePositions != null) {
            rowValuePositions.forEach((rowPositions, rowValue) => {
              let currentValue = NullValueObject.create();
              if (ERROR_TYPE_SET.has(rowValue)) {
                currentValue = ErrorValueObject.create(rowValue);
              } else if (typeof rowValue === "string") {
                currentValue = StringValueObject.create(rowValue);
              } else if (typeof rowValue === "number") {
                currentValue = NumberValueObject.create(rowValue);
              } else if (typeof rowValue === "boolean") {
                currentValue = BooleanValueObject.create(rowValue);
              }
              let matchResult;
              if (currentValue.isError()) {
                matchResult = currentValue;
              } else if (valueObject.isError()) {
                matchResult = valueObject;
              } else {
                matchResult = currentValue.compare(valueObject, operator, isCaseSensitive);
              }
              if (matchResult.isError() || matchResult.getValue() === true) {
                rowPositions.forEach((index) => {
                  if (index >= startRow && index <= startRow + rowCount - 1) {
                    if (result[index - startRow] == null) {
                      result[index - startRow] = [];
                    }
                    result[index - startRow][column] = matchResult;
                  }
                });
              }
            });
          }
        }
        if (rowsNotInCache.length > 0) {
          for (const interval of rowsNotInCache) {
            const [start, end] = interval;
            for (let r = start; r <= end; r++) {
              this.__batchOperatorRowValue(
                valueObject,
                column,
                result,
                batchOperatorType,
                r - startRow,
                unitId,
                sheetId,
                startRow,
                startColumn,
                operator,
                isCaseSensitive
              );
            }
            CELL_INVERTED_INDEX_CACHE.setContinueBuildingCache(
              unitId,
              sheetId,
              column + startColumn,
              start,
              end
            );
          }
        }
        return;
      }
    }
    for (let r = 0; r < rowCount; r++) {
      this.__batchOperatorRowValue(
        valueObject,
        column,
        result,
        batchOperatorType,
        r,
        unitId,
        sheetId,
        startRow,
        startColumn,
        operator,
        isCaseSensitive
      );
    }
    CELL_INVERTED_INDEX_CACHE.setContinueBuildingCache(
      unitId,
      sheetId,
      column + startColumn,
      startRow,
      startRow + rowCount - 1
    );
  }
  // eslint-disable-next-line
  __batchOperatorRowValue(valueObject, column, result, batchOperatorType, r, unitId, sheetId, startRow, startColumn, operator, isCaseSensitive) {
    const currentValue = this.getValueOrDefault(r, column);
    if (result[r] == null) {
      result[r] = [];
    }
    if (currentValue && valueObject) {
      if (currentValue.isError()) {
        result[r][column] = currentValue;
      } else if (valueObject.isError()) {
        result[r][column] = valueObject;
      } else {
        switch (batchOperatorType) {
          case 1 /* PLUS */:
            result[r][column] = currentValue.plus(valueObject);
            break;
          case 0 /* MINUS */:
            result[r][column] = currentValue.minus(valueObject);
            break;
          case 2 /* MULTIPLY */:
            result[r][column] = currentValue.multiply(valueObject);
            break;
          case 3 /* DIVIDED */:
            result[r][column] = currentValue.divided(valueObject);
            break;
          case 4 /* MOD */:
            result[r][column] = currentValue.mod(valueObject);
            break;
          case 5 /* COMPARE */:
            if (!operator) {
              result[r][column] = ErrorValueObject.create("#VALUE!" /* VALUE */);
            } else {
              result[r][column] = currentValue.compare(valueObject, operator, isCaseSensitive);
            }
            break;
          case 6 /* CONCATENATE_FRONT */:
            result[r][column] = currentValue.concatenateFront(valueObject);
            break;
          case 7 /* CONCATENATE_BACK */:
            result[r][column] = currentValue.concatenateBack(valueObject);
            break;
          case 8 /* POW */:
            result[r][column] = currentValue.pow(valueObject);
            break;
          case 9 /* ROUND */:
            result[r][column] = currentValue.round(valueObject);
            break;
          case 10 /* FLOOR */:
            result[r][column] = currentValue.floor(valueObject);
            break;
          case 12 /* ATAN2 */:
            result[r][column] = currentValue.atan2(valueObject);
            break;
          case 11 /* CEIL */:
            result[r][column] = currentValue.ceil(valueObject);
            break;
        }
      }
    } else {
      result[r][column] = ErrorValueObject.create("#N/A" /* NA */);
    }
    if (currentValue == null) {
      return;
    }
    if (currentValue.isError()) {
      CELL_INVERTED_INDEX_CACHE.set(
        unitId,
        sheetId,
        column + startColumn,
        currentValue.getErrorType(),
        r + startRow
      );
    } else {
      CELL_INVERTED_INDEX_CACHE.set(
        unitId,
        sheetId,
        column + startColumn,
        currentValue.getValue(),
        r + startRow
      );
    }
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _batchOperatorArray(valueObject, batchOperatorType, operator, isCaseSensitive) {
    let rowCount = valueObject.getRowCount();
    let columnCount = valueObject.getColumnCount();
    if (rowCount < this._rowCount) {
      rowCount = this._rowCount;
    }
    if (columnCount < this._columnCount) {
      columnCount = this._columnCount;
    }
    const result = [];
    const currentCalculateType = this._checkArrayCalculateType(this);
    const opCalculateType = this._checkArrayCalculateType(valueObject);
    for (let r = 0; r < rowCount; r++) {
      const rowList = [];
      for (let c = 0; c < columnCount; c++) {
        let currentValue;
        if (currentCalculateType === 3 /* SINGLE */) {
          currentValue = this.getValueOrDefault(0, 0);
        } else if (currentCalculateType === 1 /* ROW */) {
          currentValue = this.getValueOrDefault(0, c);
        } else if (currentCalculateType === 2 /* COLUMN */) {
          currentValue = this.getValueOrDefault(r, 0);
        } else {
          currentValue = this.getValueOrDefault(r, c);
        }
        let opValue;
        if (opCalculateType === 3 /* SINGLE */) {
          opValue = valueObject.getValueOrDefault(0, 0);
        } else if (opCalculateType === 1 /* ROW */) {
          opValue = valueObject.getValueOrDefault(0, c);
        } else if (opCalculateType === 2 /* COLUMN */) {
          opValue = valueObject.getValueOrDefault(r, 0);
        } else {
          opValue = valueObject.getValueOrDefault(r, c);
        }
        if (currentValue && opValue) {
          if (currentValue.isError()) {
            rowList[c] = currentValue;
          } else if (opValue.isError()) {
            rowList[c] = opValue;
          } else {
            switch (batchOperatorType) {
              case 1 /* PLUS */:
                rowList[c] = currentValue.plus(opValue);
                break;
              case 0 /* MINUS */:
                rowList[c] = currentValue.minus(opValue);
                break;
              case 2 /* MULTIPLY */:
                rowList[c] = currentValue.multiply(opValue);
                break;
              case 3 /* DIVIDED */:
                rowList[c] = currentValue.divided(opValue);
                break;
              case 4 /* MOD */:
                rowList[c] = currentValue.mod(opValue);
                break;
              case 5 /* COMPARE */:
                if (!operator) {
                  rowList[c] = ErrorValueObject.create("#VALUE!" /* VALUE */);
                } else {
                  rowList[c] = currentValue.compare(opValue, operator, isCaseSensitive);
                }
                break;
              case 6 /* CONCATENATE_FRONT */:
                rowList[c] = currentValue.concatenateFront(opValue);
                break;
              case 7 /* CONCATENATE_BACK */:
                rowList[c] = currentValue.concatenateBack(opValue);
                break;
              case 8 /* POW */:
                rowList[c] = currentValue.pow(opValue);
                break;
              case 9 /* ROUND */:
                rowList[c] = currentValue.round(opValue);
                break;
              case 12 /* ATAN2 */:
                rowList[c] = currentValue.atan2(opValue);
                break;
              case 10 /* FLOOR */:
                rowList[c] = currentValue.floor(opValue);
                break;
              case 11 /* CEIL */:
                rowList[c] = currentValue.ceil(opValue);
                break;
            }
          }
        } else {
          rowList[c] = ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      result.push(rowList);
    }
    return this._createNewArray(result, rowCount, columnCount);
  }
  _checkArrayCalculateType(valueObject) {
    if (valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
      return 3 /* SINGLE */;
    }
    if (valueObject.getRowCount() === 1) {
      return 1 /* ROW */;
    }
    if (valueObject.getColumnCount() === 1) {
      return 2 /* COLUMN */;
    }
    return 0 /* PRODUCT */;
  }
  _formatValue(rawValue) {
    if (typeof rawValue !== "string") {
      rawValue = rawValue;
      this._rowCount = rawValue.rowCount;
      this._columnCount = rawValue.columnCount;
      this._unitId = rawValue.unitId;
      this._sheetId = rawValue.sheetId;
      this._currentRow = rawValue.row;
      this._currentColumn = rawValue.column;
      return rawValue.calculateValueList;
    }
    rawValue = rawValue.slice(1, -1);
    const rowArray = rawValue.split(";");
    const rowArrayCount = rowArray.length;
    const result = [];
    let maxColumnCount = 0;
    for (let r = 0; r < rowArrayCount; r++) {
      const columnRaw = rowArray[r];
      const columnArray = columnRaw.split(",");
      const columnArrayCount = columnArray.length;
      if (maxColumnCount < columnArrayCount) {
        maxColumnCount = columnArrayCount;
      }
      const row = [];
      for (let c = 0; c < columnArrayCount; c++) {
        const cellRaw = columnArray[c].trim();
        row.push(ValueObjectFactory.create(cellRaw));
      }
      result.push(row);
    }
    this._rowCount = rowArrayCount;
    this._columnCount = maxColumnCount;
    return result;
  }
  _createNewArray(result, rowCount, columnCount, row = -1, column = -1) {
    if (this._currentColumn === -1 || this._currentRow === -1) {
      row = -1;
      column = -1;
    }
    const arrayValueObjectData = {
      calculateValueList: result,
      rowCount,
      columnCount,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row,
      column
    };
    return _ArrayValueObject.create(arrayValueObjectData);
  }
};
var ValueObjectFactory = class {
  static create(rawValue) {
    if (rawValue == null) {
      return NullValueObject.create();
    }
    if (typeof rawValue === "boolean") {
      return BooleanValueObject.create(rawValue);
    }
    if (typeof rawValue === "string") {
      const rawValueUpper = rawValue.toLocaleUpperCase().trim();
      if (ERROR_TYPE_SET.has(rawValueUpper)) {
        return ErrorValueObject.create(rawValueUpper);
      }
      if (rawValueUpper === "TRUE" /* TRUE */ || rawValueUpper === "FALSE" /* FALSE */) {
        return createBooleanValueObjectByRawValue(rawValue);
      }
      if (isRealNum(rawValue)) {
        return NumberValueObject.create(Number(rawValue));
      }
      const { isNumberPattern, value, pattern } = stringIsNumberPattern(rawValue);
      if (isNumberPattern) {
        return NumberValueObject.create(value, pattern);
      }
      const rawValueSingleLine = rawValue.replace(/\n/g, "").replace(/\r/g, "");
      if (!isStringWrappedByDoubleQuotes(rawValueSingleLine) && regexTestArrayValue(rawValueSingleLine)) {
        return ArrayValueObject.create(rawValueSingleLine);
      }
      return createStringValueObjectByRawValue(rawValue);
    }
    if (typeof rawValue === "number") {
      return createNumberValueObjectByRawValue(rawValue);
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};
function isStringWrappedByDoubleQuotes(input) {
  const trimmedInput = input.trim();
  return trimmedInput.startsWith('"') && trimmedInput.endsWith('"');
}

// ../packages/engine-formula/src/engine/reference-object/base-reference-object.ts
var FORMULA_CACHE_LRU_COUNT2 = 1e4;
var FORMULA_REF_TO_ARRAY_CACHE = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT2);
var BaseReferenceObject = class extends ObjectClassType {
  constructor(_token) {
    super();
    this._token = _token;
    __publicField(this, "_forcedSheetId", "");
    __publicField(this, "_forcedSheetName", "");
    __publicField(this, "_defaultSheetId", "");
    __publicField(this, "_rangeData", {
      startColumn: -1,
      startRow: -1,
      endRow: -1,
      endColumn: -1
    });
    __publicField(this, "_unitData", {});
    __publicField(this, "_unitStylesData", {});
    __publicField(this, "_filteredOutRows", []);
    __publicField(this, "_defaultUnitId", "");
    __publicField(this, "_forcedUnitId", "");
    __publicField(this, "_runtimeData", {});
    __publicField(this, "_arrayFormulaCellData", {});
    __publicField(this, "_runtimeArrayFormulaCellData", {});
    __publicField(this, "_runtimeFeatureCellData", {});
    __publicField(this, "_refOffsetX", 0);
    __publicField(this, "_refOffsetY", 0);
  }
  dispose() {
    this._unitData = {};
    this._unitStylesData = {};
    this._runtimeData = {};
  }
  getToken() {
    return this._token;
  }
  setToken(token) {
    this._token = token;
  }
  isExceedRange() {
    const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
    if (startRow < 0 || startColumn < 0 || endRow >= this.getActiveSheetRowCount() || endColumn >= this.getActiveSheetColumnCount()) {
      return true;
    }
    return false;
  }
  setRefOffset(x = 0, y = 0) {
    this._refOffsetX = x;
    this._refOffsetY = y;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
  getRangePosition() {
    let { startRow, startColumn, endRow, endColumn } = moveRangeByOffset(this._rangeData, this._refOffsetX, this._refOffsetY);
    if (Number.isNaN(startRow)) {
      startRow = 0;
    }
    if (Number.isNaN(startColumn)) {
      startColumn = 0;
    }
    if (Number.isNaN(endRow)) {
      endRow = this.getActiveSheetRowCount() - 1;
    }
    if (Number.isNaN(endColumn)) {
      endColumn = this.getActiveSheetColumnCount() - 1;
    }
    return {
      ...this._rangeData,
      startRow,
      endRow,
      startColumn,
      endColumn
    };
  }
  isReferenceObject() {
    return true;
  }
  iterator(callback) {
    const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
    if (this._checkIfWorksheetMiss()) {
      return callback(ErrorValueObject.create("#VALUE!" /* VALUE */), startRow, startColumn);
    }
    const unitId = this._forcedUnitId || this._defaultUnitId;
    const sheetId = this._forcedSheetId || this._defaultSheetId;
    for (let r = startRow; r <= endRow; r++) {
      for (let c = startColumn; c <= endColumn; c++) {
        if (r < 0 || c < 0) {
          return callback(ErrorValueObject.create("#REF!" /* REF */), r, c);
        }
        const cell = this.getCellData(r, c);
        let result = false;
        if (isNullCellForFormula(cell)) {
          result = callback(null, r, c);
          continue;
        }
        let resultObjectValue = this.getCellValueObject(cell);
        if (r === startRow && c === startColumn) {
          const pattern = this.getCellPattern(unitId, sheetId, r, c);
          if (pattern && resultObjectValue.isNumber()) {
            const value = Number(resultObjectValue.getValue());
            resultObjectValue = NumberValueObject.create(value, pattern);
          }
        }
        result = callback(resultObjectValue, r, c);
        if (result === false) {
          return;
        }
      }
    }
  }
  getFirstCell() {
    const { startRow, startColumn } = this.getRangePosition();
    const cell = this.getCellData(startRow, startColumn);
    if (!cell) {
      return NumberValueObject.create(0);
    }
    let cellValueObject = this.getCellValueObject(cell);
    const unitId = this._forcedUnitId || this._defaultUnitId;
    const sheetId = this._forcedSheetId || this._defaultSheetId;
    const pattern = this.getCellPattern(unitId, sheetId, startRow, startColumn);
    if (pattern && cellValueObject.isNumber()) {
      const value = Number(cellValueObject.getValue());
      cellValueObject = NumberValueObject.create(value, pattern);
    }
    return cellValueObject;
  }
  getRangeData() {
    return this._rangeData;
  }
  setRangeData(range) {
    this._rangeData = range;
  }
  getUnitId() {
    if (this._forcedUnitId && this._forcedUnitId.length > 0) {
      return this._forcedUnitId;
    }
    return this._defaultUnitId;
  }
  getSheetId() {
    if (this._forcedSheetId && this._forcedSheetId.length > 0) {
      return this._forcedSheetId;
    }
    return this._defaultSheetId;
  }
  setForcedUnitIdDirect(unitId) {
    if (unitId.length > 0) {
      this._forcedUnitId = unitId;
    }
  }
  getForcedUnitId() {
    return this._forcedUnitId;
  }
  setForcedSheetId(sheetNameMap) {
    var _a2;
    this._forcedSheetId = (_a2 = sheetNameMap[this.getUnitId()]) == null ? void 0 : _a2[this._forcedSheetName];
  }
  setForcedSheetIdDirect(sheetId) {
    this._forcedSheetId = sheetId;
  }
  getForcedSheetId() {
    return this._forcedSheetId;
  }
  setForcedSheetName(sheetName) {
    if (sheetName.length > 0) {
      this._forcedSheetName = sheetName;
    }
  }
  getForcedSheetName() {
    return this._forcedSheetName;
  }
  setDefaultSheetId(sheetId) {
    this._defaultSheetId = sheetId;
  }
  getDefaultSheetId() {
    return this._defaultSheetId;
  }
  setDefaultUnitId(unitId) {
    this._defaultUnitId = unitId;
  }
  getDefaultUnitId() {
    return this._defaultUnitId;
  }
  getUnitData() {
    return this._unitData;
  }
  setUnitData(unitData) {
    this._unitData = unitData;
  }
  getUnitStylesData() {
    return this._unitStylesData;
  }
  setUnitStylesData(unitStylesData) {
    this._unitStylesData = unitStylesData;
  }
  getFilteredOutRows() {
    return this._filteredOutRows;
  }
  setFilteredOutRows(filteredOutRows) {
    this._filteredOutRows = filteredOutRows;
  }
  getRuntimeData() {
    return this._runtimeData;
  }
  setRuntimeData(runtimeData) {
    this._runtimeData = runtimeData;
  }
  getArrayFormulaCellData() {
    return this._arrayFormulaCellData;
  }
  setArrayFormulaCellData(unitData) {
    this._arrayFormulaCellData = unitData;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  setRuntimeArrayFormulaCellData(unitData) {
    this._runtimeArrayFormulaCellData = unitData;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(unitData) {
    this._runtimeFeatureCellData = unitData;
  }
  getActiveSheetRowCount() {
    var _a2;
    return ((_a2 = this.getCurrentActiveSheetData()) == null ? void 0 : _a2.rowCount) || 0;
  }
  getActiveSheetColumnCount() {
    var _a2;
    return ((_a2 = this.getCurrentActiveSheetData()) == null ? void 0 : _a2.columnCount) || 0;
  }
  getRowCount() {
    return this._rangeData.endRow - this._rangeData.startRow + 1;
  }
  getColumnCount() {
    return this._rangeData.endColumn - this._rangeData.startColumn + 1;
  }
  getRowData() {
    var _a2;
    return ((_a2 = this.getCurrentActiveSheetData()) == null ? void 0 : _a2.rowData) || {};
  }
  getColumnData() {
    var _a2;
    return ((_a2 = this.getCurrentActiveSheetData()) == null ? void 0 : _a2.columnData) || {};
  }
  isCell() {
    return false;
  }
  isColumn() {
    return false;
  }
  isRow() {
    return false;
  }
  isRange() {
    return false;
  }
  isTable() {
    return false;
  }
  unionBy(referenceObject) {
    return ErrorValueObject.create("#REF!" /* REF */);
  }
  unionRange(rangeData1, rangeData2) {
    return {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
  }
  getCellValueObject(cell) {
    const value = getCellValue(cell);
    if (ERROR_TYPE_SET.has(value)) {
      return ErrorValueObject.create(value);
    }
    if (cell.t === 2 /* NUMBER */) {
      const pattern = this._getPatternByCell(cell);
      if (isTextFormat(pattern)) {
        return StringValueObject.create(value.toString());
      }
      return createNumberValueObjectByRawValue(value, pattern);
    }
    if (cell.t === 1 /* STRING */ || cell.t === 4 /* FORCE_STRING */) {
      return StringValueObject.create(value.toString());
    }
    if (cell.t === 3 /* BOOLEAN */) {
      return createBooleanValueObjectByRawValue(value);
    }
    return ValueObjectFactory.create(value);
  }
  _getPatternByCell(cell) {
    var _a2;
    const styles = this._unitStylesData[this.getUnitId()];
    if (!styles) return "";
    const style = styles.getStyleByCell(cell);
    return ((_a2 = style == null ? void 0 : style.n) == null ? void 0 : _a2.pattern) || "";
  }
  getCellByRow(row) {
    return this.getCellByPosition(row);
  }
  getCellByColumn(column) {
    return this.getCellByPosition(void 0, column);
  }
  getCurrentActiveSheetData() {
    var _a2;
    return (_a2 = this._unitData[this.getUnitId()]) == null ? void 0 : _a2[this.getSheetId()];
  }
  getCurrentStylesData() {
    return this._unitStylesData[this.getUnitId()];
  }
  getCurrentRuntimeSheetData() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._runtimeData) == null ? void 0 : _a2[this.getUnitId()]) == null ? void 0 : _b2[this.getSheetId()];
  }
  getCurrentActiveArrayFormulaCellData() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._arrayFormulaCellData) == null ? void 0 : _a2[this.getUnitId()]) == null ? void 0 : _b2[this.getSheetId()];
  }
  getCurrentRuntimeActiveArrayFormulaCellData() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._runtimeArrayFormulaCellData) == null ? void 0 : _a2[this.getUnitId()]) == null ? void 0 : _b2[this.getSheetId()];
  }
  getCellData(row, column) {
    const activeSheetData = this.getCurrentActiveSheetData();
    const activeRuntimeData = this.getCurrentRuntimeSheetData();
    const activeArrayFormulaCellData = this.getCurrentActiveArrayFormulaCellData();
    const activeRuntimeArrayFormulaCellData = this.getCurrentRuntimeActiveArrayFormulaCellData();
    return (activeRuntimeData == null ? void 0 : activeRuntimeData.getValue(row, column)) || (activeRuntimeArrayFormulaCellData == null ? void 0 : activeRuntimeArrayFormulaCellData.getValue(row, column)) || this.getRuntimeFeatureCellValue(row, column) || (activeArrayFormulaCellData == null ? void 0 : activeArrayFormulaCellData.getValue(row, column)) || (activeSheetData == null ? void 0 : activeSheetData.cellData.getValue(row, column));
  }
  getRuntimeFeatureCellValue(row, column) {
    return getRuntimeFeatureCell(row, column, this.getSheetId(), this.getUnitId(), this._runtimeFeatureCellData);
  }
  getCellByPosition(rowRaw, columnRaw) {
    let row = rowRaw;
    let column = columnRaw;
    if (!row) {
      row = this._rangeData.startRow;
    }
    if (!column) {
      column = this._rangeData.startColumn;
    }
    const cell = this.getCellData(row, column);
    if (!cell) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return this.getCellValueObject(cell);
  }
  /**
   * Get the pattern of the cell
   * @param unitId
   * @param sheetId
   * @param row
   * @param column
   * @returns
   */
  getCellPattern(unitId, sheetId, row, column) {
    var _a2, _b2, _c, _d;
    const currentStyles = this._unitStylesData[unitId];
    if (!currentStyles) {
      return "";
    }
    const currentCell = (_c = (_b2 = (_a2 = this._unitData[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2.cellData) == null ? void 0 : _c.getValue(row, column);
    if (!currentCell) {
      return "";
    }
    const style = currentStyles.getStyleByCell(currentCell);
    return ((_d = style == null ? void 0 : style.n) == null ? void 0 : _d.pattern) || "";
  }
  toArrayValueObject(useCache = true) {
    var _a2;
    const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
    const key = `${this.getUnitId()}_${this.getSheetId()}_${startRow}_${endRow}_${startColumn}_${endColumn}`;
    const array = FORMULA_REF_TO_ARRAY_CACHE.get(key);
    if (array && useCache) {
      return array;
    }
    const rowSize = endRow - startRow + 1;
    const columnSize = endColumn - startColumn + 1;
    if (rowSize < 0 || columnSize < 0) {
      return this._getBlankArrayValueObject();
    }
    const arrayValueList = new Array(rowSize);
    this.iterator((valueObject, rowIndex, columnIndex) => {
      const row = rowIndex - startRow;
      const column = columnIndex - startColumn;
      if (!arrayValueList[row]) {
        arrayValueList[row] = new Array(columnSize);
      }
      if (valueObject == null) {
        valueObject = NullValueObject.create();
      }
      arrayValueList[row][column] = valueObject;
    });
    const arrayValueObjectData = {
      calculateValueList: arrayValueList,
      rowCount: arrayValueList.length,
      columnCount: ((_a2 = arrayValueList[0]) == null ? void 0 : _a2.length) || 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: startRow,
      column: startColumn
    };
    const arrayValueObject = ArrayValueObject.create(arrayValueObjectData);
    useCache && FORMULA_REF_TO_ARRAY_CACHE.set(key, arrayValueObject);
    return arrayValueObject;
  }
  toUnitRange() {
    return {
      range: this.getRangePosition(),
      sheetId: this.getSheetId(),
      unitId: this.getUnitId()
    };
  }
  _checkIfWorksheetMiss() {
    if ((this._forcedSheetId == null || this._forcedSheetId.length === 0) && this._forcedSheetName.length > 0) {
      return true;
    }
    return false;
  }
  _getBlankArrayValueObject() {
    const arrayValueObjectData = {
      calculateValueList: [],
      rowCount: 0,
      columnCount: 0,
      unitId: this.getUnitId(),
      sheetId: this.getSheetId(),
      row: 0,
      column: 0
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};
var AsyncObject = class extends ObjectClassType {
  constructor(_promise) {
    super();
    this._promise = _promise;
  }
  isAsyncObject() {
    return true;
  }
  async getValue() {
    return this._promise;
  }
};
var AsyncArrayObject = class extends ObjectClassType {
  constructor(_promiseList) {
    super();
    this._promiseList = _promiseList;
  }
  isAsyncArrayObject() {
    return true;
  }
  async getValue() {
    var _a2;
    const variants = [];
    for (let r = 0; r < this._promiseList.length; r++) {
      const promiseCells = this._promiseList[r];
      if (variants[r] == null) {
        variants[r] = [];
      }
      for (let c = 0; c < promiseCells.length; c++) {
        const promiseCell = promiseCells[c];
        if (promiseCell.isAsyncObject()) {
          variants[r][c] = await promiseCell.getValue();
        } else {
          variants[r][c] = promiseCell;
        }
      }
    }
    const arrayValueObjectData = {
      calculateValueList: variants,
      rowCount: variants.length,
      columnCount: ((_a2 = variants[0]) == null ? void 0 : _a2.length) || 0,
      unitId: "",
      sheetId: "",
      row: 0,
      column: 0
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};

// ../packages/engine-formula/src/engine/reference-object/range-reference-object.ts
var RangeReferenceObject = class extends BaseReferenceObject {
  constructor(range, forcedSheetId, forcedUnitId) {
    super("");
    this.setRangeData(range);
    if (forcedSheetId) {
      this.setForcedSheetIdDirect(forcedSheetId);
    }
    if (forcedUnitId) {
      this.setForcedUnitIdDirect(forcedUnitId);
    }
  }
  isRange() {
    return true;
  }
};

// ../packages/engine-formula/src/engine/reference-object/cell-reference-object.ts
var CellReferenceObject = class extends BaseReferenceObject {
  constructor(token) {
    super(token);
    const grid = deserializeRangeWithSheetWithCache(token);
    this.setForcedUnitIdDirect(grid.unitId);
    this.setForcedSheetName(grid.sheetName);
    this.setRangeData(grid.range);
  }
  isCell() {
    return true;
  }
  unionBy(referenceObject) {
    if (!referenceObject.isCell()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const cellReferenceObject = referenceObject;
    const newRangeData = this.unionRange(this.getRangeData(), cellReferenceObject.getRangeData());
    return this._createRange(newRangeData);
  }
  unionRange(rangeData1, rangeData2) {
    const startRow1 = rangeData1.startRow;
    const startColumn1 = rangeData1.startColumn;
    const startRow2 = rangeData2.startRow;
    const startColumn2 = rangeData2.startColumn;
    const range = {
      startRow: -1,
      startColumn: -1,
      endRow: -1,
      endColumn: -1
    };
    if (startRow1 > startRow2) {
      range.startRow = startRow2;
      range.endRow = startRow1;
    } else {
      range.startRow = startRow1;
      range.endRow = startRow2;
    }
    if (startColumn1 > startColumn2) {
      range.startColumn = startColumn2;
      range.endColumn = startColumn1;
    } else {
      range.startColumn = startColumn1;
      range.endColumn = startColumn2;
    }
    if (rangeData1.startAbsoluteRefType) {
      range.startAbsoluteRefType = rangeData1.startAbsoluteRefType;
    }
    if (rangeData2.startAbsoluteRefType) {
      range.endAbsoluteRefType = rangeData2.startAbsoluteRefType;
    }
    return range;
  }
  _createRange(newRangeData) {
    const rangeReferenceObject = new RangeReferenceObject(
      newRangeData,
      this.getForcedSheetId(),
      this.getForcedUnitId()
    );
    rangeReferenceObject.setUnitData(this.getUnitData());
    rangeReferenceObject.setDefaultSheetId(this.getDefaultSheetId());
    rangeReferenceObject.setDefaultUnitId(this.getDefaultUnitId());
    rangeReferenceObject.setRuntimeData(this.getRuntimeData());
    rangeReferenceObject.setUnitStylesData(this.getUnitStylesData());
    rangeReferenceObject.setArrayFormulaCellData(this.getArrayFormulaCellData());
    rangeReferenceObject.setRuntimeArrayFormulaCellData(this.getRuntimeArrayFormulaCellData());
    rangeReferenceObject.setRuntimeFeatureCellData(this.getRuntimeFeatureCellData());
    const { x, y } = this.getRefOffset();
    rangeReferenceObject.setRefOffset(x, y);
    const forceSheetId = this.getForcedSheetId();
    rangeReferenceObject.setForcedSheetName(this.getForcedSheetName());
    if (forceSheetId != null) {
      rangeReferenceObject.setForcedSheetIdDirect(forceSheetId);
    }
    const forcedUnitId = this.getForcedUnitId();
    if (forcedUnitId) {
      rangeReferenceObject.setForcedUnitIdDirect(forcedUnitId);
    }
    return rangeReferenceObject;
  }
};

// ../packages/engine-formula/src/engine/reference-object/column-reference-object.ts
var ColumnReferenceObject = class extends BaseReferenceObject {
  constructor(token) {
    super(token);
    const grid = deserializeRangeWithSheetWithCache(token);
    this.setForcedUnitIdDirect(grid.unitId);
    this.setForcedSheetName(grid.sheetName);
    const range = {
      ...grid.range,
      startColumn: grid.range.startColumn,
      startRow: Number.NaN,
      endColumn: grid.range.endColumn,
      endRow: Number.NaN,
      rangeType: 2 /* COLUMN */
    };
    this.setRangeData(range);
  }
  isColumn() {
    return true;
  }
  unionBy(referenceObject) {
    if (!referenceObject.isColumn()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const columnReferenceObject = referenceObject;
    if (columnReferenceObject.getForcedSheetName() !== void 0 && columnReferenceObject.getForcedSheetName() !== "") {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const currentRangeData = this.getRangeData();
    const newColumnRange = columnReferenceObject.getRangeData();
    const newColumn = newColumnRange.startColumn;
    if (newColumn >= currentRangeData.startColumn && newColumn <= currentRangeData.endColumn) {
      return this;
    }
    const column = currentRangeData.startColumn;
    if (newColumn > column) {
      currentRangeData.endColumn = newColumn;
    } else {
      currentRangeData.startColumn = newColumn;
      currentRangeData.endColumn = column;
    }
    if (newColumnRange.startAbsoluteRefType) {
      currentRangeData.endAbsoluteRefType = newColumnRange.startAbsoluteRefType;
    }
    currentRangeData.rangeType = 2 /* COLUMN */;
    this.setToken(`${this.getToken()}${":" /* COLON */}${columnReferenceObject.getToken()}`);
    return this;
  }
};

// ../packages/engine-formula/src/engine/reference-object/row-reference-object.ts
var RowReferenceObject = class extends BaseReferenceObject {
  constructor(token) {
    super(token);
    const grid = deserializeRangeWithSheetWithCache(token);
    this.setForcedUnitIdDirect(grid.unitId);
    this.setForcedSheetName(grid.sheetName);
    const range = {
      ...grid.range,
      startColumn: Number.NaN,
      startRow: grid.range.startRow,
      endColumn: Number.NaN,
      endRow: grid.range.endRow,
      rangeType: 1 /* ROW */
    };
    this.setRangeData(range);
  }
  isRow() {
    return true;
  }
  unionBy(referenceObject) {
    if (!referenceObject.isRow()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const rowReferenceObject = referenceObject;
    if (rowReferenceObject.getForcedSheetName() !== void 0 && rowReferenceObject.getForcedSheetName() !== "") {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const currentRangeData = this.getRangeData();
    const newRowRange = rowReferenceObject.getRangeData();
    const newRow = newRowRange.startRow;
    if (newRow >= currentRangeData.startRow && newRow <= currentRangeData.endRow) {
      return this;
    }
    const row = currentRangeData.startRow;
    if (newRow > row) {
      currentRangeData.endRow = newRow;
    } else {
      currentRangeData.startRow = newRow;
      currentRangeData.endRow = row;
    }
    if (newRowRange.startAbsoluteRefType) {
      currentRangeData.endAbsoluteRefType = newRowRange.startAbsoluteRefType;
    }
    currentRangeData.rangeType = 1 /* ROW */;
    this.setToken(`${this.getToken()}${":" /* COLON */}${rowReferenceObject.getToken()}`);
    return this;
  }
};

// ../packages/engine-formula/src/engine/utils/array-object.ts
function expandArrayValueObject(rowCount, columnCount, valueObject, defaultValue) {
  const valueRowCount = valueObject.isArray() ? valueObject.getRowCount() : 1;
  const valueColumnCount = valueObject.isArray() ? valueObject.getColumnCount() : 1;
  const result = [];
  for (let r = 0; r < rowCount; r++) {
    const row = [];
    for (let c = 0; c < columnCount; c++) {
      if (valueRowCount === 1 && valueColumnCount === 1) {
        const value2 = valueObject.isArray() ? valueObject.get(0, 0) : valueObject;
        row.push(value2);
        continue;
      }
      if (valueRowCount === 1 && c < valueColumnCount) {
        const value2 = valueObject.get(0, c);
        row.push(value2);
        continue;
      }
      if (valueColumnCount === 1 && r < valueRowCount) {
        const value2 = valueObject.get(r, 0);
        row.push(value2);
        continue;
      }
      if (r >= valueRowCount || c >= valueColumnCount) {
        row.push(defaultValue != null ? defaultValue : NullValueObject.create());
        continue;
      }
      const value = valueObject.get(r, c);
      row.push(value);
    }
    result.push(row);
  }
  return createNewArray(result, rowCount, columnCount);
}
function createNewArray(result, rowCount, columnCount, unitId = "", sheetId = "") {
  const arrayValueObjectData = {
    calculateValueList: result,
    rowCount,
    columnCount,
    unitId,
    sheetId,
    row: -1,
    column: -1
  };
  return ArrayValueObject.create(arrayValueObjectData);
}

// ../packages/engine-formula/src/engine/utils/object-compare.ts
function findCompareToken(str) {
  const comparisonTokens = [
    "=" /* EQUALS */,
    "<>" /* NOT_EQUAL */,
    ">=" /* GREATER_THAN_OR_EQUAL */,
    ">" /* GREATER_THAN */,
    "<=" /* LESS_THAN_OR_EQUAL */,
    "<" /* LESS_THAN */
  ];
  for (const token of comparisonTokens) {
    if (str.startsWith(token)) {
      const content = str.substring(token.length);
      return [token, ValueObjectFactory.create(content)];
    }
  }
  return ["=" /* EQUALS */, ValueObjectFactory.create(str)];
}
function valueObjectCompare(range, criteria, operator, isCaseSensitive) {
  if (!operator) {
    if (criteria.isString()) {
      const criteriaValueString = `${criteria.getValue()}`;
      const [token, criteriaStringObject] = findCompareToken(criteriaValueString);
      operator = token;
      criteria = criteriaStringObject;
    } else {
      operator = "=" /* EQUALS */;
    }
  }
  return range.compare(criteria, operator, isCaseSensitive);
}
function booleanObjectIntersection(valueObject1, valueObject2) {
  const maxRowLength = Math.max(valueObject1.isArray() ? valueObject1.getRowCount() : 1, valueObject2.isArray() ? valueObject2.getRowCount() : 1);
  const maxColumnLength = Math.max(valueObject1.isArray() ? valueObject1.getColumnCount() : 1, valueObject2.isArray() ? valueObject2.getColumnCount() : 1);
  const valueObject1Array = expandArrayValueObject(maxRowLength, maxColumnLength, valueObject1);
  const valueObject2Array = expandArrayValueObject(maxRowLength, maxColumnLength, valueObject2);
  return valueObject1Array.mapValue((valueObject12, rowIndex, columnIndex) => {
    const valueObject22 = valueObject2Array.get(rowIndex, columnIndex);
    if (valueObject12 == null ? void 0 : valueObject12.isError()) {
      return valueObject12;
    }
    if (valueObject22 == null ? void 0 : valueObject22.isError()) {
      return valueObject22;
    }
    if ((valueObject12 == null ? void 0 : valueObject12.isBoolean()) && (valueObject22 == null ? void 0 : valueObject22.isBoolean())) {
      return createBooleanValueObjectByRawValue(valueObject12.getValue() && valueObject22.getValue());
    }
    return BooleanValueObject.create(false);
  });
}

// ../packages/engine-formula/src/engine/utils/value-object.ts
function convertTonNumber(valueObject) {
  const currentValue = valueObject.getValue();
  let result = 0;
  if (currentValue) {
    result = 1;
  }
  return NumberValueObject.create(result);
}
function isSingleValueObject(valueObject) {
  if (valueObject.isArray() && valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
    return true;
  }
  if (valueObject.isReferenceObject()) {
    if (valueObject.isCell()) {
      return true;
    }
    if (valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
      return true;
    }
    return false;
  }
  valueObject = valueObject;
  if (valueObject.isString() || valueObject.isNumber() || valueObject.isBoolean() || valueObject.isError() || valueObject.isNull()) {
    return true;
  }
  return false;
}
function objectValueToCellValue(objectValue) {
  const pattern = objectValue == null ? void 0 : objectValue.getPattern();
  let cellWithStyle = {};
  let cellWithCustomData = {};
  if (pattern) {
    cellWithStyle = {
      s: {
        n: {
          pattern
        }
      }
    };
  }
  if (objectValue == null ? void 0 : objectValue.getCustomData()) {
    cellWithCustomData = {
      custom: objectValue.getCustomData()
    };
  }
  if (objectValue == null) {
    return {
      v: null,
      ...cellWithStyle
    };
  }
  if (objectValue.isError()) {
    return {
      v: objectValue.getErrorType(),
      t: 1 /* STRING */,
      ...cellWithStyle,
      ...cellWithCustomData
    };
  }
  if (objectValue.isValueObject()) {
    const vo = objectValue;
    const v = vo.getValue();
    if (vo.isNumber()) {
      return {
        v,
        t: 2 /* NUMBER */,
        ...cellWithStyle,
        ...cellWithCustomData
      };
    }
    if (vo.isBoolean()) {
      return {
        v: v ? 1 : 0,
        t: 3 /* BOOLEAN */,
        ...cellWithStyle,
        ...cellWithCustomData
      };
    }
    if (vo.isString()) {
      return {
        v,
        t: 1 /* STRING */,
        ...cellWithStyle,
        ...cellWithCustomData
      };
    }
    if (vo.isNull()) {
      return {
        v: null,
        ...cellWithStyle,
        ...cellWithCustomData
      };
    }
    return {
      v,
      t: 1 /* STRING */,
      ...cellWithStyle,
      ...cellWithCustomData
    };
  }
}
function calculateMaxDimensions(variants) {
  let maxRowLength = 0;
  let maxColumnLength = 0;
  variants.forEach((variant, i) => {
    if (i % 2 === 1) {
      if (variant.isArray()) {
        const arrayValue = variant;
        maxRowLength = Math.max(maxRowLength, arrayValue.getRowCount());
        maxColumnLength = Math.max(maxColumnLength, arrayValue.getColumnCount());
      } else {
        maxRowLength = Math.max(maxRowLength, 1);
        maxColumnLength = Math.max(maxColumnLength, 1);
      }
    }
  });
  return { maxRowLength, maxColumnLength };
}
function getErrorArray(variants, sumRange, maxRowLength, maxColumnLength) {
  const sumRowLength = sumRange.getRowCount();
  const sumColumnLength = sumRange.getColumnCount();
  for (let i = 0; i < variants.length; i++) {
    if (i % 2 === 1) continue;
    const range = variants[i];
    const rangeRowLength = range.getRowCount();
    const rangeColumnLength = range.getColumnCount();
    if (rangeRowLength !== sumRowLength || rangeColumnLength !== sumColumnLength) {
      return expandArrayValueObject(maxRowLength, maxColumnLength, ErrorValueObject.create("#VALUE!" /* VALUE */));
    }
  }
  return null;
}
function getBooleanResults(variants, maxRowLength, maxColumnLength, isNumberSensitive = false) {
  const booleanResults = [];
  for (let i = 0; i < variants.length; i++) {
    if (i % 2 === 1) continue;
    const range = variants[i];
    const criteria = variants[i + 1];
    const criteriaArray = expandArrayValueObject(maxRowLength, maxColumnLength, criteria, ErrorValueObject.create("#N/A" /* NA */));
    criteriaArray.iterator((criteriaValueObject, rowIndex, columnIndex) => {
      if (!criteriaValueObject) {
        return;
      }
      let resultArrayObject = valueObjectCompare(range, criteriaValueObject);
      if (isNumberSensitive) {
        resultArrayObject = filterSameValueObjectResult(resultArrayObject, range, criteriaValueObject);
      }
      if (booleanResults[rowIndex] === void 0) {
        booleanResults[rowIndex] = [];
      }
      if (booleanResults[rowIndex][columnIndex] === void 0) {
        booleanResults[rowIndex][columnIndex] = resultArrayObject;
        return;
      }
      booleanResults[rowIndex][columnIndex] = booleanObjectIntersection(booleanResults[rowIndex][columnIndex], resultArrayObject);
    });
  }
  return booleanResults;
}
function filterSameValueObjectResult(array, range, criteria) {
  const [operator, criteriaObject] = findCompareToken(`${criteria.getValue()}`);
  return array.mapValue((valueObject, r, c) => {
    const rangeValueObject = range.get(r, c);
    if (rangeValueObject && isSameValueObjectType(rangeValueObject, criteriaObject)) {
      return valueObject;
    } else if (rangeValueObject == null ? void 0 : rangeValueObject.isNumber()) {
      if (criteriaObject.isString()) {
        const criteriaNumber = criteriaObject.convertToNumberObjectValue();
        if (criteriaNumber.isNumber()) {
          return rangeValueObject.compare(criteriaNumber, operator);
        }
      }
      return BooleanValueObject.create(false);
    } else if (criteriaObject.isNumber()) {
      if (rangeValueObject == null ? void 0 : rangeValueObject.isString()) {
        const rangeNumber = rangeValueObject.convertToNumberObjectValue();
        if (rangeNumber.isNumber()) {
          return rangeNumber.compare(criteriaObject, operator);
        }
      }
      return BooleanValueObject.create(false);
    } else if ((rangeValueObject == null ? void 0 : rangeValueObject.isError()) && criteriaObject.isError() && rangeValueObject.getValue() === criteriaObject.getValue()) {
      return BooleanValueObject.create(true);
    } else {
      return BooleanValueObject.create(false);
    }
  });
}
function isSameValueObjectType(left, right) {
  if (left.isNumber() && right.isNumber()) {
    return true;
  }
  if (left.isBoolean() && right.isBoolean()) {
    return true;
  }
  const isLeftBlank = left.isString() && left.getValue() === "";
  const isRightBlank = right.isString() && right.getValue() === "";
  if ((isLeftBlank || left.isNull()) && (isRightBlank || right.isNull())) {
    return true;
  }
  if (left.isString() && !isLeftBlank && right.isString() && !isRightBlank) {
    return true;
  }
  return false;
}
function getReferenceObjectFromCache(trimToken, type2) {
  let referenceObject;
  switch (type2) {
    case 0 /* CELL */:
      referenceObject = new CellReferenceObject(trimToken);
      break;
    case 1 /* COLUMN */:
      referenceObject = new ColumnReferenceObject(trimToken);
      break;
    case 2 /* ROW */:
      referenceObject = new RowReferenceObject(trimToken);
      break;
    default:
      throw new Error("Unknown reference object type");
  }
  return referenceObject;
}
function getRangeReferenceObjectFromCache(variant1, variant2) {
  let referenceObject = ErrorValueObject.create("#NAME?" /* NAME */);
  if (variant1.isCell() && variant2.isCell()) {
    referenceObject = variant1.unionBy(variant2);
  } else if (variant1.isRow() && variant2.isRow()) {
    referenceObject = variant1.unionBy(variant2);
  } else if (variant1.isColumn() && variant2.isColumn()) {
    referenceObject = variant1.unionBy(variant2);
  }
  return referenceObject;
}

// ../packages/engine-formula/src/services/runtime.service.ts
var FormulaRuntimeService = class extends Disposable {
  constructor(_currentConfigService) {
    super();
    this._currentConfigService = _currentConfigService;
    __publicField(this, "_formulaExecuteStage", 0 /* IDLE */);
    __publicField(this, "_stopState", false);
    __publicField(this, "_currentRow", -1);
    __publicField(this, "_currentColumn", -1);
    __publicField(this, "_currentRowCount", Number.NEGATIVE_INFINITY);
    __publicField(this, "_currentColumnCount", Number.NEGATIVE_INFINITY);
    __publicField(this, "_currentSubUnitId", "");
    __publicField(this, "_currentUnitId", "");
    __publicField(this, "_runtimeData", {});
    __publicField(this, "_runtimeOtherData", {});
    // Data returned by other businesses through formula calculation, excluding the sheet.
    __publicField(this, "_unitArrayFormulaRange", {});
    __publicField(this, "_runtimeArrayFormulaCellData", {});
    __publicField(this, "_runtimeClearArrayFormulaCellData", {});
    __publicField(this, "_runtimeFeatureRange", {});
    __publicField(this, "_runtimeFeatureCellData", {});
    __publicField(this, "_functionsExecutedState", 0 /* INITIAL */);
    // lambdaId: { key: BaseAstNode }
    __publicField(this, "_functionDefinitionPrivacyVar", /* @__PURE__ */ new Map());
    __publicField(this, "_totalFormulasToCalculate", 0);
    __publicField(this, "_completedFormulasCount", 0);
    __publicField(this, "_totalArrayFormulasToCalculate", 0);
    __publicField(this, "_completedArrayFormulasCount", 0);
    __publicField(this, "_formulaCycleIndex", 0);
    __publicField(this, "_isCycleDependency", false);
  }
  get currentRow() {
    return this._currentRow;
  }
  get currentColumn() {
    return this._currentColumn;
  }
  get currentRowCount() {
    return this._currentRowCount;
  }
  get currentColumnCount() {
    return this._currentColumnCount;
  }
  get currentSubUnitId() {
    return this._currentSubUnitId;
  }
  get currentUnitId() {
    return this._currentUnitId;
  }
  dispose() {
    super.dispose();
    this.reset();
    this._runtimeFeatureCellData = {};
    this._runtimeFeatureRange = {};
    this.clearReferenceAndNumberformatCache();
  }
  enableCycleDependency() {
    this._isCycleDependency = true;
  }
  disableCycleDependency() {
    this._isCycleDependency = false;
  }
  isCycleDependency() {
    return this._isCycleDependency;
  }
  setFormulaCycleIndex(index) {
    this._formulaCycleIndex = index;
  }
  getFormulaCycleIndex() {
    return this._formulaCycleIndex;
  }
  setTotalArrayFormulasToCalculate(value) {
    this._totalArrayFormulasToCalculate = value;
  }
  getTotalArrayFormulasToCalculate() {
    return this._totalArrayFormulasToCalculate;
  }
  setCompletedArrayFormulasCount(value) {
    this._completedArrayFormulasCount = value;
  }
  getCompletedArrayFormulasCount() {
    return this._completedArrayFormulasCount;
  }
  setTotalFormulasToCalculate(value) {
    this._totalFormulasToCalculate = value;
  }
  getTotalFormulasToCalculate() {
    return this._totalFormulasToCalculate;
  }
  setCompletedFormulasCount(value) {
    this._completedFormulasCount = value;
  }
  getCompletedFormulasCount() {
    return this._completedFormulasCount;
  }
  markedAsSuccessfullyExecuted() {
    this._functionsExecutedState = 3 /* SUCCESS */;
  }
  markedAsNoFunctionsExecuted() {
    this._functionsExecutedState = 2 /* NOT_EXECUTED */;
  }
  markedAsStopFunctionsExecuted() {
    this._functionsExecutedState = 1 /* STOP_EXECUTION */;
  }
  markedAsInitialFunctionsExecuted() {
    this._functionsExecutedState = 0 /* INITIAL */;
  }
  stopExecution() {
    this._stopState = true;
    this.setFormulaExecuteStage(0 /* IDLE */);
  }
  isStopExecution() {
    return this._stopState;
  }
  setFormulaExecuteStage(type2) {
    this._formulaExecuteStage = type2;
  }
  getFormulaExecuteStage() {
    return this._formulaExecuteStage;
  }
  reset() {
    this._formulaExecuteStage = 0 /* IDLE */;
    this._runtimeData = {};
    this._runtimeOtherData = {};
    this._unitArrayFormulaRange = {};
    this._runtimeArrayFormulaCellData = {};
    this._runtimeClearArrayFormulaCellData = {};
    this._functionDefinitionPrivacyVar.clear();
    this.markedAsInitialFunctionsExecuted();
    this._stopState = false;
    this._isCycleDependency = false;
    this._totalFormulasToCalculate = 0;
    this._completedFormulasCount = 0;
    this.clearReferenceAndNumberformatCache();
  }
  clearReferenceAndNumberformatCache() {
    clearNumberFormatTypeCache();
    clearStringToNumberPatternCache();
    clearReferenceToRangeCache();
  }
  setCurrent(row, column, rowCount, columnCount, sheetId, unitId) {
    this._currentRow = row;
    this._currentColumn = column;
    this._currentRowCount = rowCount;
    this._currentColumnCount = columnCount;
    this._currentSubUnitId = sheetId;
    this._currentUnitId = unitId;
  }
  clearFunctionDefinitionPrivacyVar() {
    this._functionDefinitionPrivacyVar.clear();
  }
  registerFunctionDefinitionPrivacyVar(lambdaId, lambdaVar) {
    this._functionDefinitionPrivacyVar.set(lambdaId, lambdaVar);
  }
  getFunctionDefinitionPrivacyVar(lambdaId) {
    return this._functionDefinitionPrivacyVar.get(lambdaId);
  }
  setRuntimeOtherData(formulaId, x, y, functionVariant) {
    const subUnitId = this._currentSubUnitId;
    const unitId = this._currentUnitId;
    if (this._runtimeOtherData[unitId] === void 0) {
      this._runtimeOtherData[unitId] = {};
    }
    const unitData = this._runtimeOtherData[unitId];
    if (unitData[subUnitId] === void 0 || unitData[subUnitId] === null) {
      unitData[subUnitId] = {};
    }
    const subComponentData = unitData[subUnitId];
    let cellDatas = [];
    if (functionVariant.isReferenceObject() || functionVariant.isValueObject() && functionVariant.isArray()) {
      const objectValueRefOrArray = functionVariant;
      const { startRow, startColumn } = objectValueRefOrArray.getRangePosition();
      objectValueRefOrArray.iterator((valueObject, rowIndex, columnIndex) => {
        const value = objectValueToCellValue(valueObject);
        const row = rowIndex - startRow;
        const column = columnIndex - startColumn;
        if (cellDatas[row] == null) {
          cellDatas[row] = [];
        }
        cellDatas[row][column] = value;
      });
    } else {
      cellDatas = [[objectValueToCellValue(functionVariant)]];
    }
    if (subComponentData[formulaId] === void 0 || subComponentData[formulaId] === null) {
      subComponentData[formulaId] = {};
    }
    if (subComponentData[formulaId][y] === void 0 || subComponentData[formulaId][y] === null) {
      subComponentData[formulaId][y] = {};
    }
    subComponentData[formulaId][y][x] = cellDatas;
  }
  // eslint-disable-next-line max-lines-per-function
  setRuntimeData(functionVariant) {
    const row = this._currentRow;
    const column = this._currentColumn;
    const rowCount = this._currentRowCount;
    const columnCount = this.currentColumnCount;
    const sheetId = this._currentSubUnitId;
    const unitId = this._currentUnitId;
    if (this._runtimeData[unitId] == null) {
      this._runtimeData[unitId] = {};
    }
    const unitData = this._runtimeData[unitId];
    if (unitData[sheetId] == null) {
      unitData[sheetId] = new ObjectMatrix();
    }
    if (this._unitArrayFormulaRange[unitId] == null) {
      this._unitArrayFormulaRange[unitId] = {};
    }
    const arrayFormulaRange = this._unitArrayFormulaRange[unitId];
    if (arrayFormulaRange[sheetId] === null || arrayFormulaRange[sheetId] === void 0) {
      arrayFormulaRange[sheetId] = {};
    }
    const arrayData = new ObjectMatrix(arrayFormulaRange[sheetId]);
    if (this._runtimeArrayFormulaCellData[unitId] === void 0) {
      this._runtimeArrayFormulaCellData[unitId] = {};
    }
    const runtimeArrayFormulaCellData = this._runtimeArrayFormulaCellData[unitId];
    if (runtimeArrayFormulaCellData[sheetId] == null) {
      runtimeArrayFormulaCellData[sheetId] = new ObjectMatrix();
    }
    if (this._runtimeClearArrayFormulaCellData[unitId] === void 0) {
      this._runtimeClearArrayFormulaCellData[unitId] = {};
    }
    const clearArrayFormulaCellData = this._runtimeClearArrayFormulaCellData[unitId];
    if (clearArrayFormulaCellData[sheetId] == null) {
      clearArrayFormulaCellData[sheetId] = new ObjectMatrix();
    }
    const sheetData = unitData[sheetId];
    const runtimeArrayUnitData = runtimeArrayFormulaCellData[sheetId];
    const clearArrayUnitData = clearArrayFormulaCellData[sheetId];
    if (functionVariant.isReferenceObject() || functionVariant.isValueObject() && functionVariant.isArray()) {
      const objectValueRefOrArray = functionVariant;
      const { startRow, startColumn, endRow, endColumn } = objectValueRefOrArray.getRangePosition();
      if (startRow === endRow && startColumn === endColumn) {
        const firstCell = objectValueRefOrArray.getFirstCell();
        const valueObject = objectValueToCellValue(firstCell);
        sheetData.setValue(row, column, valueObject);
        clearArrayUnitData.setValue(row, column, valueObject);
        return;
      }
      const arrayRange = {
        startRow: row,
        startColumn: column,
        endRow: endRow - startRow + row,
        endColumn: endColumn - startColumn + column
      };
      arrayData.setValue(row, column, arrayRange);
      if (this._checkIfArrayFormulaRangeHasData(unitId, sheetId, row, column, arrayRange) || this._checkIfArrayFormulaExceeded(rowCount, columnCount, arrayRange)) {
        const errorObject = objectValueToCellValue(ErrorValueObject.create("#SPILL!" /* SPILL */));
        sheetData.setValue(row, column, errorObject);
        clearArrayUnitData.setValue(row, column, errorObject);
        const unitData2 = this._currentConfigService.getUnitData();
        objectValueRefOrArray.iterator((_, rowIndex, columnIndex) => {
          var _a2, _b2;
          const currentRow = rowIndex - startRow + row;
          const currentColumn = columnIndex - startColumn + column;
          const cell = (_b2 = (_a2 = unitData2[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2.cellData.getValue(currentRow, currentColumn);
          if (rowIndex === startRow && columnIndex === startColumn) {
            runtimeArrayUnitData.setValue(row, column, errorObject);
          } else if (cell != null) {
            if (cell.v == null) {
              cell.v = "";
            }
            runtimeArrayUnitData.setValue(currentRow, currentColumn, cell);
          } else if (this._isInOtherArrayFormulaRange(unitId, sheetId, row, column, currentRow, currentColumn)) {
            return true;
          } else {
            runtimeArrayUnitData.setValue(currentRow, currentColumn, { v: "" });
          }
        });
      } else {
        const spillError = ErrorValueObject.create("#SPILL!" /* SPILL */);
        objectValueRefOrArray.iterator((valueObject, rowIndex, columnIndex) => {
          const value = objectValueToCellValue(valueObject);
          if (rowIndex === startRow && columnIndex === startColumn) {
            if (valueObject != null && valueObject.isError() && valueObject.isEqualType(spillError)) {
              clearArrayUnitData.setValue(row, column, {});
              sheetData.setValue(row, column, { ...objectValueToCellValue(spillError) });
              return false;
            }
            sheetData.setValue(row, column, { ...value });
          }
          const currentRow = rowIndex - startRow + row;
          const currentColumn = columnIndex - startColumn + column;
          runtimeArrayUnitData.setValue(currentRow, currentColumn, value);
        });
      }
    } else {
      const valueObject = objectValueToCellValue(functionVariant);
      sheetData.setValue(row, column, valueObject);
      clearArrayUnitData.setValue(row, column, valueObject);
    }
  }
  getUnitData() {
    return this._runtimeData;
  }
  getUnitArrayFormula() {
    return this._unitArrayFormulaRange;
  }
  getRuntimeOtherData() {
    return this._runtimeOtherData;
  }
  getRuntimeArrayFormulaCellData() {
    return this._runtimeArrayFormulaCellData;
  }
  getRuntimeClearArrayFormulaCellData() {
    return this._runtimeClearArrayFormulaCellData;
  }
  getRuntimeFeatureRange() {
    return this._runtimeFeatureRange;
  }
  setRuntimeFeatureRange(featureId, featureRange) {
    this._runtimeFeatureRange[featureId] = featureRange;
  }
  getRuntimeFeatureCellData() {
    return this._runtimeFeatureCellData;
  }
  setRuntimeFeatureCellData(featureId, featureData) {
    this._runtimeFeatureCellData[featureId] = featureData;
  }
  getAllRuntimeData() {
    return {
      unitData: this.getUnitData(),
      arrayFormulaRange: this.getUnitArrayFormula(),
      unitOtherData: this.getRuntimeOtherData(),
      functionsExecutedState: this._functionsExecutedState,
      arrayFormulaCellData: this.getRuntimeArrayFormulaCellData(),
      clearArrayFormulaCellData: this.getRuntimeClearArrayFormulaCellData(),
      runtimeFeatureRange: this.getRuntimeFeatureRange(),
      runtimeFeatureCellData: this.getRuntimeFeatureCellData()
    };
  }
  getRuntimeState() {
    return {
      totalFormulasToCalculate: this.getTotalFormulasToCalculate(),
      completedFormulasCount: this.getCompletedFormulasCount(),
      totalArrayFormulasToCalculate: this.getTotalArrayFormulasToCalculate(),
      completedArrayFormulasCount: this.getCompletedArrayFormulasCount(),
      stage: this.getFormulaExecuteStage(),
      formulaCycleIndex: this.getFormulaCycleIndex()
    };
  }
  // eslint-disable-next-line complexity
  _checkIfArrayFormulaRangeHasData(formulaUnitId, formulaSheetId, formulaRow, formulaColumn, arrayRange) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const { startRow, startColumn, endRow, endColumn } = arrayRange;
    const unitData = this._currentConfigService.getUnitData();
    const arrayData = this._currentConfigService.getArrayFormulaCellData();
    const unitArrayFormulaRange = (_c = (_b2 = (_a2 = this._unitArrayFormulaRange[formulaUnitId]) == null ? void 0 : _a2[formulaSheetId]) == null ? void 0 : _b2[formulaRow]) == null ? void 0 : _c[formulaColumn];
    for (let r = startRow; r <= endRow; r++) {
      for (let c = startColumn; c <= endColumn; c++) {
        if (r === formulaRow && formulaColumn === c) {
          continue;
        }
        const cell = (_f = (_e = (_d = this._runtimeData) == null ? void 0 : _d[formulaUnitId]) == null ? void 0 : _e[formulaSheetId]) == null ? void 0 : _f.getValue(r, c);
        const arrayDataCell = (_h = (_g = arrayData == null ? void 0 : arrayData[formulaUnitId]) == null ? void 0 : _g[formulaSheetId]) == null ? void 0 : _h.getValue(
          r,
          c
        );
        const currentCell = (_k = (_j = (_i = unitData == null ? void 0 : unitData[formulaUnitId]) == null ? void 0 : _i[formulaSheetId]) == null ? void 0 : _j.cellData) == null ? void 0 : _k.getValue(r, c);
        const featureCell = this._getRuntimeFeatureCellValue(r, c, formulaSheetId, formulaUnitId);
        if (!isNullCellForFormula(cell) || this._isInOtherArrayFormulaRange(formulaUnitId, formulaSheetId, formulaRow, formulaColumn, r, c) || !isNullCellForFormula(currentCell) || !isNullCellForFormula(featureCell)) {
          return true;
        }
      }
    }
    return false;
  }
  _getRuntimeFeatureCellValue(row, column, sheetId, unitId) {
    return getRuntimeFeatureCell(row, column, sheetId, unitId, this._runtimeFeatureCellData);
  }
  _arrayCellHasData(cell) {
    if (cell === null || cell === void 0) {
      return false;
    }
    if (cell.v !== void 0) {
      return true;
    }
    return false;
  }
  /**
   * If the current array formula in the extended area intersects with the existing array formula, a #SPILL! error will be reported. Note that if other array formulas are already #SPILL!, they will not conflict with the current array formula
   * @param formulaUnitId
   * @param formulaSheetId
   * @param formulaRow
   * @param formulaColumn
   * @param r
   * @param c
   * @returns
   */
  _isInOtherArrayFormulaRange(formulaUnitId, formulaSheetId, formulaRow, formulaColumn, r, c) {
    var _a2;
    const arrayFormulaRange = (_a2 = this._currentConfigService.getArrayFormulaRange()[formulaUnitId]) == null ? void 0 : _a2[formulaSheetId];
    if (arrayFormulaRange == null) {
      return false;
    }
    let isCellOverlapping = false;
    const arrayFormulaRangeMatrix = new ObjectMatrix(arrayFormulaRange);
    arrayFormulaRangeMatrix.forValue((rangeRow, rangeCol, range) => {
      var _a3, _b2;
      if (rangeRow === formulaRow && rangeCol === formulaColumn) {
        return;
      }
      const isOverlapping = this._isInArrayFormulaRange(range, r, c);
      const cell = (_b2 = (_a3 = this._runtimeData[formulaUnitId]) == null ? void 0 : _a3[formulaSheetId]) == null ? void 0 : _b2.getValue(rangeRow, rangeCol);
      if (isOverlapping && (cell == null ? void 0 : cell.v) !== "#SPILL!" /* SPILL */) {
        isCellOverlapping = true;
      }
    });
    return isCellOverlapping;
  }
  _isInArrayFormulaRange(range, r, c) {
    if (range == null) {
      return false;
    }
    const { startRow, startColumn, endRow, endColumn } = range;
    if (r >= startRow && r <= endRow && c >= startColumn && c <= endColumn) {
      return true;
    }
    return false;
  }
  _checkIfArrayFormulaExceeded(rowCount, columnCount, arrayRange) {
    if (arrayRange.endRow >= rowCount || arrayRange.endColumn >= columnCount) {
      return true;
    }
    return false;
  }
  _isInDirtyRange(unitId, sheetId, row, column) {
    const dirtyRanges = this._currentConfigService.getDirtyRanges();
    if (dirtyRanges.length === 0) {
      return true;
    }
    return isInDirtyRange(dirtyRanges, unitId, sheetId, row, column);
  }
};
FormulaRuntimeService = __decorateClass([
  __decorateParam(0, IFormulaCurrentConfigService)
], FormulaRuntimeService);
var IFormulaRuntimeService = createIdentifier("univer.formula.runtime.service");

// ../packages/engine-formula/src/engine/ast-node/node-type.ts
var NODE_ORDER_MAP = /* @__PURE__ */ new Map([
  [1 /* REFERENCE */, 7],
  [2 /* VALUE */, 9],
  [3 /* OPERATOR */, 8],
  [4 /* FUNCTION */, 6],
  [5 /* LAMBDA */, 1],
  [6 /* LAMBDA_PARAMETER */, 2],
  [9 /* ROOT */, 10],
  [10 /* UNION */, 3],
  [11 /* PREFIX */, 4],
  [12 /* SUFFIX */, 5]
]);

// ../packages/engine-formula/src/engine/ast-node/base-ast-node.ts
var BaseAstNode = class {
  constructor(_token) {
    this._token = _token;
    __publicField(this, "_children", []);
    __publicField(this, "_definedNames");
    __publicField(this, "_parent");
    __publicField(this, "_valueObject");
    __publicField(this, "_calculateState", false);
    __publicField(this, "_async", false);
    __publicField(this, "_address", false);
    __publicField(this, "_isForcedCalculateFunction", false);
  }
  dispose() {
    var _a2;
    this._children.forEach((node) => {
      node.dispose();
    });
    (_a2 = this._valueObject) == null ? void 0 : _a2.dispose();
    this._valueObject = null;
    this._children = [];
    this._definedNames = null;
    this._parent = null;
  }
  get nodeType() {
    return 8 /* BASE */;
  }
  isAsync() {
    return this._async;
  }
  isAddress() {
    return this._address;
  }
  isForcedCalculateFunction() {
    return this._isForcedCalculateFunction;
  }
  setAsync() {
    this._async = true;
  }
  setAddress() {
    this._address = true;
  }
  getParent() {
    return this._parent;
  }
  setParent(node) {
    this._parent = node;
    node.addChildren(this);
  }
  setForcedCalculateFunction() {
    this._isForcedCalculateFunction = true;
  }
  getChildren() {
    return this._children;
  }
  addChildren(...astNode) {
    this._children.push(...astNode);
  }
  getToken() {
    return this._token;
  }
  setValue(value) {
    this._valueObject = value;
  }
  getValue() {
    return this._valueObject;
  }
  isCalculated() {
    return this._calculateState;
  }
  setCalculated() {
    this._calculateState = true;
  }
  execute() {
  }
  setNotEmpty(state = true) {
  }
  async executeAsync() {
    return Promise.resolve(0 /* SUCCESS */);
  }
  serialize() {
    const token = this.getToken();
    const children = this.getChildren();
    const childrenSerialization = [];
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      childrenSerialization.push(item.serialize());
    }
    const result = {
      token,
      nodeType: this.nodeType
    };
    if (childrenCount > 0) {
      result.children = childrenSerialization;
    }
    return result;
  }
  hasDefinedName(definedName) {
    var _a2;
    return ((_a2 = this._definedNames) == null ? void 0 : _a2.includes(definedName)) || false;
  }
  setDefinedNames(definedNames) {
    this._definedNames = definedNames;
  }
  getDefinedNames() {
    return this._definedNames;
  }
};
var ErrorNode = class _ErrorNode extends BaseAstNode {
  constructor(errorType) {
    super(errorType);
    __publicField(this, "_errorValueObject");
    this._errorValueObject = ErrorValueObject.create(errorType);
  }
  get nodeType() {
    return 7 /* ERROR */;
  }
  static create(errorType) {
    return new _ErrorNode(errorType);
  }
  getValue() {
    return this._errorValueObject;
  }
};

// ../packages/engine-formula/src/engine/ast-node/base-ast-node-factory.ts
var DEFAULT_AST_NODE_FACTORY_Z_INDEX = 100;
var BaseAstNodeFactory = class {
  get zIndex() {
    return 0;
  }
  dispose() {
  }
  create(param, currentRow, currentColumn) {
    let token;
    if (param instanceof LexerNode) {
      token = param.getToken();
    } else {
      token = param;
    }
    return new BaseAstNode(token);
  }
};

// ../packages/engine-formula/src/engine/ast-node/ast-root-node.ts
var AstRootNode = class extends BaseAstNode {
  get nodeType() {
    return 9 /* ROOT */;
  }
  execute() {
    const children = this.getChildren();
    if (children.length > 1) {
      this.setValue(ErrorValueObject.create("#VALUE!" /* VALUE */));
      return;
    }
    const node = children[0];
    if (node == null) {
      this.setValue(ErrorValueObject.create("#VALUE!" /* VALUE */));
    } else {
      this.setValue(node.getValue());
    }
  }
};
var AstRootNodeFactory = class extends BaseAstNodeFactory {
  get zIndex() {
    return NODE_ORDER_MAP.get(9 /* ROOT */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  checkAndCreateNodeType(param) {
    if (!(param instanceof LexerNode)) {
      return;
    }
    const token = param.getToken();
    if (token === DEFAULT_TOKEN_TYPE_ROOT) {
      return new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
    }
  }
};

// ../packages/engine-formula/src/engine/utils/generate-ast-node.ts
var FORMULA_CACHE_LRU_COUNT3 = 5e3;
var FORMULA_AST_CACHE = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT3);
function generateAstNode(unitId, formulaString, lexer, astTreeBuilder, currentConfigService) {
  let astNode = FORMULA_AST_CACHE.get(`${unitId}${formulaString}`);
  if (astNode && !isDirtyDefinedForNode(astNode, currentConfigService)) {
    return astNode;
  }
  const lexerNode = lexer.treeBuilder(formulaString);
  if (ERROR_TYPE_SET.has(lexerNode)) {
    return ErrorNode.create(lexerNode);
  }
  astNode = astTreeBuilder.parse(lexerNode);
  if (astNode == null) {
    throw new Error("astNode is null");
  }
  FORMULA_AST_CACHE.set(`${unitId}${formulaString}`, astNode);
  return astNode;
}
function isDirtyDefinedForNode(node, currentConfigService) {
  const definedNameMap = currentConfigService.getDirtyDefinedNameMap();
  const executeUnitId = currentConfigService.getExecuteUnitId();
  if (executeUnitId != null && definedNameMap[executeUnitId] != null) {
    const names = Object.keys(definedNameMap[executeUnitId]);
    for (let i = 0, len = names.length; i < len; i++) {
      const name = names[i];
      if (node.hasDefinedName(name)) {
        return true;
      }
    }
  }
  return false;
}
function includeDefinedName(tree, node, currentConfigService) {
  if (node != null) {
    const dirtyDefinedName = isDirtyDefinedForNode(node, currentConfigService);
    if (dirtyDefinedName) {
      return true;
    }
  }
  return false;
}

// ../packages/engine-formula/src/services/function.service.ts
var IFunctionService = createIdentifier("univer.formula-function.service");
var FunctionService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_functionExecutors", /* @__PURE__ */ new Map());
    __publicField(this, "_functionDescriptions", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose();
    this._functionExecutors.clear();
    this._functionDescriptions.clear();
  }
  registerExecutors(...functions) {
    for (let i = 0; i < functions.length; i++) {
      const func = functions[i];
      this._functionExecutors.set(func.name, func);
    }
  }
  getExecutors() {
    return this._functionExecutors;
  }
  getExecutor(functionToken) {
    return this._functionExecutors.get(functionToken);
  }
  hasExecutor(functionToken) {
    return this._functionExecutors.has(functionToken);
  }
  unregisterExecutors(...functionTokens) {
    for (let i = 0; i < functionTokens.length; i++) {
      const functionToken = functionTokens[i];
      this._functionExecutors.delete(functionToken);
    }
  }
  registerDescriptions(...descriptions) {
    for (let i = 0; i < descriptions.length; i++) {
      const description = descriptions[i];
      this._functionDescriptions.set(description.functionName, description);
    }
    return toDisposable(() => {
      for (let i = 0; i < descriptions.length; i++) {
        const description = descriptions[i];
        this._functionDescriptions.delete(description.functionName);
      }
    });
  }
  getDescriptions() {
    return this._functionDescriptions;
  }
  getDescription(functionToken) {
    return this._functionDescriptions.get(functionToken);
  }
  hasDescription(functionToken) {
    return this._functionDescriptions.has(functionToken);
  }
  unregisterDescriptions(...functionTokens) {
    for (let i = 0; i < functionTokens.length; i++) {
      const functionToken = functionTokens[i];
      this._functionDescriptions.delete(functionToken);
    }
  }
  deleteFormulaAstCacheKey(...functionToken) {
    FORMULA_AST_CACHE.forEach((_, key) => {
      functionToken.forEach((token) => {
        if (key.includes(token)) {
          FORMULA_AST_CACHE.delete(key);
        }
      });
    });
  }
};

// ../packages/engine-formula/src/engine/ast-node/prefix-node.ts
var PrefixNode = class extends BaseAstNode {
  constructor(_runtimeService, _operatorString, _functionExecutor) {
    super(_operatorString);
    this._runtimeService = _runtimeService;
    this._operatorString = _operatorString;
    this._functionExecutor = _functionExecutor;
  }
  get nodeType() {
    return 11 /* PREFIX */;
  }
  execute() {
    const children = this.getChildren();
    let value = children[0].getValue();
    let result;
    if (value == null) {
      throw new Error("object is null");
    }
    if (this._operatorString === "-" /* MINUS */) {
      if (value.isReferenceObject()) {
        value = value.toArrayValueObject();
      }
      result = this._functionExecutor.calculate(
        NumberValueObject.create(0),
        value
      );
    } else if (this._operatorString === "@" /* AT */) {
      result = this._handlerAT(value);
    } else {
      result = ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    this.setValue(result);
  }
  _handlerAT(value) {
    if (!value.isReferenceObject()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const currentValue = value;
    if (currentValue.isCell()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const runtimeService = this._runtimeService;
    const currentRow = runtimeService.currentRow || 0;
    const currentColumn = runtimeService.currentColumn || 0;
    const rangePos = currentValue.getRangePosition();
    const { startRow, startColumn, endRow, endColumn } = rangePos;
    if (endColumn !== startColumn && endRow !== startRow) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (startRow === endRow && startColumn === endColumn) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (endRow === startRow && currentColumn >= startColumn && currentColumn <= endColumn) {
      return currentValue.getCellByColumn(currentColumn);
    } else if (startColumn === endColumn && currentRow >= startRow && currentRow <= endRow) {
      return currentValue.getCellByRow(currentRow);
    }
    if (currentValue.isTable()) {
      return currentValue.getCellByPosition(currentRow);
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};
var PrefixNodeFactory = class extends BaseAstNodeFactory {
  constructor(_functionService, _runtimeService) {
    super();
    this._functionService = _functionService;
    this._runtimeService = _runtimeService;
  }
  get zIndex() {
    return NODE_ORDER_MAP.get(11 /* PREFIX */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  checkAndCreateNodeType(param) {
    if (!(param instanceof LexerNode)) {
      return;
    }
    const token = param.getToken();
    const tokenTrim = token.trim();
    if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
      return;
    }
    let functionName = "";
    if (tokenTrim === "-" /* MINUS */) {
      functionName = "MINUS" /* MINUS */;
    } else if (tokenTrim === "@" /* AT */) {
      return new PrefixNode(this._runtimeService, tokenTrim);
    } else {
      return;
    }
    const functionExecutor = this._functionService.getExecutor(functionName);
    if (!functionExecutor) {
      console.error(`No function ${token}`);
      return ErrorNode.create("#NAME?" /* NAME */);
    }
    return new PrefixNode(this._runtimeService, tokenTrim, functionExecutor);
  }
};
PrefixNodeFactory = __decorateClass([
  __decorateParam(0, IFunctionService),
  __decorateParam(1, IFormulaRuntimeService)
], PrefixNodeFactory);

// ../packages/engine-formula/src/engine/utils/prefix-handler.ts
var minusRegExp = new RegExp("-" /* MINUS */, "g");
var atRegExp = new RegExp("@" /* AT */, "g");
function prefixHandler(tokenTrimParam, functionService, runtimeService) {
  let minusPrefixNode;
  let atPrefixNode;
  let tokenTrim = tokenTrimParam;
  const prefix = tokenTrim.slice(0, 2);
  let sliceLength = 0;
  if (prefix[0] === "-" /* MINUS */) {
    const functionExecutor = functionService.getExecutor("MINUS" /* MINUS */);
    minusPrefixNode = new PrefixNode(runtimeService, "-" /* MINUS */, functionExecutor);
    sliceLength++;
  }
  if (prefix[0] === "@" /* AT */) {
    atPrefixNode = new PrefixNode(runtimeService, "@" /* AT */);
    if (minusPrefixNode) {
      atPrefixNode.setParent(minusPrefixNode);
    }
    sliceLength++;
  }
  if (sliceLength > 0) {
    tokenTrim = tokenTrim.slice(sliceLength);
  }
  return { tokenTrim, minusPrefixNode, atPrefixNode };
}

// ../packages/engine-formula/src/engine/ast-node/function-node.ts
var FunctionNode = class extends BaseAstNode {
  constructor(token, _functionExecutor, _currentConfigService, _runtimeService, _definedNamesService, _formulaDataModel) {
    super(token);
    this._functionExecutor = _functionExecutor;
    this._currentConfigService = _currentConfigService;
    this._runtimeService = _runtimeService;
    this._definedNamesService = _definedNamesService;
    this._formulaDataModel = _formulaDataModel;
    if (this._functionExecutor.isAsync()) {
      this.setAsync();
    }
    if (this._functionExecutor.isAddress()) {
      this.setAddress();
    }
    if (this._functionExecutor.needsLocale) {
      this._setLocale();
    }
    if (this._functionExecutor.needsSheetsInfo) {
      this._setSheetsInfo();
    }
    if (this._functionExecutor.needsFormulaDataModel) {
      this._functionExecutor.setFormulaDataModel(this._formulaDataModel);
    }
  }
  get nodeType() {
    return 4 /* FUNCTION */;
  }
  async executeAsync() {
    const variants = [];
    const children = this.getChildren();
    const childrenCount = children.length;
    this._compatibility();
    for (let i = 0; i < childrenCount; i++) {
      const child = children[i];
      const object = child.getValue();
      if (object == null) {
        continue;
      }
      if (object.isReferenceObject() && !this._functionExecutor.needsReferenceObject) {
        variants.push(object.toArrayValueObject());
      } else {
        variants.push(object);
      }
    }
    const resultVariant = await this._calculateAsync(variants);
    let result;
    if (resultVariant.isAsyncObject() || resultVariant.isAsyncArrayObject()) {
      result = await resultVariant.getValue();
    } else {
      result = resultVariant;
    }
    this._setRefData(result);
    this.setValue(result);
    return Promise.resolve(0 /* SUCCESS */);
  }
  execute() {
    const variants = [];
    const children = this.getChildren();
    const childrenCount = children.length;
    this._compatibility();
    for (let i = 0; i < childrenCount; i++) {
      const child = children[i];
      const object = child.getValue();
      if (object == null) {
        continue;
      }
      if (object.isReferenceObject() && this._functionExecutor.needsFilteredOutRows) {
        this._setFilteredOutRows(object);
      }
      if (object.isReferenceObject() && !this._functionExecutor.needsReferenceObject) {
        variants.push(object.toArrayValueObject());
      } else {
        variants.push(object);
      }
    }
    const resultVariant = this._calculate(variants);
    this._setRefData(resultVariant);
    this.setValue(resultVariant);
  }
  /**
   * Compatibility handling for special functions.
   */
  _compatibility() {
    this._lookupCompatibility();
  }
  /**
   * The LOOKUP function follows the following rules when dealing with vectors of different sizes:
   *    If the lookup_vector is larger than the result_vector,
   *    the LOOKUP function will ignore the extra portion of the lookup_vector and only use the portion of the result_vector that is the same size as the lookup_vector for lookup and returning results.
   *    If the lookup_vector is smaller than the result_vector,
   *    the LOOKUP function will continue using the last value of the result_vector for lookup and returning results after the last value of the lookup_vector.
   */
  _lookupCompatibility() {
    const children = this.getChildren();
    const childrenCount = children.length;
    if (!this._functionExecutor.needsExpandParams || childrenCount !== 3) {
      return;
    }
    const lookupVectorOrArray = children[1].getValue();
    const resultVector = children[2].getValue();
    if (!(lookupVectorOrArray == null ? void 0 : lookupVectorOrArray.isReferenceObject()) && !(resultVector == null ? void 0 : resultVector.isReferenceObject())) {
      return;
    }
    let lookupCountRow;
    let lookupCountColumn;
    if (lookupVectorOrArray == null ? void 0 : lookupVectorOrArray.isReferenceObject()) {
      const lookupVectorOrArrayRange = lookupVectorOrArray.getRangeData();
      const { startRow, startColumn, endRow, endColumn } = lookupVectorOrArrayRange;
      lookupCountRow = endRow - startRow + 1;
      lookupCountColumn = endColumn - startColumn + 1;
    } else {
      lookupCountRow = (lookupVectorOrArray == null ? void 0 : lookupVectorOrArray.isArray()) ? lookupVectorOrArray.getRowCount() : 1;
      lookupCountColumn = (lookupVectorOrArray == null ? void 0 : lookupVectorOrArray.isArray()) ? lookupVectorOrArray.getColumnCount() : 1;
    }
    const resultVectorRange = resultVector.getRangeData();
    const { startRow: reStartRow, startColumn: reStartColumn, endRow: reEndRow, endColumn: reEndColumn } = resultVectorRange;
    const resultCountRow = reEndRow - reStartRow + 1;
    const resultCountColumn = reEndColumn - reStartColumn + 1;
    if (lookupCountRow !== resultCountRow) {
      resultVectorRange.endRow += lookupCountRow - resultCountRow;
    }
    if (lookupCountColumn !== resultCountColumn) {
      resultVectorRange.endColumn += lookupCountColumn - resultCountColumn;
    }
  }
  /**
   * Transform the result of a custom function to a NodeValueType.
   */
  _handleCustomResult(resultVariantCustom) {
    var _a2;
    if (typeof resultVariantCustom !== "object" || resultVariantCustom == null) {
      return ValueObjectFactory.create(resultVariantCustom);
    }
    const arrayValues = transformToValueObject(resultVariantCustom);
    return ArrayValueObject.create({
      calculateValueList: arrayValues,
      rowCount: arrayValues.length,
      columnCount: ((_a2 = arrayValues[0]) == null ? void 0 : _a2.length) || 0,
      unitId: "",
      sheetId: "",
      row: -1,
      column: -1
    });
  }
  _handleAddressFunction() {
    if (this._functionExecutor.isAddress()) {
      this._setDefinedNamesForFunction();
    }
  }
  _mapVariantsToValues(variants) {
    return variants.map((variant) => {
      if (variant.isArray()) {
        return variant.toValue();
      }
      if (variant.isLambda()) {
        return variant;
      }
      return variant.getValue();
    });
  }
  _calculate(variants) {
    const { minParams, maxParams } = this._functionExecutor;
    if (minParams !== -1 && maxParams !== -1 && (variants.length < minParams || variants.length > maxParams)) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let resultVariant;
    this._setRefInfo();
    if (this._functionExecutor.isCustom()) {
      const resultVariantCustom = this._functionExecutor.calculateCustom(
        ...this._mapVariantsToValues(variants)
      );
      resultVariant = this._handleCustomResult(resultVariantCustom);
    } else {
      this._handleAddressFunction();
      resultVariant = this._functionExecutor.calculate(...variants);
    }
    return resultVariant;
  }
  async _calculateAsync(variants) {
    const { minParams, maxParams } = this._functionExecutor;
    if (minParams !== -1 && maxParams !== -1 && (variants.length < minParams || variants.length > maxParams)) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let resultVariant;
    this._setRefInfo();
    if (this._functionExecutor.isCustom()) {
      const resultVariantCustom = await this._functionExecutor.calculateCustom(
        ...this._mapVariantsToValues(variants)
      );
      resultVariant = this._handleCustomResult(resultVariantCustom);
    } else {
      this._handleAddressFunction();
      resultVariant = this._functionExecutor.calculate(...variants);
    }
    return resultVariant;
  }
  _setDefinedNamesForFunction() {
    const editorUnitId = this._currentConfigService.getExecuteUnitId();
    if (editorUnitId == null) {
      return;
    }
    const definedNames = this._definedNamesService.getDefinedNameMap(editorUnitId);
    if (definedNames == null) {
      return;
    }
    this._functionExecutor.setDefinedNames(definedNames);
  }
  _setRefInfo() {
    const { currentUnitId, currentSubUnitId, currentRow, currentColumn } = this._runtimeService;
    this._functionExecutor.setRefInfo(currentUnitId, currentSubUnitId, currentRow, currentColumn);
    if (this._functionExecutor.needsSheetRowColumnCount) {
      const { rowCount, columnCount } = this._currentConfigService.getSheetRowColumnCount(currentUnitId, currentSubUnitId);
      this._functionExecutor.setSheetRowColumnCount(rowCount, columnCount);
    }
  }
  _setRefData(variant) {
    if (!variant.isReferenceObject()) {
      return;
    }
    const referenceObject = variant;
    referenceObject.setForcedSheetId(this._currentConfigService.getSheetNameMap());
    referenceObject.setUnitData(this._currentConfigService.getUnitData());
    referenceObject.setArrayFormulaCellData(this._currentConfigService.getArrayFormulaCellData());
    referenceObject.setRuntimeData(this._runtimeService.getUnitData());
    referenceObject.setRuntimeArrayFormulaCellData(this._runtimeService.getRuntimeArrayFormulaCellData());
    referenceObject.setRuntimeFeatureCellData(this._runtimeService.getRuntimeFeatureCellData());
  }
  _setLocale() {
    this._functionExecutor.setLocale(this._currentConfigService.getLocale());
  }
  _setSheetsInfo() {
    this._functionExecutor.setSheetsInfo(this._currentConfigService.getSheetsInfo());
  }
  _setFilteredOutRows(referenceObject) {
    const { startRow, endRow } = referenceObject.getRangePosition();
    const filteredOutRows = this._currentConfigService.getFilteredOutRows(
      referenceObject.getUnitId(),
      referenceObject.getSheetId(),
      startRow,
      endRow
    );
    referenceObject.setFilteredOutRows(filteredOutRows);
  }
};
var ErrorFunctionNode = class extends BaseAstNode {
  constructor(token = "Error") {
    super(token);
  }
  get nodeType() {
    return 4 /* FUNCTION */;
  }
  async executeAsync() {
    this.setValue(ErrorValueObject.create("#NAME?" /* NAME */));
    return Promise.resolve(0 /* SUCCESS */);
  }
  execute() {
    this.setValue(ErrorValueObject.create("#NAME?" /* NAME */));
  }
};
var FunctionNodeFactory = class extends BaseAstNodeFactory {
  constructor(_functionService, _currentConfigService, _runtimeService, _definedNamesService, _injector, _formulaDataModel) {
    super();
    this._functionService = _functionService;
    this._currentConfigService = _currentConfigService;
    this._runtimeService = _runtimeService;
    this._definedNamesService = _definedNamesService;
    this._injector = _injector;
    this._formulaDataModel = _formulaDataModel;
  }
  get zIndex() {
    return NODE_ORDER_MAP.get(4 /* FUNCTION */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  create(token) {
    const functionExecutor = this._functionService.getExecutor(token);
    if (!functionExecutor) {
      console.error(`No function ${token}`);
      return ErrorNode.create("#NAME?" /* NAME */);
    }
    return new FunctionNode(
      token,
      functionExecutor,
      this._currentConfigService,
      this._runtimeService,
      this._definedNamesService,
      this._formulaDataModel
    );
  }
  checkAndCreateNodeType(param) {
    if (typeof param === "string") {
      return;
    }
    const token = param.getToken();
    const { tokenTrim, minusPrefixNode, atPrefixNode } = prefixHandler(token.trim(), this._functionService, this._runtimeService);
    if (!Number.isNaN(Number(tokenTrim)) && !this._isParentUnionNode(param)) {
      return ErrorNode.create("#VALUE!" /* VALUE */);
    }
    const tokenTrimUpper = tokenTrim.toUpperCase();
    if (this._functionService.hasExecutor(tokenTrimUpper)) {
      const functionNode = this.create(tokenTrimUpper);
      if (atPrefixNode) {
        functionNode.setParent(atPrefixNode);
      } else if (minusPrefixNode) {
        functionNode.setParent(minusPrefixNode);
      }
      return functionNode;
    }
  }
  _isParentUnionNode(param) {
    var _a2, _b2;
    return ((_b2 = (_a2 = param.getParent()) == null ? void 0 : _a2.getParent()) == null ? void 0 : _b2.getToken()) === ":" /* COLON */;
  }
};
FunctionNodeFactory = __decorateClass([
  __decorateParam(0, IFunctionService),
  __decorateParam(1, IFormulaCurrentConfigService),
  __decorateParam(2, IFormulaRuntimeService),
  __decorateParam(3, IDefinedNamesService),
  __decorateParam(4, Inject(Injector)),
  __decorateParam(5, Inject(FormulaDataModel))
], FunctionNodeFactory);

// ../packages/engine-formula/src/engine/interpreter/interpreter.ts
var Interpreter = class extends Disposable {
  constructor(_runtimeService) {
    super();
    this._runtimeService = _runtimeService;
  }
  async executeAsync(nodeData) {
    if (!nodeData || !nodeData.node) {
      return Promise.resolve(ErrorValueObject.create("#VALUE!" /* VALUE */));
    }
    const node = nodeData.node;
    const refOffsetX = nodeData.refOffsetX;
    const refOffsetY = nodeData.refOffsetY;
    await this._executeAsync(node, refOffsetX, refOffsetY);
    const value = node.getValue();
    if (value == null) {
      return Promise.resolve(ErrorValueObject.create("#VALUE!" /* VALUE */));
    }
    return Promise.resolve(value);
  }
  execute(nodeData) {
    if (!nodeData || !nodeData.node) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const node = nodeData.node;
    const refOffsetX = nodeData.refOffsetX;
    const refOffsetY = nodeData.refOffsetY;
    this._execute(node, refOffsetX, refOffsetY);
    const value = node.getValue();
    if (value == null) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return value;
  }
  executePreCalculateNode(node) {
    node.execute();
    return node.getValue();
  }
  checkAsyncNode(node) {
    if (node == null) {
      return false;
    }
    const result = [];
    this._checkAsyncNode(node, result);
    for (let i = 0, len = result.length; i < len; i++) {
      const item = result[i];
      if (item === true) {
        return true;
      }
    }
    return false;
  }
  _checkAsyncNode(node, resultList) {
    const children = node.getChildren();
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      resultList.push(item.isAsync());
      this._checkAsyncNode(item, resultList);
    }
  }
  async _executeAsync(node, refOffsetX = 0, refOffsetY = 0) {
    if (this._runtimeService.isStopExecution()) {
      return Promise.resolve(1 /* ERROR */);
    }
    const children = node.getChildren();
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      const token = item.getToken();
      if (token.toUpperCase() === DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME && item.isEmptyParamFunction()) {
        item.execute();
        continue;
      }
      await this._executeAsync(item, refOffsetX, refOffsetY);
    }
    if (node.nodeType === 1 /* REFERENCE */) {
      node.setRefOffset(refOffsetX, refOffsetY);
    }
    if (node.nodeType === 4 /* FUNCTION */ && node.isAsync()) {
      await node.executeAsync();
    } else {
      node.execute();
    }
    return Promise.resolve(0 /* SUCCESS */);
  }
  _execute(node, refOffsetX = 0, refOffsetY = 0) {
    if (this._runtimeService.isStopExecution()) {
      return 1 /* ERROR */;
    }
    const children = node.getChildren();
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      const token = item.getToken();
      if (token.toUpperCase() === DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME && item.isEmptyParamFunction()) {
        item.execute();
        continue;
      }
      this._execute(item, refOffsetX, refOffsetY);
    }
    if (node.nodeType === 1 /* REFERENCE */) {
      node.setRefOffset(refOffsetX, refOffsetY);
    }
    node.execute();
    return 0 /* SUCCESS */;
  }
};
Interpreter = __decorateClass([
  __decorateParam(0, IFormulaRuntimeService)
], Interpreter);

// ../packages/engine-formula/src/engine/utils/function-definition.ts
function isFirstChildParameter(lexerNode) {
  if (!(lexerNode instanceof LexerNode)) {
    return false;
  }
  return lexerNode.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER;
}
function isChildRunTimeParameter(lexerNode) {
  if (!(lexerNode instanceof LexerNode)) {
    return false;
  }
  return lexerNode.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_OMIT_PARAMETER;
}

// ../packages/engine-formula/src/engine/utils/update-lambda-statement.ts
function updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar) {
  const children = functionStatementNode.getChildren();
  const childrenCount = children.length;
  const firstChild = children[0];
  for (let i = 0; i < childrenCount; i++) {
    const node = children[i];
    if (isFirstChildParameter(firstChild) && i !== 0) {
      continue;
    }
    if (node instanceof LexerNode) {
      updateLambdaStatement(node, lambdaId, currentLambdaPrivacyVar);
    } else {
      const token = node.trim();
      if (currentLambdaPrivacyVar.has(token)) {
        const newNode = new LexerNode();
        newNode.setToken(DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER);
        newNode.setLambdaId(lambdaId);
        newNode.setLambdaPrivacyVar(currentLambdaPrivacyVar);
        newNode.setLambdaParameter(token);
        children[i] = newNode;
      }
    }
  }
}

// ../packages/engine-formula/src/engine/value-object/lambda-value-object.ts
function getRootLexerHasValueNode(node) {
  if (!node) {
    return;
  }
  if (node.getToken() !== DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
    return node;
  }
  const parameterNode = node;
  const currentLambdaPrivacyVar = parameterNode.getCurrentLambdaPrivacyVar();
  const lambdaParameter = parameterNode.getLambdaParameter();
  if (!currentLambdaPrivacyVar) {
    return;
  }
  const chainNode = currentLambdaPrivacyVar.get(lambdaParameter);
  if (chainNode == null && node.getValue()) {
    return node;
  }
  return getRootLexerHasValueNode(chainNode);
}
var LambdaValueObjectObject = class _LambdaValueObjectObject extends BaseValueObject {
  constructor(_lambdaNode, _interpreter, _lambdaPrivacyVarKeys) {
    super(0);
    this._lambdaNode = _lambdaNode;
    this._interpreter = _interpreter;
    this._lambdaPrivacyVarKeys = _lambdaPrivacyVarKeys;
    __publicField(this, "_lambdaPrivacyValueMap", /* @__PURE__ */ new Map());
    this._lambdaPrivacyValueMap.clear();
  }
  static create(lambdaNode, interpreter, lambdaPrivacyVarKeys) {
    return new _LambdaValueObjectObject(lambdaNode, interpreter, lambdaPrivacyVarKeys);
  }
  dispose() {
    this._lambdaPrivacyValueMap.clear();
    this._lambdaPrivacyValueMap = /* @__PURE__ */ new Map();
    this._lambdaNode = null;
    this._interpreter = null;
    this._lambdaPrivacyVarKeys = [];
  }
  isLambda() {
    return true;
  }
  execute(...variants) {
    const paramCount = this._lambdaPrivacyVarKeys.length;
    if (variants.length !== paramCount || !this._interpreter || !this._lambdaNode) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    this._setLambdaPrivacyValueMap(variants);
    this._setLambdaNodeValue(this._lambdaNode);
    this._lambdaNode.setNotEmpty(false);
    let value;
    if (this._interpreter.checkAsyncNode(this._lambdaNode)) {
      value = new AsyncObject(this._interpreter.executeAsync(generateExecuteAstNodeData(this._lambdaNode)));
    } else {
      const o = this._interpreter.execute(generateExecuteAstNodeData(this._lambdaNode));
      if (o.isReferenceObject()) {
        value = o.toArrayValueObject();
      } else {
        value = o;
      }
    }
    this._lambdaNode.setNotEmpty(true);
    return value;
  }
  /**
   * Execute custom lambda function, handle basic types
   * @param variants
   */
  executeCustom(...variants) {
    const baseValueObjects = variants.map((variant) => ValueObjectFactory.create(variant));
    return this.execute(...baseValueObjects);
  }
  _setLambdaNodeValue(node) {
    if (!node) {
      return;
    }
    const children = node.getChildren();
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      const token = item.getToken();
      if (token === DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
        const lambdaParameter = item.getLambdaParameter();
        const value = this._lambdaPrivacyValueMap.get(lambdaParameter);
        if (value) {
          item.setValue(value);
        } else {
          const currentLambdaPrivacyVar = item.getCurrentLambdaPrivacyVar();
          const node2 = getRootLexerHasValueNode(currentLambdaPrivacyVar.get(lambdaParameter));
          if (node2 != null) {
            item.setValue(node2.getValue());
          }
        }
        continue;
      }
      this._setLambdaNodeValue(item);
    }
  }
  _setLambdaPrivacyValueMap(variants) {
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      const key = this._lambdaPrivacyVarKeys[i];
      this._lambdaPrivacyValueMap.set(key, variant);
    }
  }
  getLambdaPrivacyVarKeys() {
    return this._lambdaPrivacyVarKeys;
  }
};

// ../packages/engine-formula/src/engine/ast-node/lambda-node.ts
var LambdaNode = class extends BaseAstNode {
  constructor(token, _lambdaId, _interpreter, _lambdaPrivacyVarKeys) {
    super(token);
    this._lambdaId = _lambdaId;
    this._interpreter = _interpreter;
    this._lambdaPrivacyVarKeys = _lambdaPrivacyVarKeys;
    __publicField(this, "_isNotEmpty", true);
  }
  get nodeType() {
    return 5 /* LAMBDA */;
  }
  setNotEmpty(state = false) {
    this._isNotEmpty = state;
  }
  isEmptyParamFunction() {
    return this.getChildren().length < 2 && this._isNotEmpty;
  }
  isFunctionParameter() {
    return this._lambdaId === null;
  }
  getLambdaId() {
    return this._lambdaId;
  }
  execute() {
    if (this.isEmptyParamFunction()) {
      this.setValue(LambdaValueObjectObject.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
    } else {
      const children = this.getChildren();
      const childrenCount = children.length;
      this.setValue(children[childrenCount - 1].getValue());
    }
  }
  // override async executeAsync() {
  //     if (this.isEmptyParamFunction()) {
  //         await this.setValue(LambdaValueObjectObject.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
  //     } else {
  //         const children = this.getChildren();
  //         const childrenCount = children.length;
  //         await this.setValue(children[childrenCount - 1].getValue());
  //     }
  //     return Promise.resolve(AstNodePromiseType.SUCCESS);
  // }
};
var LambdaNodeFactory = class extends BaseAstNodeFactory {
  constructor(_runtimeService, _interpreter) {
    super();
    this._runtimeService = _runtimeService;
    this._interpreter = _interpreter;
  }
  get zIndex() {
    return NODE_ORDER_MAP.get(5 /* LAMBDA */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  create(param) {
    const children = param.getChildren();
    const lambdaVar = children[0];
    let parameterArray = children.slice(1, -1);
    const functionStatementNode = children[children.length - 1];
    if (!(lambdaVar instanceof LexerNode && functionStatementNode instanceof LexerNode)) {
      return ErrorNode.create("#NAME?" /* NAME */);
    }
    if (lambdaVar.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
      const lambdaVarChildren = lambdaVar.getChildren();
      if (parameterArray.length !== lambdaVarChildren.length) {
        return ErrorNode.create("#VALUE!" /* VALUE */);
      }
    } else {
      parameterArray = children.slice(0, -1);
    }
    const lambdaId = Tools.generateRandomId(8);
    const currentLambdaPrivacyVar = /* @__PURE__ */ new Map();
    for (let i = 0; i < parameterArray.length; i++) {
      const parameter = parameterArray[i];
      if (parameter instanceof LexerNode) {
        const variant = parameter.getChildren()[0];
        parameter.setToken(DEFAULT_TOKEN_TYPE_LAMBDA_OMIT_PARAMETER);
        currentLambdaPrivacyVar.set(variant.trim(), void 0);
      } else {
        return ErrorNode.create("#VALUE!" /* VALUE */);
      }
    }
    this._runtimeService.registerFunctionDefinitionPrivacyVar(lambdaId, currentLambdaPrivacyVar);
    this._updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar);
    return new LambdaNode(param.getToken(), lambdaId, this._interpreter, [...currentLambdaPrivacyVar.keys()]);
  }
  checkAndCreateNodeType(param) {
    if (!(param instanceof LexerNode)) {
      return;
    }
    const token = param.getToken().trim().toUpperCase();
    if (token !== DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME) {
      return;
    }
    return this.create(param);
  }
  _updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar) {
    updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar);
  }
};
LambdaNodeFactory = __decorateClass([
  __decorateParam(0, IFormulaRuntimeService),
  __decorateParam(1, Inject(Interpreter))
], LambdaNodeFactory);

// ../packages/engine-formula/src/engine/ast-node/lambda-parameter-node.ts
function getRootLexerNode(node) {
  if (!node) {
    return;
  }
  if (node.getToken() !== DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
    return node;
  }
  const parameterNode = node;
  const currentLambdaPrivacyVar = parameterNode.getCurrentLambdaPrivacyVar();
  const lambdaParameter = parameterNode.getLambdaParameter();
  if (!currentLambdaPrivacyVar) {
    return;
  }
  return getRootLexerNode(currentLambdaPrivacyVar.get(lambdaParameter));
}
var LambdaParameterNode = class extends BaseAstNode {
  constructor(token, _lambdaParameter, _currentLambdaPrivacyVar) {
    super(token);
    this._lambdaParameter = _lambdaParameter;
    this._currentLambdaPrivacyVar = _currentLambdaPrivacyVar;
  }
  getLambdaParameter() {
    return this._lambdaParameter;
  }
  getCurrentLambdaPrivacyVar() {
    return this._currentLambdaPrivacyVar;
  }
  get nodeType() {
    return 6 /* LAMBDA_PARAMETER */;
  }
  execute() {
    const node = getRootLexerNode(this._currentLambdaPrivacyVar.get(this._lambdaParameter));
    if (!node) {
      const value = this.getValue();
      if (value == null || value.isError()) {
        this.setValue(ErrorValueObject.create("#NAME?" /* NAME */));
      }
    } else {
      this.setValue(node.getValue());
    }
  }
};
var LambdaParameterNodeFactory = class extends BaseAstNodeFactory {
  get zIndex() {
    return NODE_ORDER_MAP.get(6 /* LAMBDA_PARAMETER */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  create(param) {
    const currentLambdaPrivacyVar = param.getFunctionDefinitionPrivacyVar();
    const lambdaParameter = param.getLambdaParameter();
    if (!currentLambdaPrivacyVar) {
      return new ErrorNode("#NAME?" /* NAME */);
    }
    return new LambdaParameterNode(param.getToken(), lambdaParameter, currentLambdaPrivacyVar);
  }
  checkAndCreateNodeType(param) {
    if (!(param instanceof LexerNode)) {
      return;
    }
    const token = param.getToken().trim();
    if (token !== DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
      return;
    }
    return this.create(param);
  }
};

// ../packages/engine-formula/src/engine/ast-node/null-node.ts
var NullNode = class extends BaseAstNode {
  constructor(_operatorString) {
    super(_operatorString);
    this._operatorString = _operatorString;
  }
  get nodeType() {
    return 13 /* NULL */;
  }
  execute() {
    this.setValue(NullValueObject.create());
  }
};

// ../packages/engine-formula/src/engine/ast-node/operator-node.ts
var OperatorNode = class extends BaseAstNode {
  constructor(operatorString, _functionExecutor) {
    super(operatorString);
    this._functionExecutor = _functionExecutor;
  }
  get nodeType() {
    return 3 /* OPERATOR */;
  }
  execute() {
    const children = this.getChildren();
    if (this._functionExecutor.name === "COMPARE" /* COMPARE */) {
      this._functionExecutor.setCompareType(this.getToken());
    }
    const child1 = children[0];
    const child2 = children[1];
    let object1 = child1 == null ? void 0 : child1.getValue();
    let object2 = child2 == null ? void 0 : child2.getValue();
    const token = this.getToken();
    if ((object1 == null || object2 == null) && token !== "-" /* MINUS */ && token !== "+" /* PLUS */) {
      this.setValue(ErrorValueObject.create("#VALUE!" /* VALUE */));
      return;
    }
    if (object1 == null) {
      object1 = NullValueObject.create();
    }
    if (object2 == null) {
      object2 = NullValueObject.create();
    }
    if (object1.isReferenceObject()) {
      object1 = object1.toArrayValueObject();
    }
    if (object2.isReferenceObject()) {
      object2 = object2.toArrayValueObject();
    }
    this.setValue(
      this._functionExecutor.calculate(
        object1,
        object2
      )
    );
  }
};
var OperatorNodeFactory = class extends BaseAstNodeFactory {
  constructor(_functionService) {
    super();
    this._functionService = _functionService;
  }
  get zIndex() {
    return NODE_ORDER_MAP.get(3 /* OPERATOR */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  create(param) {
    let functionName = "";
    const tokenTrim = param;
    if (tokenTrim === "+" /* PLUS */) {
      functionName = "PLUS" /* PLUS */;
    } else if (tokenTrim === "-" /* MINUS */) {
      functionName = "MINUS" /* MINUS */;
    } else if (tokenTrim === "*" /* MULTIPLY */) {
      functionName = "MULTIPLY" /* MULTIPLY */;
    } else if (tokenTrim === "/" /* DIVIDED */) {
      functionName = "DIVIDED" /* DIVIDED */;
    } else if (tokenTrim === "&" /* CONCATENATE */) {
      functionName = "CONCATENATE" /* CONCATENATE */;
    } else if (tokenTrim === "^" /* POWER */) {
      functionName = "POWER" /* POWER */;
    } else if (OPERATOR_TOKEN_COMPARE_SET.has(tokenTrim)) {
      functionName = "COMPARE" /* COMPARE */;
    }
    const functionExecutor = this._functionService.getExecutor(functionName);
    if (!functionExecutor) {
      console.error(`No function ${param}`);
      return ErrorNode.create("#NAME?" /* NAME */);
    }
    return new OperatorNode(tokenTrim, functionExecutor);
  }
  checkAndCreateNodeType(param) {
    if (param instanceof LexerNode) {
      return;
    }
    const tokenTrim = param.trim();
    if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
      return;
    }
    if (OPERATOR_TOKEN_SET.has(tokenTrim)) {
      return this.create(tokenTrim);
    }
  }
};
OperatorNodeFactory = __decorateClass([
  __decorateParam(0, IFunctionService)
], OperatorNodeFactory);

// ../packages/engine-formula/src/engine/ast-node/reference-node.ts
var ReferenceNode = class extends BaseAstNode {
  constructor(_currentConfigService, _runtimeService, operatorString, _referenceObjectType, _isPrepareMerge = false) {
    super(operatorString);
    this._currentConfigService = _currentConfigService;
    this._runtimeService = _runtimeService;
    this._referenceObjectType = _referenceObjectType;
    this._isPrepareMerge = _isPrepareMerge;
    __publicField(this, "_refOffsetX", 0);
    __publicField(this, "_refOffsetY", 0);
  }
  get nodeType() {
    return 1 /* REFERENCE */;
  }
  execute() {
    const currentConfigService = this._currentConfigService;
    const runtimeService = this._runtimeService;
    const referenceObject = getReferenceObjectFromCache(this.getToken(), this._referenceObjectType);
    referenceObject.setDefaultUnitId(runtimeService.currentUnitId);
    referenceObject.setDefaultSheetId(runtimeService.currentSubUnitId);
    referenceObject.setForcedSheetId(currentConfigService.getSheetNameMap());
    referenceObject.setUnitData(currentConfigService.getUnitData());
    referenceObject.setArrayFormulaCellData(currentConfigService.getArrayFormulaCellData());
    referenceObject.setRuntimeData(runtimeService.getUnitData());
    referenceObject.setUnitStylesData(currentConfigService.getUnitStylesData());
    referenceObject.setRuntimeArrayFormulaCellData(runtimeService.getRuntimeArrayFormulaCellData());
    referenceObject.setRuntimeFeatureCellData(runtimeService.getRuntimeFeatureCellData());
    const { x, y } = this.getRefOffset();
    referenceObject.setRefOffset(x, y);
    if (!this._isPrepareMerge && referenceObject.isExceedRange()) {
      this.setValue(ErrorValueObject.create("#NAME?" /* NAME */));
    } else {
      this.setValue(referenceObject);
    }
  }
  setRefOffset(x = 0, y = 0) {
    this._refOffsetX = x;
    this._refOffsetY = y;
  }
  getRefOffset() {
    return {
      x: this._refOffsetX,
      y: this._refOffsetY
    };
  }
};
var ReferenceNodeFactory = class extends BaseAstNodeFactory {
  constructor(_currentConfigService, _formulaRuntimeService, _functionService) {
    super();
    this._currentConfigService = _currentConfigService;
    this._formulaRuntimeService = _formulaRuntimeService;
    this._functionService = _functionService;
  }
  get zIndex() {
    return NODE_ORDER_MAP.get(1 /* REFERENCE */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  checkAndCreateNodeType(param) {
    var _a2, _b2;
    let isLexerNode = false;
    let tokenTrimPre;
    let isPrepareMerge = false;
    if (param instanceof LexerNode) {
      isLexerNode = true;
      tokenTrimPre = param.getToken().trim();
      if (((_b2 = (_a2 = param.getParent()) == null ? void 0 : _a2.getParent()) == null ? void 0 : _b2.getToken().trim()) === ":" /* COLON */) {
        isPrepareMerge = true;
      }
    } else {
      tokenTrimPre = param.trim();
    }
    const currentConfigService = this._currentConfigService;
    const runtimeService = this._formulaRuntimeService;
    const { tokenTrim, minusPrefixNode, atPrefixNode } = prefixHandler(tokenTrimPre, this._functionService, runtimeService);
    if (!isLexerNode && tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
      return;
    }
    let node;
    if (regexTestSingeRange(tokenTrim)) {
      node = new ReferenceNode(currentConfigService, runtimeService, tokenTrim, 0 /* CELL */, isPrepareMerge);
    } else if (isLexerNode && this._checkParentIsUnionOperator(param)) {
      if (regexTestSingleRow(tokenTrim)) {
        node = new ReferenceNode(currentConfigService, runtimeService, tokenTrim, 2 /* ROW */, isPrepareMerge);
      } else if (regexTestSingleColumn(tokenTrim)) {
        node = new ReferenceNode(currentConfigService, runtimeService, tokenTrim, 1 /* COLUMN */, isPrepareMerge);
      }
    }
    if (node) {
      if (atPrefixNode) {
        node.setParent(atPrefixNode);
      } else if (minusPrefixNode) {
        node.setParent(minusPrefixNode);
      }
      return node;
    }
  }
  _checkParentIsUnionOperator(param) {
    var _a2, _b2;
    return ((_b2 = (_a2 = param.getParent()) == null ? void 0 : _a2.getParent()) == null ? void 0 : _b2.getToken().trim()) === ":" /* COLON */;
  }
};
ReferenceNodeFactory = __decorateClass([
  __decorateParam(0, IFormulaCurrentConfigService),
  __decorateParam(1, IFormulaRuntimeService),
  __decorateParam(2, IFunctionService)
], ReferenceNodeFactory);

// ../packages/engine-formula/src/engine/ast-node/suffix-node.ts
var SuffixNode = class extends BaseAstNode {
  constructor(_currentConfigService, _lexer, _operatorString, _functionExecutor) {
    super(_operatorString);
    this._currentConfigService = _currentConfigService;
    this._lexer = _lexer;
    this._operatorString = _operatorString;
    this._functionExecutor = _functionExecutor;
  }
  get nodeType() {
    return 12 /* SUFFIX */;
  }
  execute() {
    const children = this.getChildren();
    let value = children[0].getValue();
    let result;
    if (value == null) {
      throw new Error("object is null");
    }
    if (this._operatorString === "%" /* PERCENTAGE */) {
      if (value.isReferenceObject()) {
        value = value.toArrayValueObject();
      }
      result = this._functionExecutor.calculate(
        value,
        NumberValueObject.create(100)
      );
      if (result.isNumber()) {
        const value2 = Number(result.getValue());
        result = NumberValueObject.create(value2, "0.00%");
      }
    } else if (this._operatorString === "#" /* POUND */) {
      result = this._handlerPound(value);
    } else {
      result = ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    this.setValue(result);
  }
  _handlerPound(value) {
    var _a2, _b2, _c, _d;
    if (!value.isReferenceObject()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!value.isCell()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const cellValue = value;
    const range = cellValue.getRangePosition();
    const unitId = cellValue.getUnitId();
    const sheetId = cellValue.getSheetId();
    const formulaData = this._currentConfigService.getFormulaData();
    const formulaString = (_d = (_c = (_b2 = (_a2 = formulaData == null ? void 0 : formulaData[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2[range.startRow]) == null ? void 0 : _c[range.startColumn]) == null ? void 0 : _d.f;
    if (!formulaString) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const lexerNode = this._lexer.treeBuilder(formulaString);
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};
var SuffixNodeFactory = class extends BaseAstNodeFactory {
  constructor(_functionService, _lexer, _currentConfigService) {
    super();
    this._functionService = _functionService;
    this._lexer = _lexer;
    this._currentConfigService = _currentConfigService;
  }
  get zIndex() {
    return NODE_ORDER_MAP.get(12 /* SUFFIX */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  checkAndCreateNodeType(param) {
    if (!(param instanceof LexerNode)) {
      return;
    }
    const tokenTrim = param.getToken().trim();
    if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
      return;
    }
    let functionName = "";
    if (tokenTrim === "%" /* PERCENTAGE */) {
      functionName = "DIVIDED" /* DIVIDED */;
    } else if (tokenTrim === "#" /* POUND */) {
      return new SuffixNode(this._currentConfigService, this._lexer, tokenTrim);
    } else {
      return;
    }
    const functionExecutor = this._functionService.getExecutor(functionName);
    if (!functionExecutor) {
      console.error(`No function ${param}`);
      return ErrorNode.create("#NAME?" /* NAME */);
    }
    return new SuffixNode(this._currentConfigService, this._lexer, tokenTrim, functionExecutor);
  }
};
SuffixNodeFactory = __decorateClass([
  __decorateParam(0, IFunctionService),
  __decorateParam(1, Inject(Lexer)),
  __decorateParam(2, IFormulaCurrentConfigService)
], SuffixNodeFactory);

// ../packages/engine-formula/src/engine/ast-node/union-node.ts
var UnionNode = class extends BaseAstNode {
  constructor(operatorString) {
    super(operatorString);
  }
  get nodeType() {
    return 10 /* UNION */;
  }
  execute() {
    const children = this.getChildren();
    const leftChild = children[0];
    const rightChild = children[1];
    const leftNode = leftChild.getValue();
    const rightNode = rightChild.getValue();
    if (leftNode == null || rightNode == null) {
      throw new Error("leftNode and rightNode");
    }
    let result;
    if (this.getToken() === ":" /* COLON */) {
      result = this._unionFunction(leftNode, rightNode);
    } else {
      result = ErrorValueObject.create("#NAME?" /* NAME */);
    }
    this.setValue(result);
  }
  _unionFunction(variant1, variant2) {
    if (variant1.isError() || variant2.isError()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (!variant1.isReferenceObject() || !variant2.isReferenceObject()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    variant1 = variant1;
    variant2 = variant2;
    return getRangeReferenceObjectFromCache(variant1, variant2);
  }
};
var UnionNodeFactory = class extends BaseAstNodeFactory {
  constructor(_functionService) {
    super();
    this._functionService = _functionService;
  }
  get zIndex() {
    return NODE_ORDER_MAP.get(10 /* UNION */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  create(param) {
    return new UnionNode(param);
  }
  checkAndCreateNodeType(param) {
    if (!(param instanceof LexerNode)) {
      return;
    }
    const token = param.getToken();
    const tokenTrim = token.trim();
    if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
      return;
    }
    if (tokenTrim !== ":" /* COLON */) {
      return;
    }
    return this.create(tokenTrim);
  }
};
UnionNodeFactory = __decorateClass([
  __decorateParam(0, IFunctionService)
], UnionNodeFactory);

// ../packages/engine-formula/src/engine/ast-node/value-node.ts
var ValueNode = class extends BaseAstNode {
  constructor(operatorString) {
    super(operatorString);
  }
  get nodeType() {
    return 2 /* VALUE */;
  }
  execute() {
    this.setValue(ValueObjectFactory.create(this.getToken()));
  }
};
var ValueNodeFactory = class extends BaseAstNodeFactory {
  get zIndex() {
    return NODE_ORDER_MAP.get(2 /* VALUE */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
  }
  _checkValueNode(token) {
    if (Number.isNaN(Number(token))) {
      const tokenTrim = token.trim();
      const startToken = tokenTrim.charAt(0);
      const endToken = tokenTrim.charAt(tokenTrim.length - 1);
      if (ERROR_TYPE_SET.has(tokenTrim)) {
        return this.create(tokenTrim);
      }
      if (startToken === '"' && endToken === '"') {
        return this.create(tokenTrim);
      }
      if (startToken === "{" && endToken === "}") {
        return this.create(tokenTrim);
      }
      const tokenTrimUpper = tokenTrim.toUpperCase();
      if (tokenTrimUpper === "TRUE" /* TRUE */ || tokenTrimUpper === "FALSE" /* FALSE */) {
        return this.create(tokenTrimUpper);
      }
    } else {
      return this.create(token);
    }
  }
  create(param) {
    return new ValueNode(param);
  }
  checkAndCreateNodeType(param) {
    if (param instanceof LexerNode) {
      return;
    }
    return this._checkValueNode(param);
  }
};

// ../packages/engine-formula/src/engine/analysis/parser.ts
var AstTreeBuilder = class extends Disposable {
  constructor(_runtimeService, _astRootNodeFactory, _functionNodeFactory, _lambdaNodeFactory, _lambdaParameterNodeFactory, _operatorNodeFactory, _prefixNodeFactory, _referenceNodeFactory, _suffixNodeFactory, _unionNodeFactory, _valueNodeFactory) {
    super();
    this._runtimeService = _runtimeService;
    this._astRootNodeFactory = _astRootNodeFactory;
    this._functionNodeFactory = _functionNodeFactory;
    this._lambdaNodeFactory = _lambdaNodeFactory;
    this._lambdaParameterNodeFactory = _lambdaParameterNodeFactory;
    this._operatorNodeFactory = _operatorNodeFactory;
    this._prefixNodeFactory = _prefixNodeFactory;
    this._referenceNodeFactory = _referenceNodeFactory;
    this._suffixNodeFactory = _suffixNodeFactory;
    this._unionNodeFactory = _unionNodeFactory;
    this._valueNodeFactory = _valueNodeFactory;
    __publicField(this, "_astNodeFactoryList", []);
    this._initializeAstNode();
  }
  dispose() {
    this._astNodeFactoryList.forEach((nodeFactory) => {
      nodeFactory.dispose();
    });
    this._astNodeFactoryList = [];
  }
  parse(lexerNode) {
    const astNode = new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
    const node = this._parse(lexerNode, astNode);
    if (lexerNode.hasDefinedNames()) {
      node == null ? void 0 : node.setDefinedNames(lexerNode.getDefinedNames());
    }
    return node;
  }
  _lambdaParameterHandler(lexerNode, parent) {
    if (parent.getLambdaId == null) {
      return ErrorNode.create("#VALUE!" /* VALUE */);
    }
    const lambdaId = parent.getLambdaId();
    const parentAstNode = new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
    const currentLambdaPrivacyVar = this._runtimeService.getFunctionDefinitionPrivacyVar(lambdaId);
    if (!currentLambdaPrivacyVar) {
      return false;
    }
    const currentLambdaPrivacyVarKeys = [...currentLambdaPrivacyVar.keys()];
    const children = lexerNode.getChildren();
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      if (item instanceof LexerNode) {
        updateLambdaStatement(item, lambdaId, currentLambdaPrivacyVar);
        this._parse(item, parentAstNode);
        const parentChildren = parentAstNode.getChildren();
        const valueNode = parentChildren[i];
        if (valueNode != null) {
          currentLambdaPrivacyVar.set(currentLambdaPrivacyVarKeys[i], valueNode);
        }
      } else {
        return false;
      }
    }
    parentAstNode.setParent(parent);
    return parent;
  }
  _changeLetToLambda(letLexerNode) {
    const letChildren = letLexerNode.getChildren();
    const letChildrenCount = letChildren.length;
    if (letChildrenCount % 2 !== 1 || letChildrenCount === 0) {
      return;
    }
    const newLambdaNode = new LexerNode();
    newLambdaNode.setToken(DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME);
    const newLambdaParameterNode = new LexerNode();
    newLambdaParameterNode.setToken(DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER);
    const copyChildren = [...letChildren];
    for (let i = 0; i < letChildrenCount; i++) {
      const child = copyChildren[i];
      if (!(child instanceof LexerNode)) {
        return;
      }
      if (i % 2 === 0) {
        child.changeToParent(newLambdaNode);
      } else {
        child.changeToParent(newLambdaParameterNode);
      }
    }
    newLambdaNode.addChildrenFirst(newLambdaParameterNode);
    newLambdaParameterNode.setParent(newLambdaNode);
    const parent = letLexerNode.getParent();
    parent == null ? void 0 : parent.replaceChild(letLexerNode, newLambdaNode);
    return newLambdaNode;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _parse(lexerNode, parent) {
    var _a2;
    const children = lexerNode.getChildren();
    const childrenCount = children.length;
    const calculateStack = [];
    let currentAstNode = null;
    const token = lexerNode.getToken().trim().toUpperCase();
    if (token === DEFAULT_TOKEN_LET_FUNCTION_NAME) {
      const resultNode = this._changeLetToLambda(lexerNode);
      if (resultNode != null) {
        return this._parse(resultNode, parent);
      }
      return ErrorNode.create("#ERROR!" /* ERROR */);
    }
    if (token === DEFAULT_TOKEN_TYPE_PARAMETER) {
      currentAstNode = parent;
      if (childrenCount === 0) {
        const nullNode = new NullNode(DEFAULT_TOKEN_TYPE_ROOT);
        nullNode.setParent(parent);
        return currentAstNode;
      }
    } else {
      if (token === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
        let resultNode = this._lambdaParameterHandler(lexerNode, parent);
        if (resultNode === false) {
          resultNode = ErrorNode.create("#ERROR!" /* ERROR */);
        }
        return resultNode;
      }
      currentAstNode = this._checkAstNode(lexerNode);
      if (currentAstNode == null) {
        return ErrorNode.create("#NAME?" /* NAME */);
      }
    }
    const firstChild = children[0];
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      if (isFirstChildParameter(firstChild)) {
        if (i !== 0 && i !== childrenCount - 1) {
          continue;
        }
      } else if (isChildRunTimeParameter(item)) {
        if (i !== childrenCount - 1) {
          continue;
        }
      }
      let astNode = null;
      if (item instanceof LexerNode) {
        if (item.getToken() === DEFAULT_TOKEN_TYPE_PARAMETER && item.getChildren().length === 0) {
          const children2 = (_a2 = item.getParent()) == null ? void 0 : _a2.getChildren();
          if (children2 && children2.length === 1) {
            return ErrorNode.create("#NAME?" /* NAME */);
          }
        }
        astNode = this._parse(item, currentAstNode);
        if (astNode === currentAstNode) {
          continue;
        }
      } else {
        astNode = this._checkAstNode(item);
      }
      if (astNode == null) {
        return ErrorNode.create("#NAME?" /* NAME */);
      }
      astNode = getAstNodeTopParent(astNode);
      if (astNode == null || (astNode == null ? void 0 : astNode.nodeType) === 7 /* ERROR */) {
        return astNode;
      }
      switch (astNode.nodeType) {
        // case NodeType.ERROR:
        //     return astNode;
        case 4 /* FUNCTION */: {
          const token2 = astNode.getToken().trim().toUpperCase();
          if (FORCED_RECALCULATION_FUNCTION_NAME.has(token2)) {
            astNode.setForcedCalculateFunction();
          }
          calculateStack.push(astNode);
          break;
        }
        case 5 /* LAMBDA */:
          calculateStack.push(astNode);
          break;
        case 6 /* LAMBDA_PARAMETER */:
          calculateStack.push(astNode);
          break;
        case 3 /* OPERATOR */: {
          const parameterNode1 = calculateStack.pop();
          const parameterNode2 = calculateStack.pop();
          if (parameterNode2) {
            parameterNode2.setParent(astNode);
          }
          if (parameterNode1) {
            parameterNode1.setParent(astNode);
          }
          calculateStack.push(astNode);
          break;
        }
        case 1 /* REFERENCE */:
          calculateStack.push(astNode);
          break;
        case 9 /* ROOT */:
          calculateStack.push(astNode);
          break;
        case 10 /* UNION */:
          calculateStack.push(astNode);
          break;
        case 2 /* VALUE */:
          calculateStack.push(astNode);
          break;
        case 11 /* PREFIX */:
          calculateStack.push(astNode);
          break;
        case 12 /* SUFFIX */:
          calculateStack.push(astNode);
          break;
      }
    }
    const calculateStackCount = calculateStack.length;
    for (let i = 0; i < calculateStackCount; i++) {
      const item = calculateStack[i];
      item.setParent(currentAstNode);
    }
    return currentAstNode;
  }
  // private _setPrefixRefOffset(astNode: BaseAstNode) {
  //     const children = astNode.getChildren();
  //     const childrenCount = children.length;
  //     for (let i = 0; i < childrenCount; i++) {
  //         const item = children[i];
  //         if (item.nodeType === NodeType.REFERENCE) {
  //             item.setRefOffset(this._refOffsetX, this._refOffsetY);
  //         }
  //     }
  // }
  _checkAstNode(item) {
    let astNode = null;
    const astNodeFactoryListCount = this._astNodeFactoryList.length;
    for (let x = 0; x < astNodeFactoryListCount; x++) {
      const astNodeFactory = this._astNodeFactoryList[x];
      astNode = astNodeFactory.checkAndCreateNodeType(item);
      if (astNode != null) {
        break;
      }
    }
    if (astNode == null) {
      return new ErrorFunctionNode();
    }
    return astNode;
  }
  _initializeAstNode() {
    this._astNodeFactoryList = [
      this._astRootNodeFactory,
      this._functionNodeFactory,
      this._lambdaNodeFactory,
      this._lambdaParameterNodeFactory,
      this._operatorNodeFactory,
      this._prefixNodeFactory,
      this._referenceNodeFactory,
      this._suffixNodeFactory,
      this._unionNodeFactory,
      this._valueNodeFactory
    ].sort(sortRules);
  }
};
AstTreeBuilder = __decorateClass([
  __decorateParam(0, IFormulaRuntimeService),
  __decorateParam(1, Inject(AstRootNodeFactory)),
  __decorateParam(2, Inject(FunctionNodeFactory)),
  __decorateParam(3, Inject(LambdaNodeFactory)),
  __decorateParam(4, Inject(LambdaParameterNodeFactory)),
  __decorateParam(5, Inject(OperatorNodeFactory)),
  __decorateParam(6, Inject(PrefixNodeFactory)),
  __decorateParam(7, Inject(ReferenceNodeFactory)),
  __decorateParam(8, Inject(SuffixNodeFactory)),
  __decorateParam(9, Inject(UnionNodeFactory)),
  __decorateParam(10, Inject(ValueNodeFactory))
], AstTreeBuilder);

// ../packages/engine-formula/src/services/dependency-manager.service.ts
var DependencyManagerBaseService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_otherFormulaData", /* @__PURE__ */ new Map());
    //  [unitId: string]: Nullable<{ [sheetId: string]: { [formulaId: string]: Set<number> } }>;
    __publicField(this, "_featureFormulaData", /* @__PURE__ */ new Map());
    // [unitId: string]: Nullable<{ [sheetId: string]: { [featureId: string]: Nullable<number> } }>;
    __publicField(this, "_formulaData", /* @__PURE__ */ new Map());
    // [unitId: string]: Nullable<{ [sheetId: string]: ObjectMatrix<number> }>;
    __publicField(this, "_definedNameMap", /* @__PURE__ */ new Map());
    // unitId -> definedName -> treeId
    __publicField(this, "_otherFormulaDataMainData", /* @__PURE__ */ new Set());
    __publicField(this, "_dependencyRTreeCache", new RTree());
    __publicField(this, "_dependencyTreeIdLast", 0);
  }
  buildDependencyTree(shouldBeBuildTrees, dependencyTrees) {
    throw new Error("Method not implemented.");
  }
  getTreeById(treeId) {
    throw new Error("Method not implemented.");
  }
  getAllTree() {
    throw new Error("Method not implemented.");
  }
  reset() {
    throw new Error("Method not implemented.");
  }
  addOtherFormulaDependency(unitId, sheetId, formulaId, dependencyTree) {
    throw new Error("Method not implemented.");
  }
  removeOtherFormulaDependency(unitId, sheetId, formulaId) {
    throw new Error("Method not implemented.");
  }
  clearOtherFormulaDependency(unitId, sheetId) {
    throw new Error("Method not implemented.");
  }
  addFeatureFormulaDependency(unitId, sheetId, featureId, dependencyTree) {
    throw new Error("Method not implemented.");
  }
  removeFeatureFormulaDependency(unitId, sheetId, featureIds) {
    throw new Error("Method not implemented.");
  }
  clearFeatureFormulaDependency(unitId, sheetId) {
    throw new Error("Method not implemented.");
  }
  addFormulaDependency(unitId, sheetId, row, column, dependencyTree) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependency(unitId, sheetId, row, column) {
    throw new Error("Method not implemented.");
  }
  clearFormulaDependency(unitId, sheetId) {
    throw new Error("Method not implemented.");
  }
  removeFormulaDependencyByDefinedName(unitId, definedName) {
    throw new Error("Method not implemented.");
  }
  searchDependency(search, exceptTreeIds) {
    return this._dependencyRTreeCache.bulkSearch(search, exceptTreeIds);
  }
  _restDependencyTreeId() {
    this._dependencyTreeIdLast = 0;
  }
  getOtherFormulaDependency(unitId, sheetId, formulaId) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._otherFormulaData.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(formulaId);
  }
  addOtherFormulaDependencyMainData(formulaId) {
    this._otherFormulaDataMainData.add(formulaId);
  }
  hasOtherFormulaDataMainData(formulaId) {
    return this._otherFormulaDataMainData.has(formulaId);
  }
  _removeDependencyRTreeCacheById(unitId, sheetId) {
    this._dependencyRTreeCache.removeById(unitId, sheetId);
  }
  getFeatureFormulaDependency(unitId, sheetId, featureId) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._featureFormulaData.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(featureId);
  }
  getFormulaDependency(unitId, sheetId, row, column) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._formulaData.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.getValue(row, column);
  }
  addDependencyRTreeCache(tree) {
    const searchRanges = [];
    for (let i = 0; i < tree.rangeList.length; i++) {
      const unitRangeWithNum = tree.rangeList[i];
      const { unitId, sheetId, range } = unitRangeWithNum;
      searchRanges.push({
        unitId,
        sheetId,
        range,
        id: tree.treeId
      });
    }
    this._dependencyRTreeCache.bulkInsert(searchRanges);
    this._addAllTreeMap(tree);
  }
  getLastTreeId() {
    const id = this._dependencyTreeIdLast;
    this._dependencyTreeIdLast++;
    return id;
  }
  _addAllTreeMap(tree) {
    throw new Error("Method not implemented.");
  }
  _addDefinedName(unitId, definedName, treeId) {
    if (!this._definedNameMap.has(unitId)) {
      this._definedNameMap.set(unitId, /* @__PURE__ */ new Map());
    }
    const unitMap = this._definedNameMap.get(unitId);
    if (!unitMap.has(definedName)) {
      unitMap.set(definedName, /* @__PURE__ */ new Set());
    }
    const treeSet = unitMap.get(definedName);
    treeSet.add(treeId);
  }
  addFormulaDependencyByDefinedName(tree, node) {
    const treeId = tree.treeId;
    const definedNames = (node == null ? void 0 : node.getDefinedNames()) || [];
    for (const definedName of definedNames) {
      this._addDefinedName(tree.unitId, definedName, treeId);
    }
  }
};
var DependencyManagerService = class extends DependencyManagerBaseService {
  constructor() {
    super(...arguments);
    __publicField(this, "_allTreeMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose();
    this.reset();
  }
  buildDependencyTree(shouldBeBuildTrees, dependencyTrees = []) {
    const allTrees = this.getAllTree();
    if (shouldBeBuildTrees.length === 0) {
      this._buildReverseDependency(allTrees, dependencyTrees);
      return allTrees;
    }
    this._buildDependencyTree(allTrees, shouldBeBuildTrees);
    this._buildReverseDependency(allTrees, shouldBeBuildTrees);
    return allTrees;
  }
  /**
   * Build the dependency relationship between the trees.
   * @param allTrees  all FormulaDependencyTree
   * @param shouldBeBuildTrees  FormulaDependencyTree[] | FormulaDependencyTreeCache
   */
  _buildDependencyTree(allTrees, shouldBeBuildTrees) {
    const shouldBeBuildTreeMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < shouldBeBuildTrees.length; i++) {
      const tree = shouldBeBuildTrees[i];
      shouldBeBuildTreeMap.set(tree.treeId, tree);
    }
    for (let i = 0; i < allTrees.length; i++) {
      const tree = allTrees[i];
      const RTreeItem = tree.toRTreeItem();
      const searchResults = this._dependencyRTreeCache.bulkSearch(RTreeItem);
      for (const id of searchResults) {
        const shouldBeBuildTree = shouldBeBuildTreeMap.get(id);
        if (shouldBeBuildTree && tree !== shouldBeBuildTree && !shouldBeBuildTree.hasChildren(tree.treeId)) {
          shouldBeBuildTree.pushChildren(tree);
        }
      }
    }
    shouldBeBuildTreeMap.clear();
  }
  /**
   * Build the reverse dependency relationship between the trees.
   * @param allTrees
   * @param dependencyTrees
   */
  _buildReverseDependency(allTrees, dependencyTrees) {
    const allTreeMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < allTrees.length; i++) {
      const tree = allTrees[i];
      allTreeMap.set(tree.treeId, tree);
    }
    for (let i = 0; i < dependencyTrees.length; i++) {
      const tree = dependencyTrees[i];
      const RTreeItem = tree.toRTreeItem();
      const searchResults = this._dependencyRTreeCache.bulkSearch(RTreeItem);
      for (const id of searchResults) {
        const allTree = allTreeMap.get(id);
        if (allTree && tree !== allTree && !allTree.hasChildren(tree.treeId)) {
          allTree.pushChildren(tree);
        }
      }
    }
    allTreeMap.clear();
  }
  /**
   * Get all FormulaDependencyTree from _otherFormulaData, _featureFormulaData, _formulaData
   * return FormulaDependencyTree[]
   */
  getAllTree() {
    const trees = [];
    this._allTreeMap.forEach((tree) => {
      tree.resetState();
      trees.push(tree);
    });
    return trees;
  }
  getTreeById(treeId) {
    return this._allTreeMap.get(treeId);
  }
  reset() {
    this._otherFormulaData.clear();
    this._featureFormulaData.clear();
    this._formulaData.clear();
    this._definedNameMap.clear();
    this._otherFormulaDataMainData.clear();
    this._dependencyRTreeCache.clear();
    this._allTreeMap.clear();
    this._restDependencyTreeId();
  }
  addOtherFormulaDependency(unitId, sheetId, formulaId, dependencyTree) {
    if (!this._otherFormulaData.has(unitId)) {
      this._otherFormulaData.set(unitId, /* @__PURE__ */ new Map());
    }
    const unitMap = this._otherFormulaData.get(unitId);
    if (!unitMap.has(sheetId)) {
      unitMap.set(sheetId, /* @__PURE__ */ new Map());
    }
    const sheetMap = unitMap.get(sheetId);
    if (!sheetMap.has(formulaId)) {
      sheetMap.set(formulaId, new ObjectMatrix());
    }
    const formulaMatrix = sheetMap.get(formulaId);
    formulaMatrix.setValue(dependencyTree.refOffsetX, dependencyTree.refOffsetY, dependencyTree.treeId);
    this._addAllTreeMap(dependencyTree);
  }
  removeOtherFormulaDependency(unitId, sheetId, formulaIds) {
    const unitMap = this._otherFormulaData.get(unitId);
    if (unitMap && unitMap.has(sheetId)) {
      const sheetMap = unitMap.get(sheetId);
      formulaIds.forEach((formulaId) => {
        const treeSet = sheetMap.get(formulaId);
        if (treeSet == null) {
          return;
        }
        treeSet.forValue((row, column, treeId) => {
          this._removeDependencyRTreeCache(treeId);
          this.clearDependencyForTree(this._allTreeMap.get(treeId));
          this._removeAllTreeMap(treeId);
        });
        sheetMap.delete(formulaId);
        this._otherFormulaDataMainData.delete(formulaId);
      });
      if (sheetMap.size === 0) {
        unitMap.delete(sheetId);
      }
      if (unitMap.size === 0) {
        this._otherFormulaData.delete(unitId);
      }
    }
  }
  clearOtherFormulaDependency(unitId, sheetId) {
    const unitMap = this._otherFormulaData.get(unitId);
    if (sheetId && unitMap && unitMap.has(sheetId)) {
      const sheetMap = unitMap.get(sheetId);
      this._removeDependencyRTreeCacheById(unitId, sheetId);
      for (const formulaId of sheetMap.keys()) {
        const formulaTreeSet = sheetMap.get(formulaId);
        if (formulaTreeSet == null) {
          continue;
        }
        formulaTreeSet.forValue((row, column, treeId) => {
          const tree = this._allTreeMap.get(treeId);
          if (tree) {
            this.clearDependencyForTree(tree);
            this._removeAllTreeMap(treeId);
          }
        });
        this._otherFormulaDataMainData.delete(formulaId);
      }
      sheetMap.clear();
    } else if (unitMap) {
      for (const sheetId2 of unitMap.keys()) {
        const sheetMap = unitMap.get(sheetId2);
        this._removeDependencyRTreeCacheById(unitId, sheetId2);
        for (const formulaId of sheetMap.keys()) {
          const formulaTreeSet = sheetMap.get(formulaId);
          if (formulaTreeSet == null) {
            continue;
          }
          formulaTreeSet.forValue((row, column, treeId) => {
            const tree = this._allTreeMap.get(treeId);
            if (tree) {
              this.clearDependencyForTree(tree);
              this._removeAllTreeMap(treeId);
            }
          });
          this._otherFormulaDataMainData.delete(formulaId);
        }
      }
      this._otherFormulaData.delete(unitId);
    }
  }
  addFeatureFormulaDependency(unitId, sheetId, featureId, dependencyTree) {
    if (!this._featureFormulaData.has(unitId)) {
      this._featureFormulaData.set(unitId, /* @__PURE__ */ new Map());
    }
    const unitMap = this._featureFormulaData.get(unitId);
    if (!unitMap.has(sheetId)) {
      unitMap.set(sheetId, /* @__PURE__ */ new Map());
    }
    const sheetMap = unitMap.get(sheetId);
    sheetMap.set(featureId, dependencyTree.treeId);
    this._addAllTreeMap(dependencyTree);
  }
  removeFeatureFormulaDependency(unitId, sheetId, featureIds) {
    const unitMap = this._featureFormulaData.get(unitId);
    if (unitMap && unitMap.has(sheetId)) {
      const sheetMap = unitMap.get(sheetId);
      featureIds.forEach((featureId) => {
        const deleteTreeId = sheetMap.get(featureId);
        if (deleteTreeId == null) {
          return;
        }
        this._removeDependencyRTreeCache(deleteTreeId);
        sheetMap.delete(featureId);
        this.clearDependencyForTree(this._allTreeMap.get(deleteTreeId));
        this._removeAllTreeMap(deleteTreeId);
      });
    }
  }
  clearFeatureFormulaDependency(unitId, sheetId) {
    const unitMap = this._featureFormulaData.get(unitId);
    if (sheetId && unitMap && unitMap.has(sheetId)) {
      const sheetMap = unitMap.get(sheetId);
      this._removeDependencyRTreeCacheById(unitId, sheetId);
      sheetMap.forEach((featureTreeId) => {
        if (featureTreeId == null) {
          return;
        }
        this.clearDependencyForTree(this._allTreeMap.get(featureTreeId));
        this._removeAllTreeMap(featureTreeId);
      });
      sheetMap.clear();
    } else if (unitMap) {
      unitMap.forEach((sheetMap, sheetId2) => {
        this._removeDependencyRTreeCacheById(unitId, sheetId2);
        sheetMap.forEach((featureTreeId) => {
          if (featureTreeId == null) {
            return;
          }
          this.clearDependencyForTree(this._allTreeMap.get(featureTreeId));
          this._removeAllTreeMap(featureTreeId);
        });
      });
      this._featureFormulaData.delete(unitId);
    }
  }
  addFormulaDependency(unitId, sheetId, row, column, dependencyTree) {
    if (!this._formulaData.has(unitId)) {
      this._formulaData.set(unitId, /* @__PURE__ */ new Map());
    }
    const unitMap = this._formulaData.get(unitId);
    if (!unitMap.has(sheetId)) {
      unitMap.set(sheetId, new ObjectMatrix());
    }
    const sheetMatrix = unitMap.get(sheetId);
    sheetMatrix.setValue(row, column, dependencyTree.treeId);
    this._addAllTreeMap(dependencyTree);
  }
  removeFormulaDependency(unitId, sheetId, row, column) {
    const unitMap = this._formulaData.get(unitId);
    if (unitMap && unitMap.has(sheetId)) {
      const sheetMatrix = unitMap.get(sheetId);
      const deleteTreeId = sheetMatrix.getValue(row, column);
      if (deleteTreeId == null) {
        return;
      }
      this._removeDependencyRTreeCache(deleteTreeId);
      sheetMatrix.realDeleteValue(row, column);
      this.clearDependencyForTree(this._allTreeMap.get(deleteTreeId));
      this._removeAllTreeMap(deleteTreeId);
    }
  }
  clearFormulaDependency(unitId, sheetId) {
    const unitMap = this._formulaData.get(unitId);
    if (sheetId && unitMap && unitMap.has(sheetId)) {
      const sheetMatrix = unitMap.get(sheetId);
      this._removeDependencyRTreeCacheById(unitId, sheetId);
      sheetMatrix.forValue((row, column, treeId) => {
        if (treeId == null) {
          return true;
        }
        this.clearDependencyForTree(this._allTreeMap.get(treeId));
        this._removeAllTreeMap(treeId);
      });
      sheetMatrix.reset();
    } else if (unitMap) {
      unitMap.forEach((sheetMatrix, sheetId2) => {
        this._removeDependencyRTreeCacheById(unitId, sheetId2);
        sheetMatrix.forValue((row, column, treeId) => {
          if (treeId == null) {
            return true;
          }
          this.clearDependencyForTree(this._allTreeMap.get(treeId));
          this._removeAllTreeMap(treeId);
        });
      });
      this._formulaData.delete(unitId);
    }
  }
  /**
   * Clear the dependency relationship of the tree.
   * establish the relationship between the parent and the child.
   * @param shouldBeClearTree
   */
  clearDependencyForTree(shouldBeClearTree) {
    if (shouldBeClearTree == null) {
      return;
    }
    const parents = shouldBeClearTree.parents;
    const children = shouldBeClearTree.children;
    const allTreeMap = this._allTreeMap;
    for (const parentTreeId of parents) {
      const parent = allTreeMap.get(parentTreeId);
      parent == null ? void 0 : parent.children.delete(shouldBeClearTree.treeId);
    }
    for (const childTreeId of children) {
      const child = allTreeMap.get(childTreeId);
      child == null ? void 0 : child.parents.delete(shouldBeClearTree.treeId);
    }
    shouldBeClearTree.dispose();
  }
  _removeDependencyRTreeCache(treeId) {
    if (treeId == null) {
      return;
    }
    const treeRangeMap = this._allTreeMap.get(treeId);
    if (treeRangeMap) {
      const searchRanges = [];
      for (let i = 0; i < treeRangeMap.rangeList.length; i++) {
        const unitRangeWithNum = treeRangeMap.rangeList[i];
        const { unitId, sheetId, range } = unitRangeWithNum;
        searchRanges.push({
          unitId,
          sheetId,
          range,
          id: treeId
        });
      }
      this._dependencyRTreeCache.bulkRemove(searchRanges);
    }
  }
  removeFormulaDependencyByDefinedName(unitId, definedName) {
    const unitMap = this._definedNameMap.get(unitId);
    if (unitMap) {
      const treeSet = unitMap.get(definedName);
      if (treeSet) {
        for (const treeId of treeSet) {
          this._removeDependencyRTreeCache(treeId);
          this.clearDependencyForTree(this._allTreeMap.get(treeId));
          this._removeAllTreeMap(treeId);
        }
        treeSet.clear();
      }
    }
  }
  _removeAllTreeMap(treeId) {
    if (treeId == null) {
      return;
    }
    this._allTreeMap.delete(treeId);
  }
  _addAllTreeMap(tree) {
    this._allTreeMap.set(tree.treeId, tree);
  }
};
var IDependencyManagerService = createIdentifier(
  "univer.formula.dependency-manager.service"
);

// ../packages/engine-formula/src/services/feature-calculation-manager.service.ts
var import_rxjs22 = __toESM(require_cjs());
var FeatureCalculationManagerService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_referenceExecutorMap", /* @__PURE__ */ new Map());
    // unitId -> subUnitId -> featureId -> IFeatureCalculationManagerParam
    __publicField(this, "_onChanged$", new import_rxjs22.Subject());
    __publicField(this, "onChanged$", this._onChanged$.asObservable());
  }
  dispose() {
    super.dispose();
    this._referenceExecutorMap.clear();
    this._onChanged$.complete();
  }
  remove(unitId, subUnitId, featureIds) {
    featureIds.forEach((featureId) => {
      var _a2, _b2;
      (_b2 = (_a2 = this._referenceExecutorMap.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.delete(featureId);
    });
    this._onChanged$.next({
      unitId,
      subUnitId,
      featureIds
    });
  }
  get(unitId, subUnitId, featureId) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._referenceExecutorMap.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.get(featureId);
  }
  has(unitId, subUnitId, featureId) {
    var _a2, _b2;
    return Boolean((_b2 = (_a2 = this._referenceExecutorMap.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.has(featureId));
  }
  register(unitId, subUnitId, featureId, referenceExecutor) {
    let unitMap = this._referenceExecutorMap.get(unitId);
    if (!unitMap) {
      unitMap = /* @__PURE__ */ new Map();
      this._referenceExecutorMap.set(unitId, unitMap);
    }
    let subUnitMap = unitMap.get(subUnitId);
    if (!subUnitMap) {
      subUnitMap = /* @__PURE__ */ new Map();
      unitMap.set(subUnitId, subUnitMap);
    }
    this._onChanged$.next({
      unitId,
      subUnitId,
      featureIds: [featureId]
    });
    subUnitMap.set(featureId, referenceExecutor);
  }
  getReferenceExecutorMap() {
    return this._referenceExecutorMap;
  }
};
var IFeatureCalculationManagerService = createIdentifier(
  "univer.formula.feature-calculation-manager.service"
);

// ../packages/engine-formula/src/services/other-formula-manager.service.ts
var OtherFormulaManagerService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_otherFormulaData", {});
  }
  dispose() {
    super.dispose();
    this._otherFormulaData = {};
  }
  remove(searchParam) {
    var _a2, _b2, _c;
    const { unitId, subUnitId, formulaId } = searchParam;
    (_c = (_b2 = (_a2 = this._otherFormulaData) == null ? void 0 : _a2[unitId]) == null ? void 0 : _b2[subUnitId]) == null ? true : delete _c[formulaId];
  }
  get(searchParam) {
    var _a2, _b2;
    const { unitId, subUnitId, formulaId } = searchParam;
    return (_b2 = (_a2 = this._otherFormulaData[unitId]) == null ? void 0 : _a2[subUnitId]) == null ? void 0 : _b2[formulaId];
  }
  has(searchParam) {
    var _a2, _b2;
    const { unitId, subUnitId, formulaId } = searchParam;
    return ((_b2 = (_a2 = this._otherFormulaData[unitId]) == null ? void 0 : _a2[subUnitId]) == null ? void 0 : _b2[formulaId]) != null;
  }
  register(insertParam) {
    const { unitId, subUnitId, formulaId, item } = insertParam;
    if (!this._otherFormulaData[unitId]) {
      this._otherFormulaData[unitId] = {};
    }
    if (!this._otherFormulaData[unitId][subUnitId]) {
      this._otherFormulaData[unitId][subUnitId] = {};
    }
    this._otherFormulaData[unitId][subUnitId][formulaId] = item;
  }
  batchRegister(formulaData) {
    Object.keys(formulaData).forEach((unitId) => {
      const subUnits = formulaData[unitId];
      if (subUnits == null) {
        return true;
      }
      Object.keys(subUnits).forEach((subUnitId) => {
        const subUnit = subUnits[subUnitId];
        if (subUnit == null) {
          return true;
        }
        Object.keys(subUnit).forEach((formulaId) => {
          const item = subUnit[formulaId];
          if (item == null) {
            return true;
          }
          this.register({
            unitId,
            subUnitId,
            formulaId,
            item
          });
        });
      });
    });
  }
  batchRemove(formulaData) {
    Object.keys(formulaData).forEach((unitId) => {
      const subUnits = formulaData[unitId];
      if (subUnits == null) {
        return true;
      }
      Object.keys(subUnits).forEach((subUnitId) => {
        const subUnit = subUnits[subUnitId];
        if (subUnit == null) {
          return true;
        }
        Object.keys(subUnit).forEach((formulaId) => {
          this.remove({
            unitId,
            subUnitId,
            formulaId
          });
        });
      });
    });
  }
  getOtherFormulaData() {
    return this._otherFormulaData;
  }
};
var IOtherFormulaManagerService = createIdentifier(
  "univer.formula.other-formula-manager.service"
);

// ../packages/engine-formula/src/engine/dependency/dependency-tree.ts
var FormulaDependencyTreeCalculator = class {
  constructor() {
    __publicField(this, "_state", 0 /* DEFAULT */);
    __publicField(this, "treeId");
    __publicField(this, "children", /* @__PURE__ */ new Set());
    __publicField(this, "parents", /* @__PURE__ */ new Set());
  }
  resetState() {
    this._state = 0 /* DEFAULT */;
  }
  setAdded() {
    this._state = 1 /* ADDED */;
  }
  isAdded() {
    return this._state === 1 /* ADDED */;
  }
  setSkip() {
    this._state = 2 /* SKIP */;
  }
  isSkip() {
    return this._state === 2 /* SKIP */;
  }
  pushChildren(tree) {
    this.children.add(tree.treeId);
    tree._pushParent(this);
  }
  hasChildren(treeId) {
    return this.children.has(treeId);
  }
  _pushParent(tree) {
    this.parents.add(tree.treeId);
  }
};
var FormulaDependencyTreeVirtual = class extends FormulaDependencyTreeCalculator {
  constructor() {
    super(...arguments);
    __publicField(this, "refTree");
    __publicField(this, "refOffsetX", -1);
    __publicField(this, "refOffsetY", -1);
    __publicField(this, "isCache", false);
    __publicField(this, "isDirty", false);
    __publicField(this, "addressFunctionNodes", []);
    __publicField(this, "getDirtyData");
    __publicField(this, "featureId");
  }
  get isVirtual() {
    return true;
  }
  get row() {
    if (this.refTree == null) {
      return -1;
    }
    return this.refTree.row + this.refOffsetY;
  }
  get column() {
    if (this.refTree == null) {
      return -1;
    }
    return this.refTree.column + this.refOffsetX;
  }
  get rowCount() {
    if (this.refTree == null) {
      return 0;
    }
    return this.refTree.rowCount;
  }
  get columnCount() {
    if (this.refTree == null) {
      return 0;
    }
    return this.refTree.columnCount;
  }
  get unitId() {
    if (this.refTree == null) {
      return "";
    }
    return this.refTree.unitId;
  }
  get subUnitId() {
    if (this.refTree == null) {
      return "";
    }
    return this.refTree.subUnitId;
  }
  get formula() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.refTree) == null ? void 0 : _a2.formula) != null ? _b2 : "";
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  get node() {
    var _a2;
    return (_a2 = this.refTree) == null ? void 0 : _a2.node;
  }
  dispose() {
    this.refTree = null;
  }
  get rangeList() {
    const unitRangeList = [];
    if (this.refTree == null) {
      return [];
    }
    for (let i = 0; i < this.refTree.rangeList.length; i++) {
      const range = this.refTree.rangeList[i];
      unitRangeList.push({
        unitId: range.unitId,
        sheetId: range.sheetId,
        range: moveRangeByOffset(range.range, this.refOffsetX, this.refOffsetY)
      });
    }
    return unitRangeList;
  }
  toRTreeItem() {
    const currentRow = this.row;
    const currentColumn = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: currentRow,
        startColumn: currentColumn,
        endRow: currentRow,
        endColumn: currentColumn
      }
    }];
  }
  inRangeData(range) {
    const startRow = range.startRow;
    const startColumn = range.startColumn;
    const endRow = range.endRow;
    const endColumn = range.endColumn;
    const currentRow = this.row;
    const currentColumn = this.column;
    if (currentRow < startRow || currentRow > endRow || currentColumn < startColumn || currentColumn > endColumn) {
      return false;
    }
    return true;
  }
  dependencySheetName(dirtyUnitSheetNameMap) {
    if (this.refTree == null) {
      return false;
    }
    return this.refTree.dependencySheetName(dirtyUnitSheetNameMap);
  }
  isExcludeRange(unitExcludedCell) {
    var _a2;
    const rangeList = this.rangeList;
    if (rangeList.length === 0) {
      return false;
    }
    for (let r = 0, len = rangeList.length; r < len; r++) {
      const unitRange = rangeList[r];
      const { unitId, sheetId, range } = unitRange;
      const excludedCell = (_a2 = unitExcludedCell == null ? void 0 : unitExcludedCell[unitId]) == null ? void 0 : _a2[sheetId];
      let { startRow: rangeStartRow, endRow: rangeEndRow, startColumn: rangeStartColumn, endColumn: rangeEndColumn } = range;
      if (Number.isNaN(rangeStartRow)) {
        rangeStartRow = 0;
      }
      if (Number.isNaN(rangeStartColumn)) {
        rangeStartColumn = 0;
      }
      if (Number.isNaN(rangeEndRow)) {
        rangeEndRow = Number.POSITIVE_INFINITY;
      }
      if (Number.isNaN(rangeEndColumn)) {
        rangeEndColumn = Number.POSITIVE_INFINITY;
      }
      let isInclude = false;
      excludedCell == null ? void 0 : excludedCell.forValue((row, column) => {
        if (row >= rangeStartRow && row <= rangeEndRow && column >= rangeStartColumn && column <= rangeEndColumn) {
          isInclude = true;
          return false;
        }
      });
      if (isInclude) {
        return true;
      }
    }
    return false;
  }
  get formulaId() {
    if (this.refTree == null) {
      return "";
    }
    return this.refTree.formulaId;
  }
};
var FormulaDependencyTree = class extends FormulaDependencyTreeCalculator {
  constructor(treeId) {
    super();
    __publicField(this, "isCache", false);
    __publicField(this, "featureId");
    __publicField(this, "featureDirtyRanges", []);
    __publicField(this, "refOffsetX", 0);
    __publicField(this, "refOffsetY", 0);
    __publicField(this, "type", 0 /* NORMAL_FORMULA */);
    __publicField(this, "formulaId");
    __publicField(this, "subUnitId", "");
    __publicField(this, "unitId", "");
    __publicField(this, "rangeList", []);
    __publicField(this, "formula", "");
    __publicField(this, "row", -1);
    __publicField(this, "column", -1);
    __publicField(this, "rowCount", Number.NEGATIVE_INFINITY);
    __publicField(this, "columnCount", Number.NEGATIVE_INFINITY);
    __publicField(this, "isDirty", false);
    __publicField(this, "node");
    __publicField(this, "addressFunctionNodes", []);
    __publicField(this, "getDirtyData");
    this.treeId = treeId;
  }
  get isVirtual() {
    return false;
  }
  get nodeData() {
    return {
      node: this.node,
      refOffsetX: 0,
      refOffsetY: 0
    };
  }
  toJson() {
    return {
      formula: this.formula,
      refOffsetX: this.refOffsetX,
      refOffsetY: this.refOffsetY
    };
  }
  dispose() {
    this.featureDirtyRanges = [];
    this.rangeList = [];
    this.addressFunctionNodes = [];
    this.getDirtyData = null;
  }
  inRangeData(range) {
    const startRow = range.startRow;
    const startColumn = range.startColumn;
    const endRow = range.endRow;
    const endColumn = range.endColumn;
    const currentRow = this.row;
    const currentColumn = this.column;
    if (currentRow < startRow || currentRow > endRow || currentColumn < startColumn || currentColumn > endColumn) {
      return false;
    }
    return true;
  }
  dependencySheetName(dirtyUnitSheetNameMap) {
    var _a2;
    const rangeList = this.rangeList;
    if (rangeList.length === 0 || dirtyUnitSheetNameMap == null) {
      return false;
    }
    for (let r = 0, len = rangeList.length; r < len; r++) {
      const unitRange = rangeList[r];
      const { unitId, sheetId } = unitRange;
      if (((_a2 = dirtyUnitSheetNameMap[unitId]) == null ? void 0 : _a2[sheetId]) != null) {
        return true;
      }
    }
    return false;
  }
  isExcludeRange(unitExcludedCell) {
    var _a2;
    const rangeList = this.rangeList;
    if (rangeList.length === 0) {
      return false;
    }
    for (let r = 0, len = rangeList.length; r < len; r++) {
      const unitRange = rangeList[r];
      const { unitId, sheetId, range } = unitRange;
      const excludedCell = (_a2 = unitExcludedCell == null ? void 0 : unitExcludedCell[unitId]) == null ? void 0 : _a2[sheetId];
      let { startRow: rangeStartRow, endRow: rangeEndRow, startColumn: rangeStartColumn, endColumn: rangeEndColumn } = range;
      if (Number.isNaN(rangeStartRow)) {
        rangeStartRow = 0;
      }
      if (Number.isNaN(rangeStartColumn)) {
        rangeStartColumn = 0;
      }
      if (Number.isNaN(rangeEndRow)) {
        rangeEndRow = Number.POSITIVE_INFINITY;
      }
      if (Number.isNaN(rangeEndColumn)) {
        rangeEndColumn = Number.POSITIVE_INFINITY;
      }
      let isInclude = false;
      excludedCell == null ? void 0 : excludedCell.forValue((row, column) => {
        if (row >= rangeStartRow && row <= rangeEndRow && column >= rangeStartColumn && column <= rangeEndColumn) {
          isInclude = true;
          return false;
        }
      });
      if (isInclude) {
        return true;
      }
    }
    return false;
  }
  // pushChildren(tree: FormulaDependencyTree) {
  //     this.children.add(tree.treeId);
  //     tree._pushParent(this);
  // }
  /**
   * Add the range corresponding to the current ast node.
   * @param range
   */
  pushRangeList(ranges) {
    this.rangeList.push(...ranges);
  }
  shouldBePushRangeList() {
    return this.rangeList.length === 0 && this.type !== 2 /* FEATURE_FORMULA */;
  }
  // hasChildren(treeId: number) {
  //     return this.children.has(treeId);
  // }
  toRTreeItem() {
    if (this.featureId != null) {
      return this.featureDirtyRanges;
    }
    const currentRow = this.row;
    const currentColumn = this.column;
    return [{
      unitId: this.unitId,
      sheetId: this.subUnitId,
      range: {
        startRow: currentRow,
        startColumn: currentColumn,
        endRow: currentRow,
        endColumn: currentColumn
      }
    }];
  }
  /**
   * Determine whether it is dependent on other trees.
   * @param dependenceTree
   */
  // dependency(dependenceTree: FormulaDependencyTree) {
  //     if (this.rangeList.length === 0) {
  //         return false;
  //     }
  //     for (let r = 0, len = this.rangeList.length; r < len; r++) {
  //         const unitRange = this.rangeList[r];
  //         const unitId = unitRange.unitId;
  //         const sheetId = unitRange.sheetId;
  //         const range = unitRange.range;
  //         if (
  //             dependenceTree.unitId === unitId &&
  //             dependenceTree.subUnitId === sheetId &&
  //             dependenceTree.inRangeData(range)
  //         ) {
  //             return true;
  //         }
  //     }
  //     return false;
  // }
  // private _pushParent(tree: FormulaDependencyTree) {
  //     this.parents.add(tree.treeId);
  // }
};

// ../packages/engine-formula/src/engine/dependency/formula-dependency.ts
function generateRandomDependencyTreeId(dependencyManagerService) {
  const idNum = dependencyManagerService.getLastTreeId() || 0;
  return idNum;
}
var IFormulaDependencyGenerator = createIdentifier("engine-formula.dependency-generator");
var FormulaDependencyGenerator = class extends Disposable {
  constructor(_currentConfigService, _runtimeService, _otherFormulaManagerService, _featureCalculationManagerService, _interpreter, _astTreeBuilder, _lexer, _dependencyManagerService) {
    super();
    this._currentConfigService = _currentConfigService;
    this._runtimeService = _runtimeService;
    this._otherFormulaManagerService = _otherFormulaManagerService;
    this._featureCalculationManagerService = _featureCalculationManagerService;
    this._interpreter = _interpreter;
    this._astTreeBuilder = _astTreeBuilder;
    this._lexer = _lexer;
    this._dependencyManagerService = _dependencyManagerService;
    __publicField(this, "_updateRangeFlattenCache", /* @__PURE__ */ new Map());
    __publicField(this, "_dependencyRTreeCacheForAddressFunction", new RTree());
    __publicField(this, "_executedAddressFunctionNodeIds", /* @__PURE__ */ new Set());
  }
  dispose() {
    this._updateRangeFlattenCache.clear();
    this._dependencyRTreeCacheForAddressFunction.clear();
    FORMULA_AST_CACHE.clear();
  }
  async generate() {
    this._updateRangeFlatten();
    const formulaData = this._currentConfigService.getFormulaData();
    const otherFormulaData = this._otherFormulaManagerService.getOtherFormulaData();
    const clearDependencyTreeCache = this._currentConfigService.getClearDependencyTreeCache();
    if (clearDependencyTreeCache != null) {
      Object.keys(clearDependencyTreeCache).forEach((unitId) => {
        if (unitId == null) {
          return;
        }
        Object.keys(clearDependencyTreeCache[unitId]).forEach((subUnitId) => {
          if (subUnitId == null) {
            return;
          }
          this._dependencyManagerService.clearOtherFormulaDependency(unitId, subUnitId);
          this._dependencyManagerService.clearFeatureFormulaDependency(unitId, subUnitId);
          this._dependencyManagerService.clearFormulaDependency(unitId, subUnitId);
        });
      });
    }
    const unitData = this._currentConfigService.getUnitData();
    const treeList = await this._generateTreeList(formulaData, otherFormulaData, unitData);
    const updateTreeList = this._getUpdateTreeListAndMakeDependency(treeList);
    let finalTreeList = this._calculateRunList(updateTreeList);
    const hasFeatureCalculation = this._dependencyFeatureCalculation(finalTreeList);
    if (hasFeatureCalculation) {
      finalTreeList.forEach((tree) => {
        tree.resetState();
      });
      finalTreeList = this._calculateRunList(finalTreeList);
    }
    const isCycleDependency = this._checkIsCycleDependency(finalTreeList);
    if (isCycleDependency) {
      this._runtimeService.enableCycleDependency();
    }
    this._dependencyRTreeCacheForAddressFunction.clear();
    return Promise.resolve(finalTreeList);
  }
  _dependencyFeatureCalculation(newTreeList) {
    const featureMap = this._featureCalculationManagerService.getReferenceExecutorMap();
    if (featureMap.size === 0) {
      return;
    }
    this._clearFeatureCalculationNode(newTreeList);
    let hasFeatureCalculation = false;
    featureMap.forEach((subUnitMap, _) => {
      subUnitMap.forEach((featureMap2, _2) => {
        featureMap2.forEach((params, featureId) => {
          const { unitId, subUnitId, getDirtyData } = params;
          const allDependency = getDirtyData(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData());
          const dirtyRanges = this._convertDirtyRangesToUnitRange(allDependency.dirtyRanges);
          const intersectTrees = this._intersectFeatureCalculation(dirtyRanges, newTreeList, { unitId, subUnitId, featureId });
          if (intersectTrees.length > 0) {
            let featureTree = this._getExistTreeList({ unitId, subUnitId, featureId }, newTreeList);
            if (featureTree == null) {
              featureTree = this._getFeatureFormulaTree(featureId, generateRandomDependencyTreeId(this._dependencyManagerService), params);
              newTreeList.push(featureTree);
            }
            featureTree.parents = /* @__PURE__ */ new Set();
            intersectTrees.forEach((tree) => {
              if (tree.hasChildren(featureTree.treeId)) {
                return;
              }
              tree.pushChildren(featureTree);
            });
            hasFeatureCalculation = true;
          }
        });
      });
    });
    return hasFeatureCalculation;
  }
  _clearFeatureCalculationNode(newTreeList) {
    const featureMap = this._featureCalculationManagerService.getReferenceExecutorMap();
    newTreeList.forEach((tree) => {
      var _a2, _b2, _c, _d;
      const newChildren = /* @__PURE__ */ new Set();
      for (const childTreeId of tree.children) {
        const child = this._dependencyManagerService.getTreeById(childTreeId);
        if (!child) {
          continue;
        }
        if (!child.featureId) {
          newChildren.add(childTreeId);
        } else if (!((_b2 = (_a2 = featureMap.get(tree.unitId)) == null ? void 0 : _a2.get(tree.subUnitId)) == null ? void 0 : _b2.has(child.featureId))) {
          newChildren.add(childTreeId);
        }
      }
      tree.children = newChildren;
      const newParents = /* @__PURE__ */ new Set();
      for (const parentTreeId of tree.parents) {
        const parent = this._dependencyManagerService.getTreeById(parentTreeId);
        if (!parent) {
          continue;
        }
        if (!parent.featureId) {
          newParents.add(parentTreeId);
        } else if (!((_d = (_c = featureMap.get(tree.unitId)) == null ? void 0 : _c.get(tree.subUnitId)) == null ? void 0 : _d.has(parent.featureId))) {
          newParents.add(parentTreeId);
        }
      }
      tree.parents = newParents;
    });
  }
  /**
   * TODO @DR-Univer: The next step will be to try changing the incoming dirtyRanges to an array, thus avoiding conversion.
   * @param dirtyRanges
   * @returns
   */
  _convertDirtyRangesToUnitRange(dirtyRanges) {
    const unitRange = [];
    for (const unitId in dirtyRanges) {
      const unitMap = dirtyRanges[unitId];
      for (const subUnitId in unitMap) {
        const ranges = unitMap[subUnitId];
        for (const range of ranges) {
          unitRange.push({
            unitId,
            sheetId: subUnitId,
            range
          });
        }
      }
    }
    return unitRange;
  }
  _intersectFeatureCalculation(dirtyRanges, newTreeList, param) {
    const dependencyTree = [];
    const treeIds = this._dependencyManagerService.searchDependency(dirtyRanges);
    for (let i = 0, len = newTreeList.length; i < len; i++) {
      const tree = newTreeList[i];
      if (tree.unitId === param.unitId && tree.subUnitId === param.subUnitId && tree.featureId === param.featureId) {
        continue;
      }
      const isAdded = treeIds.has(tree.treeId);
      if (isAdded) {
        dependencyTree.push(tree);
      }
    }
    return dependencyTree;
  }
  _getExistTreeList(param, treeList) {
    const { unitId, subUnitId, featureId } = param;
    for (let i = 0, len = treeList.length; i < len; i++) {
      const tree = treeList[i];
      if (tree.unitId === unitId && tree.subUnitId === subUnitId && tree.featureId === featureId) {
        return tree;
      }
    }
  }
  _isCyclicUtil(treeId, visited, recursionStack) {
    const node = this._dependencyManagerService.getTreeById(treeId);
    if (node == null) {
      return false;
    }
    if (!visited.has(node.treeId)) {
      visited.add(node.treeId);
      recursionStack.add(node.treeId);
      for (const childTreeId of node.children) {
        if (!visited.has(childTreeId) && this._isCyclicUtil(childTreeId, visited, recursionStack)) {
          return true;
        }
        if (recursionStack.has(childTreeId)) {
          return true;
        }
      }
    }
    recursionStack.delete(node.treeId);
    return false;
  }
  _checkIsCycleDependency(treeList) {
    const visited = /* @__PURE__ */ new Set();
    const recursionStack = /* @__PURE__ */ new Set();
    for (let i = 0, len = treeList.length; i < len; i++) {
      const tree = treeList[i];
      const isCycle = this._isCyclicUtil(tree.treeId, visited, recursionStack);
      if (isCycle === true) {
        return true;
      }
    }
    return false;
  }
  /**
   * Generate nodes for the dependency tree, where each node contains all the reference data ranges included in each formula.
   * @param formulaData
   */
  async _generateTreeList(formulaData, otherFormulaData, unitData) {
    const formulaDataKeys = Object.keys(formulaData);
    const otherFormulaDataKeys = Object.keys(otherFormulaData);
    const treeList = [];
    const forceCalculate = this._currentConfigService.isForceCalculate();
    if (forceCalculate) {
      this._dependencyManagerService.reset();
    }
    this._registerFormulas(formulaDataKeys, formulaData, unitData, treeList);
    this._registerOtherFormulas(otherFormulaData, otherFormulaDataKeys, treeList);
    this._registerFeatureFormulas(treeList);
    for (let i = 0, len = treeList.length; i < len; i++) {
      const tree = treeList[i];
      if (!tree.formula) {
        continue;
      }
      const node = this._getTreeNode(tree);
      tree.isDirty = this._includeTree(tree, node);
      const addressFunctionNodes = this._getAddressFunctionNodeList(node);
      if (addressFunctionNodes.length > 0) {
        tree.addressFunctionNodes = addressFunctionNodes;
      }
      if (tree.isVirtual) {
        continue;
      }
      this._runtimeService.setCurrent(
        tree.row,
        tree.column,
        tree.rowCount,
        tree.columnCount,
        tree.subUnitId,
        tree.unitId
      );
      const rangeList = await this._getRangeListByNode({
        node,
        refOffsetX: tree.refOffsetX,
        refOffsetY: tree.refOffsetY
      });
      tree.pushRangeList(rangeList);
    }
    for (let i = 0, len = treeList.length; i < len; i++) {
      const tree = treeList[i];
      if (tree.isCache) {
        continue;
      }
      this._dependencyManagerService.addDependencyRTreeCache(tree);
    }
    await this._calculateListByFunctionRefNode(treeList);
    return treeList;
  }
  // private _moveRangeList(tree: FormulaDependencyTree, refOffsetX: number, refOffsetY: number) {
  //     const rangeList = tree.rangeList;
  //     const newRangeList = [];
  //     for (let i = 0, len = rangeList.length; i < len; i++) {
  //         const unitRange = rangeList[i];
  //         const newRange = {
  //             unitId: tree.unitId,
  //             sheetId: tree.subUnitId,
  //             range: moveRangeByOffset(unitRange.range, refOffsetX, refOffsetY),
  //         };
  //         newRangeList.push(newRange);
  //     }
  //     return newRangeList;
  // }
  _registerFeatureFormulas(treeList) {
    const featureMap = this._featureCalculationManagerService.getReferenceExecutorMap();
    featureMap.forEach((subUnitMap, _) => {
      subUnitMap.forEach((featureMap2, _2) => {
        featureMap2.forEach((params, featureId) => {
          const treeId = this._dependencyManagerService.getFeatureFormulaDependency(params.unitId, params.subUnitId, featureId);
          treeList.push(this._getFeatureFormulaTree(featureId, treeId, params));
        });
      });
    });
  }
  _getFeatureFormulaTree(featureId, treeId, params) {
    const { unitId, subUnitId, dependencyRanges, getDirtyData } = params;
    const treeIdNum = treeId || generateRandomDependencyTreeId(this._dependencyManagerService);
    const FDtree = new FormulaDependencyTree(treeIdNum);
    FDtree.unitId = unitId;
    FDtree.subUnitId = subUnitId;
    FDtree.rangeList = dependencyRanges;
    FDtree.getDirtyData = getDirtyData;
    const allDependency = getDirtyData(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData());
    const dirtyRanges = this._convertDirtyRangesToUnitRange(allDependency.dirtyRanges);
    FDtree.featureDirtyRanges = dirtyRanges;
    FDtree.featureId = featureId;
    FDtree.type = 2 /* FEATURE_FORMULA */;
    this._dependencyManagerService.addFeatureFormulaDependency(unitId, subUnitId, featureId, FDtree);
    const treeCache = this._dependencyManagerService.getFeatureFormulaDependency(params.unitId, params.subUnitId, featureId);
    if (treeCache) {
      FDtree.isCache = true;
    }
    return FDtree;
  }
  _registerOtherFormulas(otherFormulaData, otherFormulaDataKeys, treeList) {
    for (const unitId of otherFormulaDataKeys) {
      const subComponentData = otherFormulaData[unitId];
      if (subComponentData == null) {
        continue;
      }
      const subComponentKeys = Object.keys(subComponentData);
      for (const subUnitId of subComponentKeys) {
        const subFormulaData = subComponentData[subUnitId];
        if (subFormulaData == null) {
          continue;
        }
        const subFormulaDataKeys = Object.keys(subFormulaData);
        for (const subFormulaDataId of subFormulaDataKeys) {
          const hasOtherFormula = this._dependencyManagerService.hasOtherFormulaDataMainData(subFormulaDataId);
          const formulaDataItem = subFormulaData[subFormulaDataId];
          const { f: formulaString, ranges } = formulaDataItem;
          let isCache = false;
          if (hasOtherFormula) {
            isCache = true;
          }
          const node = generateAstNode(unitId, formulaString, this._lexer, this._astTreeBuilder, this._currentConfigService);
          const { firstRow, firstColumn } = this._getFirstCellOfRange(ranges);
          const treeMatrix = this._dependencyManagerService.getOtherFormulaDependency(unitId, subUnitId, subFormulaDataId);
          const firstTreeId = (treeMatrix == null ? void 0 : treeMatrix.getValue(0, 0)) || generateRandomDependencyTreeId(this._dependencyManagerService);
          const firstFDtree = new FormulaDependencyTree(firstTreeId);
          for (let i = 0; i < ranges.length; i++) {
            const range = ranges[i];
            const { startRow, startColumn, endRow, endColumn } = range;
            for (let r = startRow; r <= endRow; r++) {
              for (let c = startColumn; c <= endColumn; c++) {
                const x = c - firstColumn;
                const y = r - firstRow;
                if (x === 0 && y === 0) {
                  firstFDtree.node = node;
                  firstFDtree.formula = formulaString;
                  firstFDtree.unitId = unitId;
                  firstFDtree.subUnitId = subUnitId;
                  firstFDtree.formulaId = subFormulaDataId;
                  firstFDtree.type = 1 /* OTHER_FORMULA */;
                  firstFDtree.isCache = isCache;
                  treeList.push(firstFDtree);
                  this._dependencyManagerService.addOtherFormulaDependency(unitId, subUnitId, subFormulaDataId, firstFDtree);
                  this._dependencyManagerService.addFormulaDependencyByDefinedName(firstFDtree);
                  continue;
                }
                const virtual = new FormulaDependencyTreeVirtual();
                virtual.treeId = (treeMatrix == null ? void 0 : treeMatrix.getValue(x, y)) || generateRandomDependencyTreeId(this._dependencyManagerService);
                virtual.refTree = firstFDtree;
                virtual.refOffsetX = x;
                virtual.refOffsetY = y;
                virtual.isCache = isCache;
                this._dependencyManagerService.addOtherFormulaDependency(unitId, subUnitId, subFormulaDataId, virtual);
                this._dependencyManagerService.addFormulaDependencyByDefinedName(virtual);
                treeList.push(virtual);
              }
            }
          }
          this._dependencyManagerService.addOtherFormulaDependencyMainData(subFormulaDataId);
        }
      }
    }
  }
  _getFirstCellOfRange(ranges) {
    const range = ranges[0];
    return {
      firstRow: range.startRow,
      firstColumn: range.startColumn
    };
  }
  _registerFormulas(formulaDataKeys, formulaData, unitData, treeList) {
    for (const unitId of formulaDataKeys) {
      const sheetData = formulaData[unitId];
      if (sheetData == null) {
        continue;
      }
      const sheetDataKeys = Object.keys(sheetData);
      for (const sheetId of sheetDataKeys) {
        const matrixData = new ObjectMatrix(sheetData[sheetId] || {});
        const sIdCache = /* @__PURE__ */ new Map();
        matrixData.forValue((row, column, formulaDataItem) => {
          if (formulaDataItem == null) {
            return true;
          }
          const { x = 0, y = 0, si } = formulaDataItem;
          if (!(x === 0 && y === 0 && si != null)) {
            return true;
          }
          const FDtree = this._createFDtree(unitId, sheetId, row, column, unitData, formulaDataItem);
          const treeId = this._dependencyManagerService.getFormulaDependency(unitId, sheetId, row, column);
          if (treeId != null) {
            FDtree.treeId = treeId;
          } else {
            this._dependencyManagerService.addFormulaDependency(unitId, sheetId, row, column, FDtree);
            this._dependencyManagerService.addFormulaDependencyByDefinedName(FDtree);
          }
          sIdCache.set(si, FDtree);
          treeList.push(FDtree);
        });
        matrixData.forValue((row, column, formulaDataItem) => {
          if (formulaDataItem == null) {
            return true;
          }
          const { x = 0, y = 0, si } = formulaDataItem;
          if (x === 0 && y === 0 && si != null) {
            return true;
          }
          let FDtree;
          if (si && sIdCache.has(si)) {
            const cache = sIdCache.get(si);
            FDtree = this._createVirtualFDtree(cache, formulaDataItem);
          } else {
            FDtree = this._createFDtree(unitId, sheetId, row, column, unitData, formulaDataItem);
          }
          const treeId = this._dependencyManagerService.getFormulaDependency(unitId, sheetId, row, column);
          if (treeId != null) {
            FDtree.treeId = treeId;
          } else {
            this._dependencyManagerService.addFormulaDependency(unitId, sheetId, row, column, FDtree);
            this._dependencyManagerService.addFormulaDependencyByDefinedName(FDtree);
          }
          treeList.push(FDtree);
        });
        sIdCache.clear();
      }
    }
  }
  _createFDtree(unitId, sheetId, row, column, unitData, formulaDataItem) {
    const { f: formulaString, x = 0, y = 0 } = formulaDataItem;
    const FDtree = new FormulaDependencyTree(generateRandomDependencyTreeId(this._dependencyManagerService));
    const sheetItem = unitData[unitId][sheetId];
    const node = generateAstNode(unitId, formulaString, this._lexer, this._astTreeBuilder, this._currentConfigService);
    FDtree.node = node;
    FDtree.formula = formulaString;
    FDtree.unitId = unitId;
    FDtree.subUnitId = sheetId;
    FDtree.row = row;
    FDtree.column = column;
    FDtree.rowCount = sheetItem.rowCount;
    FDtree.columnCount = sheetItem.columnCount;
    return FDtree;
  }
  _createVirtualFDtree(tree, formulaDataItem) {
    const { x = 0, y = 0 } = formulaDataItem;
    const virtual = new FormulaDependencyTreeVirtual();
    virtual.treeId = generateRandomDependencyTreeId(this._dependencyManagerService);
    virtual.refTree = tree;
    virtual.refOffsetX = x;
    virtual.refOffsetY = y;
    return virtual;
  }
  /**
   * Break down the dirty areas into ranges for subsequent matching.
   */
  _updateRangeFlatten() {
    const forceCalculate = this._currentConfigService.isForceCalculate();
    const dirtyRanges = this._currentConfigService.getDirtyRanges();
    if (forceCalculate) {
      return;
    }
    this._updateRangeFlattenCache.clear();
    for (let i = 0; i < dirtyRanges.length; i++) {
      const gridRange = dirtyRanges[i];
      const range = gridRange.range;
      const sheetId = gridRange.sheetId;
      const unitId = gridRange.unitId;
      this._addFlattenCache(unitId, sheetId, range);
    }
  }
  _addFlattenCache(unitId, sheetId, range) {
    let unitMatrix = this._updateRangeFlattenCache.get(unitId);
    if (unitMatrix == null) {
      unitMatrix = /* @__PURE__ */ new Map();
      this._updateRangeFlattenCache.set(unitId, unitMatrix);
    }
    let ranges = unitMatrix.get(sheetId);
    if (ranges == null) {
      ranges = [];
      unitMatrix.set(sheetId, ranges);
    }
    ranges.push(range);
  }
  _isPreCalculateNode(node) {
    if (node.nodeType === 10 /* UNION */) {
      return true;
    }
    if (node.nodeType === 11 /* PREFIX */ && node.getToken() === "@" /* AT */) {
      return true;
    }
    if (node.nodeType === 12 /* SUFFIX */ && node.getToken() === "#" /* POUND */) {
      return true;
    }
    return false;
  }
  _nodeTraversalRef(node, result) {
    const children = node.getChildren();
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      if (this._isPreCalculateNode(item)) {
        result.push(item);
        if (item.nodeType === 10 /* UNION */) {
          for (const unionChildItem of item.getChildren()) {
            if (unionChildItem.nodeType === 4 /* FUNCTION */ && unionChildItem.isAddress()) {
              this._nodeTraversalRef(unionChildItem, result);
            }
          }
        }
        continue;
      } else if (item.nodeType === 1 /* REFERENCE */) {
        result.push(item);
      }
      this._nodeTraversalRef(item, result);
    }
  }
  _nodeTraversalReferenceFunction(node, result) {
    const children = node.getChildren();
    const childrenCount = children.length;
    for (let i = 0; i < childrenCount; i++) {
      const item = children[i];
      if (item.nodeType === 4 /* FUNCTION */ && item.isAddress()) {
        result.push(item);
        continue;
      }
      this._nodeTraversalReferenceFunction(item, result);
    }
  }
  async _executeNode(node, refOffsetX = 0, refOffsetY = 0) {
    let value;
    const nodeData = {
      node,
      refOffsetX,
      refOffsetY
    };
    if (this._interpreter.checkAsyncNode(node)) {
      value = await this._interpreter.executeAsync(nodeData);
    } else {
      value = this._interpreter.execute(nodeData);
    }
    return value;
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  async _getRangeListByNode(nodeData) {
    const preCalculateNodeList = [];
    const refOffsetX = nodeData.refOffsetX;
    const refOffsetY = nodeData.refOffsetY;
    const node = nodeData.node;
    if (node == null) {
      return [];
    }
    this._nodeTraversalRef(node, preCalculateNodeList);
    const rangeList = [];
    for (let i = 0, len = preCalculateNodeList.length; i < len; i++) {
      const node2 = preCalculateNodeList[i];
      const value = await this._executeNode(node2, refOffsetX, refOffsetY);
      const gridRange = value.toUnitRange();
      rangeList.push(gridRange);
      node2.setValue(null);
    }
    return rangeList;
  }
  _getAddressFunctionNodeList(node) {
    const referenceFunctionList = [];
    if (node == null) {
      return [];
    }
    this._nodeTraversalReferenceFunction(node, referenceFunctionList);
    return referenceFunctionList;
  }
  _getTreeNode(tree) {
    return tree.node;
  }
  async _buildDirtyRangesByAddressFunction(treeDependencyCache, tree) {
    const addressFunctionNodes = tree.addressFunctionNodes;
    if (addressFunctionNodes.length === 0) {
      return;
    }
    const refOffsetX = tree.refOffsetX;
    const refOffsetY = tree.refOffsetY;
    const addressFunctionRangeList = await this._getRangeListByFunctionRefNode(addressFunctionNodes, refOffsetX, refOffsetY);
    tree.addressFunctionNodes = [];
    this._addDependencyTreeByAddressFunction(tree, addressFunctionRangeList);
    const newSearchResults = treeDependencyCache.bulkSearch(addressFunctionRangeList);
    const preCalculateTreeList = this._buildTreeNodeById(newSearchResults);
    if (preCalculateTreeList.length === 0) {
      return;
    }
    await this._calculateAddressFunctionRuntimeData(treeDependencyCache, preCalculateTreeList);
  }
  async _calculateListByFunctionRefNode(treeList) {
    const treeDependencyCache = new RTree();
    for (let i = 0, len = treeList.length; i < len; i++) {
      const tree = treeList[i];
      treeDependencyCache.insert({
        unitId: tree.unitId,
        sheetId: tree.subUnitId,
        range: {
          startRow: tree.row,
          startColumn: tree.column,
          endRow: tree.row,
          endColumn: tree.column
        },
        id: tree.treeId
      });
    }
    this._executedAddressFunctionNodeIds.clear();
    for (let i = 0, len = treeList.length; i < len; i++) {
      const tree = treeList[i];
      await this._calculateAddressFunction(treeDependencyCache, tree);
    }
  }
  async _calculateAddressFunction(treeDependencyCache, tree) {
    const addressFunctionNodes = tree.addressFunctionNodes;
    if (addressFunctionNodes.length === 0) {
      return;
    }
    const refOffsetX = tree.refOffsetX;
    const refOffsetY = tree.refOffsetY;
    this._runtimeService.setCurrent(
      tree.row,
      tree.column,
      tree.rowCount,
      tree.columnCount,
      tree.subUnitId,
      tree.unitId
    );
    const dirtyRanges = [];
    for (let j = 0, len = addressFunctionNodes.length; j < len; j++) {
      const rangeList = await this._getRangeListByNode({
        node: addressFunctionNodes[j],
        refOffsetX,
        refOffsetY
      });
      dirtyRanges.push(...rangeList);
    }
    const newSearchResults = /* @__PURE__ */ new Set();
    this._searchDependencyByAddressFunction(treeDependencyCache, dirtyRanges, newSearchResults);
    const preCalculateTreeList = this._buildTreeNodeById(newSearchResults);
    if (preCalculateTreeList.length === 0) {
      await this._buildDirtyRangesByAddressFunction(treeDependencyCache, tree);
      return;
    }
    await this._calculateAddressFunctionRuntimeData(treeDependencyCache, preCalculateTreeList);
    await this._buildDirtyRangesByAddressFunction(treeDependencyCache, tree);
  }
  async _calculateAddressFunctionRuntimeData(treeDependencyCache, preCalculateTreeList) {
    while (preCalculateTreeList.length > 0) {
      const tree = preCalculateTreeList.pop();
      const node = this._getTreeNode(tree);
      const nodeData = {
        node,
        refOffsetX: tree.refOffsetX,
        refOffsetY: tree.refOffsetY
      };
      await this._calculateAddressFunction(treeDependencyCache, tree);
      this._runtimeService.setCurrent(
        tree.row,
        tree.column,
        tree.rowCount,
        tree.columnCount,
        tree.subUnitId,
        tree.unitId
      );
      let value;
      if (this._interpreter.checkAsyncNode(nodeData.node)) {
        value = await this._interpreter.executeAsync(nodeData);
      } else {
        value = this._interpreter.execute(nodeData);
      }
      if (tree.formulaId != null) {
        this._runtimeService.setRuntimeOtherData(tree.formulaId, tree.refOffsetX, tree.refOffsetY, value);
      } else {
        this._runtimeService.setRuntimeData(value);
      }
    }
  }
  _buildTreeNodeById(treeIds) {
    const preCalculateTreeList = [];
    for (const treeId of treeIds) {
      const tree = this._getTreeById(treeId);
      if (!tree || this._executedAddressFunctionNodeIds.has(treeId)) {
        continue;
      }
      this._executedAddressFunctionNodeIds.add(treeId);
      preCalculateTreeList.push(tree);
    }
    return preCalculateTreeList;
  }
  _searchDependencyByAddressFunction(treeDependencyCache, dirtyRanges, searchResults) {
    const newSearchResults = treeDependencyCache.bulkSearch(dirtyRanges);
    const addressFunctionNodes = this._dependencyRTreeCacheForAddressFunction.bulkSearch(dirtyRanges);
    for (const treeId of addressFunctionNodes) {
      if (!searchResults.has(treeId)) {
        searchResults.add(treeId);
      }
    }
    const newDirtyRanges = [];
    for (const treeId of newSearchResults) {
      const tree = this._getTreeById(treeId);
      if (tree && !searchResults.has(treeId)) {
        newDirtyRanges.push(...tree.rangeList);
        searchResults.add(treeId);
      }
    }
    if (newDirtyRanges.length > 0) {
      this._searchDependencyByAddressFunction(treeDependencyCache, newDirtyRanges, searchResults);
    }
    return searchResults;
  }
  _getTreeById(treeId) {
    return this._dependencyManagerService.getTreeById(treeId);
  }
  _addDependencyTreeByAddressFunction(tree, addressFunctionRangeList) {
    const searchRanges = [];
    for (let i = 0; i < addressFunctionRangeList.length; i++) {
      const unitRangeWithNum = addressFunctionRangeList[i];
      const { unitId, sheetId, range } = unitRangeWithNum;
      searchRanges.push({
        unitId,
        sheetId,
        range,
        id: tree.treeId
      });
    }
    this._dependencyRTreeCacheForAddressFunction.bulkInsert(searchRanges);
  }
  /**
   * Calculate the range required for collection in advance,
   * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
   * @param node
   */
  async _getRangeListByFunctionRefNode(referenceFunctionList, refOffsetX, refOffsetY) {
    const rangeList = [];
    for (let i = 0, len = referenceFunctionList.length; i < len; i++) {
      const node = referenceFunctionList[i];
      const value = await this._executeNode(node, refOffsetX, refOffsetY);
      const gridRange = value.toUnitRange();
      rangeList.push(gridRange);
      node.setValue(null);
    }
    return rangeList;
  }
  /**
   * Build a formula dependency tree based on the dependency relationships.
   * @param treeList
   */
  _getUpdateTreeListAndMakeDependency(treeList) {
    const newTreeList = [];
    const existTree = /* @__PURE__ */ new Set();
    const forceCalculate = this._currentConfigService.isForceCalculate();
    const dirtyRanges = this._currentConfigService.getDirtyRanges();
    const treeIds = this._dependencyManagerService.searchDependency(dirtyRanges);
    const addressSearchResults = this._dependencyRTreeCacheForAddressFunction.bulkSearch(dirtyRanges);
    for (const addressSearchResult of addressSearchResults) {
      treeIds.add(addressSearchResult);
    }
    const allTree = this._dependencyManagerService.buildDependencyTree(treeList);
    for (const tree of allTree) {
      const treeId = tree.treeId;
      if ((forceCalculate || tree.isDirty || tree.dependencySheetName(this._currentConfigService.getDirtyNameMap()) || //O(n) n=tree.rangeList.length
      treeIds.has(treeId) && !tree.isExcludeRange(this._currentConfigService.getExcludedRange())) && !existTree.has(treeId)) {
        newTreeList.push(tree);
        existTree.add(treeId);
      }
    }
    return newTreeList;
  }
  _includeTreeFeature(tree) {
    var _a2, _b2;
    const unitId = tree.unitId;
    const subUnitId = tree.subUnitId;
    const featureId = tree.featureId;
    if (featureId != null) {
      const featureMap = this._currentConfigService.getDirtyUnitFeatureMap();
      const state = (_b2 = (_a2 = featureMap == null ? void 0 : featureMap[unitId]) == null ? void 0 : _a2[subUnitId]) == null ? void 0 : _b2[featureId];
      if (state != null) {
        return true;
      }
    }
    return false;
  }
  _includeOtherFormula(tree) {
    var _a2, _b2;
    const unitId = tree.unitId;
    const subUnitId = tree.subUnitId;
    const formulaId = tree.formulaId;
    if (formulaId != null) {
      const otherFormulaMap = this._currentConfigService.getDirtyUnitOtherFormulaMap();
      const state = (_b2 = (_a2 = otherFormulaMap == null ? void 0 : otherFormulaMap[unitId]) == null ? void 0 : _a2[subUnitId]) == null ? void 0 : _b2[formulaId];
      if (state != null) {
        return true;
      }
    }
    return false;
  }
  _detectForcedRecalculationNode(tree, node) {
    if (node == null) {
      return false;
    }
    return this._detectForcedRecalculationNodeRecursion(node);
  }
  _detectForcedRecalculationNodeRecursion(node) {
    if (node.isForcedCalculateFunction()) {
      return true;
    }
    const children = node.getChildren();
    for (let i = 0, len = children.length; i < len; i++) {
      const child = children[i];
      if (this._detectForcedRecalculationNodeRecursion(child)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Determine whether all ranges of the current node exist within the dirty area.
   * If they are within the dirty area, return true, indicating that this node needs to be calculated.
   * @param tree
   */
  _includeTree(tree, node) {
    var _a2, _b2, _c;
    const unitId = tree.unitId;
    const subUnitId = tree.subUnitId;
    if (this._detectForcedRecalculationNode(tree, node) === true) {
      return true;
    }
    if (this._includeTreeFeature(tree) === true) {
      return true;
    }
    if (this._includeOtherFormula(tree) === true) {
      return true;
    }
    if (includeDefinedName(tree, node, this._currentConfigService) === true) {
      return true;
    }
    const excludedCell = (_b2 = (_a2 = this._currentConfigService.getExcludedRange()) == null ? void 0 : _a2[unitId]) == null ? void 0 : _b2[subUnitId];
    const isExclude = (excludedCell == null ? void 0 : excludedCell.getValue(tree.row, tree.column)) != null;
    if (isExclude) {
      return false;
    }
    if (((_c = this._currentConfigService.getDirtyNameMap()[unitId]) == null ? void 0 : _c[subUnitId]) != null) {
      return true;
    }
    if (!this._updateRangeFlattenCache.has(unitId)) {
      return false;
    }
    const sheetRangeMap = this._updateRangeFlattenCache.get(unitId);
    if (!sheetRangeMap.has(subUnitId)) {
      return false;
    }
    const ranges = sheetRangeMap.get(subUnitId);
    for (const range of ranges) {
      if (tree.inRangeData(range)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Generate the final formula calculation order array by traversing the dependency tree established via depth-first search.
   * @param treeList
   */
  _calculateRunList(treeList) {
    const stack = treeList;
    const formulaRunList = [];
    const cacheStack = [];
    while (stack.length > 0) {
      const tree = stack.pop();
      if (tree === void 0 || tree.isSkip()) {
        continue;
      }
      if (tree.isAdded()) {
        formulaRunList.push(tree);
        tree.setSkip();
        continue;
      }
      cacheStack.length = 0;
      for (const parentTreeId of tree.parents) {
        const parentTree = this._dependencyManagerService.getTreeById(parentTreeId);
        if (!parentTree) {
          throw new Error("ParentDependencyTree object is null");
        }
        if (parentTree.isAdded() || tree.isSkip()) {
          continue;
        }
        cacheStack.push(parentTree);
      }
      const addressSearchResults = this._dependencyRTreeCacheForAddressFunction.bulkSearch(tree.toRTreeItem());
      for (const parentTreeId of addressSearchResults) {
        const parentTree = this._dependencyManagerService.getTreeById(parentTreeId);
        if (!parentTree) {
          throw new Error("ParentDependencyTree object is null");
        }
        if (parentTree.isAdded() || tree.isSkip()) {
          continue;
        }
        cacheStack.push(parentTree);
      }
      if (cacheStack.length === 0) {
        formulaRunList.push(tree);
        tree.setSkip();
      } else {
        tree.setAdded();
        stack.push(tree, ...cacheStack);
      }
    }
    return formulaRunList;
  }
};
FormulaDependencyGenerator = __decorateClass([
  __decorateParam(0, IFormulaCurrentConfigService),
  __decorateParam(1, IFormulaRuntimeService),
  __decorateParam(2, IOtherFormulaManagerService),
  __decorateParam(3, IFeatureCalculationManagerService),
  __decorateParam(4, Inject(Interpreter)),
  __decorateParam(5, Inject(AstTreeBuilder)),
  __decorateParam(6, Inject(Lexer)),
  __decorateParam(7, IDependencyManagerService)
], FormulaDependencyGenerator);

// ../packages/engine-formula/src/services/calculate-formula.service.ts
var DEFAULT_INTERVAL_COUNT = 500;
var ICalculateFormulaService = createIdentifier("engine-formula.calculate-formula.service");
var CalculateFormulaService = class extends Disposable {
  constructor(_configService, _lexer, _currentConfigService, _runtimeService, _formulaDependencyGenerator, _interpreter, _astTreeBuilder) {
    super();
    this._configService = _configService;
    this._lexer = _lexer;
    this._currentConfigService = _currentConfigService;
    this._runtimeService = _runtimeService;
    this._formulaDependencyGenerator = _formulaDependencyGenerator;
    this._interpreter = _interpreter;
    this._astTreeBuilder = _astTreeBuilder;
    __publicField(this, "_executionInProgressListener$", new import_rxjs23.Subject());
    __publicField(this, "executionInProgressListener$", this._executionInProgressListener$.asObservable());
    __publicField(this, "_executionCompleteListener$", new import_rxjs23.Subject());
    __publicField(this, "executionCompleteListener$", this._executionCompleteListener$.asObservable());
  }
  dispose() {
    super.dispose();
    this._executionInProgressListener$.complete();
    this._executionCompleteListener$.complete();
    FORMULA_REF_TO_ARRAY_CACHE.clear();
    CELL_INVERTED_INDEX_CACHE.clear();
    ErrorValueObjectCache.clear();
    StringValueObjectCache.clear();
  }
  /**
   * Stop the execution of the formula.
   */
  stopFormulaExecution() {
    this._runtimeService.stopExecution();
  }
  /**
   * When the feature is loading,
   * the pre-calculated content needs to be input to the formula engine in advance,
   * so that the formula can read the correct values.
   * @param featureId
   * @param featureData
   */
  setRuntimeFeatureCellData(featureId, featureData) {
    this._runtimeService.setRuntimeFeatureCellData(featureId, featureData);
  }
  setRuntimeFeatureRange(featureId, featureRange) {
    this._runtimeService.setRuntimeFeatureRange(featureId, featureRange);
  }
  async execute(formulaDatasetConfig) {
    this._runtimeService.setFormulaExecuteStage(1 /* START */);
    this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    this._currentConfigService.load(formulaDatasetConfig);
    this._runtimeService.reset();
    const cycleReferenceCount = formulaDatasetConfig.maxIteration || DEFAULT_CYCLE_REFERENCE_COUNT;
    for (let i = 0; i < cycleReferenceCount; i++) {
      this._runtimeService.setFormulaCycleIndex(i);
      await this._execute();
      FORMULA_REF_TO_ARRAY_CACHE.clear();
      const isCycleDependency = this._runtimeService.isCycleDependency();
      if (!isCycleDependency) {
        break;
      }
    }
    this._runtimeService.setFormulaExecuteStage(8 /* CALCULATION_COMPLETED */);
    this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData());
    CELL_INVERTED_INDEX_CACHE.clear();
    this._runtimeService.reset();
  }
  async _execute() {
    const executeState = await this._apply();
    if (executeState == null) {
      return;
    }
    const { arrayFormulaRange, runtimeFeatureRange } = executeState;
    const { dirtyRanges, excludedCell } = this._getArrayFormulaDirtyRangeAndExcludedRange(
      arrayFormulaRange,
      runtimeFeatureRange
    );
    if (dirtyRanges == null || dirtyRanges.length === 0) {
      return true;
    }
    this._currentConfigService.loadDirtyRangesAndExcludedCell(dirtyRanges, excludedCell);
    await this._apply(true);
    return true;
  }
  _getArrayFormulaDirtyRangeAndExcludedRange(arrayFormulaRange, runtimeFeatureRange) {
    const dirtyRanges = [];
    const excludedCell = {};
    Object.keys(arrayFormulaRange).forEach((unitId) => {
      const sheetArrayFormulaRange = arrayFormulaRange[unitId];
      if (sheetArrayFormulaRange == null) {
        return true;
      }
      Object.keys(sheetArrayFormulaRange).forEach((sheetId) => {
        const cellValue = new ObjectMatrix(sheetArrayFormulaRange[sheetId]);
        if (cellValue == null) {
          return true;
        }
        const newCellData = new ObjectMatrix();
        cellValue.forValue((row, column, range) => {
          newCellData.setValue(row, column, true);
          dirtyRanges.push({ unitId, sheetId, range });
        });
        if (excludedCell[unitId] == null) {
          excludedCell[unitId] = {};
        }
        excludedCell[unitId][sheetId] = newCellData;
      });
    });
    Object.keys(runtimeFeatureRange).forEach((featureId) => {
      const arrayRange = runtimeFeatureRange[featureId];
      Object.keys(arrayRange).forEach((unitId) => {
        const sheetArrayFormulaRange = arrayRange[unitId];
        if (sheetArrayFormulaRange == null) {
          return true;
        }
        Object.keys(sheetArrayFormulaRange).forEach((sheetId) => {
          const ranges = sheetArrayFormulaRange[sheetId];
          if (ranges == null) {
            return true;
          }
          for (const range of ranges) {
            dirtyRanges.push({ unitId, sheetId, range });
          }
        });
      });
    });
    return { dirtyRanges, excludedCell };
  }
  // eslint-disable-next-line max-lines-per-function
  async _apply(isArrayFormulaState = false) {
    if (isArrayFormulaState) {
      this._runtimeService.setFormulaExecuteStage(5 /* START_DEPENDENCY_ARRAY_FORMULA */);
    } else {
      this._runtimeService.setFormulaExecuteStage(2 /* START_DEPENDENCY */);
    }
    this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    const treeList = (await this._formulaDependencyGenerator.generate()).reverse();
    const interpreter = this._interpreter;
    if (isArrayFormulaState) {
      this._runtimeService.setFormulaExecuteStage(6 /* START_CALCULATION_ARRAY_FORMULA */);
      this._runtimeService.setTotalArrayFormulasToCalculate(treeList.length);
    } else {
      this._runtimeService.setFormulaExecuteStage(3 /* START_CALCULATION */);
      this._runtimeService.setTotalFormulasToCalculate(treeList.length);
    }
    this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
    let pendingTasks = [];
    const config2 = this._configService.getConfig(ENGINE_FORMULA_PLUGIN_CONFIG_KEY);
    const intervalCount = (config2 == null ? void 0 : config2.intervalCount) || DEFAULT_INTERVAL_COUNT;
    const treeCount = treeList.length;
    for (let i = 0; i < treeCount; i++) {
      const tree = treeList[i];
      const nodeData = tree.nodeData;
      const getDirtyData = tree.getDirtyData;
      if (i % intervalCount === 0) {
        await new Promise((resolve) => {
          const calCancelTask = requestImmediateMacroTask(resolve);
          pendingTasks.push(calCancelTask);
        });
        if (isArrayFormulaState) {
          this._runtimeService.setFormulaExecuteStage(
            7 /* CURRENTLY_CALCULATING_ARRAY_FORMULA */
          );
          this._runtimeService.setCompletedArrayFormulasCount(i + 1);
        } else {
          this._runtimeService.setFormulaExecuteStage(4 /* CURRENTLY_CALCULATING */);
          this._runtimeService.setCompletedFormulasCount(i + 1);
        }
        this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
        if (this._runtimeService.isStopExecution() || nodeData == null && getDirtyData == null) {
          this._runtimeService.setFormulaExecuteStage(0 /* IDLE */);
          this._runtimeService.markedAsStopFunctionsExecuted();
          this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData());
          return;
        }
      }
      this._runtimeService.setCurrent(
        tree.row,
        tree.column,
        tree.rowCount,
        tree.columnCount,
        tree.subUnitId,
        tree.unitId
      );
      let value;
      if (getDirtyData != null && tree.featureId != null) {
        const { runtimeCellData, dirtyRanges } = getDirtyData(this._currentConfigService.getDirtyData(), this._runtimeService.getAllRuntimeData());
        this._runtimeService.setRuntimeFeatureCellData(tree.featureId, runtimeCellData);
        this._runtimeService.setRuntimeFeatureRange(tree.featureId, dirtyRanges);
      } else if (nodeData != null) {
        if (interpreter.checkAsyncNode(nodeData.node)) {
          value = await interpreter.executeAsync(nodeData);
        } else {
          value = interpreter.execute(nodeData);
        }
        if (tree.formulaId != null) {
          this._runtimeService.setRuntimeOtherData(tree.formulaId, tree.refOffsetX, tree.refOffsetY, value);
        } else {
          this._runtimeService.setRuntimeData(value);
        }
      }
    }
    pendingTasks.forEach((cancel) => cancel());
    pendingTasks = [];
    if (treeCount > 0) {
      this._runtimeService.markedAsSuccessfullyExecuted();
    } else if (!isArrayFormulaState) {
      this._runtimeService.markedAsNoFunctionsExecuted();
    }
    return this._runtimeService.getAllRuntimeData();
  }
  calculate(formulaString, transformSuffix = true) {
    const lexerNode = this._lexer.treeBuilder(formulaString, transformSuffix);
    if (Object.values(ErrorType).includes(lexerNode)) {
      return ErrorNode.create(lexerNode);
    }
    const astNode = this._astTreeBuilder.parse(lexerNode);
    astNode == null ? void 0 : astNode.serialize();
  }
};
CalculateFormulaService = __decorateClass([
  __decorateParam(0, IConfigService),
  __decorateParam(1, Inject(Lexer)),
  __decorateParam(2, IFormulaCurrentConfigService),
  __decorateParam(3, IFormulaRuntimeService),
  __decorateParam(4, IFormulaDependencyGenerator),
  __decorateParam(5, Inject(Interpreter)),
  __decorateParam(6, Inject(AstTreeBuilder))
], CalculateFormulaService);

// ../packages/engine-formula/src/controller/calculate.controller.ts
var CalculateController = class extends Disposable {
  constructor(_commandService, _calculateFormulaService, _formulaDataModel) {
    super();
    this._commandService = _commandService;
    this._calculateFormulaService = _calculateFormulaService;
    this._formulaDataModel = _formulaDataModel;
    this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
    this._initialExecuteFormulaListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === SetFormulaCalculationStopMutation.id) {
          this._calculateFormulaService.stopFormulaExecution();
        } else if (command.id === SetFormulaCalculationStartMutation.id) {
          const params = command.params;
          this._calculate(params);
        } else if (command.id === SetArrayFormulaDataMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { arrayFormulaRange, arrayFormulaCellData } = params;
          this._formulaDataModel.setArrayFormulaRange(arrayFormulaRange);
          this._formulaDataModel.setArrayFormulaCellData(arrayFormulaCellData);
        }
      })
    );
  }
  async _calculate(formulaDirtyData) {
    const { forceCalculation: forceCalculate = false, dirtyRanges = [], dirtyNameMap = {}, dirtyDefinedNameMap = {}, dirtyUnitFeatureMap = {}, dirtyUnitOtherFormulaMap = {}, clearDependencyTreeCache = {}, maxIteration = DEFAULT_CYCLE_REFERENCE_COUNT, rowData } = formulaDirtyData;
    const formulaData = this._formulaDataModel.getFormulaData();
    const arrayFormulaCellData = this._formulaDataModel.getArrayFormulaCellData();
    const arrayFormulaRange = this._formulaDataModel.getArrayFormulaRange();
    this._calculateFormulaService.execute({
      formulaData,
      arrayFormulaCellData,
      arrayFormulaRange,
      forceCalculate,
      dirtyRanges,
      dirtyNameMap,
      dirtyDefinedNameMap,
      dirtyUnitFeatureMap,
      dirtyUnitOtherFormulaMap,
      clearDependencyTreeCache,
      maxIteration,
      rowData
    });
  }
  // Notification
  _initialExecuteFormulaListener() {
    this._calculateFormulaService.executionCompleteListener$.subscribe((data) => {
      const functionsExecutedState = data.functionsExecutedState;
      switch (functionsExecutedState) {
        case 2 /* NOT_EXECUTED */:
          break;
        case 1 /* STOP_EXECUTION */:
          break;
        case 3 /* SUCCESS */:
          this._applyResult(data);
          break;
        case 0 /* INITIAL */:
          break;
      }
      this._commandService.executeCommand(
        SetFormulaCalculationNotificationMutation.id,
        {
          functionsExecutedState
        },
        {
          onlyLocal: true
        }
      );
    });
    this._calculateFormulaService.executionInProgressListener$.subscribe((data) => {
      this._commandService.executeCommand(
        SetFormulaCalculationNotificationMutation.id,
        {
          stageInfo: data
        },
        {
          onlyLocal: true
        }
      );
    });
  }
  async _applyResult(data) {
    const { unitData, unitOtherData, arrayFormulaRange, arrayFormulaCellData, clearArrayFormulaCellData } = data;
    if (!unitData) {
      console.error("No sheetData from Formula Engine!");
      return;
    }
    if (arrayFormulaRange) {
      this._formulaDataModel.clearPreviousArrayFormulaCellData(clearArrayFormulaCellData);
      this._formulaDataModel.mergeArrayFormulaCellData(arrayFormulaCellData);
      this._formulaDataModel.mergeArrayFormulaRange(arrayFormulaRange);
      this._commandService.executeCommand(
        SetArrayFormulaDataMutation.id,
        {
          arrayFormulaRange: this._formulaDataModel.getArrayFormulaRange(),
          arrayFormulaCellData: this._formulaDataModel.getArrayFormulaCellData()
        },
        {
          onlyLocal: true
        }
      );
    }
    this._commandService.executeCommand(
      SetFormulaCalculationResultMutation.id,
      {
        unitData: convertRuntimeToUnitData(unitData),
        unitOtherData
      },
      {
        onlyLocal: true
      }
    );
  }
};
CalculateController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, ICalculateFormulaService),
  __decorateParam(2, Inject(FormulaDataModel))
], CalculateController);

// ../packages/engine-formula/src/engine/utils/r1c1-reference.ts
var $relativeRegex = /[\[\]]/g;
function handleR1C1(rowOrColumnString, current) {
  if ($relativeRegex.test(rowOrColumnString)) {
    const index = Number(rowOrColumnString.replace($relativeRegex, ""));
    return current + index;
  }
  return Number(rowOrColumnString) - 1;
}
function singleReference(refBody, currentRow = 0, currentColumn = 0) {
  refBody = refBody.toLocaleUpperCase();
  const refBodyArray = refBody.split(/[RC]/);
  const rowString = refBodyArray[1];
  const columnString = refBodyArray[2];
  const row = handleR1C1(rowString, currentRow);
  const column = handleR1C1(columnString, currentColumn);
  return {
    row,
    column,
    absoluteRefType: 0 /* NONE */
  };
}
function deserializeRangeForR1C1(refString, currentRow = 0, currentColumn = 0) {
  const { refBody, sheetName, unitId } = handleRefStringInfo(refString);
  const colonIndex = refBody.indexOf(":");
  if (colonIndex === -1) {
    const grid = singleReference(refBody, currentRow, currentColumn);
    const row = grid.row;
    const column = grid.column;
    const absoluteRefType = grid.absoluteRefType;
    const range = {
      startRow: row,
      startColumn: column,
      endRow: row,
      endColumn: column,
      startAbsoluteRefType: absoluteRefType,
      endAbsoluteRefType: absoluteRefType
    };
    return {
      unitId,
      sheetName,
      range
    };
  }
  const refStartString = refBody.substring(0, colonIndex);
  const refEndString = refBody.substring(colonIndex + 1);
  const startGrid = singleReference(refStartString, currentRow, currentColumn);
  const endGrid = singleReference(refEndString, currentRow, currentColumn);
  const startRow = startGrid.row;
  const startColumn = startGrid.column;
  const endRow = endGrid.row;
  const endColumn = endGrid.column;
  return {
    unitId,
    sheetName,
    range: {
      startRow,
      startColumn,
      endRow,
      endColumn,
      startAbsoluteRefType: startGrid.absoluteRefType,
      endAbsoluteRefType: endGrid.absoluteRefType
    }
  };
}
function serializeRangeToR1C1(range) {
  const startRowRef = getR1C1Ref(range.startRow, range.startAbsoluteRefType, true);
  const startColumnRef = getR1C1Ref(range.startColumn, range.startAbsoluteRefType, false);
  const endRowRef = getR1C1Ref(range.endRow, range.endAbsoluteRefType, true);
  const endColumnRef = getR1C1Ref(range.endColumn, range.endAbsoluteRefType, false);
  if (startRowRef === endRowRef && startColumnRef === endColumnRef) {
    return `R${startRowRef}C${startColumnRef}`;
  }
  return `R${startRowRef}C${startColumnRef}:R${endRowRef}C${endColumnRef}`;
}
function getR1C1Ref(index, absoluteRefType = 3 /* ALL */, isRow) {
  index += 1;
  switch (absoluteRefType) {
    case 3 /* ALL */:
      return `${index}`;
    case 1 /* ROW */:
      return isRow ? `${index}` : `[${index}]`;
    case 2 /* COLUMN */:
      return isRow ? `[${index}]` : `${index}`;
    case 0 /* NONE */:
      return `[${index}]`;
  }
}

// ../packages/engine-formula/src/engine/utils/check-variant-error.ts
function checkVariantErrorIsArray(variant) {
  let _variant = variant;
  if (variant.isArray()) {
    const rowCount = variant.getRowCount();
    const columnCount = variant.getColumnCount();
    if (rowCount > 1 || columnCount > 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    _variant = variant.get(0, 0);
  }
  if (_variant.isError()) {
    return _variant;
  }
  return _variant;
}
function checkVariantsErrorIsArray(...variants) {
  for (let i = 0; i < variants.length; i++) {
    const variant = checkVariantErrorIsArray(variants[i]);
    if (variant.isError()) {
      return {
        isError: true,
        errorObject: variant
      };
    }
    variants[i] = variant;
  }
  return {
    isError: false,
    variants
  };
}
function checkVariantsErrorIsArrayOrBoolean(...variants) {
  for (let i = 0; i < variants.length; i++) {
    const variant = checkVariantErrorIsArray(variants[i]);
    if (variant.isError()) {
      return {
        isError: true,
        errorObject: variant
      };
    }
    if (variant.isBoolean()) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    variants[i] = variant;
  }
  return {
    isError: false,
    variants
  };
}
function checkVariantsErrorIsNullorArrayOrBoolean(...variants) {
  for (let i = 0; i < variants.length; i++) {
    let variant = variants[i];
    if (variant.isError()) {
      return {
        isError: true,
        errorObject: variant
      };
    }
    if (variant.isNull()) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#N/A" /* NA */)
      };
    }
    variant = checkVariantErrorIsArray(variants[i]);
    if (variant.isError()) {
      return {
        isError: true,
        errorObject: variant
      };
    }
    if (variant.isBoolean()) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    variants[i] = variant;
  }
  return {
    isError: false,
    variants
  };
}
function checkVariantsErrorIsStringToNumber(...variants) {
  for (let i = 0; i < variants.length; i++) {
    let variant = variants[i];
    if (variant.isString()) {
      variant = variant.convertToNumberObjectValue();
    }
    if (variant.isError()) {
      return {
        isError: true,
        errorObject: variant
      };
    }
    variants[i] = variant;
  }
  return {
    isError: false,
    variants
  };
}

// ../packages/engine-formula/src/functions/base-function.ts
var BaseFunction = class {
  constructor(_name) {
    this._name = _name;
    __publicField(this, "_unitId");
    __publicField(this, "_subUnitId");
    __publicField(this, "_row", -1);
    __publicField(this, "_column", -1);
    __publicField(this, "_definedNames");
    __publicField(this, "_locale");
    __publicField(this, "_sheetOrder");
    __publicField(this, "_sheetNameMap");
    __publicField(this, "_formulaDataModel");
    __publicField(this, "_rowCount", -1);
    __publicField(this, "_columnCount", -1);
    /**
     * Whether the function needs to expand the parameters
     */
    __publicField(this, "needsExpandParams", false);
    /**
     * Whether the function needs to pass in reference object
     */
    __publicField(this, "needsReferenceObject", false);
    /**
     * Whether the function needs handle locale
     */
    __publicField(this, "needsLocale", false);
    /**
     * Whether the function needs sheets info
     */
    __publicField(this, "needsSheetsInfo", false);
    /**
     * Whether the function needs function methods in FormulaDataModel
     */
    __publicField(this, "needsFormulaDataModel", false);
    /**
     * Whether the function needs the number of rows and columns in the sheet
     */
    __publicField(this, "needsSheetRowColumnCount", false);
    /**
     * Whether the function needs to filter out rows
     */
    __publicField(this, "needsFilteredOutRows", false);
    /**
     * Minimum number of parameters
     */
    __publicField(this, "minParams", -1);
    /**
     * Maximum number of parameters
     */
    __publicField(this, "maxParams", -1);
  }
  get name() {
    return this._name;
  }
  get unitId() {
    return this._unitId;
  }
  get subUnitId() {
    return this._subUnitId;
  }
  get row() {
    return this._row;
  }
  get column() {
    return this._column;
  }
  dispose() {
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  getDefinedName(name) {
    var _a2;
    const nameMap2 = this._definedNames;
    if (nameMap2 == null) {
      return null;
    }
    return (_a2 = Array.from(Object.values(nameMap2)).filter((value) => {
      return value.name === name;
    })) == null ? void 0 : _a2[0];
  }
  setDefinedNames(definedNames) {
    this._definedNames = definedNames;
  }
  getLocale() {
    return this._locale;
  }
  setLocale(locale) {
    this._locale = locale;
  }
  getSheetsInfo() {
    return {
      sheetOrder: this._sheetOrder,
      sheetNameMap: this._sheetNameMap
    };
  }
  setSheetsInfo({
    sheetOrder,
    sheetNameMap
  }) {
    this._sheetOrder = sheetOrder;
    this._sheetNameMap = sheetNameMap;
  }
  setFormulaDataModel(_formulaDataModel) {
    this._formulaDataModel = _formulaDataModel;
  }
  setSheetRowColumnCount(rowCount, columnCount) {
    this._rowCount = rowCount;
    this._columnCount = columnCount;
  }
  isAsync() {
    return false;
  }
  isAddress() {
    return false;
  }
  isCustom() {
    return false;
  }
  setRefInfo(unitId, subUnitId, row, column) {
    this._unitId = unitId;
    this._subUnitId = subUnitId;
    this._row = row;
    this._column = column;
  }
  calculateCustom(...arg) {
    return null;
  }
  calculate(...arg) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  checkArrayType(variant) {
    return variant.isReferenceObject() || variant.isValueObject() && variant.isArray();
  }
  /**
   * Starting with 1
   * For instance, The column number (starting with 1 for the left-most column of table_array) that contains the return value.
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * @param indexNum
   */
  getIndexNumValue(indexNum, defaultValue = 1) {
    let _indexNum = indexNum;
    if (_indexNum.isArray()) {
      _indexNum = _indexNum.getFirstCell();
    }
    if (_indexNum.isBoolean()) {
      const colIndexNumV = _indexNum.getValue();
      if (colIndexNumV === false) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return defaultValue;
    }
    if (_indexNum.isString()) {
      const colIndexNumV = Number(_indexNum.getValue());
      if (Number.isNaN(colIndexNumV)) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      return colIndexNumV;
    } else if (_indexNum.isNumber()) {
      const colIndexNumV = _indexNum.getValue();
      return colIndexNumV;
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, default 1
   * For instance range_lookup, A logical value that specifies whether you want VLOOKUP to find an approximate or an exact match
   * Approximate match - 1/TRUE
   * Exact match - 0/FALSE
   * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
   * For instance A1, A logical value that specifies what type of reference is contained in the cell ref_text.
   * If a1 is TRUE or omitted, ref_text is interpreted as an A1-style reference.
   * If a1 is FALSE, ref_text is interpreted as an R1C1-style reference.
   * https://support.microsoft.com/zh-cn/office/indirect-%E5%87%BD%E6%95%B0-474b3a3a-8a26-4f44-b491-92b6306fa261
   * @param logicValueObject
   */
  getZeroOrOneByOneDefault(logicValueObject) {
    if (logicValueObject == null) {
      return 1;
    }
    let logicValue = 1;
    if (logicValueObject.isArray()) {
      logicValueObject = logicValueObject.getFirstCell();
    }
    if (logicValueObject.isBoolean()) {
      const logicV = logicValueObject.getValue();
      if (logicV === false) {
        logicValue = 0;
      }
    } else if (logicValueObject.isString()) {
      return;
    } else if (logicValueObject.isNumber()) {
      const logicV = logicValueObject.getValue();
      if (logicV === 0) {
        logicValue = 0;
      }
    }
    return logicValue;
  }
  /**
   * A logical value that specifies 1/TRUE , 0/FALSE, -1, default 1.
   * The difference from getZeroOrOneByOneDefault is that we need to get -1
   * @param logicValueObject
   */
  getMatchTypeValue(logicValueObject) {
    if (logicValueObject == null) {
      return 1;
    }
    let logicValue = 1;
    if (logicValueObject.isArray()) {
      logicValueObject = logicValueObject.getFirstCell();
    }
    if (logicValueObject.isBoolean()) {
      const logicV = logicValueObject.getValue();
      if (logicV === false) {
        logicValue = 0;
      }
    } else if (logicValueObject.isString()) {
      return;
    } else if (logicValueObject.isNumber()) {
      const logicV = logicValueObject.getValue();
      if (logicV <= 0) {
        logicValue = logicV;
      }
    }
    return logicValue;
  }
  binarySearch(value, searchArray2, resultArray, searchType, matchType) {
    const rowOrColumn = searchArray2.binarySearch(value, searchType, matchType);
    if (rowOrColumn == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let resultValue;
    if (resultArray.getRowCount() === 1) {
      resultValue = resultArray.get(0, rowOrColumn) || NullValueObject.create();
    } else {
      resultValue = resultArray.get(rowOrColumn, 0) || NullValueObject.create();
    }
    if (resultValue.isNull()) {
      return NumberValueObject.create(0);
    }
    return resultValue;
  }
  _getOneFirstByRaw(array) {
    if (array.length === 0) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    return array[0][0] || ErrorValueObject.create("#N/A" /* NA */);
  }
  _getOneLastByRaw(array) {
    if (array.length === 0) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    return array[array.length - 1][array[0].length - 1] || ErrorValueObject.create("#N/A" /* NA */);
  }
  equalSearch(value, searchArray2, resultArray, isFirst = true) {
    const resultArrayValue = resultArray.pickRaw(searchArray2.isEqual(value));
    if (isFirst) {
      return this._getOneFirstByRaw(resultArrayValue);
    }
    return this._getOneLastByRaw(resultArrayValue);
  }
  fuzzySearch(value, searchArray2, resultArray, isFirst = true) {
    const resultArrayValue = resultArray.pickRaw(searchArray2.compare(value, "=" /* EQUALS */));
    if (isFirst) {
      return this._getOneFirstByRaw(resultArrayValue);
    }
    return this._getOneLastByRaw(resultArrayValue);
  }
  orderSearch(value, searchArray2, resultArray, searchType = 1 /* MIN */, isDesc = false) {
    const position = searchArray2.orderSearch(value, searchType, isDesc);
    if (position == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const resultValue = resultArray.get(position.row, position.column) || NullValueObject.create();
    if (resultValue.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    return resultValue;
  }
  binarySearchExpand(value, searchArray2, resultArray, axis = 0, searchType, matchType) {
    const rowOrColumn = searchArray2.binarySearch(value, searchType, matchType);
    if (rowOrColumn == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (axis === 0) {
      return resultArray.slice([rowOrColumn, rowOrColumn + 1]);
    }
    return resultArray.slice(void 0, [rowOrColumn, rowOrColumn + 1]);
  }
  equalSearchExpand(value, searchArray2, resultArray, isFirst = true, axis = 0) {
    const matchObject = searchArray2.isEqual(value);
    let position;
    if (isFirst) {
      position = matchObject.getFirstTruePosition();
    } else {
      position = matchObject.getLastTruePosition();
    }
    if (position == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (axis === 0) {
      return resultArray.slice([position.row, position.row + 1]);
    }
    return resultArray.slice(void 0, [position.column, position.column + 1]);
  }
  fuzzySearchExpand(value, searchArray2, resultArray, isFirst = true, axis = 0) {
    const matchObject = searchArray2.compare(value, "=" /* EQUALS */);
    let position;
    if (isFirst) {
      position = matchObject.getFirstTruePosition();
    } else {
      position = matchObject.getLastTruePosition();
    }
    if (position == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (axis === 0) {
      return resultArray.slice([position.row, position.row + 1]);
    }
    return resultArray.slice(void 0, [position.column, position.column + 1]);
  }
  orderSearchExpand(value, searchArray2, resultArray, searchType = 1 /* MIN */, isDesc = false, axis = 0) {
    const position = searchArray2.orderSearch(value, searchType, isDesc);
    if (position == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (axis === 0) {
      return resultArray.slice([position.row, position.row + 1]);
    }
    return resultArray.slice(void 0, [position.column, position.column + 1]);
  }
  flattenArray(variants, ignoreLogicalValuesAndText = true) {
    const flattenValues = [];
    flattenValues[0] = [];
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString() || variant.isBoolean() || variant.isNull()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        let errorValue;
        variant.iterator((valueObject) => {
          if (valueObject == null || valueObject.isNull()) {
            return true;
          }
          if (ignoreLogicalValuesAndText && (valueObject.isString() || valueObject.isBoolean())) {
            return true;
          }
          valueObject = this._includingLogicalValuesAndText(valueObject);
          if (valueObject.isError()) {
            errorValue = valueObject;
            return false;
          }
          flattenValues[0].push(valueObject);
        });
        if (errorValue == null ? void 0 : errorValue.isError()) {
          return errorValue;
        }
      } else {
        flattenValues[0].push(variant);
      }
    }
    return createNewArray(flattenValues, 1, flattenValues[0].length);
  }
  _includingLogicalValuesAndText(valueObject) {
    if (valueObject.isBoolean()) {
      valueObject = convertTonNumber(valueObject);
    }
    if (valueObject.isString()) {
      const value = Number(valueObject.getValue());
      valueObject = NumberValueObject.create(Number.isNaN(value) ? 0 : value);
    }
    return valueObject;
  }
  createReferenceObject(reference, range) {
    const unitId = reference.getForcedUnitId();
    const sheetId = reference.getForcedSheetId() || "";
    const sheetName = reference.getForcedSheetName();
    const gridRangeName = {
      unitId,
      sheetName,
      range
    };
    const token = serializeRangeToRefString(gridRangeName);
    let referenceObject;
    if (regexTestSingeRange(token)) {
      referenceObject = new CellReferenceObject(token);
    } else if (regexTestSingleRow(token)) {
      referenceObject = new RowReferenceObject(token);
    } else if (regexTestSingleColumn(token)) {
      referenceObject = new ColumnReferenceObject(token);
    } else {
      referenceObject = new RangeReferenceObject(range, sheetId, unitId);
    }
    return this._setReferenceDefault(reference, referenceObject);
  }
  _setReferenceDefault(reference, object) {
    if (this.unitId == null || this.subUnitId == null) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    object.setDefaultUnitId(this.unitId);
    object.setDefaultSheetId(this.subUnitId);
    object.setUnitData(reference.getUnitData());
    object.setRuntimeData(reference.getRuntimeData());
    object.setArrayFormulaCellData(reference.getArrayFormulaCellData());
    object.setRuntimeArrayFormulaCellData(reference.getRuntimeArrayFormulaCellData());
    return object;
  }
};

// ../packages/engine-formula/src/functions/array/array-constrain/index.ts
var ArrayConstrain = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(inputRange, numRows, numCols) {
    if (inputRange.isError()) {
      return inputRange;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArray(numRows, numCols);
    if (isError) {
      return errorObject;
    }
    const { isError: _isError, errorObject: _errorObject, variants: _variants } = checkVariantsErrorIsStringToNumber(...variants);
    if (_isError) {
      return _errorObject;
    }
    const [numRowsObject, numColsObject] = _variants;
    const numRowsValue = Math.floor(+numRowsObject.getValue());
    const numColsValue = Math.floor(+numColsObject.getValue());
    if (numRowsValue < 0 || numColsValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (numRowsValue === 0 || numColsValue === 0) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const rowCount = inputRange.isArray() ? inputRange.getRowCount() : 1;
    const columnCount = inputRange.isArray() ? inputRange.getColumnCount() : 1;
    if (rowCount === 1 && columnCount === 1) {
      return inputRange.isArray() ? inputRange.get(0, 0) : inputRange;
    }
    const maxRowCount = numRowsValue > rowCount ? rowCount : numRowsValue;
    const maxColumnCount = numColsValue > columnCount ? columnCount : numColsValue;
    return inputRange.slice([0, maxRowCount], [0, maxColumnCount]);
  }
};

// ../packages/engine-formula/src/functions/array/flatten/index.ts
var Flatten = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const resultArray = [];
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      const rowCount = variant.isArray() ? variant.getRowCount() : 1;
      const columnCount = variant.isArray() ? variant.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const valueObject = variant.isArray() ? variant.get(r, c) : variant;
          resultArray.push([valueObject]);
        }
      }
    }
    return ArrayValueObject.create({
      calculateValueList: resultArray,
      rowCount: resultArray.length,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/array/function-map.ts
var functionArray = [
  [ArrayConstrain, "ARRAY_CONSTRAIN" /* ARRAY_CONSTRAIN */],
  [Flatten, "FLATTEN" /* FLATTEN */]
];

// ../packages/engine-formula/src/basics/engineering.ts
var BESSEL;
((BESSEL2) => {
  const W = 0.636619772;
  function _horner(arr, v) {
    let z = 0;
    for (let i = 0; i < arr.length; ++i) {
      z = v * z + arr[i];
    }
    return z;
  }
  function _bessel_iter(x, n, f0, f1, sign2) {
    if (n === 0) {
      return f0;
    }
    if (n === 1) {
      return f1;
    }
    const tdx = 2 / x;
    let _f0 = f0;
    let _f1 = f1;
    let f2 = f1;
    for (let o = 1; o < n; ++o) {
      f2 = _f1 * o * tdx + sign2 * _f0;
      _f0 = _f1;
      _f1 = f2;
    }
    return f2;
  }
  function _bessel_wrap(bessel0, bessel1, nonzero, sign2) {
    return function bessel(x, n) {
      if (nonzero) {
        if (x === 0) {
          return nonzero === 1 ? -Infinity : Infinity;
        } else if (x < 0) {
          return Number.NaN;
        }
      }
      if (n === 0) {
        return bessel0(x);
      }
      if (n === 1) {
        return bessel1(x);
      }
      if (n < 0) {
        return Number.NaN;
      }
      const _n = n | 0;
      const b0 = bessel0(x);
      const b1 = bessel1(x);
      return _bessel_iter(x, _n, b0, b1, sign2);
    };
  }
  BESSEL2.besselj = /* @__PURE__ */ (() => {
    const b0_a1a = [-184.9052456, 77392.33017, -1121442418e-2, 6516196407e-1, -13362590354, 57568490574];
    const b0_a2a = [1, 267.8532712, 59272.64853, 9494680718e-3, 1029532985, 57568490411];
    const b0_a1b = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1];
    const b0_a2b = [-934935152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function bessel0(x) {
      let a2 = 0;
      let a1 = 0;
      let a22 = 0;
      let y = x * x;
      if (x < 8) {
        a1 = _horner(b0_a1a, y);
        a22 = _horner(b0_a2a, y);
        a2 = a1 / a22;
      } else {
        const xx = x - 0.785398164;
        y = 64 / y;
        a1 = _horner(b0_a1b, y);
        a22 = _horner(b0_a2b, y);
        a2 = Math.sqrt(W / x) * (Math.cos(xx) * a1 - Math.sin(xx) * a22 * 8 / x);
      }
      return a2;
    }
    const b1_a1a = [-30.16036606, 15704.4826, -2972611439e-3, 2423968531e-1, -7895059235, 72362614232];
    const b1_a2a = [1, 376.9991397, 99447.43394, 1858330474e-2, 2300535178, 144725228442];
    const b1_a1b = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1];
    const b1_a2b = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function bessel1(x) {
      let a2 = 0;
      let a1 = 0;
      let a22 = 0;
      let y = x * x;
      const xx = Math.abs(x) - 2.356194491;
      if (Math.abs(x) < 8) {
        a1 = x * _horner(b1_a1a, y);
        a22 = _horner(b1_a2a, y);
        a2 = a1 / a22;
      } else {
        y = 64 / y;
        a1 = _horner(b1_a1b, y);
        a22 = _horner(b1_a2b, y);
        a2 = Math.sqrt(W / Math.abs(x)) * (Math.cos(xx) * a1 - Math.sin(xx) * a22 * 8 / Math.abs(x));
        if (x < 0) {
          a2 = -a2;
        }
      }
      return a2;
    }
    return function besselj2(x, n) {
      const _n = Math.round(n);
      if (!Number.isFinite(x)) {
        return Number.isNaN(x) ? x : 0;
      }
      if (_n < 0) {
        return (_n % 2 ? -1 : 1) * besselj2(x, -_n);
      }
      if (x < 0) {
        return (_n % 2 ? -1 : 1) * besselj2(-x, _n);
      }
      if (_n === 0) {
        return bessel0(x);
      }
      if (_n === 1) {
        return bessel1(x);
      }
      if (x === 0) {
        return 0;
      }
      let ret = 0;
      if (x > _n) {
        ret = _bessel_iter(x, _n, bessel0(x), bessel1(x), -1);
      } else {
        const m = 2 * Math.floor((_n + Math.floor(Math.sqrt(40 * _n))) / 2);
        let jsum = false;
        let bjp = 0;
        let sum2 = 0;
        let bj = 1;
        let bjm = 0;
        const tox = 2 / x;
        for (let j = m; j > 0; j--) {
          bjm = j * tox * bj - bjp;
          bjp = bj;
          bj = bjm;
          if (Math.abs(bj) > 1e10) {
            bj *= 1e-10;
            bjp *= 1e-10;
            ret *= 1e-10;
            sum2 *= 1e-10;
          }
          if (jsum) {
            sum2 += bj;
          }
          jsum = !jsum;
          if (j === _n) {
            ret = bjp;
          }
          if (m - j > 100 && ret === 0) {
            return Number.NaN;
          }
        }
        sum2 = 2 * sum2 - bj;
        ret /= sum2;
      }
      return ret;
    };
  })();
  BESSEL2.bessely = (() => {
    const b0_a1a = [228.4622733, -86327.92757, 1087988129e-2, -5123598036e-1, 7062834065, -2957821389];
    const b0_a2a = [1, 226.1030244, 47447.2647, 7189466438e-3, 7452499648e-1, 40076544269];
    const b0_a1b = [2093887211e-16, -2073370639e-15, 2734510407e-14, -0.001098628627, 1];
    const b0_a2b = [-934945152e-16, 7621095161e-16, -6911147651e-15, 1430488765e-13, -0.01562499995];
    function bessel0(x) {
      let a2 = 0;
      let a1 = 0;
      let a22 = 0;
      let y = x * x;
      const xx = x - 0.785398164;
      if (x < 8) {
        a1 = _horner(b0_a1a, y);
        a22 = _horner(b0_a2a, y);
        a2 = a1 / a22 + W * (0, BESSEL2.besselj)(x, 0) * Math.log(x);
      } else {
        y = 64 / y;
        a1 = _horner(b0_a1b, y);
        a22 = _horner(b0_a2b, y);
        a2 = Math.sqrt(W / x) * (Math.sin(xx) * a1 + Math.cos(xx) * a22 * 8 / x);
      }
      return a2;
    }
    const b1_a1a = [8511.937935, -4237922726e-3, 7349264551e-1, -51534381390, 127527439e4, -4900604943e3];
    const b1_a2a = [1, 354.9632885, 102042.605, 2245904002e-2, 3733650367, 424441966400, 249958057e5];
    const b1_a1b = [-240337019e-15, 2457520174e-15, -3516396496e-14, 183105e-8, 1];
    const b1_a2b = [105787412e-15, -88228987e-14, 8449199096e-15, -2002690873e-13, 0.04687499995];
    function bessel1(x) {
      let a2 = 0;
      let a1 = 0;
      let a22 = 0;
      let y = x * x;
      const xx = x - 2.356194491;
      if (x < 8) {
        a1 = x * _horner(b1_a1a, y);
        a22 = _horner(b1_a2a, y);
        a2 = a1 / a22 + W * ((0, BESSEL2.besselj)(x, 1) * Math.log(x) - 1 / x);
      } else {
        y = 64 / y;
        a1 = _horner(b1_a1b, y);
        a22 = _horner(b1_a2b, y);
        a2 = Math.sqrt(W / x) * (Math.sin(xx) * a1 + Math.cos(xx) * a22 * 8 / x);
      }
      return a2;
    }
    return _bessel_wrap(bessel0, bessel1, 1, -1);
  })();
  BESSEL2.besseli = /* @__PURE__ */ (() => {
    const b0_a = [45813e-7, 0.0360768, 0.2659732, 1.2067492, 3.0899424, 3.5156229, 1];
    const b0_b = [392377e-8, -0.01647633, 0.02635537, -0.02057706, 916281e-8, -157565e-8, 225319e-8, 0.01328592, 0.39894228];
    function bessel0(x) {
      if (x <= 3.75) {
        return _horner(b0_a, x * x / (3.75 * 3.75));
      }
      return Math.exp(Math.abs(x)) / Math.sqrt(Math.abs(x)) * _horner(b0_b, 3.75 / Math.abs(x));
    }
    const b1_a = [32411e-8, 301532e-8, 0.02658733, 0.15084934, 0.51498869, 0.87890594, 0.5];
    const b1_b = [-420059e-8, 0.01787654, -0.02895312, 0.02282967, -0.01031555, 163801e-8, -362018e-8, -0.03988024, 0.39894228];
    function bessel1(x) {
      if (x < 3.75) {
        return x * _horner(b1_a, x * x / (3.75 * 3.75));
      }
      return (x < 0 ? -1 : 1) * Math.exp(Math.abs(x)) / Math.sqrt(Math.abs(x)) * _horner(b1_b, 3.75 / Math.abs(x));
    }
    return function besseli2(x, n) {
      const _n = Math.round(n);
      if (_n === 0) {
        return bessel0(x);
      }
      if (_n === 1) {
        return bessel1(x);
      }
      if (_n < 0) {
        return Number.NaN;
      }
      if (Math.abs(x) === 0) {
        return 0;
      }
      if (x === Infinity) {
        return Infinity;
      }
      let ret = 0;
      let j;
      const tox = 2 / Math.abs(x);
      let bip = 0;
      let bi = 1;
      let bim = 0;
      const m = 2 * Math.round((_n + Math.round(Math.sqrt(40 * _n))) / 2);
      for (j = m; j > 0; j--) {
        bim = j * tox * bi + bip;
        bip = bi;
        bi = bim;
        if (Math.abs(bi) > 1e10) {
          bi *= 1e-10;
          bip *= 1e-10;
          ret *= 1e-10;
        }
        if (j === _n) ret = bip;
        if (m - j > 100 && ret === 0) {
          return Number.NaN;
        }
      }
      ret *= besseli2(x, 0) / bi;
      return x < 0 && _n % 2 ? -ret : ret;
    };
  })();
  BESSEL2.besselk = (() => {
    const b0_a = [74e-7, 1075e-7, 262698e-8, 0.0348859, 0.23069756, 0.4227842, -0.57721566];
    const b0_b = [53208e-8, -25154e-7, 587872e-8, -0.01062446, 0.02189568, -0.07832358, 1.25331414];
    function bessel0(x) {
      if (x <= 2) {
        return -Math.log(x / 2) * (0, BESSEL2.besseli)(x, 0) + _horner(b0_a, x * x / 4);
      }
      return Math.exp(-x) / Math.sqrt(x) * _horner(b0_b, 2 / x);
    }
    const b1_a = [-4686e-8, -110404e-8, -0.01919402, -0.18156897, -0.67278579, 0.15443144, 1];
    const b1_b = [-68245e-8, 325614e-8, -780353e-8, 0.01504268, -0.0365562, 0.23498619, 1.25331414];
    function bessel1(x) {
      if (x <= 2) {
        return Math.log(x / 2) * (0, BESSEL2.besseli)(x, 1) + 1 / x * _horner(b1_a, x * x / 4);
      }
      return Math.exp(-x) / Math.sqrt(x) * _horner(b1_b, 2 / x);
    }
    return _bessel_wrap(bessel0, bessel1, 2, 1);
  })();
})(BESSEL || (BESSEL = {}));
function isValidBinaryNumber(number) {
  return /^[01]{1,10}$/.test(number);
}
function isValidOctalNumber(number) {
  return /^[0-7]{1,10}$/.test(number);
}
function isValidHexadecimalNumber(number) {
  return /^[0-9A-Fa-f]{1,10}$/.test(number);
}
function erf(x) {
  if (x === 0) {
    return 0;
  }
  const cof = [
    -1.3026537197817094,
    // eslint-disable-next-line no-loss-of-precision
    0.6419697923564902,
    0.019476473204185836,
    -0.00956151478680863,
    -946595344482036e-18,
    366839497852761e-18,
    42523324806907e-18,
    -20278578112534e-18,
    -1624290004647e-18,
    130365583558e-17,
    15626441722e-18,
    -85238095915e-18,
    6529054439e-18,
    5059343495e-18,
    -991364156e-18,
    -227365122e-18,
    96467911e-18,
    2394038e-18,
    -6886027e-18,
    894487e-18,
    313092e-18,
    -112708e-18,
    381e-18,
    7106e-18,
    -1523e-18,
    -94e-18,
    121e-18,
    -28e-18
  ];
  let _x = x;
  let isNeg = false;
  if (_x < 0) {
    _x = -_x;
    isNeg = true;
  }
  const t = 2 / (2 + _x);
  const ty = 4 * t - 2;
  let d = 0;
  let dd = 0;
  let tmp;
  for (let j = cof.length - 1; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }
  const res = t * Math.exp(-_x * _x + 0.5 * (cof[0] + ty * d) - dd);
  return isNeg ? res - 1 : 1 - res;
}
function erfc(x) {
  return 1 - erf(x);
}
function erfcINV(p) {
  if (p >= 2) {
    return -100;
  }
  if (p <= 0) {
    return 100;
  }
  const _p = p < 1 ? p : 2 - p;
  const temp = Math.sqrt(-2 * Math.log(_p / 2));
  let x = -0.70711 * ((2.30753 + temp * 0.27061) / (1 + temp * (0.99229 + temp * 0.04481)) - temp);
  for (let j = 0; j < 2; j++) {
    const err = erfc(x) - _p;
    x += err / (1.1283791670955126 * Math.exp(-x * x) - x * err);
  }
  return p < 1 ? x : -x;
}

// ../packages/engine-formula/src/basics/math.ts
function calculateFactorial(n, step = 1) {
  let _n = Math.floor(n);
  if (n < 0) {
    return Number.NaN;
  }
  let result = 1;
  while (_n > 1 && Number.isFinite(result)) {
    result *= _n;
    _n -= step;
  }
  return result;
}
function calculateCombin(n, k) {
  const t = Math.min(n - k, k);
  let result = 1;
  for (let i = 1; i <= t; i++) {
    if (!Number.isFinite(result)) {
      break;
    }
    result *= n - i + 1;
    result /= i;
  }
  return result;
}
function calculateGcd(a2, b) {
  let _a2 = Math.floor(a2);
  let _b2 = Math.floor(b);
  while (_b2 !== 0) {
    const t = _b2;
    _b2 = _a2 % _b2;
    _a2 = t;
  }
  return _a2;
}
function calculateLcm(a2, b) {
  const den = calculateGcd(a2, b);
  if (den === 0) {
    return 0;
  }
  return Math.abs(a2 * b) / den;
}
function calculateMdeterm(matrix) {
  const n = matrix.length;
  if (n === 1) {
    return matrix[0][0];
  }
  if (n === 2) {
    return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
  }
  let det = 0;
  for (let col = 0; col < n; col++) {
    det += (col % 2 === 0 ? 1 : -1) * matrix[0][col] * calculateMdeterm(minor(matrix, 0, col));
  }
  return det;
}
function calculateMinverse(matrix) {
  const det = calculateMdeterm(matrix);
  if (det === 0) {
    return null;
  }
  if (matrix.length === 1) {
    return [[1 / det]];
  }
  const adjugate = adjoint(matrix);
  const inverseMatrix = adjugate.map((row) => row.map((value) => value / det));
  return inverseMatrix;
}
function minor(matrix, row, col) {
  return matrix.filter((_, r) => r !== row).map((row2) => row2.filter((_, c) => c !== col));
}
function adjoint(matrix) {
  const n = matrix.length;
  const adj = Array.from({ length: n }, () => new Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const sign2 = (i + j) % 2 === 0 ? 1 : -1;
      adj[j][i] = sign2 * calculateMdeterm(minor(matrix, i, j));
    }
  }
  return adj;
}
function calculateMmult(matrix1, matrix2) {
  return matrix1.map((row) => matrix2[0].map(
    (_, colIndex) => row.reduce((sum2, element, rowIndex) => sum2 + element * matrix2[rowIndex][colIndex], 0)
  ));
}
function matrixTranspose(matrix) {
  return matrix[0].map((_, colIndex) => matrix.map((row) => row[colIndex]));
}
function inverseMatrixByLUD(matrix) {
  const { smallPivotDetected, luMatrix, permutation } = performLUDecomposition(matrix);
  if (smallPivotDetected) {
    return null;
  }
  return transformMatrix(luMatrix, permutation);
}
function performLUDecomposition(matrix) {
  const decomposedMatrix = matrixTranspose(matrix);
  const numRows = decomposedMatrix.length;
  const numCols = decomposedMatrix[0].length;
  let isRowSwap = true;
  let smallPivotDetected = false;
  const luMatrix = createMatrix(numRows, numCols, 0);
  const permutation = new Array(numCols).fill(0).map((_, index) => index);
  for (let c = 0; c < numCols; c++) {
    for (let i = 0; i < c; i++) {
      let value = decomposedMatrix[i][c];
      for (let k = 0; k < i; k++) {
        value -= luMatrix[i][k] * luMatrix[k][c];
      }
      luMatrix[i][c] = value;
    }
    let maxPivot = -Infinity;
    let pivotRow = c;
    for (let r = c; r < numRows; r++) {
      let value = decomposedMatrix[r][c];
      for (let k = 0; k < c; k++) {
        value -= luMatrix[r][k] * luMatrix[k][c];
      }
      luMatrix[r][c] = value;
      const absValue = Math.abs(value);
      if (absValue > maxPivot) {
        maxPivot = absValue;
        pivotRow = r;
      }
    }
    if (Math.abs(luMatrix[pivotRow][c]) < 1e-11) {
      smallPivotDetected = true;
      break;
    }
    if (pivotRow !== c) {
      [luMatrix[c], luMatrix[pivotRow]] = [luMatrix[pivotRow], luMatrix[c]];
      [decomposedMatrix[c], decomposedMatrix[pivotRow]] = [decomposedMatrix[pivotRow], decomposedMatrix[c]];
      [permutation[c], permutation[pivotRow]] = [permutation[pivotRow], permutation[c]];
      isRowSwap = !isRowSwap;
    }
    const pivotElement = luMatrix[c][c];
    for (let r = c + 1; r < numRows; r++) {
      luMatrix[r][c] /= pivotElement;
    }
  }
  return {
    rowSwap: isRowSwap,
    smallPivotDetected,
    luMatrix,
    permutation
  };
}
function transformMatrix(inputMatrix, indices) {
  const size = indices.length;
  const identityMatrix = createMatrix(size, size, 0);
  for (let i = 0; i < size; i++) {
    identityMatrix[i][i] = 1;
  }
  const resultMatrix = createMatrix(size, size, 0);
  for (let rowIndex = 0; rowIndex < size; rowIndex++) {
    const index = indices[rowIndex];
    for (let colIndex = 0; colIndex < size; colIndex++) {
      resultMatrix[rowIndex][colIndex] = identityMatrix[index][colIndex];
    }
  }
  for (let pivot = 0; pivot < size; pivot++) {
    const currentRow = resultMatrix[pivot];
    for (let row = pivot + 1; row < size; row++) {
      const factor = inputMatrix[row][pivot];
      for (let column = 0; column < size; column++) {
        resultMatrix[row][column] -= currentRow[column] * factor;
      }
    }
  }
  for (let row = size - 1; row >= 0; row--) {
    const currentRow = resultMatrix[row];
    const pivotElement = inputMatrix[row][row];
    for (let column = 0; column < size; column++) {
      currentRow[column] /= pivotElement;
    }
    for (let upperRow = 0; upperRow < row; upperRow++) {
      const upperFactor = inputMatrix[upperRow][row];
      for (let upperCol = 0; upperCol < size; upperCol++) {
        resultMatrix[upperRow][upperCol] -= currentRow[upperCol] * upperFactor;
      }
    }
  }
  return resultMatrix;
}
function createMatrix(rows, cols, initialValue) {
  const matrix = [];
  for (let r = 0; r < rows; r++) {
    matrix[r] = [];
    for (let c = 0; c < cols; c++) {
      matrix[r].push(initialValue);
    }
  }
  return matrix;
}
function inverseMatrixByUSV(matrix) {
  const matrixUSV = getMatrixUSV(matrix);
  if (!matrixUSV) {
    return null;
  }
  const { matrixU, matrixS, matrixV } = matrixUSV;
  const matrixUT = matrixTranspose(matrixU);
  const newMatrix = Array.from({ length: matrixS.length }, () => new Array(matrix[0].length).fill(0));
  const EPSILON = Math.max(matrix.length, matrix[0].length) * Number.EPSILON * matrixS[0];
  for (let i = 0; i < matrixS.length; i++) {
    if (Math.abs(matrixS[i]) > EPSILON) {
      newMatrix[i][i] = 1 / matrixS[i];
    }
  }
  return calculateMmult(matrixV, calculateMmult(newMatrix, matrixUT));
}
function getMatrixUSV(matrix) {
  const matrixU = matrixTranspose(matrix);
  const m = matrixU.length;
  const n = matrixU[0].length;
  if (m < n) {
    return null;
  }
  const matrixF = new Array(n).fill(0);
  const matrixS = new Array(n).fill(0);
  const matrixV = Array.from({ length: n }, () => new Array(n).fill(0));
  let EPSILON = Number.EPSILON;
  let sqrt3 = 0;
  let msp = 0;
  let maxCoeffecient = 0;
  for (let i = 0; i < n; i++) {
    matrixF[i] = sqrt3;
    msp = getMatrixSumProductOfRows(matrixU, i, m, i, i);
    if (msp <= 1e-64 / EPSILON) {
      sqrt3 = 0;
    } else {
      sqrt3 = Math.sqrt(msp);
      if (matrixU[i][i] >= 0) {
        sqrt3 = -sqrt3;
      }
      const temp = matrixU[i][i] * sqrt3 - msp;
      matrixU[i][i] -= sqrt3;
      for (let j = i + 1; j < n; j++) {
        msp = getMatrixSumProductOfRows(matrixU, i, m, i, j);
        for (let k = i; k < m; k++) {
          matrixU[k][j] += msp / temp * matrixU[k][i];
        }
      }
    }
    matrixS[i] = sqrt3;
    msp = getMatrixSumProductOfCols(matrixU, i + 1, n, i, i);
    if (msp <= 1e-64 / EPSILON) {
      sqrt3 = 0;
    } else {
      sqrt3 = Math.sqrt(msp);
      if (matrixU[i][i + 1] >= 0) {
        sqrt3 = -sqrt3;
      }
      const temp = matrixU[i][i + 1] * sqrt3 - msp;
      matrixU[i][i + 1] -= sqrt3;
      for (let j = i + 1; j < n; j++) {
        matrixF[j] = matrixU[i][j] / temp;
      }
      for (let j = i + 1; j < m; j++) {
        msp = getMatrixSumProductOfCols(matrixU, i + 1, n, j, i);
        for (let k = i + 1; k < n; k++) {
          matrixU[j][k] += msp * matrixF[k];
        }
      }
    }
    const coefficient = Math.abs(matrixS[i]) + Math.abs(matrixF[i]);
    if (coefficient > maxCoeffecient) {
      maxCoeffecient = coefficient;
    }
  }
  let o = 0;
  for (let i = n - 1; i >= 0; i--) {
    if (sqrt3 !== 0) {
      for (let j = o; j < n; j++) {
        matrixV[j][i] = matrixU[i][j] / (sqrt3 * matrixU[i][i + 1]);
      }
      for (let j = o; j < n; j++) {
        msp = 0;
        for (let k = o; k < n; k++) {
          msp += matrixU[i][k] * matrixV[k][j];
        }
        for (let k = o; k < n; k++) {
          matrixV[k][j] += msp * matrixV[k][i];
        }
      }
    }
    for (let j = o; j < n; j++) {
      matrixV[i][j] = 0;
      matrixV[j][i] = 0;
    }
    matrixV[i][i] = 1;
    sqrt3 = matrixF[i];
    o = i;
  }
  for (let i = n - 1; i >= 0; i--) {
    sqrt3 = matrixS[i];
    for (let j = i + 1; j < n; j++) {
      matrixU[i][j] = 0;
    }
    if (sqrt3 !== 0) {
      for (let j = i + 1; j < n; j++) {
        msp = getMatrixSumProductOfRows(matrixU, i + 1, m, i, j);
        for (let k = i; k < m; k++) {
          matrixU[k][j] += msp / (matrixU[i][i] * sqrt3) * matrixU[k][i];
        }
      }
      for (let j = i; j < m; j++) {
        matrixU[j][i] /= sqrt3;
      }
    } else {
      for (let j = i; j < m; j++) {
        matrixU[j][i] = 0;
      }
    }
    matrixU[i][i] += 1;
  }
  EPSILON *= maxCoeffecient;
  let a2 = 0;
  let b = 0;
  let ratio = 0;
  for (let i = n - 1; i >= 0; i--) {
    for (let S2 = 0; S2 < 50; S2++) {
      let isNeedHandle = false;
      let index = i;
      for (; index >= 0; index--) {
        if (Math.abs(matrixF[index]) <= EPSILON) {
          isNeedHandle = true;
          break;
        }
        if (Math.abs(matrixS[index - 1]) <= EPSILON) {
          break;
        }
      }
      if (!isNeedHandle) {
        let temp12 = 0;
        let temp22 = 1;
        for (let j = index; j < i + 1; j++) {
          a2 = temp22 * matrixF[j];
          b = matrixS[j];
          matrixF[j] *= temp12;
          if (Math.abs(a2) <= EPSILON) {
            break;
          }
          ratio = computeHypotenuse(a2, b);
          matrixS[j] = ratio;
          temp12 = b / ratio;
          temp22 = -a2 / ratio;
          for (let k = 0; k < m; k++) {
            const value1 = matrixU[k][index - 1];
            const value2 = matrixU[k][j];
            matrixU[k][index - 1] = value1 * temp12 + value2 * temp22;
            matrixU[k][j] = -value1 * temp22 + value2 * temp12;
          }
        }
      }
      if (index === i) {
        if (matrixS[i] < 0) {
          matrixS[i] = -matrixS[i];
          for (let j = 0; j < n; j++) {
            matrixV[j][i] = -matrixV[j][i];
          }
        }
        break;
      }
      if (S2 >= 49) {
        return null;
      }
      let indexValue = matrixS[index];
      a2 = ((matrixS[i - 1] - matrixS[i]) * (matrixS[i - 1] + matrixS[i]) + (matrixF[i - 1] - matrixF[i]) * (matrixF[i - 1] + matrixF[i])) / (2 * matrixF[i] * matrixS[i - 1]);
      ratio = computeHypotenuse(a2, 1);
      if (a2 < 0) {
        a2 = ((indexValue - matrixS[i]) * (indexValue + matrixS[i]) + matrixF[i] * (matrixS[i - 1] / (a2 - ratio) - matrixF[i])) / indexValue;
      } else {
        a2 = ((indexValue - matrixS[i]) * (indexValue + matrixS[i]) + matrixF[i] * (matrixS[i - 1] / (a2 + ratio) - matrixF[i])) / indexValue;
      }
      let temp1 = 1;
      let temp2 = 1;
      for (let j = index + 1; j < i + 1; j++) {
        let matrixFValue = matrixF[j];
        let matrixSValue = matrixS[j];
        b = temp2 * matrixFValue;
        matrixFValue *= temp1;
        ratio = computeHypotenuse(a2, b);
        matrixF[j - 1] = ratio;
        temp1 = a2 / ratio;
        temp2 = b / ratio;
        a2 = indexValue * temp1 + matrixFValue * temp2;
        b = matrixSValue * temp2;
        matrixFValue = -indexValue * temp2 + matrixFValue * temp1;
        matrixSValue *= temp1;
        for (let k = 0; k < n; k++) {
          const value1 = matrixV[k][j - 1];
          const value2 = matrixV[k][j];
          matrixV[k][j - 1] = value1 * temp1 + value2 * temp2;
          matrixV[k][j] = -value1 * temp2 + value2 * temp1;
        }
        ratio = computeHypotenuse(a2, b);
        matrixS[j - 1] = ratio;
        temp1 = a2 / ratio;
        temp2 = b / ratio;
        a2 = temp1 * matrixFValue + temp2 * matrixSValue;
        indexValue = -temp2 * matrixFValue + temp1 * matrixSValue;
        for (let k = 0; k < m; k++) {
          const value1 = matrixU[k][j - 1];
          const value2 = matrixU[k][j];
          matrixU[k][j - 1] = value1 * temp1 + value2 * temp2;
          matrixU[k][j] = -value1 * temp2 + value2 * temp1;
        }
      }
      matrixF[index] = 0;
      matrixF[i] = a2;
      matrixS[i] = indexValue;
    }
  }
  for (let i = 0; i < matrixS.length; i++) {
    if (matrixS[i] < EPSILON) {
      matrixS[i] = 0;
    }
  }
  for (let i = 0; i < n; i++) {
    for (let j = i - 1; j >= 0; j--) {
      if (matrixS[j] < matrixS[i]) {
        const temp = matrixS[j];
        matrixS[j] = matrixS[i];
        matrixS[i] = temp;
        for (let k = 0; k < matrixU.length; k++) {
          const temp2 = matrixU[k][i];
          matrixU[k][i] = matrixU[k][j];
          matrixU[k][j] = temp2;
        }
        for (let k = 0; k < matrixV.length; k++) {
          const temp2 = matrixV[k][i];
          matrixV[k][i] = matrixV[k][j];
          matrixV[k][j] = temp2;
        }
        i = j;
      }
    }
  }
  return {
    matrixU,
    matrixS,
    matrixV
  };
}
function computeHypotenuse(a2, b) {
  let ratio = 0;
  if (Math.abs(a2) > Math.abs(b)) {
    ratio = b / a2;
    return Math.abs(a2) * Math.sqrt(1 + ratio * ratio);
  }
  if (b !== 0) {
    ratio = a2 / b;
    return Math.abs(b) * Math.sqrt(1 + ratio * ratio);
  }
  return 0;
}
function getMatrixSumProductOfRows(matrix, startRow, endRow, col1, col2) {
  let sum2 = 0;
  for (let i = startRow; i < endRow; i++) {
    sum2 += matrix[i][col1] * matrix[i][col2];
  }
  return sum2;
}
function getMatrixSumProductOfCols(matrix, startCol, endCol, row1, row2) {
  let sum2 = 0;
  for (let i = startCol; i < endCol; i++) {
    sum2 += matrix[row1][i] * matrix[row2][i];
  }
  return sum2;
}
var romanToArabicMap = /* @__PURE__ */ new Map([
  ["I", 1],
  ["V", 5],
  ["X", 10],
  ["L", 50],
  ["C", 100],
  ["D", 500],
  ["M", 1e3]
]);
var arabicToRomanMap = /* @__PURE__ */ new Map([
  [1, "I"],
  [4, "IV"],
  [5, "V"],
  [9, "IX"],
  [10, "X"],
  [40, "XL"],
  [45, "VL"],
  [49, "IL"],
  [50, "L"],
  [90, "XC"],
  [95, "VC"],
  [99, "IC"],
  [100, "C"],
  [400, "CD"],
  [450, "LD"],
  [490, "XD"],
  [495, "VD"],
  [499, "ID"],
  [500, "D"],
  [900, "CM"],
  [950, "LM"],
  [990, "XM"],
  [995, "VM"],
  [999, "IM"],
  [1e3, "M"]
]);
var romanFormArray = [
  [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 50, 90, 95, 100, 400, 450, 500, 900, 950, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 500, 900, 950, 990, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 500, 900, 950, 990, 995, 1e3, 4e3],
  [1, 4, 5, 9, 10, 40, 45, 49, 50, 90, 95, 99, 100, 400, 450, 490, 495, 499, 500, 900, 950, 990, 995, 999, 1e3, 4e3]
];

// ../packages/engine-formula/src/basics/statistical.ts
function betaCDF(x, alpha, beta) {
  if (x <= 0) {
    return 0;
  }
  if (x >= 1) {
    return 1;
  }
  return incompleteBetaFunction(x, alpha, beta);
}
function betaPDF(x, alpha, beta) {
  if (x <= 0 || x >= 1) {
    return 0;
  }
  if (alpha === 1 && beta === 1) {
    return 1;
  }
  if (alpha < 512 && beta < 512) {
    return x ** (alpha - 1) * (1 - x) ** (beta - 1) / betaFunction(alpha, beta);
  }
  return Math.exp((alpha - 1) * Math.log(x) + (beta - 1) * Math.log(1 - x) - betaFunctionNaturalLogarithm(alpha, beta));
}
function betaINV(probability, alpha, beta) {
  if (probability <= 0) {
    return 0;
  }
  if (probability >= 1) {
    return 1;
  }
  const EPSILON = 1e-8;
  let x;
  if (alpha >= 1 && beta >= 1) {
    const p = probability < 0.5 ? probability : 1 - probability;
    const temp = Math.sqrt(-2 * Math.log(p));
    x = (2.30753 + temp * 0.27061) / (1 + temp * (0.99229 + temp * 0.04481)) - temp;
    if (probability < 0.5) {
      x = -x;
    }
    const temp1 = (x * x - 3) / 6;
    const temp2 = 2 / (1 / (2 * alpha - 1) + 1 / (2 * beta - 1));
    const temp3 = x * Math.sqrt(temp1 + temp2) / temp2 - (1 / (2 * beta - 1) - 1 / (2 * alpha - 1)) * (temp1 + 5 / 6 - 2 / (3 * temp2));
    x = alpha / (alpha + beta * Math.exp(2 * temp3));
  } else {
    const temp1 = Math.exp(alpha * Math.log(alpha / (alpha + beta))) / alpha;
    const temp2 = Math.exp(beta * Math.log(beta / (alpha + beta))) / beta;
    const temp3 = temp1 + temp2;
    if (probability < temp1 / temp3) {
      x = (alpha * temp3 * probability) ** (1 / alpha);
    } else {
      x = 1 - (beta * temp3 * (1 - probability)) ** (1 / beta);
    }
  }
  const betalnNeg = -betaFunctionNaturalLogarithm(alpha, beta);
  let ibeta, t, u;
  for (let j = 0; j < 10; j++) {
    if (x === 0 || x === 1) {
      return x;
    }
    ibeta = incompleteBetaFunction(x, alpha, beta) - probability;
    t = Math.exp((alpha - 1) * Math.log(x) + (beta - 1) * Math.log(1 - x) + betalnNeg);
    u = ibeta / t;
    x -= t = u / (1 - 0.5 * Math.min(1, u * ((alpha - 1) / x - (beta - 1) / (1 - x))));
    if (x <= 0) {
      x = 0.5 * (x + t);
    }
    if (x >= 1) {
      x = 0.5 * (x + t + 1);
    }
    if (Math.abs(t) < EPSILON * x && j > 0) {
      break;
    }
  }
  return x;
}
function incompleteBetaFunction(x, alpha, beta) {
  const bt = x === 0 || x === 1 ? 0 : Math.exp(gammaln(alpha + beta) - gammaln(alpha) - gammaln(beta) + alpha * Math.log(x) + beta * Math.log(1 - x));
  if (x < (alpha + 1) / (alpha + beta + 2)) {
    return bt * betaContinuedFraction(x, alpha, beta) / alpha;
  }
  return 1 - bt * betaContinuedFraction(1 - x, beta, alpha) / beta;
}
function betaContinuedFraction(x, alpha, beta) {
  const MAX_ITER = 100;
  const EPSILON = 1e-8;
  let d = 1 - (alpha + beta) * x / (alpha + 1);
  if (Math.abs(d) < EPSILON) {
    d = EPSILON;
  }
  d = 1 / d;
  let c = 1;
  let h = d;
  for (let m = 1; m <= MAX_ITER; m++) {
    let temp = m * (beta - m) * x / ((alpha - 1 + m * 2) * (alpha + m * 2));
    d = 1 + temp * d;
    if (Math.abs(d) < EPSILON) {
      d = EPSILON;
    }
    c = 1 + temp / c;
    if (Math.abs(c) < EPSILON) {
      c = EPSILON;
    }
    d = 1 / d;
    h *= d * c;
    temp = -(alpha + m) * (alpha + beta + m) * x / ((alpha + m * 2) * (alpha + 1 + m * 2));
    d = 1 + temp * d;
    if (Math.abs(d) < EPSILON) {
      d = EPSILON;
    }
    c = 1 + temp / c;
    if (Math.abs(c) < EPSILON) {
      c = EPSILON;
    }
    d = 1 / d;
    h *= d * c;
    if (Math.abs(d * c - 1) < EPSILON) {
      break;
    }
  }
  return h;
}
function betaFunction(alpha, beta) {
  if (alpha + beta > 170) {
    return Math.exp(betaFunctionNaturalLogarithm(alpha, beta));
  }
  return gamma(alpha) * gamma(beta) / gamma(alpha + beta);
}
function betaFunctionNaturalLogarithm(alpha, beta) {
  return gammaln(alpha) + gammaln(beta) - gammaln(alpha + beta);
}
function binomialCDF(x, trials, probability) {
  if (x < 0) {
    return 0;
  }
  if (x >= trials) {
    return 1;
  }
  if (probability < 0 || probability > 1 || trials <= 0) {
    return Number.NaN;
  }
  let result = 0;
  for (let i = 0; i <= x; i++) {
    result += binomialPDF(i, trials, probability);
  }
  return result;
}
function binomialPDF(x, trials, probability) {
  if (probability === 0 || probability === 1) {
    if (trials * probability === x) {
      return 1;
    }
    return 0;
  }
  return calculateCombin(trials, x) * probability ** x * (1 - probability) ** (trials - x);
}
function chisquareCDF(x, degFreedom) {
  if (x <= 0) {
    return 0;
  }
  return lowRegGamma(degFreedom / 2, x / 2);
}
function chisquarePDF(x, degFreedom) {
  if (x < 0) {
    return 0;
  }
  if (x === 0 && degFreedom === 2) {
    return 0.5;
  }
  return Math.exp((degFreedom / 2 - 1) * Math.log(x) - x / 2 - degFreedom / 2 * Math.log(2) - gammaln(degFreedom / 2));
}
function chisquareINV(probability, degFreedom) {
  if (probability <= 0) {
    return 0;
  }
  if (probability >= 1) {
    return Infinity;
  }
  return 2 * lowRegGammaInverse(probability, degFreedom / 2);
}
function centralFCDF(x, degFreedom1, degFreedom2) {
  if (x < 0) {
    return 0;
  }
  return incompleteBetaFunction(degFreedom1 * x / (degFreedom1 * x + degFreedom2), degFreedom1 / 2, degFreedom2 / 2);
}
function centralFPDF(x, degFreedom1, degFreedom2) {
  if (x < 0) {
    return 0;
  }
  if (x === 0 && degFreedom1 < 2) {
    return Infinity;
  }
  if (x === 0 && degFreedom1 === 2) {
    return 1;
  }
  let result = 1 / betaFunction(degFreedom1 / 2, degFreedom2 / 2);
  result *= (degFreedom1 / degFreedom2) ** (degFreedom1 / 2);
  result *= x ** (degFreedom1 / 2 - 1);
  result *= (1 + degFreedom1 / degFreedom2 * x) ** (-(degFreedom1 + degFreedom2) / 2);
  return result;
}
function centralFINV(probability, degFreedom1, degFreedom2) {
  if (probability <= 0) {
    return 0;
  }
  if (probability >= 1) {
    return Infinity;
  }
  return degFreedom2 / (degFreedom1 * (1 / betaINV(probability, degFreedom1 / 2, degFreedom2 / 2) - 1));
}
function exponentialCDF(x, lambda) {
  if (x < 0) {
    return 0;
  }
  return 1 - Math.exp(-lambda * x);
}
function exponentialPDF(x, lambda) {
  if (x < 0) {
    return 0;
  }
  return lambda * Math.exp(-lambda * x);
}
function forecastLinear(x, knownYs, knownXs) {
  const n = knownYs.length;
  let knownYsSum = 0;
  let knownXsSum = 0;
  for (let i = 0; i < n; i++) {
    knownYsSum += knownYs[i];
    knownXsSum += knownXs[i];
  }
  const knownYsMean = knownYsSum / n;
  const knownXsMean = knownXsSum / n;
  let num = 0;
  let den = 0;
  for (let i = 0; i < n; i++) {
    num += (knownYs[i] - knownYsMean) * (knownXs[i] - knownXsMean);
    den += (knownXs[i] - knownXsMean) ** 2;
  }
  if (den === 0) {
    return Infinity;
  }
  const b = num / den;
  const a2 = knownYsMean - b * knownXsMean;
  return a2 + b * x;
}
function gamma(x) {
  const p = [
    -1.716185138865495,
    24.76565080557592,
    -379.80425647094563,
    629.3311553128184,
    866.9662027904133,
    -31451.272968848367,
    -36144.413418691176,
    66456.14382024054
  ];
  const q = [
    -30.8402300119739,
    315.35062697960416,
    -1015.1563674902192,
    -3107.771671572311,
    // eslint-disable-next-line no-loss-of-precision
    22538.11842098015,
    // eslint-disable-next-line no-loss-of-precision
    4755.846277527881,
    -134659.9598649693,
    -115132.2596755535
  ];
  let fact = 0;
  let y = x;
  if (x > 171.6243769536076) {
    return Infinity;
  }
  if (y <= 0) {
    const resMod = y % 1 + 36e-17;
    if (resMod) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * resMod);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  const yi = y;
  let n = 0;
  let z;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  let xnum = 0;
  let xden = 0;
  for (let i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  let res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (let i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
}
function gammaCDF(x, alpha, beta) {
  if (x <= 0) {
    return 0;
  }
  return lowRegGamma(alpha, x / beta);
}
function gammaPDF(x, alpha, beta) {
  if (x < 0) {
    return 0;
  }
  if (x === 0 && alpha === 1) {
    return 1 / beta;
  }
  return Math.exp((alpha - 1) * Math.log(x) - x / beta - gammaln(alpha) - alpha * Math.log(beta));
}
function gammaINV(probability, alpha, beta) {
  if (probability <= 0) {
    return 0;
  }
  if (probability >= 1) {
    return Infinity;
  }
  return beta * lowRegGammaInverse(probability, alpha);
}
function gammaln(x) {
  const coefficients = [
    76.18009172947146,
    -86.50532032941678,
    24.01409824083091,
    // eslint-disable-line
    -1.231739572450155,
    0.001208650973866179,
    -5395239384953e-18
  ];
  let y = x;
  let tmp = x + 5.5;
  tmp -= (x + 0.5) * Math.log(tmp);
  let ser = 1.000000000190015;
  for (let j = 0; j < 6; j++) {
    ser += coefficients[j] / ++y;
  }
  return -tmp + Math.log(2.5066282746310007 * ser / x);
}
function lowRegGamma(a2, x) {
  if (x < 0 || a2 <= 0) {
    return Number.NaN;
  }
  const EPSILON = 1e-30;
  const MAX_ITER = -~(Math.log(a2 >= 1 ? a2 : 1 / a2) * 8.5 + a2 * 0.4 + 17);
  const aln = gammaln(a2);
  const exp2 = Math.exp(-x + a2 * Math.log(x) - aln);
  let _a2 = a2;
  let sum2 = 1 / a2;
  let del = sum2;
  if (x < a2 + 1) {
    if (exp2 === 0) {
      return 0;
    }
    for (let i = 1; i <= MAX_ITER; i++) {
      sum2 += del *= x / ++_a2;
      if (Math.abs(del) < Math.abs(sum2) * EPSILON) {
        break;
      }
    }
    return sum2 * exp2;
  }
  if (exp2 === 0) {
    return 1;
  }
  let b = x + 1 - a2;
  let c = 1 / EPSILON;
  let d = 1 / b;
  let h = d;
  for (let i = 1; i <= MAX_ITER; i++) {
    const temp = -i * (i - a2);
    b += 2;
    d = temp * d + b;
    if (Math.abs(d) < EPSILON) {
      d = EPSILON;
    }
    c = b + temp / c;
    if (Math.abs(c) < EPSILON) {
      c = EPSILON;
    }
    d = 1 / d;
    h *= d * c;
    if (Math.abs(d * c - 1) < EPSILON) {
      break;
    }
  }
  return 1 - h * exp2;
}
function lowRegGammaInverse(p, a2) {
  if (p <= 0) {
    return 0;
  }
  if (p >= 1) {
    return Math.max(100, a2 + 100 * Math.sqrt(a2));
  }
  let x;
  if (a2 > 1) {
    const _p = p < 0.5 ? p : 1 - p;
    const temp = Math.sqrt(-2 * Math.log(_p));
    x = (2.30753 + temp * 0.27061) / (1 + temp * (0.99229 + temp * 0.04481)) - temp;
    if (p < 0.5) {
      x = -x;
    }
    x = Math.max(1e-3, a2 * (1 - 1 / (9 * a2) - x / (3 * Math.sqrt(a2))) ** 3);
  } else {
    const temp = 1 - a2 * (0.253 + a2 * 0.12);
    if (p < temp) {
      x = (p / temp) ** (1 / a2);
    } else {
      x = 1 - Math.log(1 - (p - temp) / (1 - temp));
    }
  }
  const EPSILON = 1e-8;
  const aln = gammaln(a2);
  let err, t;
  for (let j = 0; j < 12; j++) {
    if (x <= 0) {
      return 0;
    }
    err = lowRegGamma(a2, x) - p;
    if (a2 > 1) {
      t = Math.exp((a2 - 1) * (Math.log(a2 - 1) - 1) - aln) * Math.exp(-(x - (a2 - 1)) + (a2 - 1) * (Math.log(x) - Math.log(a2 - 1)));
    } else {
      t = Math.exp(-x + (a2 - 1) * Math.log(x) - aln);
    }
    if (t !== 0) {
      t = err / t / (1 - 0.5 * Math.min(1, err / t * ((a2 - 1) / x - 1)));
    }
    x -= t;
    if (x <= 0) {
      x = 0.5 * (x + t);
    }
    if (Math.abs(t) < EPSILON * x) {
      break;
    }
  }
  return x;
}
function hypergeometricCDF(x, n, M, N2) {
  let result = 0;
  for (let i = 0; i <= x; i++) {
    result += hypergeometricPDF(i, n, M, N2);
  }
  return result;
}
function hypergeometricPDF(x, n, M, N2) {
  if (n - x > N2 - M) {
    return 0;
  }
  return calculateCombin(M, x) * calculateCombin(N2 - M, n - x) / calculateCombin(N2, n);
}
function lognormalCDF(x, mean, standardDev) {
  if (x < 0) {
    return 0;
  }
  return 0.5 + 0.5 * erf((Math.log(x) - mean) / Math.sqrt(2 * standardDev * standardDev));
}
function lognormalPDF(x, mean, standardDev) {
  if (x <= 0) {
    return 0;
  }
  return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) - Math.log(standardDev) - (Math.log(x) - mean) ** 2 / (2 * standardDev * standardDev));
}
function lognormalINV(probability, mean, standardDev) {
  return Math.exp(normalINV(probability, mean, standardDev));
}
function negbinomialCDF(numberF, numberS, probabilityS) {
  if (numberF < 0) {
    return 0;
  }
  let result = 0;
  for (let i = 0; i <= numberF; i++) {
    result += negbinomialPDF(i, numberS, probabilityS);
  }
  return result;
}
function negbinomialPDF(numberF, numberS, probabilityS) {
  if (numberF < 0) {
    return 0;
  }
  return calculateCombin(numberF + numberS - 1, numberS - 1) * probabilityS ** numberS * (1 - probabilityS) ** numberF;
}
function normalCDF(x, mean, standardDev) {
  return 0.5 * (1 + erf((x - mean) / Math.sqrt(2 * standardDev * standardDev)));
}
function normalPDF(x, mean, standardDev) {
  return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(standardDev) - (x - mean) ** 2 / (2 * standardDev * standardDev));
}
function normalINV(probability, mean, standardDev) {
  return -1.4142135623730951 * standardDev * erfcINV(2 * probability) + mean;
}
function poissonCDF(x, mean) {
  let result = 0;
  for (let i = 0; i <= x; i++) {
    result += poissonPDF(i, mean);
  }
  return result;
}
function poissonPDF(x, mean) {
  return Math.exp(-mean) * mean ** x / calculateFactorial(x);
}
function studentTCDF(x, degFreedom) {
  const result = 0.5 * incompleteBetaFunction(degFreedom / (x ** 2 + degFreedom), degFreedom / 2, 0.5);
  return x < 0 ? result : 1 - result;
}
function studentTPDF(x, degFreedom) {
  const pow3 = (1 + x ** 2 / degFreedom) ** (-(degFreedom + 1) / 2);
  return 1 / (Math.sqrt(degFreedom) * betaFunction(0.5, degFreedom / 2)) * pow3;
}
function studentTINV(probability, degFreedom) {
  let x = betaINV(2 * Math.min(probability, 1 - probability), 0.5 * degFreedom, 0.5);
  x = Math.sqrt(degFreedom * (1 - x) / x);
  return probability > 0.5 ? x : -x;
}
function getTwoArrayNumberValues(array1, array2, count, array1ColumnCount, array2ColumnCount) {
  const array1Values = [];
  const array2Values = [];
  let noCalculate = true;
  for (let i = 0; i < count; i++) {
    const array1RowIndex = Math.floor(i / array1ColumnCount);
    const array1ColumnIndex = i % array1ColumnCount;
    const array2RowIndex = Math.floor(i / array2ColumnCount);
    const array2ColumnIndex = i % array2ColumnCount;
    const array1Object = array1.isArray() ? array1.get(array1RowIndex, array1ColumnIndex) : array1;
    const array2Object = array2.isArray() ? array2.get(array2RowIndex, array2ColumnIndex) : array2;
    if (array1Object.isError()) {
      return {
        isError: true,
        errorObject: array1Object,
        array1Values,
        array2Values,
        noCalculate
      };
    }
    if (array2Object.isError()) {
      return {
        isError: true,
        errorObject: array2Object,
        array1Values,
        array2Values,
        noCalculate
      };
    }
    if (array1Object.isNull() || array2Object.isNull() || array1Object.isBoolean() || array2Object.isBoolean()) {
      continue;
    }
    const array1Value = array1Object.getValue();
    const array2Value = array2Object.getValue();
    if (!isRealNum(array1Value) || !isRealNum(array2Value)) {
      continue;
    }
    array1Values.push(+array1Value);
    array2Values.push(+array2Value);
    noCalculate = false;
  }
  return {
    isError: false,
    errorObject: null,
    array1Values,
    array2Values,
    noCalculate
  };
}
function checkKnownsArrayDimensions(knownYs, knownXs, newXs) {
  const knownYsRowCount = knownYs.isArray() ? knownYs.getRowCount() : 1;
  const knownYsColumnCount = knownYs.isArray() ? knownYs.getColumnCount() : 1;
  let knownXsRowCount = knownYsRowCount;
  let knownXsColumnCount = knownYsColumnCount;
  if (knownXs && !knownXs.isNull()) {
    knownXsRowCount = knownXs.isArray() ? knownXs.getRowCount() : 1;
    knownXsColumnCount = knownXs.isArray() ? knownXs.getColumnCount() : 1;
    if (knownYsRowCount === 1 && knownXsColumnCount !== knownYsColumnCount || knownYsColumnCount === 1 && knownXsRowCount !== knownYsRowCount || knownYsRowCount !== 1 && knownYsColumnCount !== 1 && (knownXsRowCount !== knownYsRowCount || knownXsColumnCount !== knownYsColumnCount)) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#REF!" /* REF */)
      };
    }
  }
  if (newXs && !newXs.isNull()) {
    const newXsRowCount = newXs.isArray() ? newXs.getRowCount() : 1;
    const newXsColumnCount = newXs.isArray() ? newXs.getColumnCount() : 1;
    if (knownYsRowCount === 1 && knownXsRowCount > 1 && newXsRowCount !== knownXsRowCount || knownYsColumnCount === 1 && knownXsColumnCount > 1 && newXsColumnCount !== knownXsColumnCount) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#REF!" /* REF */)
      };
    }
  }
  return {
    isError: false,
    errorObject: null
  };
}
function getKnownsArrayValues(array) {
  const rowCount = array.isArray() ? array.getRowCount() : 1;
  const columnCount = array.isArray() ? array.getColumnCount() : 1;
  const values = [];
  for (let r = 0; r < rowCount; r++) {
    values[r] = [];
    for (let c = 0; c < columnCount; c++) {
      const valueObject = array.isArray() ? array.get(r, c) : array;
      if (valueObject.isError() || valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      values[r].push(+valueObject.getValue());
    }
  }
  return values;
}
function getSerialNumbersByRowsColumns(rowCount, columnCount) {
  const values = [];
  let n = 1;
  for (let r = 0; r < rowCount; r++) {
    values[r] = [];
    for (let c = 0; c < columnCount; c++) {
      values[r].push(n++);
    }
  }
  return values;
}
function getSlopeAndIntercept(knownXsValues, knownYsValues, constb, isExponentialTransform) {
  let Y = knownYsValues;
  if (isExponentialTransform) {
    Y = knownYsValues.map((value) => Math.log(value));
  }
  let slope, intercept;
  if (constb) {
    ({ slope, intercept } = getSlopeAndInterceptOfConstbIsTrue(knownXsValues, Y));
  } else {
    ({ slope, intercept } = getSlopeAndInterceptOfConstbIsFalse(knownXsValues, Y));
  }
  if (isExponentialTransform) {
    slope = Math.exp(slope);
    intercept = Math.exp(intercept);
  }
  if (Number.isNaN(slope) && !constb) {
    slope = 0;
  }
  return { slope, intercept, Y };
}
function getSlopeAndInterceptOfConstbIsTrue(knownXsValues, knownYsValues) {
  const n = knownYsValues.length;
  let sumX = 0;
  let sumY = 0;
  let sumX2 = 0;
  let sumXY = 0;
  for (let i = 0; i < n; i++) {
    sumX += knownXsValues[i];
    sumY += knownYsValues[i];
    sumX2 += knownXsValues[i] * knownXsValues[i];
    sumXY += knownXsValues[i] * knownYsValues[i];
  }
  const temp = n * sumXY - sumX * sumY;
  const slope = temp / (n * sumX2 - sumX * sumX);
  const intercept = 1 / n * sumY - slope * (1 / n) * sumX;
  return {
    slope,
    intercept
  };
}
function getSlopeAndInterceptOfConstbIsFalse(knownXsValues, knownYsValues) {
  const matrixX = [[...knownXsValues]];
  const matrixY = [...knownYsValues];
  let rowCount = matrixX.length;
  let columnCount = matrixX[0].length;
  let minCount = Math.min(rowCount, columnCount);
  const newMatrix = new Array(minCount).fill(0);
  for (let i = 0; i < minCount; i++) {
    const matrixXRow = matrixX[i];
    let sumSquare = 0;
    for (let j = 0; j < columnCount; j++) {
      sumSquare += matrixXRow[j] ** 2;
    }
    const value = matrixXRow[i] < 0 ? Math.sqrt(sumSquare) : -Math.sqrt(sumSquare);
    newMatrix[i] = value;
    if (value !== 0) {
      matrixXRow[i] -= value;
      for (let j = i + 1; j < rowCount; j++) {
        let sum2 = 0;
        for (let k = i; k < columnCount; k++) {
          sum2 -= matrixX[j][k] * matrixXRow[k];
        }
        sum2 /= value * matrixXRow[i];
        for (let k = i; k < columnCount; k++) {
          matrixX[j][k] -= sum2 * matrixXRow[k];
        }
      }
    }
  }
  rowCount = matrixX.length;
  columnCount = matrixX[0].length;
  minCount = Math.min(rowCount, columnCount);
  const result = new Array(rowCount).fill(0);
  for (let i = 0; i < minCount; i++) {
    const matrixXRow = matrixX[i];
    let sum2 = 0;
    for (let j = 0; j < columnCount; j++) {
      sum2 += matrixY[j] * matrixXRow[j];
    }
    sum2 /= newMatrix[i] * matrixXRow[i];
    for (let j = 0; j < columnCount; j++) {
      matrixY[j] += sum2 * matrixXRow[j];
    }
  }
  for (let i = newMatrix.length - 1; i >= 0; i--) {
    matrixY[i] /= newMatrix[i];
    const temp = matrixY[i];
    const matrixXRow = matrixX[i];
    result[i] = temp;
    for (let j = 0; j < i; j++) {
      matrixY[j] -= temp * matrixXRow[j];
    }
  }
  return {
    slope: result[0],
    intercept: 0
  };
}
function getKnownsArrayCoefficients(knownYsValues, knownXsValues, newXsValues, constb, isExponentialTransform) {
  const isOneRow = knownYsValues.length === 1 && knownYsValues[0].length > 1;
  let Y = knownYsValues;
  if (isExponentialTransform) {
    Y = knownYsValues.map((row) => row.map((value) => Math.log(value)));
  }
  let X = knownXsValues;
  let newX = newXsValues;
  if (isOneRow) {
    Y = matrixTranspose(Y);
    X = matrixTranspose(X);
    newX = matrixTranspose(newX);
  }
  if (constb) {
    X = X.map((row) => [...row, 1]);
  }
  const XT = matrixTranspose(X);
  const XTX = calculateMmult(XT, X);
  const XTY = calculateMmult(XT, Y);
  let XTXInverse = inverseMatrixByLUD(XTX);
  if (!XTXInverse) {
    XTXInverse = inverseMatrixByUSV(XTX);
    if (!XTXInverse) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
  }
  let coefficients = calculateMmult(XTXInverse, XTY);
  if (!constb) {
    coefficients.push([0]);
  }
  coefficients = matrixTranspose(coefficients);
  const pop = coefficients[0].pop();
  coefficients[0].reverse();
  coefficients[0].push(pop);
  if (isExponentialTransform) {
    for (let i = 0; i < coefficients[0].length; i++) {
      coefficients[0][i] = Math.exp(coefficients[0][i]);
    }
  }
  return {
    coefficients,
    Y,
    X,
    newX,
    XTXInverse
  };
}

// ../packages/engine-formula/src/functions/statistical/beta-inv/index.ts
var BetaInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
  }
  calculate(probability, alpha, beta, A, B) {
    let _A = A != null ? A : NumberValueObject.create(0);
    let _B = B != null ? B : NumberValueObject.create(1);
    if (_A.isNull()) {
      _A = NumberValueObject.create(0);
    }
    if (_B.isNull()) {
      _B = NumberValueObject.create(1);
    }
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      alpha.isArray() ? alpha.getRowCount() : 1,
      beta.isArray() ? beta.getRowCount() : 1,
      _A.isArray() ? _A.getRowCount() : 1,
      _B.isArray() ? _B.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      alpha.isArray() ? alpha.getColumnCount() : 1,
      beta.isArray() ? beta.getColumnCount() : 1,
      _A.isArray() ? _A.getColumnCount() : 1,
      _B.isArray() ? _B.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const betaArray = expandArrayValueObject(maxRowLength, maxColumnLength, beta, ErrorValueObject.create("#N/A" /* NA */));
    const AArray = expandArrayValueObject(maxRowLength, maxColumnLength, _A, ErrorValueObject.create("#N/A" /* NA */));
    const BArray = expandArrayValueObject(maxRowLength, maxColumnLength, _B, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const alphaObject = alphaArray.get(rowIndex, columnIndex);
      const betaObject = betaArray.get(rowIndex, columnIndex);
      const AObject = AArray.get(rowIndex, columnIndex);
      const BObject = BArray.get(rowIndex, columnIndex);
      return this._handleSignleObject(probabilityObject, alphaObject, betaObject, AObject, BObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, alphaObject, betaObject, AObject, BObject) {
    if (probabilityObject.isError()) {
      return probabilityObject;
    }
    if (alphaObject.isError()) {
      return alphaObject;
    }
    if (betaObject.isError()) {
      return betaObject;
    }
    if (AObject.isError()) {
      return AObject;
    }
    if (BObject.isError()) {
      return BObject;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, alphaObject, betaObject, AObject, BObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _alphaObject, _betaObject, _AObject, _BObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const alphaValue = +_alphaObject.getValue();
    const betaValue = +_betaObject.getValue();
    const AValue = +_AObject.getValue();
    const BValue = +_BObject.getValue();
    if (alphaValue <= 0 || betaValue <= 0 || probabilityValue <= 0 || probabilityValue >= 1 || AValue >= BValue) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = betaINV(probabilityValue, alphaValue, betaValue) * (BValue - AValue) + AValue;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/binom-dist/index.ts
var BinomDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(numberS, trials, probabilityS, cumulative) {
    const maxRowLength = Math.max(
      numberS.isArray() ? numberS.getRowCount() : 1,
      trials.isArray() ? trials.getRowCount() : 1,
      probabilityS.isArray() ? probabilityS.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      numberS.isArray() ? numberS.getColumnCount() : 1,
      trials.isArray() ? trials.getColumnCount() : 1,
      probabilityS.isArray() ? probabilityS.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const numberSArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberS, ErrorValueObject.create("#N/A" /* NA */));
    const trialsArray = expandArrayValueObject(maxRowLength, maxColumnLength, trials, ErrorValueObject.create("#N/A" /* NA */));
    const probabilitySArray = expandArrayValueObject(maxRowLength, maxColumnLength, probabilityS, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberSArray.mapValue((numberSObject, rowIndex, columnIndex) => {
      const trialsObject = trialsArray.get(rowIndex, columnIndex);
      const probabilitySObject = probabilitySArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (numberSObject.isError()) {
        return numberSObject;
      }
      if (trialsObject.isError()) {
        return trialsObject;
      }
      if (probabilitySObject.isError()) {
        return probabilitySObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(numberSObject, trialsObject, probabilitySObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(numberSObject, trialsObject, probabilitySObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numberSObject, trialsObject, probabilitySObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_numberSObject, _trialsObject, _probabilitySObject, _cumulativeObject] = variants;
    const numberSValue = Math.floor(+_numberSObject.getValue());
    const trialsValue = Math.floor(+_trialsObject.getValue());
    const probabilitySValue = +_probabilitySObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (numberSValue < 0 || numberSValue > trialsValue || probabilitySValue < 0 || probabilitySValue > 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = binomialCDF(numberSValue, trialsValue, probabilitySValue);
    } else {
      result = binomialPDF(numberSValue, trialsValue, probabilitySValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/binom-inv/index.ts
var BinomInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(trials, probabilityS, alpha) {
    const maxRowLength = Math.max(
      trials.isArray() ? trials.getRowCount() : 1,
      probabilityS.isArray() ? probabilityS.getRowCount() : 1,
      alpha.isArray() ? alpha.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      trials.isArray() ? trials.getColumnCount() : 1,
      probabilityS.isArray() ? probabilityS.getColumnCount() : 1,
      alpha.isArray() ? alpha.getColumnCount() : 1
    );
    const trialsArray = expandArrayValueObject(maxRowLength, maxColumnLength, trials, ErrorValueObject.create("#N/A" /* NA */));
    const probabilitySArray = expandArrayValueObject(maxRowLength, maxColumnLength, probabilityS, ErrorValueObject.create("#N/A" /* NA */));
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = trialsArray.mapValue((trialsObject, rowIndex, columnIndex) => {
      const probabilitySObject = probabilitySArray.get(rowIndex, columnIndex);
      const alphaObject = alphaArray.get(rowIndex, columnIndex);
      if (trialsObject.isError()) {
        return trialsObject;
      }
      if (probabilitySObject.isError()) {
        return probabilitySObject;
      }
      if (alphaObject.isError()) {
        return alphaObject;
      }
      return this._handleSignleObject(trialsObject, probabilitySObject, alphaObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(trialsObject, probabilitySObject, alphaObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(trialsObject, probabilitySObject, alphaObject);
    if (isError) {
      return errorObject;
    }
    const [_trialsObject, _probabilitySObject, _alphaObject] = variants;
    const trialsValue = Math.floor(+_trialsObject.getValue());
    const probabilitySValue = +_probabilitySObject.getValue();
    const alphaValue = +_alphaObject.getValue();
    if (trialsValue < 0 || probabilitySValue <= 0 || probabilitySValue >= 1 || alphaValue <= 0 || alphaValue >= 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = 0;
    while (result <= trialsValue) {
      if (binomialCDF(result, trialsValue, probabilitySValue) >= alphaValue) {
        break;
      }
      result++;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/chisq-dist-rt/index.ts
var ChisqDistRt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(x, degFreedom) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      return this._handleSignleObject(xObject, degFreedomObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedomObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedomObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedomObject] = variants;
    const xValue = +_xObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    if (xValue < 0 || degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = 1 - chisquareCDF(xValue, degFreedomValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/chisq-inv-rt/index.ts
var ChisqInvRt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(probability, degFreedom) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      return this._handleSignleObject(probabilityObject, degFreedomObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, degFreedomObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, degFreedomObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _degFreedomObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    if (probabilityValue < 0 || probabilityValue > 1 || degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = chisquareINV(1 - probabilityValue, degFreedomValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/chisq-test/index.ts
var ChisqTest = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(actualRange, expectedRange) {
    const actualRangeRowCount = actualRange.isArray() ? actualRange.getRowCount() : 1;
    const actualRangeColumnCount = actualRange.isArray() ? actualRange.getColumnCount() : 1;
    const expectedRangeRowCount = expectedRange.isArray() ? expectedRange.getRowCount() : 1;
    const expectedRangeColumnCount = expectedRange.isArray() ? expectedRange.getColumnCount() : 1;
    let _actualRange = actualRange;
    if (actualRange.isArray() && actualRangeRowCount === 1 && actualRangeColumnCount === 1) {
      _actualRange = actualRange.get(0, 0);
    }
    if (_actualRange.isError()) {
      return _actualRange;
    }
    let _expectedRange = expectedRange;
    if (expectedRange.isArray() && expectedRangeRowCount === 1 && expectedRangeColumnCount === 1) {
      _expectedRange = expectedRange.get(0, 0);
    }
    if (_expectedRange.isError()) {
      return _expectedRange;
    }
    if (actualRangeRowCount * actualRangeColumnCount === 1 || expectedRangeRowCount * expectedRangeColumnCount === 1) {
      if (_actualRange.isNull() || _expectedRange.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (actualRangeRowCount * actualRangeColumnCount !== expectedRangeRowCount * expectedRangeColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      actualRange,
      expectedRange,
      actualRangeRowCount * actualRangeColumnCount,
      actualRangeColumnCount,
      expectedRangeColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values, actualRangeRowCount, actualRangeColumnCount);
  }
  _getResult(actualRangeValues, expectedRangeValues, actualRangeRowCount, actualRangeColumnCount) {
    let sumxmy2 = 0;
    for (let i = 0; i < actualRangeValues.length; i++) {
      if (expectedRangeValues[i] === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      sumxmy2 += (actualRangeValues[i] - expectedRangeValues[i]) ** 2 / expectedRangeValues[i];
    }
    let df = (actualRangeRowCount - 1) * (actualRangeColumnCount - 1);
    if (actualRangeRowCount === 1) {
      df = actualRangeColumnCount - 1;
    } else if (actualRangeColumnCount === 1) {
      df = actualRangeRowCount - 1;
    }
    const result = 1 - chisquareCDF(sumxmy2, df);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/confidence-norm/index.ts
var ConfidenceNorm = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(alpha, standardDev, size) {
    const maxRowLength = Math.max(
      alpha.isArray() ? alpha.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1,
      size.isArray() ? size.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      alpha.isArray() ? alpha.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1,
      size.isArray() ? size.getColumnCount() : 1
    );
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const sizeArray = expandArrayValueObject(maxRowLength, maxColumnLength, size, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = alphaArray.mapValue((alphaObject, rowIndex, columnIndex) => {
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      const sizeObject = sizeArray.get(rowIndex, columnIndex);
      if (alphaObject.isError()) {
        return alphaObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      if (sizeObject.isError()) {
        return sizeObject;
      }
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(alphaObject, standardDevObject, sizeObject);
      if (isError) {
        return errorObject;
      }
      const [_alphaObject, _standardDevObject, _sizeObject] = variants;
      const alphaValue = +_alphaObject.getValue();
      const standardDevValue = +_standardDevObject.getValue();
      const sizeValue = Math.floor(+_sizeObject.getValue());
      if (alphaValue <= 0 || alphaValue >= 1 || standardDevValue <= 0 || sizeValue < 1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.abs(normalINV(alphaValue / 2, 0, 1) * standardDevValue / Math.sqrt(sizeValue));
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/statistical/covariance-p/index.ts
var CovarianceP = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array1, array2) {
    const array1RowCount = array1.isArray() ? array1.getRowCount() : 1;
    const array1ColumnCount = array1.isArray() ? array1.getColumnCount() : 1;
    const array2RowCount = array2.isArray() ? array2.getRowCount() : 1;
    const array2ColumnCount = array2.isArray() ? array2.getColumnCount() : 1;
    let _array1 = array1;
    if (array1.isArray() && array1RowCount === 1 && array1ColumnCount === 1) {
      _array1 = array1.get(0, 0);
    }
    if (_array1.isError()) {
      return _array1;
    }
    let _array2 = array2;
    if (array2.isArray() && array2RowCount === 1 && array2ColumnCount === 1) {
      _array2 = array2.get(0, 0);
    }
    if (_array2.isError()) {
      return _array2;
    }
    if (array1RowCount * array1ColumnCount === 1 || array2RowCount * array2ColumnCount === 1) {
      if (_array1.isNull() || _array2.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    if (array1RowCount * array1ColumnCount !== array2RowCount * array2ColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      array1,
      array2,
      array1RowCount * array1ColumnCount,
      array1ColumnCount,
      array2ColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(array1Values, array2Values) {
    if (array1Values.length === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const n = array1Values.length;
    let array1Sum = 0;
    let array2Sum = 0;
    for (let i = 0; i < n; i++) {
      array1Sum += array1Values[i];
      array2Sum += array2Values[i];
    }
    const array1Mean = array1Sum / n;
    const array2Mean = array2Sum / n;
    let numerator = 0;
    for (let i = 0; i < n; i++) {
      const array1Diff = array1Values[i] - array1Mean;
      const array2Diff = array2Values[i] - array2Mean;
      numerator += array1Diff * array2Diff;
    }
    return NumberValueObject.create(numerator / n);
  }
};

// ../packages/engine-formula/src/functions/statistical/expon-dist/index.ts
var ExponDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, lambda, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      lambda.isArray() ? lambda.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      lambda.isArray() ? lambda.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const lambdaArray = expandArrayValueObject(maxRowLength, maxColumnLength, lambda, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const lambdaObject = lambdaArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (lambdaObject.isError()) {
        return lambdaObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, lambdaObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, lambdaObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, lambdaObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _lambdaObject, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const lambdaValue = +_lambdaObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (xValue < 0 || lambdaValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = exponentialCDF(xValue, lambdaValue);
    } else {
      result = exponentialPDF(xValue, lambdaValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/f-dist-rt/index.ts
var FDistRt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, degFreedom1, degFreedom2) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getRowCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getColumnCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom1Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom1, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom2Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedom1Object = degFreedom1Array.get(rowIndex, columnIndex);
      const degFreedom2Object = degFreedom2Array.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedom1Object.isError()) {
        return degFreedom1Object;
      }
      if (degFreedom2Object.isError()) {
        return degFreedom2Object;
      }
      return this._handleSignleObject(xObject, degFreedom1Object, degFreedom2Object);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedom1Object, degFreedom2Object) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedom1Object, degFreedom2Object);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedom1Object, _degFreedom2Object] = variants;
    const xValue = +_xObject.getValue();
    const degFreedom1Value = Math.floor(+_degFreedom1Object.getValue());
    const degFreedom2Value = Math.floor(+_degFreedom2Object.getValue());
    if (xValue < 0 || degFreedom1Value < 1 || degFreedom1Value > 10 ** 10 || degFreedom2Value < 1 || degFreedom2Value > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = 1 - centralFCDF(xValue, degFreedom1Value, degFreedom2Value);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/f-inv-rt/index.ts
var FInvRt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(probability, degFreedom1, degFreedom2) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getRowCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getColumnCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom1Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom1, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom2Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const degFreedom1Object = degFreedom1Array.get(rowIndex, columnIndex);
      const degFreedom2Object = degFreedom2Array.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (degFreedom1Object.isError()) {
        return degFreedom1Object;
      }
      if (degFreedom2Object.isError()) {
        return degFreedom2Object;
      }
      return this._handleSignleObject(probabilityObject, degFreedom1Object, degFreedom2Object);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, degFreedom1Object, degFreedom2Object) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, degFreedom1Object, degFreedom2Object);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _degFreedom1Object, _degFreedom2Object] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const degFreedom1Value = Math.floor(+_degFreedom1Object.getValue());
    const degFreedom2Value = Math.floor(+_degFreedom2Object.getValue());
    if (probabilityValue < 0 || probabilityValue > 1 || degFreedom1Value < 1 || degFreedom1Value > 10 ** 10 || degFreedom2Value < 1 || degFreedom2Value > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = centralFINV(1 - probabilityValue, degFreedom1Value, degFreedom2Value);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/f-test/index.ts
var FTest = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array1, array2) {
    const {
      isError: isError_array1,
      errorObject: errorObject_array1,
      variance: variance_array1,
      ns1: ns1_array1
    } = this._getValues(array1);
    if (isError_array1) {
      return errorObject_array1;
    }
    const {
      isError: isError_array2,
      errorObject: errorObject_array2,
      variance: variance_array2,
      ns1: ns1_array2
    } = this._getValues(array2);
    if (isError_array2) {
      return errorObject_array2;
    }
    let result = 2 * (1 - centralFCDF(variance_array1 / variance_array2, ns1_array1, ns1_array2));
    if (result > 1) {
      result = 2 - result;
    }
    return NumberValueObject.create(result);
  }
  // eslint-disable-next-line
  _getValues(array) {
    let variance = 0;
    let ns1 = 0;
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    if (arrayRowCount === 1 && arrayColumnCount === 1) {
      const _array = array.isArray() ? array.get(0, 0) : array;
      if (_array.isError()) {
        return {
          isError: true,
          errorObject: _array,
          variance,
          ns1
        };
      }
      if (_array.isNull()) {
        return {
          isError: true,
          errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
          variance,
          ns1
        };
      }
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        variance,
        ns1
      };
    }
    const values = [];
    let sum2 = 0;
    for (let r = 0; r < arrayRowCount; r++) {
      for (let c = 0; c < arrayColumnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return {
            isError: true,
            errorObject: valueObject,
            variance,
            ns1
          };
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
        sum2 += +value;
      }
    }
    if (values.length <= 1) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        variance,
        ns1
      };
    }
    const mean = sum2 / values.length;
    let sumSquares = 0;
    for (let i = 0; i < values.length; i++) {
      sumSquares += (values[i] - mean) ** 2;
    }
    ns1 = values.length - 1;
    variance = sumSquares / ns1;
    if (variance === 0) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        variance,
        ns1
      };
    }
    return {
      isError: false,
      errorObject: null,
      variance,
      ns1
    };
  }
};

// ../packages/engine-formula/src/functions/statistical/gamma-dist/index.ts
var GammaDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(x, alpha, beta, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      alpha.isArray() ? alpha.getRowCount() : 1,
      beta.isArray() ? beta.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      alpha.isArray() ? alpha.getColumnCount() : 1,
      beta.isArray() ? beta.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const betaArray = expandArrayValueObject(maxRowLength, maxColumnLength, beta, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const alphaObject = alphaArray.get(rowIndex, columnIndex);
      const betaObject = betaArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (alphaObject.isError()) {
        return alphaObject;
      }
      if (betaObject.isError()) {
        return betaObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, alphaObject, betaObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, alphaObject, betaObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, alphaObject, betaObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _alphaObject, _betaObject, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const alphaValue = +_alphaObject.getValue();
    const betaValue = +_betaObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (xValue < 0 || alphaValue <= 0 || betaValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = gammaCDF(xValue, alphaValue, betaValue);
    } else {
      result = gammaPDF(xValue, alphaValue, betaValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/gamma-inv/index.ts
var GammaInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(probability, alpha, beta) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      alpha.isArray() ? alpha.getRowCount() : 1,
      beta.isArray() ? beta.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      alpha.isArray() ? alpha.getColumnCount() : 1,
      beta.isArray() ? beta.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const betaArray = expandArrayValueObject(maxRowLength, maxColumnLength, beta, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const alphaObject = alphaArray.get(rowIndex, columnIndex);
      const betaObject = betaArray.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (alphaObject.isError()) {
        return alphaObject;
      }
      if (betaObject.isError()) {
        return betaObject;
      }
      return this._handleSignleObject(probabilityObject, alphaObject, betaObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, alphaObject, betaObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, alphaObject, betaObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _alphaObject, _betaObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const alphaValue = +_alphaObject.getValue();
    const betaValue = +_betaObject.getValue();
    if (probabilityValue < 0 || probabilityValue > 1 || alphaValue <= 0 || betaValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = gammaINV(probabilityValue, alphaValue, betaValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/lognorm-inv/index.ts
var LognormInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(probability, mean, standardDev) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      mean.isArray() ? mean.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      mean.isArray() ? mean.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const meanArray = expandArrayValueObject(maxRowLength, maxColumnLength, mean, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const meanObject = meanArray.get(rowIndex, columnIndex);
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (meanObject.isError()) {
        return meanObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      return this._handleSignleObject(probabilityObject, meanObject, standardDevObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, meanObject, standardDevObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, meanObject, standardDevObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _meanObject, _standardDevObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const meanValue = +_meanObject.getValue();
    const standardDevValue = +_standardDevObject.getValue();
    if (probabilityValue <= 0 || probabilityValue >= 1 || standardDevValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = lognormalINV(probabilityValue, meanValue, standardDevValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/mode-sngl/index.ts
var ModeSngl = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const valueMap = {};
    let order = 0;
    let maxCount = 1;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (variant.isString()) {
        const _variant = variant.convertToNumberObjectValue();
        if (_variant.isError()) {
          return _variant;
        }
      }
      const rowCount = variant.isArray() ? variant.getRowCount() : 1;
      const columnCount = variant.isArray() ? variant.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const valueObject = variant.isArray() ? variant.get(r, c) : variant;
          if (valueObject.isError()) {
            return valueObject;
          }
          if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
            continue;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            continue;
          }
          if (valueMap[+value]) {
            valueMap[+value].count++;
            if (valueMap[+value].count > maxCount) {
              maxCount = valueMap[+value].count;
            }
          } else {
            valueMap[+value] = { count: 1, order: order++ };
          }
        }
      }
    }
    if (order === 0 || maxCount === 1) {
      return new ErrorValueObject("#N/A" /* NA */);
    }
    return this._getResult(valueMap, maxCount);
  }
  _getResult(valueMap, maxCount) {
    const result = Object.entries(valueMap).filter(([_, { count }]) => count === maxCount).sort((a2, b) => a2[1].order - b[1].order).map(([value]) => +value);
    return NumberValueObject.create(result[0]);
  }
};

// ../packages/engine-formula/src/functions/statistical/norm-dist/index.ts
var NormDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(x, mean, standardDev, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      mean.isArray() ? mean.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      mean.isArray() ? mean.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const meanArray = expandArrayValueObject(maxRowLength, maxColumnLength, mean, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const meanObject = meanArray.get(rowIndex, columnIndex);
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (meanObject.isError()) {
        return meanObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, meanObject, standardDevObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, meanObject, standardDevObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, meanObject, standardDevObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _meanObject, _standardDevObject, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const meanValue = +_meanObject.getValue();
    const standardDevValue = +_standardDevObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (standardDevValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = normalCDF(xValue, meanValue, standardDevValue);
    } else {
      result = normalPDF(xValue, meanValue, standardDevValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/norm-inv/index.ts
var NormInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(probability, mean, standardDev) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      mean.isArray() ? mean.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      mean.isArray() ? mean.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const meanArray = expandArrayValueObject(maxRowLength, maxColumnLength, mean, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const meanObject = meanArray.get(rowIndex, columnIndex);
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (meanObject.isError()) {
        return meanObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      return this._handleSignleObject(probabilityObject, meanObject, standardDevObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, meanObject, standardDevObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, meanObject, standardDevObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _meanObject, _standardDevObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const meanValue = +_meanObject.getValue();
    const standardDevValue = +_standardDevObject.getValue();
    if (probabilityValue <= 0 || probabilityValue >= 1 || standardDevValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = normalINV(probabilityValue, meanValue, standardDevValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/norm-s-inv/index.ts
var NormSInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(probability) {
    if (probability.isArray()) {
      const resultArray = probability.mapValue((probabilityObject) => this._handleSignleObject(probabilityObject));
      if (probability.getRowCount() === 1 && probability.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSignleObject(probability);
  }
  _handleSignleObject(probabilityObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    if (probabilityValue <= 0 || probabilityValue >= 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = normalINV(probabilityValue, 0, 1);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/percentile-inc/index.ts
var PercentileInc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, k) {
    const arrayValues = this._getValues(array);
    if (k.isArray()) {
      const resultArray = k.mapValue((kObject) => this._handleSingleObject(arrayValues, kObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(arrayValues, k);
  }
  _handleSingleObject(array, k) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(k);
    if (isError) {
      return errorObject;
    }
    const [kObject] = variants;
    const kValue = +kObject.getValue();
    const n = array.length;
    if (kValue < 0 || kValue > 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const kValueIndex = kValue * (n - 1);
    const integerPart = Math.floor(kValueIndex);
    const fractionPart = kValueIndex - integerPart;
    if (fractionPart === 0) {
      return NumberValueObject.create(array[integerPart]);
    }
    const result = array[integerPart] + fractionPart * (array[integerPart + 1] - array[integerPart]);
    return NumberValueObject.create(result);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/percentrank-inc/index.ts
var PercentrankInc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, x, significance) {
    const arrayValues = this._getValues(array);
    let _significance = significance != null ? significance : NumberValueObject.create(3);
    if (_significance.isNull()) {
      _significance = NumberValueObject.create(3);
    }
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      _significance.isArray() ? _significance.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      _significance.isArray() ? _significance.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, _significance, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const significanceObject = significanceArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      return this._handleSingleObject(arrayValues, xObject, significanceObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(array, x, significance) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(x, significance);
    if (isError) {
      return errorObject;
    }
    const [xObject, significanceObject] = variants;
    const xValue = +xObject.getValue();
    const significanceValue = Math.floor(+significanceObject.getValue());
    const n = array.length;
    if (n === 0 || xValue < array[0] || xValue > array[n - 1]) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (n === 1) {
      if (xValue === array[0]) {
        return NumberValueObject.create(1);
      } else {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
    }
    let result = 0;
    let match = false;
    let i = 0;
    while (!match && i < n) {
      if (xValue === array[i]) {
        result = i / (n - 1);
        match = true;
      } else if (xValue > array[i] && i + 1 < n && xValue < array[i + 1]) {
        result = (i + (xValue - array[i]) / (array[i + 1] - array[i])) / (n - 1);
        match = true;
      }
      i++;
    }
    if (!match) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (significanceValue < 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    result = floor2(result, significanceValue);
    return NumberValueObject.create(result);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/poisson-dist/index.ts
var PoissonDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, mean, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      mean.isArray() ? mean.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      mean.isArray() ? mean.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const meanArray = expandArrayValueObject(maxRowLength, maxColumnLength, mean, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const meanObject = meanArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (meanObject.isError()) {
        return meanObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, meanObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, meanObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, meanObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _meanObject, _cumulativeObject] = variants;
    const xValue = Math.floor(+_xObject.getValue());
    const meanValue = +_meanObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (xValue < 0 || meanValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = poissonCDF(xValue, meanValue);
    } else {
      result = poissonPDF(xValue, meanValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/quartile-inc/index.ts
var QuartileInc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, quart) {
    const arrayValues = this._getValues(array);
    if (quart.isArray()) {
      const resultArray = quart.mapValue((quartObject) => this._handleSingleObject(arrayValues, quartObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(arrayValues, quart);
  }
  _handleSingleObject(array, quart) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(quart);
    if (isError) {
      return errorObject;
    }
    const [quartObject] = variants;
    const quartValue = Math.floor(+quartObject.getValue());
    if (quartValue < 0 || quartValue > 4) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const k = quartValue / 4;
    const n = array.length;
    const kIndex = k * (n - 1);
    const integerPart = Math.floor(kIndex);
    const fractionPart = kIndex - integerPart;
    if (fractionPart === 0) {
      return NumberValueObject.create(array[integerPart]);
    }
    const result = array[integerPart] + fractionPart * (array[integerPart + 1] - array[integerPart]);
    return NumberValueObject.create(result);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/stdev-p/index.ts
var StdevP = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.std();
  }
};

// ../packages/engine-formula/src/functions/statistical/stdev-s/index.ts
var StdevS = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.std(1);
  }
};

// ../packages/engine-formula/src/functions/statistical/t-inv-2t/index.ts
var TInv2t = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(probability, degFreedom) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      return this._handleSignleObject(probabilityObject, degFreedomObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, degFreedomObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, degFreedomObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _degFreedomObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    if (probabilityValue <= 0 || probabilityValue > 1 || degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.abs(studentTINV(probabilityValue / 2, degFreedomValue));
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/t-test/index.ts
var TTest = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  // eslint-disable-next-line
  calculate(array1, array2, tails, type2) {
    const { isError: isError_sp, errorObject: errorObject_sp, array1Values: array1Values_sp, array2Values: array2Values_sp } = this._handleArray1AndArray2(array1, array2);
    const array1Values = this._getArrayValues(array1);
    const array2Values = this._getArrayValues(array2);
    const maxRowLength = Math.max(
      tails.isArray() ? tails.getRowCount() : 1,
      type2.isArray() ? type2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      tails.isArray() ? tails.getColumnCount() : 1,
      type2.isArray() ? type2.getColumnCount() : 1
    );
    const tailsArray = expandArrayValueObject(maxRowLength, maxColumnLength, tails, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, type2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = tailsArray.mapValue((tailsObject, rowIndex, columnIndex) => {
      const typeObject = typeArray.get(rowIndex, columnIndex);
      if (array1.isError()) {
        return array1;
      }
      if (array2.isError()) {
        return array2;
      }
      if (tailsObject.isError()) {
        return tailsObject;
      }
      if (typeObject.isError()) {
        return typeObject;
      }
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(tailsObject, typeObject);
      if (isError) {
        return errorObject;
      }
      const [_tailsObject, _typeObject] = variants;
      const tailsValue = Math.floor(+_tailsObject.getValue());
      const typeValue = Math.floor(+_typeObject.getValue());
      if (![1, 2].includes(tailsValue) || ![1, 2, 3].includes(typeValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (typeValue === 1 && isError_sp) {
        return errorObject_sp;
      }
      if (typeValue !== 1 && array1Values instanceof ErrorValueObject) {
        return array1Values;
      }
      if (typeValue !== 1 && array2Values instanceof ErrorValueObject) {
        return array2Values;
      }
      return this._handleSignleObject(
        typeValue === 1 ? array1Values_sp : array1Values,
        typeValue === 1 ? array2Values_sp : array2Values,
        tailsValue,
        typeValue
      );
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(array1Values, array2Values, tails, type2) {
    if (array1Values.length < 2 || array2Values.length < 2) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const { isError, errorObject, x, degFreedom } = this._getTDistParamByArrayValues(array1Values, array2Values, type2);
    if (isError) {
      return errorObject;
    }
    let result = studentTCDF(-x, degFreedom);
    if (tails === 2) {
      result *= 2;
    }
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
  _getArrayValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const arrayValues = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull()) {
          if (rowCount * columnCount === 1) {
            return ErrorValueObject.create("#VALUE!" /* VALUE */);
          }
          continue;
        }
        if (valueObject.isBoolean() || valueObject.isString()) {
          continue;
        }
        arrayValues.push(+valueObject.getValue());
      }
    }
    return arrayValues;
  }
  // eslint-disable-next-line
  _handleArray1AndArray2(array1, array2) {
    const array1RowCount = array1.isArray() ? array1.getRowCount() : 1;
    const array1ColumnCount = array1.isArray() ? array1.getColumnCount() : 1;
    const array2RowCount = array2.isArray() ? array2.getRowCount() : 1;
    const array2ColumnCount = array2.isArray() ? array2.getColumnCount() : 1;
    let _array1 = array1;
    if (array1.isArray() && array1RowCount === 1 && array1ColumnCount === 1) {
      _array1 = array1.get(0, 0);
    }
    if (_array1.isError()) {
      return {
        isError: true,
        errorObject: _array1,
        array1Values: [],
        array2Values: []
      };
    }
    let _array2 = array2;
    if (array2.isArray() && array2RowCount === 1 && array2ColumnCount === 1) {
      _array2 = array2.get(0, 0);
    }
    if (_array2.isError()) {
      return {
        isError: true,
        errorObject: _array2,
        array1Values: [],
        array2Values: []
      };
    }
    if (array1RowCount * array1ColumnCount === 1 || array2RowCount * array2ColumnCount === 1) {
      if (_array1.isNull() || _array2.isNull()) {
        return {
          isError: true,
          errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
          array1Values: [],
          array2Values: []
        };
      }
    }
    if (array1RowCount * array1ColumnCount !== array2RowCount * array2ColumnCount) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#N/A" /* NA */),
        array1Values: [],
        array2Values: []
      };
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      array1,
      array2,
      array1RowCount * array1ColumnCount,
      array1ColumnCount,
      array2ColumnCount
    );
    if (isError) {
      return {
        isError: true,
        errorObject,
        array1Values: [],
        array2Values: []
      };
    }
    if (noCalculate || array1Values.length < 2) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        array1Values: [],
        array2Values: []
      };
    }
    return {
      isError: false,
      errorObject: null,
      array1Values,
      array2Values
    };
  }
  _getTDistParamByArrayValues(array1Values, array2Values, type2) {
    if (type2 === 1) {
      return this._getTDistParamByType1(array1Values, array2Values);
    } else if (type2 === 2) {
      return this._getTDistParamByType2(array1Values, array2Values);
    } else {
      return this._getTDistParamByType3(array1Values, array2Values);
    }
  }
  _getTDistParamByType1(array1Values, array2Values) {
    const n = array1Values.length;
    let sum1 = 0;
    let sum2 = 0;
    let sumSquareDiff = 0;
    for (let i = 0; i < n; i++) {
      sum1 += array1Values[i];
      sum2 += array2Values[i];
      sumSquareDiff += (array1Values[i] - array2Values[i]) ** 2;
    }
    const sumDiff = sum1 - sum2;
    const den = n * sumSquareDiff - sumDiff ** 2;
    const degFreedom = n - 1;
    if (den === 0) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        x: 0,
        degFreedom
      };
    }
    const x = Math.abs(sumDiff) * Math.sqrt(degFreedom / den);
    return {
      isError: false,
      errorObject: null,
      x,
      degFreedom
    };
  }
  _getTDistParamByType2(array1Values, array2Values) {
    const array1Length = array1Values.length;
    const array2Length = array2Values.length;
    let sum1 = 0;
    let sumSquare1 = 0;
    for (let i = 0; i < array1Length; i++) {
      sum1 += array1Values[i];
      sumSquare1 += array1Values[i] ** 2;
    }
    let sum2 = 0;
    let sumSquare2 = 0;
    for (let i = 0; i < array2Length; i++) {
      sum2 += array2Values[i];
      sumSquare2 += array2Values[i] ** 2;
    }
    const temp1 = sumSquare1 - sum1 ** 2 / array1Length;
    const temp2 = sumSquare2 - sum2 ** 2 / array2Length;
    const den = Math.sqrt(temp1 + temp2);
    if (den === 0) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        x: 0,
        degFreedom: 0
      };
    }
    const degFreedom = array1Length - 1 + array2Length - 1;
    const temp3 = Math.sqrt(array1Length * array2Length * degFreedom / (array1Length + array2Length));
    const x = Math.abs(sum1 / array1Length - sum2 / array2Length) / den * temp3;
    return {
      isError: false,
      errorObject: null,
      x,
      degFreedom
    };
  }
  _getTDistParamByType3(array1Values, array2Values) {
    const array1Length = array1Values.length;
    const array2Length = array2Values.length;
    let sum1 = 0;
    let sumSquare1 = 0;
    for (let i = 0; i < array1Length; i++) {
      sum1 += array1Values[i];
      sumSquare1 += array1Values[i] ** 2;
    }
    let sum2 = 0;
    let sumSquare2 = 0;
    for (let i = 0; i < array2Length; i++) {
      sum2 += array2Values[i];
      sumSquare2 += array2Values[i] ** 2;
    }
    const temp1 = (sumSquare1 - sum1 ** 2 / array1Length) / (array1Length * (array1Length - 1));
    const temp2 = (sumSquare2 - sum2 ** 2 / array2Length) / (array2Length * (array2Length - 1));
    if (temp1 + temp2 === 0) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        x: 0,
        degFreedom: 0
      };
    }
    const temp3 = temp1 / (temp1 + temp2);
    const x = Math.abs(sum1 / array1Length - sum2 / array2Length) / Math.sqrt(temp1 + temp2);
    const degFreedom = 1 / (temp3 ** 2 / (array1Length - 1) + (1 - temp3) ** 2 / (array2Length - 1));
    return {
      isError: false,
      errorObject: null,
      x,
      degFreedom
    };
  }
};

// ../packages/engine-formula/src/functions/statistical/var-p/index.ts
var VarP = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.var();
  }
};

// ../packages/engine-formula/src/functions/statistical/var-s/index.ts
var VarS = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.var(1);
  }
};

// ../packages/engine-formula/src/functions/statistical/weibull-dist/index.ts
var WeibullDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(x, alpha, beta, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      alpha.isArray() ? alpha.getRowCount() : 1,
      beta.isArray() ? beta.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      alpha.isArray() ? alpha.getColumnCount() : 1,
      beta.isArray() ? beta.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const betaArray = expandArrayValueObject(maxRowLength, maxColumnLength, beta, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const alphaObject = alphaArray.get(rowIndex, columnIndex);
      const betaObject = betaArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (alphaObject.isError()) {
        return alphaObject;
      }
      if (betaObject.isError()) {
        return betaObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, alphaObject, betaObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, alphaObject, betaObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, alphaObject, betaObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _alphaObject, _betaObject, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const alphaValue = +_alphaObject.getValue();
    const betaValue = +_betaObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (xValue < 0 || alphaValue <= 0 || betaValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const exp2 = Math.exp(-((xValue / betaValue) ** alphaValue));
    let result;
    if (cumulativeValue) {
      result = 1 - exp2;
    } else {
      result = alphaValue / betaValue ** alphaValue * xValue ** (alphaValue - 1) * exp2;
    }
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/z-test/index.ts
var ZTest = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, x, sigma) {
    const arrayValues = this._getArrayValues(array);
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      (sigma == null ? void 0 : sigma.isArray()) ? sigma.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      (sigma == null ? void 0 : sigma.isArray()) ? sigma.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const sigmaArray = sigma ? expandArrayValueObject(maxRowLength, maxColumnLength, sigma, ErrorValueObject.create("#N/A" /* NA */)) : void 0;
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      if (arrayValues instanceof ErrorValueObject) {
        return arrayValues;
      }
      if (xObject.isError()) {
        return xObject;
      }
      const sigmaObject = sigma ? sigmaArray.get(rowIndex, columnIndex) : void 0;
      if (sigmaObject == null ? void 0 : sigmaObject.isError()) {
        return sigmaObject;
      }
      if (arrayValues.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (arrayValues.length === 1) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return this._handleSignleObject(arrayValues, xObject, sigmaObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(arrayValues, x, sigma) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(x);
    if (isError) {
      return errorObject;
    }
    const [xObject] = variants;
    const xValue = +xObject.getValue();
    const n = arrayValues.length;
    let sum2 = 0;
    let sumSquare = 0;
    for (let i = 0; i < n; i++) {
      sum2 += arrayValues[i];
      sumSquare += arrayValues[i] ** 2;
    }
    let sigmaValue = 0;
    if (sigma !== void 0) {
      const { isError: _isError, errorObject: _errorObject, variants: _variants } = checkVariantsErrorIsStringToNumber(sigma);
      if (_isError) {
        return _errorObject;
      }
      const [sigmaObject] = _variants;
      sigmaValue = +sigmaObject.getValue();
    } else {
      const mean = sum2 / n;
      sigmaValue = Math.sqrt((sumSquare - 2 * mean * sum2 + n * mean ** 2) / (n - 1));
    }
    if (sigmaValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const z = (sum2 / n - xValue) / (sigmaValue / Math.sqrt(n));
    const result = 1 - normalCDF(z, 0, 1);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
  _getArrayValues(array) {
    const values = [];
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    for (let r = 0; r < arrayRowCount; r++) {
      for (let c = 0; c < arrayColumnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    return values;
  }
};

// ../packages/engine-formula/src/functions/compatibility/betadist/index.ts
var Betadist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
  }
  calculate(x, alpha, beta, A, B) {
    let _A = A != null ? A : NumberValueObject.create(0);
    let _B = B != null ? B : NumberValueObject.create(1);
    if (_A.isNull()) {
      _A = NumberValueObject.create(0);
    }
    if (_B.isNull()) {
      _B = NumberValueObject.create(1);
    }
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      alpha.isArray() ? alpha.getRowCount() : 1,
      beta.isArray() ? beta.getRowCount() : 1,
      _A.isArray() ? _A.getRowCount() : 1,
      _B.isArray() ? _B.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      alpha.isArray() ? alpha.getColumnCount() : 1,
      beta.isArray() ? beta.getColumnCount() : 1,
      _A.isArray() ? _A.getColumnCount() : 1,
      _B.isArray() ? _B.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const betaArray = expandArrayValueObject(maxRowLength, maxColumnLength, beta, ErrorValueObject.create("#N/A" /* NA */));
    const AArray = expandArrayValueObject(maxRowLength, maxColumnLength, _A, ErrorValueObject.create("#N/A" /* NA */));
    const BArray = expandArrayValueObject(maxRowLength, maxColumnLength, _B, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const alphaObject = alphaArray.get(rowIndex, columnIndex);
      const betaObject = betaArray.get(rowIndex, columnIndex);
      const AObject = AArray.get(rowIndex, columnIndex);
      const BObject = BArray.get(rowIndex, columnIndex);
      return this._handleSignleObject(xObject, alphaObject, betaObject, AObject, BObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, alphaObject, betaObject, AObject, BObject) {
    if (xObject.isError()) {
      return xObject;
    }
    if (alphaObject.isError()) {
      return alphaObject;
    }
    if (betaObject.isError()) {
      return betaObject;
    }
    if (AObject.isError()) {
      return AObject;
    }
    if (BObject.isError()) {
      return BObject;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, alphaObject, betaObject, AObject, BObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _alphaObject, _betaObject, _AObject, _BObject] = variants;
    const xValue = +_xObject.getValue();
    const alphaValue = +_alphaObject.getValue();
    const betaValue = +_betaObject.getValue();
    const AValue = +_AObject.getValue();
    const BValue = +_BObject.getValue();
    if (alphaValue <= 0 || betaValue <= 0 || xValue < AValue || xValue > BValue || AValue === BValue) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = betaCDF((xValue - AValue) / (BValue - AValue), alphaValue, betaValue);
    ;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/compatibility/hypgeomdist/index.ts
var Hypgeomdist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(sampleS, numberSample, populationS, numberPop) {
    const maxRowLength = Math.max(
      sampleS.isArray() ? sampleS.getRowCount() : 1,
      numberSample.isArray() ? numberSample.getRowCount() : 1,
      populationS.isArray() ? populationS.getRowCount() : 1,
      numberPop.isArray() ? numberPop.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      sampleS.isArray() ? sampleS.getColumnCount() : 1,
      numberSample.isArray() ? numberSample.getColumnCount() : 1,
      populationS.isArray() ? populationS.getColumnCount() : 1,
      numberPop.isArray() ? numberPop.getColumnCount() : 1
    );
    const sampleSArray = expandArrayValueObject(maxRowLength, maxColumnLength, sampleS, ErrorValueObject.create("#N/A" /* NA */));
    const numberSampleArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberSample, ErrorValueObject.create("#N/A" /* NA */));
    const populationSArray = expandArrayValueObject(maxRowLength, maxColumnLength, populationS, ErrorValueObject.create("#N/A" /* NA */));
    const numberPopArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberPop, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = sampleSArray.mapValue((sampleSObject, rowIndex, columnIndex) => {
      const numberSampleObject = numberSampleArray.get(rowIndex, columnIndex);
      const populationSObject = populationSArray.get(rowIndex, columnIndex);
      const numberPopObject = numberPopArray.get(rowIndex, columnIndex);
      if (sampleSObject.isError()) {
        return sampleSObject;
      }
      if (numberSampleObject.isError()) {
        return numberSampleObject;
      }
      if (populationSObject.isError()) {
        return populationSObject;
      }
      if (numberPopObject.isError()) {
        return numberPopObject;
      }
      return this._handleSignleObject(sampleSObject, numberSampleObject, populationSObject, numberPopObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(sampleSObject, numberSampleObject, populationSObject, numberPopObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(sampleSObject, numberSampleObject, populationSObject, numberPopObject);
    if (isError) {
      return errorObject;
    }
    const [_sampleSObject, _numberSampleObject, _populationSObject, _numberPopObject] = variants;
    const sampleSValue = Math.floor(+_sampleSObject.getValue());
    const numberSampleValue = Math.floor(+_numberSampleObject.getValue());
    const populationSValue = Math.floor(+_populationSObject.getValue());
    const numberPopValue = Math.floor(+_numberPopObject.getValue());
    if (sampleSValue < 0 || sampleSValue > numberSampleValue || sampleSValue > populationSValue || sampleSValue < numberSampleValue - numberPopValue + populationSValue || numberSampleValue <= 0 || numberSampleValue > numberPopValue || populationSValue <= 0 || populationSValue > numberPopValue || numberPopValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = hypergeometricPDF(sampleSValue, numberSampleValue, populationSValue, numberPopValue);
    if (Number.isNaN(result)) {
      result = 0;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/compatibility/lognormdist/index.ts
var Lognormdist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, mean, standardDev) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      mean.isArray() ? mean.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      mean.isArray() ? mean.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const meanArray = expandArrayValueObject(maxRowLength, maxColumnLength, mean, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const meanObject = meanArray.get(rowIndex, columnIndex);
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (meanObject.isError()) {
        return meanObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      return this._handleSignleObject(xObject, meanObject, standardDevObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, meanObject, standardDevObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, meanObject, standardDevObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _meanObject, _standardDevObject] = variants;
    const xValue = +_xObject.getValue();
    const meanValue = +_meanObject.getValue();
    const standardDevValue = +_standardDevObject.getValue();
    if (xValue <= 0 || standardDevValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = lognormalCDF(xValue, meanValue, standardDevValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/compatibility/negbinomdist/index.ts
var Negbinomdist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(numberF, numberS, probabilityS) {
    const maxRowLength = Math.max(
      numberF.isArray() ? numberF.getRowCount() : 1,
      numberS.isArray() ? numberS.getRowCount() : 1,
      probabilityS.isArray() ? probabilityS.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      numberF.isArray() ? numberF.getColumnCount() : 1,
      numberS.isArray() ? numberS.getColumnCount() : 1,
      probabilityS.isArray() ? probabilityS.getColumnCount() : 1
    );
    const numberFArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberF, ErrorValueObject.create("#N/A" /* NA */));
    const numberSArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberS, ErrorValueObject.create("#N/A" /* NA */));
    const probabilitySArray = expandArrayValueObject(maxRowLength, maxColumnLength, probabilityS, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberFArray.mapValue((numberFObject, rowIndex, columnIndex) => {
      const numberSObject = numberSArray.get(rowIndex, columnIndex);
      const probabilitySObject = probabilitySArray.get(rowIndex, columnIndex);
      if (numberFObject.isError()) {
        return numberFObject;
      }
      if (numberSObject.isError()) {
        return numberSObject;
      }
      if (probabilitySObject.isError()) {
        return probabilitySObject;
      }
      return this._handleSignleObject(numberFObject, numberSObject, probabilitySObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(numberFObject, numberSObject, probabilitySObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numberFObject, numberSObject, probabilitySObject);
    if (isError) {
      return errorObject;
    }
    const [_numberFObject, _numberSObject, _probabilitySObject] = variants;
    const numberFValue = Math.floor(+_numberFObject.getValue());
    const numberSValue = Math.floor(+_numberSObject.getValue());
    const probabilitySValue = +_probabilitySObject.getValue();
    if (numberFValue < 0 || numberSValue < 1 || probabilitySValue <= 0 || probabilitySValue >= 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = negbinomialPDF(numberFValue, numberSValue, probabilitySValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/compatibility/normsdist/index.ts
var Normsdist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(z) {
    if (z.isArray()) {
      const resultArray = z.mapValue((zObject) => this._handleSignleObject(zObject));
      if (z.getRowCount() === 1 && z.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSignleObject(z);
  }
  _handleSignleObject(zObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(zObject);
    if (isError) {
      return errorObject;
    }
    const [_zObject] = variants;
    const zValue = +_zObject.getValue();
    const result = normalCDF(zValue, 0, 1);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/compatibility/rank/index.ts
var Rank = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(number, ref, order) {
    let _number = number;
    if (_number.isReferenceObject()) {
      _number = _number.toArrayValueObject();
    }
    const { refHasError, refErrorObject, refNumbers } = this._checkRefReferenceObject(ref);
    let _order = order != null ? order : NumberValueObject.create(0);
    if (_order.isReferenceObject()) {
      _order = _order.toArrayValueObject();
    }
    const maxRowLength = Math.max(
      _number.isArray() ? _number.getRowCount() : 1,
      _order.isArray() ? _order.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _number.isArray() ? _number.getColumnCount() : 1,
      _order.isArray() ? _order.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, _number, ErrorValueObject.create("#N/A" /* NA */));
    const orderArray = expandArrayValueObject(maxRowLength, maxColumnLength, _order, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      const orderObject = orderArray.get(rowIndex, columnIndex);
      if (!number.isReferenceObject() && number.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (refHasError) {
        return refErrorObject;
      }
      if (orderObject.isError()) {
        return orderObject;
      }
      const numberValue = +numberObject.getValue();
      const orderValue = +orderObject.getValue();
      if (Number.isNaN(numberValue) || Number.isNaN(orderValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const refOrderNumbers = refNumbers.sort((a2, b) => !orderValue ? b - a2 : a2 - b);
      const result = refOrderNumbers.indexOf(numberValue);
      if (result === -1) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return NumberValueObject.create(result + 1);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _checkRefReferenceObject(ref) {
    let refHasError = false;
    let refErrorObject = ErrorValueObject.create("#N/A" /* NA */);
    const refNumbers = [];
    if (!ref.isReferenceObject()) {
      return {
        refHasError: true,
        refErrorObject,
        refNumbers
      };
    }
    const _ref = ref.toArrayValueObject();
    _ref.iterator((refObject) => {
      const _refObject = refObject;
      if (_refObject.isError()) {
        refHasError = true;
        refErrorObject = _refObject;
        return false;
      }
      if (_refObject.isNull() || _refObject.isBoolean()) {
        return true;
      }
      const refValue = +_refObject.getValue();
      if (Number.isNaN(refValue)) {
        return true;
      }
      refNumbers.push(refValue);
    });
    return {
      refHasError,
      refErrorObject,
      refNumbers
    };
  }
};

// ../packages/engine-formula/src/functions/compatibility/tdist/index.ts
var Tdist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, degFreedom, tails) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1,
      tails.isArray() ? tails.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1,
      tails.isArray() ? tails.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const tailsArray = expandArrayValueObject(maxRowLength, maxColumnLength, tails, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      const tailsObject = tailsArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      if (tailsObject.isError()) {
        return tailsObject;
      }
      return this._handleSignleObject(xObject, degFreedomObject, tailsObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedomObject, tailsObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedomObject, tailsObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedomObject, _tailsObject] = variants;
    const xValue = +_xObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    const tailsValue = Math.floor(+_tailsObject.getValue());
    if (xValue < 0 || degFreedomValue < 1 || degFreedomValue > 10 ** 10 || tailsValue < 1 || tailsValue > 2) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = studentTCDF(-xValue, degFreedomValue);
    if (tailsValue === 2) {
      result *= 2;
    }
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/compatibility/function-map.ts
var functionCompatibility = [
  [Betadist, "BETADIST" /* BETADIST */],
  [BetaInv, "BETAINV" /* BETAINV */],
  [BinomDist, "BINOMDIST" /* BINOMDIST */],
  [ChisqDistRt, "CHIDIST" /* CHIDIST */],
  [ChisqInvRt, "CHIINV" /* CHIINV */],
  [ChisqTest, "CHITEST" /* CHITEST */],
  [ConfidenceNorm, "CONFIDENCE" /* CONFIDENCE */],
  [CovarianceP, "COVAR" /* COVAR */],
  [BinomInv, "CRITBINOM" /* CRITBINOM */],
  [ExponDist, "EXPONDIST" /* EXPONDIST */],
  [FDistRt, "FDIST" /* FDIST */],
  [FInvRt, "FINV" /* FINV */],
  [FTest, "FTEST" /* FTEST */],
  [GammaDist, "GAMMADIST" /* GAMMADIST */],
  [GammaInv, "GAMMAINV" /* GAMMAINV */],
  [Hypgeomdist, "HYPGEOMDIST" /* HYPGEOMDIST */],
  [Lognormdist, "LOGNORMDIST" /* LOGNORMDIST */],
  [LognormInv, "LOGINV" /* LOGINV */],
  [ModeSngl, "MODE" /* MODE */],
  [Negbinomdist, "NEGBINOMDIST" /* NEGBINOMDIST */],
  [NormDist, "NORMDIST" /* NORMDIST */],
  [NormInv, "NORMINV" /* NORMINV */],
  [Normsdist, "NORMSDIST" /* NORMSDIST */],
  [NormSInv, "NORMSINV" /* NORMSINV */],
  [PercentileInc, "PERCENTILE" /* PERCENTILE */],
  [PercentrankInc, "PERCENTRANK" /* PERCENTRANK */],
  [PoissonDist, "POISSON" /* POISSON */],
  [QuartileInc, "QUARTILE" /* QUARTILE */],
  [Rank, "RANK" /* RANK */],
  [StdevS, "STDEV" /* STDEV */],
  [StdevP, "STDEVP" /* STDEVP */],
  [Tdist, "TDIST" /* TDIST */],
  [TInv2t, "TINV" /* TINV */],
  [TTest, "TTEST" /* TTEST */],
  [VarS, "VAR" /* VAR */],
  [VarP, "VARP" /* VARP */],
  [WeibullDist, "WEIBULL" /* WEIBULL */],
  [ZTest, "ZTEST" /* ZTEST */]
];

// ../packages/engine-formula/src/functions/cube/function-map.ts
var functionCube = [];

// ../packages/engine-formula/src/basics/database.ts
function checkDatabase(database) {
  const databaseValues = [];
  if (database.isError()) {
    return {
      isError: true,
      errorObject: database,
      databaseValues
    };
  }
  const rowCount = database.isArray() ? database.getRowCount() : 1;
  const columnCount = database.isArray() ? database.getColumnCount() : 1;
  if (rowCount < 2) {
    return {
      isError: true,
      errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
      databaseValues
    };
  }
  for (let r = 0; r < rowCount; r++) {
    const row = [];
    for (let c = 0; c < columnCount; c++) {
      const valueObject = database.get(r, c);
      if (valueObject.isNull()) {
        row.push(null);
        continue;
      }
      let value = `${valueObject.getValue()}`;
      if (valueObject.isBoolean()) {
        value = value.toLocaleUpperCase();
      }
      if (valueObject.isNumber() || isRealNum(value)) {
        row.push(+value);
        continue;
      }
      row.push(value);
    }
    databaseValues.push(row);
  }
  return {
    isError: false,
    errorObject: null,
    databaseValues
  };
}
function checkField(field, database) {
  let fieldIndex = -1;
  if (field.isError()) {
    return {
      isError: true,
      errorObject: field,
      fieldIndex
    };
  }
  const rowCount = field.isArray() ? field.getRowCount() : 1;
  const columnCount = field.isArray() ? field.getColumnCount() : 1;
  if (rowCount > 1 || columnCount > 1) {
    return {
      isError: true,
      errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
      fieldIndex
    };
  }
  const fieldObject = field.isArray() ? field.get(0, 0) : field;
  let fieldValue = `${fieldObject.getValue()}`;
  if (fieldObject.isNull()) {
    fieldValue = 0;
  } else if (fieldObject.isBoolean()) {
    fieldValue = fieldObject.getValue() ? 1 : 0;
  } else if (fieldObject.isNumber() || isRealNum(fieldValue)) {
    fieldValue = Math.floor(+fieldValue);
  }
  if (typeof fieldValue === "number") {
    if (fieldValue < 1 || fieldValue > database[0].length) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
        fieldIndex
      };
    }
    fieldIndex = fieldValue - 1;
  } else {
    fieldIndex = database[0].findIndex((value) => {
      if (value === null) {
        return false;
      }
      return `${value}`.toLocaleLowerCase() === fieldValue.toLocaleLowerCase();
    });
    if (fieldIndex === -1) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
        fieldIndex
      };
    }
  }
  return {
    isError: false,
    errorObject: null,
    fieldIndex
  };
}
function checkCriteria(criteria) {
  const criteriaValues = [];
  if (criteria.isError()) {
    return {
      isError: true,
      errorObject: criteria,
      criteriaValues
    };
  }
  const rowCount = criteria.isArray() ? criteria.getRowCount() : 1;
  const columnCount = criteria.isArray() ? criteria.getColumnCount() : 1;
  if (rowCount < 2) {
    return {
      isError: true,
      errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
      criteriaValues
    };
  }
  for (let r = 0; r < rowCount; r++) {
    const row = [];
    for (let c = 0; c < columnCount; c++) {
      const valueObject = criteria.get(r, c);
      if (valueObject.isNull()) {
        row.push(null);
        continue;
      }
      const value = `${valueObject.getValue()}`;
      if (valueObject.isBoolean()) {
        row.push(valueObject.getValue() ? 1 : 0);
        continue;
      }
      if (valueObject.isNumber() || isRealNum(value)) {
        row.push(+value);
        continue;
      }
      row.push(value);
    }
    criteriaValues.push(row);
  }
  return {
    isError: false,
    errorObject: null,
    criteriaValues
  };
}
function isCriteriaMatch(criteria, database, databaseRowIndex) {
  const rowCount = criteria.length;
  const columnCount = criteria[0].length;
  const criteriaTitleIndexCache = {};
  let isMatch = false;
  for (let r = 1; r < rowCount; r++) {
    let isRowMatch = true;
    for (let c = 0; c < columnCount; c++) {
      const criteriaValue = criteria[r][c];
      if (criteriaValue === null) {
        continue;
      }
      let criteriaTitleIndex = criteriaTitleIndexCache[c];
      if (criteriaTitleIndex === void 0) {
        const criteriaTitleValue = criteria[0][c];
        criteriaTitleIndex = database[0].findIndex((value) => {
          if (value === null || criteriaTitleValue === null) {
            return false;
          }
          return `${value}`.toLocaleLowerCase() === `${criteriaTitleValue}`.toLocaleLowerCase();
        });
        criteriaTitleIndexCache[c] = criteriaTitleIndex;
      }
      if (criteriaTitleIndex === -1 && (typeof criteriaValue === "string" || criteriaValue === 0)) {
        isRowMatch = false;
        break;
      } else if (criteriaTitleIndex > -1) {
        const databaseValue = database[databaseRowIndex][criteriaTitleIndex];
        if (databaseValue === null) {
          isRowMatch = false;
          break;
        }
        const [compareToken2, criteriaObject] = findCompareToken(`${criteriaValue}`);
        const compareObject = ValueObjectFactory.create(`${databaseValue}`).compare(criteriaObject, compareToken2);
        const compareValue = compareObject.getValue();
        if (!compareValue) {
          isRowMatch = false;
          break;
        }
      }
    }
    if (isRowMatch) {
      isMatch = true;
      break;
    }
  }
  return isMatch;
}

// ../packages/engine-formula/src/functions/database/daverage/index.ts
var Daverage = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let sum2 = 0;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        sum2 += value;
        count++;
      }
    }
    if (count === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return NumberValueObject.create(sum2 / count);
  }
};

// ../packages/engine-formula/src/functions/database/dcount/index.ts
var Dcount = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        count++;
      }
    }
    return NumberValueObject.create(count);
  }
};

// ../packages/engine-formula/src/functions/database/dcounta/index.ts
var Dcounta = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (value === null || value === void 0) {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        count++;
      }
    }
    return NumberValueObject.create(count);
  }
};

// ../packages/engine-formula/src/functions/database/dget/index.ts
var Dget = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let count = 0;
    let resultRowIndex = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (value === null || value === void 0) {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        count++;
        resultRowIndex = r;
      }
    }
    if (count === 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (count > 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return database.get(resultRowIndex, fieldIndex);
  }
};

// ../packages/engine-formula/src/functions/database/dmax/index.ts
var Dmax = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let result = -Infinity;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        result = Math.max(result, value);
        count++;
      }
    }
    if (count === 0) {
      return NumberValueObject.create(0);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/dmin/index.ts
var Dmin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let result = Infinity;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        result = Math.min(result, value);
        count++;
      }
    }
    if (count === 0) {
      return NumberValueObject.create(0);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/dproduct/index.ts
var Dproduct = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let result = 1;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        result *= value;
        count++;
      }
    }
    if (count === 0) {
      return NumberValueObject.create(0);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/dstdev/index.ts
var Dstdev = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    const values = [];
    let sum2 = 0;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        values.push(value);
        sum2 += value;
        count++;
      }
    }
    if (count <= 1) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const mean = sum2 / count;
    let sumOfSquaresDifferences = 0;
    for (let i = 0; i < count; i++) {
      sumOfSquaresDifferences += (values[i] - mean) ** 2;
    }
    const result = Math.sqrt(sumOfSquaresDifferences / (count - 1));
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/dstdevp/index.ts
var Dstdevp = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    const values = [];
    let sum2 = 0;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        values.push(value);
        sum2 += value;
        count++;
      }
    }
    if (count === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const mean = sum2 / count;
    let sumOfSquaresDifferences = 0;
    for (let i = 0; i < count; i++) {
      sumOfSquaresDifferences += (values[i] - mean) ** 2;
    }
    const result = Math.sqrt(sumOfSquaresDifferences / count);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/dsum/index.ts
var Dsum = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    let result = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        result += value;
      }
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/dvar/index.ts
var Dvar = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    const values = [];
    let sum2 = 0;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        values.push(value);
        sum2 += value;
        count++;
      }
    }
    if (count <= 1) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const mean = sum2 / count;
    let sumOfSquaresDifferences = 0;
    for (let i = 0; i < count; i++) {
      sumOfSquaresDifferences += (values[i] - mean) ** 2;
    }
    const result = sumOfSquaresDifferences / (count - 1);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/dvarp/index.ts
var Dvarp = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(database, field, criteria) {
    const { isError: databaseIsError, errorObject: databaseErrorObject, databaseValues } = checkDatabase(database);
    if (databaseIsError) {
      return databaseErrorObject;
    }
    const { isError: fieldIsError, errorObject: filedErrorObject, fieldIndex } = checkField(field, databaseValues);
    if (fieldIsError) {
      return filedErrorObject;
    }
    const { isError: criteriaIsError, errorObject: criteriaErrorObject, criteriaValues } = checkCriteria(criteria);
    if (criteriaIsError) {
      return criteriaErrorObject;
    }
    const values = [];
    let sum2 = 0;
    let count = 0;
    for (let r = 1; r < databaseValues.length; r++) {
      const value = databaseValues[r][fieldIndex];
      if (typeof value !== "number") {
        continue;
      }
      if (isCriteriaMatch(criteriaValues, databaseValues, r)) {
        values.push(value);
        sum2 += value;
        count++;
      }
    }
    if (count === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const mean = sum2 / count;
    let sumOfSquaresDifferences = 0;
    for (let i = 0; i < count; i++) {
      sumOfSquaresDifferences += (values[i] - mean) ** 2;
    }
    const result = sumOfSquaresDifferences / count;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/database/function-map.ts
var functionDatabase = [
  [Daverage, "DAVERAGE" /* DAVERAGE */],
  [Dcount, "DCOUNT" /* DCOUNT */],
  [Dcounta, "DCOUNTA" /* DCOUNTA */],
  [Dget, "DGET" /* DGET */],
  [Dmax, "DMAX" /* DMAX */],
  [Dmin, "DMIN" /* DMIN */],
  [Dproduct, "DPRODUCT" /* DPRODUCT */],
  [Dstdev, "DSTDEV" /* DSTDEV */],
  [Dstdevp, "DSTDEVP" /* DSTDEVP */],
  [Dsum, "DSUM" /* DSUM */],
  [Dvar, "DVAR" /* DVAR */],
  [Dvarp, "DVARP" /* DVARP */]
];

// ../packages/engine-formula/src/basics/date.ts
var DEFAULT_DATE_FORMAT = "yyyy/mm/dd;@";
var DEFAULT_NOW_FORMAT = "yyyy/mm/dd hh:mm";
var DEFAULT_TIME_FORMAT = "h:mm A/P";
function excelDateSerial(date) {
  const baseDate = new Date(Date.UTC(1900, 0, 1));
  const leapDayDate = new Date(Date.UTC(1900, 1, 28));
  const dateInUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
  let dayDifference = (dateInUTC - baseDate.getTime()) / (1e3 * 3600 * 24);
  if (dateInUTC > leapDayDate.getTime()) {
    dayDifference += 1;
  }
  return Math.floor(dayDifference) + 1;
}
function excelDateTimeSerial(date) {
  const baseDate = new Date(Date.UTC(1900, 0, 1, 0, 0, 0));
  const leapDayDate = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  const diffMilliseconds = date.getTime() - baseDate.getTime();
  let dayDifference = diffMilliseconds / (1e3 * 3600 * 24);
  if (date > leapDayDate) {
    dayDifference += 1;
  }
  return dayDifference + 1;
}
function excelSerialToDate(serial) {
  const baseDate = new Date(Date.UTC(1900, 0, 1));
  const leapDayDate = new Date(Date.UTC(1900, 1, 28));
  let dayDifference = Math.floor(serial) - 1;
  if (dayDifference > (leapDayDate.getTime() - baseDate.getTime()) / (1e3 * 3600 * 24)) {
    dayDifference -= 1;
  }
  const resultDate = new Date(baseDate.getTime() + dayDifference * (1e3 * 3600 * 24));
  return resultDate;
}
function excelSerialToDateTime(serial) {
  const baseDate = new Date(Date.UTC(1900, 0, 1, 0, 0, 0));
  const leapDayDate = new Date(Date.UTC(1900, 1, 28, 0, 0, 0));
  let dayDifference = serial - 1;
  if (dayDifference > (leapDayDate.getTime() - baseDate.getTime()) / (1e3 * 3600 * 24)) {
    dayDifference -= 1;
  }
  if (dayDifference < 0) {
    dayDifference = serial;
  }
  const resultDate = new Date(baseDate.getTime() + dayDifference * (1e3 * 3600 * 24));
  return resultDate;
}
function isValidDateStr(dateStr) {
  const regex = /^\d{4}[-/](0?[1-9]|1[012])[-/](0?[1-9]|[12][0-9]|3[01])$/;
  if (!regex.test(dateStr)) {
    return false;
  }
  const normalizedDateStr = dateStr.replace(/-/g, "/").replace(/T.+/, "");
  const dateWithTime = /* @__PURE__ */ new Date(`${normalizedDateStr}`);
  if (Number.isNaN(dateWithTime.getTime())) {
    return false;
  }
  const year = dateWithTime.getFullYear();
  const month = (dateWithTime.getMonth() + 1).toString().padStart(2, "0");
  const day = dateWithTime.getDate().toString().padStart(2, "0");
  const reconstructedDateStr = `${year}-${month}-${day}`;
  const dateStrPad = dateStr.replace(/\//g, "-").split("-").map((v) => v.padStart(2, "0")).join("-");
  return dateStrPad === reconstructedDateStr;
}
function parseFormattedDate(value) {
  return numfmt.parseDate(value);
}
function parseFormattedValue(value) {
  return numfmt.parseValue(value);
}
function parseFormattedTime(value) {
  return numfmt.parseTime(value);
}
function isDate(format) {
  return numfmt.isDate(format);
}
var weekendNumberMap = {
  1: [6, 0],
  // Saturday, Sunday
  2: [0, 1],
  // Sunday, Monday
  3: [1, 2],
  // Monday, Tuesday
  4: [2, 3],
  // Tuesday, Wednesday
  5: [3, 4],
  // Wednesday, Thursday
  6: [4, 5],
  // Thursday, Friday
  7: [5, 6],
  // Friday, Saturday
  11: [0],
  // Sunday only
  12: [1],
  // Monday only
  13: [2],
  // Tuesday only
  14: [3],
  // Wednesday only
  15: [4],
  // Thursday only
  16: [5],
  // Friday only
  17: [6]
  // Saturday only
};
function isValidWeekend(weekend) {
  if (typeof weekend === "string" && /^[0|1]{7}/.test(weekend)) {
    return true;
  }
  if (weekendNumberMap[Number(weekend)]) {
    return true;
  }
  return false;
}
function getWeekendArray(weekend) {
  if (!isValidWeekend(weekend)) {
    return [];
  }
  if (typeof weekend === "string" && /^[0|1]{7}/.test(weekend)) {
    const result = [];
    for (let i = 1; i <= weekend.length; i++) {
      if (`${weekend[i - 1]}` === "1") {
        if (i === weekend.length) {
          result.push(0);
        } else {
          result.push(i);
        }
      }
    }
    return result;
  }
  return weekendNumberMap[Number(weekend)] || [];
}
function countWorkingDays(startDateSerialNumber, endDateSerialNumber, weekend = 1, holidays) {
  const weekendArray = getWeekendArray(weekend);
  const start = Math.floor(startDateSerialNumber);
  const end = Math.floor(endDateSerialNumber);
  const startSerialNumber = end > start ? start : end;
  let workingDays = 0;
  const daysDiff = Math.abs(Math.floor(endDateSerialNumber) - Math.floor(startDateSerialNumber)) + 1;
  for (let i = 0; i < daysDiff; i++) {
    const currentDateSerialNumber = startSerialNumber + i;
    if (holidays && holidays.length > 0 && holidays.some((item) => Math.floor(item) === currentDateSerialNumber)) {
      continue;
    }
    const weekDay = getWeekDayByDateSerialNumber(currentDateSerialNumber);
    if (weekendArray.includes(weekDay)) {
      continue;
    }
    workingDays++;
  }
  return end >= start ? workingDays : -workingDays;
}
function getDateSerialNumberByWorkingDays(startDateSerialNumber, workingDays, weekend = 1, holidays) {
  const weekendArray = getWeekendArray(weekend);
  const _startDateSerialNumber = Math.floor(startDateSerialNumber);
  let targetDateSerialNumber = _startDateSerialNumber;
  let days = Math.abs(workingDays);
  for (let i = 1; i <= days; i++) {
    const currentDateSerialNumber = workingDays < 0 ? _startDateSerialNumber - i : _startDateSerialNumber + i;
    if (currentDateSerialNumber < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (holidays && holidays.length > 0 && holidays.some((item) => Math.floor(item) === currentDateSerialNumber)) {
      days++;
      continue;
    }
    const weekDay = getWeekDayByDateSerialNumber(currentDateSerialNumber);
    if (weekendArray.includes(weekDay)) {
      days++;
      continue;
    }
    targetDateSerialNumber = currentDateSerialNumber;
  }
  return targetDateSerialNumber;
}
function getDateSerialNumberByObject(serialNumberObject) {
  if (serialNumberObject.isError()) {
    return serialNumberObject;
  }
  const dateValue = serialNumberObject.getValue();
  if (serialNumberObject.isString()) {
    let dateSerial;
    if (parseFormattedDate(`${dateValue}`)) {
      dateSerial = parseFormattedDate(`${dateValue}`).v;
    } else if (parseFormattedTime(`${dateValue}`)) {
      dateSerial = parseFormattedTime(`${dateValue}`).v;
    } else if (isRealNum(dateValue)) {
      dateSerial = +dateValue;
    } else {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (dateSerial instanceof Date) {
      dateSerial = excelDateTimeSerial(dateSerial);
    }
    if (+dateSerial < 0 || +dateSerial > 2958465) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return +dateSerial;
  } else {
    const dateSerial = +serialNumberObject.getValue();
    if (dateSerial < 0 || dateSerial > 2958465) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return dateSerial;
  }
}
function getWeekDayByDateSerialNumber(dateSerialNumber) {
  const isDate19000229 = Math.floor(dateSerialNumber) === 60;
  let date = excelSerialToDate(dateSerialNumber);
  const dateTime = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())).getTime();
  const leapDayDateTime = new Date(Date.UTC(1900, 1, 28)).getTime();
  if (!isDate19000229 && dateTime <= leapDayDateTime) {
    date = new Date(dateTime - 24 * 3600 * 1e3);
  }
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate())).getUTCDay();
}
function getTwoDateDaysByBasis(startDateSerialNumber, endDateSerialNumber, basis) {
  switch (basis) {
    case 0:
      return getDaysByNASD(startDateSerialNumber, endDateSerialNumber);
    case 1:
      return getDaysByActual(startDateSerialNumber, endDateSerialNumber);
    case 2:
      return {
        days: Math.abs(endDateSerialNumber - startDateSerialNumber),
        yearDays: 360
      };
    case 3:
      return {
        days: Math.abs(endDateSerialNumber - startDateSerialNumber),
        yearDays: 365
      };
    case 4:
      return getDaysByEuropean(startDateSerialNumber, endDateSerialNumber);
    default:
      return {
        days: Math.abs(endDateSerialNumber - startDateSerialNumber),
        yearDays: 365
      };
  }
}
function getDaysByNASD(startDateSerialNumber, endDateSerialNumber) {
  const startDateDate = excelSerialToDate(startDateSerialNumber);
  const startYear = startDateSerialNumber > 0 ? startDateDate.getUTCFullYear() : 1900;
  const startMonth = startDateSerialNumber > 0 ? startDateDate.getUTCMonth() + 1 : 1;
  let startDay = startDateSerialNumber > 0 ? startDateDate.getUTCDate() : 0;
  let endDateDate = excelSerialToDate(endDateSerialNumber);
  let endYear = endDateSerialNumber > 0 ? endDateDate.getUTCFullYear() : 1900;
  let endMonth = endDateSerialNumber > 0 ? endDateDate.getUTCMonth() + 1 : 1;
  let endDay = endDateSerialNumber > 0 ? endDateDate.getUTCDate() : 0;
  if (startMonth === 2) {
    const startDateAfterDay = excelSerialToDate(startDateSerialNumber + 1);
    if (startDateAfterDay.getUTCMonth() + 1 === 3) {
      startDay = 30;
    }
  } else if (startDay === 31) {
    startDay = 30;
  }
  if (endDay === 31) {
    if (startDay < 30) {
      endDateDate = excelSerialToDate(endDateSerialNumber + 1);
      endYear = endDateDate.getUTCFullYear();
      endMonth = endDateDate.getUTCMonth() + 1;
      endDay = endDateDate.getUTCDate();
    } else {
      endDay = 30;
    }
  }
  const daysInYears = (endYear - startYear) * 360;
  const daysInStartMonth = endDateSerialNumber >= startDateSerialNumber ? 30 - startDay : -startDay;
  const daysInEndMonth = endDateSerialNumber >= startDateSerialNumber ? endDay : endDay - 30;
  const daysInMidMonths = (endDateSerialNumber >= startDateSerialNumber ? endMonth - startMonth - 1 : endMonth - startMonth + 1) * 30;
  const totalDays = Math.abs(daysInYears + daysInStartMonth + daysInEndMonth + daysInMidMonths);
  return {
    days: totalDays,
    yearDays: 360
  };
}
function getDaysByActual(startDateSerialNumber, endDateSerialNumber) {
  const startDateDate = excelSerialToDate(startDateSerialNumber);
  const startYear = startDateSerialNumber > 0 ? startDateDate.getUTCFullYear() : 1900;
  const endDateDate = excelSerialToDate(endDateSerialNumber);
  const endYear = endDateSerialNumber > 0 ? endDateDate.getUTCFullYear() : 1900;
  const totalDays = Math.abs(endDateSerialNumber - startDateSerialNumber);
  const totalYear = Math.abs(endYear - startYear) + 1;
  let startYearFirstDaySerialNumber;
  let endYearLastDaySerialNumber;
  if (endYear < startYear) {
    const startYearFirstDay = new Date(Date.UTC(endYear, 0, 1));
    const endYearLastDay = new Date(Date.UTC(startYear, 11, 31));
    startYearFirstDaySerialNumber = excelDateSerial(startYearFirstDay);
    endYearLastDaySerialNumber = excelDateSerial(endYearLastDay);
    if (endYear === 1900) {
      startYearFirstDaySerialNumber += 1;
    }
  } else {
    const startYearFirstDay = new Date(Date.UTC(startYear, 0, 1));
    const endYearLastDay = new Date(Date.UTC(endYear, 11, 31));
    startYearFirstDaySerialNumber = excelDateSerial(startYearFirstDay);
    endYearLastDaySerialNumber = excelDateSerial(endYearLastDay);
    if (startYear === 1900) {
      startYearFirstDaySerialNumber += 1;
    }
  }
  return {
    days: totalDays,
    yearDays: (endYearLastDaySerialNumber - startYearFirstDaySerialNumber + 1) / totalYear
  };
}
function getDaysByEuropean(startDateSerialNumber, endDateSerialNumber) {
  const startDateDate = excelSerialToDate(startDateSerialNumber);
  const startYear = startDateSerialNumber > 0 ? startDateDate.getUTCFullYear() : 1900;
  const startMonth = startDateSerialNumber > 0 ? startDateDate.getUTCMonth() + 1 : 1;
  let startDay = startDateSerialNumber > 0 ? startDateDate.getUTCDate() : 0;
  const endDateDate = excelSerialToDate(endDateSerialNumber);
  const endYear = endDateSerialNumber > 0 ? endDateDate.getUTCFullYear() : 1900;
  const endMonth = endDateSerialNumber > 0 ? endDateDate.getUTCMonth() + 1 : 1;
  let endDay = endDateSerialNumber > 0 ? endDateDate.getUTCDate() : 0;
  if (startDay === 31) {
    startDay = 30;
  }
  if (endDay === 31) {
    endDay = 30;
  }
  const daysInYears = (endYear - startYear) * 360;
  const daysInStartMonth = endDateSerialNumber >= startDateSerialNumber ? 30 - startDay : -startDay;
  const daysInEndMonth = endDateSerialNumber >= startDateSerialNumber ? endDay : endDay - 30;
  const daysInMidMonths = (endDateSerialNumber >= startDateSerialNumber ? endMonth - startMonth - 1 : endMonth - startMonth + 1) * 30;
  const totalDays = Math.abs(daysInYears + daysInStartMonth + daysInEndMonth + daysInMidMonths);
  return {
    days: totalDays,
    yearDays: 360
  };
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function isLeapYear1900(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0 || year === 1900;
}
var daysInMonthL = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var daysInMonthR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function getDaysInMonth(year, month) {
  return isLeapYear(year) ? daysInMonthL[month] : daysInMonthR[month];
}
function getDaysInYear(year) {
  return isLeapYear1900(year) ? 366 : 365;
}
function getNormalYearDaysByBasis(dateSerialNumber, basis) {
  switch (basis) {
    case 0:
    case 2:
    case 4:
      return 360;
    case 1:
      return getDaysInYear(excelSerialToDate(dateSerialNumber).getUTCFullYear());
    case 3:
      return 365;
    default:
      return -1;
  }
}
function lastDayOfMonth(year, month, day) {
  return getDaysInMonth(year, month) === day;
}
function dateAddMonths(date, months) {
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth();
  const day = date.getUTCDate();
  if (lastDayOfMonth(year, month, day)) {
    date.setUTCDate(1);
    date.setUTCMonth(date.getUTCMonth() + months);
    year = date.getUTCFullYear();
    month = date.getUTCMonth();
    date.setUTCDate(getDaysInMonth(year, month));
  } else {
    date.setUTCMonth(date.getUTCMonth() + months);
  }
  return date;
}

// ../packages/engine-formula/src/functions/date/date/index.ts
var DateFunction = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(year, month, day) {
    if (year.isError()) {
      return year;
    }
    if (month.isError()) {
      return month;
    }
    if (day.isError()) {
      return day;
    }
    const maxRowLength = Math.max(
      year.isArray() ? year.getRowCount() : 1,
      month.isArray() ? month.getRowCount() : 1,
      day.isArray() ? day.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      year.isArray() ? year.getColumnCount() : 1,
      month.isArray() ? month.getColumnCount() : 1,
      day.isArray() ? day.getColumnCount() : 1
    );
    const yearArray = expandArrayValueObject(maxRowLength, maxColumnLength, year);
    const monthArray = expandArrayValueObject(maxRowLength, maxColumnLength, month);
    const dayArray = expandArrayValueObject(maxRowLength, maxColumnLength, day);
    return yearArray.map((yearValueObject, rowIndex, columnIndex) => {
      const monthValueObject = monthArray.get(rowIndex, columnIndex) || NullValueObject.create();
      const dayValueObject = dayArray.get(rowIndex, columnIndex) || NullValueObject.create();
      if (yearValueObject.isError()) {
        return yearValueObject;
      }
      if (monthValueObject.isError()) {
        return monthValueObject;
      }
      if (dayValueObject.isError()) {
        return dayValueObject;
      }
      if (yearValueObject.isString() || monthValueObject.isString() || dayValueObject.isString()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let yearValue = +yearValueObject.getValue();
      const monthValue = Math.floor(+monthValueObject.getValue());
      const dayValue = +dayValueObject.getValue();
      if (yearValue < 0 || yearValue > 9999) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (yearValue >= 0 && yearValue < 1899) {
        yearValue += 1900;
      }
      const date = new Date(yearValue, monthValue - 1, dayValue);
      const currentSerial = excelDateSerial(date);
      if (currentSerial < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const valueObject = NumberValueObject.create(currentSerial, DEFAULT_DATE_FORMAT);
      return valueObject;
    });
  }
};

// ../packages/engine-formula/src/functions/date/datedif/index.ts
var Datedif = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(startDate, endDate, unit) {
    let _startDate = startDate;
    let _endDate = endDate;
    let _unit = unit;
    if (_startDate.isArray()) {
      _startDate = _startDate.get(0, 0);
    }
    if (_endDate.isArray()) {
      _endDate = _endDate.get(0, 0);
    }
    if (_unit.isArray()) {
      _unit = _unit.get(0, 0);
    }
    if (_startDate.isError()) {
      return _startDate;
    }
    if (_endDate.isError()) {
      return _endDate;
    }
    if (_unit.isError()) {
      return _unit;
    }
    const startDateSerialNumber = getDateSerialNumberByObject(_startDate);
    if (typeof startDateSerialNumber !== "number") {
      return startDateSerialNumber;
    }
    const endDateSerialNumber = getDateSerialNumberByObject(_endDate);
    if (typeof endDateSerialNumber !== "number") {
      return endDateSerialNumber;
    }
    if (endDateSerialNumber < startDateSerialNumber) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (!_unit.isString()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return this._getResultByUnit(startDateSerialNumber, endDateSerialNumber, _unit);
  }
  _getResultByUnit(startDateSerialNumber, endDateSerialNumber, unit) {
    const startDateDate = excelSerialToDate(startDateSerialNumber);
    const startYear = startDateDate.getUTCFullYear();
    const startMonth = startDateDate.getUTCMonth() + 1;
    const startDay = startDateDate.getUTCDate();
    const endDateDate = excelSerialToDate(endDateSerialNumber);
    const endYear = endDateDate.getUTCFullYear();
    const endMonth = endDateDate.getUTCMonth() + 1;
    const endDay = endDateDate.getUTCDate();
    const unitValue = `${unit.getValue()}`.toLocaleUpperCase();
    let diff = 0;
    let newDate;
    switch (unitValue) {
      case "Y":
        diff = endYear - startYear;
        if (endMonth < startMonth || endMonth === startMonth && endDay < startDay) {
          diff -= 1;
        }
        break;
      case "M":
        diff = (endYear - startYear) * 12 + endMonth - startMonth;
        if (endDay < startDay) {
          diff -= 1;
        }
        break;
      case "D":
        diff = Math.floor(endDateSerialNumber) - Math.floor(startDateSerialNumber);
        break;
      case "MD":
        diff = endDay - startDay;
        if (endDay < startDay) {
          newDate = new Date(Date.UTC(endYear, endMonth - 1, 0));
          diff += getDaysInMonth(newDate.getUTCFullYear(), newDate.getUTCMonth());
        }
        break;
      case "YM":
        diff = endMonth - startMonth;
        if (endMonth < startMonth || endMonth === startMonth && endDay < startDay) {
          diff += 12;
        }
        if (endDay < startDay) {
          diff -= 1;
        }
        break;
      case "YD":
        newDate = new Date(Date.UTC(startYear, endMonth - 1, endDay));
        if (endMonth < startMonth || endMonth === startMonth && endDay < startDay) {
          newDate = new Date(Date.UTC(startYear + 1, endMonth - 1, endDay));
        }
        diff = Math.floor(excelDateSerial(newDate)) - Math.floor(startDateSerialNumber);
        break;
      default:
        return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(diff);
  }
};

// ../packages/engine-formula/src/functions/date/datevalue/index.ts
var Datevalue = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(dateText) {
    if (dateText.isError()) {
      return dateText;
    }
    if (dateText.isArray()) {
      return dateText.map((dateTextObject) => this._handleSingleObject(dateTextObject));
    }
    return this._handleSingleObject(dateText);
  }
  _handleSingleObject(dateTextObject) {
    if (dateTextObject.isString()) {
      const value = `${dateTextObject.getValue()}`;
      const parsedDate = parseFormattedValue(value);
      if (parsedDate) {
        let { v, z } = parsedDate;
        if (z && isDate(z)) {
          if (v instanceof Date) {
            v = excelDateTimeSerial(v);
          }
          return NumberValueObject.create(Math.trunc(+v));
        }
      }
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};

// ../packages/engine-formula/src/functions/date/day/index.ts
var Day = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(serialNumber) {
    if (serialNumber.isError()) {
      return serialNumber;
    }
    if (serialNumber.isArray()) {
      return serialNumber.map((serialNumberObject) => this._handleSingleObject(serialNumberObject));
    }
    return this._handleSingleObject(serialNumber);
  }
  _handleSingleObject(serialNumberObject) {
    let date;
    const dateValue = serialNumberObject.getValue();
    if (serialNumberObject.isString()) {
      if (!isValidDateStr(`${dateValue}`)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      date = /* @__PURE__ */ new Date(`${dateValue}`);
    } else {
      const dateSerial = +serialNumberObject.getValue();
      if (dateSerial < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (dateSerial === 0) {
        return NumberValueObject.create(0);
      }
      date = excelSerialToDate(dateSerial);
    }
    const month = date.getDate();
    const valueObject = NumberValueObject.create(month);
    return valueObject;
  }
};

// ../packages/engine-formula/src/functions/date/days/index.ts
var Days = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(endDate, startDate) {
    if (endDate.isError()) {
      return endDate;
    }
    if (startDate.isError()) {
      return startDate;
    }
    const maxRowLength = Math.max(
      endDate.isArray() ? endDate.getRowCount() : 1,
      startDate.isArray() ? startDate.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      endDate.isArray() ? endDate.getColumnCount() : 1,
      startDate.isArray() ? startDate.getColumnCount() : 1
    );
    const endDateArray = expandArrayValueObject(maxRowLength, maxColumnLength, endDate);
    const startDateArray = expandArrayValueObject(maxRowLength, maxColumnLength, startDate);
    const resultArray = endDateArray.map((endDateObject, rowIndex, columnIndex) => {
      const startDateObject = startDateArray.get(rowIndex, columnIndex);
      if (endDateObject.isError()) {
        return endDateObject;
      }
      if (startDateObject.isError()) {
        return startDateObject;
      }
      const endDateSerialNumber = getDateSerialNumberByObject(endDateObject);
      if (typeof endDateSerialNumber !== "number") {
        return endDateSerialNumber;
      }
      const startDateSerialNumber = getDateSerialNumberByObject(startDateObject);
      if (typeof startDateSerialNumber !== "number") {
        return startDateSerialNumber;
      }
      const result = Math.floor(endDateSerialNumber) - Math.floor(startDateSerialNumber);
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/date/days360/index.ts
var Days360 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(startDate, endDate, method) {
    const _method = method != null ? method : BooleanValueObject.create(false);
    if (startDate.isError()) {
      return startDate;
    }
    if (endDate.isError()) {
      return endDate;
    }
    if (_method.isError()) {
      return _method;
    }
    const maxRowLength = Math.max(
      startDate.isArray() ? startDate.getRowCount() : 1,
      endDate.isArray() ? endDate.getRowCount() : 1,
      _method.isArray() ? _method.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      startDate.isArray() ? startDate.getColumnCount() : 1,
      endDate.isArray() ? endDate.getColumnCount() : 1,
      _method.isArray() ? _method.getColumnCount() : 1
    );
    const startDateArray = expandArrayValueObject(maxRowLength, maxColumnLength, startDate, ErrorValueObject.create("#N/A" /* NA */));
    const endDateArray = expandArrayValueObject(maxRowLength, maxColumnLength, endDate, ErrorValueObject.create("#N/A" /* NA */));
    const methodArray = expandArrayValueObject(maxRowLength, maxColumnLength, _method, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = startDateArray.map((startDateObject, rowIndex, columnIndex) => {
      const endDateObject = endDateArray.get(rowIndex, columnIndex);
      let methodObject = methodArray.get(rowIndex, columnIndex);
      if (startDateObject.isError()) {
        return startDateObject;
      }
      const startDateSerialNumber = getDateSerialNumberByObject(startDateObject);
      if (typeof startDateSerialNumber !== "number") {
        return startDateSerialNumber;
      }
      if (endDateObject.isError()) {
        return endDateObject;
      }
      const endDateSerialNumber = getDateSerialNumberByObject(endDateObject);
      if (typeof endDateSerialNumber !== "number") {
        return endDateSerialNumber;
      }
      if (methodObject.isString()) {
        methodObject = methodObject.convertToNumberObjectValue();
      }
      if (methodObject.isError()) {
        return methodObject;
      }
      const methodValue = +methodObject.getValue();
      const { days } = getTwoDateDaysByBasis(startDateSerialNumber, endDateSerialNumber, !methodValue ? 0 : 4);
      const result = endDateSerialNumber >= startDateSerialNumber ? days : -days;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/date/edate/index.ts
var Edate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(startDate, months) {
    if (startDate.isError()) {
      return startDate;
    }
    if (months.isError()) {
      return months;
    }
    const maxRowLength = Math.max(
      startDate.isArray() ? startDate.getRowCount() : 1,
      months.isArray() ? months.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      startDate.isArray() ? startDate.getColumnCount() : 1,
      months.isArray() ? months.getColumnCount() : 1
    );
    const startDateArray = expandArrayValueObject(maxRowLength, maxColumnLength, startDate);
    const monthsArray = expandArrayValueObject(maxRowLength, maxColumnLength, months);
    return startDateArray.map((startDateObject, rowIndex, columnIndex) => {
      const monthsValueObject = monthsArray.get(rowIndex, columnIndex) || NullValueObject.create();
      if (startDateObject.isError()) {
        return startDateObject;
      }
      if (monthsValueObject.isError()) {
        return monthsValueObject;
      }
      if (startDateObject.isString() || startDateObject.isBoolean() || monthsValueObject.isString() || monthsValueObject.isBoolean()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const startDateSerial = +startDateObject.getValue();
      if (startDateSerial < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const monthsValue = Math.floor(+monthsValueObject.getValue());
      const _startDate = excelSerialToDate(startDateSerial);
      const year = _startDate.getUTCFullYear();
      const month = _startDate.getUTCMonth() + monthsValue;
      const day = _startDate.getUTCDate();
      const resultDate = new Date(Date.UTC(year, month, day));
      const currentSerial = excelDateSerial(resultDate);
      return NumberValueObject.create(currentSerial, DEFAULT_DATE_FORMAT);
    });
  }
};

// ../packages/engine-formula/src/functions/date/eomonth/index.ts
var Eomonth = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(startDate, months) {
    let _startDate = startDate;
    let _months = months;
    if (_startDate.isArray()) {
      const rowCount = _startDate.getRowCount();
      const columnCount = _startDate.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _startDate = _startDate.get(0, 0);
    }
    if (_months.isArray()) {
      const rowCount = _months.getRowCount();
      const columnCount = _months.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _months = _months.get(0, 0);
    }
    if (_startDate.isError()) {
      return _startDate;
    }
    if (_months.isError()) {
      return _months;
    }
    const startDateSerialNumber = getDateSerialNumberByObject(_startDate);
    if (typeof startDateSerialNumber !== "number") {
      return startDateSerialNumber;
    }
    if (_months.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const startDateDate = excelSerialToDate(startDateSerialNumber);
    const startYear = startDateSerialNumber > 0 ? startDateDate.getUTCFullYear() : 1900;
    const startMonth = startDateSerialNumber > 0 ? startDateDate.getUTCMonth() : 0;
    const monthsValue = Math.floor(+_months.getValue());
    if (Number.isNaN(monthsValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const targetDate = new Date(Date.UTC(startYear, startMonth + monthsValue + 1, 0));
    const result = excelDateSerial(targetDate);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/epochtodate/index.ts
var Epochtodate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(timestamp, unit) {
    const _unit = unit != null ? unit : NumberValueObject.create(1);
    const { isError, errorObject, timestampIsReferenceObject, timestampObject, unitObject } = this._checkVariants(timestamp, _unit);
    if (isError) {
      return errorObject;
    }
    if (timestampObject.isNull() || timestampObject.isBoolean() || timestampObject.isString()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!timestampIsReferenceObject && timestampObject.isNumber() && timestampObject.getPattern() !== "") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let timestampValue = +timestampObject.getValue();
    const { isError: _isError, errorObject: _errorObject, variants } = checkVariantsErrorIsStringToNumber(unitObject);
    if (_isError) {
      return _errorObject;
    }
    const [_unitObject] = variants;
    const unitValue = Math.floor(+_unitObject.getValue());
    if (timestampValue < 0 || unitValue < 1 || unitValue > 3) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (unitValue === 1) {
      timestampValue = timestampValue * 1e3;
    }
    if (unitValue === 3) {
      timestampValue = timestampValue / 1e3;
    }
    const date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, 0) + timestampValue);
    if (!Number.isNaN(date.getTime())) {
      const dateSerialNumber = excelDateTimeSerial(date);
      return NumberValueObject.create(dateSerialNumber, "yyyy-MM-dd AM/PM hh:mm:ss");
    } else {
      const result = 25569 + timestampValue / 864e5;
      return NumberValueObject.create(result);
    }
  }
  _checkVariants(timestamp, unit) {
    const timestampIsReferenceObject = timestamp.isReferenceObject();
    const unitIsReferenceObject = unit.isReferenceObject();
    let _timestamp = timestamp;
    if (timestampIsReferenceObject) {
      _timestamp = timestamp.toArrayValueObject();
    }
    if (_timestamp.isArray()) {
      const rowCount = _timestamp.getRowCount();
      const columnCount = _timestamp.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return {
          isError: true,
          errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
        };
      }
      _timestamp = _timestamp.get(0, 0);
    }
    if (_timestamp.isError()) {
      return {
        isError: true,
        errorObject: _timestamp
      };
    }
    let _unit = unit;
    if (unitIsReferenceObject) {
      _unit = unit.toArrayValueObject();
    }
    if (_unit.isArray()) {
      const rowCount = _unit.getRowCount();
      const columnCount = _unit.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return {
          isError: true,
          errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
        };
      }
      _unit = _unit.get(0, 0);
    }
    if (_unit.isError()) {
      return {
        isError: true,
        errorObject: _unit
      };
    }
    return {
      isError: false,
      errorObject: null,
      timestampIsReferenceObject,
      timestampObject: _timestamp,
      unitIsReferenceObject,
      unitObject: _unit
    };
  }
};

// ../packages/engine-formula/src/functions/date/hour/index.ts
var Hour = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(serialNumber) {
    if (serialNumber.isError()) {
      return serialNumber;
    }
    if (serialNumber.isArray()) {
      return serialNumber.map((serialNumberObject) => {
        if (serialNumberObject.isError()) {
          return serialNumberObject;
        }
        return this._handleSingleObject(serialNumberObject);
      });
    }
    return this._handleSingleObject(serialNumber);
  }
  _handleSingleObject(serialNumberObject) {
    const dateSerialNumber = getDateSerialNumberByObject(serialNumberObject);
    if (typeof dateSerialNumber !== "number") {
      return dateSerialNumber;
    }
    if (dateSerialNumber === 0) {
      return NumberValueObject.create(0);
    }
    const date = excelSerialToDateTime(dateSerialNumber);
    const hours = date.getUTCHours();
    return NumberValueObject.create(hours);
  }
};

// ../packages/engine-formula/src/functions/date/isoweeknum/index.ts
var Isoweeknum = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(date) {
    if (date.isError()) {
      return date;
    }
    if (date.isArray()) {
      return date.map((dateObject) => {
        if (dateObject.isError()) {
          return dateObject;
        }
        return this._handleSingleObject(dateObject);
      });
    }
    return this._handleSingleObject(date);
  }
  _handleSingleObject(date) {
    const dateSerialNumber = getDateSerialNumberByObject(date);
    if (typeof dateSerialNumber !== "number") {
      return dateSerialNumber;
    }
    const currentDate = excelSerialToDate(dateSerialNumber);
    const currentYear = dateSerialNumber > 0 ? currentDate.getUTCFullYear() : 1900;
    let yearStart = new Date(Date.UTC(currentYear, 0, 1));
    let yearStartSerialNumber = excelDateSerial(yearStart);
    let yearStartWeekDay = getWeekDayByDateSerialNumber(yearStartSerialNumber);
    let yearWeekStartSerialNumber;
    if (yearStartWeekDay < 1) {
      yearWeekStartSerialNumber = yearStartSerialNumber + 1;
    } else if (yearStartWeekDay <= 4) {
      yearWeekStartSerialNumber = yearStartSerialNumber - (yearStartWeekDay - 1);
    } else {
      yearWeekStartSerialNumber = yearStartSerialNumber + (11 - yearStartWeekDay);
    }
    if (dateSerialNumber < yearWeekStartSerialNumber) {
      yearStart = new Date(Date.UTC(currentYear - 1, 0, 1));
      yearStartSerialNumber = excelDateSerial(yearStart);
      yearStartWeekDay = getWeekDayByDateSerialNumber(yearStartSerialNumber);
      if (yearStartWeekDay < 1) {
        yearWeekStartSerialNumber = yearStartSerialNumber + 1;
      } else if (yearStartWeekDay <= 4) {
        yearWeekStartSerialNumber = yearStartSerialNumber - (yearStartWeekDay - 1);
      } else {
        yearWeekStartSerialNumber = yearStartSerialNumber + (11 - yearStartWeekDay);
      }
    }
    const result = Math.ceil((dateSerialNumber - yearWeekStartSerialNumber + 1) / 7);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/minute/index.ts
var Minute = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(serialNumber) {
    if (serialNumber.isError()) {
      return serialNumber;
    }
    if (serialNumber.isArray()) {
      return serialNumber.map((serialNumberObject) => {
        if (serialNumberObject.isError()) {
          return serialNumberObject;
        }
        return this._handleSingleObject(serialNumberObject);
      });
    }
    return this._handleSingleObject(serialNumber);
  }
  _handleSingleObject(serialNumberObject) {
    const dateSerialNumber = getDateSerialNumberByObject(serialNumberObject);
    if (typeof dateSerialNumber !== "number") {
      return dateSerialNumber;
    }
    if (dateSerialNumber === 0) {
      return NumberValueObject.create(0);
    }
    const date = excelSerialToDateTime(dateSerialNumber);
    const minutes = date.getUTCMinutes();
    return NumberValueObject.create(minutes);
  }
};

// ../packages/engine-formula/src/functions/date/month/index.ts
var Month = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(serialNumber) {
    if (serialNumber.isArray()) {
      return serialNumber.map((serialNumberObject) => this._handleSingleObject(serialNumberObject));
    }
    return this._handleSingleObject(serialNumber);
  }
  _handleSingleObject(serialNumberObject) {
    if (serialNumberObject.isError()) {
      return serialNumberObject;
    }
    let date;
    const dateValue = serialNumberObject.getValue();
    if (serialNumberObject.isString()) {
      if (!isValidDateStr(`${dateValue}`)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      date = /* @__PURE__ */ new Date(`${dateValue}`);
    } else {
      const dateSerial = +serialNumberObject.getValue();
      if (dateSerial < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (dateSerial === 0) {
        return NumberValueObject.create(1);
      }
      date = excelSerialToDate(dateSerial);
    }
    const month = date.getUTCMonth() + 1;
    const valueObject = NumberValueObject.create(month);
    return valueObject;
  }
};

// ../packages/engine-formula/src/functions/date/networkdays/index.ts
var Networkdays = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(startDate, endDate, holidays) {
    let _startDate = startDate;
    let _endDate = endDate;
    if (_startDate.isArray()) {
      const rowCount = _startDate.getRowCount();
      const columnCount = _startDate.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _startDate = _startDate.get(0, 0);
    }
    if (_startDate.isError()) {
      return _startDate;
    }
    if (_endDate.isArray()) {
      const rowCount = _endDate.getRowCount();
      const columnCount = _endDate.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _endDate = _endDate.get(0, 0);
    }
    if (_endDate.isError()) {
      return _endDate;
    }
    if (holidays == null ? void 0 : holidays.isError()) {
      return holidays;
    }
    if (_startDate.isBoolean() || _endDate.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const startDateSerialNumber = getDateSerialNumberByObject(_startDate);
    if (typeof startDateSerialNumber !== "number") {
      return startDateSerialNumber;
    }
    const endDateSerialNumber = getDateSerialNumberByObject(_endDate);
    if (typeof endDateSerialNumber !== "number") {
      return endDateSerialNumber;
    }
    if (holidays) {
      return this._getResultByHolidays(startDateSerialNumber, endDateSerialNumber, holidays);
    }
    const result = countWorkingDays(startDateSerialNumber, endDateSerialNumber);
    return NumberValueObject.create(result);
  }
  _getResultByHolidays(startDateSerialNumber, endDateSerialNumber, holidays) {
    const holidaysValueArray = [];
    if (holidays == null ? void 0 : holidays.isArray()) {
      const rowCount = holidays.getRowCount();
      const columnCount = holidays.getColumnCount();
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const cell = holidays.get(r, c);
          if (cell.isBoolean()) {
            return ErrorValueObject.create("#VALUE!" /* VALUE */);
          }
          const holidaySerialNumber = getDateSerialNumberByObject(cell);
          if (typeof holidaySerialNumber !== "number") {
            return holidaySerialNumber;
          }
          holidaysValueArray.push(holidaySerialNumber);
        }
      }
    } else {
      if (holidays.isBoolean()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const holidaySerialNumber = getDateSerialNumberByObject(holidays);
      if (typeof holidaySerialNumber !== "number") {
        return holidaySerialNumber;
      }
      holidaysValueArray.push(holidaySerialNumber);
    }
    const result = countWorkingDays(startDateSerialNumber, endDateSerialNumber, 1, holidaysValueArray);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/networkdays-intl/index.ts
var NetworkdaysIntl = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 4);
  }
  calculate(startDate, endDate, weekend, holidays) {
    if (startDate.isError()) {
      return startDate;
    }
    if (endDate.isError()) {
      return endDate;
    }
    if (weekend == null ? void 0 : weekend.isError()) {
      return weekend;
    }
    if (holidays == null ? void 0 : holidays.isError()) {
      return holidays;
    }
    if (weekend == null ? void 0 : weekend.isArray()) {
      return weekend.map((weekendItem) => this._handleSingleObject(startDate, endDate, weekendItem, holidays));
    }
    return this._handleSingleObject(startDate, endDate, weekend, holidays);
  }
  _handleSingleObject(startDate, endDate, weekend, holidays) {
    let _startDate = startDate;
    let _endDate = endDate;
    if (_startDate.isArray()) {
      const rowCount = _startDate.getRowCount();
      const columnCount = _startDate.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _startDate = _startDate.get(0, 0);
    }
    if (_startDate.isError()) {
      return _startDate;
    }
    if (_endDate.isArray()) {
      const rowCount = _endDate.getRowCount();
      const columnCount = _endDate.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _endDate = _endDate.get(0, 0);
    }
    if (_endDate.isError()) {
      return _endDate;
    }
    let weekendValue = 1;
    if (weekend) {
      weekendValue = weekend.getValue();
      if (weekend.isBoolean()) {
        weekendValue = +weekendValue;
      }
      if (weekend.isString() && !isValidWeekend(weekendValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (!isValidWeekend(weekendValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    if (_startDate.isBoolean() || _endDate.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const startDateSerialNumber = getDateSerialNumberByObject(_startDate);
    if (typeof startDateSerialNumber !== "number") {
      return startDateSerialNumber;
    }
    const endDateSerialNumber = getDateSerialNumberByObject(_endDate);
    if (typeof endDateSerialNumber !== "number") {
      return endDateSerialNumber;
    }
    if (holidays) {
      return this._getResultByHolidays(startDateSerialNumber, endDateSerialNumber, weekendValue, holidays);
    }
    const result = countWorkingDays(startDateSerialNumber, endDateSerialNumber, weekendValue);
    return NumberValueObject.create(result);
  }
  _getResultByHolidays(startDateSerialNumber, endDateSerialNumber, weekendValue, holidays) {
    const holidaysValueArray = [];
    if (holidays == null ? void 0 : holidays.isArray()) {
      const rowCount = holidays.getRowCount();
      const columnCount = holidays.getColumnCount();
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const cell = holidays.get(r, c);
          if (cell.isBoolean()) {
            return ErrorValueObject.create("#VALUE!" /* VALUE */);
          }
          const holidaySerialNumber = getDateSerialNumberByObject(cell);
          if (typeof holidaySerialNumber !== "number") {
            return holidaySerialNumber;
          }
          holidaysValueArray.push(holidaySerialNumber);
        }
      }
    } else {
      if (holidays.isBoolean()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const holidaySerialNumber = getDateSerialNumberByObject(holidays);
      if (typeof holidaySerialNumber !== "number") {
        return holidaySerialNumber;
      }
      holidaysValueArray.push(holidaySerialNumber);
    }
    const result = countWorkingDays(startDateSerialNumber, endDateSerialNumber, weekendValue, holidaysValueArray);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/now/index.ts
var Now = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
  }
  calculate() {
    const now = /* @__PURE__ */ new Date();
    const utcNow = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), now.getMinutes(), now.getSeconds()));
    const currentSerial = excelDateTimeSerial(utcNow);
    const valueObject = NumberValueObject.create(currentSerial, DEFAULT_NOW_FORMAT);
    return valueObject;
  }
};

// ../packages/engine-formula/src/functions/date/second/index.ts
var Second = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(serialNumber) {
    if (serialNumber.isError()) {
      return serialNumber;
    }
    if (serialNumber.isArray()) {
      return serialNumber.map((serialNumberObject) => {
        if (serialNumberObject.isError()) {
          return serialNumberObject;
        }
        return this._handleSingleObject(serialNumberObject);
      });
    }
    return this._handleSingleObject(serialNumber);
  }
  _handleSingleObject(serialNumberObject) {
    const dateSerialNumber = getDateSerialNumberByObject(serialNumberObject);
    if (typeof dateSerialNumber !== "number") {
      return dateSerialNumber;
    }
    if (dateSerialNumber === 0) {
      return NumberValueObject.create(0);
    }
    const date = excelSerialToDateTime(dateSerialNumber);
    const seconds = date.getUTCSeconds();
    return NumberValueObject.create(seconds);
  }
};

// ../packages/engine-formula/src/functions/date/time/index.ts
var Time = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(hour, minute, second) {
    if (hour.isError()) {
      return hour;
    }
    if (minute.isError()) {
      return minute;
    }
    if (second.isError()) {
      return second;
    }
    const maxRowLength = Math.max(
      hour.isArray() ? hour.getRowCount() : 1,
      minute.isArray() ? minute.getRowCount() : 1,
      second.isArray() ? second.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      hour.isArray() ? hour.getColumnCount() : 1,
      minute.isArray() ? minute.getColumnCount() : 1,
      second.isArray() ? second.getColumnCount() : 1
    );
    const hourArray = expandArrayValueObject(maxRowLength, maxColumnLength, hour);
    const minuteArray = expandArrayValueObject(maxRowLength, maxColumnLength, minute);
    const secondArray = expandArrayValueObject(maxRowLength, maxColumnLength, second);
    return hourArray.map((hourValueObject, rowIndex, columnIndex) => {
      return this._calculateTime(hourValueObject, minuteArray, secondArray, rowIndex, columnIndex);
    });
  }
  _calculateTime(hourValueObject, minuteArray, secondArray, rowIndex, columnIndex) {
    let _hourValueObject = hourValueObject;
    let minuteValueObject = minuteArray.get(rowIndex, columnIndex) || NullValueObject.create();
    let secondValueObject = secondArray.get(rowIndex, columnIndex) || NullValueObject.create();
    if (_hourValueObject.isString() || _hourValueObject.isBoolean()) {
      _hourValueObject = _hourValueObject.convertToNumberObjectValue();
    }
    if (minuteValueObject.isString() || minuteValueObject.isBoolean()) {
      minuteValueObject = minuteValueObject.convertToNumberObjectValue();
    }
    if (secondValueObject.isString() || secondValueObject.isBoolean()) {
      secondValueObject = secondValueObject.convertToNumberObjectValue();
    }
    if (_hourValueObject.isError()) {
      return _hourValueObject;
    }
    if (minuteValueObject.isError()) {
      return minuteValueObject;
    }
    if (secondValueObject.isError()) {
      return secondValueObject;
    }
    let hourValue = Math.floor(+_hourValueObject.getValue());
    let minuteValue = Math.floor(+minuteValueObject.getValue());
    let secondValue = Math.floor(+secondValueObject.getValue());
    if (hourValue < 0 || minuteValue < 0 || secondValue < 0 || hourValue > 32767 || minuteValue > 32767 || secondValue > 32767) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    minuteValue += Math.floor(secondValue / 60);
    secondValue %= 60;
    hourValue += Math.floor(minuteValue / 60);
    minuteValue %= 60;
    hourValue %= 24;
    const totalSeconds = hourValue * 3600 + minuteValue * 60 + secondValue;
    const fractionOfDay = totalSeconds / 86400;
    const valueObject = NumberValueObject.create(fractionOfDay, DEFAULT_TIME_FORMAT);
    return valueObject;
  }
};

// ../packages/engine-formula/src/functions/date/timevalue/index.ts
var Timevalue = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(timeText) {
    if (timeText.isError()) {
      return timeText;
    }
    if (timeText.isArray()) {
      return timeText.map((timeTextObject) => this._handleSingleObject(timeTextObject));
    }
    return this._handleSingleObject(timeText);
  }
  _handleSingleObject(timeTextObject) {
    if (timeTextObject.isString()) {
      const value = `${timeTextObject.getValue()}`;
      const parsedTime = parseFormattedValue(value);
      if (parsedTime) {
        let { v, z } = parsedTime;
        if (z && isDate(z)) {
          if (v instanceof Date) {
            v = excelDateTimeSerial(v);
          }
          return NumberValueObject.create(getFractionalPart(+v));
        }
      }
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};

// ../packages/engine-formula/src/functions/date/to-date/index.ts
var ToDate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(value) {
    const isReferenceObject = value.isReferenceObject();
    let _value = value;
    if (isReferenceObject) {
      _value = value.toArrayValueObject();
    }
    if (_value.isArray()) {
      const rowCount = _value.getRowCount();
      const columnCount = _value.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _value = _value.get(0, 0);
    }
    if (_value.isError() || _value.isNull() || _value.isBoolean() || _value.isString()) {
      return _value;
    }
    if (!isReferenceObject && _value.isNumber() && _value.getPattern() !== "") {
      return _value;
    }
    const val = +_value.getValue();
    return NumberValueObject.create(val, "yyyy-MM-dd hh:mm:ss AM/PM");
  }
};

// ../packages/engine-formula/src/functions/date/today/index.ts
var Today = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
  }
  calculate() {
    const currentSerial = excelDateSerial(/* @__PURE__ */ new Date());
    const valueObject = NumberValueObject.create(currentSerial, DEFAULT_DATE_FORMAT);
    return valueObject;
  }
};

// ../packages/engine-formula/src/functions/date/weekday/index.ts
var Weekday = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
    __publicField(this, "_returnTypeMap", {
      1: [1, 2, 3, 4, 5, 6, 7],
      // Sunday = 1 ~ Saturday = 7
      2: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      3: [6, 0, 1, 2, 3, 4, 5],
      // Monday = 0 ~ Sunday = 6
      11: [7, 1, 2, 3, 4, 5, 6],
      // Monday = 1 ~ Sunday = 7
      12: [6, 7, 1, 2, 3, 4, 5],
      // Tuesday = 1 ~ Monday = 7
      13: [5, 6, 7, 1, 2, 3, 4],
      // Wednesday = 1 ~ Tuesday = 7
      14: [4, 5, 6, 7, 1, 2, 3],
      // Thursday = 1 ~ Wednesday = 7
      15: [3, 4, 5, 6, 7, 1, 2],
      // Friday = 1 ~ Thursday = 7
      16: [2, 3, 4, 5, 6, 7, 1],
      // Saturday = 1 ~ Friday = 7
      17: [1, 2, 3, 4, 5, 6, 7]
      // Sunday = 1 ~ Saturday = 7
    });
  }
  calculate(serialNumber, returnType) {
    const _returnType = returnType != null ? returnType : NumberValueObject.create(1);
    if (serialNumber.isError()) {
      return serialNumber;
    }
    if (_returnType.isError()) {
      return _returnType;
    }
    const maxRowLength = Math.max(
      serialNumber.isArray() ? serialNumber.getRowCount() : 1,
      _returnType.isArray() ? _returnType.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      serialNumber.isArray() ? serialNumber.getColumnCount() : 1,
      _returnType.isArray() ? _returnType.getColumnCount() : 1
    );
    const serialNumberArray = expandArrayValueObject(maxRowLength, maxColumnLength, serialNumber, ErrorValueObject.create("#N/A" /* NA */));
    const returnTypeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _returnType, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = serialNumberArray.map((serialNumberObject, rowIndex, columnIndex) => {
      const returnTypeObject = returnTypeArray.get(rowIndex, columnIndex);
      return this._handleSingleObject(serialNumberObject, returnTypeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(serialNumberObject, returnTypeObject) {
    let _returnTypeObject = returnTypeObject;
    if (serialNumberObject.isError()) {
      return serialNumberObject;
    }
    if (_returnTypeObject.isError()) {
      return _returnTypeObject;
    }
    const dateSerialNumber = getDateSerialNumberByObject(serialNumberObject);
    if (typeof dateSerialNumber !== "number") {
      return dateSerialNumber;
    }
    if (_returnTypeObject.isString()) {
      _returnTypeObject = _returnTypeObject.convertToNumberObjectValue();
      if (_returnTypeObject.isError()) {
        return _returnTypeObject;
      }
    }
    const returnTypeValue = Math.floor(+_returnTypeObject.getValue());
    if (!this._returnTypeMap[returnTypeValue]) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const weekDay = getWeekDayByDateSerialNumber(dateSerialNumber);
    const result = this._returnTypeMap[returnTypeValue][weekDay];
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/weeknum/index.ts
var Weeknum = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
    __publicField(this, "_returnTypeMap", {
      1: 0,
      2: 1,
      11: 1,
      12: 2,
      13: 3,
      14: 4,
      15: 5,
      16: 6,
      17: 0,
      21: 4
    });
  }
  calculate(serialNumber, returnType) {
    let _serialNumber = serialNumber;
    let _returnType = returnType != null ? returnType : NumberValueObject.create(1);
    if (_serialNumber.isArray()) {
      const rowCount = _serialNumber.getRowCount();
      const columnCount = _serialNumber.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _serialNumber = _serialNumber.get(0, 0);
    }
    if (_serialNumber.isError()) {
      return _serialNumber;
    }
    if (_returnType.isArray()) {
      const rowCount = _returnType.getRowCount();
      const columnCount = _returnType.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _returnType = _returnType.get(0, 0);
    }
    if (_returnType.isError()) {
      return _returnType;
    }
    if (_serialNumber.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const dateSerialNumber = getDateSerialNumberByObject(_serialNumber);
    if (typeof dateSerialNumber !== "number") {
      return dateSerialNumber;
    }
    if (_returnType.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const returnTypeValue = Math.floor(+_returnType.getValue());
    if (Number.isNaN(returnTypeValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!(returnTypeValue in this._returnTypeMap)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return this._getResult(dateSerialNumber, returnTypeValue);
  }
  _getResult(dateSerialNumber, returnTypeValue) {
    const currentDate = excelSerialToDate(dateSerialNumber);
    const currentYear = dateSerialNumber > 0 ? currentDate.getUTCFullYear() : 1900;
    let yearStart = new Date(Date.UTC(currentYear, 0, 1));
    let yearStartSerialNumber = excelDateSerial(yearStart);
    let yearStartWeekDay = getWeekDayByDateSerialNumber(yearStartSerialNumber);
    let yearWeekStartSerialNumber;
    if (returnTypeValue === 21) {
      if (yearStartWeekDay < 1) {
        yearWeekStartSerialNumber = yearStartSerialNumber + 1;
      } else if (yearStartWeekDay <= 4) {
        yearWeekStartSerialNumber = yearStartSerialNumber - (yearStartWeekDay - 1);
      } else {
        yearWeekStartSerialNumber = yearStartSerialNumber + (11 - yearStartWeekDay);
      }
      if (dateSerialNumber < yearWeekStartSerialNumber) {
        yearStart = new Date(Date.UTC(currentYear - 1, 0, 1));
        yearStartSerialNumber = excelDateSerial(yearStart);
        yearStartWeekDay = getWeekDayByDateSerialNumber(yearStartSerialNumber);
        if (yearStartWeekDay < 1) {
          yearWeekStartSerialNumber = yearStartSerialNumber + 1;
        } else if (yearStartWeekDay <= 4) {
          yearWeekStartSerialNumber = yearStartSerialNumber - (yearStartWeekDay - 1);
        } else {
          yearWeekStartSerialNumber = yearStartSerialNumber + (11 - yearStartWeekDay);
        }
      }
    } else {
      const weekDay = this._returnTypeMap[returnTypeValue];
      if (yearStartWeekDay < weekDay) {
        yearWeekStartSerialNumber = yearStartSerialNumber - (yearStartWeekDay + 7 - weekDay);
      } else {
        yearWeekStartSerialNumber = yearStartSerialNumber - (yearStartWeekDay - weekDay);
      }
    }
    const result = Math.ceil((dateSerialNumber - yearWeekStartSerialNumber + 1) / 7);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/workday/index.ts
var Workday = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(startDate, days, holidays) {
    let _startDate = startDate;
    let _days = days;
    if (_startDate.isArray()) {
      const rowCount = _startDate.getRowCount();
      const columnCount = _startDate.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _startDate = _startDate.get(0, 0);
    }
    if (_startDate.isError()) {
      return _startDate;
    }
    if (_days.isArray()) {
      const rowCount = _days.getRowCount();
      const columnCount = _days.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _days = _days.get(0, 0);
    }
    if (_days.isError()) {
      return _days;
    }
    if (holidays == null ? void 0 : holidays.isError()) {
      return holidays;
    }
    if (_startDate.isBoolean() || _days.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const startDateSerialNumber = getDateSerialNumberByObject(_startDate);
    if (typeof startDateSerialNumber !== "number") {
      return startDateSerialNumber;
    }
    const workingDays = +_days.getValue();
    if (Number.isNaN(workingDays)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (holidays) {
      return this._getResultByHolidays(startDateSerialNumber, workingDays, holidays);
    }
    const result = getDateSerialNumberByWorkingDays(startDateSerialNumber, workingDays);
    if (typeof result !== "number") {
      return result;
    }
    return NumberValueObject.create(result);
  }
  _getResultByHolidays(startDateSerialNumber, workingDays, holidays) {
    const holidaysValueArray = [];
    if (holidays == null ? void 0 : holidays.isArray()) {
      const rowCount = holidays.getRowCount();
      const columnCount = holidays.getColumnCount();
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const cell = holidays.get(r, c);
          if (cell.isBoolean()) {
            return ErrorValueObject.create("#VALUE!" /* VALUE */);
          }
          const holidaySerialNumber = getDateSerialNumberByObject(cell);
          if (typeof holidaySerialNumber !== "number") {
            return holidaySerialNumber;
          }
          holidaysValueArray.push(holidaySerialNumber);
        }
      }
    } else {
      if (holidays.isBoolean()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const holidaySerialNumber = getDateSerialNumberByObject(holidays);
      if (typeof holidaySerialNumber !== "number") {
        return holidaySerialNumber;
      }
      holidaysValueArray.push(holidaySerialNumber);
    }
    const result = getDateSerialNumberByWorkingDays(startDateSerialNumber, workingDays, 1, holidaysValueArray);
    if (typeof result !== "number") {
      return result;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/workday-intl/index.ts
var WorkdayIntl = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 4);
  }
  calculate(startDate, days, weekend, holidays) {
    if (startDate.isError()) {
      return startDate;
    }
    if (days.isError()) {
      return days;
    }
    if (weekend == null ? void 0 : weekend.isError()) {
      return weekend;
    }
    if (holidays == null ? void 0 : holidays.isError()) {
      return holidays;
    }
    if (weekend == null ? void 0 : weekend.isArray()) {
      return weekend.map((weekendItem) => this._handleSingleObject(startDate, days, weekendItem, holidays));
    }
    return this._handleSingleObject(startDate, days, weekend, holidays);
  }
  _handleSingleObject(startDate, days, weekend, holidays) {
    const _weekend = weekend != null ? weekend : NumberValueObject.create(1);
    const _startDate = this._checkArrayError(startDate);
    if (_startDate.isError()) {
      return _startDate;
    }
    const _days = this._checkArrayError(days);
    if (_days.isError()) {
      return _days;
    }
    if (_startDate.isBoolean() || _days.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const startDateSerialNumber = getDateSerialNumberByObject(startDate);
    if (typeof startDateSerialNumber !== "number") {
      return startDateSerialNumber;
    }
    const workingDays = +days.getValue();
    if (Number.isNaN(workingDays)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let weekendValue = _weekend.getValue();
    if (_weekend.isBoolean()) {
      weekendValue = +weekendValue;
    }
    if (_weekend.isString() && (!isValidWeekend(weekendValue) || weekendValue === "1111111")) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!isValidWeekend(weekendValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (holidays) {
      return this._getResultByHolidays(startDateSerialNumber, workingDays, weekendValue, holidays);
    }
    const result = getDateSerialNumberByWorkingDays(startDateSerialNumber, workingDays, weekendValue);
    if (typeof result !== "number") {
      return result;
    }
    return NumberValueObject.create(result);
  }
  _checkArrayError(variant) {
    let _variant = variant;
    if (_variant.isArray()) {
      const rowCount = _variant.getRowCount();
      const columnCount = _variant.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _variant = _variant.get(0, 0);
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant;
  }
  _getResultByHolidays(startDateSerialNumber, workingDays, weekendValue, holidays) {
    const holidaysValueArray = [];
    if (holidays == null ? void 0 : holidays.isArray()) {
      const rowCount = holidays.getRowCount();
      const columnCount = holidays.getColumnCount();
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const cell = holidays.get(r, c);
          if (cell.isBoolean()) {
            return ErrorValueObject.create("#VALUE!" /* VALUE */);
          }
          const holidaySerialNumber = getDateSerialNumberByObject(cell);
          if (typeof holidaySerialNumber !== "number") {
            return holidaySerialNumber;
          }
          holidaysValueArray.push(holidaySerialNumber);
        }
      }
    } else {
      if (holidays.isBoolean()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const holidaySerialNumber = getDateSerialNumberByObject(holidays);
      if (typeof holidaySerialNumber !== "number") {
        return holidaySerialNumber;
      }
      holidaysValueArray.push(holidaySerialNumber);
    }
    const result = getDateSerialNumberByWorkingDays(startDateSerialNumber, workingDays, weekendValue, holidaysValueArray);
    if (typeof result !== "number") {
      return result;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/year/index.ts
var Year = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(serialNumber) {
    if (serialNumber.isArray()) {
      return serialNumber.map((serialNumberObject) => this._handleSingleObject(serialNumberObject));
    }
    return this._handleSingleObject(serialNumber);
  }
  _handleSingleObject(serialNumberObject) {
    if (serialNumberObject.isError()) {
      return serialNumberObject;
    }
    let date;
    const dateValue = serialNumberObject.getValue();
    if (serialNumberObject.isString()) {
      if (!isValidDateStr(`${dateValue}`)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      date = /* @__PURE__ */ new Date(`${dateValue}`);
    } else {
      const dateSerial = +dateValue;
      if (dateSerial < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (dateSerial === 0) {
        return NumberValueObject.create(1900);
      }
      date = excelSerialToDate(dateSerial);
    }
    const year = date.getUTCFullYear();
    const valueObject = NumberValueObject.create(year);
    return valueObject;
  }
};

// ../packages/engine-formula/src/functions/date/yearfrac/index.ts
var Yearfrac = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(startDate, endDate, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    const _startDate = checkVariantErrorIsArray(startDate);
    if (_startDate.isError()) {
      return _startDate;
    }
    const _endDate = checkVariantErrorIsArray(endDate);
    if (_endDate.isError()) {
      return _endDate;
    }
    _basis = checkVariantErrorIsArray(_basis);
    if (_basis.isError()) {
      return _basis;
    }
    if (_startDate.isBoolean() || _endDate.isBoolean() || _basis.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const startDateSerialNumber = getDateSerialNumberByObject(_startDate);
    if (typeof startDateSerialNumber !== "number") {
      return startDateSerialNumber;
    }
    const endDateSerialNumber = getDateSerialNumberByObject(_endDate);
    if (typeof endDateSerialNumber !== "number") {
      return endDateSerialNumber;
    }
    const basisValue = Math.floor(+_basis.getValue());
    if (Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (basisValue < 0 || basisValue > 4) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const { days, yearDays } = getTwoDateDaysByBasis(startDateSerialNumber, endDateSerialNumber, basisValue);
    const result = days / yearDays;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/date/function-map.ts
var functionDate = [
  [DateFunction, "DATE" /* DATE */],
  [Datedif, "DATEDIF" /* DATEDIF */],
  [Datevalue, "DATEVALUE" /* DATEVALUE */],
  [Day, "DAY" /* DAY */],
  [Days, "DAYS" /* DAYS */],
  [Days360, "DAYS360" /* DAYS360 */],
  [Edate, "EDATE" /* EDATE */],
  [Eomonth, "EOMONTH" /* EOMONTH */],
  [Epochtodate, "EPOCHTODATE" /* EPOCHTODATE */],
  [Hour, "HOUR" /* HOUR */],
  [Isoweeknum, "ISOWEEKNUM" /* ISOWEEKNUM */],
  [Minute, "MINUTE" /* MINUTE */],
  [Month, "MONTH" /* MONTH */],
  [Networkdays, "NETWORKDAYS" /* NETWORKDAYS */],
  [NetworkdaysIntl, "NETWORKDAYS.INTL" /* NETWORKDAYS_INTL */],
  [Now, "NOW" /* NOW */],
  [Second, "SECOND" /* SECOND */],
  [Time, "TIME" /* TIME */],
  [Timevalue, "TIMEVALUE" /* TIMEVALUE */],
  [ToDate, "TO_DATE" /* TO_DATE */],
  [Today, "TODAY" /* TODAY */],
  [Weekday, "WEEKDAY" /* WEEKDAY */],
  [Weeknum, "WEEKNUM" /* WEEKNUM */],
  [Workday, "WORKDAY" /* WORKDAY */],
  [WorkdayIntl, "WORKDAY.INTL" /* WORKDAY_INTL */],
  [Year, "YEAR" /* YEAR */],
  [Yearfrac, "YEARFRAC" /* YEARFRAC */]
];

// ../packages/engine-formula/src/functions/engineering/besseli/index.ts
var Besseli = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(x, n) {
    if (x.isNull() || n.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x, n);
    if (isError) {
      return errorObject;
    }
    const [xObject, nObject] = variants;
    const xValue = +xObject.getValue();
    const nValue = Math.floor(+nObject.getValue());
    if (Number.isNaN(xValue) || Number.isNaN(nValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (nValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = BESSEL.besseli(xValue, nValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/besselj/index.ts
var Besselj = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(x, n) {
    if (x.isNull() || n.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x, n);
    if (isError) {
      return errorObject;
    }
    const [xObject, nObject] = variants;
    const xValue = +xObject.getValue();
    const nValue = Math.floor(+nObject.getValue());
    if (Number.isNaN(xValue) || Number.isNaN(nValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (nValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = BESSEL.besselj(xValue, nValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/besselk/index.ts
var Besselk = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(x, n) {
    if (x.isNull() || n.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x, n);
    if (isError) {
      return errorObject;
    }
    const [xObject, nObject] = variants;
    const xValue = +xObject.getValue();
    const nValue = Math.floor(+nObject.getValue());
    if (Number.isNaN(xValue) || Number.isNaN(nValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (nValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = BESSEL.besselk(xValue, nValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/bessely/index.ts
var Bessely = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(x, n) {
    if (x.isNull() || n.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x, n);
    if (isError) {
      return errorObject;
    }
    const [xObject, nObject] = variants;
    const xValue = +xObject.getValue();
    const nValue = Math.floor(+nObject.getValue());
    if (Number.isNaN(xValue) || Number.isNaN(nValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (nValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = BESSEL.bessely(xValue, nValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/bin2dec/index.ts
var Bin2dec = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidBinaryNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (numberValue.length === 10 && numberValue.substring(0, 1) === "1") {
      result = Number.parseInt(numberValue.substring(1), 2) - 512;
    } else {
      result = Number.parseInt(numberValue, 2);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/bin2hex/index.ts
var Bin2hex = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidBinaryNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (numberValue.length === 10 && numberValue.substring(0, 1) === "1") {
      result = (1099511627264 + Number.parseInt(numberValue.substring(1), 2)).toString(16);
    } else {
      result = Number.parseInt(numberValue, 2).toString(16);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result.toLocaleUpperCase());
  }
};

// ../packages/engine-formula/src/functions/engineering/bin2oct/index.ts
var Bin2oct = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidBinaryNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (numberValue.length === 10 && numberValue.substring(0, 1) === "1") {
      result = (1073741312 + Number.parseInt(numberValue.substring(1), 2)).toString(8);
    } else {
      result = Number.parseInt(numberValue, 2).toString(8);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/bitand/index.ts
var Bitand = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number1, number2) {
    if (number1.isError()) {
      return number1;
    }
    if (number2.isError()) {
      return number2;
    }
    const maxRowLength = Math.max(
      number1.isArray() ? number1.getRowCount() : 1,
      number2.isArray() ? number2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number1.isArray() ? number1.getColumnCount() : 1,
      number2.isArray() ? number2.getColumnCount() : 1
    );
    const number1Array = expandArrayValueObject(maxRowLength, maxColumnLength, number1, ErrorValueObject.create("#N/A" /* NA */));
    const number2Array = expandArrayValueObject(maxRowLength, maxColumnLength, number2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = number1Array.map((itemObject, rowIndex, columnIndex) => {
      let number1Object = itemObject;
      if (number1Object.isString()) {
        number1Object = number1Object.convertToNumberObjectValue();
      }
      if (number1Object.isError()) {
        return number1Object;
      }
      let number2Object = number2Array.get(rowIndex, columnIndex);
      if (number2Object.isString()) {
        number2Object = number2Object.convertToNumberObjectValue();
      }
      if (number2Object.isError()) {
        return number2Object;
      }
      const number1Value = +number1Object.getValue();
      const number2Value = +number2Object.getValue();
      if (number1Value < 0 || number2Value < 0 || Math.floor(number1Value) !== number1Value || Math.floor(number2Value) !== number2Value || number1Value > 281474976710655 || number2Value > 281474976710655) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = number1Value & number2Value;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/engineering/bitlshift/index.ts
var Bitlshift = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, shiftAmount) {
    if (number.isError()) {
      return number;
    }
    if (shiftAmount.isError()) {
      return shiftAmount;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      shiftAmount.isArray() ? shiftAmount.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      shiftAmount.isArray() ? shiftAmount.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const shiftAmountArray = expandArrayValueObject(maxRowLength, maxColumnLength, shiftAmount, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((itemObject, rowIndex, columnIndex) => {
      let numberObject = itemObject;
      if (numberObject.isString()) {
        numberObject = numberObject.convertToNumberObjectValue();
      }
      if (numberObject.isError()) {
        return numberObject;
      }
      let shiftAmountObject = shiftAmountArray.get(rowIndex, columnIndex);
      if (shiftAmountObject.isString()) {
        shiftAmountObject = shiftAmountObject.convertToNumberObjectValue();
      }
      if (shiftAmountObject.isError()) {
        return shiftAmountObject;
      }
      const numberValue = +numberObject.getValue();
      let shiftAmountValue = +shiftAmountObject.getValue();
      if (numberValue < 0 || Math.floor(numberValue) !== numberValue || numberValue > 281474976710655 || Math.abs(shiftAmountValue) > 53) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      shiftAmountValue = Math.trunc(shiftAmountValue);
      const result = Number(shiftAmountValue >= 0 ? BigInt(numberValue) << BigInt(shiftAmountValue) : BigInt(numberValue) >> BigInt(-shiftAmountValue));
      if (result > 281474976710655) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/engineering/bitor/index.ts
var Bitor = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number1, number2) {
    if (number1.isError()) {
      return number1;
    }
    if (number2.isError()) {
      return number2;
    }
    const maxRowLength = Math.max(
      number1.isArray() ? number1.getRowCount() : 1,
      number2.isArray() ? number2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number1.isArray() ? number1.getColumnCount() : 1,
      number2.isArray() ? number2.getColumnCount() : 1
    );
    const number1Array = expandArrayValueObject(maxRowLength, maxColumnLength, number1, ErrorValueObject.create("#N/A" /* NA */));
    const number2Array = expandArrayValueObject(maxRowLength, maxColumnLength, number2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = number1Array.map((itemObject, rowIndex, columnIndex) => {
      let number1Object = itemObject;
      if (number1Object.isString()) {
        number1Object = number1Object.convertToNumberObjectValue();
      }
      if (number1Object.isError()) {
        return number1Object;
      }
      let number2Object = number2Array.get(rowIndex, columnIndex);
      if (number2Object.isString()) {
        number2Object = number2Object.convertToNumberObjectValue();
      }
      if (number2Object.isError()) {
        return number2Object;
      }
      const number1Value = +number1Object.getValue();
      const number2Value = +number2Object.getValue();
      if (number1Value < 0 || number2Value < 0 || Math.floor(number1Value) !== number1Value || Math.floor(number2Value) !== number2Value || number1Value > 281474976710655 || number2Value > 281474976710655) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Number(BigInt(number1Value) | BigInt(number2Value));
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/engineering/bitrshift/index.ts
var Bitrshift = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, shiftAmount) {
    if (number.isError()) {
      return number;
    }
    if (shiftAmount.isError()) {
      return shiftAmount;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      shiftAmount.isArray() ? shiftAmount.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      shiftAmount.isArray() ? shiftAmount.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const shiftAmountArray = expandArrayValueObject(maxRowLength, maxColumnLength, shiftAmount, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((itemObject, rowIndex, columnIndex) => {
      let numberObject = itemObject;
      if (numberObject.isString()) {
        numberObject = numberObject.convertToNumberObjectValue();
      }
      if (numberObject.isError()) {
        return numberObject;
      }
      let shiftAmountObject = shiftAmountArray.get(rowIndex, columnIndex);
      if (shiftAmountObject.isString()) {
        shiftAmountObject = shiftAmountObject.convertToNumberObjectValue();
      }
      if (shiftAmountObject.isError()) {
        return shiftAmountObject;
      }
      const numberValue = +numberObject.getValue();
      let shiftAmountValue = +shiftAmountObject.getValue();
      if (numberValue < 0 || Math.floor(numberValue) !== numberValue || numberValue > 281474976710655 || Math.abs(shiftAmountValue) > 53) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      shiftAmountValue = Math.trunc(shiftAmountValue);
      const result = Number(shiftAmountValue >= 0 ? BigInt(numberValue) >> BigInt(shiftAmountValue) : BigInt(numberValue) << BigInt(-shiftAmountValue));
      if (result > 281474976710655) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/engineering/bitxor/index.ts
var Bitxor = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number1, number2) {
    if (number1.isError()) {
      return number1;
    }
    if (number2.isError()) {
      return number2;
    }
    const maxRowLength = Math.max(
      number1.isArray() ? number1.getRowCount() : 1,
      number2.isArray() ? number2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number1.isArray() ? number1.getColumnCount() : 1,
      number2.isArray() ? number2.getColumnCount() : 1
    );
    const number1Array = expandArrayValueObject(maxRowLength, maxColumnLength, number1, ErrorValueObject.create("#N/A" /* NA */));
    const number2Array = expandArrayValueObject(maxRowLength, maxColumnLength, number2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = number1Array.map((itemObject, rowIndex, columnIndex) => {
      let number1Object = itemObject;
      if (number1Object.isString()) {
        number1Object = number1Object.convertToNumberObjectValue();
      }
      if (number1Object.isError()) {
        return number1Object;
      }
      let number2Object = number2Array.get(rowIndex, columnIndex);
      if (number2Object.isString()) {
        number2Object = number2Object.convertToNumberObjectValue();
      }
      if (number2Object.isError()) {
        return number2Object;
      }
      const number1Value = +number1Object.getValue();
      const number2Value = +number2Object.getValue();
      if (number1Value < 0 || number2Value < 0 || Math.floor(number1Value) !== number1Value || Math.floor(number2Value) !== number2Value || number1Value > 281474976710655 || number2Value > 281474976710655) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = number1Value ^ number2Value;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/basics/complex.ts
decimal_default.prototype.cos = function() {
  const num = this.toNumber();
  return new decimal_default(Math.cos(num));
};
var Complex = class _Complex {
  constructor(inumber) {
    __publicField(this, "_inumber", "");
    __publicField(this, "_realNum", 0);
    __publicField(this, "_iNum", 0);
    __publicField(this, "_suffix", "");
    __publicField(this, "_isError", false);
    if (`${inumber}`.trim() === "") {
      this._isError = true;
      return;
    }
    this._inumber = inumber;
    this._getImReal();
    this._getImAginary();
    this._getImSuffix();
  }
  static getComplex(realNum, iNum, suffix) {
    const _realNum = new decimal_default(realNum).toSignificantDigits(15).toNumber();
    const _iNum = new decimal_default(iNum).toSignificantDigits(15).toNumber();
    const _suffix = suffix === "" ? "i" : suffix;
    let result;
    if (_realNum === 0 && _iNum === 0) {
      result = 0;
    } else if (_realNum === 0) {
      result = _iNum === 1 ? _suffix : `${_iNum}${_suffix}`;
    } else if (_iNum === 0) {
      result = _realNum;
    } else {
      const sign2 = _iNum > 0 ? "+" : "";
      const suffixStr = _iNum === 1 ? _suffix : `${_iNum}${_suffix}`;
      result = `${_realNum}${sign2}${suffixStr}`;
    }
    return result;
  }
  static createByComplexStr(realNum, iNum, suffix) {
    const complexStr = _Complex.getComplex(realNum, iNum, suffix);
    return new _Complex(complexStr);
  }
  _getImReal() {
    if (this._inumber === 0 || this._inumber === "0") {
      this._realNum = 0;
      return;
    }
    const inumberStr = `${this._inumber}`;
    if (["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(inumberStr) >= 0) {
      this._realNum = 0;
      return;
    }
    let plus2 = inumberStr.indexOf("+");
    let minus2 = inumberStr.indexOf("-");
    if (plus2 === 0) {
      plus2 = inumberStr.indexOf("+", 1);
    }
    if (minus2 === 0) {
      minus2 = inumberStr.indexOf("-", 1);
    }
    const last = inumberStr.substring(inumberStr.length - 1, inumberStr.length);
    const unit = last === "i" || last === "j";
    if (plus2 >= 0 || minus2 >= 0) {
      if (!unit) {
        this._isError = true;
        return;
      }
      if (plus2 >= 0) {
        if (Number.isNaN(+inumberStr.substring(0, plus2)) || Number.isNaN(+inumberStr.substring(plus2 + 1, inumberStr.length - 1))) {
          this._isError = true;
        } else {
          this._realNum = +inumberStr.substring(0, plus2);
        }
      } else {
        if (Number.isNaN(+inumberStr.substring(0, minus2)) || Number.isNaN(+inumberStr.substring(minus2 + 1, inumberStr.length - 1))) {
          this._isError = true;
        } else {
          this._realNum = +inumberStr.substring(0, minus2);
        }
      }
    } else {
      if (unit) {
        if (Number.isNaN(+inumberStr.substring(0, inumberStr.length - 1))) {
          this._isError = true;
        } else {
          this._realNum = 0;
        }
      } else {
        if (Number.isNaN(+inumberStr)) {
          this._isError = true;
        } else {
          this._realNum = +inumberStr;
        }
      }
    }
  }
  _getImAginary() {
    if (this._isError) {
      return;
    }
    if (this._inumber === 0 || this._inumber === "0") {
      this._iNum = 0;
      return;
    }
    let inumberStr = `${this._inumber}`;
    if (["i", "j"].indexOf(inumberStr) >= 0) {
      this._iNum = 1;
      return;
    }
    inumberStr = inumberStr.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
    let plus2 = inumberStr.indexOf("+");
    let minus2 = inumberStr.indexOf("-");
    if (plus2 === 0) {
      plus2 = inumberStr.indexOf("+", 1);
    }
    if (minus2 === 0) {
      minus2 = inumberStr.indexOf("-", 1);
    }
    const last = inumberStr.substring(inumberStr.length - 1, inumberStr.length);
    const unit = last === "i" || last === "j";
    if (plus2 >= 0 || minus2 >= 0) {
      if (!unit) {
        this._isError = true;
        return;
      }
      if (plus2 >= 0) {
        if (Number.isNaN(+inumberStr.substring(0, plus2)) || Number.isNaN(+inumberStr.substring(plus2 + 1, inumberStr.length - 1))) {
          this._isError = true;
        } else {
          this._iNum = +inumberStr.substring(plus2 + 1, inumberStr.length - 1);
        }
      } else {
        if (Number.isNaN(+inumberStr.substring(0, minus2)) || Number.isNaN(+inumberStr.substring(minus2 + 1, inumberStr.length - 1))) {
          this._isError = true;
        } else {
          this._iNum = -+inumberStr.substring(minus2 + 1, inumberStr.length - 1);
        }
      }
    } else {
      if (unit) {
        if (Number.isNaN(+inumberStr.substring(0, inumberStr.length - 1))) {
          this._isError = true;
        } else {
          this._iNum = +inumberStr.substring(0, inumberStr.length - 1);
        }
      } else {
        if (Number.isNaN(+inumberStr)) {
          this._isError = true;
        } else {
          this._iNum = 0;
        }
      }
    }
  }
  _getImSuffix() {
    const inumberStr = `${this._inumber}`;
    const suffix = inumberStr.substring(inumberStr.length - 1);
    this._suffix = suffix === "i" || suffix === "j" ? suffix : "";
  }
  getRealNum() {
    return this._realNum;
  }
  getINum() {
    return this._iNum;
  }
  getSuffix() {
    return this._suffix;
  }
  isError() {
    return this._isError;
  }
  toString() {
    return _Complex.getComplex(this._realNum, this._iNum, this._suffix);
  }
  isDifferentSuffixes(complex2) {
    const suffix2 = complex2.getSuffix();
    if (this._suffix === "" || suffix2 === "") {
      return false;
    }
    return this._suffix !== suffix2;
  }
  Abs() {
    const result = decimal_default.sqrt(decimal_default.pow(this._realNum, 2).add(decimal_default.pow(this._iNum, 2))).toSignificantDigits(16).toNumber();
    return result;
  }
  Argument() {
    const abs2 = decimal_default.sqrt(decimal_default.pow(this._realNum, 2).add(decimal_default.pow(this._iNum, 2)));
    let result = decimal_default.acos(new decimal_default(this._realNum).div(abs2)).toSignificantDigits(16).toNumber();
    if (this._iNum < 0) {
      result = -result;
    }
    return result;
  }
  Conjugate() {
    return _Complex.getComplex(this._realNum, -this._iNum, this._suffix);
  }
  Cos() {
    if (this._iNum) {
      const realNum = decimal_default.cos(this._realNum).mul(decimal_default.cosh(this._iNum)).toNumber();
      const iNum = decimal_default.sin(this._realNum).mul(decimal_default.sinh(this._iNum)).negated().toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = decimal_default.cos(this._realNum).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Cosh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum))) {
      this._isError = true;
      return "";
    }
    if (this._iNum) {
      const realNum = decimal_default.cosh(this._realNum).mul(decimal_default.cos(this._iNum)).toNumber();
      const iNum = decimal_default.sinh(this._realNum).mul(decimal_default.sin(this._iNum)).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = decimal_default.cosh(this._realNum).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Cot() {
    if (this._iNum) {
      const den = decimal_default.cosh(this._iNum * 2).sub(decimal_default.cos(this._realNum * 2));
      const realNum = decimal_default.sin(this._realNum * 2).div(den).toNumber();
      const iNum = decimal_default.sinh(this._iNum * 2).div(den).negated().toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = new decimal_default(1).div(decimal_default.tan(this._realNum)).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Coth() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum))) {
      this._isError = true;
      return "";
    }
    if (this._iNum) {
      const den = decimal_default.cosh(this._realNum * 2).sub(decimal_default.cos(this._iNum * 2));
      const realNum = decimal_default.sinh(this._realNum * 2).div(den).toNumber();
      const iNum = decimal_default.sin(this._iNum * 2).div(den).negated().toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = new decimal_default(1).div(decimal_default.tanh(this._realNum)).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Csc() {
    if (this._iNum) {
      const den = decimal_default.cosh(this._iNum * 2).sub(decimal_default.cos(this._realNum * 2));
      const realNum = decimal_default.sin(this._realNum).mul(decimal_default.cosh(this._iNum)).mul(2).div(den).toNumber();
      const iNum = decimal_default.cos(this._realNum).mul(decimal_default.sinh(this._iNum)).mul(-2).div(den).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = new decimal_default(1).div(decimal_default.sin(this._realNum)).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Csch() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum))) {
      return _Complex.getComplex(0, 0, this._suffix);
    }
    if (this._iNum) {
      const den = decimal_default.cosh(this._realNum * 2).sub(decimal_default.cos(this._iNum * 2));
      const realNum = decimal_default.sinh(this._realNum).mul(decimal_default.cos(this._iNum)).mul(2).div(den).toNumber();
      const iNum = decimal_default.cosh(this._realNum).mul(decimal_default.sin(this._iNum)).mul(-2).div(den).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = new decimal_default(1).div(decimal_default.sinh(this._realNum)).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Div(complex2) {
    const Decimal_realNum1 = new decimal_default(this._realNum);
    const Decimal_iNum1 = new decimal_default(this._iNum);
    const Decimal_realNum2 = new decimal_default(complex2.getRealNum());
    const Decimal_iNum2 = new decimal_default(complex2.getINum());
    const den = Decimal_realNum2.mul(Decimal_realNum2).add(Decimal_iNum2.mul(Decimal_iNum2));
    const realNum = Decimal_realNum1.mul(Decimal_realNum2).add(Decimal_iNum1.mul(Decimal_iNum2)).div(den).toNumber();
    const iNum = Decimal_iNum1.mul(Decimal_realNum2).sub(Decimal_realNum1.mul(Decimal_iNum2)).div(den).toNumber();
    const suffix = this._suffix === "" ? complex2.getSuffix() : this._suffix;
    return _Complex.getComplex(realNum, iNum, suffix);
  }
  Exp() {
    if (!Number.isFinite(Math.exp(this._realNum))) {
      this._isError = true;
      return "";
    }
    const realNum = decimal_default.exp(this._realNum).mul(decimal_default.cos(this._iNum)).toNumber();
    const iNum = decimal_default.exp(this._realNum).mul(decimal_default.sin(this._iNum)).toNumber();
    return _Complex.getComplex(realNum, iNum, this._suffix);
  }
  Ln() {
    const abs2 = decimal_default.sqrt(decimal_default.pow(this._realNum, 2).add(decimal_default.pow(this._iNum, 2)));
    const realNum = decimal_default.ln(abs2).toNumber();
    const iNum = decimal_default.acos(new decimal_default(this._realNum).div(abs2)).toNumber();
    return _Complex.getComplex(realNum, iNum, this._suffix);
  }
  Log(base) {
    const abs2 = decimal_default.sqrt(decimal_default.pow(this._realNum, 2).add(decimal_default.pow(this._iNum, 2)));
    const Decimal_realNum1 = decimal_default.ln(abs2);
    let Decimal_iNum1 = decimal_default.acos(new decimal_default(this._realNum).div(abs2));
    if (this._iNum < 0) {
      Decimal_iNum1 = Decimal_iNum1.negated();
    }
    const Decimal_realNum2 = decimal_default.ln(base);
    const Decimal_iNum2 = new decimal_default(0);
    const den = Decimal_realNum2.mul(Decimal_realNum2).add(Decimal_iNum2.mul(Decimal_iNum2));
    if (den.eq(0)) {
      this._isError = true;
      return "";
    }
    const realNum = Decimal_realNum1.mul(Decimal_realNum2).add(Decimal_iNum1.mul(Decimal_iNum2)).div(den).toNumber();
    const iNum = Decimal_iNum1.mul(Decimal_realNum2).sub(Decimal_realNum1.mul(Decimal_iNum2)).div(den).toNumber();
    return _Complex.getComplex(realNum, iNum, this._suffix);
  }
  Power(number) {
    if (this._realNum === 0 && this._iNum === 0) {
      if (number > 0) {
        return _Complex.getComplex(this._realNum, this._iNum, this._suffix);
      } else {
        this._isError = true;
        return "";
      }
    }
    let power = decimal_default.sqrt(decimal_default.pow(this._realNum, 2).add(decimal_default.pow(this._iNum, 2)));
    let phi = decimal_default.acos(new decimal_default(this._realNum).div(power));
    if (this._iNum < 0) {
      phi = phi.negated();
    }
    power = decimal_default.pow(power, number);
    phi = phi.mul(number);
    const realNum = decimal_default.cos(phi).mul(power).toNumber();
    const iNum = decimal_default.sin(phi).mul(power).toNumber();
    if (!Number.isFinite(realNum) || !Number.isFinite(iNum)) {
      this._isError = true;
      return "";
    }
    return _Complex.getComplex(realNum, iNum, this._suffix);
  }
  Product(complex2) {
    const Decimal_realNum1 = new decimal_default(this._realNum);
    const Decimal_iNum1 = new decimal_default(this._iNum);
    const Decimal_realNum2 = new decimal_default(complex2.getRealNum());
    const Decimal_iNum2 = new decimal_default(complex2.getINum());
    const realNum = Decimal_realNum1.mul(Decimal_realNum2).sub(Decimal_iNum1.mul(Decimal_iNum2)).toNumber();
    const iNum = Decimal_realNum1.mul(Decimal_iNum2).add(Decimal_iNum1.mul(Decimal_realNum2)).toNumber();
    const suffix = this._suffix === "" ? complex2.getSuffix() : this._suffix;
    return _Complex.getComplex(realNum, iNum, suffix);
  }
  Sec() {
    if (this._iNum) {
      const den = decimal_default.cosh(this._iNum * 2).add(decimal_default.cos(this._realNum * 2));
      const realNum = decimal_default.cos(this._realNum).mul(decimal_default.cosh(this._iNum)).mul(2).div(den).toNumber();
      const iNum = decimal_default.sin(this._realNum).mul(decimal_default.sinh(this._iNum)).mul(2).div(den).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = new decimal_default(1).div(decimal_default.cos(this._realNum)).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Sech() {
    if (!Number.isFinite(Math.sinh(this._realNum * 2)) || !Number.isFinite(Math.cosh(this._realNum * 2))) {
      return _Complex.getComplex(0, 0, this._suffix);
    }
    if (this._iNum) {
      const den = decimal_default.cosh(this._realNum * 2).add(decimal_default.cos(this._iNum * 2));
      const realNum = decimal_default.cosh(this._realNum).mul(decimal_default.cos(this._iNum)).mul(2).div(den).toNumber();
      const iNum = decimal_default.sinh(this._realNum).mul(decimal_default.sin(this._iNum)).mul(-2).div(den).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = new decimal_default(1).div(decimal_default.cosh(this._realNum)).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Sin() {
    if (this._iNum) {
      const realNum = decimal_default.sin(this._realNum).mul(decimal_default.cosh(this._iNum)).toNumber();
      const iNum = decimal_default.cos(this._realNum).mul(decimal_default.sinh(this._iNum)).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = decimal_default.sin(this._realNum).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Sinh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum))) {
      this._isError = true;
      return "";
    }
    if (this._iNum) {
      const realNum = decimal_default.sinh(this._realNum).mul(decimal_default.cos(this._iNum)).toNumber();
      const iNum = decimal_default.cosh(this._realNum).mul(decimal_default.sin(this._iNum)).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = decimal_default.sinh(this._realNum).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Sqrt() {
    const abs2 = decimal_default.sqrt(decimal_default.pow(this._realNum, 2).add(decimal_default.pow(this._iNum, 2)));
    const abs_sqrt = decimal_default.sqrt(abs2);
    let arg = decimal_default.acos(new decimal_default(this._realNum).div(abs2));
    if (this._iNum < 0) {
      arg = arg.negated();
    }
    const realNum = abs_sqrt.mul(decimal_default.cos(arg.div(2).toNumber())).toNumber();
    const iNum = abs_sqrt.mul(decimal_default.sin(arg.div(2))).toNumber();
    return _Complex.getComplex(realNum, iNum, this._suffix);
  }
  Sub(complex2) {
    const Decimal_realNum1 = new decimal_default(this._realNum);
    const Decimal_iNum1 = new decimal_default(this._iNum);
    const Decimal_realNum2 = new decimal_default(complex2.getRealNum());
    const Decimal_iNum2 = new decimal_default(complex2.getINum());
    const realNum = Decimal_realNum1.sub(Decimal_realNum2).toNumber();
    const iNum = Decimal_iNum1.sub(Decimal_iNum2).toNumber();
    const suffix = this._suffix === "" ? complex2.getSuffix() : this._suffix;
    return _Complex.getComplex(realNum, iNum, suffix);
  }
  Sum(complex2) {
    const Decimal_realNum1 = new decimal_default(this._realNum);
    const Decimal_iNum1 = new decimal_default(this._iNum);
    const Decimal_realNum2 = new decimal_default(complex2.getRealNum());
    const Decimal_iNum2 = new decimal_default(complex2.getINum());
    const realNum = Decimal_realNum1.add(Decimal_realNum2).toNumber();
    const iNum = Decimal_iNum1.add(Decimal_iNum2).toNumber();
    const suffix = this._suffix === "" ? complex2.getSuffix() : this._suffix;
    return _Complex.getComplex(realNum, iNum, suffix);
  }
  Tan() {
    if (this._iNum) {
      const den = decimal_default.cos(this._realNum * 2).add(decimal_default.cosh(this._iNum * 2));
      const realNum = decimal_default.sin(this._realNum * 2).div(den).toNumber();
      const iNum = decimal_default.sinh(this._iNum * 2).div(den).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = decimal_default.tan(this._realNum).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
  Tanh() {
    if (!Number.isFinite(Math.sinh(this._realNum)) || !Number.isFinite(Math.cosh(this._realNum))) {
      this._isError = true;
      return "";
    }
    if (this._iNum) {
      const den = decimal_default.cosh(this._realNum * 2).add(decimal_default.cos(this._iNum * 2));
      const realNum = decimal_default.sinh(this._realNum * 2).div(den).toNumber();
      const iNum = decimal_default.sin(this._iNum * 2).div(den).toNumber();
      return _Complex.getComplex(realNum, iNum, this._suffix);
    } else {
      const realNum = decimal_default.tanh(this._realNum).toNumber();
      return _Complex.getComplex(realNum, this._iNum, this._suffix);
    }
  }
};

// ../packages/engine-formula/src/functions/engineering/complex/index.ts
var Complex2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(realNum, iNum, suffix) {
    const _suffix = suffix != null ? suffix : StringValueObject.create("i");
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(realNum, iNum, _suffix);
    if (isError) {
      return errorObject;
    }
    const [realNumObject, iNumObject, suffixObject] = variants;
    const realNumValue = +realNumObject.getValue();
    const iNumValue = +iNumObject.getValue();
    const suffixValue = `${suffixObject.getValue()}`;
    if (Number.isNaN(realNumValue) || Number.isNaN(iNumValue) || suffixValue !== "i" && suffixValue !== "j") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = Complex.getComplex(realNumValue, iNumValue, suffixValue);
    if (typeof result === "number") {
      return NumberValueObject.create(result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/convert/index.ts
var Convert = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
    // List of units supported by CONVERT and units defined by the International System of Units
    // [Name, Symbol, Alternate symbols, Quantity, ISU, CONVERT, Conversion ratio]
    __publicField(this, "_units", [
      ["a.u. of action", "?", null, "action", false, false, 105457168181818e-48],
      ["a.u. of charge", "e", null, "electric_charge", false, false, 160217653141414e-33],
      ["a.u. of energy", "Eh", null, "energy", false, false, 435974417757576e-32],
      ["a.u. of length", "a?", null, "length", false, false, 529177210818182e-25],
      ["a.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
      ["a.u. of time", "?/Eh", null, "time", false, false, 241888432650516e-31],
      ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
      ["ampere", "A", null, "electric_current", true, false, 1],
      ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
      ["\xE5ngstr\xF6m", "\xC5", ["ang"], "length", false, true, 1e-10],
      ["are", "ar", null, "area", false, true, 100],
      ["astronomical unit", "ua", null, "length", false, false, 149597870691667e-25],
      ["bar", "bar", null, "pressure", false, false, 1e5],
      ["barn", "b", null, "area", false, false, 1e-28],
      ["becquerel", "Bq", null, "radioactivity", true, false, 1],
      ["bit", "bit", ["b"], "information", false, true, 1],
      ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
      ["byte", "byte", null, "information", false, true, 8],
      ["candela", "cd", null, "luminous_intensity", true, false, 1],
      ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
      ["centigrade", "C", ["cel"], "temperature", true, false, 1],
      ["cubic \xE5ngstr\xF6m", "ang3", ["ang^3"], "volume", false, true, 1e-30],
      ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
      ["cubic inch", "in3", ["in^3"], "volume", false, true, 16387064e-12],
      ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 846786664623715e-61],
      ["cubic metre", "m3", ["m^3"], "volume", true, true, 1],
      ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 416818182544058e-5],
      ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
      ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 758660370370369e-22],
      ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
      ["cup", "cup", null, "volume", false, true, 2365882365e-13],
      ["dalton", "Da", ["u"], "mass", false, false, 166053886282828e-41],
      ["day", "d", ["day"], "time", false, true, 86400],
      ["degree", "\xB0", null, "angle", false, false, 0.0174532925199433],
      ["dyne", "dyn", ["dy"], "force", false, true, 1e-5],
      ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
      ["ell", "ell", null, "length", false, true, 1.143],
      ["erg", "erg", ["e"], "energy", false, true, 1e-7],
      ["fahrenheit", "F", ["fah"], "temperature", true, false, 1],
      ["fluid ounce", "oz", null, "volume", false, true, 295735295625e-16],
      ["foot", "ft", null, "length", false, true, 0.3048],
      ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
      ["gal", "Gal", null, "acceleration", false, false, 0.01],
      ["gallon", "gal", null, "volume", false, true, 0.003785411784],
      ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
      ["grain", "grain", null, "mass", false, true, 647989e-10],
      ["gram", "g", null, "mass", false, true, 1e-3],
      ["gray", "Gy", null, "absorbed_dose", true, false, 1],
      ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
      ["hectare", "ha", null, "area", false, true, 1e4],
      ["henry", "H", null, "inductance", true, false, 1],
      ["hertz", "Hz", null, "frequency", true, false, 1],
      ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
      ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519538e-3],
      ["hour", "h", ["hr"], "time", false, true, 3600],
      ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 454609e-8],
      ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
      ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
      ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
      ["inch", "in", null, "length", false, true, 0.0254],
      ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
      ["IT calorie", "cal", null, "energy", false, true, 4.1868],
      ["joule", "J", null, "energy", true, true, 1],
      ["katal", "kat", null, "catalytic_activity", true, false, 1],
      ["kelvin", "K", ["kel"], "temperature", true, true, 1],
      ["kilogram", "kg", null, "mass", true, true, 1],
      ["knot", "kn", null, "speed", false, true, 0.514444444444444],
      ["light-year", "ly", null, "length", false, true, 9460730472580800],
      ["litre", "L", ["l", "lt"], "volume", false, true, 1e-3],
      ["lumen", "lm", null, "luminous_flux", true, false, 1],
      ["lux", "lx", null, "illuminance", true, false, 1],
      ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
      ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
      ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 27777777777778e-17],
      ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
      ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
      ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
      ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
      ["metre", "m", null, "length", true, true, 1],
      ["miles per hour", "mph", null, "speed", false, true, 0.44704],
      ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
      ["minute", "?", null, "angle", false, false, 290888208665722e-18],
      ["minute", "min", ["mn"], "time", false, true, 60],
      ["modern teaspoon", "tspm", null, "volume", false, true, 5e-6],
      ["mole", "mol", null, "amount_of_substance", true, false, 1],
      ["morgen", "Morgen", null, "area", false, true, 2500],
      ["n.u. of action", "?", null, "action", false, false, 105457168181818e-48],
      ["n.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
      ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
      ["n.u. of time", "?/(me?c??)", null, "time", false, false, 128808866778687e-35],
      ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
      ["newton", "N", null, "force", true, true, 1],
      ["\u0153rsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
      ["ohm", "\u03A9", null, "electric_resistance", true, false, 1],
      ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
      ["pascal", "Pa", null, "pressure", true, false, 1],
      ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
      ["pferdest\xE4rke", "PS", null, "power", false, true, 735.49875],
      ["phot", "ph", null, "illuminance", false, false, 1e-4],
      ["pica (1/6 inch)", "pica", null, "length", false, true, 35277777777778e-17],
      ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
      ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
      ["pond", "pond", null, "force", false, true, 980665e-8],
      ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
      ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
      ["quart", "qt", null, "volume", false, true, 946352946e-12],
      ["radian", "rad", null, "angle", true, false, 1],
      ["rankine", "Rank", null, "temperature", false, true, 1],
      ["reaumur", "Reau", null, "temperature", false, true, 1],
      ["second", "?", null, "angle", false, false, 484813681109536e-20],
      ["second", "s", ["sec"], "time", true, true, 1],
      ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
      ["siemens", "S", null, "electrical_conductance", true, false, 1],
      ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
      ["slug", "sg", null, "mass", false, true, 14.59390294],
      ["square \xE5ngstr\xF6m", "ang2", ["ang^2"], "area", false, true, 1e-20],
      ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
      ["square inch", "in2", ["in^2"], "area", false, true, 64516e-8],
      ["square light-year", "ly2", ["ly^2"], "area", false, true, 895054210748189e17],
      ["square meter", "m?", null, "area", true, true, 1],
      ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988110336e-6],
      ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
      ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 1792111111111e-17],
      ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
      ["statute mile", "mi", null, "length", false, true, 1609.344],
      ["steradian", "sr", null, "solid_angle", true, false, 1],
      ["stilb", "sb", null, "luminance", false, false, 1e-4],
      ["stokes", "St", null, "kinematic_viscosity", false, false, 1e-4],
      ["stone", "stone", null, "mass", false, true, 6.35029318],
      ["tablespoon", "tbs", null, "volume", false, true, 147868e-10],
      ["teaspoon", "tsp", null, "volume", false, true, 492892e-11],
      ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
      ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
      ["ton", "ton", null, "mass", false, true, 907.18474],
      ["tonne", "t", null, "mass", false, false, 1e3],
      ["U.K. pint", "uk_pt", null, "volume", false, true, 56826125e-11],
      ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
      ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
      ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 473176473e-12],
      ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
      ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
      ["volt", "V", null, "voltage", true, false, 1],
      ["watt", "W", null, "power", true, true, 1],
      ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
      ["weber", "Wb", null, "magnetic_flux", true, false, 1],
      ["yard", "yd", null, "length", false, true, 0.9144],
      ["year", "yr", null, "time", false, true, 31557600]
    ]);
    // Binary prefixes
    // [Name, Prefix power of 2 value, Previx value, Abbreviation, Derived from]
    __publicField(this, "_binaryPrefixes", {
      Yi: ["yobi", 80, 12089258196146292e8, "Yi", "yotta"],
      Zi: ["zebi", 70, 11805916207174113e5, "Zi", "zetta"],
      Ei: ["exbi", 60, 1152921504606847e3, "Ei", "exa"],
      Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
      Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
      Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
      Mi: ["mebi", 20, 1048576, "Mi", "mega"],
      ki: ["kibi", 10, 1024, "ki", "kilo"]
    });
    // Unit prefixes
    // [Name, Multiplier, Abbreviation]
    __publicField(this, "_unitPrefixes", {
      Y: ["yotta", 1e24, "Y"],
      Z: ["zetta", 1e21, "Z"],
      E: ["exa", 1e18, "E"],
      P: ["peta", 1e15, "P"],
      T: ["tera", 1e12, "T"],
      G: ["giga", 1e9, "G"],
      M: ["mega", 1e6, "M"],
      k: ["kilo", 1e3, "k"],
      h: ["hecto", 100, "h"],
      e: ["dekao", 10, "e"],
      d: ["deci", 0.1, "d"],
      c: ["centi", 0.01, "c"],
      m: ["milli", 1e-3, "m"],
      u: ["micro", 1e-6, "u"],
      n: ["nano", 1e-9, "n"],
      p: ["pico", 1e-12, "p"],
      f: ["femto", 1e-15, "f"],
      a: ["atto", 1e-18, "a"],
      z: ["zepto", 1e-21, "z"],
      y: ["yocto", 1e-24, "y"]
    });
  }
  calculate(number, fromUnit, toUnit) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number, fromUnit, toUnit);
    if (isError) {
      return errorObject;
    }
    const [numberObject, fromUnitObject, toUnitObject] = variants;
    const numberValue = +numberObject.getValue();
    const fromUnitValue = `${fromUnitObject.getValue()}`;
    const toUnitValue = `${toUnitObject.getValue()}`;
    if (Number.isNaN(numberValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let from;
    let fromMultiplier = 1;
    let to;
    let toMultiplier = 1;
    const { _from, _to } = this._lookupFromAndToUnits(fromUnitValue, toUnitValue);
    from = _from;
    to = _to;
    if (from === null) {
      const { _from: _from2, _fromMultiplier } = this._lookupFromPrefix(fromUnitValue);
      from = _from2;
      fromMultiplier = _fromMultiplier;
    }
    if (to === null) {
      const { _to: _to2, _toMultiplier } = this._lookupToPrefix(toUnitValue);
      to = _to2;
      toMultiplier = _toMultiplier;
    }
    if (from === null || to === null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (from[3] !== to[3]) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let result;
    if (from[3] === "temperature") {
      result = this._getTemperatureConversion(numberValue, from[1], to[1]);
      result = +result.toFixed(2);
    } else {
      result = numberValue * from[6] * fromMultiplier / (to[6] * toMultiplier);
    }
    return NumberValueObject.create(result);
  }
  _lookupFromAndToUnits(fromUnitValue, toUnitValue) {
    let _from = null;
    let _to = null;
    let alt;
    for (let i = 0; i < this._units.length; i++) {
      alt = this._units[i][2] === null ? [] : this._units[i][2];
      if (this._units[i][1] === fromUnitValue || alt.indexOf(fromUnitValue) >= 0) {
        _from = this._units[i];
      }
      if (this._units[i][1] === toUnitValue || alt.indexOf(toUnitValue) >= 0) {
        _to = this._units[i];
      }
    }
    return {
      _from,
      _to
    };
  }
  _lookupFromPrefix(fromUnitValue) {
    let _from = null;
    let _fromMultiplier = 1;
    let baseFromUnit = fromUnitValue;
    let alt;
    const fromBinaryPrefix = this._binaryPrefixes[fromUnitValue.substring(0, 2)];
    let fromUnitPrefix = this._unitPrefixes[fromUnitValue.substring(0, 1)];
    if (fromUnitValue.substring(0, 2) === "da") {
      fromUnitPrefix = ["dekao", 10, "da"];
    }
    if (fromBinaryPrefix) {
      _fromMultiplier = fromBinaryPrefix[2];
      baseFromUnit = fromUnitValue.substring(2);
    } else if (fromUnitPrefix) {
      _fromMultiplier = fromUnitPrefix[1];
      baseFromUnit = fromUnitValue.substring(fromUnitPrefix[2].length);
    }
    for (let j = 0; j < this._units.length; j++) {
      alt = this._units[j][2] === null ? [] : this._units[j][2];
      if (this._units[j][1] === baseFromUnit || alt.indexOf(baseFromUnit) >= 0) {
        _from = this._units[j];
      }
    }
    return {
      _from,
      _fromMultiplier
    };
  }
  _lookupToPrefix(toUnitValue) {
    let _to = null;
    let _toMultiplier = 1;
    let baseToUnit = toUnitValue;
    let alt;
    const toBinaryPrefix = this._binaryPrefixes[toUnitValue.substring(0, 2)];
    let toUnitPrefix = this._unitPrefixes[toUnitValue.substring(0, 1)];
    if (toUnitValue.substring(0, 2) === "da") {
      toUnitPrefix = ["dekao", 10, "da"];
    }
    if (toBinaryPrefix) {
      _toMultiplier = toBinaryPrefix[2];
      baseToUnit = toUnitValue.substring(2);
    } else if (toUnitPrefix) {
      _toMultiplier = toUnitPrefix[1];
      baseToUnit = toUnitValue.substring(toUnitPrefix[2].length);
    }
    for (let k = 0; k < this._units.length; k++) {
      alt = this._units[k][2] === null ? [] : this._units[k][2];
      if (this._units[k][1] === baseToUnit || alt.indexOf(baseToUnit) >= 0) {
        _to = this._units[k];
      }
    }
    return {
      _to,
      _toMultiplier
    };
  }
  _getTemperatureConversion(number, from, to) {
    switch (from) {
      case "C":
        return this._centigradeConversion(number, to);
      case "F":
        return this._fahrenheitConversion(number, to);
      case "K":
        return this._kelvinConversion(number, to);
      case "Rank":
        return this._rankineConversion(number, to);
      case "Reau":
        return this._reaumurConversion(number, to);
      default:
        return number;
    }
  }
  _centigradeConversion(number, to) {
    switch (to) {
      case "F":
        return number * 9 / 5 + 32;
      case "K":
        return number + 273.15;
      case "Rank":
        return (number + 273.15) * 9 / 5;
      case "Reau":
        return number * 4 / 5;
      default:
        return number;
    }
  }
  _fahrenheitConversion(number, to) {
    switch (to) {
      case "C":
        return (number - 32) * 5 / 9;
      case "K":
        return (number - 32) * 5 / 9 + 273.15;
      case "Rank":
        return number + 459.67;
      case "Reau":
        return (number - 32) * 4 / 9;
      default:
        return number;
    }
  }
  _kelvinConversion(number, to) {
    switch (to) {
      case "C":
        return number - 273.15;
      case "F":
        return (number - 273.15) * 9 / 5 + 32;
      case "Rank":
        return number * 9 / 5;
      case "Reau":
        return (number - 273.15) * 4 / 5;
      default:
        return number;
    }
  }
  _rankineConversion(number, to) {
    switch (to) {
      case "C":
        return (number - 491.67) * 5 / 9;
      case "F":
        return number - 459.67;
      case "K":
        return number * 5 / 9;
      case "Reau":
        return (number - 491.67) * 4 / 9;
      default:
        return number;
    }
  }
  _reaumurConversion(number, to) {
    switch (to) {
      case "C":
        return number * 5 / 4;
      case "F":
        return number * 9 / 4 + 32;
      case "K":
        return number * 5 / 4 + 273.15;
      case "Rank":
        return number * 9 / 4 + 491.67;
      default:
        return number;
    }
  }
};

// ../packages/engine-formula/src/functions/engineering/dec2bin/index.ts
var Dec2bin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = Math.trunc(+numberObject.getValue());
    if (Number.isNaN(numberValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!/^-?[0-9]{1,3}$/.test(`${numberValue}`) || numberValue < -512 || numberValue > 511) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (numberValue < 0) {
      const toStr = (512 + numberValue).toString(2);
      result = `1${"0".repeat(9 - toStr.length)}${toStr}`;
    } else {
      result = Number.parseInt(`${numberValue}`, 10).toString(2);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/dec2hex/index.ts
var Dec2hex = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = Math.trunc(+numberObject.getValue());
    if (Number.isNaN(numberValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!/^-?[0-9]{1,12}$/.test(`${numberValue}`) || numberValue < -549755813888 || numberValue > 549755813887) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (numberValue < 0) {
      result = (1099511627776 + numberValue).toString(16);
    } else {
      result = Number.parseInt(`${numberValue}`, 10).toString(16);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result.toLocaleUpperCase());
  }
};

// ../packages/engine-formula/src/functions/engineering/dec2oct/index.ts
var Dec2oct = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = Math.trunc(+numberObject.getValue());
    if (Number.isNaN(numberValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!/^-?[0-9]{1,9}$/.test(`${numberValue}`) || numberValue < -536870912 || numberValue > 536870911) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (numberValue < 0) {
      result = (1073741824 + numberValue).toString(8);
    } else {
      result = Number.parseInt(`${numberValue}`, 10).toString(8);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/delta/index.ts
var Delta = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number1, number2) {
    const _number2 = number2 != null ? number2 : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number1, _number2);
    if (isError) {
      return errorObject;
    }
    const [number1Object, number2Object] = variants;
    const number1Value = +number1Object.getValue();
    const number2Value = +number2Object.getValue();
    if (Number.isNaN(number1Value) || Number.isNaN(number2Value)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = number1Value === number2Value ? 1 : 0;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/erf/index.ts
var Erf = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(lowerLimit, upperLimit) {
    let result;
    if (upperLimit) {
      const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(lowerLimit, upperLimit);
      if (isError) {
        return errorObject;
      }
      const [lowerLimitObject, upperLimitObject] = variants;
      const lowerLimitValue = +lowerLimitObject.getValue();
      const upperLimitValue = +upperLimitObject.getValue();
      if (Number.isNaN(lowerLimitValue) || Number.isNaN(upperLimitValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      result = erf(upperLimitValue) - erf(lowerLimitValue);
    } else {
      const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(lowerLimit);
      if (isError) {
        return errorObject;
      }
      const [lowerLimitObject] = variants;
      const lowerLimitValue = +lowerLimitObject.getValue();
      if (Number.isNaN(lowerLimitValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      result = erf(lowerLimitValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/erf-precise/index.ts
var ErfPrecise = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(x) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x);
    if (isError) {
      return errorObject;
    }
    const [xObject] = variants;
    const xValue = +xObject.getValue();
    if (Number.isNaN(xValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = erf(xValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/erfc/index.ts
var Erfc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(x) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x);
    if (isError) {
      return errorObject;
    }
    const [xObject] = variants;
    const xValue = +xObject.getValue();
    if (Number.isNaN(xValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = erfc(xValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/erfc-precise/index.ts
var ErfcPrecise = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(x) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x);
    if (isError) {
      return errorObject;
    }
    const [xObject] = variants;
    const xValue = +xObject.getValue();
    if (Number.isNaN(xValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = erfc(xValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/gestep/index.ts
var Gestep = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, step) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const _step = step != null ? step : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number, _step);
    if (isError) {
      return errorObject;
    }
    const [numberObject, stepObject] = variants;
    const numberValue = +numberObject.getValue();
    const stepValue = +stepObject.getValue();
    if (Number.isNaN(numberValue) || Number.isNaN(stepValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = numberValue >= stepValue ? 1 : 0;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/hex2bin/index.ts
var Hex2bin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidHexadecimalNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const negative = !!(numberValue.length === 10 && numberValue.substring(0, 1).toLocaleUpperCase() === "F");
    const decimal = negative ? Number.parseInt(numberValue, 16) - 1099511627776 : Number.parseInt(numberValue, 16);
    if (decimal < -512 || decimal > 511) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (negative) {
      const toStr = (512 + decimal).toString(2);
      result = `1${"0".repeat(9 - toStr.length)}${toStr}`;
    } else {
      result = decimal.toString(2);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/hex2dec/index.ts
var Hex2dec = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidHexadecimalNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = Number.parseInt(numberValue, 16);
    if (result >= 549755813888) {
      result -= 1099511627776;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/hex2oct/index.ts
var Hex2oct = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidHexadecimalNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const decimal = Number.parseInt(numberValue, 16);
    if (decimal > 536870911 && decimal < 1098974756864) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (decimal >= 1098974756864) {
      result = (decimal - 1098437885952).toString(8);
    } else {
      result = decimal.toString(8);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imabs/index.ts
var Imabs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Abs();
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imaginary/index.ts
var Imaginary = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.getINum();
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imargument/index.ts
var Imargument = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = complex.Argument();
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imconjugate/index.ts
var Imconjugate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Conjugate();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imcos/index.ts
var Imcos = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Cos();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imcosh/index.ts
var Imcosh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Cosh();
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imcot/index.ts
var Imcot = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Cot();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imcoth/index.ts
var Imcoth = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Coth();
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imcsc/index.ts
var Imcsc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Csc();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imcsch/index.ts
var Imcsch = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Csch();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imdiv/index.ts
var Imdiv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(inumber1, inumber2) {
    if (inumber1.isNull() || inumber2.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber1, inumber2);
    if (isError) {
      return errorObject;
    }
    const [inumber1Object, inumber2Object] = variants;
    const inumber1Value = `${inumber1Object.getValue()}`;
    const inumber2Value = `${inumber2Object.getValue()}`;
    const complex1 = new Complex(inumber1Value);
    const complex2 = new Complex(inumber2Value);
    if (complex1.isError() || complex2.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex1.isDifferentSuffixes(complex2)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex2.getRealNum() === 0 && complex2.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex1.Div(complex2);
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imexp/index.ts
var Imexp = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Exp();
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imln/index.ts
var Imln = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Ln();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imlog/index.ts
var Imlog = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(inumber, base) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    let _base = base != null ? base : NumberValueObject.create(10);
    if (_base.isArray()) {
      const rowCount = _base.getRowCount();
      const columnCount = _base.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _base = _base.get(0, 0);
    }
    const { isError: _isError, errorObject: _errorObject, variants: _variants } = checkVariantsErrorIsStringToNumber(_base);
    if (_isError) {
      return _errorObject;
    }
    const [baseObject] = _variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const baseValue = +baseObject.getValue();
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (baseValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Log(baseValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imlog2/index.ts
var Imlog2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Log(2);
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imlog10/index.ts
var Imlog10 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Log(10);
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/impower/index.ts
var Impower = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(inumber, number) {
    if (inumber.isNull() || number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber, number);
    if (isError) {
      return errorObject;
    }
    const [inumberObject, numberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const numberValue = +numberObject.getValue();
    if (Number.isNaN(numberValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = complex.Power(numberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/improduct/index.ts
var Improduct = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let result = "";
    for (let i = 0; i < variants.length; i++) {
      if (result instanceof ErrorValueObject) {
        return result;
      }
      const variant = variants[i];
      if (variant.isArray()) {
        let isError = false;
        let errorObject;
        variant.iterator((valueObject) => {
          result = this._handleSingleObject(valueObject, result);
          if (result instanceof ErrorValueObject) {
            isError = true;
            errorObject = result;
            return false;
          }
        });
        if (isError) {
          return errorObject;
        }
      } else {
        result = this._handleSingleObject(variant, result);
      }
    }
    if (result instanceof ErrorValueObject) {
      return result;
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
  _handleSingleObject(variant, result) {
    let _result = result;
    if (variant.isError()) {
      return variant;
    }
    if (variant.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const value = `${variant.getValue()}`;
    if (typeof result !== "number" && !result) {
      const complex = new Complex(value);
      if (complex.isError()) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      _result = complex.toString();
    } else {
      const complex1 = new Complex(result);
      const complex2 = new Complex(value);
      if (complex1.isError() || complex2.isError()) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (complex1.isDifferentSuffixes(complex2)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _result = complex1.Product(complex2);
    }
    return _result;
  }
};

// ../packages/engine-formula/src/functions/engineering/imreal/index.ts
var Imreal = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.getRealNum();
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imsec/index.ts
var Imsec = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Sec();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imsech/index.ts
var Imsech = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Sech();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imsin/index.ts
var Imsin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Sin();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imsinh/index.ts
var Imsinh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Sinh();
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imsqrt/index.ts
var Imsqrt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex.getRealNum() === 0 && complex.getINum() === 0) {
      return NumberValueObject.create(0);
    }
    const result = complex.Sqrt();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imsub/index.ts
var Imsub = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(inumber1, inumber2) {
    if (inumber1.isNull() || inumber2.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber1, inumber2);
    if (isError) {
      return errorObject;
    }
    const [inumber1Object, inumber2Object] = variants;
    const inumber1Value = `${inumber1Object.getValue()}`;
    const inumber2Value = `${inumber2Object.getValue()}`;
    const complex1 = new Complex(inumber1Value);
    const complex2 = new Complex(inumber2Value);
    if (complex1.isError() || complex2.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (complex1.isDifferentSuffixes(complex2)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex1.Sub(complex2);
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imsum/index.ts
var Imsum = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let result = "";
    for (let i = 0; i < variants.length; i++) {
      if (result instanceof ErrorValueObject) {
        return result;
      }
      const variant = variants[i];
      if (variant.isArray()) {
        let isError = false;
        let errorObject;
        variant.iterator((valueObject) => {
          result = this._handleSingleObject(valueObject, result);
          if (result instanceof ErrorValueObject) {
            isError = true;
            errorObject = result;
            return false;
          }
        });
        if (isError) {
          return errorObject;
        }
      } else {
        result = this._handleSingleObject(variant, result);
      }
    }
    if (result instanceof ErrorValueObject) {
      return result;
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
  _handleSingleObject(variant, result) {
    let _result = result;
    if (variant.isError()) {
      return variant;
    }
    if (variant.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const value = `${variant.getValue()}`;
    if (typeof result !== "number" && !result) {
      const complex = new Complex(value);
      if (complex.isError()) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      _result = complex.toString();
    } else {
      const complex1 = new Complex(result);
      const complex2 = new Complex(value);
      if (complex1.isError() || complex2.isError()) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (complex1.isDifferentSuffixes(complex2)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _result = complex1.Sum(complex2);
    }
    return _result;
  }
};

// ../packages/engine-formula/src/functions/engineering/imtan/index.ts
var Imtan = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Tan();
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/imtanh/index.ts
var Imtanh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(inumber) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(inumber);
    if (isError) {
      return errorObject;
    }
    const [inumberObject] = variants;
    const inumberValue = `${inumberObject.getValue()}`;
    const complex = new Complex(inumberValue);
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = complex.Tanh();
    if (complex.isError()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (typeof result === "number" || isRealNum(result)) {
      return NumberValueObject.create(+result);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/oct2bin/index.ts
var Oct2bin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidOctalNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const negative = !!(numberValue.length === 10 && numberValue.substring(0, 1) === "7");
    const decimal = negative ? Number.parseInt(numberValue, 8) - 1073741824 : Number.parseInt(numberValue, 8);
    if (decimal < -512 || decimal > 511) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (negative) {
      const toStr = (512 + decimal).toString(2);
      result = `1${"0".repeat(9 - toStr.length)}${toStr}`;
    } else {
      result = decimal.toString(2);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/oct2dec/index.ts
var Oct2dec = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidOctalNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = Number.parseInt(numberValue, 8);
    if (result >= 536870912) {
      result -= 1073741824;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/engineering/oct2hex/index.ts
var Oct2hex = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, places) {
    if (number.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let placesValue = 0;
    if (places) {
      const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsArrayOrBoolean(places);
      if (isError2) {
        return errorObject2;
      }
      const [placesObject] = variants2;
      placesValue = Math.floor(+placesObject.getValue());
      if (Number.isNaN(placesValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (placesValue < 0 || placesValue > 10) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = `${numberObject.getValue()}`;
    if (!isValidOctalNumber(numberValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const decimal = Number.parseInt(numberValue, 8);
    let result;
    if (decimal >= 536870912) {
      result = `ff${(decimal + 3221225472).toString(16)}`;
    } else {
      result = decimal.toString(16);
      if (places) {
        if (placesValue < result.length) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        result = "0".repeat(placesValue - result.length) + result;
      }
    }
    return StringValueObject.create(result.toLocaleUpperCase());
  }
};

// ../packages/engine-formula/src/functions/engineering/function-map.ts
var functionEngineering = [
  [Besseli, "BESSELI" /* BESSELI */],
  [Besselj, "BESSELJ" /* BESSELJ */],
  [Besselk, "BESSELK" /* BESSELK */],
  [Bessely, "BESSELY" /* BESSELY */],
  [Bin2dec, "BIN2DEC" /* BIN2DEC */],
  [Bin2hex, "BIN2HEX" /* BIN2HEX */],
  [Bin2oct, "BIN2OCT" /* BIN2OCT */],
  [Bitand, "BITAND" /* BITAND */],
  [Bitlshift, "BITLSHIFT" /* BITLSHIFT */],
  [Bitor, "BITOR" /* BITOR */],
  [Bitrshift, "BITRSHIFT" /* BITRSHIFT */],
  [Bitxor, "BITXOR" /* BITXOR */],
  [Complex2, "COMPLEX" /* COMPLEX */],
  [Convert, "CONVERT" /* CONVERT */],
  [Dec2bin, "DEC2BIN" /* DEC2BIN */],
  [Dec2hex, "DEC2HEX" /* DEC2HEX */],
  [Dec2oct, "DEC2OCT" /* DEC2OCT */],
  [Delta, "DELTA" /* DELTA */],
  [Erf, "ERF" /* ERF */],
  [ErfPrecise, "ERF.PRECISE" /* ERF_PRECISE */],
  [Erfc, "ERFC" /* ERFC */],
  [ErfcPrecise, "ERFC.PRECISE" /* ERFC_PRECISE */],
  [Gestep, "GESTEP" /* GESTEP */],
  [Hex2bin, "HEX2BIN" /* HEX2BIN */],
  [Hex2dec, "HEX2DEC" /* HEX2DEC */],
  [Hex2oct, "HEX2OCT" /* HEX2OCT */],
  [Imabs, "IMABS" /* IMABS */],
  [Imaginary, "IMAGINARY" /* IMAGINARY */],
  [Imargument, "IMARGUMENT" /* IMARGUMENT */],
  [Imconjugate, "IMCONJUGATE" /* IMCONJUGATE */],
  [Imcos, "IMCOS" /* IMCOS */],
  [Imcosh, "IMCOSH" /* IMCOSH */],
  [Imcot, "IMCOT" /* IMCOT */],
  [Imcoth, "IMCOTH" /* IMCOTH */],
  [Imcsc, "IMCSC" /* IMCSC */],
  [Imcsch, "IMCSCH" /* IMCSCH */],
  [Imdiv, "IMDIV" /* IMDIV */],
  [Imexp, "IMEXP" /* IMEXP */],
  [Imln, "IMLN" /* IMLN */],
  [Imlog, "IMLOG" /* IMLOG */],
  [Imlog10, "IMLOG10" /* IMLOG10 */],
  [Imlog2, "IMLOG2" /* IMLOG2 */],
  [Impower, "IMPOWER" /* IMPOWER */],
  [Improduct, "IMPRODUCT" /* IMPRODUCT */],
  [Imreal, "IMREAL" /* IMREAL */],
  [Imsec, "IMSEC" /* IMSEC */],
  [Imsech, "IMSECH" /* IMSECH */],
  [Imsin, "IMSIN" /* IMSIN */],
  [Imsinh, "IMSINH" /* IMSINH */],
  [Imsqrt, "IMSQRT" /* IMSQRT */],
  [Imsub, "IMSUB" /* IMSUB */],
  [Imsum, "IMSUM" /* IMSUM */],
  [Imtan, "IMTAN" /* IMTAN */],
  [Imtanh, "IMTANH" /* IMTANH */],
  [Oct2bin, "OCT2BIN" /* OCT2BIN */],
  [Oct2dec, "OCT2DEC" /* OCT2DEC */],
  [Oct2hex, "OCT2HEX" /* OCT2HEX */]
];

// ../packages/engine-formula/src/basics/financial.ts
function calculateCoupdaybs(settlementSerialNumber, maturitySerialNumber, frequency, basis) {
  const coupDateSerialNumber = calculateCouppcd(settlementSerialNumber, maturitySerialNumber, frequency);
  const { days } = getTwoDateDaysByBasis(coupDateSerialNumber, settlementSerialNumber, basis);
  return days;
}
function calculateCoupdays(settlementSerialNumber, maturitySerialNumber, frequency, basis) {
  let result;
  if (basis === 1) {
    const beforeSettlementDateSerialNumber = calculateCouppcd(settlementSerialNumber, maturitySerialNumber, frequency);
    let coupDate = excelSerialToDate(beforeSettlementDateSerialNumber);
    coupDate = dateAddMonths(coupDate, 12 / frequency);
    const afterSettlementDateSerialNumber = excelDateSerial(coupDate);
    if (beforeSettlementDateSerialNumber < 0 && frequency === 1) {
      result = 365;
    } else {
      result = afterSettlementDateSerialNumber - beforeSettlementDateSerialNumber;
    }
  } else if (basis === 3) {
    result = 365 / frequency;
  } else {
    result = 360 / frequency;
  }
  return result;
}
function calculateCoupncd(settlementSerialNumber, maturitySerialNumber, frequency) {
  const settlementDate = excelSerialToDate(settlementSerialNumber);
  let coupDate = excelSerialToDate(maturitySerialNumber);
  coupDate.setUTCFullYear(settlementDate.getUTCFullYear());
  if (coupDate < settlementDate) {
    coupDate.setUTCFullYear(coupDate.getUTCFullYear() + 1);
  }
  while (coupDate > settlementDate) {
    coupDate = dateAddMonths(coupDate, -12 / frequency);
  }
  coupDate = dateAddMonths(coupDate, 12 / frequency);
  const coupDateSerialNumber = excelDateSerial(coupDate);
  return coupDateSerialNumber;
}
function calculateCoupnum(settlementSerialNumber, maturitySerialNumber, frequency) {
  let result = 0;
  const settlementDate = excelSerialToDate(settlementSerialNumber);
  let coupDate = excelSerialToDate(maturitySerialNumber);
  while (coupDate > settlementDate) {
    coupDate = dateAddMonths(coupDate, -12 / frequency);
    result++;
  }
  return result;
}
function calculateCouppcd(settlementSerialNumber, maturitySerialNumber, frequency) {
  const settlementDate = excelSerialToDate(settlementSerialNumber);
  let coupDate = excelSerialToDate(maturitySerialNumber);
  coupDate.setUTCFullYear(settlementDate.getUTCFullYear());
  if (coupDate < settlementDate) {
    coupDate.setUTCFullYear(coupDate.getUTCFullYear() + 1);
  }
  while (coupDate > settlementDate) {
    coupDate = dateAddMonths(coupDate, -12 / frequency);
  }
  const coupDateSerialNumber = excelDateSerial(coupDate);
  return coupDateSerialNumber;
}
function calculateDuration(settlementSerialNumber, maturitySerialNumber, coupon, yld, frequency, basis) {
  const coupdaybs = calculateCoupdaybs(settlementSerialNumber, maturitySerialNumber, frequency, basis);
  const coupdays = calculateCoupdays(settlementSerialNumber, maturitySerialNumber, frequency, basis);
  const coupnum = calculateCoupnum(settlementSerialNumber, maturitySerialNumber, frequency);
  const coupdaysDiff = (coupdays - coupdaybs) / coupdays - 1;
  const _yld = yld / frequency + 1;
  const _coupon = coupon * 100 / frequency;
  let duration = 0;
  let den = 0;
  for (let i = 1; i <= coupnum; i++) {
    const index2 = i + coupdaysDiff;
    const num2 = _coupon / _yld ** index2;
    duration += index2 * num2;
    den += num2;
  }
  const index = coupnum + coupdaysDiff;
  const num = 100 / _yld ** index;
  duration += index * num;
  den += num;
  return duration / den / frequency;
}
function calculatePMT(rate, nper, pv, fv, type2) {
  let result;
  if (rate === 0) {
    result = (pv + fv) / nper;
  } else {
    const term = (1 + rate) ** nper;
    result = type2 === 1 ? (fv * rate / (term - 1) + pv * rate / (1 - 1 / term)) / (1 + rate) : fv * rate / (term - 1) + pv * rate / (1 - 1 / term);
  }
  return -result;
}
function calculateFV(rate, nper, pmt, pv, type2) {
  let result;
  if (rate === 0) {
    result = pv + pmt * nper;
  } else {
    if (rate === -1 && nper === 0) {
      return Number.NaN;
    }
    const term = (1 + rate) ** nper;
    result = type2 === 1 ? pv * term + pmt * (1 + rate) * (term - 1) / rate : pv * term + pmt * (term - 1) / rate;
  }
  return -result;
}
function calculateIPMT(rate, per, nper, pv, fv, type2) {
  const payment = calculatePMT(rate, nper, pv, fv, type2);
  const result = per === 1 ? type2 === 1 ? 0 : -pv : type2 === 1 ? calculateFV(rate, per - 2, payment, pv, 1) - payment : calculateFV(rate, per - 1, payment, pv, 0);
  return result * rate;
}
function calculateNpv(rate, values) {
  let res = 0;
  for (let i = 1; i <= values.length; i++) {
    res += values[i - 1] / (1 + rate) ** i;
  }
  return res;
}
function calculateOddFPrice(settlementSerialNumber, maturitySerialNumber, issueSerialNumber, firstCouponSerialNumber, rate, yld, redemption, frequency, basis) {
  const DFC = getPositiveDaysBetween(issueSerialNumber, firstCouponSerialNumber, basis);
  const E = calculateCoupdays(settlementSerialNumber, firstCouponSerialNumber, frequency, basis);
  if (DFC < E) {
    return calculateOddShortFirstCoupon(
      settlementSerialNumber,
      maturitySerialNumber,
      issueSerialNumber,
      firstCouponSerialNumber,
      rate,
      yld,
      redemption,
      frequency,
      basis,
      DFC,
      E
    );
  } else {
    return calculateOddLongFirstCoupon(
      settlementSerialNumber,
      maturitySerialNumber,
      issueSerialNumber,
      firstCouponSerialNumber,
      rate,
      yld,
      redemption,
      frequency,
      basis,
      E
    );
  }
}
function calculateOddShortFirstCoupon(settlementSerialNumber, maturitySerialNumber, issueSerialNumber, firstCouponSerialNumber, rate, yld, redemption, frequency, basis, DFC, E) {
  let result = 0;
  const N2 = calculateCoupnum(settlementSerialNumber, maturitySerialNumber, frequency);
  const DSC = getPositiveDaysBetween(settlementSerialNumber, firstCouponSerialNumber, basis);
  result += redemption / (1 + yld / frequency) ** (N2 - 1 + DSC / E);
  result += 100 * rate / frequency * DFC / E / (1 + yld / frequency) ** (DSC / E);
  for (let k = 2; k <= N2; k++) {
    result += 100 * rate / frequency / (1 + yld / frequency) ** (k - 1 + DSC / E);
  }
  const A = getPositiveDaysBetween(issueSerialNumber, settlementSerialNumber, basis);
  result -= 100 * rate / frequency * A / E;
  return result;
}
function calculateOddLongFirstCoupon(settlementSerialNumber, maturitySerialNumber, issueSerialNumber, firstCouponSerialNumber, rate, yld, redemption, frequency, basis, E) {
  let result = 0;
  const N2 = calculateCoupnum(firstCouponSerialNumber, maturitySerialNumber, frequency);
  const Nq = getCouponsNumber(firstCouponSerialNumber, settlementSerialNumber, 12 / frequency, true);
  let DSC;
  if (basis === 2 || basis === 3) {
    const coupncd = calculateCoupncd(settlementSerialNumber, firstCouponSerialNumber, frequency);
    DSC = getPositiveDaysBetween(settlementSerialNumber, coupncd, basis);
  } else {
    const couppcd = calculateCouppcd(settlementSerialNumber, firstCouponSerialNumber, frequency);
    const { days } = getTwoDateDaysByBasis(couppcd, settlementSerialNumber, basis);
    DSC = E - days;
  }
  result += redemption / (1 + yld / frequency) ** (N2 + Nq + DSC / E);
  const NC = calculateCoupnum(issueSerialNumber, firstCouponSerialNumber, frequency);
  let lateCoupon = firstCouponSerialNumber;
  let DCiDivNLiSum = 0;
  let AiDivNLiSum = 0;
  for (let index = NC; index >= 1; index--) {
    const earlyCoupon = getDateSerialNumberByMonths(lateCoupon, -12 / frequency, false);
    const NLi = basis === 1 ? getPositiveDaysBetween(earlyCoupon, lateCoupon, basis) : E;
    const DCi = index > 1 ? NLi : getPositiveDaysBetween(issueSerialNumber, lateCoupon, basis);
    DCiDivNLiSum += DCi / NLi;
    const startDate = issueSerialNumber > earlyCoupon ? issueSerialNumber : earlyCoupon;
    const endDate = settlementSerialNumber < lateCoupon ? settlementSerialNumber : lateCoupon;
    const Ai = getPositiveDaysBetween(startDate, endDate, basis);
    AiDivNLiSum += Ai / NLi;
    lateCoupon = earlyCoupon;
  }
  result += 100 * rate / frequency * DCiDivNLiSum / (1 + yld / frequency) ** (Nq + DSC / E);
  for (let k = 1; k <= N2; k++) {
    result += 100 * rate / frequency / (1 + yld / frequency) ** (k + Nq + DSC / E);
  }
  result -= 100 * rate / frequency * AiDivNLiSum;
  return result;
}
function getPositiveDaysBetween(startDateSerialNumber, endDateSerialNumber, basis) {
  const { days } = getTwoDateDaysByBasis(startDateSerialNumber, endDateSerialNumber, basis);
  return startDateSerialNumber < endDateSerialNumber ? days : 0;
}
function validDaysBetweenIsWholeFrequencyByTwoDate(date1SerialNumber, date2SerialNumber, frequency) {
  const date1 = excelSerialToDate(date1SerialNumber);
  const date1Year = date1.getUTCFullYear();
  const date1Month = date1.getUTCMonth();
  const date1Day = date1.getUTCDate();
  const date1LastDayOfMonth = lastDayOfMonth(date1Year, date1Month, date1Day);
  const date2 = excelSerialToDate(date2SerialNumber);
  const date2Year = date2.getUTCFullYear();
  const date2Month = date2.getUTCMonth();
  const date2Day = date2.getUTCDate();
  const date2LastDayOfMonth = lastDayOfMonth(date2Year, date2Month, date2Day);
  if (date1Day !== date2Day && !(date1LastDayOfMonth && date2LastDayOfMonth)) {
    return false;
  }
  const months = Math.abs((date2Year - date1Year) * 12 + (date2Month - date1Month));
  if (months % (12 / frequency) !== 0) {
    return false;
  }
  return true;
}
function validCouppcdIsGte0ByTwoDate(date1SerialNumber, date2SerialNumber, frequency) {
  const couppcd = calculateCouppcd(date1SerialNumber, date2SerialNumber, frequency);
  return couppcd >= 0;
}
function getDateSerialNumberByMonths(serialNumber, months, returnLastDay) {
  let date = excelSerialToDate(serialNumber);
  date = dateAddMonths(date, months);
  if (returnLastDay) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const daysInMonth = getDaysInMonth(year, month);
    date.setUTCDate(daysInMonth);
  }
  return excelDateSerial(date);
}
function getCouponsNumber(startDateSerialNumber, endDateSerialNumber, months, isWholeNumber) {
  const startDate = excelSerialToDate(startDateSerialNumber);
  const endDate = excelSerialToDate(endDateSerialNumber);
  const startDateYear = startDate.getUTCFullYear();
  const startDateMonth = startDate.getUTCMonth();
  const startDateDay = startDate.getUTCDate();
  const endDateYear = endDate.getUTCFullYear();
  const endDateMonth = endDate.getUTCMonth();
  const endDateDay = endDate.getUTCDate();
  const endOfMonthTemp = lastDayOfMonth(startDateYear, startDateMonth, startDateDay);
  const endOfMonth = !endOfMonthTemp && startDateMonth !== 1 && startDateDay > 28 && startDateDay < getDaysInMonth(startDateYear, startDateMonth) ? lastDayOfMonth(endDateYear, endDateMonth, endDateDay) : endOfMonthTemp;
  const newDateSerialNumber = getDateSerialNumberByMonths(endDateSerialNumber, 0, endOfMonth);
  let coupons = +isWholeNumber - 0 + +(endDateSerialNumber < newDateSerialNumber);
  let frontDateSerialNumber = getDateSerialNumberByMonths(newDateSerialNumber, months, endOfMonth);
  while (!(months > 0 ? frontDateSerialNumber >= endDateSerialNumber : frontDateSerialNumber <= endDateSerialNumber)) {
    frontDateSerialNumber = getDateSerialNumberByMonths(frontDateSerialNumber, months, endOfMonth);
    coupons++;
  }
  return coupons;
}
function getResultByGuessIterF(guess, iterF) {
  const g_Eps = 1e-7;
  const g_Eps2 = g_Eps * 2;
  const nIM = 500;
  let eps = 1;
  let nMC = 0;
  let x = guess;
  let xN;
  while (eps > g_Eps && nMC < nIM) {
    const den = (iterF(x + g_Eps) - iterF(x - g_Eps)) / g_Eps2;
    xN = x - iterF(x) / den;
    nMC++;
    eps = Math.abs(xN - x);
    x = xN;
  }
  if (Number.isNaN(x) || Infinity === Math.abs(x) || nMC === nIM) {
    return guessIsNaNorInfinity(guess, iterF);
  }
  return x;
}
function guessIsNaNorInfinity(guess, iterF) {
  const g_Eps = 1e-7;
  const nIM = 60;
  const max2 = Number.MAX_VALUE;
  const min2 = -1;
  const step = 1.6;
  let low = guess - 0.01 <= min2 ? min2 + g_Eps : guess - 0.01;
  let high = guess + 0.01 >= max2 ? max2 - g_Eps : guess + 0.01;
  let xBegin;
  let xEnd;
  let currentIter = 0;
  if (guess <= min2 || guess >= max2) {
    return ErrorValueObject.create("#NUM!" /* NUM */);
  }
  for (let i = 0; i < nIM; i++) {
    xBegin = low <= min2 ? min2 + g_Eps : low;
    xEnd = high >= max2 ? max2 - g_Eps : high;
    const x = iterF(xBegin);
    const y = iterF(xEnd);
    if (x * y <= 0) {
      break;
    } else if (x * y > 0) {
      low = xBegin + step * (xBegin - xEnd);
      high = xEnd + step * (xEnd - xBegin);
    } else {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (i === nIM - 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
  }
  xBegin = xBegin;
  xEnd = xEnd;
  let fXbegin = iterF(xBegin);
  const fXend = iterF(xEnd);
  let fXi;
  let xI;
  if (Math.abs(fXbegin) < g_Eps) {
    return ErrorValueObject.create("#NUM!" /* NUM */);
  }
  if (Math.abs(fXend) < g_Eps) {
    return ErrorValueObject.create("#NUM!" /* NUM */);
  }
  do {
    xI = xBegin + (xEnd - xBegin) / 2;
    fXi = iterF(xI);
    if (fXbegin * fXi < 0) {
      xEnd = xI;
    } else {
      xBegin = xI;
    }
    fXbegin = iterF(xBegin);
    currentIter++;
  } while (Math.abs(fXi) > g_Eps && currentIter < nIM);
  return xI;
}
function calculatePrice(settlementSerialNumber, maturitySerialNumber, rate, yld, redemption, frequency, basis) {
  const N2 = calculateCoupnum(settlementSerialNumber, maturitySerialNumber, frequency);
  const E = calculateCoupdays(settlementSerialNumber, maturitySerialNumber, frequency, basis);
  const A = calculateCoupdaybs(settlementSerialNumber, maturitySerialNumber, frequency, basis);
  if (N2 === 1) {
    const DSR = E - A;
    const T1 = 100 * rate / frequency + redemption;
    const T2 = yld / frequency * DSR / E + 1;
    const T3 = 100 * rate / frequency * A / E;
    return T1 / T2 - T3;
  }
  const DSC = E - A;
  let result = redemption / (1 + yld / frequency) ** (N2 - 1 + DSC / E);
  for (let k = 1; k <= N2; k++) {
    result += 100 * rate / frequency / (1 + yld / frequency) ** (k - 1 + DSC / E);
  }
  result -= 100 * rate / frequency * A / E;
  return result;
}
function calculateDDB(cost, salvage, life, period, factor) {
  let oldCost = 0;
  let fdl = factor / life;
  if (fdl >= 1) {
    fdl = 1;
    oldCost = period === 1 ? cost : 0;
  } else {
    oldCost = cost * (1 - fdl) ** (period - 1);
  }
  const newCost = cost * (1 - fdl) ** period;
  let result = 0;
  if (newCost < salvage) {
    result = oldCost - salvage;
  } else {
    result = oldCost - newCost;
  }
  if (result < 0) {
    result = 0;
  }
  return result;
}

// ../packages/engine-formula/src/functions/financial/accrint/index.ts
var Accrint = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 6);
    __publicField(this, "maxParams", 8);
  }
  calculate(issue, firstInterest, settlement, rate, par, frequency, basis, calcMethod) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const _calcMethod = calcMethod != null ? calcMethod : BooleanValueObject.create(true);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(issue, firstInterest, settlement, rate, par, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [issueObject, firstInterestObject, settlementObject, rateObject, parObject, frequencyObject, basisObject] = variants;
    const issueSerialNumber = getDateSerialNumberByObject(issueObject);
    if (typeof issueSerialNumber !== "number") {
      return issueSerialNumber;
    }
    const firstInterestSerialNumber = getDateSerialNumberByObject(firstInterestObject);
    if (typeof firstInterestSerialNumber !== "number") {
      return firstInterestSerialNumber;
    }
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const parValue = +parObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    const calcMethodValue = +_calcMethod.getValue();
    if (Number.isNaN(rateValue) || Number.isNaN(parValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue) || Number.isNaN(calcMethodValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue <= 0 || parValue <= 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(issueSerialNumber) >= Math.floor(settlementSerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return this._getResult(issueSerialNumber, firstInterestSerialNumber, settlementSerialNumber, rateValue, parValue, frequencyValue, basisValue, calcMethodValue);
  }
  _getResult(issueSerialNumber, firstInterestSerialNumber, settlementSerialNumber, rateValue, parValue, frequencyValue, basisValue, calcMethodValue) {
    let couppcd = calculateCouppcd(issueSerialNumber, firstInterestSerialNumber, frequencyValue);
    if (couppcd <= 0) {
      return NumberValueObject.create(0);
    }
    couppcd = calculateCouppcd(settlementSerialNumber, firstInterestSerialNumber, frequencyValue);
    const numMonths = 12 / frequencyValue;
    const firstInterestDate = excelSerialToDate(firstInterestSerialNumber);
    const firstInterestDateYear = firstInterestDate.getUTCFullYear();
    const firstInterestDateMonth = firstInterestDate.getUTCMonth();
    const firstInterestDateDay = firstInterestDate.getUTCDate();
    const lastDayOfMonthF = lastDayOfMonth(firstInterestDateYear, firstInterestDateMonth, firstInterestDateDay);
    let coupDateSerialNumber = getDateSerialNumberByMonths(firstInterestSerialNumber, -numMonths, lastDayOfMonthF);
    if (settlementSerialNumber > firstInterestSerialNumber && calcMethodValue) {
      coupDateSerialNumber = firstInterestSerialNumber;
      while (coupDateSerialNumber < settlementSerialNumber) {
        coupDateSerialNumber = getDateSerialNumberByMonths(coupDateSerialNumber, numMonths, lastDayOfMonthF);
      }
    }
    let firstDateSerialNumber = issueSerialNumber > coupDateSerialNumber ? issueSerialNumber : coupDateSerialNumber;
    let { days } = getTwoDateDaysByBasis(firstDateSerialNumber, settlementSerialNumber, basisValue);
    if (couppcd >= issueSerialNumber) {
      const { days: DFS } = getTwoDateDaysByBasis(firstDateSerialNumber, settlementSerialNumber, !basisValue ? 0 : 4);
      days = DFS;
    }
    if (settlementSerialNumber < firstDateSerialNumber) {
      days = -days;
    }
    let coupdays = calculateCoupdays(coupDateSerialNumber, firstInterestSerialNumber, frequencyValue, basisValue);
    let accruedDaysSum = days / coupdays;
    let startDateSerialNumber = coupDateSerialNumber;
    let endDateSerialNumber = issueSerialNumber;
    while (startDateSerialNumber > issueSerialNumber) {
      endDateSerialNumber = startDateSerialNumber;
      startDateSerialNumber = getDateSerialNumberByMonths(startDateSerialNumber, -numMonths, lastDayOfMonthF);
      firstDateSerialNumber = issueSerialNumber > startDateSerialNumber ? issueSerialNumber : startDateSerialNumber;
      const { days: DFE } = getTwoDateDaysByBasis(firstDateSerialNumber, endDateSerialNumber, basisValue);
      if (basisValue === 0) {
        if (endDateSerialNumber >= firstDateSerialNumber || issueSerialNumber <= startDateSerialNumber) {
          days = DFE;
        } else {
          days = -DFE;
        }
        coupdays = calculateCoupdays(startDateSerialNumber, endDateSerialNumber, frequencyValue, basisValue);
      } else {
        days = endDateSerialNumber < firstDateSerialNumber ? -DFE : DFE;
        if (basisValue === 3) {
          coupdays = 365 / frequencyValue;
        } else {
          const { days: DSE } = getTwoDateDaysByBasis(startDateSerialNumber, endDateSerialNumber, basisValue);
          coupdays = endDateSerialNumber < startDateSerialNumber ? -DSE : DSE;
        }
      }
      accruedDaysSum += issueSerialNumber <= startDateSerialNumber ? calcMethodValue ? 1 : 0 : days / coupdays;
    }
    const result = parValue * rateValue / frequencyValue * accruedDaysSum;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/accrintm/index.ts
var Accrintm = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
  }
  calculate(issue, settlement, rate, par, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(issue, settlement, rate, par, _basis);
    if (isError) {
      return errorObject;
    }
    const [issueObject, settlementObject, rateObject, parObject, basisObject] = variants;
    const issueSerialNumber = getDateSerialNumberByObject(issueObject);
    if (typeof issueSerialNumber !== "number") {
      return issueSerialNumber;
    }
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const parValue = +parObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(parValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue <= 0 || parValue <= 0 || basisValue < 0 || basisValue > 4 || Math.floor(issueSerialNumber) > Math.floor(settlementSerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (Math.floor(issueSerialNumber) === Math.floor(settlementSerialNumber)) {
      return NumberValueObject.create(0);
    }
    const { days, yearDays } = getTwoDateDaysByBasis(issueSerialNumber, settlementSerialNumber, basisValue);
    const result = parValue * rateValue * days / yearDays;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/amorlinc/index.ts
var Amorlinc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 6);
    __publicField(this, "maxParams", 7);
  }
  calculate(cost, datePurchased, firstPeriod, salvage, period, rate, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(cost, datePurchased, firstPeriod, salvage, period, rate, _basis);
    if (isError) {
      return errorObject;
    }
    const [costObject, datePurchasedObject, firstPeriodObject, salvageObject, periodObject, rateObject, basisObject] = variants;
    const datePurchasedSerialNumber = getDateSerialNumberByObject(datePurchasedObject);
    if (typeof datePurchasedSerialNumber !== "number") {
      return datePurchasedSerialNumber;
    }
    const firstPeriodSerialNumber = getDateSerialNumberByObject(firstPeriodObject);
    if (typeof firstPeriodSerialNumber !== "number") {
      return firstPeriodSerialNumber;
    }
    const costValue = +costObject.getValue();
    const salvageValue = +salvageObject.getValue();
    let periodValue = +periodObject.getValue();
    const rateValue = +rateObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(costValue) || Number.isNaN(salvageValue) || Number.isNaN(periodValue) || Number.isNaN(rateValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (costValue <= 0 || salvageValue < 0 || costValue < salvageValue || Math.floor(datePurchasedSerialNumber) > Math.floor(firstPeriodSerialNumber) || periodValue < 0 || rateValue <= 0 || ![0, 1, 3, 4].includes(basisValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (periodValue > 1) {
      periodValue = Math.floor(periodValue);
    } else {
      periodValue = Math.ceil(periodValue);
    }
    return this._getResult(costValue, datePurchasedSerialNumber, firstPeriodSerialNumber, salvageValue, periodValue, rateValue, basisValue);
  }
  _getResult(costValue, datePurchasedSerialNumber, firstPeriodSerialNumber, salvageValue, periodValue, rateValue, basisValue) {
    const totalDepreciation = costValue - salvageValue;
    const baseDepreciation = costValue * rateValue;
    const { days, yearDays } = getTwoDateDaysByBasis(datePurchasedSerialNumber, firstPeriodSerialNumber, basisValue);
    const firstPeriodYearsFraction = days / yearDays;
    const life = Math.ceil(totalDepreciation / baseDepreciation - firstPeriodYearsFraction);
    if (life < 0) {
      return NumberValueObject.create(0);
    }
    let result = baseDepreciation;
    if (periodValue === 0) {
      result = baseDepreciation * firstPeriodYearsFraction;
    } else if (periodValue === life) {
      result = totalDepreciation - baseDepreciation * (firstPeriodYearsFraction + periodValue - 1);
    } else if (periodValue > life) {
      result = 0;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/coupdaybs/index.ts
var Coupdaybs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(settlement, maturity, frequency, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = calculateCoupdaybs(settlementSerialNumber, maturitySerialNumber, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/coupdays/index.ts
var Coupdays = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(settlement, maturity, frequency, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = calculateCoupdays(settlementSerialNumber, maturitySerialNumber, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/coupdaysnc/index.ts
var Coupdaysnc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(settlement, maturity, frequency, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const settlementDate = excelSerialToDate(settlementSerialNumber);
    const coupDate = excelSerialToDate(maturitySerialNumber);
    coupDate.setUTCFullYear(settlementDate.getUTCFullYear());
    if (coupDate < settlementDate) {
      coupDate.setUTCFullYear(coupDate.getUTCFullYear() + 1);
    }
    while (coupDate > settlementDate) {
      coupDate.setUTCMonth(coupDate.getUTCMonth() - 12 / frequencyValue);
    }
    coupDate.setUTCMonth(coupDate.getUTCMonth() + 12 / frequencyValue);
    const coupDateSerialNumber = excelDateSerial(coupDate);
    const { days } = getTwoDateDaysByBasis(settlementSerialNumber, coupDateSerialNumber, basisValue);
    return NumberValueObject.create(days);
  }
};

// ../packages/engine-formula/src/functions/financial/coupncd/index.ts
var Coupncd = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(settlement, maturity, frequency, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = calculateCoupncd(settlementSerialNumber, maturitySerialNumber, frequencyValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/coupnum/index.ts
var Coupnum = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(settlement, maturity, frequency, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const coupDateSerialNumber = calculateCouppcd(settlementSerialNumber, maturitySerialNumber, frequencyValue);
    if (coupDateSerialNumber < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = calculateCoupnum(settlementSerialNumber, maturitySerialNumber, frequencyValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/couppcd/index.ts
var Couppcd = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(settlement, maturity, frequency, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = calculateCouppcd(settlementSerialNumber, maturitySerialNumber, frequencyValue);
    if (result < 0) {
      result = 0;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/cumipmt/index.ts
var Cumipmt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 6);
    __publicField(this, "maxParams", 6);
  }
  calculate(rate, nper, pv, startPeriod, endPeriod, type2) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(rate, nper, pv, startPeriod, endPeriod, type2);
    if (isError) {
      return errorObject;
    }
    const [rateObject, nperObject, pvObject, startPeriodObject, endPeriodObject, typeObject] = variants;
    const rateValue = +rateObject.getValue();
    const nperValue = +nperObject.getValue();
    const pvValue = +pvObject.getValue();
    const startPeriodValue = +startPeriodObject.getValue();
    const endPeriodValue = +endPeriodObject.getValue();
    const typeValue = +typeObject.getValue();
    if (Number.isNaN(rateValue) || Number.isNaN(nperValue) || Number.isNaN(pvValue) || Number.isNaN(startPeriodValue) || Number.isNaN(endPeriodValue) || Number.isNaN(typeValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue <= 0 || nperValue <= 0 || pvValue <= 0 || startPeriodValue < 1 || endPeriodValue < 1 || startPeriodValue > endPeriodValue || startPeriodValue > nperValue || endPeriodValue > nperValue || ![0, 1].includes(typeValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (Math.trunc(startPeriodValue) !== startPeriodValue && Math.trunc(endPeriodValue) !== endPeriodValue && Math.trunc(startPeriodValue) === Math.trunc(endPeriodValue)) {
      return NumberValueObject.create(0);
    }
    return this._getResult(rateValue, nperValue, pvValue, startPeriodValue, endPeriodValue, typeValue);
  }
  _getResult(rateValue, nperValue, pvValue, startPeriodValue, endPeriodValue, typeValue) {
    const payment = calculatePMT(rateValue, nperValue, pvValue, 0, typeValue);
    let result = 0;
    let _startPeriodValue = Math.ceil(startPeriodValue);
    if (_startPeriodValue === 1) {
      if (typeValue === 0) {
        result = -pvValue;
      }
      _startPeriodValue++;
    }
    let canNotCalculate = false;
    for (let i = _startPeriodValue; i <= endPeriodValue; i++) {
      const principal = typeValue === 1 ? calculateFV(rateValue, i - 2, payment, pvValue, 1) : calculateFV(rateValue, i - 1, payment, pvValue, 0);
      if (principal === 0) {
        canNotCalculate = true;
        break;
      }
      result += typeValue === 1 ? principal - payment : principal;
    }
    result *= rateValue;
    if (result < payment * (endPeriodValue - startPeriodValue + 1) || canNotCalculate) {
      result = payment * (endPeriodValue - startPeriodValue + 1);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/cumprinc/index.ts
var Cumprinc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 6);
    __publicField(this, "maxParams", 6);
  }
  calculate(rate, nper, pv, startPeriod, endPeriod, type2) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(rate, nper, pv, startPeriod, endPeriod, type2);
    if (isError) {
      return errorObject;
    }
    const [rateObject, nperObject, pvObject, startPeriodObject, endPeriodObject, typeObject] = variants;
    const rateValue = +rateObject.getValue();
    const nperValue = +nperObject.getValue();
    const pvValue = +pvObject.getValue();
    const startPeriodValue = +startPeriodObject.getValue();
    const endPeriodValue = +endPeriodObject.getValue();
    const typeValue = +typeObject.getValue();
    if (Number.isNaN(rateValue) || Number.isNaN(nperValue) || Number.isNaN(pvValue) || Number.isNaN(startPeriodValue) || Number.isNaN(endPeriodValue) || Number.isNaN(typeValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue <= 0 || nperValue <= 0 || pvValue <= 0 || startPeriodValue < 1 || endPeriodValue < 1 || startPeriodValue > endPeriodValue || ![0, 1].includes(typeValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (Math.trunc(startPeriodValue) !== startPeriodValue && Math.trunc(endPeriodValue) !== endPeriodValue && Math.trunc(startPeriodValue) === Math.trunc(endPeriodValue)) {
      return NumberValueObject.create(0);
    }
    return this._getResult(rateValue, nperValue, pvValue, startPeriodValue, endPeriodValue, typeValue);
  }
  _getResult(rateValue, nperValue, pvValue, startPeriodValue, endPeriodValue, typeValue) {
    const payment = calculatePMT(rateValue, nperValue, pvValue, 0, typeValue);
    let result = 0;
    let _startPeriodValue = Math.ceil(startPeriodValue);
    if (_startPeriodValue === 1) {
      result = typeValue === 0 ? payment + pvValue * rateValue : payment;
      _startPeriodValue++;
    }
    for (let i = _startPeriodValue; i <= endPeriodValue; i++) {
      result += typeValue === 1 ? payment - (calculateFV(rateValue, i - 2, payment, pvValue, 1) - payment) * rateValue : payment - calculateFV(rateValue, i - 1, payment, pvValue, 0) * rateValue;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/db/index.ts
var Db = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
    __publicField(this, "needsLocale", true);
  }
  calculate(cost, salvage, life, period, month) {
    let _month = month != null ? month : NumberValueObject.create(12);
    if (_month.isNull()) {
      _month = NumberValueObject.create(12);
    }
    const maxRowLength = Math.max(
      cost.isArray() ? cost.getRowCount() : 1,
      salvage.isArray() ? salvage.getRowCount() : 1,
      life.isArray() ? life.getRowCount() : 1,
      period.isArray() ? period.getRowCount() : 1,
      _month.isArray() ? _month.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      cost.isArray() ? cost.getColumnCount() : 1,
      salvage.isArray() ? salvage.getColumnCount() : 1,
      life.isArray() ? life.getColumnCount() : 1,
      period.isArray() ? period.getColumnCount() : 1,
      _month.isArray() ? _month.getColumnCount() : 1
    );
    const costArray = expandArrayValueObject(maxRowLength, maxColumnLength, cost, ErrorValueObject.create("#N/A" /* NA */));
    const salvageArray = expandArrayValueObject(maxRowLength, maxColumnLength, salvage, ErrorValueObject.create("#N/A" /* NA */));
    const lifeArray = expandArrayValueObject(maxRowLength, maxColumnLength, life, ErrorValueObject.create("#N/A" /* NA */));
    const periodArray = expandArrayValueObject(maxRowLength, maxColumnLength, period, ErrorValueObject.create("#N/A" /* NA */));
    const monthArray = expandArrayValueObject(maxRowLength, maxColumnLength, _month, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = costArray.map((costObject, rowIndex, columnIndex) => {
      const salvageObject = salvageArray.get(rowIndex, columnIndex);
      const lifeObject = lifeArray.get(rowIndex, columnIndex);
      const periodObject = periodArray.get(rowIndex, columnIndex);
      const monthObject = monthArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(costObject, salvageObject, lifeObject, periodObject, monthObject);
      if (isError) {
        return errorObject;
      }
      const [_costObject, _salvageObject, _lifeObject, _periodObject, _monthObject] = variants;
      const costValue = +_costObject.getValue();
      const salvageValue = +_salvageObject.getValue();
      const lifeValue = +_lifeObject.getValue();
      let periodValue = +_periodObject.getValue();
      const monthValue = Math.floor(+_monthObject.getValue());
      if (costValue < 0 || salvageValue < 0 || lifeValue <= 0 || periodValue <= 0 || Math.floor(periodValue) > Math.floor(lifeValue) || monthValue < 1 || monthValue > 12) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (periodValue < 1) {
        periodValue = 1;
      }
      periodValue = Math.floor(periodValue);
      return this._getResult(costValue, salvageValue, lifeValue, periodValue, monthValue, rowIndex, columnIndex);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResult(costValue, salvageValue, lifeValue, periodValue, monthValue, rowIndex, columnIndex) {
    const rate = +(1 - (salvageValue / costValue) ** (1 / lifeValue)).toFixed(3);
    const initial = costValue * rate * monthValue / 12;
    let total = initial;
    let current = 0;
    const ceiling = periodValue === lifeValue ? lifeValue - 1 : periodValue;
    for (let i = 2; i <= ceiling; i++) {
      current = (costValue - total) * rate;
      total += current;
    }
    let result;
    if (periodValue === 1) {
      result = initial;
    } else if (periodValue === lifeValue) {
      result = (costValue - total) * rate;
    } else {
      result = current;
    }
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (rowIndex === 0 && columnIndex === 0) {
      return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
    } else {
      return NumberValueObject.create(result);
    }
  }
};

// ../packages/engine-formula/src/functions/financial/ddb/index.ts
var Ddb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
    __publicField(this, "needsLocale", true);
  }
  calculate(cost, salvage, life, period, factor) {
    let _factor = factor != null ? factor : NumberValueObject.create(2);
    if (_factor.isNull()) {
      _factor = NumberValueObject.create(2);
    }
    const maxRowLength = Math.max(
      cost.isArray() ? cost.getRowCount() : 1,
      salvage.isArray() ? salvage.getRowCount() : 1,
      life.isArray() ? life.getRowCount() : 1,
      period.isArray() ? period.getRowCount() : 1,
      _factor.isArray() ? _factor.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      cost.isArray() ? cost.getColumnCount() : 1,
      salvage.isArray() ? salvage.getColumnCount() : 1,
      life.isArray() ? life.getColumnCount() : 1,
      period.isArray() ? period.getColumnCount() : 1,
      _factor.isArray() ? _factor.getColumnCount() : 1
    );
    const costArray = expandArrayValueObject(maxRowLength, maxColumnLength, cost, ErrorValueObject.create("#N/A" /* NA */));
    const salvageArray = expandArrayValueObject(maxRowLength, maxColumnLength, salvage, ErrorValueObject.create("#N/A" /* NA */));
    const lifeArray = expandArrayValueObject(maxRowLength, maxColumnLength, life, ErrorValueObject.create("#N/A" /* NA */));
    const periodArray = expandArrayValueObject(maxRowLength, maxColumnLength, period, ErrorValueObject.create("#N/A" /* NA */));
    const factorArray = expandArrayValueObject(maxRowLength, maxColumnLength, _factor, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = costArray.map((costObject, rowIndex, columnIndex) => {
      const salvageObject = salvageArray.get(rowIndex, columnIndex);
      const lifeObject = lifeArray.get(rowIndex, columnIndex);
      const periodObject = periodArray.get(rowIndex, columnIndex);
      const factorObject = factorArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(costObject, salvageObject, lifeObject, periodObject, factorObject);
      if (isError) {
        return errorObject;
      }
      const [_costObject, _salvageObject, _lifeObject, _periodObject, _factorObject] = variants;
      const costValue = +_costObject.getValue();
      const salvageValue = +_salvageObject.getValue();
      const lifeValue = +_lifeObject.getValue();
      const periodValue = +_periodObject.getValue();
      const factorValue = +_factorObject.getValue();
      if (costValue < 0 || salvageValue < 0 || lifeValue <= 0 || periodValue <= 0 || periodValue > lifeValue || factorValue <= 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = calculateDDB(costValue, salvageValue, lifeValue, periodValue, factorValue);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/disc/index.ts
var Disc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
  }
  calculate(settlement, maturity, pr, redemption, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, pr, redemption, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, prObject, redemptionObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const prValue = +prObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(prValue) || Number.isNaN(redemptionValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (prValue <= 0 || redemptionValue <= 0 || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const { days, yearDays } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basisValue);
    const result = (redemptionValue - prValue) / redemptionValue * (yearDays / days);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/dollarde/index.ts
var Dollarde = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(fractionalDollar, fraction) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(fractionalDollar, fraction);
    if (isError) {
      return errorObject;
    }
    const [fractionalDollarObject, fractionObject] = variants;
    const fractionalDollarValue = +fractionalDollarObject.getValue();
    let fractionValue = Math.floor(+fractionObject.getValue());
    if (Number.isNaN(fractionalDollarValue) || Number.isNaN(fractionValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (fractionValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (fractionValue >= 0 && fractionValue < 1) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    fractionValue = Number.parseInt(`${fractionValue}`, 10);
    let result = Number.parseInt(`${fractionalDollarValue}`, 10);
    result += fractionalDollarValue % 1 * 10 ** Math.ceil(Math.log(fractionValue) / Math.LN10) / fractionValue;
    const power = 10 ** (Math.ceil(Math.log(fractionValue) / Math.LN2) + 1);
    result = Math.round(result * power) / power;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/dollarfr/index.ts
var Dollarfr = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(decimalDollar, fraction) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(decimalDollar, fraction);
    if (isError) {
      return errorObject;
    }
    const [decimalDollarObject, fractionObject] = variants;
    const decimalDollarValue = +decimalDollarObject.getValue();
    let fractionValue = Math.floor(+fractionObject.getValue());
    if (Number.isNaN(decimalDollarValue) || Number.isNaN(fractionValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (fractionValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (fractionValue >= 0 && fractionValue < 1) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    fractionValue = Number.parseInt(`${fractionValue}`, 10);
    let result = Number.parseInt(`${decimalDollarValue}`, 10);
    result += decimalDollarValue % 1 * 10 ** -Math.ceil(Math.log(fractionValue) / Math.LN10) * fractionValue;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/duration/index.ts
var Duration = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 5);
    __publicField(this, "maxParams", 6);
  }
  calculate(settlement, maturity, coupon, yld, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, coupon, yld, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, couponObject, yldObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const couponValue = +couponObject.getValue();
    const yldValue = +yldObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(couponValue) || Number.isNaN(yldValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (couponValue < 0 || yldValue < 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (settlementSerialNumber <= 0 || maturitySerialNumber <= 366) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = calculateDuration(settlementSerialNumber, maturitySerialNumber, couponValue, yldValue, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/effect/index.ts
var Effect = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(nominalRate, npery) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(nominalRate, npery);
    if (isError) {
      return errorObject;
    }
    const [nominalRateObject, nperyObject] = variants;
    const nominalRateValue = +nominalRateObject.getValue();
    let nperyValue = Math.floor(+nperyObject.getValue());
    if (Number.isNaN(nominalRateValue) || Number.isNaN(nperyValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (nominalRateValue <= 0 || nperyValue < 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    nperyValue = Number.parseInt(`${nperyValue}`, 10);
    const result = (1 + nominalRateValue / nperyValue) ** nperyValue - 1;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/fv/index.ts
var Fv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
    __publicField(this, "needsLocale", true);
  }
  calculate(rate, nper, pmt, pv, type2) {
    const _pv = pv != null ? pv : NumberValueObject.create(0);
    const _type = type2 != null ? type2 : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      nper.isArray() ? nper.getRowCount() : 1,
      pmt.isArray() ? pmt.getRowCount() : 1,
      _pv.isArray() ? _pv.getRowCount() : 1,
      _type.isArray() ? _type.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      nper.isArray() ? nper.getColumnCount() : 1,
      pmt.isArray() ? pmt.getColumnCount() : 1,
      _pv.isArray() ? _pv.getColumnCount() : 1,
      _type.isArray() ? _type.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pmtArray = expandArrayValueObject(maxRowLength, maxColumnLength, pmt, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, _pv, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _type, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const nperObject = nperArray.get(rowIndex, columnIndex);
      const pmtObject = pmtArray.get(rowIndex, columnIndex);
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const typeObject = typeArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, nperObject, pmtObject, pvObject, typeObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _nperObject, _pmtObject, _pvObject, _typeObject] = variants;
      const rateValue = +_rateObject.getValue();
      const nperValue = +_nperObject.getValue();
      const pmtValue = +_pmtObject.getValue();
      const pvValue = +_pvObject.getValue();
      const typeValue = +_typeObject.getValue();
      const result = calculateFV(rateValue, nperValue, pmtValue, pvValue, typeValue ? 1 : 0);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      } else {
        return NumberValueObject.create(result);
      }
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/fvschedule/index.ts
var Fvschedule = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(principal, schedule) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(principal);
    if (isError) {
      return errorObject;
    }
    const [principalObject] = variants;
    const principalValue = +principalObject.getValue();
    if (Number.isNaN(principalValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let result = principalValue;
    if (schedule.isArray()) {
      const scheduleValues = schedule.getArrayValue().flat();
      for (let i = 0; i < scheduleValues.length; i++) {
        const scheduleObject = scheduleValues[i];
        if (scheduleObject.isBoolean()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        const scheduleValue = +scheduleObject.getValue();
        if (Number.isNaN(scheduleValue)) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        result *= 1 + scheduleValue;
      }
    } else {
      if (schedule.isBoolean()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const scheduleValue = +schedule.getValue();
      if (Number.isNaN(scheduleValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      result *= 1 + scheduleValue;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/intrate/index.ts
var Intrate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
  }
  calculate(settlement, maturity, investment, redemption, basis) {
    const _basis = basis != null ? basis : NumberValueObject.create(0);
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(settlement, maturity, investment, redemption, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, investmentObject, redemptionObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const investmentValue = +investmentObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(investmentValue) || Number.isNaN(redemptionValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (investmentValue <= 0 || redemptionValue <= 0 || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const { days, yearDays } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basisValue);
    const result = (redemptionValue - investmentValue) / investmentValue * (yearDays / days);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/ipmt/index.ts
var Ipmt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 6);
    __publicField(this, "needsLocale", true);
  }
  calculate(rate, per, nper, pv, fv, type2) {
    const _fv = fv != null ? fv : NumberValueObject.create(0);
    const _type = type2 != null ? type2 : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      per.isArray() ? per.getRowCount() : 1,
      nper.isArray() ? nper.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1,
      _fv.isArray() ? _fv.getRowCount() : 1,
      _type.isArray() ? _type.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      per.isArray() ? per.getColumnCount() : 1,
      nper.isArray() ? nper.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1,
      _fv.isArray() ? _fv.getColumnCount() : 1,
      _type.isArray() ? _type.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const perArray = expandArrayValueObject(maxRowLength, maxColumnLength, per, ErrorValueObject.create("#N/A" /* NA */));
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, _fv, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _type, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const perObject = perArray.get(rowIndex, columnIndex);
      const nperObject = nperArray.get(rowIndex, columnIndex);
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const typeObject = typeArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, perObject, nperObject, pvObject, fvObject, typeObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _perObject, _nperObject, _pvObject, _fvObject, _typeObject] = variants;
      const rateValue = +_rateObject.getValue();
      const perValue = +_perObject.getValue();
      const nperValue = +_nperObject.getValue();
      const pvValue = +_pvObject.getValue();
      const fvValue = +_fvObject.getValue();
      const typeValue = +_typeObject.getValue();
      if (perValue < 1 || Math.floor(perValue) > Math.ceil(nperValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = calculateIPMT(rateValue, perValue, nperValue, pvValue, fvValue, typeValue ? 1 : 0);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      } else {
        return NumberValueObject.create(result);
      }
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/irr/index.ts
var Irr = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(values, guess) {
    let _guess = guess != null ? guess : NumberValueObject.create(0.1);
    if (_guess.isNull()) {
      _guess = NumberValueObject.create(0.1);
    }
    if (_guess.isArray()) {
      return _guess.map((guessObject, rowIndex, columnIndex) => this._handleSingleObject(values, guessObject, rowIndex, columnIndex));
    }
    return this._handleSingleObject(values, _guess);
  }
  _handleSingleObject(values, guess, rowIndex = 0, columnIndex = 0) {
    if (values.isError()) {
      return values;
    }
    if (guess.isError()) {
      return guess;
    }
    if (values.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (!values.isArray()) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const { _values, valuesHasError } = this._getValues(values);
    if (valuesHasError) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let _guess = guess;
    if (_guess.isString()) {
      _guess = _guess.convertToNumberObjectValue();
      if (_guess.isError()) {
        return _guess;
      }
    }
    const guessValue = +_guess.getValue();
    const { positive, negative } = this._checkValues(_values);
    if (!positive || !negative) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = getResultByGuessIterF(guessValue, (rate) => calculateNpv(rate, _values));
    if (typeof result !== "number") {
      return result;
    }
    if (rowIndex === 0 && columnIndex === 0) {
      return NumberValueObject.create(result, "0%");
    }
    return NumberValueObject.create(result);
  }
  _getValues(values) {
    const _values = [];
    let valuesHasError = false;
    values.iterator((valueOject) => {
      const _valueOject = valueOject;
      if (_valueOject.isError()) {
        valuesHasError = true;
        return false;
      }
      if (_valueOject.isNull() || _valueOject.isBoolean()) {
        return true;
      }
      const value = +_valueOject.getValue();
      if (Number.isNaN(value)) {
        return true;
      }
      _values.push(value);
    });
    return {
      _values,
      valuesHasError
    };
  }
  _checkValues(values) {
    let positive = false;
    let negative = false;
    for (let i = 0; i < values.length; i++) {
      if (values[i] > 0) {
        positive = true;
      }
      if (values[i] < 0) {
        negative = true;
      }
    }
    return {
      positive,
      negative
    };
  }
};

// ../packages/engine-formula/src/functions/financial/ispmt/index.ts
var Ispmt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(rate, per, nper, pv) {
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      per.isArray() ? per.getRowCount() : 1,
      nper.isArray() ? nper.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      per.isArray() ? per.getColumnCount() : 1,
      nper.isArray() ? nper.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const perArray = expandArrayValueObject(maxRowLength, maxColumnLength, per, ErrorValueObject.create("#N/A" /* NA */));
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const perObject = perArray.get(rowIndex, columnIndex);
      const nperObject = nperArray.get(rowIndex, columnIndex);
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, perObject, nperObject, pvObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _perObject, _nperObject, _pvObject] = variants;
      const rateValue = +_rateObject.getValue();
      const perValue = +_perObject.getValue();
      const nperValue = +_nperObject.getValue();
      const pvValue = +_pvObject.getValue();
      if (nperValue === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = pvValue * rateValue * (perValue / nperValue - 1);
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/mduration/index.ts
var Mduration = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 5);
    __publicField(this, "maxParams", 6);
  }
  calculate(settlement, maturity, coupon, yld, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, coupon, yld, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, couponObject, yldObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const couponValue = +couponObject.getValue();
    const yldValue = +yldObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(couponValue) || Number.isNaN(yldValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (couponValue < 0 || yldValue < 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || Math.floor(settlementSerialNumber) >= Math.floor(maturitySerialNumber)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = calculateDuration(settlementSerialNumber, maturitySerialNumber, couponValue, yldValue, frequencyValue, basisValue);
    result /= 1 + yldValue / frequencyValue;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/mirr/index.ts
var Mirr = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(values, financeRate, reinvestRate) {
    const { _values, numberValues, positive, negative } = this._getValues(values);
    const maxRowLength = Math.max(
      financeRate.isArray() ? financeRate.getRowCount() : 1,
      reinvestRate.isArray() ? reinvestRate.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      financeRate.isArray() ? financeRate.getColumnCount() : 1,
      reinvestRate.isArray() ? reinvestRate.getColumnCount() : 1
    );
    const financeRateArray = expandArrayValueObject(maxRowLength, maxColumnLength, financeRate, ErrorValueObject.create("#N/A" /* NA */));
    const reinvestRateArray = expandArrayValueObject(maxRowLength, maxColumnLength, reinvestRate, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = financeRateArray.map((financeRateObject, rowIndex, columnIndex) => {
      const reinvestRateObject = reinvestRateArray.get(rowIndex, columnIndex);
      if (values.isError()) {
        return values;
      }
      if (reinvestRateObject.isError()) {
        return reinvestRateObject;
      }
      if (_values.isError()) {
        return _values;
      }
      if (!positive || !negative) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const financeRateValue = +financeRateObject.getValue();
      const reinvestRateValue = +reinvestRateObject.getValue();
      if (Number.isNaN(financeRateValue) || Number.isNaN(reinvestRateValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (reinvestRateValue === -1) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = this._getResult(numberValues, financeRateValue, reinvestRateValue);
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, "0%");
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getValues(values) {
    let _values = values;
    let _numberValues = [];
    let _positive = false;
    let _negative = false;
    if (!values.isError()) {
      if (values.isNull()) {
        _values = ErrorValueObject.create("#VALUE!" /* VALUE */);
      } else if (!values.isArray()) {
        _values = ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      } else {
        const { numberValues, valuesHasError, errorObject, positive, negative } = this._checkValues(values);
        if (valuesHasError) {
          _values = errorObject;
        }
        _numberValues = numberValues;
        _positive = positive;
        _negative = negative;
      }
    }
    return {
      _values,
      numberValues: _numberValues,
      positive: _positive,
      negative: _negative
    };
  }
  _checkValues(values) {
    const numberValues = [];
    let valuesHasError = false;
    let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
    let positive = false;
    let negative = false;
    values.iterator((valueOject) => {
      const _valueOject = valueOject;
      if (_valueOject.isError()) {
        valuesHasError = true;
        errorObject = _valueOject;
        return false;
      }
      if (_valueOject.isNull() || _valueOject.isBoolean()) {
        return true;
      }
      const value = +_valueOject.getValue();
      if (Number.isNaN(value)) {
        return true;
      }
      if (value > 0) {
        positive = true;
      }
      if (value < 0) {
        negative = true;
      }
      numberValues.push(value);
    });
    return {
      numberValues,
      valuesHasError,
      errorObject,
      positive,
      negative
    };
  }
  _getResult(values, financeRate, reinvestRate) {
    const n = values.length;
    const negatives = [];
    const positives = [];
    for (let i = 0; i < n; i++) {
      if (values[i] > 0) {
        positives.push(values[i]);
      } else if (values[i] < 0) {
        negatives.push(values[i]);
      }
    }
    const npvR = this._npv(reinvestRate, values, "positive");
    const npvF = this._npv(financeRate, values, "negative");
    const num = -npvR * (1 + reinvestRate) ** n;
    const den = npvF * (1 + financeRate);
    const result = (num / den) ** (1 / (n - 1)) - 1;
    return result;
  }
  _npv(rate, values, type2) {
    let res = 0;
    for (let i = 1; i <= values.length; i++) {
      const value = values[i - 1];
      if (type2 === "positive" && value > 0 || type2 === "negative" && value < 0) {
        res += value / (1 + rate) ** i;
      }
    }
    return res;
  }
};

// ../packages/engine-formula/src/functions/financial/nominal/index.ts
var Nominal = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(effectRate, npery) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(effectRate, npery);
    if (isError) {
      return errorObject;
    }
    const [effectRateObject, nperyObject] = variants;
    const effectRateValue = +effectRateObject.getValue();
    let nperyValue = Math.floor(+nperyObject.getValue());
    if (Number.isNaN(effectRateValue) || Number.isNaN(nperyValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (effectRateValue <= 0 || nperyValue < 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    nperyValue = Number.parseInt(`${nperyValue}`, 10);
    const result = ((effectRateValue + 1) ** (1 / nperyValue) - 1) * nperyValue;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/nper/index.ts
var Nper = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
  }
  calculate(rate, pmt, pv, fv, type2) {
    const _fv = fv != null ? fv : NumberValueObject.create(0);
    const _type = type2 != null ? type2 : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      pmt.isArray() ? pmt.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1,
      _fv.isArray() ? _fv.getRowCount() : 1,
      _type.isArray() ? _type.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      pmt.isArray() ? pmt.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1,
      _fv.isArray() ? _fv.getColumnCount() : 1,
      _type.isArray() ? _type.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const pmtArray = expandArrayValueObject(maxRowLength, maxColumnLength, pmt, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, _fv, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _type, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const pmtObject = pmtArray.get(rowIndex, columnIndex);
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const typeObject = typeArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, pmtObject, pvObject, fvObject, typeObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _pmtObject, _pvObject, _fvObject, _typeObject] = variants;
      const rateValue = +_rateObject.getValue();
      const pmtValue = +_pmtObject.getValue();
      const pvValue = +_pvObject.getValue();
      const fvValue = +_fvObject.getValue();
      let typeValue = +_typeObject.getValue();
      typeValue = typeValue ? 1 : 0;
      if (rateValue === 0 && pmtValue === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      let result;
      if (rateValue === 0) {
        result = -(pvValue + fvValue) / pmtValue;
      } else {
        const num = pmtValue * (1 + rateValue * typeValue) - fvValue * rateValue;
        const den = pvValue * rateValue + pmtValue * (1 + rateValue * typeValue);
        result = Math.log(num / den) / Math.log(1 + rateValue);
      }
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/npv/index.ts
var Npv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
    __publicField(this, "needsLocale", true);
  }
  calculate(rate, ...variants) {
    if (rate.isError()) {
      return rate;
    }
    const { isError, errorObject, values } = this._getValues(variants);
    if (rate.isArray()) {
      return rate.map((rateObject, rowIndex, columnIndex) => this._handleSingleObject(rateObject, isError, errorObject, values, rowIndex, columnIndex));
    }
    return this._handleSingleObject(rate, isError, errorObject, values);
  }
  _handleSingleObject(rate, isError, errorObject, values, rowIndex = 0, columnIndex = 0) {
    let _rate = rate;
    if (_rate.isString()) {
      _rate = _rate.convertToNumberObjectValue();
    }
    if (_rate.isError()) {
      return _rate;
    }
    if (isError) {
      return errorObject;
    }
    const rateValue = +rate.getValue();
    const result = calculateNpv(rateValue, values);
    if (Number.isNaN(result) || Math.abs(result) === Infinity) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    if (rowIndex === 0 && columnIndex === 0) {
      return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
    }
    return NumberValueObject.create(result);
  }
  _getValues(variants) {
    const values = [];
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return {
          isError: true,
          errorObject: variant
        };
      }
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((variantOject) => {
          const _variantOject = variantOject;
          if (_variantOject.isError()) {
            isError = true;
            errorObject = _variantOject;
            return false;
          }
          if (_variantOject.isNull() || _variantOject.isBoolean()) {
            return true;
          }
          const value = +_variantOject.getValue();
          if (Number.isNaN(value)) {
            return true;
          }
          values.push(value);
        });
        if (isError) {
          return {
            isError,
            errorObject
          };
        }
      } else {
        const value = +variant.getValue();
        if (Number.isNaN(value)) {
          return {
            isError: true,
            errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
          };
        }
        values.push(value);
      }
    }
    return {
      isError: false,
      values
    };
  }
};

// ../packages/engine-formula/src/functions/financial/oddfprice/index.ts
var Oddfprice = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 8);
    __publicField(this, "maxParams", 9);
  }
  calculate(settlement, maturity, issue, firstCoupon, rate, yld, redemption, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, issue, firstCoupon, rate, yld, redemption, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, issueObject, firstCouponObject, rateObject, yldObject, redemptionObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const issueSerialNumber = getDateSerialNumberByObject(issueObject);
    if (typeof issueSerialNumber !== "number") {
      return issueSerialNumber;
    }
    const firstCouponSerialNumber = getDateSerialNumberByObject(firstCouponObject);
    if (typeof firstCouponSerialNumber !== "number") {
      return firstCouponSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const yldValue = +yldObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(yldValue) || Number.isNaN(redemptionValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue < 0 || yldValue < 0 || redemptionValue <= 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || !this._validDate(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber, frequencyValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = calculateOddFPrice(settlementSerialNumber, maturitySerialNumber, issueSerialNumber, firstCouponSerialNumber, rateValue, yldValue, redemptionValue, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
  _validDate(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber, frequencyValue) {
    return this._getDateCorrectOrder(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber) && validDaysBetweenIsWholeFrequencyByTwoDate(maturitySerialNumber, firstCouponSerialNumber, frequencyValue) && validCouppcdIsGte0ByTwoDate(issueSerialNumber, maturitySerialNumber, frequencyValue);
  }
  _getDateCorrectOrder(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber) {
    return Math.floor(maturitySerialNumber) > Math.floor(firstCouponSerialNumber) && Math.floor(firstCouponSerialNumber) > Math.floor(settlementSerialNumber) && Math.floor(settlementSerialNumber) > Math.floor(issueSerialNumber);
  }
};

// ../packages/engine-formula/src/functions/financial/oddfyield/index.ts
var Oddfyield = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 8);
    __publicField(this, "maxParams", 9);
  }
  calculate(settlement, maturity, issue, firstCoupon, rate, pr, redemption, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, issue, firstCoupon, rate, pr, redemption, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, issueObject, firstCouponObject, rateObject, prObject, redemptionObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const issueSerialNumber = getDateSerialNumberByObject(issueObject);
    if (typeof issueSerialNumber !== "number") {
      return issueSerialNumber;
    }
    const firstCouponSerialNumber = getDateSerialNumberByObject(firstCouponObject);
    if (typeof firstCouponSerialNumber !== "number") {
      return firstCouponSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const prValue = +prObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(prValue) || Number.isNaN(redemptionValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue < 0 || prValue <= 0 || redemptionValue <= 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || !this._validDate(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber, frequencyValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return this._getResult(settlementSerialNumber, maturitySerialNumber, issueSerialNumber, firstCouponSerialNumber, rateValue, prValue, redemptionValue, frequencyValue, basisValue);
  }
  _validDate(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber, frequencyValue) {
    return this._getDateCorrectOrder(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber) && validDaysBetweenIsWholeFrequencyByTwoDate(maturitySerialNumber, firstCouponSerialNumber, frequencyValue) && validCouppcdIsGte0ByTwoDate(issueSerialNumber, maturitySerialNumber, frequencyValue);
  }
  _getDateCorrectOrder(maturitySerialNumber, firstCouponSerialNumber, settlementSerialNumber, issueSerialNumber) {
    return Math.floor(maturitySerialNumber) > Math.floor(firstCouponSerialNumber) && Math.floor(firstCouponSerialNumber) > Math.floor(settlementSerialNumber) && Math.floor(settlementSerialNumber) > Math.floor(issueSerialNumber);
  }
  _getResult(settlementSerialNumber, maturitySerialNumber, issueSerialNumber, firstCouponSerialNumber, rate, pr, redemption, frequency, basis) {
    const { days } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basis);
    const guess = (rate * days * 100 - (pr - 100)) / ((pr - 100) * 0.25 * (1 + 2 * days) + days * 100);
    function _iterF(yld) {
      return pr - calculateOddFPrice(settlementSerialNumber, maturitySerialNumber, issueSerialNumber, firstCouponSerialNumber, rate, yld, redemption, frequency, basis);
    }
    const result = getResultByGuessIterF(guess, (yld) => _iterF(yld));
    if (typeof result !== "number") {
      return result;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/oddlprice/index.ts
var Oddlprice = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 7);
    __publicField(this, "maxParams", 8);
  }
  calculate(settlement, maturity, lastInterest, rate, yld, redemption, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, lastInterest, rate, yld, redemption, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, lastInterestObject, rateObject, yldObject, redemptionObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const lastInterestSerialNumber = getDateSerialNumberByObject(lastInterestObject);
    if (typeof lastInterestSerialNumber !== "number") {
      return lastInterestSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const yldValue = +yldObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(yldValue) || Number.isNaN(redemptionValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue < 0 || yldValue < 0 || redemptionValue <= 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || !this._validDate(maturitySerialNumber, settlementSerialNumber, lastInterestSerialNumber, frequencyValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = this._getResult(settlementSerialNumber, maturitySerialNumber, lastInterestSerialNumber, rateValue, yldValue, redemptionValue, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
  _validDate(maturitySerialNumber, settlementSerialNumber, lastInterestSerialNumber, frequencyValue) {
    return Math.floor(maturitySerialNumber) > Math.floor(settlementSerialNumber) && Math.floor(settlementSerialNumber) > Math.floor(lastInterestSerialNumber) && validCouppcdIsGte0ByTwoDate(lastInterestSerialNumber, maturitySerialNumber, frequencyValue);
  }
  _getResult(settlementSerialNumber, maturitySerialNumber, lastInterestSerialNumber, rate, yld, redemption, frequency, basis) {
    const coupDateSerialNumber = this._getCoupDate(maturitySerialNumber, lastInterestSerialNumber, frequency);
    const fAi = this._getFrac(lastInterestSerialNumber, settlementSerialNumber, coupDateSerialNumber, frequency, basis);
    const fDCi = this._getFrac(lastInterestSerialNumber, maturitySerialNumber, coupDateSerialNumber, frequency, basis);
    const fDSCi = this._getFrac(settlementSerialNumber, maturitySerialNumber, coupDateSerialNumber, frequency, basis);
    const result = (redemption * frequency + 100 * rate * (fDCi - fAi * (1 + yld * fDSCi / frequency))) / (yld * fDSCi + frequency);
    return result;
  }
  _getCoupDate(maturitySerialNumber, lastInterestSerialNumber, frequency) {
    const maturityDate = excelSerialToDate(maturitySerialNumber);
    const coupDate = excelSerialToDate(lastInterestSerialNumber);
    coupDate.setUTCFullYear(maturityDate.getUTCFullYear());
    if (coupDate > maturityDate) {
      coupDate.setUTCFullYear(coupDate.getUTCFullYear() - 1);
    }
    while (coupDate < maturityDate) {
      coupDate.setUTCMonth(coupDate.getUTCMonth() + 12 / frequency);
    }
    return excelDateSerial(coupDate);
  }
  _getFrac(startDateSerialNumber, endDateSerialNumber, coupDateSerialNumber, frequency, basis) {
    const startDate = excelSerialToDate(startDateSerialNumber);
    const endDate = excelSerialToDate(endDateSerialNumber);
    const coupDate = excelSerialToDate(coupDateSerialNumber);
    coupDate.setUTCFullYear(startDate.getUTCFullYear());
    if (coupDate < startDate) {
      coupDate.setUTCFullYear(coupDate.getUTCFullYear() + 1);
    }
    while (coupDate > startDate) {
      coupDate.setUTCMonth(coupDate.getUTCMonth() - 12 / frequency);
    }
    let earlyCouponSerialNumber = excelDateSerial(coupDate);
    coupDate.setUTCMonth(coupDate.getUTCMonth() + 12 / frequency);
    let lateCouponSerialNumber = excelDateSerial(coupDate);
    if (lateCouponSerialNumber >= endDateSerialNumber) {
      const { days } = getTwoDateDaysByBasis(startDateSerialNumber, endDateSerialNumber, basis);
      const coupdays = calculateCoupdays(earlyCouponSerialNumber, lateCouponSerialNumber, frequency, basis);
      return days / coupdays;
    }
    const { days: daysF } = getTwoDateDaysByBasis(startDateSerialNumber, lateCouponSerialNumber, basis);
    const coupdaysF = calculateCoupdays(earlyCouponSerialNumber, lateCouponSerialNumber, frequency, basis);
    let result = daysF / coupdaysF;
    const earlyCoupon = excelSerialToDate(lateCouponSerialNumber);
    const lateCoupon = excelSerialToDate(lateCouponSerialNumber);
    lateCoupon.setUTCMonth(lateCoupon.getUTCMonth() + 12 / frequency);
    while (lateCoupon < endDate) {
      earlyCoupon.setUTCMonth(earlyCoupon.getUTCMonth() + 12 / frequency);
      lateCoupon.setUTCMonth(lateCoupon.getUTCMonth() + 12 / frequency);
      result += 1;
    }
    earlyCouponSerialNumber = excelDateSerial(earlyCoupon);
    lateCouponSerialNumber = excelDateSerial(lateCoupon);
    const { days: daysL } = getTwoDateDaysByBasis(earlyCouponSerialNumber, endDateSerialNumber, basis);
    const coupdaysL = calculateCoupdays(earlyCouponSerialNumber, lateCouponSerialNumber, frequency, basis);
    result += daysL / coupdaysL;
    return result;
  }
};

// ../packages/engine-formula/src/functions/financial/oddlyield/index.ts
var Oddlyield = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 8);
    __publicField(this, "maxParams", 9);
  }
  calculate(settlement, maturity, lastInterest, rate, pr, redemption, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, lastInterest, rate, pr, redemption, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, lastInterestObject, rateObject, prObject, redemptionObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const lastInterestSerialNumber = getDateSerialNumberByObject(lastInterestObject);
    if (typeof lastInterestSerialNumber !== "number") {
      return lastInterestSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const prValue = +prObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(prValue) || Number.isNaN(redemptionValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue < 0 || prValue <= 0 || redemptionValue <= 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || !this._validDate(maturitySerialNumber, settlementSerialNumber, lastInterestSerialNumber, frequencyValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = this._getResult(settlementSerialNumber, maturitySerialNumber, lastInterestSerialNumber, rateValue, prValue, redemptionValue, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
  _validDate(maturitySerialNumber, settlementSerialNumber, lastInterestSerialNumber, frequencyValue) {
    return Math.floor(maturitySerialNumber) > Math.floor(settlementSerialNumber) && Math.floor(settlementSerialNumber) > Math.floor(lastInterestSerialNumber) && validCouppcdIsGte0ByTwoDate(lastInterestSerialNumber, maturitySerialNumber, frequencyValue);
  }
  _getResult(settlementSerialNumber, maturitySerialNumber, lastInterestSerialNumber, rate, pr, redemption, frequency, basis) {
    const coupDateSerialNumber = this._getCoupDate(maturitySerialNumber, lastInterestSerialNumber, frequency);
    const fAi = this._getFrac(lastInterestSerialNumber, settlementSerialNumber, coupDateSerialNumber, frequency, basis);
    const fDCi = this._getFrac(lastInterestSerialNumber, maturitySerialNumber, coupDateSerialNumber, frequency, basis);
    const fDSCi = this._getFrac(settlementSerialNumber, maturitySerialNumber, coupDateSerialNumber, frequency, basis);
    const result = (frequency * (redemption - pr) + 100 * rate * (fDCi - fAi)) / (fDSCi * pr + 100 * rate * fAi * fDSCi / frequency);
    return result;
  }
  _getCoupDate(maturitySerialNumber, lastInterestSerialNumber, frequency) {
    const maturityDate = excelSerialToDate(maturitySerialNumber);
    const coupDate = excelSerialToDate(lastInterestSerialNumber);
    coupDate.setUTCFullYear(maturityDate.getUTCFullYear());
    if (coupDate > maturityDate) {
      coupDate.setUTCFullYear(coupDate.getUTCFullYear() - 1);
    }
    while (coupDate < maturityDate) {
      coupDate.setUTCMonth(coupDate.getUTCMonth() + 12 / frequency);
    }
    return excelDateSerial(coupDate);
  }
  _getFrac(startDateSerialNumber, endDateSerialNumber, coupDateSerialNumber, frequency, basis) {
    const startDate = excelSerialToDate(startDateSerialNumber);
    const endDate = excelSerialToDate(endDateSerialNumber);
    const coupDate = excelSerialToDate(coupDateSerialNumber);
    coupDate.setUTCFullYear(startDate.getUTCFullYear());
    if (coupDate < startDate) {
      coupDate.setUTCFullYear(coupDate.getUTCFullYear() + 1);
    }
    while (coupDate > startDate) {
      coupDate.setUTCMonth(coupDate.getUTCMonth() - 12 / frequency);
    }
    let earlyCouponSerialNumber = excelDateSerial(coupDate);
    coupDate.setUTCMonth(coupDate.getUTCMonth() + 12 / frequency);
    let lateCouponSerialNumber = excelDateSerial(coupDate);
    if (lateCouponSerialNumber >= endDateSerialNumber) {
      const { days } = getTwoDateDaysByBasis(startDateSerialNumber, endDateSerialNumber, basis);
      const coupdays = calculateCoupdays(earlyCouponSerialNumber, lateCouponSerialNumber, frequency, basis);
      return days / coupdays;
    }
    const { days: daysF } = getTwoDateDaysByBasis(startDateSerialNumber, lateCouponSerialNumber, basis);
    const coupdaysF = calculateCoupdays(earlyCouponSerialNumber, lateCouponSerialNumber, frequency, basis);
    let result = daysF / coupdaysF;
    const earlyCoupon = excelSerialToDate(lateCouponSerialNumber);
    const lateCoupon = excelSerialToDate(lateCouponSerialNumber);
    lateCoupon.setUTCMonth(lateCoupon.getUTCMonth() + 12 / frequency);
    while (lateCoupon < endDate) {
      earlyCoupon.setUTCMonth(earlyCoupon.getUTCMonth() + 12 / frequency);
      lateCoupon.setUTCMonth(lateCoupon.getUTCMonth() + 12 / frequency);
      result += 1;
    }
    earlyCouponSerialNumber = excelDateSerial(earlyCoupon);
    lateCouponSerialNumber = excelDateSerial(lateCoupon);
    const { days: daysL } = getTwoDateDaysByBasis(earlyCouponSerialNumber, endDateSerialNumber, basis);
    const coupdaysL = calculateCoupdays(earlyCouponSerialNumber, lateCouponSerialNumber, frequency, basis);
    result += daysL / coupdaysL;
    return result;
  }
};

// ../packages/engine-formula/src/functions/financial/pduration/index.ts
var Pduration = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(rate, pv, fv) {
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1,
      fv.isArray() ? fv.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1,
      fv.isArray() ? fv.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, fv, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, pvObject, fvObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _pvObject, _fvObject] = variants;
      const rateValue = +_rateObject.getValue();
      const pvValue = +_pvObject.getValue();
      const fvValue = +_fvObject.getValue();
      if (rateValue <= -1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = (Math.log(fvValue) - Math.log(pvValue)) / Math.log(1 + rateValue);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/pmt/index.ts
var Pmt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
    __publicField(this, "needsLocale", true);
  }
  calculate(rate, nper, pv, fv, type2) {
    const _fv = fv != null ? fv : NumberValueObject.create(0);
    const _type = type2 != null ? type2 : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      nper.isArray() ? nper.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1,
      _fv.isArray() ? _fv.getRowCount() : 1,
      _type.isArray() ? _type.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      nper.isArray() ? nper.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1,
      _fv.isArray() ? _fv.getColumnCount() : 1,
      _type.isArray() ? _type.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, _fv, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _type, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const nperObject = nperArray.get(rowIndex, columnIndex);
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const typeObject = typeArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, nperObject, pvObject, fvObject, typeObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _nperObject, _pvObject, _fvObject, _typeObject] = variants;
      const rateValue = +_rateObject.getValue();
      const nperValue = +_nperObject.getValue();
      const pvValue = +_pvObject.getValue();
      const fvValue = +_fvObject.getValue();
      const typeValue = +_typeObject.getValue();
      if (rateValue <= -1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = calculatePMT(rateValue, nperValue, pvValue, fvValue, typeValue ? 1 : 0);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      } else {
        return NumberValueObject.create(result);
      }
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/ppmt/index.ts
var Ppmt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 6);
    __publicField(this, "needsLocale", true);
  }
  calculate(rate, per, nper, pv, fv, type2) {
    const _fv = fv != null ? fv : NumberValueObject.create(0);
    const _type = type2 != null ? type2 : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      per.isArray() ? per.getRowCount() : 1,
      nper.isArray() ? nper.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1,
      _fv.isArray() ? _fv.getRowCount() : 1,
      _type.isArray() ? _type.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      per.isArray() ? per.getColumnCount() : 1,
      nper.isArray() ? nper.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1,
      _fv.isArray() ? _fv.getColumnCount() : 1,
      _type.isArray() ? _type.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const perArray = expandArrayValueObject(maxRowLength, maxColumnLength, per, ErrorValueObject.create("#N/A" /* NA */));
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, _fv, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _type, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const perObject = perArray.get(rowIndex, columnIndex);
      const nperObject = nperArray.get(rowIndex, columnIndex);
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const typeObject = typeArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, perObject, nperObject, pvObject, fvObject, typeObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _perObject, _nperObject, _pvObject, _fvObject, _typeObject] = variants;
      const rateValue = +_rateObject.getValue();
      const perValue = +_perObject.getValue();
      const nperValue = +_nperObject.getValue();
      const pvValue = +_pvObject.getValue();
      const fvValue = +_fvObject.getValue();
      const typeValue = +_typeObject.getValue();
      if (perValue < 1 || Math.floor(perValue) > Math.ceil(nperValue) || perValue - nperValue >= 1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = calculatePMT(rateValue, nperValue, pvValue, fvValue, typeValue ? 1 : 0) - calculateIPMT(rateValue, perValue, nperValue, pvValue, fvValue, typeValue ? 1 : 0);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      } else {
        return NumberValueObject.create(result);
      }
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/price/index.ts
var Price = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 6);
    __publicField(this, "maxParams", 7);
  }
  calculate(settlement, maturity, rate, yld, redemption, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, rate, yld, redemption, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, rateObject, yldObject, redemptionObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const yldValue = +yldObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(yldValue) || Number.isNaN(redemptionValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue < 0 || yldValue < 0 || redemptionValue <= 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || settlementSerialNumber >= maturitySerialNumber || !validCouppcdIsGte0ByTwoDate(settlementSerialNumber, maturitySerialNumber, frequencyValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = calculatePrice(settlementSerialNumber, maturitySerialNumber, rateValue, yldValue, redemptionValue, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/pricedisc/index.ts
var Pricedisc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
  }
  calculate(settlement, maturity, discount, redemption, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, discount, redemption, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, discountObject, redemptionObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const discountValue = +discountObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(discountValue) || Number.isNaN(redemptionValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (discountValue <= 0 || redemptionValue <= 0 || basisValue < 0 || basisValue > 4 || settlementSerialNumber >= maturitySerialNumber) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const { days: DSM, yearDays: B } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basisValue);
    const result = redemptionValue - discountValue * redemptionValue * DSM / B;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/pricemat/index.ts
var Pricemat = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 5);
    __publicField(this, "maxParams", 6);
  }
  calculate(settlement, maturity, issue, rate, yld, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, issue, rate, yld, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, issueObject, rateObject, yldObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const issueSerialNumber = getDateSerialNumberByObject(issueObject);
    if (typeof issueSerialNumber !== "number") {
      return issueSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const yldValue = +yldObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(yldValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const isCorrectOrder = this._getDateCorrectOrder(maturitySerialNumber, settlementSerialNumber, issueSerialNumber);
    if (rateValue < 0 || yldValue < 0 || basisValue < 0 || basisValue > 4 || !isCorrectOrder) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const B = getNormalYearDaysByBasis(settlementSerialNumber, basisValue);
    const { days: DSM } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basisValue);
    const { days: DIM } = getTwoDateDaysByBasis(issueSerialNumber, maturitySerialNumber, basisValue);
    const { days: A } = getTwoDateDaysByBasis(issueSerialNumber, settlementSerialNumber, basisValue);
    const result = (100 + DIM / B * rateValue * 100) / (1 + DSM / B * yldValue) - A / B * rateValue * 100;
    return NumberValueObject.create(result);
  }
  _getDateCorrectOrder(maturitySerialNumber, settlementSerialNumber, issueSerialNumber) {
    return Math.floor(maturitySerialNumber) > Math.floor(settlementSerialNumber) && Math.floor(settlementSerialNumber) > Math.floor(issueSerialNumber);
  }
};

// ../packages/engine-formula/src/functions/financial/pv/index.ts
var Pv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
    __publicField(this, "needsLocale", true);
  }
  calculate(rate, nper, pmt, fv, type2) {
    const _fv = fv != null ? fv : NumberValueObject.create(0);
    const _type = type2 != null ? type2 : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      rate.isArray() ? rate.getRowCount() : 1,
      nper.isArray() ? nper.getRowCount() : 1,
      pmt.isArray() ? pmt.getRowCount() : 1,
      _fv.isArray() ? _fv.getRowCount() : 1,
      _type.isArray() ? _type.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rate.isArray() ? rate.getColumnCount() : 1,
      nper.isArray() ? nper.getColumnCount() : 1,
      pmt.isArray() ? pmt.getColumnCount() : 1,
      _fv.isArray() ? _fv.getColumnCount() : 1,
      _type.isArray() ? _type.getColumnCount() : 1
    );
    const rateArray = expandArrayValueObject(maxRowLength, maxColumnLength, rate, ErrorValueObject.create("#N/A" /* NA */));
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pmtArray = expandArrayValueObject(maxRowLength, maxColumnLength, pmt, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, _fv, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _type, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rateArray.map((rateObject, rowIndex, columnIndex) => {
      const nperObject = nperArray.get(rowIndex, columnIndex);
      const pmtObject = pmtArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const typeObject = typeArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rateObject, nperObject, pmtObject, fvObject, typeObject);
      if (isError) {
        return errorObject;
      }
      const [_rateObject, _nperObject, _pmtObject, _fvObject, _typeObject] = variants;
      const rateValue = +_rateObject.getValue();
      const nperValue = +_nperObject.getValue();
      const pmtValue = +_pmtObject.getValue();
      const fvValue = +_fvObject.getValue();
      let typeValue = +_typeObject.getValue();
      typeValue = typeValue ? 1 : 0;
      const result = rateValue === 0 ? -pmtValue * nperValue - fvValue : ((1 - (1 + rateValue) ** nperValue) / rateValue * pmtValue * (1 + rateValue * typeValue) - fvValue) / (1 + rateValue) ** nperValue;
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      } else {
        return NumberValueObject.create(result);
      }
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/rate/index.ts
var Rate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 6);
  }
  calculate(nper, pmt, pv, fv, type2, guess) {
    const _fv = fv != null ? fv : NumberValueObject.create(0);
    const _type = type2 != null ? type2 : NumberValueObject.create(0);
    const _guess = guess != null ? guess : NumberValueObject.create(0.1);
    const maxRowLength = Math.max(
      nper.isArray() ? nper.getRowCount() : 1,
      pmt.isArray() ? pmt.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1,
      _fv.isArray() ? _fv.getRowCount() : 1,
      _type.isArray() ? _type.getRowCount() : 1,
      _guess.isArray() ? _guess.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      nper.isArray() ? nper.getColumnCount() : 1,
      pmt.isArray() ? pmt.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1,
      _fv.isArray() ? _fv.getColumnCount() : 1,
      _type.isArray() ? _type.getColumnCount() : 1,
      _guess.isArray() ? _guess.getColumnCount() : 1
    );
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pmtArray = expandArrayValueObject(maxRowLength, maxColumnLength, pmt, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, _fv, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _type, ErrorValueObject.create("#N/A" /* NA */));
    const guessArray = expandArrayValueObject(maxRowLength, maxColumnLength, _guess, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = nperArray.map((nperObject, rowIndex, columnIndex) => {
      const pmtObject = pmtArray.get(rowIndex, columnIndex);
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const typeObject = typeArray.get(rowIndex, columnIndex);
      const guessObject = guessArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(nperObject, pmtObject, pvObject, fvObject, typeObject, guessObject);
      if (isError) {
        return errorObject;
      }
      const [_nperObject, _pmtObject, _pvObject, _fvObject, _typeObject, _guessObject] = variants;
      const nperValue = +_nperObject.getValue();
      const pmtValue = +_pmtObject.getValue();
      const pvValue = +_pvObject.getValue();
      const fvValue = +_fvObject.getValue();
      let typeValue = +_typeObject.getValue();
      const guessValue = +_guessObject.getValue();
      typeValue = typeValue ? 1 : 0;
      if (nperValue <= 0 || pmtValue >= 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return this._getResult(nperValue, pmtValue, pvValue, fvValue, typeValue, guessValue, rowIndex, columnIndex);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResult(nperValue, pmtValue, pvValue, fvValue, typeValue, guessValue, rowIndex, columnIndex) {
    const epsMax = 1e-10;
    const iterMax = 20;
    let result = guessValue;
    for (let i = 0; i < iterMax; i++) {
      if (result <= -1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      let y, f;
      if (Math.abs(result) < epsMax) {
        y = pvValue * (1 + nperValue * result) + pmtValue * (1 + result * typeValue) * nperValue + fvValue;
      } else {
        f = (1 + result) ** nperValue;
        y = pvValue * f + pmtValue * (1 / result + typeValue) * (f - 1) + fvValue;
      }
      if (Math.abs(y) < epsMax) {
        break;
      }
      let dy;
      if (Math.abs(result) < epsMax) {
        dy = pvValue * nperValue + pmtValue * typeValue * nperValue;
      } else {
        f = (1 + result) ** nperValue;
        const df = nperValue * (1 + result) ** (nperValue - 1);
        dy = pvValue * df + pmtValue * (1 / result + typeValue) * df + pmtValue * (-1 / (result * result)) * (f - 1);
      }
      result -= y / dy;
    }
    if (rowIndex === 0 && columnIndex === 0) {
      return NumberValueObject.create(result, "0%");
    } else {
      return NumberValueObject.create(result);
    }
  }
};

// ../packages/engine-formula/src/functions/financial/received/index.ts
var Received = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
  }
  calculate(settlement, maturity, investment, discount, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, investment, discount, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, investmentObject, discountObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const investmentValue = +investmentObject.getValue();
    const discountValue = +discountObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(investmentValue) || Number.isNaN(discountValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (investmentValue <= 0 || discountValue <= 0 || basisValue < 0 || basisValue > 4 || settlementSerialNumber >= maturitySerialNumber) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const { days: DSM, yearDays: B } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basisValue);
    const result = investmentValue / (1 - discountValue * DSM / B);
    if (result < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/rri/index.ts
var Rri = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 6);
  }
  calculate(nper, pv, fv) {
    const maxRowLength = Math.max(
      nper.isArray() ? nper.getRowCount() : 1,
      pv.isArray() ? pv.getRowCount() : 1,
      fv.isArray() ? fv.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      nper.isArray() ? nper.getColumnCount() : 1,
      pv.isArray() ? pv.getColumnCount() : 1,
      fv.isArray() ? fv.getColumnCount() : 1
    );
    const nperArray = expandArrayValueObject(maxRowLength, maxColumnLength, nper, ErrorValueObject.create("#N/A" /* NA */));
    const pvArray = expandArrayValueObject(maxRowLength, maxColumnLength, pv, ErrorValueObject.create("#N/A" /* NA */));
    const fvArray = expandArrayValueObject(maxRowLength, maxColumnLength, fv, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = nperArray.map((nperObject, rowIndex, columnIndex) => {
      const pvObject = pvArray.get(rowIndex, columnIndex);
      const fvObject = fvArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(nperObject, pvObject, fvObject);
      if (isError) {
        return errorObject;
      }
      const [_nperObject, _pvObject, _fvObject] = variants;
      const nperValue = +_nperObject.getValue();
      const pvValue = +_pvObject.getValue();
      const fvValue = +_fvObject.getValue();
      if (nperValue <= 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (pvValue === 0 && fvValue === 0) {
        return NumberValueObject.create(0);
      }
      const result = (fvValue / pvValue) ** (1 / nperValue) - 1;
      if (Number.isNaN(result) || !Number.isFinite(result) || fvValue / pvValue < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/sln/index.ts
var Sln = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsLocale", true);
  }
  calculate(cost, salvage, life) {
    const maxRowLength = Math.max(
      cost.isArray() ? cost.getRowCount() : 1,
      salvage.isArray() ? salvage.getRowCount() : 1,
      life.isArray() ? life.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      cost.isArray() ? cost.getColumnCount() : 1,
      salvage.isArray() ? salvage.getColumnCount() : 1,
      life.isArray() ? life.getColumnCount() : 1
    );
    const costArray = expandArrayValueObject(maxRowLength, maxColumnLength, cost, ErrorValueObject.create("#N/A" /* NA */));
    const salvageArray = expandArrayValueObject(maxRowLength, maxColumnLength, salvage, ErrorValueObject.create("#N/A" /* NA */));
    const lifeArray = expandArrayValueObject(maxRowLength, maxColumnLength, life, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = costArray.map((costObject, rowIndex, columnIndex) => {
      const salvageObject = salvageArray.get(rowIndex, columnIndex);
      const lifeObject = lifeArray.get(rowIndex, columnIndex);
      if (salvageObject.isError()) {
        return salvageObject;
      }
      if (lifeObject.isError()) {
        return lifeObject;
      }
      const costValue = +costObject.getValue();
      const salvageValue = +salvageObject.getValue();
      const lifeValue = +lifeObject.getValue();
      if (Number.isNaN(costValue) || Number.isNaN(salvageValue) || Number.isNaN(lifeValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (lifeValue === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = (costValue - salvageValue) / lifeValue;
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/syd/index.ts
var Syd = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
    __publicField(this, "needsLocale", true);
  }
  calculate(cost, salvage, life, per) {
    const maxRowLength = Math.max(
      cost.isArray() ? cost.getRowCount() : 1,
      salvage.isArray() ? salvage.getRowCount() : 1,
      life.isArray() ? life.getRowCount() : 1,
      per.isArray() ? per.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      cost.isArray() ? cost.getColumnCount() : 1,
      salvage.isArray() ? salvage.getColumnCount() : 1,
      life.isArray() ? life.getColumnCount() : 1,
      per.isArray() ? per.getColumnCount() : 1
    );
    const costArray = expandArrayValueObject(maxRowLength, maxColumnLength, cost, ErrorValueObject.create("#N/A" /* NA */));
    const salvageArray = expandArrayValueObject(maxRowLength, maxColumnLength, salvage, ErrorValueObject.create("#N/A" /* NA */));
    const lifeArray = expandArrayValueObject(maxRowLength, maxColumnLength, life, ErrorValueObject.create("#N/A" /* NA */));
    const perArray = expandArrayValueObject(maxRowLength, maxColumnLength, per, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = costArray.map((costObject, rowIndex, columnIndex) => {
      const salvageObject = salvageArray.get(rowIndex, columnIndex);
      const lifeObject = lifeArray.get(rowIndex, columnIndex);
      const perObject = perArray.get(rowIndex, columnIndex);
      if (salvageObject.isError()) {
        return salvageObject;
      }
      if (lifeObject.isError()) {
        return lifeObject;
      }
      if (perObject.isError()) {
        return perObject;
      }
      const costValue = +costObject.getValue();
      const salvageValue = +salvageObject.getValue();
      const lifeValue = +lifeObject.getValue();
      const perValue = +perObject.getValue();
      if (Number.isNaN(costValue) || Number.isNaN(salvageValue) || Number.isNaN(lifeValue) || Number.isNaN(perValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (salvageValue < 0 || lifeValue <= 0 || perValue > lifeValue) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = (costValue - salvageValue) * (lifeValue - perValue + 1) * 2 / (lifeValue * (lifeValue + 1));
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/financial/tbilleq/index.ts
var Tbilleq = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(settlement, maturity, discount) {
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, discount);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, discountObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const discountValue = +discountObject.getValue();
    if (Number.isNaN(discountValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (discountValue <= 0 || settlementSerialNumber >= maturitySerialNumber) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const DSM = Math.floor(maturitySerialNumber) - Math.floor(settlementSerialNumber);
    const date = excelSerialToDate(settlementSerialNumber);
    const year = date.getUTCFullYear();
    const yearDays = getDaysInYear(year);
    if (DSM > yearDays) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = 365 * discountValue / (360 - discountValue * DSM);
    if (DSM > 182) {
      const tbillPrice = 100 * (1 - discountValue * DSM / 360);
      const fraction = DSM / 365;
      result = (-fraction + Math.sqrt(fraction * fraction - (fraction * 2 - 1) * (1 - 100 / tbillPrice))) / (fraction - 0.5);
      if (Number.isNaN(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
    }
    if (result < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/tbillprice/index.ts
var Tbillprice = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsLocale", true);
  }
  calculate(settlement, maturity, discount) {
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, discount);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, discountObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const discountValue = +discountObject.getValue();
    if (Number.isNaN(discountValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (discountValue <= 0 || settlementSerialNumber >= maturitySerialNumber) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const DSM = Math.floor(maturitySerialNumber) - Math.floor(settlementSerialNumber);
    const date = excelSerialToDate(settlementSerialNumber);
    const year = date.getUTCFullYear();
    const yearDays = getDaysInYear(year);
    if (DSM > yearDays) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = 100 * (1 - discountValue * DSM / 360);
    if (result < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
  }
};

// ../packages/engine-formula/src/functions/financial/tbillyield/index.ts
var Tbillyield = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(settlement, maturity, pr) {
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, pr);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, prObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const prValue = +prObject.getValue();
    if (Number.isNaN(prValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (prValue <= 0 || settlementSerialNumber >= maturitySerialNumber) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const DSM = Math.floor(maturitySerialNumber) - Math.floor(settlementSerialNumber);
    const date = excelSerialToDate(settlementSerialNumber);
    const year = date.getUTCFullYear();
    const yearDays = getDaysInYear(year);
    if (DSM > yearDays) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = (100 - prValue) / prValue * 360 / DSM;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/vdb/index.ts
var Vdb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 5);
    __publicField(this, "maxParams", 7);
    __publicField(this, "needsLocale", true);
  }
  calculate(cost, salvage, life, startPeriod, endPeriod, factor, noSwitch) {
    let _factor = factor != null ? factor : NumberValueObject.create(2);
    if (_factor.isNull()) {
      _factor = NumberValueObject.create(2);
    }
    let _noSwitch = noSwitch != null ? noSwitch : BooleanValueObject.create(false);
    if (_noSwitch.isNull()) {
      _noSwitch = BooleanValueObject.create(false);
    }
    const maxRowLength = Math.max(
      cost.isArray() ? cost.getRowCount() : 1,
      salvage.isArray() ? salvage.getRowCount() : 1,
      life.isArray() ? life.getRowCount() : 1,
      startPeriod.isArray() ? startPeriod.getRowCount() : 1,
      endPeriod.isArray() ? endPeriod.getRowCount() : 1,
      _factor.isArray() ? _factor.getRowCount() : 1,
      _noSwitch.isArray() ? _noSwitch.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      cost.isArray() ? cost.getColumnCount() : 1,
      salvage.isArray() ? salvage.getColumnCount() : 1,
      life.isArray() ? life.getColumnCount() : 1,
      startPeriod.isArray() ? startPeriod.getColumnCount() : 1,
      endPeriod.isArray() ? endPeriod.getColumnCount() : 1,
      _factor.isArray() ? _factor.getColumnCount() : 1,
      _noSwitch.isArray() ? _noSwitch.getColumnCount() : 1
    );
    const costArray = expandArrayValueObject(maxRowLength, maxColumnLength, cost, ErrorValueObject.create("#N/A" /* NA */));
    const salvageArray = expandArrayValueObject(maxRowLength, maxColumnLength, salvage, ErrorValueObject.create("#N/A" /* NA */));
    const lifeArray = expandArrayValueObject(maxRowLength, maxColumnLength, life, ErrorValueObject.create("#N/A" /* NA */));
    const startPeriodArray = expandArrayValueObject(maxRowLength, maxColumnLength, startPeriod, ErrorValueObject.create("#N/A" /* NA */));
    const endPeriodArray = expandArrayValueObject(maxRowLength, maxColumnLength, endPeriod, ErrorValueObject.create("#N/A" /* NA */));
    const factorArray = expandArrayValueObject(maxRowLength, maxColumnLength, _factor, ErrorValueObject.create("#N/A" /* NA */));
    const noSwitchArray = expandArrayValueObject(maxRowLength, maxColumnLength, _noSwitch, ErrorValueObject.create("#N/A" /* NA */));
    return this._getResultArray(
      costArray,
      salvageArray,
      lifeArray,
      startPeriodArray,
      endPeriodArray,
      factorArray,
      noSwitchArray,
      maxRowLength,
      maxColumnLength
    );
  }
  _getResultArray(costArray, salvageArray, lifeArray, startPeriodArray, endPeriodArray, factorArray, noSwitchArray, maxRowLength, maxColumnLength) {
    const resultArray = costArray.map((costObject, rowIndex, columnIndex) => {
      const salvageObject = salvageArray.get(rowIndex, columnIndex);
      const lifeObject = lifeArray.get(rowIndex, columnIndex);
      const startPeriodObject = startPeriodArray.get(rowIndex, columnIndex);
      const endPeriodObject = endPeriodArray.get(rowIndex, columnIndex);
      const factorObject = factorArray.get(rowIndex, columnIndex);
      const noSwitchObject = noSwitchArray.get(rowIndex, columnIndex);
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(costObject, salvageObject, lifeObject, startPeriodObject, endPeriodObject, factorObject, noSwitchObject);
      if (isError) {
        return errorObject;
      }
      const [_costObject, _salvageObject, _lifeObject, _startPeriodObject, _endPeriodObject, _factorObject, _noSwitchObject] = variants;
      const costValue = +_costObject.getValue();
      const salvageValue = +_salvageObject.getValue();
      const lifeValue = +_lifeObject.getValue();
      const startPeriodValue = +_startPeriodObject.getValue();
      const endPeriodValue = +_endPeriodObject.getValue();
      const factorValue = +_factorObject.getValue();
      const noSwitchValue = +_noSwitchObject.getValue();
      if (costValue < 0 || salvageValue < 0 || lifeValue < 0 || startPeriodValue < 0 || endPeriodValue < 0 || endPeriodValue > lifeValue || startPeriodValue > endPeriodValue || factorValue < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (lifeValue === 0 && startPeriodValue === 0 && endPeriodValue === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = this._getResult(costValue, salvageValue, lifeValue, startPeriodValue, endPeriodValue, factorValue, noSwitchValue);
      if (rowIndex === 0 && columnIndex === 0) {
        return NumberValueObject.create(result, getCurrencyFormat(this.getLocale()));
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResult(cost, salvage, life, startPeriod, endPeriod, factor, noSwitch) {
    const start = Math.floor(startPeriod);
    const end = Math.ceil(endPeriod);
    let result = 0;
    if (cost < salvage) {
      if (startPeriod >= 1 || noSwitch) {
        return result;
      }
      const tempMinus = Math.abs(cost - salvage);
      result = tempMinus * (endPeriod - startPeriod) > tempMinus ? tempMinus : tempMinus * (endPeriod - startPeriod);
      return -result;
    }
    if (noSwitch) {
      for (let i = start + 1; i <= end; i++) {
        let ddb = calculateDDB(cost, salvage, life, i, factor);
        if (i === start + 1) {
          ddb *= Math.min(endPeriod, start + 1) - startPeriod;
        } else if (i === end) {
          ddb *= endPeriod + 1 - end;
        }
        result += ddb;
      }
    } else {
      const _cost = cost - this._getVdb(cost, salvage, life, life, startPeriod, factor);
      result = this._getVdb(_cost, salvage, life, life - startPeriod, endPeriod - startPeriod, factor);
    }
    return result;
  }
  _getVdb(cost, salvage, life, startPeriod, endPeriod, factor) {
    const end = Math.ceil(endPeriod);
    let result = 0;
    let rest = cost - salvage;
    let sln = 0;
    let temp = 0;
    let flag = false;
    for (let i = 1; i <= end; i++) {
      if (!flag) {
        const ddb = calculateDDB(cost, salvage, life, i, factor);
        sln = rest / (startPeriod - (i - 1));
        if (sln > ddb) {
          temp = sln;
          flag = true;
        } else {
          temp = ddb;
          rest -= ddb;
        }
      } else {
        temp = sln;
      }
      if (i === end) {
        temp *= endPeriod + 1 - end;
      }
      result += temp;
    }
    return result;
  }
};

// ../packages/engine-formula/src/functions/financial/xirr/index.ts
var Xirr = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(values, dates, guess) {
    if (values.isNull() || dates.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObejct, _values, _dates } = this._checkErrors(values, dates);
    if (isError) {
      return errorObejct;
    }
    let _guess = guess != null ? guess : NumberValueObject.create(0.1);
    if (_guess.isNull()) {
      _guess = NumberValueObject.create(0.1);
    }
    const { isError: _isError_guess, errorObject: _errorObject_guess, variants } = checkVariantsErrorIsArrayOrBoolean(_guess);
    if (_isError_guess) {
      return _errorObject_guess;
    }
    const [guessObject] = variants;
    const guessValue = +guessObject.getValue();
    if (Number.isNaN(guessValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const { positive, negative } = this._checkValues(_values);
    if (!positive || !negative || (_values == null ? void 0 : _values.length) !== (_dates == null ? void 0 : _dates.length) || guessValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = getResultByGuessIterF(guessValue, (rate) => this._iterF(_values, _dates, rate));
    if (typeof result !== "number") {
      return result;
    }
    return NumberValueObject.create(result);
  }
  _checkErrors(values, dates) {
    if (values.isError()) {
      return {
        isError: true,
        errorObejct: values
      };
    }
    if (dates.isError()) {
      return {
        isError: true,
        errorObejct: dates
      };
    }
    const { isError: isError_values, errorObejct: errorObejct_values, _values } = this._checkErrorValues(values);
    if (isError_values) {
      return {
        isError: isError_values,
        errorObejct: errorObejct_values
      };
    }
    const { isError: isError_dates, errorObejct: errorObejct_dates, _dates } = this._checkErrorDates(dates);
    if (isError_dates) {
      return {
        isError: isError_dates,
        errorObejct: errorObejct_dates
      };
    }
    return {
      isError: false,
      _values,
      _dates
    };
  }
  _checkErrorValues(values) {
    const _values = [];
    if (values.isArray()) {
      let isError = false;
      let errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
      values.iterator((valuesObject) => {
        const _valuesObject = valuesObject;
        if (_valuesObject.isError()) {
          isError = true;
          errorObejct = _valuesObject;
          return false;
        }
        if (_valuesObject.isBoolean()) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        const value = +_valuesObject.getValue();
        if (Number.isNaN(value)) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        _values.push(value);
      });
      if (isError) {
        return {
          isError,
          errorObejct
        };
      }
      if (_values.length <= 1) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#N/A" /* NA */)
        };
      }
      return {
        isError,
        _values
      };
    } else {
      const valuesValue = values.getValue();
      if (values.isBoolean() || values.isString() && !isRealNum(valuesValue)) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#VALUE!" /* VALUE */)
        };
      }
      return {
        isError: true,
        errorObejct: ErrorValueObject.create("#N/A" /* NA */)
      };
    }
  }
  _checkErrorDates(dates) {
    const _dates = [];
    if (dates.isArray()) {
      let isError = false;
      let errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
      dates.iterator((datesObject) => {
        if (datesObject == null ? void 0 : datesObject.isError()) {
          isError = true;
          errorObejct = datesObject;
          return false;
        }
        if (datesObject == null ? void 0 : datesObject.isBoolean()) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        const datesValue = +datesObject.getValue();
        if (Number.isNaN(datesValue)) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        if (datesValue < 0) {
          isError = true;
          errorObejct = ErrorValueObject.create("#NUM!" /* NUM */);
          return false;
        }
        _dates.push(Math.floor(datesValue));
      });
      if (isError) {
        return {
          isError,
          errorObejct
        };
      }
      if (_dates.length <= 1) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#N/A" /* NA */)
        };
      }
      return {
        isError,
        _dates
      };
    } else {
      const datesValue = dates.getValue();
      if (dates.isBoolean() || dates.isString() && !isRealNum(datesValue)) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#VALUE!" /* VALUE */)
        };
      }
      if (+datesValue < 0) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#NUM!" /* NUM */)
        };
      }
      return {
        isError: true,
        errorObejct: ErrorValueObject.create("#N/A" /* NA */)
      };
    }
  }
  _checkValues(values) {
    let positive = false;
    let negative = false;
    for (let i = 0; i < values.length; i++) {
      if (values[i] > 0) {
        positive = true;
      }
      if (values[i] < 0) {
        negative = true;
      }
    }
    return {
      positive,
      negative
    };
  }
  _iterF(values, dates, rate) {
    return values.reduce((total, value, index) => {
      return total + value / (1 + rate) ** ((dates[index] - dates[0]) / 365);
    }, 0);
  }
};

// ../packages/engine-formula/src/functions/financial/xnpv/index.ts
var Xnpv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(rate, values, dates) {
    if (rate.isNull() || values.isNull() || dates.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError: _isError_rate, errorObject: _errorObject_rate, variants } = checkVariantsErrorIsArrayOrBoolean(rate);
    if (_isError_rate) {
      return _errorObject_rate;
    }
    const [rateObject] = variants;
    const rateValue = +rateObject.getValue();
    if (Number.isNaN(rateValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let { isError, errorObejct, _values, _dates } = this._checkErrors(values, dates);
    if (isError) {
      return errorObejct;
    }
    _values = _values;
    _dates = _dates;
    if (rateValue < 0 || _values.length !== _dates.length) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = 0;
    const d1 = _dates[0];
    for (let i = 0; i < _dates.length; i++) {
      const di = _dates[i];
      const Pi2 = _values[i];
      result += Pi2 / (1 + rateValue) ** ((di - d1) / 365);
    }
    return NumberValueObject.create(result);
  }
  _checkErrors(values, dates) {
    if (values.isError()) {
      return {
        isError: true,
        errorObejct: values
      };
    }
    if (dates.isError()) {
      return {
        isError: true,
        errorObejct: dates
      };
    }
    const { isError: isError_values, errorObejct: errorObejct_values, _values } = this._checkErrorValues(values);
    if (isError_values) {
      return {
        isError: isError_values,
        errorObejct: errorObejct_values
      };
    }
    const { isError: isError_dates, errorObejct: errorObejct_dates, _dates } = this._checkErrorDates(dates);
    if (isError_dates) {
      return {
        isError: isError_dates,
        errorObejct: errorObejct_dates
      };
    }
    return {
      isError: false,
      _values,
      _dates
    };
  }
  _checkErrorValues(values) {
    const _values = [];
    if (values.isArray()) {
      let isError = false;
      let errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
      values.iterator((valuesObject) => {
        const _valuesObject = valuesObject;
        if (_valuesObject.isError()) {
          isError = true;
          errorObejct = _valuesObject;
          return false;
        }
        if (_valuesObject.isNull() || _valuesObject.isBoolean()) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        const value = +_valuesObject.getValue();
        if (Number.isNaN(value)) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        _values.push(value);
      });
      if (isError) {
        return {
          isError,
          errorObejct
        };
      }
      if (_values.length <= 1) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#N/A" /* NA */)
        };
      }
      return {
        isError,
        _values
      };
    } else {
      const valuesValue = values.getValue();
      if (values.isNull() || values.isBoolean() || values.isString() && !isRealNum(valuesValue)) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#VALUE!" /* VALUE */)
        };
      }
      return {
        isError: true,
        errorObejct: ErrorValueObject.create("#N/A" /* NA */)
      };
    }
  }
  _checkErrorDates(dates) {
    const _dates = [];
    if (dates.isArray()) {
      let isError = false;
      let errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
      dates.iterator((datesObject) => {
        const _datesObject = datesObject;
        if (_datesObject.isError()) {
          isError = true;
          errorObejct = _datesObject;
          return false;
        }
        if (_datesObject.isNull() || _datesObject.isBoolean()) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        const datesValue = +_datesObject.getValue();
        if (Number.isNaN(datesValue)) {
          isError = true;
          errorObejct = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        if (datesValue < 0) {
          isError = true;
          errorObejct = ErrorValueObject.create("#NUM!" /* NUM */);
          return false;
        }
        _dates.push(Math.floor(datesValue));
      });
      if (isError) {
        return {
          isError,
          errorObejct
        };
      }
      if (_dates.length <= 1) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#N/A" /* NA */)
        };
      }
      return {
        isError,
        _dates
      };
    } else {
      const datesValue = dates.getValue();
      if (dates.isNull() || dates.isBoolean() || dates.isString() && !isRealNum(datesValue)) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#VALUE!" /* VALUE */)
        };
      }
      if (+datesValue < 0) {
        return {
          isError: true,
          errorObejct: ErrorValueObject.create("#NUM!" /* NUM */)
        };
      }
      return {
        isError: true,
        errorObejct: ErrorValueObject.create("#N/A" /* NA */)
      };
    }
  }
};

// ../packages/engine-formula/src/functions/financial/yield/index.ts
var Yield = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 6);
    __publicField(this, "maxParams", 7);
  }
  calculate(settlement, maturity, rate, pr, redemption, frequency, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, rate, pr, redemption, frequency, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, rateObject, prObject, redemptionObject, frequencyObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const prValue = +prObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const frequencyValue = Math.floor(+frequencyObject.getValue());
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(prValue) || Number.isNaN(redemptionValue) || Number.isNaN(frequencyValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rateValue < 0 || prValue <= 0 || redemptionValue <= 0 || ![1, 2, 4].includes(frequencyValue) || basisValue < 0 || basisValue > 4 || settlementSerialNumber >= maturitySerialNumber || !validCouppcdIsGte0ByTwoDate(settlementSerialNumber, maturitySerialNumber, frequencyValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = this._getResult(settlementSerialNumber, maturitySerialNumber, rateValue, prValue, redemptionValue, frequencyValue, basisValue);
    return NumberValueObject.create(result);
  }
  _getResult(settlementSerialNumber, maturitySerialNumber, rate, pr, redemption, frequency, basis) {
    const N2 = calculateCoupnum(settlementSerialNumber, maturitySerialNumber, frequency);
    if (N2 > 1) {
      const g_Eps = 1e-7;
      let yld = rate || 0.01;
      let price = calculatePrice(settlementSerialNumber, maturitySerialNumber, rate, yld, redemption, frequency, basis);
      let eps = price - pr;
      for (let i = 0; i < 100 && Math.abs(eps) > g_Eps; i++) {
        price = calculatePrice(settlementSerialNumber, maturitySerialNumber, rate, 1.01 * yld, redemption, frequency, basis);
        yld += -eps / (price - pr - eps) * yld * 0.01;
        const priceN = calculatePrice(settlementSerialNumber, maturitySerialNumber, rate, yld, redemption, frequency, basis);
        eps = priceN - pr;
      }
      return yld;
    }
    const A = calculateCoupdaybs(settlementSerialNumber, maturitySerialNumber, frequency, basis);
    const E = calculateCoupdays(settlementSerialNumber, maturitySerialNumber, frequency, basis);
    const { days: DSR } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basis);
    const temp = pr / 100 + A / E * rate / frequency;
    const result = (redemption / 100 + rate / frequency - temp) / temp * frequency * E / DSR;
    return result;
  }
};

// ../packages/engine-formula/src/functions/financial/yielddisc/index.ts
var Yielddisc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 5);
  }
  calculate(settlement, maturity, pr, redemption, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, pr, redemption, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, prObject, redemptionObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const prValue = +prObject.getValue();
    const redemptionValue = +redemptionObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(prValue) || Number.isNaN(redemptionValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (prValue <= 0 || redemptionValue <= 0 || basisValue < 0 || basisValue > 4 || settlementSerialNumber >= maturitySerialNumber) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const { days: DSM, yearDays: B } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basisValue);
    const result = (redemptionValue / prValue - 1) / (DSM / B);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/financial/yieldmat/index.ts
var Yieldmat = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 5);
    __publicField(this, "maxParams", 6);
  }
  calculate(settlement, maturity, issue, rate, pr, basis) {
    let _basis = basis != null ? basis : NumberValueObject.create(0);
    if (_basis.isNull()) {
      _basis = NumberValueObject.create(0);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsNullorArrayOrBoolean(settlement, maturity, issue, rate, pr, _basis);
    if (isError) {
      return errorObject;
    }
    const [settlementObject, maturityObject, issueObject, rateObject, prObject, basisObject] = variants;
    const settlementSerialNumber = getDateSerialNumberByObject(settlementObject);
    if (typeof settlementSerialNumber !== "number") {
      return settlementSerialNumber;
    }
    const maturitySerialNumber = getDateSerialNumberByObject(maturityObject);
    if (typeof maturitySerialNumber !== "number") {
      return maturitySerialNumber;
    }
    const issueSerialNumber = getDateSerialNumberByObject(issueObject);
    if (typeof issueSerialNumber !== "number") {
      return issueSerialNumber;
    }
    const rateValue = +rateObject.getValue();
    const prValue = +prObject.getValue();
    const basisValue = Math.floor(+basisObject.getValue());
    if (Number.isNaN(rateValue) || Number.isNaN(prValue) || Number.isNaN(basisValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const isCorrectOrder = this._getDateCorrectOrder(maturitySerialNumber, settlementSerialNumber, issueSerialNumber);
    if (rateValue < 0 || prValue <= 0 || basisValue < 0 || basisValue > 4 || !isCorrectOrder) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const B = getNormalYearDaysByBasis(settlementSerialNumber, basisValue);
    const { days: DSM } = getTwoDateDaysByBasis(settlementSerialNumber, maturitySerialNumber, basisValue);
    const { days: DIM } = getTwoDateDaysByBasis(issueSerialNumber, maturitySerialNumber, basisValue);
    const { days: A } = getTwoDateDaysByBasis(issueSerialNumber, settlementSerialNumber, basisValue);
    const result = ((1 + DIM / B * rateValue) / (prValue / 100 + A / B * rateValue) - 1) / (DSM / B);
    return NumberValueObject.create(result);
  }
  _getDateCorrectOrder(maturitySerialNumber, settlementSerialNumber, issueSerialNumber) {
    return Math.floor(maturitySerialNumber) > Math.floor(settlementSerialNumber) && Math.floor(settlementSerialNumber) > Math.floor(issueSerialNumber);
  }
};

// ../packages/engine-formula/src/functions/financial/function-map.ts
var functionFinancial = [
  [Accrint, "ACCRINT" /* ACCRINT */],
  [Accrintm, "ACCRINTM" /* ACCRINTM */],
  [Amorlinc, "AMORLINC" /* AMORLINC */],
  [Coupdaybs, "COUPDAYBS" /* COUPDAYBS */],
  [Coupdays, "COUPDAYS" /* COUPDAYS */],
  [Coupdaysnc, "COUPDAYSNC" /* COUPDAYSNC */],
  [Coupncd, "COUPNCD" /* COUPNCD */],
  [Coupnum, "COUPNUM" /* COUPNUM */],
  [Couppcd, "COUPPCD" /* COUPPCD */],
  [Cumipmt, "CUMIPMT" /* CUMIPMT */],
  [Cumprinc, "CUMPRINC" /* CUMPRINC */],
  [Db, "DB" /* DB */],
  [Ddb, "DDB" /* DDB */],
  [Disc, "DISC" /* DISC */],
  [Dollarde, "DOLLARDE" /* DOLLARDE */],
  [Dollarfr, "DOLLARFR" /* DOLLARFR */],
  [Duration, "DURATION" /* DURATION */],
  [Effect, "EFFECT" /* EFFECT */],
  [Fv, "FV" /* FV */],
  [Fvschedule, "FVSCHEDULE" /* FVSCHEDULE */],
  [Intrate, "INTRATE" /* INTRATE */],
  [Ipmt, "IPMT" /* IPMT */],
  [Irr, "IRR" /* IRR */],
  [Ispmt, "ISPMT" /* ISPMT */],
  [Mduration, "MDURATION" /* MDURATION */],
  [Mirr, "MIRR" /* MIRR */],
  [Nominal, "NOMINAL" /* NOMINAL */],
  [Nper, "NPER" /* NPER */],
  [Npv, "NPV" /* NPV */],
  [Oddfprice, "ODDFPRICE" /* ODDFPRICE */],
  [Oddfyield, "ODDFYIELD" /* ODDFYIELD */],
  [Oddlprice, "ODDLPRICE" /* ODDLPRICE */],
  [Oddlyield, "ODDLYIELD" /* ODDLYIELD */],
  [Pduration, "PDURATION" /* PDURATION */],
  [Pmt, "PMT" /* PMT */],
  [Ppmt, "PPMT" /* PPMT */],
  [Price, "PRICE" /* PRICE */],
  [Pricedisc, "PRICEDISC" /* PRICEDISC */],
  [Pricemat, "PRICEMAT" /* PRICEMAT */],
  [Pv, "PV" /* PV */],
  [Rate, "RATE" /* RATE */],
  [Received, "RECEIVED" /* RECEIVED */],
  [Rri, "RRI" /* RRI */],
  [Sln, "SLN" /* SLN */],
  [Syd, "SYD" /* SYD */],
  [Tbilleq, "TBILLEQ" /* TBILLEQ */],
  [Tbillprice, "TBILLPRICE" /* TBILLPRICE */],
  [Tbillyield, "TBILLYIELD" /* TBILLYIELD */],
  [Vdb, "VDB" /* VDB */],
  [Xirr, "XIRR" /* XIRR */],
  [Xnpv, "XNPV" /* XNPV */],
  [Yield, "YIELD" /* YIELD */],
  [Yielddisc, "YIELDDISC" /* YIELDDISC */],
  [Yieldmat, "YIELDMAT" /* YIELDMAT */]
];

// ../packages/engine-formula/src/functions/information/cell/index.ts
var Cell = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "needsReferenceObject", true);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(infoType, reference) {
    let _infoType = infoType;
    if (_infoType.isError()) {
      return _infoType;
    }
    if (_infoType.isReferenceObject()) {
      _infoType = _infoType.toArrayValueObject();
    }
    if (_infoType.isArray()) {
      const rowCount = _infoType.getRowCount();
      const columnCount = _infoType.getColumnCount();
      if (rowCount === 1 && columnCount === 1) {
        const infoTypeObject = _infoType.get(0, 0);
        return this._handleSingleObject(infoTypeObject, reference);
      }
      return _infoType.map((infoTypeObject) => {
        if (infoTypeObject.isError()) {
          return infoTypeObject;
        }
        return this._handleSingleObject(infoTypeObject, reference, true);
      });
    }
    return this._handleSingleObject(_infoType, reference);
  }
  _handleSingleObject(infoType, reference, infoTypeIsArray = false) {
    let _reference = reference;
    if (_reference.isError()) {
      return _reference;
    }
    if (!_reference.isReferenceObject()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const currentActiveSheetData = _reference.getCurrentActiveSheetData();
    const { columnData, defaultColumnWidth } = currentActiveSheetData;
    _reference = _reference.toArrayValueObject();
    const _currentRow = _reference.getCurrentRow();
    const _currentColumn = _reference.getCurrentColumn();
    _reference = _reference.getFirstCell();
    const infoTypeValue = `${infoType.getValue()}`;
    let result;
    switch (infoTypeValue.toLocaleLowerCase()) {
      case "address":
        return StringValueObject.create(`$${Tools.chatAtABC(_currentColumn)}$${_currentRow + 1}`);
      case "col":
        return NumberValueObject.create(_currentColumn + 1);
      case "color":
        return NumberValueObject.create(0);
      case "contents":
        return _reference;
      case "filename":
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      case "format":
        return StringValueObject.create("G");
      case "parentheses":
        return NumberValueObject.create(0);
      case "prefix":
        return StringValueObject.create("");
      case "protect":
        return NumberValueObject.create(1);
      case "row":
        return NumberValueObject.create(_currentRow + 1);
      case "type":
        result = "v";
        if (_reference.isNull()) {
          result = "b";
        }
        if (_reference.isString()) {
          result = "l";
        }
        return StringValueObject.create(result);
      case "width":
        return this._getWidthResult(columnData, defaultColumnWidth, _currentColumn, infoTypeIsArray);
      default:
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  }
  _getWidthResult(columnData, defaultColumnWidth, _currentColumn, infoTypeIsArray) {
    var _a2;
    let result = (_a2 = columnData[_currentColumn]) == null ? void 0 : _a2.w;
    if (!result && result !== 0) {
      result = defaultColumnWidth;
    }
    if (infoTypeIsArray) {
      return NumberValueObject.create(result);
    }
    const resultArray = [[result, result === defaultColumnWidth]];
    return ArrayValueObject.createByArray(resultArray);
  }
};

// ../packages/engine-formula/src/functions/information/error-type/index.ts
var ErrorType2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
    __publicField(this, "_errorTypeValueMap", /* @__PURE__ */ new Map([
      ["#NULL!" /* NULL */, 1],
      ["#DIV/0!" /* DIV_BY_ZERO */, 2],
      ["#VALUE!" /* VALUE */, 3],
      ["#REF!" /* REF */, 4],
      ["#NAME?" /* NAME */, 5],
      ["#NUM!" /* NUM */, 6],
      ["#N/A" /* NA */, 7],
      ["#GETTING_DATA" /* CONNECT */, 8],
      ["#CALC!" /* CALC */, 14]
    ]));
  }
  calculate(errorVal) {
    if (errorVal.isArray()) {
      return errorVal.mapValue((errorValObject) => this._handleSingleObject(errorValObject));
    }
    return this._handleSingleObject(errorVal);
  }
  _handleSingleObject(errorVal) {
    const errorValValue = errorVal.getValue();
    const result = this._errorTypeValueMap.get(errorValValue);
    if (result) {
      return NumberValueObject.create(result);
    }
    return ErrorValueObject.create("#N/A" /* NA */);
  }
};

// ../packages/engine-formula/src/functions/information/isbetween/index.ts
var Isbetween = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
  }
  calculate(valueToCompare, lowerValue, upperValue, lowerValueIsInclusive, upperValueIsInclusive) {
    const _lowerValueIsInclusive = lowerValueIsInclusive != null ? lowerValueIsInclusive : BooleanValueObject.create(true);
    const _upperValueIsInclusive = upperValueIsInclusive != null ? upperValueIsInclusive : BooleanValueObject.create(true);
    const { isError, errorObject, variants } = checkVariantsErrorIsArray(valueToCompare, lowerValue, upperValue, _lowerValueIsInclusive, _upperValueIsInclusive);
    if (isError) {
      return errorObject;
    }
    const [valueToCompareObject, lowerValueObject, upperValueObject, lowerValueIsInclusiveObject, upperValueIsInclusiveObject] = variants;
    if (lowerValueIsInclusiveObject.isString() || upperValueIsInclusiveObject.isString()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const lowGreaterThanUpper = lowerValueObject.compare(upperValueObject, ">");
    if (lowGreaterThanUpper.getValue() === true) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const lowerValueIsInclusiveValue = +lowerValueIsInclusiveObject.getValue();
    const upperValueIsInclusiveValue = +upperValueIsInclusiveObject.getValue();
    const lowerComparisonOperator = lowerValueIsInclusiveValue ? ">=" : ">";
    const upperComparisonOperator = upperValueIsInclusiveValue ? "<=" : "<";
    const lowerComparison = valueToCompareObject.compare(lowerValueObject, lowerComparisonOperator);
    if (lowerComparison.getValue() === false) {
      return BooleanValueObject.create(false);
    }
    const upperComparison = valueToCompareObject.compare(upperValueObject, upperComparisonOperator);
    if (upperComparison.getValue() === false) {
      return BooleanValueObject.create(false);
    }
    return BooleanValueObject.create(true);
  }
};

// ../packages/engine-formula/src/functions/information/isblank/index.ts
var Isblank = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.isNull()) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (valueObject.isNull()) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/isdate/index.ts
var Isdate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    let _value = value;
    if (_value.isArray()) {
      const rowCount = _value.getRowCount();
      const columnCount = _value.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _value = _value.get(0, 0);
    }
    if (_value.isError()) {
      return _value;
    }
    if (_value.isNumber() && _value.getPattern() !== "") {
      return BooleanValueObject.create(isDate(_value.getPattern()));
    }
    if (_value.isString() && (parseFormattedDate(`${_value.getValue()}`) || parseFormattedTime(`${_value.getValue()}`))) {
      return BooleanValueObject.create(true);
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/isemail/index.ts
var Isemail = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    let _value = value;
    if (_value.isArray()) {
      const rowCount = _value.getRowCount();
      const columnCount = _value.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _value = _value.get(0, 0);
    }
    if (_value.isError()) {
      return _value;
    }
    if (_value.isNull() || _value.isBoolean() || _value.isNumber()) {
      return BooleanValueObject.create(false);
    }
    const val = `${_value.getValue()}`;
    if (val.length > 254) {
      return BooleanValueObject.create(false);
    }
    const topLevelDomain = Tools.topLevelDomainCombiningString();
    const reg = new RegExp(
      `^(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${topLevelDomain})$`,
      "i"
    );
    return BooleanValueObject.create(reg.test(val));
  }
};

// ../packages/engine-formula/src/functions/information/iserr/index.ts
var Iserr = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.getValue() === "#N/A" /* NA */) {
      return BooleanValueObject.create(false);
    }
    if (value.isError()) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (valueObject.getValue() === "#N/A" /* NA */) {
          return BooleanValueObject.create(false);
        }
        if (valueObject.isError()) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/iserror/index.ts
var Iserror = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.isError()) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (valueObject.isError()) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/iseven/iseven.ts
var Iseven = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    let _value = value;
    if (_value.isArray()) {
      const rowCount = _value.getRowCount();
      const columnCount = _value.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _value = _value.get(0, 0);
    }
    if (_value.isError()) {
      return _value;
    }
    if (_value.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const val = Math.trunc(+_value.getValue());
    if (Number.isNaN(val)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = val % 2 === 0;
    return BooleanValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/information/isformula/index.ts
var Isformula = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(reference) {
    var _a2;
    if (reference.isError()) {
      return reference;
    }
    if (!reference.isReferenceObject()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const cellDataMatrix = (_a2 = reference.getCurrentActiveSheetData()) == null ? void 0 : _a2.cellData.getMatrix();
    const { startRow, startColumn } = reference.getRangePosition();
    const _reference = reference.toArrayValueObject();
    const resultArray = _reference.mapValue((valueObject, rowIndex, columnIndex) => {
      var _a3;
      const cellData = (_a3 = cellDataMatrix == null ? void 0 : cellDataMatrix[startRow + rowIndex]) == null ? void 0 : _a3[startColumn + columnIndex];
      if ((cellData == null ? void 0 : cellData.f) || (cellData == null ? void 0 : cellData.si)) {
        return BooleanValueObject.create(true);
      }
      return BooleanValueObject.create(false);
    });
    if (_reference.getRowCount() === 1 && _reference.getColumnCount() === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/information/islogical/index.ts
var Islogical = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.isBoolean()) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (valueObject.isBoolean()) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/isna/index.ts
var Isna = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.getValue() === "#N/A" /* NA */) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (valueObject.getValue() === "#N/A" /* NA */) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/isnontext/index.ts
var Isnontext = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (!value.isArray() && !value.isString()) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (!valueObject.isString()) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/isnumber/index.ts
var Isnumber = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.isNumber()) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (valueObject.isNumber()) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/isodd/isodd.ts
var Isodd = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    let _value = value;
    if (_value.isArray()) {
      const rowCount = _value.getRowCount();
      const columnCount = _value.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _value = _value.get(0, 0);
    }
    if (_value.isError()) {
      return _value;
    }
    if (_value.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const val = Math.trunc(+_value.getValue());
    if (Number.isNaN(val)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = val % 2 !== 0;
    return BooleanValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/information/isref/index.ts
var Isref = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(value) {
    if (value.isReferenceObject()) {
      return BooleanValueObject.create(true);
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/istext/index.ts
var Istext = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.isString()) {
      return BooleanValueObject.create(true);
    } else if (value.isArray()) {
      return value.mapValue((valueObject) => {
        if (valueObject.isString()) {
          return BooleanValueObject.create(true);
        }
        return BooleanValueObject.create(false);
      });
    }
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/information/isurl/index.ts
var Isurl = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    let _value = value;
    if (_value.isArray()) {
      const rowCount = _value.getRowCount();
      const columnCount = _value.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _value = _value.get(0, 0);
    }
    if (_value.isError()) {
      return _value;
    }
    if (_value.isNull() || _value.isBoolean() || _value.isNumber()) {
      return BooleanValueObject.create(false);
    }
    const val = `${_value.getValue()}`.replace(/^\s+|\s+$/g, "");
    if (val.length > 1e3) {
      return BooleanValueObject.create(false);
    }
    const topLevelDomain = Tools.topLevelDomainCombiningString();
    const reg = new RegExp(
      `^(?:(?:https?|s?ftp|ftps|nfs|ssh)://+[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${topLevelDomain})(?::[0-9]+)?(?:/(?:[A-Za-z0-9\\-._~!$&'()*+,;=:@]|%[A-Fa-f0-9]{2})*)*/?(?:[?#]\\S*)?|mailto:(?:[\\w+-]+\\.)*[\\w+-]+@[a-z0-9_-]+(?:\\.[a-z0-9_-]+)*\\.(?:${topLevelDomain})|(?:news|aim):[%a-z0-9$_\\.+!*(),;/?#:@&~=-]+)$`,
      "i"
    );
    return BooleanValueObject.create(reg.test(val));
  }
};

// ../packages/engine-formula/src/functions/information/n/index.ts
var N = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    let _value = value;
    if (value.isArray()) {
      _value = value.get(0, 0);
    }
    if (_value.isError()) {
      return _value;
    }
    if (_value.isString()) {
      return NumberValueObject.create(0);
    }
    const val = +_value.getValue();
    return NumberValueObject.create(val);
  }
};

// ../packages/engine-formula/src/functions/information/na/index.ts
var Na = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
  }
  calculate() {
    return ErrorValueObject.create("#N/A" /* NA */);
  }
};

// ../packages/engine-formula/src/functions/information/sheet/index.ts
var Sheet = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 1);
    __publicField(this, "needsReferenceObject", true);
    __publicField(this, "needsSheetsInfo", true);
  }
  calculate(value) {
    var _a2;
    if (value == null ? void 0 : value.isError()) {
      return value;
    }
    const { sheetOrder, sheetNameMap } = this.getSheetsInfo();
    if (!value) {
      const sheetIndex2 = sheetOrder.findIndex((sheetId) => sheetId === this.subUnitId);
      return NumberValueObject.create(sheetIndex2 + 1);
    }
    if (value.isReferenceObject()) {
      const forcedSheetId = value.getForcedSheetId();
      const defaultSheetId = value.getDefaultSheetId();
      const sheetIndex2 = sheetOrder.findIndex((sheetId) => {
        if (forcedSheetId) {
          return sheetId === forcedSheetId;
        } else {
          return sheetId === defaultSheetId;
        }
      });
      return NumberValueObject.create(sheetIndex2 + 1);
    }
    if (value.isArray()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const inputValue = `${value.getValue()}`.toLocaleLowerCase();
    const inputSheetId = (_a2 = Object.entries(sheetNameMap).find(([_, name]) => name.toLocaleLowerCase() === inputValue)) == null ? void 0 : _a2[0];
    if (!inputSheetId) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const sheetIndex = sheetOrder.findIndex((sheetId) => sheetId === inputSheetId);
    return NumberValueObject.create(sheetIndex + 1);
  }
};

// ../packages/engine-formula/src/functions/information/sheets/index.ts
var Sheets = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
    __publicField(this, "needsSheetsInfo", true);
  }
  calculate() {
    const { sheetOrder } = this.getSheetsInfo();
    return NumberValueObject.create(sheetOrder.length);
  }
};

// ../packages/engine-formula/src/functions/information/type/index.ts
var Type = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "needsReferenceObject", true);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(value) {
    if (value.isReferenceObject()) {
      const rowCount = value.getRowCount();
      const columnCount = value.getColumnCount();
      if (rowCount === 1 && columnCount === 1) {
        const _value = value.getFirstCell();
        if (_value.isError()) {
          return NumberValueObject.create(16);
        }
        if (_value.isBoolean()) {
          return NumberValueObject.create(4);
        }
        if (_value.isString()) {
          return NumberValueObject.create(2);
        }
        if (_value.isNumber() || _value.isNull()) {
          return NumberValueObject.create(1);
        }
      } else {
        return NumberValueObject.create(64);
      }
    } else {
      if (value.isArray()) {
        return NumberValueObject.create(64);
      }
      if (value.isError()) {
        return NumberValueObject.create(16);
      }
      if (value.isBoolean()) {
        return NumberValueObject.create(4);
      }
      if (value.isString()) {
        return NumberValueObject.create(2);
      }
      if (value.isNumber() || value.isNull()) {
        return NumberValueObject.create(1);
      }
    }
    return NumberValueObject.create(128);
  }
};

// ../packages/engine-formula/src/functions/information/function-map.ts
var functionInformation = [
  [Cell, "CELL" /* CELL */],
  [ErrorType2, "ERROR.TYPE" /* ERROR_TYPE */],
  [Isbetween, "ISBETWEEN" /* ISBETWEEN */],
  [Isblank, "ISBLANK" /* ISBLANK */],
  [Isdate, "ISDATE" /* ISDATE */],
  [Isemail, "ISEMAIL" /* ISEMAIL */],
  [Iserr, "ISERR" /* ISERR */],
  [Iserror, "ISERROR" /* ISERROR */],
  [Iseven, "ISEVEN" /* ISEVEN */],
  [Isformula, "ISFORMULA" /* ISFORMULA */],
  [Islogical, "ISLOGICAL" /* ISLOGICAL */],
  [Isna, "ISNA" /* ISNA */],
  [Isnontext, "ISNONTEXT" /* ISNONTEXT */],
  [Isnumber, "ISNUMBER" /* ISNUMBER */],
  [Isodd, "ISODD" /* ISODD */],
  [Isref, "ISREF" /* ISREF */],
  [Istext, "ISTEXT" /* ISTEXT */],
  [Isurl, "ISURL" /* ISURL */],
  [N, "N" /* N */],
  [Na, "NA" /* NA */],
  [Sheet, "SHEET" /* SHEET */],
  [Sheets, "SHEETS" /* SHEETS */],
  [Type, "TYPE" /* TYPE */]
];

// ../packages/engine-formula/src/functions/logical/and/index.ts
var And = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...logicalValues) {
    let result = true;
    let noBoolean = true;
    let errorValue = null;
    for (const logicalValue of logicalValues) {
      if (logicalValue.isError()) {
        return logicalValue;
      }
      if (logicalValue.isArray()) {
        logicalValue.iterator((value) => {
          if (value == null ? void 0 : value.isError()) {
            errorValue = value;
            return false;
          } else if ((value == null ? void 0 : value.isBoolean()) || (value == null ? void 0 : value.isNumber())) {
            result = result && !!value.getValue();
            noBoolean = false;
          }
        });
        if (errorValue) {
          return errorValue;
        }
      } else if (logicalValue.isBoolean() || logicalValue.isNumber()) {
        result = result && !!logicalValue.getValue();
        noBoolean = false;
      }
    }
    return noBoolean ? ErrorValueObject.create("#VALUE!" /* VALUE */) : BooleanValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/logical/bycol/index.ts
var Bycol = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
    __publicField(this, "needsReferenceObject", true);
  }
  // eslint-disable-next-line
  calculate(array, lambda) {
    let _array = array;
    let _array_reference = null;
    if (array.isReferenceObject()) {
      _array = array.toArrayValueObject();
      _array_reference = array;
    }
    if (_array.isError()) {
      return _array;
    }
    if (lambda.isError()) {
      return lambda;
    }
    if (!(lambda.isValueObject() && lambda.isLambda() && lambda.getLambdaPrivacyVarKeys().length === 1)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const _lambda = lambda;
    const rowCount = _array.isArray() ? _array.getRowCount() : 1;
    const columnCount = _array.isArray() ? _array.getColumnCount() : 1;
    _array = expandArrayValueObject(rowCount, columnCount, _array);
    const result = [[]];
    for (let c = 0; c < columnCount; c++) {
      const rows = [];
      for (let r = 0; r < rowCount; r++) {
        const col = _array.get(r, c);
        rows.push([col]);
      }
      let lambdaVariant = ArrayValueObject.create({
        calculateValueList: rows,
        rowCount,
        columnCount: 1,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (_array_reference) {
        const { startRow, startColumn } = _array_reference.getRangePosition();
        const range = {
          startRow,
          startColumn: startColumn + c,
          endRow: startRow + rowCount - 1,
          endColumn: startColumn + c
        };
        lambdaVariant = this.createReferenceObject(_array_reference, range);
      }
      let value = _lambda.execute(lambdaVariant);
      if (value.isArray()) {
        const valueRowCount = value.getRowCount();
        const valueColumnCount = value.getColumnCount();
        if (valueRowCount > 1 || valueColumnCount > 1) {
          return ErrorValueObject.create("#CALC!" /* CALC */);
        }
        value = value.get(0, 0);
      }
      if (value.isNull()) {
        value = NumberValueObject.create(0);
      }
      result[0].push(value);
    }
    if (columnCount === 1) {
      return result[0][0];
    }
    return ArrayValueObject.create({
      calculateValueList: result,
      rowCount: 1,
      columnCount,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/logical/byrow/index.ts
var Byrow = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
    __publicField(this, "needsReferenceObject", true);
  }
  // eslint-disable-next-line
  calculate(array, lambda) {
    let _array = array;
    let _array_reference = null;
    if (array.isReferenceObject()) {
      _array = array.toArrayValueObject();
      _array_reference = array;
    }
    if (_array.isError()) {
      return _array;
    }
    if (lambda.isError()) {
      return lambda;
    }
    if (!(lambda.isValueObject() && lambda.isLambda() && lambda.getLambdaPrivacyVarKeys().length === 1)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const _lambda = lambda;
    const rowCount = _array.isArray() ? _array.getRowCount() : 1;
    const columnCount = _array.isArray() ? _array.getColumnCount() : 1;
    _array = expandArrayValueObject(rowCount, columnCount, _array);
    const result = [];
    for (let r = 0; r < rowCount; r++) {
      const rows = [[]];
      for (let c = 0; c < columnCount; c++) {
        const col = _array.get(r, c);
        rows[0].push(col);
      }
      let lambdaVariant = ArrayValueObject.create({
        calculateValueList: rows,
        rowCount: 1,
        columnCount,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
      if (_array_reference) {
        const { startRow, startColumn } = _array_reference.getRangePosition();
        const range = {
          startRow: startRow + r,
          startColumn,
          endRow: startRow + r,
          endColumn: startColumn + columnCount - 1
        };
        lambdaVariant = this.createReferenceObject(_array_reference, range);
      }
      let value = _lambda.execute(lambdaVariant);
      if (value.isArray()) {
        const valueRowCount = value.getRowCount();
        const valueColumnCount = value.getColumnCount();
        if (valueRowCount > 1 || valueColumnCount > 1) {
          return ErrorValueObject.create("#CALC!" /* CALC */);
        }
        value = value.get(0, 0);
      }
      if (value.isNull()) {
        value = NumberValueObject.create(0);
      }
      result.push([value]);
    }
    if (rowCount === 1) {
      return result[0][0];
    }
    return ArrayValueObject.create({
      calculateValueList: result,
      rowCount,
      columnCount: 1,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/logical/false/index.ts
var False = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
  }
  calculate() {
    return BooleanValueObject.create(false);
  }
};

// ../packages/engine-formula/src/functions/logical/if/index.ts
var If = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(logicalTest, valueIfTrue, valueIfFalse = BooleanValueObject.create(false)) {
    const _logicalTest = this._getSingleValueObject(logicalTest);
    if (_logicalTest.isError()) {
      return _logicalTest;
    }
    if (!_logicalTest.isArray()) {
      return _logicalTest.getValue() ? valueIfTrue : valueIfFalse;
    }
    const maxRowLength = Math.max(
      _logicalTest.isArray() ? _logicalTest.getRowCount() : 1,
      valueIfTrue.isArray() ? valueIfTrue.getRowCount() : 1,
      valueIfFalse.isArray() ? valueIfFalse.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _logicalTest.isArray() ? _logicalTest.getColumnCount() : 1,
      valueIfTrue.isArray() ? valueIfTrue.getColumnCount() : 1,
      valueIfFalse.isArray() ? valueIfFalse.getColumnCount() : 1
    );
    const logicalTestArray = expandArrayValueObject(maxRowLength, maxColumnLength, _logicalTest);
    const valueIfTrueArray = expandArrayValueObject(maxRowLength, maxColumnLength, valueIfTrue, ErrorValueObject.create("#N/A" /* NA */));
    const valueIfFalseArray = expandArrayValueObject(maxRowLength, maxColumnLength, valueIfFalse, ErrorValueObject.create("#N/A" /* NA */));
    return logicalTestArray.map((logicalTestValue, rowIndex, columnIndex) => {
      if (logicalTestValue.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      } else {
        const valueIfTrueValue = valueIfTrueArray.get(rowIndex, columnIndex) || NullValueObject.create();
        const valueIfFalseValue = valueIfFalseArray.get(rowIndex, columnIndex) || NullValueObject.create();
        return this._calculateSingleCell(logicalTestValue, valueIfTrueValue, valueIfFalseValue);
      }
    });
  }
  _getSingleValueObject(valueObject) {
    if (valueObject.isArray() && valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
      return valueObject.getFirstCell();
    }
    return valueObject;
  }
  _calculateSingleCell(logicalTest, valueIfTrue, valueIfFalse) {
    if (logicalTest.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const logicalTestValue = logicalTest.getValue();
    if (logicalTestValue) {
      if (valueIfTrue.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return valueIfTrue;
    }
    if (valueIfFalse.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    return valueIfFalse;
  }
};

// ../packages/engine-formula/src/functions/logical/iferror/index.ts
var Iferror = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(value, valueIfError) {
    if (!value.isArray()) {
      return value.isError() ? valueIfError : value;
    }
    const maxRowLength = Math.max(
      value.isArray() ? value.getRowCount() : 1,
      valueIfError.isArray() ? valueIfError.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      value.isArray() ? value.getColumnCount() : 1,
      valueIfError.isArray() ? valueIfError.getColumnCount() : 1
    );
    const valueArray = expandArrayValueObject(maxRowLength, maxColumnLength, value);
    const valueIfErrorArray = expandArrayValueObject(maxRowLength, maxColumnLength, valueIfError);
    valueArray.iterator((value2, rowIndex, columnIndex) => {
      if (value2 == null ? void 0 : value2.isError()) {
        valueArray.set(rowIndex, columnIndex, valueIfErrorArray.get(rowIndex, columnIndex));
      }
    });
    return valueArray;
  }
};

// ../packages/engine-formula/src/functions/logical/ifna/index.ts
var Ifna = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(value, valueIfNa) {
    if (value.isError() && value.getErrorType() !== "#N/A" /* NA */) {
      return value;
    }
    if (valueIfNa.isError()) {
      return valueIfNa;
    }
    if (!value.isArray()) {
      return value.isError() && value.getErrorType() === "#N/A" /* NA */ ? valueIfNa : value;
    }
    const maxRowLength = Math.max(
      value.isArray() ? value.getRowCount() : 1,
      valueIfNa.isArray() ? valueIfNa.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      value.isArray() ? value.getColumnCount() : 1,
      valueIfNa.isArray() ? valueIfNa.getColumnCount() : 1
    );
    const valueArray = expandArrayValueObject(maxRowLength, maxColumnLength, value);
    const valueIfNaArray = expandArrayValueObject(maxRowLength, maxColumnLength, valueIfNa);
    valueArray.iterator((cellValue, rowIndex, columnIndex) => {
      if ((cellValue == null ? void 0 : cellValue.isError()) && cellValue.getErrorType() === "#N/A" /* NA */) {
        valueArray.set(rowIndex, columnIndex, valueIfNaArray.get(rowIndex, columnIndex));
      }
    });
    return valueArray;
  }
};

// ../packages/engine-formula/src/functions/logical/ifs/index.ts
var Ifs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
  }
  calculate(...params) {
    if (params.length % 2 !== 0) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    for (let i = 0; i < params.length; i++) {
      if (params[i].isError()) {
        return params[i];
      }
    }
    const maxRowLength = Math.max(
      ...params.map((param) => param.isArray() ? param.getRowCount() : 1)
    );
    const maxColumnLength = Math.max(
      ...params.map((param) => param.isArray() ? param.getColumnCount() : 1)
    );
    const expandedParams = params.map(
      (param) => expandArrayValueObject(maxRowLength, maxColumnLength, param, ErrorValueObject.create("#N/A" /* NA */))
    );
    const resultArray = expandedParams[0].map((_, rowIndex, columnIndex) => {
      for (let i = 0; i < expandedParams.length; i += 2) {
        const condition = expandedParams[i].get(rowIndex, columnIndex) || NullValueObject.create();
        const result = expandedParams[i + 1].get(rowIndex, columnIndex) || NullValueObject.create();
        if (condition.isNull()) {
          continue;
        }
        if (condition.isError()) {
          return condition;
        }
        const conditionValue = condition.getValue();
        if (condition.isString()) {
          if (`${conditionValue}`.toLocaleUpperCase() === "TRUE") {
            return result;
          }
          if (`${conditionValue}`.toLocaleUpperCase() === "FALSE") {
            continue;
          }
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        if (+conditionValue) {
          return result.isNull() ? ErrorValueObject.create("#N/A" /* NA */) : result;
        }
      }
      return ErrorValueObject.create("#N/A" /* NA */);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/logical/lambda/index.ts
var Lambda = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};

// ../packages/engine-formula/src/functions/logical/let/index.ts
var Let = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};

// ../packages/engine-formula/src/functions/logical/makearray/index.ts
var Makearray = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(...variants) {
    const row = this.getIndexNumValue(variants[0]);
    if (typeof row !== "number") {
      return row;
    }
    const column = this.getIndexNumValue(variants[1]);
    if (typeof column !== "number") {
      return column;
    }
    if (!(variants[2].isValueObject() && variants[2].isLambda())) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const lambda = variants[2];
    const result = [];
    for (let r = 0; r < row; r++) {
      if (result[r] == null) {
        result[r] = [];
      }
      for (let c = 0; c < column; c++) {
        let value = lambda.execute(NumberValueObject.create(r + 1), NumberValueObject.create(c + 1));
        if (value.isArray()) {
          value = value.get(0, 0);
        }
        result[r][c] = value;
      }
    }
    return new AsyncArrayObject(result);
  }
  isAsync() {
    return true;
  }
};

// ../packages/engine-formula/src/functions/logical/map/index.ts
var Map3 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(...variants) {
    const _variants = [];
    let lambda = null;
    let maxRowLength = 0;
    let maxColumnLength = 0;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      let _variant = variant;
      if (_variant.isReferenceObject()) {
        _variant = variant.toArrayValueObject();
      }
      if (_variant.isError()) {
        return _variant;
      }
      if (i === variants.length - 1) {
        if (!(variant.isValueObject() && variant.isLambda())) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        lambda = variant;
      } else {
        _variants.push(variant);
        maxRowLength = Math.max(maxRowLength, _variant.isArray() ? _variant.getRowCount() : 1);
        maxColumnLength = Math.max(maxColumnLength, _variant.isArray() ? _variant.getColumnCount() : 1);
      }
    }
    const resultArray = this._getResultArray(_variants, lambda, maxRowLength, maxColumnLength);
    if (resultArray instanceof ErrorValueObject) {
      return resultArray;
    }
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray[0][0];
    }
    return ArrayValueObject.create({
      calculateValueList: resultArray,
      rowCount: maxRowLength,
      columnCount: maxColumnLength,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line
  _getResultArray(variants, lambda, maxRowLength, maxColumnLength) {
    const resultArray = [];
    for (let r = 0; r < maxRowLength; r++) {
      const row = [];
      for (let c = 0; c < maxColumnLength; c++) {
        const lambdaVariant = [];
        let isRowPushed = false;
        for (let i = 0; i < variants.length; i++) {
          let variant = variants[i];
          let _variant_reference = null;
          if (variant.isReferenceObject()) {
            _variant_reference = variant;
            variant = variant.toArrayValueObject();
          }
          if (!variant.isArray()) {
            if (r === 0 && c === 0) {
              lambdaVariant.push(_variant_reference || variant);
              continue;
            } else {
              row.push(ErrorValueObject.create("#N/A" /* NA */));
              isRowPushed = true;
              break;
            }
          }
          let valueObject = variant.get(r, c);
          if (!valueObject) {
            row.push(ErrorValueObject.create("#N/A" /* NA */));
            isRowPushed = true;
            break;
          }
          if (_variant_reference) {
            const { startRow, startColumn } = _variant_reference.getRangePosition();
            const range = {
              startRow: startRow + r,
              startColumn: startColumn + c,
              endRow: startRow + r,
              endColumn: startColumn + c
            };
            valueObject = this.createReferenceObject(_variant_reference, range);
          }
          lambdaVariant.push(valueObject);
        }
        if (isRowPushed || lambdaVariant.length === 0) {
          continue;
        }
        let value = lambda.execute(...lambdaVariant);
        if (value.isArray()) {
          const rowCount = value.getRowCount();
          const columnCount = value.getColumnCount();
          if (rowCount > 1 || columnCount > 1) {
            return ErrorValueObject.create("#CALC!" /* CALC */);
          }
          value = value.get(0, 0);
        }
        if (value.isNull()) {
          value = NumberValueObject.create(0);
        }
        row.push(value);
      }
      resultArray.push(row);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/logical/not/index.ts
var Not = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(logical) {
    if (logical.isArray()) {
      return logical.map((logicalObject) => this._handleSingleObject(logicalObject));
    }
    return this._handleSingleObject(logical);
  }
  _handleSingleObject(logical) {
    if (logical.isError()) {
      return logical;
    }
    const logicalValue = +logical.getValue();
    if (Number.isNaN(logicalValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return BooleanValueObject.create(!logicalValue);
  }
};

// ../packages/engine-formula/src/functions/logical/or/index.ts
var Or = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...logicalValues) {
    let result = false;
    let noBoolean = true;
    let errorValue = null;
    for (const logicalValue of logicalValues) {
      if (logicalValue.isError()) {
        return logicalValue;
      }
      if (logicalValue.isArray()) {
        logicalValue.iterator((value) => {
          if (value == null ? void 0 : value.isError()) {
            errorValue = value;
            return false;
          } else if ((value == null ? void 0 : value.isBoolean()) || (value == null ? void 0 : value.isNumber())) {
            result = result || !!value.getValue();
            noBoolean = false;
          }
        });
        if (errorValue) {
          return errorValue;
        }
      } else if (logicalValue.isBoolean() || logicalValue.isNumber()) {
        result = result || !!logicalValue.getValue();
        noBoolean = false;
      }
    }
    return noBoolean ? new ErrorValueObject("#VALUE!" /* VALUE */) : new BooleanValueObject(result);
  }
};

// ../packages/engine-formula/src/functions/logical/reduce/index.ts
var Reduce = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(initialValue, array, lambda) {
    let _initialValue;
    let _initialValueReference;
    if (initialValue.isReferenceObject()) {
      _initialValue = initialValue.toArrayValueObject();
      _initialValueReference = initialValue;
    } else {
      _initialValue = initialValue;
      _initialValueReference = null;
    }
    let _array;
    let _arrayReference;
    if (array.isReferenceObject()) {
      _array = array.toArrayValueObject();
      _arrayReference = array;
    } else {
      _array = array;
      _arrayReference = null;
    }
    if (_initialValue.isArray()) {
      return _initialValue.mapValue((initialValueObject) => this._handleSingleValueObject(initialValueObject, _array, lambda, _initialValueReference, _arrayReference));
    }
    return this._handleSingleValueObject(_initialValue, _array, lambda, _initialValueReference, _arrayReference);
  }
  _handleSingleValueObject(initialValue, array, lambda, _initialValue_reference, _array_reference) {
    if (initialValue.isError()) {
      return initialValue;
    }
    if (array.isError()) {
      return array;
    }
    if (lambda.isError()) {
      return lambda;
    }
    if (!(lambda.isValueObject() && lambda.isLambda() && lambda.getLambdaPrivacyVarKeys().length === 2)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const _lambda = lambda;
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    let accumulator = initialValue;
    if (_initialValue_reference) {
      accumulator = _initialValue_reference;
    }
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        let valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (_array_reference) {
          const { startRow, startColumn } = _array_reference.getRangePosition();
          const range = {
            startRow: startRow + r,
            startColumn: startColumn + c,
            endRow: startRow + r,
            endColumn: startColumn + c
          };
          valueObject = this.createReferenceObject(_array_reference, range);
        }
        let value = _lambda.execute(accumulator, valueObject);
        if (value.isError()) {
          return value;
        }
        if (value.isNull()) {
          value = NumberValueObject.create(0);
        }
        accumulator = value;
      }
    }
    if (accumulator.isReferenceObject()) {
      return accumulator.toArrayValueObject();
    }
    return accumulator;
  }
};

// ../packages/engine-formula/src/functions/logical/scan/index.ts
var Scan = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(initialValue, array, lambda) {
    let _initialValue = initialValue;
    let _initialValue_reference = null;
    if (initialValue.isReferenceObject()) {
      _initialValue = initialValue.toArrayValueObject();
      _initialValue_reference = initialValue;
    }
    _initialValue = _initialValue;
    let _array = array;
    let _array_reference = null;
    if (array.isReferenceObject()) {
      _array = array.toArrayValueObject();
      _array_reference = array;
    }
    _array = _array;
    if (_initialValue.isError()) {
      return _initialValue;
    }
    if (_array.isError()) {
      return _array;
    }
    if (lambda.isError()) {
      return lambda;
    }
    if (!(lambda.isValueObject() && lambda.isLambda() && lambda.getLambdaPrivacyVarKeys().length === 2)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (_initialValue.isArray()) {
      const rowCount = _initialValue.getRowCount();
      const columnCount = _initialValue.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#CALC!" /* CALC */);
      }
      _initialValue = _initialValue.get(0, 0);
    }
    return this._getResult(_initialValue, _array, lambda, _initialValue_reference, _array_reference);
  }
  // eslint-disable-next-line
  _getResult(initialValue, array, lambda, _initialValue_reference, _array_reference) {
    const resultArray = [];
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    let accumulator = initialValue;
    if (_initialValue_reference) {
      accumulator = _initialValue_reference;
    }
    for (let r = 0; r < rowCount; r++) {
      const row = [];
      for (let c = 0; c < columnCount; c++) {
        if (accumulator.isError()) {
          row.push(accumulator);
          continue;
        }
        let valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          accumulator = valueObject;
          row.push(valueObject);
          continue;
        }
        if (_array_reference) {
          const { startRow, startColumn } = _array_reference.getRangePosition();
          const range = {
            startRow: startRow + r,
            startColumn: startColumn + c,
            endRow: startRow + r,
            endColumn: startColumn + c
          };
          valueObject = this.createReferenceObject(_array_reference, range);
        }
        let value = lambda.execute(accumulator, valueObject);
        if (value.isArray()) {
          const rowCount2 = value.getRowCount();
          const columnCount2 = value.getColumnCount();
          if (rowCount2 > 1 || columnCount2 > 1) {
            return ErrorValueObject.create("#CALC!" /* CALC */);
          }
          value = value.get(0, 0);
        }
        if (value.isNull()) {
          value = NumberValueObject.create(0);
        }
        accumulator = value;
        row.push(value);
      }
      resultArray.push(row);
    }
    if (rowCount === 1 && columnCount === 1) {
      return resultArray[0][0];
    }
    return ArrayValueObject.create({
      calculateValueList: resultArray,
      rowCount,
      columnCount,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/logical/switch/index.ts
var Switch = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
  }
  calculate(expression, ...args) {
    if (expression.isError()) {
      return expression;
    }
    const hasDefault = args.length % 2 !== 0;
    const defaultValue = hasDefault ? args[args.length - 1] : NullValueObject.create();
    if (!expression.isArray() && !args.some((arg) => arg.isArray())) {
      return this._handleNonArrayInputs(expression, args, defaultValue, hasDefault);
    }
    return this._handleArrayInputs(expression, args, defaultValue, hasDefault);
  }
  _handleNonArrayInputs(expression, args, defaultValue, hasDefault) {
    for (let i = 0; i < args.length - (hasDefault ? 1 : 0); i += 2) {
      const switchValue = args[i];
      const resultValue = args[i + 1];
      if (switchValue.isNull()) {
        continue;
      }
      if (switchValue.isError()) {
        return switchValue;
      }
      if (`${expression.getValue()}`.toLocaleLowerCase() === `${switchValue.getValue()}`.toLocaleLowerCase()) {
        return resultValue.isNull() ? ErrorValueObject.create("#N/A" /* NA */) : resultValue;
      }
    }
    return defaultValue.isNull() ? ErrorValueObject.create("#N/A" /* NA */) : defaultValue;
  }
  _handleArrayInputs(expression, args, defaultValue, hasDefault) {
    const maxRowLength = Math.max(
      expression.isArray() ? expression.getRowCount() : 1,
      ...args.map((arg) => arg.isArray() ? arg.getRowCount() : 1),
      defaultValue.isArray() ? defaultValue.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      expression.isArray() ? expression.getColumnCount() : 1,
      ...args.map((arg) => arg.isArray() ? arg.getColumnCount() : 1),
      defaultValue.isArray() ? defaultValue.getColumnCount() : 1
    );
    const expandedExpression = expandArrayValueObject(maxRowLength, maxColumnLength, expression);
    const expandedArgs = args.map(
      (arg) => expandArrayValueObject(maxRowLength, maxColumnLength, arg, ErrorValueObject.create("#N/A" /* NA */))
    );
    const expandedDefault = expandArrayValueObject(maxRowLength, maxColumnLength, defaultValue, ErrorValueObject.create("#N/A" /* NA */));
    return expandedExpression.map((expValue, rowIndex, columnIndex) => {
      for (let i = 0; i < expandedArgs.length - (hasDefault ? 1 : 0); i += 2) {
        const switchValue = expandedArgs[i].get(rowIndex, columnIndex) || NullValueObject.create();
        const resultValue = expandedArgs[i + 1].get(rowIndex, columnIndex) || NullValueObject.create();
        if (switchValue.isNull()) {
          continue;
        }
        if (switchValue.isError() || expValue.isError()) {
          return switchValue.isError() ? switchValue : expValue;
        }
        if (`${expValue.getValue()}`.toLocaleLowerCase() === `${switchValue.getValue()}`.toLocaleLowerCase()) {
          return resultValue.isNull() ? ErrorValueObject.create("#N/A" /* NA */) : resultValue;
        }
      }
      const defaultCellValue = expandedDefault.get(rowIndex, columnIndex) || NullValueObject.create();
      return defaultCellValue.isNull() ? ErrorValueObject.create("#N/A" /* NA */) : defaultCellValue;
    });
  }
};

// ../packages/engine-formula/src/functions/logical/true/index.ts
var True = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
  }
  calculate() {
    return BooleanValueObject.create(true);
  }
};

// ../packages/engine-formula/src/functions/logical/xor/index.ts
var Xor = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...logicalValues) {
    let trueCount = 0;
    let noBoolean = true;
    let errorValue = null;
    for (const logicalValue of logicalValues) {
      if (logicalValue.isError()) {
        return logicalValue;
      }
      if (logicalValue.isArray()) {
        logicalValue.iterator((value) => {
          if (value == null ? void 0 : value.isError()) {
            errorValue = value;
            return false;
          } else if ((value == null ? void 0 : value.isBoolean()) || (value == null ? void 0 : value.isNumber())) {
            if (value.getValue()) {
              trueCount++;
            }
            noBoolean = false;
          }
        });
        if (errorValue) {
          return errorValue;
        }
      } else if (logicalValue.isBoolean() || logicalValue.isNumber()) {
        if (logicalValue.getValue()) {
          trueCount++;
        }
        noBoolean = false;
      }
    }
    return noBoolean ? ErrorValueObject.create("#VALUE!" /* VALUE */) : BooleanValueObject.create(trueCount % 2 === 1);
  }
};

// ../packages/engine-formula/src/functions/logical/function-map.ts
var functionLogical = [
  [And, "AND" /* AND */],
  [Bycol, "BYCOL" /* BYCOL */],
  [Byrow, "BYROW" /* BYROW */],
  [False, "FALSE" /* FALSE */],
  [If, "IF" /* IF */],
  [Iferror, "IFERROR" /* IFERROR */],
  [Ifna, "IFNA" /* IFNA */],
  [Ifs, "IFS" /* IFS */],
  [Lambda, "LAMBDA" /* LAMBDA */],
  [Let, "LET" /* LET */],
  [Makearray, "MAKEARRAY" /* MAKEARRAY */],
  [Map3, "MAP" /* MAP */],
  [Not, "NOT" /* NOT */],
  [Or, "OR" /* OR */],
  [Reduce, "REDUCE" /* REDUCE */],
  [Scan, "SCAN" /* SCAN */],
  [Switch, "SWITCH" /* SWITCH */],
  [True, "TRUE" /* TRUE */],
  [Xor, "XOR" /* XOR */]
];

// ../packages/engine-formula/src/functions/lookup/address/index.ts
var Address = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 5);
  }
  // eslint-disable-next-line max-lines-per-function
  calculate(rowNumber, columnNumber, absNumber, a1, sheetText) {
    if (rowNumber.isError()) {
      return rowNumber;
    }
    if (columnNumber.isError()) {
      return columnNumber;
    }
    if (absNumber == null ? void 0 : absNumber.isError()) {
      return absNumber;
    }
    if (a1 == null ? void 0 : a1.isError()) {
      return a1;
    }
    if (sheetText == null ? void 0 : sheetText.isError()) {
      return sheetText;
    }
    const _absNumber = absNumber != null ? absNumber : NumberValueObject.create(1);
    const _a1 = a1 != null ? a1 : BooleanValueObject.create(true);
    const _sheetText = sheetText != null ? sheetText : StringValueObject.create("");
    const maxRowLength = Math.max(
      rowNumber.isArray() ? rowNumber.getRowCount() : 1,
      columnNumber.isArray() ? columnNumber.getRowCount() : 1,
      _absNumber.isArray() ? _absNumber.getRowCount() : 1,
      _a1.isArray() ? _a1.getRowCount() : 1,
      _sheetText.isArray() ? _sheetText.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rowNumber.isArray() ? rowNumber.getColumnCount() : 1,
      columnNumber.isArray() ? columnNumber.getColumnCount() : 1,
      _absNumber.isArray() ? _absNumber.getColumnCount() : 1,
      _a1.isArray() ? _a1.getColumnCount() : 1,
      _sheetText.isArray() ? _sheetText.getColumnCount() : 1
    );
    const rowNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, rowNumber, ErrorValueObject.create("#N/A" /* NA */));
    const columnNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, columnNumber, ErrorValueObject.create("#N/A" /* NA */));
    const absNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _absNumber, ErrorValueObject.create("#N/A" /* NA */));
    const a1Array = expandArrayValueObject(maxRowLength, maxColumnLength, _a1, ErrorValueObject.create("#N/A" /* NA */));
    const sheetTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, _sheetText, ErrorValueObject.create("#N/A" /* NA */));
    return rowNumArray.map((rowNumValue, rowIndex, columnIndex) => {
      const columnNumValue = columnNumArray.get(rowIndex, columnIndex) || ErrorValueObject.create("#N/A" /* NA */);
      const absNumValue = absNumArray.get(rowIndex, columnIndex) || ErrorValueObject.create("#N/A" /* NA */);
      const a1Value = a1Array.get(rowIndex, columnIndex) || ErrorValueObject.create("#N/A" /* NA */);
      const sheetTextValue = sheetTextArray.get(rowIndex, columnIndex) || ErrorValueObject.create("#N/A" /* NA */);
      if (rowNumValue.isError()) {
        return rowNumValue;
      }
      if (columnNumValue.isError()) {
        return columnNumValue;
      }
      if (absNumValue.isError()) {
        return absNumValue;
      }
      if (a1Value.isError()) {
        return a1Value;
      }
      if (sheetTextValue.isError()) {
        return sheetTextValue;
      }
      return this._calculateSingleCell(rowNumValue, columnNumValue, absNumValue, a1Value, sheetTextValue);
    });
  }
  _calculateSingleCell(rowNumber, columnNumber, absNumber, a1, sheetText) {
    const row = Number.parseInt(`${Number(rowNumber.getValue()) - 1}`);
    const column = Number.parseInt(`${Number(columnNumber.getValue()) - 1}`);
    const absNumberValue = Number.parseInt(`${Number(absNumber.getValue())}`);
    if (Number.isNaN(row) || Number.isNaN(column) || Number.isNaN(absNumberValue) || absNumberValue < 1 || absNumberValue > 4) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const absType = transformAbsoluteRefType(absNumberValue);
    const a1Value = this.getZeroOrOneByOneDefault(a1);
    const sheetTextValue = `${sheetText.getValue()}`;
    const sheetName = addQuotesBothSides(sheetTextValue);
    const range = {
      startRow: row,
      startColumn: column,
      endRow: row,
      endColumn: column,
      startAbsoluteRefType: absType,
      endAbsoluteRefType: absType
    };
    const rangeString = a1 && !a1Value ? serializeRangeToR1C1(range) : serializeRange(range);
    return StringValueObject.create(sheetName !== "" ? `${sheetName}!${rangeString}` : rangeString);
  }
};
function transformAbsoluteRefType(number) {
  switch (number) {
    case 1:
      return 3 /* ALL */;
    case 2:
      return 1 /* ROW */;
    case 3:
      return 2 /* COLUMN */;
    case 4:
      return 0 /* NONE */;
    default:
      return 3 /* ALL */;
  }
}

// ../packages/engine-formula/src/functions/lookup/areas/index.ts
var Areas = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(reference) {
    if (reference.isReferenceObject()) {
      return NumberValueObject.create(1);
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
};

// ../packages/engine-formula/src/functions/lookup/choose/index.ts
var Choose = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(indexNum, ...variants) {
    let _indexNum = indexNum;
    if (_indexNum.isError()) {
      return _indexNum;
    }
    if (_indexNum.isReferenceObject()) {
      _indexNum = _indexNum.toArrayValueObject();
    }
    if (!_indexNum.isArray()) {
      const index = _indexNum.convertToNumberObjectValue();
      if (index.isError()) {
        return index;
      }
      const variant = variants[Math.trunc(+index.getValue()) - 1] || ErrorValueObject.create("#VALUE!" /* VALUE */);
      return variant;
    }
    let maxRowLength = _indexNum.isArray() ? _indexNum.getRowCount() : 1;
    let maxColumnLength = _indexNum.isArray() ? _indexNum.getColumnCount() : 1;
    variants.forEach((variant, i) => {
      if (variant.isArray()) {
        const arrayValue = variant;
        maxRowLength = Math.max(maxRowLength, arrayValue.getRowCount());
        maxColumnLength = Math.max(maxColumnLength, arrayValue.getColumnCount());
      } else {
        maxRowLength = Math.max(maxRowLength, 1);
        maxColumnLength = Math.max(maxColumnLength, 1);
      }
    });
    const indexNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _indexNum, ErrorValueObject.create("#N/A" /* NA */));
    const arrayValueObjectList = variants.map((variant) => {
      let _variant = variant;
      if (_variant.isReferenceObject()) {
        _variant = _variant.toArrayValueObject();
      }
      return expandArrayValueObject(maxRowLength, maxColumnLength, _variant, ErrorValueObject.create("#N/A" /* NA */));
    });
    return indexNumArray.map((indexNumValue, row, column) => {
      if (indexNumValue.isError()) {
        return indexNumValue;
      }
      const index = indexNumValue.convertToNumberObjectValue();
      if (index.isError()) {
        return index;
      }
      const arrayValueObject = arrayValueObjectList[Math.trunc(+index.getValue()) - 1];
      let valueObject = (arrayValueObject == null ? void 0 : arrayValueObject.get(row, column)) || ErrorValueObject.create("#VALUE!" /* VALUE */);
      if (valueObject == null ? void 0 : valueObject.isNull()) {
        valueObject = NumberValueObject.create(0);
      }
      return valueObject;
    });
  }
};

// ../packages/engine-formula/src/functions/lookup/choosecols/index.ts
var Choosecols = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
  }
  calculate(array, ...variants) {
    if (array.isError()) {
      return array;
    }
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const result = [];
    for (let i = 0; i < variants.length; i++) {
      let variantObject = variants[i];
      if (variantObject.isArray()) {
        const variantRowCount = variantObject.getRowCount();
        const variantColumnCount = variantObject.getColumnCount();
        if (variantRowCount > 1 || variantColumnCount > 1) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        variantObject = variantObject.get(0, 0);
      }
      if (variantObject.isString()) {
        variantObject = variantObject.convertToNumberObjectValue();
      }
      if (variantObject.isError()) {
        return variantObject;
      }
      const variantValue = Math.trunc(+variantObject.getValue());
      if (variantValue === 0 || Math.abs(variantValue) > arrayColumnCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let searchColArray = array;
      if (arrayColumnCount > 1) {
        if (variantValue < 0) {
          searchColArray = array.slice(void 0, [variantValue + arrayColumnCount, variantValue + 1 + arrayColumnCount]);
        } else {
          searchColArray = array.slice(void 0, [variantValue - 1, variantValue]);
        }
      }
      for (let r = 0; r < arrayRowCount; r++) {
        if (!result[r]) {
          result[r] = [];
        }
        if (array.isArray()) {
          result[r].push(searchColArray.get(r, 0));
        } else {
          result[r].push(array);
        }
      }
    }
    return ArrayValueObject.create({
      calculateValueList: result,
      rowCount: result.length,
      columnCount: result[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/lookup/chooserows/index.ts
var Chooserows = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
  }
  calculate(array, ...variants) {
    if (array.isError()) {
      return array;
    }
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const result = [];
    for (let i = 0; i < variants.length; i++) {
      let variantObject = variants[i];
      if (variantObject.isArray()) {
        const variantRowCount = variantObject.getRowCount();
        const variantColumnCount = variantObject.getColumnCount();
        if (variantRowCount > 1 || variantColumnCount > 1) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        variantObject = variantObject.get(0, 0);
      }
      if (variantObject.isString()) {
        variantObject = variantObject.convertToNumberObjectValue();
      }
      if (variantObject.isError()) {
        return variantObject;
      }
      const variantValue = Math.trunc(+variantObject.getValue());
      if (variantValue === 0 || Math.abs(variantValue) > arrayRowCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let searchRowArray = array;
      if (arrayRowCount > 1) {
        if (variantValue < 0) {
          searchRowArray = array.slice([variantValue + arrayRowCount, variantValue + 1 + arrayRowCount]);
        } else {
          searchRowArray = array.slice([variantValue - 1, variantValue]);
        }
      }
      if (array.isArray()) {
        result.push(searchRowArray.getArrayValue()[0]);
      } else {
        result.push([array]);
      }
    }
    return ArrayValueObject.create({
      calculateValueList: result,
      rowCount: result.length,
      columnCount: result[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/lookup/column/index.ts
var Column = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 1);
  }
  calculate(reference) {
    if (reference == null) {
      return NumberValueObject.create(this.column + 1);
    }
    if (reference.isError()) {
      return reference;
    }
    if (!reference.isArray()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const column = reference.getCurrentColumn();
    const columnCount = reference.getColumnCount();
    const calculateValueList = [];
    for (let i = 0; i < columnCount; i++) {
      calculateValueList.push(NumberValueObject.create(column + i + 1));
    }
    const arrayValueObjectData = {
      calculateValueList: [calculateValueList],
      rowCount: 1,
      columnCount,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};

// ../packages/engine-formula/src/functions/lookup/columns/index.ts
var Columns = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(reference) {
    if (reference.isError()) {
      return reference;
    }
    if (reference.isString() || reference.isNumber() || reference.isBoolean()) {
      return NumberValueObject.create(1);
    }
    if (!reference.isArray()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const columnCount = reference.getColumnCount();
    return NumberValueObject.create(columnCount);
  }
};

// ../packages/engine-formula/src/functions/lookup/drop/index.ts
var Drop = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, rows, columns) {
    const _columns = columns != null ? columns : NumberValueObject.create(0);
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const maxRowLength = Math.max(
      rows.isArray() ? rows.getRowCount() : 1,
      _columns.isArray() ? _columns.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rows.isArray() ? rows.getColumnCount() : 1,
      _columns.isArray() ? _columns.getColumnCount() : 1
    );
    const rowsArray = expandArrayValueObject(maxRowLength, maxColumnLength, rows, ErrorValueObject.create("#N/A" /* NA */));
    const columnsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _columns, ErrorValueObject.create("#N/A" /* NA */));
    if (maxRowLength > 1 || maxColumnLength > 1) {
      return rowsArray.mapValue((rowsObject2, rowIndex, columnIndex) => {
        const columnsObject2 = columnsArray.get(rowIndex, columnIndex);
        if (array.isError()) {
          return array;
        }
        if (array.isNull()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        const { isError: isError2, errorObject: errorObject2 } = this._checkRowsColumns(rowsObject2, columnsObject2, arrayRowCount, arrayColumnCount);
        if (isError2) {
          return errorObject2;
        }
        if (array.isArray()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        return array;
      });
    }
    if (array.isError()) {
      return array;
    }
    if (array.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowsObject = rows.isArray() ? rows.get(0, 0) : rows;
    const columnsObject = _columns.isArray() ? _columns.get(0, 0) : _columns;
    const { isError, errorObject, rowsValue, columnsValue } = this._checkRowsColumns(rowsObject, columnsObject, arrayRowCount, arrayColumnCount);
    if (isError) {
      return errorObject;
    }
    return this._getResultArray(array, rowsValue, columnsValue, arrayRowCount, arrayColumnCount);
  }
  _checkRowsColumns(rowsObject, columnsObject, arrayRowCount, arrayColumnCount) {
    if (rowsObject.isError()) {
      return {
        isError: true,
        errorObject: rowsObject
      };
    }
    if (columnsObject.isError()) {
      return {
        isError: true,
        errorObject: columnsObject
      };
    }
    const rowsValue = Math.trunc(+rowsObject.getValue());
    const columnsValue = Math.trunc(+columnsObject.getValue());
    if (Number.isNaN(rowsValue) || Number.isNaN(columnsValue)) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    if (Math.abs(rowsValue) >= arrayRowCount || Math.abs(columnsValue) >= arrayColumnCount) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#CALC!" /* CALC */)
      };
    }
    return {
      isError: false,
      rowsValue,
      columnsValue
    };
  }
  _getResultArray(array, rows, columns, arrayRowCount, arrayColumnCount) {
    const rowParam = rows >= 0 ? [rows, arrayRowCount] : [0, arrayRowCount + rows];
    const columnParam = columns >= 0 ? [columns, arrayColumnCount] : [0, arrayColumnCount + columns];
    let resultArray;
    if (rows === 0 && columns === 0) {
      resultArray = array;
    } else if (rows === 0) {
      resultArray = array.slice(void 0, columnParam);
    } else if (columns === 0) {
      resultArray = array.slice(rowParam, void 0);
    } else {
      resultArray = array.slice(rowParam, columnParam);
    }
    resultArray = resultArray.map((valueObject) => valueObject.isNull() ? NumberValueObject.create(0) : valueObject);
    if (arrayRowCount - rows === 1 && arrayColumnCount - columns === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/lookup/expand/index.ts
var Expand = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 4);
  }
  calculate(array, rows, columns, padWith) {
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    let _rows = rows;
    let _columns = columns != null ? columns : NumberValueObject.create(arrayColumnCount);
    const _padWith = padWith != null ? padWith : ErrorValueObject.create("#N/A" /* NA */);
    if (rows.isNull()) {
      _rows = NumberValueObject.create(arrayRowCount);
    }
    if (_columns.isNull()) {
      _columns = NumberValueObject.create(arrayColumnCount);
    }
    const maxRowLength = Math.max(
      _rows.isArray() ? _rows.getRowCount() : 1,
      _columns.isArray() ? _columns.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _rows.isArray() ? _rows.getColumnCount() : 1,
      _columns.isArray() ? _columns.getColumnCount() : 1
    );
    const rowsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _rows, ErrorValueObject.create("#N/A" /* NA */));
    const columnsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _columns, ErrorValueObject.create("#N/A" /* NA */));
    if (maxRowLength > 1 || maxColumnLength > 1) {
      return rowsArray.mapValue((rowsObject2, rowIndex, columnIndex) => {
        const columnsObject2 = columnsArray.get(rowIndex, columnIndex);
        if (array.isError()) {
          return array;
        }
        if (array.isNull()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        const { isError: isError2, errorObject: errorObject2 } = this._checkRowsColumnsPadWith(rowsObject2, columnsObject2, _padWith, arrayRowCount, arrayColumnCount);
        if (isError2) {
          return errorObject2;
        }
        if (array.isArray()) {
          return array.get(0, 0);
        }
        return array;
      });
    }
    if (array.isError()) {
      return array;
    }
    if (array.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowsObject = _rows.isArray() ? _rows.get(0, 0) : _rows;
    const columnsObject = _columns.isArray() ? _columns.get(0, 0) : _columns;
    const { isError, errorObject, rowsValue, columnsValue, padWithObject } = this._checkRowsColumnsPadWith(rowsObject, columnsObject, _padWith, arrayRowCount, arrayColumnCount);
    if (isError) {
      return errorObject;
    }
    return this._getResultArray(array, rowsValue, columnsValue, padWithObject, arrayRowCount, arrayColumnCount);
  }
  _checkRowsColumnsPadWith(rowsObject, columnsObject, padWith, arrayRowCount, arrayColumnCount) {
    if (rowsObject.isError()) {
      return {
        isError: true,
        errorObject: rowsObject
      };
    }
    if (columnsObject.isError()) {
      return {
        isError: true,
        errorObject: columnsObject
      };
    }
    const rowsValue = Math.trunc(+rowsObject.getValue());
    const columnsValue = Math.trunc(+columnsObject.getValue());
    if (Number.isNaN(rowsValue) || Number.isNaN(columnsValue)) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    if (Math.abs(rowsValue) < arrayRowCount || Math.abs(columnsValue) < arrayColumnCount) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    let _padWith = padWith;
    if (padWith.isArray()) {
      const rowCount = padWith.getRowCount();
      const columnCount = padWith.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return {
          isError: true,
          errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
        };
      }
      _padWith = padWith.get(0, 0);
    }
    return {
      isError: false,
      rowsValue,
      columnsValue,
      padWithObject: _padWith
    };
  }
  _getResultArray(array, rows, columns, padWith, arrayRowCount, arrayColumnCount) {
    let resultArray = [];
    if (array.isArray()) {
      resultArray = array.map((valueObject) => valueObject.isNull() ? NumberValueObject.create(0) : valueObject).getArrayValue();
    } else {
      resultArray = [[array]];
    }
    const addRows = Math.max(0, rows - arrayRowCount);
    const addColumns = Math.max(0, columns - arrayColumnCount);
    for (let r = 0; r < addRows; r++) {
      resultArray.push(new Array(arrayColumnCount).fill(padWith));
    }
    for (let c = 0; c < addColumns; c++) {
      resultArray.forEach((row) => {
        row.push(padWith);
      });
    }
    if (rows === 1 && columns === 1) {
      return resultArray[0][0];
    }
    return ArrayValueObject.create({
      calculateValueList: resultArray,
      rowCount: resultArray.length,
      columnCount: resultArray[0].length,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/lookup/filter/index.ts
var Filter = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, include, ifEmpty) {
    const _ifEmpty = ifEmpty != null ? ifEmpty : ErrorValueObject.create("#CALC!" /* CALC */);
    if (array.isError()) {
      return array;
    }
    if (include.isError()) {
      return include;
    }
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const includeRowCount = include.isArray() ? include.getRowCount() : 1;
    const includeColumnCount = include.isArray() ? include.getColumnCount() : 1;
    if (includeRowCount > 1 && includeColumnCount > 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (includeRowCount === 1 && includeColumnCount !== arrayColumnCount || includeColumnCount === 1 && includeRowCount !== arrayRowCount) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (arrayRowCount === 1 && arrayColumnCount === 1) {
      return this._getResultArrayByR1C1(array, include, _ifEmpty);
    }
    if (includeRowCount === 1) {
      if (includeColumnCount !== arrayColumnCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return this._getResultArrayByR1(arrayRowCount, arrayColumnCount, array, include, _ifEmpty);
    }
    if (includeColumnCount === 1) {
      if (includeRowCount !== arrayRowCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return this._getResultArrayByC1(arrayRowCount, arrayColumnCount, array, include, _ifEmpty);
    }
    return _ifEmpty;
  }
  _getResultArrayByR1C1(array, include, ifEmpty) {
    let _array = array;
    let _include = include;
    if (_array.isArray()) {
      _array = _array.get(0, 0);
    }
    if (_include.isArray()) {
      _include = _include.get(0, 0);
    }
    if (_include.isString()) {
      _include = _include.convertToNumberObjectValue();
    }
    if (_include.isError()) {
      return _include;
    }
    const includeValue = +_include.getValue();
    if (includeValue) {
      return _array;
    }
    return ifEmpty;
  }
  _getResultArrayByR1(arrayRowCount, arrayColumnCount, array, include, ifEmpty) {
    const resultArray = [];
    for (let c = 0; c < arrayColumnCount; c++) {
      let includeObject = include.get(0, c);
      if (includeObject.isString()) {
        includeObject = includeObject.convertToNumberObjectValue();
      }
      if (includeObject.isError()) {
        return includeObject;
      }
      const includeValue = +includeObject.getValue();
      if (!includeValue) {
        continue;
      }
      for (let r = 0; r < arrayRowCount; r++) {
        if (!resultArray[r]) {
          resultArray[r] = [];
        }
        const arrayObject = array.get(r, c);
        resultArray[r].push(arrayObject);
      }
    }
    if (resultArray.length === 0) {
      return ifEmpty;
    }
    return ArrayValueObject.create({
      calculateValueList: resultArray,
      rowCount: resultArray.length,
      columnCount: resultArray[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  _getResultArrayByC1(arrayRowCount, arrayColumnCount, array, include, ifEmpty) {
    const resultArray = [];
    for (let r = 0; r < arrayRowCount; r++) {
      let includeObject = include.get(r, 0);
      if (includeObject.isString()) {
        includeObject = includeObject.convertToNumberObjectValue();
      }
      if (includeObject.isError()) {
        return includeObject;
      }
      const includeValue = +includeObject.getValue();
      if (!includeValue) {
        continue;
      }
      const row = [];
      for (let c = 0; c < arrayColumnCount; c++) {
        const arrayObject = array.get(r, c);
        row.push(arrayObject);
      }
      resultArray.push(row);
    }
    if (resultArray.length === 0) {
      return ifEmpty;
    }
    return ArrayValueObject.create({
      calculateValueList: resultArray,
      rowCount: resultArray.length,
      columnCount: resultArray[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/lookup/formulatext/index.ts
var Formulatext = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
    __publicField(this, "needsReferenceObject", true);
    __publicField(this, "needsFormulaDataModel", true);
  }
  calculate(reference) {
    var _a2, _b2;
    if (!reference.isReferenceObject()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const unitId = reference.getUnitId();
    const sheetId = reference.getSheetId();
    const unitData = reference.getUnitData();
    const cellData = (_b2 = (_a2 = unitData[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2.cellData;
    const { startRow, startColumn } = reference.getRangePosition();
    const referenceObject = reference.toArrayValueObject();
    const resultArray = referenceObject.mapValue((_, rowIndex, columnIndex) => {
      const cellValue = cellData.getValue(startRow + rowIndex, startColumn + columnIndex);
      if ((cellValue == null ? void 0 : cellValue.f) || (cellValue == null ? void 0 : cellValue.si)) {
        const formulaString = this._formulaDataModel.getFormulaStringByCell(startRow + rowIndex, startColumn + columnIndex, sheetId, unitId);
        return StringValueObject.create(formulaString);
      }
      return ErrorValueObject.create("#N/A" /* NA */);
    });
    if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/lookup/hlookup/index.ts
var Hlookup = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(lookupValue, tableArray, rowIndexNum, rangeLookup) {
    if (lookupValue.isError()) {
      return lookupValue;
    }
    if (tableArray.isError()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (!tableArray.isArray()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (rowIndexNum.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (rangeLookup == null ? void 0 : rangeLookup.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const rangeLookupValue = this.getZeroOrOneByOneDefault(rangeLookup);
    if (rangeLookupValue == null) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowIndexNumValue = this.getIndexNumValue(rowIndexNum);
    if (rowIndexNumValue instanceof ErrorValueObject) {
      return rowIndexNumValue;
    }
    const searchArray2 = tableArray.slice([0, 1]);
    const resultArray = tableArray.slice([rowIndexNumValue - 1, rowIndexNumValue]);
    if (searchArray2 == null || resultArray == null) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (lookupValue.isArray()) {
      return lookupValue.map((value) => this._handleSingleObject(value, searchArray2, resultArray, rangeLookupValue));
    }
    return this._handleSingleObject(lookupValue, searchArray2, resultArray, rangeLookupValue);
  }
  _handleSingleObject(value, searchArray2, resultArray, rangeLookupValue) {
    if (rangeLookupValue === 0) {
      return this.equalSearch(value, searchArray2, resultArray);
    }
    return this.binarySearch(value, searchArray2, resultArray);
  }
};

// ../packages/engine-formula/src/functions/lookup/hstack/index.ts
var Hstack = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const maxRowLength = Math.max(
      ...variants.map((variantObject) => variantObject.isArray() ? variantObject.getRowCount() : 1)
    );
    const result = [];
    for (let i = 0; i < variants.length; i++) {
      const variantObject = variants[i];
      if (variantObject.isError()) {
        return variantObject;
      }
      const rowCount = variantObject.isArray() ? variantObject.getRowCount() : 1;
      const columnCount = variantObject.isArray() ? variantObject.getColumnCount() : 1;
      for (let r = 0; r < maxRowLength; r++) {
        if (!result[r]) {
          result[r] = [];
        }
        for (let c = 0; c < columnCount; c++) {
          let singleObject = variantObject;
          if (variantObject.isArray()) {
            singleObject = variantObject.get(r, c);
          }
          if (r > rowCount - 1 || !singleObject) {
            result[r].push(ErrorValueObject.create("#N/A" /* NA */));
          } else {
            result[r].push(singleObject);
          }
        }
      }
    }
    return ArrayValueObject.create({
      calculateValueList: result,
      rowCount: result.length,
      columnCount: result[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/lookup/index/index.ts
var Index = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 4);
    __publicField(this, "needsReferenceObject", true);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(reference, rowNum, columnNum, areaNum) {
    if (reference.isError()) {
      return reference;
    }
    if (rowNum == null ? void 0 : rowNum.isError()) {
      return rowNum;
    }
    if (columnNum == null ? void 0 : columnNum.isError()) {
      return columnNum;
    }
    if (areaNum == null ? void 0 : areaNum.isError()) {
      return areaNum;
    }
    let referenceRowCount = 0;
    let referenceColumnCount = 0;
    if (reference.isValueObject()) {
      referenceRowCount = 1;
      referenceColumnCount = 1;
    } else if (reference.isReferenceObject()) {
      const { startRow, endRow, startColumn, endColumn } = reference.getRangePosition();
      referenceRowCount = endRow - startRow + 1;
      referenceColumnCount = endColumn - startColumn + 1;
    } else {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let _rowNum, _columnNum;
    if (referenceRowCount === 1 && referenceColumnCount > 1 && columnNum == null) {
      _columnNum = rowNum != null ? rowNum : NumberValueObject.create(0);
      _rowNum = NumberValueObject.create(0);
    } else {
      _rowNum = rowNum != null ? rowNum : NumberValueObject.create(0);
      _columnNum = columnNum != null ? columnNum : NumberValueObject.create(0);
    }
    let _areaNum = areaNum != null ? areaNum : NumberValueObject.create(1);
    if (_rowNum.isReferenceObject()) {
      _rowNum = _rowNum.toArrayValueObject();
    }
    if (_columnNum.isReferenceObject()) {
      _columnNum = _columnNum.toArrayValueObject();
    }
    if (_areaNum.isReferenceObject()) {
      _areaNum = _areaNum.toArrayValueObject();
    }
    const maxRowLength = Math.max(
      _rowNum.isArray() ? _rowNum.getRowCount() : 1,
      _columnNum.isArray() ? _columnNum.getRowCount() : 1,
      _areaNum.isArray() ? _areaNum.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _rowNum.isArray() ? _rowNum.getColumnCount() : 1,
      _columnNum.isArray() ? _columnNum.getColumnCount() : 1,
      _areaNum.isArray() ? _areaNum.getColumnCount() : 1
    );
    _rowNum = _rowNum;
    _columnNum = _columnNum;
    _areaNum = _areaNum;
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return this._calculateSingleCell(reference, _rowNum, _columnNum, _areaNum);
    } else {
      const rowNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _rowNum, ErrorValueObject.create("#N/A" /* NA */));
      const columnNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _columnNum, ErrorValueObject.create("#N/A" /* NA */));
      const areaNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _areaNum, ErrorValueObject.create("#N/A" /* NA */));
      return rowNumArray.map((rowNumValue, rowIndex, columnIndex) => {
        const columnNumValue = columnNumArray.get(rowIndex, columnIndex) || NullValueObject.create();
        const areaNumValue = areaNumArray.get(rowIndex, columnIndex) || NullValueObject.create();
        const result = this._calculateSingleCell(reference, rowNumValue, columnNumValue, areaNumValue);
        if (result.isReferenceObject()) {
          return result.toArrayValueObject().getFirstCell();
        }
        return result;
      });
    }
  }
  _calculateSingleCell(reference, rowNum, columnNum, areaNum) {
    if (rowNum.isError()) {
      return rowNum;
    }
    const rowNumberValue = this._getNumberValue(rowNum);
    if (rowNumberValue === void 0 || rowNumberValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (columnNum.isError()) {
      return columnNum;
    }
    const columnNumberValue = this._getNumberValue(columnNum);
    if (columnNumberValue === void 0 || columnNumberValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (areaNum.isError()) {
      return areaNum;
    }
    const areaNumberValue = this._getAreaNumberValue(areaNum);
    if (areaNumberValue === void 0 || areaNumberValue < 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (reference.isReferenceObject()) {
      return this._getReferenceObject(reference, rowNumberValue, columnNumberValue, areaNumberValue);
    } else if (reference.isValueObject() && rowNumberValue === 1 && columnNumberValue === 1) {
      return reference;
    } else {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
  }
  _getNumberValue(numberValueObject) {
    if (numberValueObject == null) {
      return 0;
    }
    let logicValue = 0;
    if (numberValueObject.isBoolean()) {
      const logicV = numberValueObject.getValue();
      if (logicV === true) {
        logicValue = 1;
      }
    } else if (numberValueObject.isString()) {
      return;
    } else if (numberValueObject.isNumber()) {
      logicValue = Math.floor(numberValueObject.getValue());
    } else if (numberValueObject.isNull()) {
      logicValue = 0;
    }
    return logicValue;
  }
  _getAreaNumberValue(numberValueObject) {
    if (numberValueObject == null) {
      return 1;
    }
    let logicValue = 0;
    if (numberValueObject.isBoolean()) {
      const logicV = numberValueObject.getValue();
      if (logicV === true) {
        logicValue = 1;
      }
    } else if (numberValueObject.isString()) {
      return;
    } else if (numberValueObject.isNumber()) {
      logicValue = Math.floor(numberValueObject.getValue());
    } else if (numberValueObject.isNull()) {
      logicValue = 0;
    }
    return logicValue;
  }
  _getReferenceObject(reference, rowNumberValue, columnNumberValue, areaNumberValue) {
    const { startRow, endRow, startColumn, endColumn } = reference.getRangePosition();
    let referenceStartRow = 0;
    let referenceEndRow = 0;
    let referenceStartColumn = 0;
    let referenceEndColumn = 0;
    if (rowNumberValue === 0) {
      referenceStartRow = startRow;
      referenceEndRow = endRow;
    } else {
      referenceStartRow = referenceEndRow = startRow + rowNumberValue - 1;
    }
    if (columnNumberValue === 0) {
      referenceStartColumn = startColumn;
      referenceEndColumn = endColumn;
    } else {
      referenceStartColumn = referenceEndColumn = startColumn + columnNumberValue - 1;
    }
    if (referenceStartRow > endRow || referenceStartColumn > endColumn) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const range = {
      startRow: referenceStartRow,
      startColumn: referenceStartColumn,
      endRow: referenceEndRow,
      endColumn: referenceEndColumn
    };
    return this.createReferenceObject(reference, range);
  }
};

// ../packages/engine-formula/src/functions/lookup/indirect/index.ts
var Indirect = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  isAddress() {
    return true;
  }
  calculate(refText, a1) {
    if (refText.isError()) {
      return refText;
    }
    if (a1 == null ? void 0 : a1.isError()) {
      return a1;
    }
    let a1Value = this.getZeroOrOneByOneDefault(a1);
    if (a1Value == null) {
      a1Value = 1;
    }
    let _refText = refText;
    if (refText.isArray()) {
      const rowCount = refText.getRowCount();
      const columnCount = refText.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return refText.map(() => {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        });
      }
      _refText = refText.getFirstCell();
    }
    return this._handleSingleObject(_refText, a1Value);
  }
  _handleSingleObject(refTextObject, a1Value) {
    const refTextValue = `${refTextObject.getValue()}`;
    if (refTextValue.trim() === "") {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const refTextV = this._convertToDefinedName(refTextValue);
    if (a1Value === 0) {
      const gridRange2 = deserializeRangeForR1C1(refTextV);
      const { range: range2, sheetName: sheetName2, unitId: unitId2 } = gridRange2;
      const rangeReferenceObject2 = new RangeReferenceObject(range2);
      rangeReferenceObject2.setForcedUnitIdDirect(unitId2);
      rangeReferenceObject2.setForcedSheetName(sheetName2);
      return this._setDefault(rangeReferenceObject2);
    }
    if (regexTestSingeRange(refTextV)) {
      return this._setDefault(new CellReferenceObject(refTextV));
    }
    if (regexTestRow(refTextV)) {
      return this._setDefault(new RowReferenceObject(refTextV));
    }
    if (regexTestColumn(refTextV)) {
      return this._setDefault(new ColumnReferenceObject(refTextV));
    }
    const gridRange = deserializeRangeWithSheetWithCache(refTextV);
    const { range, sheetName, unitId } = gridRange;
    if (Number.isNaN(range.startRow) || range.endRow + 1 > 1048576 || Number.isNaN(range.startColumn) || range.endColumn + 1 > 16384) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const rangeReferenceObject = new RangeReferenceObject(range);
    rangeReferenceObject.setForcedUnitIdDirect(unitId);
    rangeReferenceObject.setForcedSheetName(sheetName);
    return this._setDefault(rangeReferenceObject);
  }
  _setDefault(object) {
    if (this.unitId == null || this.subUnitId == null) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    object.setDefaultUnitId(this.unitId);
    object.setDefaultSheetId(this.subUnitId);
    return object;
  }
  /**
   * In Excel, to inject a defined name into a function that has positioning capabilities,
   * such as using the INDIRECT function to reference a named range,
   * you can write it as follows:
   * =INDIRECT("DefinedName1")
   */
  _convertToDefinedName(refText) {
    const definedName = this.getDefinedName(refText);
    if (definedName == null) {
      return refText;
    }
    const formulaOrRefString = definedName.formulaOrRefString;
    if (formulaOrRefString == null) {
      return refText;
    }
    if (formulaOrRefString.startsWith("=" /* EQUALS */)) {
      return formulaOrRefString.slice(1);
    }
    return formulaOrRefString;
  }
};

// ../packages/engine-formula/src/functions/lookup/lookup/index.ts
var Lookup = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsExpandParams", true);
  }
  calculate(lookupValue, lookupVectorOrArray, resultVector) {
    if (lookupValue.isError()) {
      return lookupValue;
    }
    if (lookupVectorOrArray.isError()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (!lookupVectorOrArray.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (resultVector == null ? void 0 : resultVector.isError()) {
      return resultVector;
    }
    if (lookupVectorOrArray.getColumnCount() === 1 || lookupVectorOrArray.getRowCount() === 1) {
      if (resultVector != null && !resultVector.isArray()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      return this._handleVector(lookupValue, lookupVectorOrArray, resultVector);
    }
    return this._handleArray(lookupValue, lookupVectorOrArray);
  }
  _handleVector(lookupValue, lookupVector, resultVector) {
    let _resultVector = resultVector;
    if (_resultVector == null) {
      _resultVector = lookupVector;
    } else if (_resultVector.getRowCount() !== lookupVector.getRowCount() || _resultVector.getColumnCount() !== lookupVector.getColumnCount()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (lookupValue.isArray()) {
      return lookupValue.map((value) => {
        return this.binarySearch(value, lookupVector, _resultVector);
      });
    }
    return this.binarySearch(lookupValue, lookupVector, _resultVector);
  }
  _handleArray(lookupValue, lookupArray) {
    const rowCount = lookupArray.getRowCount();
    const columnCount = lookupArray.getColumnCount();
    let searchArray2;
    let resultArray;
    if (columnCount > rowCount) {
      searchArray2 = lookupArray.slice([0, 1]);
      resultArray = lookupArray.slice([rowCount - 1, rowCount]);
    } else {
      searchArray2 = lookupArray.slice(void 0, [0, 1]);
      resultArray = lookupArray.slice(void 0, [columnCount - 1, columnCount]);
    }
    if (searchArray2 == null || resultArray == null) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (lookupValue.isArray()) {
      return lookupValue.map((value) => {
        return this.binarySearch(value, searchArray2, resultArray);
      });
    }
    return this.binarySearch(lookupValue, searchArray2, resultArray);
  }
};

// ../packages/engine-formula/src/functions/lookup/match/index.ts
var Match = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(lookupValue, lookupArray, matchType) {
    if (lookupValue.isError()) {
      return lookupValue;
    }
    if (lookupArray.isError()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (!lookupArray.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowCountLookup = lookupArray.getRowCount();
    const columnCountLookup = lookupArray.getColumnCount();
    if (rowCountLookup !== 1 && columnCountLookup !== 1) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (matchType == null ? void 0 : matchType.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const matchTypeValue = this.getMatchTypeValue(matchType);
    if (matchTypeValue == null) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (lookupValue.isArray()) {
      return lookupValue.map((value) => this._handleSingleObject(
        value,
        lookupArray,
        matchTypeValue
      ));
    }
    return this._handleSingleObject(
      lookupValue,
      lookupArray,
      matchTypeValue
    );
  }
  _handleSingleObject(value, searchArray2, matchTypeValue) {
    const searchType = this._getSearchModeValue(matchTypeValue);
    const result = searchArray2.orderSearch(value, searchType);
    if (result == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (result instanceof ErrorValueObject) {
      return result;
    }
    const resultNumber = searchArray2.getRowCount() === 1 ? result.column + 1 : result.row + 1;
    return NumberValueObject.create(resultNumber);
  }
  _getSearchModeValue(searchModeValue) {
    switch (searchModeValue) {
      case 1:
        return 1 /* MIN */;
      case 0:
        return 0 /* NORMAL */;
      case -1:
        return 2 /* MAX */;
    }
  }
};

// ../packages/engine-formula/src/functions/lookup/offset/index.ts
var Offset = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 5);
    __publicField(this, "needsReferenceObject", true);
  }
  isAddress() {
    return true;
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  calculate(reference, rows, columns, height, width) {
    if (reference.isError()) {
      return reference;
    }
    if (rows.isError()) {
      return rows;
    }
    if (columns.isError()) {
      return columns;
    }
    if (height == null ? void 0 : height.isError()) {
      return height;
    }
    if (width == null ? void 0 : width.isError()) {
      return width;
    }
    if (!reference.isReferenceObject()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowCount = reference.getRowCount();
    const columnCount = reference.getColumnCount();
    let _rows = rows;
    if (_rows.isReferenceObject()) {
      _rows = _rows.toArrayValueObject();
    }
    let _columns = columns;
    if (_columns.isReferenceObject()) {
      _columns = _columns.toArrayValueObject();
    }
    let _height = height != null ? height : NumberValueObject.create(rowCount);
    if (_height.isReferenceObject()) {
      _height = _height.toArrayValueObject();
    }
    if (_height.isNull()) {
      _height = NumberValueObject.create(rowCount);
    }
    let _width = width != null ? width : NumberValueObject.create(columnCount);
    if (_width.isReferenceObject()) {
      _width = _width.toArrayValueObject();
    }
    if (_width.isNull()) {
      _width = NumberValueObject.create(columnCount);
    }
    const maxRowLength = Math.max(
      _rows.isArray() ? _rows.getRowCount() : 1,
      _columns.isArray() ? _columns.getRowCount() : 1,
      _height.isArray() ? _height.getRowCount() : 1,
      _width.isArray() ? _width.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _rows.isArray() ? _rows.getColumnCount() : 1,
      _columns.isArray() ? _columns.getColumnCount() : 1,
      _height.isArray() ? _height.getColumnCount() : 1,
      _width.isArray() ? _width.getColumnCount() : 1
    );
    _rows = _rows;
    _columns = _columns;
    _height = _height;
    _width = _width;
    if (maxRowLength === 1 && maxColumnLength === 1) {
      _rows = _rows.isArray() ? _rows.get(0, 0) : _rows;
      _columns = _columns.isArray() ? _columns.get(0, 0) : _columns;
      _height = _height.isArray() ? _height.get(0, 0) : _height;
      _width = _width.isArray() ? _width.get(0, 0) : _width;
      return this._handleSingleObject(reference, _rows, _columns, _height, _width);
    }
    const rowsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _rows, ErrorValueObject.create("#N/A" /* NA */));
    const columnsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _columns, ErrorValueObject.create("#N/A" /* NA */));
    const heightArray = expandArrayValueObject(maxRowLength, maxColumnLength, _height, ErrorValueObject.create("#N/A" /* NA */));
    const widthArray = expandArrayValueObject(maxRowLength, maxColumnLength, _width, ErrorValueObject.create("#N/A" /* NA */));
    return rowsArray.mapValue((rowsValue, rowIndex, columnIndex) => {
      const columnsValue = columnsArray.get(rowIndex, columnIndex);
      const heightValue = heightArray.get(rowIndex, columnIndex);
      const widthValue = widthArray.get(rowIndex, columnIndex);
      if (rowsValue.isError()) {
        return rowsValue;
      }
      if (columnsValue.isError()) {
        return columnsValue;
      }
      if (heightValue.isError()) {
        return heightValue;
      }
      if (widthValue.isError()) {
        return widthValue;
      }
      return this._handleSingleObject(reference, rowsValue, columnsValue, heightValue, widthValue, true);
    });
  }
  // eslint-disable-next-line
  _handleSingleObject(reference, rowsValue, columnsValue, heightValue, widthValue, isReportError = false) {
    const { startRow: referenceStartRow, startColumn: referenceStartColumn } = reference.getRangePosition();
    let _rowsValue = rowsValue;
    if (_rowsValue.isString()) {
      _rowsValue = _rowsValue.convertToNumberObjectValue();
    }
    if (_rowsValue.isError()) {
      return _rowsValue;
    }
    let _columnsValue = columnsValue;
    if (_columnsValue.isString()) {
      _columnsValue = _columnsValue.convertToNumberObjectValue();
    }
    if (_columnsValue.isError()) {
      return _columnsValue;
    }
    const rowOffset = +_rowsValue.getValue();
    const columnOffset = +_columnsValue.getValue();
    if (typeof rowOffset !== "number" || typeof columnOffset !== "number") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const targetRow = referenceStartRow + rowOffset;
    const targetColumn = referenceStartColumn + columnOffset;
    if (targetRow < 0 || targetColumn < 0) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const heightCount = this.getIndexNumValue(heightValue);
    const widthCount = this.getIndexNumValue(widthValue);
    if (typeof heightCount !== "number" || typeof widthCount !== "number") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (heightCount === 0 || widthCount === 0) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const targetRowWithHeight = heightCount > 0 ? targetRow + heightCount - 1 : targetRow + heightCount + 1;
    const targetColumnWithWidth = widthCount > 0 ? targetColumn + widthCount - 1 : targetColumn + widthCount + 1;
    if (targetRowWithHeight < 0 || targetColumnWithWidth < 0) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (isReportError) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const startRow = targetRow < targetRowWithHeight ? targetRow : targetRowWithHeight;
    const startColumn = targetColumn < targetColumnWithWidth ? targetColumn : targetColumnWithWidth;
    const endRow = targetRow > targetRowWithHeight ? targetRow : targetRowWithHeight;
    const endColumn = targetColumn > targetColumnWithWidth ? targetColumn : targetColumnWithWidth;
    const range = {
      startRow,
      startColumn,
      endRow,
      endColumn
    };
    return this.createReferenceObject(reference, range);
  }
};

// ../packages/engine-formula/src/functions/lookup/row/index.ts
var Row = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 1);
  }
  calculate(reference) {
    if (reference == null) {
      return NumberValueObject.create(this.row + 1);
    }
    if (reference.isError()) {
      return reference;
    }
    if (!reference.isArray()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const row = reference.getCurrentRow();
    const rowCount = reference.getRowCount();
    const calculateValueList = [];
    for (let i = 0; i < rowCount; i++) {
      calculateValueList.push([NumberValueObject.create(row + i + 1)]);
    }
    const arrayValueObjectData = {
      calculateValueList,
      rowCount,
      columnCount: 1,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};

// ../packages/engine-formula/src/functions/lookup/rows/index.ts
var Rows = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(reference) {
    if (reference.isError()) {
      return reference;
    }
    if (reference.isString() || reference.isNumber() || reference.isBoolean()) {
      return NumberValueObject.create(1);
    }
    if (!reference.isArray()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const rowCount = reference.getRowCount();
    return NumberValueObject.create(rowCount);
  }
};

// ../packages/engine-formula/src/functions/lookup/sort/index.ts
var Sort = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 4);
  }
  calculate(array, sortIndex, sortOrder, byCol) {
    const _sortIndex = sortIndex != null ? sortIndex : NumberValueObject.create(1);
    const _sortOrder = sortOrder != null ? sortOrder : NumberValueObject.create(1);
    const _byCol = byCol != null ? byCol : BooleanValueObject.create(false);
    if (_byCol.isArray()) {
      const byColRowCount = _byCol.getRowCount();
      const byColColumnCount = _byCol.getColumnCount();
      if (byColRowCount === 1 && byColColumnCount === 1) {
        const byColObject = _byCol.get(0, 0);
        return this._handleSingleObject(array, _sortIndex, _sortOrder, byColObject);
      }
      return _byCol.map((byColObject) => {
        const result = this._handleSingleObject(array, _sortIndex, _sortOrder, byColObject);
        return result.isArray() ? result.get(0, 0) : result;
      });
    }
    return this._handleSingleObject(array, _sortIndex, _sortOrder, _byCol);
  }
  _handleSingleObject(array, sortIndex, sortOrder, byCol) {
    if (array.isError()) {
      return array;
    }
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const _sortIndex = this._checkArrayError(sortIndex);
    if (_sortIndex.isError()) {
      return _sortIndex;
    }
    const sortIndexValue = Math.floor(+_sortIndex.getValue());
    if (sortIndexValue < 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const _sortOrder = this._checkArrayError(sortOrder);
    if (_sortOrder.isError()) {
      return _sortOrder;
    }
    const sortOrderValue = Math.floor(+_sortOrder.getValue());
    if (sortOrderValue !== -1 && sortOrderValue !== 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let _byCol = byCol;
    if (_byCol.isString()) {
      _byCol = _byCol.convertToNumberObjectValue();
    }
    if (_byCol.isError()) {
      return _byCol;
    }
    if (!array.isArray() || arrayRowCount === 1 && arrayColumnCount === 1) {
      return array;
    }
    const byColValue = +_byCol.getValue();
    return this._getResult(array, sortIndexValue, sortOrderValue, byColValue, arrayRowCount, arrayColumnCount);
  }
  _checkArrayError(variant) {
    let _variant = variant;
    if (_variant.isArray()) {
      const rowCount = _variant.getRowCount();
      const columnCount = _variant.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _variant = _variant.get(0, 0);
    }
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    return _variant;
  }
  _getResult(array, sortIndexValue, sortOrderValue, byColValue, arrayRowCount, arrayColumnCount) {
    if (!byColValue) {
      if (sortIndexValue > arrayColumnCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const arrayValue = array.getArrayValue();
      arrayValue.sort(this._sort(sortIndexValue - 1, sortOrderValue));
      return ArrayValueObject.create({
        calculateValueList: arrayValue,
        rowCount: arrayValue.length,
        columnCount: arrayValue[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    } else {
      if (sortIndexValue > arrayRowCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const arrayValue = array.transpose().getArrayValue();
      arrayValue.sort(this._sort(sortIndexValue - 1, sortOrderValue));
      const newArray = ArrayValueObject.create({
        calculateValueList: arrayValue,
        rowCount: arrayValue.length,
        columnCount: arrayValue[0].length || 0,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
      return newArray.transpose();
    }
  }
  _sort(sortIndex, sortOrder = 1) {
    const compare = getCompare();
    if (sortOrder === 1) {
      return this._sortAsc(sortIndex, compare);
    } else {
      return this._sortDesc(sortIndex, compare);
    }
  }
  _sortAsc(sortIndex, compare) {
    return (a2, b) => {
      const columnA = a2[sortIndex];
      const columnB = b[sortIndex];
      if (columnA == null || columnA.isNull()) {
        return 1;
      }
      if (columnB == null || columnB.isNull()) {
        return -1;
      }
      if (columnA.isError() && columnB.isError()) {
        return 0;
      }
      if (columnA.isError()) {
        return 1;
      }
      if (columnB.isError()) {
        return -1;
      }
      const columnAValue = columnA.getValue();
      const columnBValue = columnB.getValue();
      if (columnA.isBoolean() && columnAValue === true) {
        return 1;
      }
      if (columnB.isBoolean() && columnBValue === true) {
        return -1;
      }
      if (columnA.isBoolean() && columnAValue === false) {
        return 1;
      }
      if (columnB.isBoolean() && columnBValue === false) {
        return -1;
      }
      if (columnA.isNumber() && columnB.isNumber()) {
        return +columnAValue - +columnBValue;
      }
      return compare(
        columnAValue,
        columnBValue
      );
    };
  }
  _sortDesc(sortIndex, compare) {
    return (a2, b) => {
      const columnA = a2[sortIndex];
      const columnB = b[sortIndex];
      if (columnA == null || columnA.isNull()) {
        return 1;
      }
      if (columnB == null || columnB.isNull()) {
        return -1;
      }
      if (columnA.isError() && columnB.isError()) {
        return 0;
      }
      if (columnA.isError()) {
        return -1;
      }
      if (columnB.isError()) {
        return 1;
      }
      const columnAValue = columnA.getValue();
      const columnBValue = columnB.getValue();
      if (columnA.isBoolean() && columnAValue === true) {
        return -1;
      }
      if (columnB.isBoolean() && columnBValue === true) {
        return 1;
      }
      if (columnA.isBoolean() && columnAValue === false) {
        return -1;
      }
      if (columnB.isBoolean() && columnBValue === false) {
        return 1;
      }
      if (columnA.isNumber() && columnB.isNumber()) {
        return +columnBValue - +columnAValue;
      }
      return compare(
        columnBValue,
        columnAValue
      );
    };
  }
};

// ../packages/engine-formula/src/functions/lookup/sortby/index.ts
var Sortby = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
  }
  calculate(array, ...variants) {
    if (variants.length === 1) {
      variants.push(NumberValueObject.create(1));
    }
    const variantsError = this._getVariantsError(array, ...variants);
    const { maxRowLength, maxColumnLength } = calculateMaxDimensions(variants);
    if (variantsError.isError()) {
      const expandArray = expandArrayValueObject(maxRowLength, maxColumnLength, variantsError);
      if (maxRowLength === 1 && maxColumnLength === 1) {
        return expandArray.get(0, 0);
      }
      return expandArray;
    }
    const _variants = variants.map((variant, index) => {
      if (index % 2 === 0) {
        return variant;
      }
      const variantArray = expandArrayValueObject(maxRowLength, maxColumnLength, variant, ErrorValueObject.create("#N/A" /* NA */));
      return variantArray;
    });
    const resultArray = this._getResultArray(array, _variants, maxRowLength, maxColumnLength);
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray[0][0];
    }
    return ArrayValueObject.create({
      calculateValueList: resultArray,
      rowCount: resultArray.length,
      columnCount: resultArray[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  // eslint-disable-next-line complexity
  _getVariantsError(array, ...variants) {
    if (array.isError()) {
      return array;
    }
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
    }
    if (variants.length < 2 || variants.length % 2 !== 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const byArray1RowCount = variants[0].isArray() ? variants[0].getRowCount() : 1;
    const byArray1ColumnCount = variants[0].isArray() ? variants[0].getColumnCount() : 1;
    if (byArray1RowCount > 1 || byArray1ColumnCount > 1) {
      if (byArray1RowCount > 1 && byArray1ColumnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (byArray1RowCount === 1 && byArray1ColumnCount !== arrayColumnCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (byArray1ColumnCount === 1 && byArray1RowCount !== arrayRowCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    for (let i = 2; i < variants.length; i++) {
      if (i % 2 === 1) {
        continue;
      }
      const byArrayRowCount = variants[i].isArray() ? variants[i].getRowCount() : 1;
      const byArrayColumnCount = variants[i].isArray() ? variants[i].getColumnCount() : 1;
      if (byArrayRowCount !== byArray1RowCount || byArrayColumnCount !== byArray1ColumnCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    return BooleanValueObject.create(true);
  }
  _getResultArray(array, variants, maxRowLength, maxColumnLength) {
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const byArray1RowCount = variants[0].isArray() ? variants[0].getRowCount() : 1;
    const byArray1ColumnCount = variants[0].isArray() ? variants[0].getColumnCount() : 1;
    const resultArray = [];
    for (let r = 0; r < maxRowLength; r++) {
      resultArray[r] = [];
      for (let c = 0; c < maxColumnLength; c++) {
        const { isError, errorObject, byArrays, sortOrders } = this._getByArraysAndSortOrders(variants, r, c, byArray1ColumnCount);
        if (isError) {
          resultArray[r].push(errorObject);
          continue;
        }
        if (!array.isArray() || arrayRowCount === 1 && arrayColumnCount === 1) {
          resultArray[r].push(array);
          continue;
        }
        let arrayValue = array.getArrayValue();
        if (!(byArray1RowCount === 1 && byArray1ColumnCount === 1)) {
          if (byArray1RowCount === 1) {
            arrayValue = arrayValue.concat(byArrays);
            arrayValue = this._transposeArray(arrayValue);
            arrayValue.sort(this._sort(arrayRowCount, sortOrders));
            arrayValue = this._transposeArray(arrayValue).slice(0, arrayRowCount);
          } else if (byArray1ColumnCount === 1) {
            arrayValue = this._transposeArray(arrayValue);
            arrayValue = arrayValue.concat(byArrays);
            arrayValue = this._transposeArray(arrayValue);
            arrayValue.sort(this._sort(arrayColumnCount, sortOrders));
            arrayValue = arrayValue.map((row) => row.slice(0, arrayColumnCount));
          }
        }
        const result = ArrayValueObject.create({
          calculateValueList: arrayValue,
          rowCount: arrayValue.length,
          columnCount: arrayValue[0].length || 0,
          unitId: this.unitId,
          sheetId: this.subUnitId,
          row: this.row,
          column: this.column
        });
        if (maxRowLength > 1 || maxColumnLength > 1) {
          resultArray[r].push(result.get(0, 0));
          continue;
        }
        resultArray[r].push(result);
      }
    }
    return resultArray;
  }
  _getByArraysAndSortOrders(variants, r, c, byArray1ColumnCount) {
    const byArrays = [];
    const sortOrders = [];
    let isError = false;
    let errorObject = null;
    for (let i = 0; i < variants.length; i++) {
      if (i % 2 === 1) {
        continue;
      }
      const byArray = variants[i];
      let sortOrder = variants[i + 1].get(r, c);
      if (sortOrder.isString()) {
        sortOrder = sortOrder.convertToNumberObjectValue();
      }
      if (sortOrder.isError()) {
        isError = true;
        errorObject = sortOrder;
        break;
      }
      const sortOrderValue = Math.floor(+sortOrder.getValue());
      if (sortOrderValue !== -1 && sortOrderValue !== 1) {
        isError = true;
        errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        break;
      }
      sortOrders.push(sortOrderValue);
      if (byArray.isArray()) {
        let byArrayValue = byArray.getArrayValue();
        if (byArray1ColumnCount === 1) {
          byArrayValue = this._transposeArray(byArrayValue);
        }
        byArrays.push(byArrayValue[0]);
      } else {
        byArrays.push([byArray]);
      }
    }
    return {
      isError,
      errorObject,
      byArrays,
      sortOrders
    };
  }
  _transposeArray(array) {
    const rows = array.length;
    const cols = array[0].length;
    const transposedArray = [];
    for (let col = 0; col < cols; col++) {
      transposedArray[col] = [];
      for (let row = 0; row < rows; row++) {
        transposedArray[col][row] = array[row][col];
      }
    }
    return transposedArray;
  }
  _sort(sortIndex, sortOrders) {
    const compare = getCompare();
    return (a2, b) => {
      let columnA = a2[sortIndex];
      let columnB = b[sortIndex];
      let result = this._compare(columnA, columnB, sortOrders[0], compare);
      if (result === 0 && sortOrders.length > 1) {
        for (let i = 1; i < sortOrders.length; i++) {
          columnA = a2[sortIndex + i];
          columnB = b[sortIndex + i];
          result = this._compare(columnA, columnB, sortOrders[i], compare);
          if (result !== 0) {
            return result;
          }
        }
      }
      return result;
    };
  }
  _compare(columnA, columnB, sortOrder, compare) {
    if (sortOrder === 1) {
      return this._asc(columnA, columnB, compare);
    } else {
      return this._desc(columnA, columnB, compare);
    }
  }
  _asc(columnA, columnB, compare) {
    if (columnA == null || columnA.isNull()) {
      return 1;
    }
    if (columnB == null || columnB.isNull()) {
      return -1;
    }
    if (columnA.isError() && columnB.isError()) {
      return 0;
    }
    if (columnA.isError()) {
      return 1;
    }
    if (columnB.isError()) {
      return -1;
    }
    const columnAValue = columnA.getValue();
    const columnBValue = columnB.getValue();
    if (columnA.isBoolean() && columnAValue === true) {
      return 1;
    }
    if (columnB.isBoolean() && columnBValue === true) {
      return -1;
    }
    if (columnA.isBoolean() && columnAValue === false) {
      return 1;
    }
    if (columnB.isBoolean() && columnBValue === false) {
      return -1;
    }
    if (columnA.isNumber() && columnB.isNumber()) {
      return +columnAValue - +columnBValue;
    }
    return compare(
      columnAValue,
      columnBValue
    );
  }
  _desc(columnA, columnB, compare) {
    if (columnA == null || columnA.isNull()) {
      return 1;
    }
    if (columnB == null || columnB.isNull()) {
      return -1;
    }
    if (columnA.isError() && columnB.isError()) {
      return 0;
    }
    if (columnA.isError()) {
      return -1;
    }
    if (columnB.isError()) {
      return 1;
    }
    const columnAValue = columnA.getValue();
    const columnBValue = columnB.getValue();
    if (columnA.isBoolean() && columnAValue === true) {
      return -1;
    }
    if (columnB.isBoolean() && columnBValue === true) {
      return 1;
    }
    if (columnA.isBoolean() && columnAValue === false) {
      return -1;
    }
    if (columnB.isBoolean() && columnBValue === false) {
      return 1;
    }
    if (columnA.isNumber() && columnB.isNumber()) {
      return +columnBValue - +columnAValue;
    }
    return compare(
      columnBValue,
      columnAValue
    );
  }
};

// ../packages/engine-formula/src/functions/lookup/take/index.ts
var Take = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, rows, columns) {
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    let _rows = rows;
    let _columns = columns != null ? columns : NumberValueObject.create(arrayColumnCount);
    if (rows.isNull()) {
      _rows = NumberValueObject.create(arrayRowCount);
    }
    if (_columns.isNull()) {
      _columns = NumberValueObject.create(arrayColumnCount);
    }
    const maxRowLength = Math.max(
      _rows.isArray() ? _rows.getRowCount() : 1,
      _columns.isArray() ? _columns.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _rows.isArray() ? _rows.getColumnCount() : 1,
      _columns.isArray() ? _columns.getColumnCount() : 1
    );
    const rowsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _rows, ErrorValueObject.create("#N/A" /* NA */));
    const columnsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _columns, ErrorValueObject.create("#N/A" /* NA */));
    if (maxRowLength > 1 || maxColumnLength > 1) {
      return rowsArray.mapValue((rowsObject2, rowIndex, columnIndex) => {
        const columnsObject2 = columnsArray.get(rowIndex, columnIndex);
        if (array.isError()) {
          return array;
        }
        if (array.isNull()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        const { isError: isError2, errorObject: errorObject2 } = this._checkRowsColumns(rowsObject2, columnsObject2, arrayRowCount, arrayColumnCount);
        if (isError2) {
          return errorObject2;
        }
        if (array.isArray()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        return array;
      });
    }
    if (array.isError()) {
      return array;
    }
    if (array.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowsObject = _rows.isArray() ? _rows.get(0, 0) : _rows;
    const columnsObject = _columns.isArray() ? _columns.get(0, 0) : _columns;
    const { isError, errorObject, rowsValue, columnsValue } = this._checkRowsColumns(rowsObject, columnsObject, arrayRowCount, arrayColumnCount);
    if (isError) {
      return errorObject;
    }
    return this._getResultArray(array, rowsValue, columnsValue, arrayRowCount, arrayColumnCount);
  }
  _checkRowsColumns(rowsObject, columnsObject, arrayRowCount, arrayColumnCount) {
    if (rowsObject.isError()) {
      return {
        isError: true,
        errorObject: rowsObject
      };
    }
    if (columnsObject.isError()) {
      return {
        isError: true,
        errorObject: columnsObject
      };
    }
    let rowsValue = Math.trunc(+rowsObject.getValue());
    let columnsValue = Math.trunc(+columnsObject.getValue());
    if (Number.isNaN(rowsValue) || Number.isNaN(columnsValue)) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    if (Math.abs(rowsValue) === 0 || Math.abs(columnsValue) === 0) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#CALC!" /* CALC */)
      };
    }
    if (rowsValue > arrayRowCount) {
      rowsValue = arrayRowCount;
    }
    if (columnsValue > arrayColumnCount) {
      columnsValue = arrayColumnCount;
    }
    return {
      isError: false,
      rowsValue,
      columnsValue
    };
  }
  _getResultArray(array, rows, columns, arrayRowCount, arrayColumnCount) {
    if (!array.isArray()) {
      return array;
    }
    const rowParam = rows >= 0 ? [0, rows] : [arrayRowCount + rows, arrayRowCount];
    const columnParam = columns >= 0 ? [0, columns] : [arrayColumnCount + columns, arrayColumnCount];
    let resultArray;
    if (rows === arrayRowCount && columns === arrayColumnCount) {
      resultArray = array;
    } else if (rows === arrayRowCount) {
      resultArray = array.slice(void 0, columnParam);
    } else if (columns === arrayColumnCount) {
      resultArray = array.slice(rowParam, void 0);
    } else {
      resultArray = array.slice(rowParam, columnParam);
    }
    resultArray = resultArray.map((valueObject) => valueObject.isNull() ? NumberValueObject.create(0) : valueObject);
    if (rows === 1 && columns === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/lookup/tocol/index.ts
var Tocol = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, ignore, scanByColumn) {
    const _ignore = ignore != null ? ignore : NumberValueObject.create(0);
    const _scanByColumn = scanByColumn != null ? scanByColumn : BooleanValueObject.create(false);
    const maxRowLength = Math.max(
      _ignore.isArray() ? _ignore.getRowCount() : 1,
      _scanByColumn.isArray() ? _scanByColumn.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _ignore.isArray() ? _ignore.getColumnCount() : 1,
      _scanByColumn.isArray() ? _scanByColumn.getColumnCount() : 1
    );
    const ignoreArray = expandArrayValueObject(maxRowLength, maxColumnLength, _ignore, ErrorValueObject.create("#N/A" /* NA */));
    const scanByColumnArray = expandArrayValueObject(maxRowLength, maxColumnLength, _scanByColumn, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = ignoreArray.mapValue((ignoreObject, rowIndex, columnIndex) => {
      const scanByColumnObject = scanByColumnArray.get(rowIndex, columnIndex);
      if (array.isError()) {
        return array;
      }
      if (array.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (ignoreObject.isError()) {
        return ignoreObject;
      }
      if (scanByColumnObject.isError()) {
        return scanByColumnObject;
      }
      const ignoreValue = Math.trunc(+ignoreObject.getValue());
      const scanByColumnValue = +scanByColumnObject.getValue();
      if (Number.isNaN(ignoreValue) || ignoreValue < 0 || ignoreValue > 3 || Number.isNaN(scanByColumnValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (!array.isArray()) {
        return array;
      }
      let result = [];
      if (scanByColumnValue) {
        result = this._getArrayValueByColumn(array, ignoreValue);
      } else {
        result = this._getArrayValueByRow(array, ignoreValue);
      }
      if (result.length === 0) {
        return ErrorValueObject.create("#CALC!" /* CALC */);
      }
      if (maxRowLength > 1 || maxColumnLength > 1 || result.length === 1) {
        return result[0];
      }
      return ArrayValueObject.create({
        calculateValueList: result.map((valueObject) => [valueObject]),
        rowCount: result.length,
        columnCount: 1,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getArrayValueByColumn(array, ignore) {
    const _array = array;
    const arrayRowCount = _array.getRowCount();
    const arrayColumnCount = _array.getColumnCount();
    const result = [];
    for (let c = 0; c < arrayColumnCount; c++) {
      for (let r = 0; r < arrayRowCount; r++) {
        const valueObject = _array.get(r, c);
        if (!this._isIgnore(valueObject, ignore)) {
          result.push(valueObject.isNull() ? NumberValueObject.create(0) : valueObject);
        }
      }
    }
    return result;
  }
  _getArrayValueByRow(array, ignore) {
    const _array = array;
    const arrayRowCount = _array.getRowCount();
    const arrayColumnCount = _array.getColumnCount();
    const result = [];
    for (let r = 0; r < arrayRowCount; r++) {
      for (let c = 0; c < arrayColumnCount; c++) {
        const valueObject = _array.get(r, c);
        if (!this._isIgnore(valueObject, ignore)) {
          result.push(valueObject.isNull() ? NumberValueObject.create(0) : valueObject);
        }
      }
    }
    return result;
  }
  _isIgnore(valueObject, ignore) {
    switch (ignore) {
      case 0:
        return false;
      case 1:
        return valueObject.isNull();
      case 2:
        return valueObject.isError();
      case 3:
        return valueObject.isNull() || valueObject.isError();
      default:
        return false;
    }
  }
};

// ../packages/engine-formula/src/functions/lookup/torow/index.ts
var Torow = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, ignore, scanByColumn) {
    const _ignore = ignore != null ? ignore : NumberValueObject.create(0);
    const _scanByColumn = scanByColumn != null ? scanByColumn : BooleanValueObject.create(false);
    const maxRowLength = Math.max(
      _ignore.isArray() ? _ignore.getRowCount() : 1,
      _scanByColumn.isArray() ? _scanByColumn.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _ignore.isArray() ? _ignore.getColumnCount() : 1,
      _scanByColumn.isArray() ? _scanByColumn.getColumnCount() : 1
    );
    const ignoreArray = expandArrayValueObject(maxRowLength, maxColumnLength, _ignore, ErrorValueObject.create("#N/A" /* NA */));
    const scanByColumnArray = expandArrayValueObject(maxRowLength, maxColumnLength, _scanByColumn, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = ignoreArray.mapValue((ignoreObject, rowIndex, columnIndex) => {
      const scanByColumnObject = scanByColumnArray.get(rowIndex, columnIndex);
      if (array.isError()) {
        return array;
      }
      if (ignoreObject.isError()) {
        return ignoreObject;
      }
      if (scanByColumnObject.isError()) {
        return scanByColumnObject;
      }
      const ignoreValue = Math.trunc(+ignoreObject.getValue());
      const scanByColumnValue = +scanByColumnObject.getValue();
      if (Number.isNaN(ignoreValue) || ignoreValue < 0 || ignoreValue > 3 || Number.isNaN(scanByColumnValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (array.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (!array.isArray()) {
        return array;
      }
      let result = [];
      if (scanByColumnValue) {
        result = this._getArrayValueByColumn(array, ignoreValue);
      } else {
        result = this._getArrayValueByRow(array, ignoreValue);
      }
      if (result.length === 0) {
        return ErrorValueObject.create("#CALC!" /* CALC */);
      }
      if (maxRowLength > 1 || maxColumnLength > 1 || result.length === 1) {
        return result[0];
      }
      return ArrayValueObject.create({
        calculateValueList: [result],
        rowCount: 1,
        columnCount: result.length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getArrayValueByColumn(array, ignore) {
    const _array = array;
    const arrayRowCount = _array.getRowCount();
    const arrayColumnCount = _array.getColumnCount();
    const result = [];
    for (let c = 0; c < arrayColumnCount; c++) {
      for (let r = 0; r < arrayRowCount; r++) {
        const valueObject = _array.get(r, c);
        if (!this._isIgnore(valueObject, ignore)) {
          result.push(valueObject.isNull() ? NumberValueObject.create(0) : valueObject);
        }
      }
    }
    return result;
  }
  _getArrayValueByRow(array, ignore) {
    const _array = array;
    const arrayRowCount = _array.getRowCount();
    const arrayColumnCount = _array.getColumnCount();
    const result = [];
    for (let r = 0; r < arrayRowCount; r++) {
      for (let c = 0; c < arrayColumnCount; c++) {
        const valueObject = _array.get(r, c);
        if (!this._isIgnore(valueObject, ignore)) {
          result.push(valueObject.isNull() ? NumberValueObject.create(0) : valueObject);
        }
      }
    }
    return result;
  }
  _isIgnore(valueObject, ignore) {
    switch (ignore) {
      case 0:
        return false;
      case 1:
        return valueObject.isNull();
      case 2:
        return valueObject.isError();
      case 3:
        return valueObject.isNull() || valueObject.isError();
      default:
        return false;
    }
  }
};

// ../packages/engine-formula/src/functions/lookup/transpose/index.ts
var Transpose = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(array) {
    if (array.isError()) {
      return array;
    }
    if (array.isArray()) {
      const rowCount = array.getRowCount();
      const columnCount = array.getColumnCount();
      if (rowCount === 1 && columnCount === 1) {
        return array.get(0, 0);
      }
      return array.transpose();
    }
    return array;
  }
};

// ../packages/engine-formula/src/functions/lookup/unique/index.ts
var Unique = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, byCol, exactlyOnce) {
    const _byCol = byCol != null ? byCol : BooleanValueObject.create(false);
    const _exactlyOnce = exactlyOnce != null ? exactlyOnce : BooleanValueObject.create(false);
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const maxRowLength = Math.max(
      _byCol.isArray() ? _byCol.getRowCount() : 1,
      _exactlyOnce.isArray() ? _exactlyOnce.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _byCol.isArray() ? _byCol.getColumnCount() : 1,
      _exactlyOnce.isArray() ? _exactlyOnce.getColumnCount() : 1
    );
    const byColArray = expandArrayValueObject(maxRowLength, maxColumnLength, _byCol, ErrorValueObject.create("#N/A" /* NA */));
    const exactlyOnceArray = expandArrayValueObject(maxRowLength, maxColumnLength, _exactlyOnce, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = byColArray.map((byColObject, rowIndex, columnIndex) => {
      let _byColObject = byColObject;
      let exactlyOnceObject = exactlyOnceArray.get(rowIndex, columnIndex);
      if (array.isError()) {
        return array;
      }
      if (_byColObject.isString()) {
        _byColObject = _byColObject.convertToNumberObjectValue();
      }
      if (_byColObject.isError()) {
        return _byColObject;
      }
      if (exactlyOnceObject.isString()) {
        exactlyOnceObject = exactlyOnceObject.convertToNumberObjectValue();
      }
      if (exactlyOnceObject.isError()) {
        return exactlyOnceObject;
      }
      const byColValue = +_byColObject.getValue();
      const exactlyOnceValue = +exactlyOnceObject.getValue();
      let result;
      if (!byColValue && arrayRowCount === 1 || byColValue && arrayColumnCount === 1) {
        result = array;
      } else {
        result = this._getResult(array, byColValue, exactlyOnceValue);
      }
      if ((maxRowLength > 1 || maxColumnLength > 1) && (result == null ? void 0 : result.isArray())) {
        return result.get(0, 0);
      }
      return result;
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResult(array, byColValue, exactlyOnceValue) {
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    let arrayValue = array.getArrayValue();
    let arrayRows = arrayRowCount;
    let arrayColumns = arrayColumnCount;
    if (byColValue) {
      arrayValue = this._transposeArray(arrayValue);
      arrayRows = arrayColumnCount;
      arrayColumns = arrayRowCount;
    }
    const repeatRows = this._getRepeatRows(arrayValue, arrayRows, arrayColumns);
    if (repeatRows.length > 0) {
      const spliceRows = [];
      repeatRows.forEach((rows) => {
        rows.forEach((r, index) => {
          if (index !== 0 || exactlyOnceValue) {
            spliceRows.push(r);
          }
        });
      });
      arrayValue = arrayValue.filter((row, rowIndex) => !spliceRows.includes(rowIndex));
    }
    if (arrayValue.length === 0) {
      return ErrorValueObject.create("#CALC!" /* CALC */);
    }
    if (byColValue) {
      arrayValue = this._transposeArray(arrayValue);
    }
    return ArrayValueObject.create({
      calculateValueList: arrayValue,
      rowCount: arrayValue.length,
      columnCount: arrayValue[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
  _getRepeatRows(arrayValue, arrayRows, arrayColumns) {
    let repeatRows = [];
    for (let c = 0; c < arrayColumns; c++) {
      if (c === 0) {
        const objects = new Array(arrayRows).fill(null).map((item, index) => {
          return {
            r: index,
            valueObject: arrayValue[index][c]
          };
        });
        repeatRows = this._getRepeatRowsByObjects(objects);
      } else {
        if (repeatRows.length === 0) {
          break;
        }
        let newRepeatRows = [];
        repeatRows.forEach((item) => {
          const objects = item.map((r) => {
            return {
              r,
              valueObject: arrayValue[r][c]
            };
          });
          const _repeatRows = this._getRepeatRowsByObjects(objects);
          newRepeatRows = newRepeatRows.concat(_repeatRows);
        });
        repeatRows = newRepeatRows;
      }
    }
    return repeatRows;
  }
  _getRepeatRowsByObjects(objects) {
    const valueMap = /* @__PURE__ */ new Map();
    objects.forEach((item) => {
      const r = item.r;
      const valueObject = item.valueObject;
      let value = valueObject.getValue();
      if (valueObject.isNull()) {
        value = null;
      } else if (valueObject.isString() && isRealNum(value)) {
        value = +value;
      }
      if (!valueMap.has(value)) {
        valueMap.set(value, [r]);
      } else {
        const valueMapItem = valueMap.get(value);
        valueMapItem.push(r);
        valueMap.set(value, valueMapItem);
      }
    });
    return Array.from(valueMap.values()).filter((item) => item.length > 1);
  }
  _transposeArray(array) {
    const rows = array.length;
    const cols = array[0].length;
    const transposedArray = [];
    for (let col = 0; col < cols; col++) {
      transposedArray[col] = [];
      for (let row = 0; row < rows; row++) {
        transposedArray[col][row] = array[row][col];
      }
    }
    return transposedArray;
  }
};

// ../packages/engine-formula/src/functions/lookup/vlookup/index.ts
var Vlookup = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(lookupValue, tableArray, colIndexNum, rangeLookup) {
    if (lookupValue.isError()) {
      return lookupValue;
    }
    if (tableArray.isError()) {
      return tableArray;
    }
    if (!tableArray.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (colIndexNum.isError()) {
      return colIndexNum;
    }
    if (rangeLookup == null ? void 0 : rangeLookup.isError()) {
      return rangeLookup;
    }
    const _rangeLookup = rangeLookup != null ? rangeLookup : BooleanValueObject.create(true);
    if (isSingleValueObject(lookupValue) && isSingleValueObject(_rangeLookup) && colIndexNum.isArray()) {
      return this._handleArrayColIndexNum(lookupValue, tableArray, colIndexNum, _rangeLookup);
    }
    return this._handleNonArrayColIndexNum(lookupValue, tableArray, colIndexNum, _rangeLookup);
  }
  _handleArrayColIndexNum(lookupValue, tableArray, colIndexNum, rangeLookup) {
    const _lookupValue = lookupValue.isArray() ? lookupValue.getFirstCell() : lookupValue;
    const rangeLookupValue = this.getZeroOrOneByOneDefault(rangeLookup);
    if (rangeLookupValue == null) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let errorValue;
    const result = [];
    colIndexNum.iterator((colIndexNumValueObject, rowIndex, columnIndex) => {
      if (colIndexNumValueObject === null || colIndexNumValueObject === void 0) {
        errorValue = ErrorValueObject.create("#VALUE!" /* VALUE */);
        return false;
      }
      const searchObject = this._handleTableArray(_lookupValue, tableArray, colIndexNumValueObject, rangeLookupValue);
      if (searchObject.isError()) {
        errorValue = searchObject;
        return false;
      }
      if (result[rowIndex] === void 0) {
        result[rowIndex] = [];
      }
      result[rowIndex][columnIndex] = searchObject;
    });
    if (errorValue) {
      return errorValue;
    }
    return createNewArray(result, result.length, result[0].length, this.unitId || "", this.subUnitId || "");
  }
  _handleNonArrayColIndexNum(lookupValue, tableArray, colIndexNum, rangeLookup) {
    const maxRowLength = Math.max(
      lookupValue.isArray() ? lookupValue.getRowCount() : 1,
      rangeLookup.isArray() ? rangeLookup.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      lookupValue.isArray() ? lookupValue.getColumnCount() : 1,
      rangeLookup.isArray() ? rangeLookup.getColumnCount() : 1
    );
    const lookupValueArray = expandArrayValueObject(maxRowLength, maxColumnLength, lookupValue);
    const rangeLookupArray = expandArrayValueObject(maxRowLength, maxColumnLength, rangeLookup);
    return lookupValueArray.map((lookupValue2, rowIndex, columnIndex) => {
      if (lookupValue2.isError()) {
        return lookupValue2;
      }
      const rangeLookupValueObject = rangeLookupArray.get(rowIndex, columnIndex);
      if (rangeLookupValueObject == null) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (rangeLookupValueObject.isError()) {
        return rangeLookupValueObject;
      }
      const rangeLookupValue = this.getZeroOrOneByOneDefault(rangeLookupValueObject);
      if (rangeLookupValue == null) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return this._handleTableArray(lookupValue2, tableArray, colIndexNum, rangeLookupValue);
    });
  }
  _handleTableArray(lookupValue, tableArray, colIndexNum, rangeLookupValue) {
    let colIndexNumValue = this.getIndexNumValue(colIndexNum);
    if (colIndexNumValue instanceof ErrorValueObject) {
      return colIndexNumValue;
    }
    colIndexNumValue = Math.floor(colIndexNumValue);
    if (colIndexNumValue < 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const searchArray2 = tableArray.slice(void 0, [0, 1]);
    if (searchArray2 == null) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const resultArray = tableArray.slice(void 0, [colIndexNumValue - 1, colIndexNumValue]);
    if (resultArray == null) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    return this._handleSingleObject(lookupValue, searchArray2, resultArray, rangeLookupValue);
  }
  _handleSingleObject(value, searchArray2, resultArray, rangeLookupValue) {
    if (rangeLookupValue === 0) {
      return this.equalSearch(value, searchArray2, resultArray);
    }
    return this.binarySearch(value, searchArray2, resultArray);
  }
};

// ../packages/engine-formula/src/functions/lookup/vstack/index.ts
var Vstack = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const maxColumnLength = Math.max(
      ...variants.map((variantObject) => variantObject.isArray() ? variantObject.getColumnCount() : 1)
    );
    const result = [];
    for (let i = 0; i < variants.length; i++) {
      const variantObject = variants[i];
      if (variantObject.isError()) {
        return variantObject;
      }
      const rowCount = variantObject.isArray() ? variantObject.getRowCount() : 1;
      const columnCount = variantObject.isArray() ? variantObject.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        const row = [];
        for (let c = 0; c < maxColumnLength; c++) {
          let singleObject = variantObject;
          if (variantObject.isArray()) {
            singleObject = variantObject.get(r, c);
          }
          if (c > columnCount - 1 || !singleObject) {
            row.push(ErrorValueObject.create("#N/A" /* NA */));
          } else {
            row.push(singleObject);
          }
        }
        result.push(row);
      }
    }
    return ArrayValueObject.create({
      calculateValueList: result,
      rowCount: result.length,
      columnCount: result[0].length || 0,
      unitId: this.unitId,
      sheetId: this.subUnitId,
      row: this.row,
      column: this.column
    });
  }
};

// ../packages/engine-formula/src/functions/lookup/wrapcols/index.ts
var Wrapcols = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(vector, wrapCount, padWith) {
    let _padWith = padWith != null ? padWith : ErrorValueObject.create("#N/A" /* NA */);
    if (_padWith.isNull()) {
      _padWith = ErrorValueObject.create("#N/A" /* NA */);
    }
    const vectorRowCount = vector.isArray() ? vector.getRowCount() : 1;
    const vectorColumnCount = vector.isArray() ? vector.getColumnCount() : 1;
    const maxRowLength = Math.max(
      wrapCount.isArray() ? wrapCount.getRowCount() : 1,
      _padWith.isArray() ? _padWith.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      wrapCount.isArray() ? wrapCount.getColumnCount() : 1,
      _padWith.isArray() ? _padWith.getColumnCount() : 1
    );
    const wrapCountArray = expandArrayValueObject(maxRowLength, maxColumnLength, wrapCount, ErrorValueObject.create("#N/A" /* NA */));
    const padWithArray = expandArrayValueObject(maxRowLength, maxColumnLength, _padWith, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = wrapCountArray.mapValue((wrapCountObject, rowIndex, columnIndex) => {
      const padWithObject = padWithArray.get(rowIndex, columnIndex);
      if (vector.isError()) {
        return vector;
      }
      if (vector.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (wrapCountObject.isError()) {
        return wrapCountObject;
      }
      const wrapCountValue = Math.trunc(+wrapCountObject.getValue());
      if (vectorRowCount > 1 && vectorColumnCount > 1 || Number.isNaN(wrapCountValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (wrapCountValue < 1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const vectorArray = vector.isArray() ? vector.getArrayValue().flat() : [vector];
      const result = this._getWrapArray(vectorArray, wrapCountValue, padWithObject);
      if (maxRowLength > 1 || maxColumnLength > 1 || result.length === 1 && result[0].length === 1) {
        return result[0][0];
      }
      return ArrayValueObject.create({
        calculateValueList: result,
        rowCount: result.length,
        columnCount: result[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getWrapArray(vectorArray, wrapCount, padWith) {
    const columns = Math.ceil(vectorArray.length / wrapCount);
    const _wrapCount = columns > 1 ? wrapCount : vectorArray.length;
    const result = [];
    for (let c = 0; c < columns; c++) {
      for (let r = 0; r < _wrapCount; r++) {
        if (!result[r]) {
          result[r] = [];
        }
        const index = c * _wrapCount + r;
        if (index < vectorArray.length) {
          result[r].push(vectorArray[index].isNull() ? NumberValueObject.create(0) : vectorArray[index]);
        } else {
          result[r].push(padWith);
        }
      }
    }
    return result;
  }
};

// ../packages/engine-formula/src/functions/lookup/wraprows/index.ts
var Wraprows = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(vector, wrapCount, padWith) {
    let _padWith = padWith != null ? padWith : ErrorValueObject.create("#N/A" /* NA */);
    if (_padWith.isNull()) {
      _padWith = ErrorValueObject.create("#N/A" /* NA */);
    }
    const vectorRowCount = vector.isArray() ? vector.getRowCount() : 1;
    const vectorColumnCount = vector.isArray() ? vector.getColumnCount() : 1;
    const maxRowLength = Math.max(
      wrapCount.isArray() ? wrapCount.getRowCount() : 1,
      _padWith.isArray() ? _padWith.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      wrapCount.isArray() ? wrapCount.getColumnCount() : 1,
      _padWith.isArray() ? _padWith.getColumnCount() : 1
    );
    const wrapCountArray = expandArrayValueObject(maxRowLength, maxColumnLength, wrapCount, ErrorValueObject.create("#N/A" /* NA */));
    const padWithArray = expandArrayValueObject(maxRowLength, maxColumnLength, _padWith, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = wrapCountArray.mapValue((wrapCountObject, rowIndex, columnIndex) => {
      const padWithObject = padWithArray.get(rowIndex, columnIndex);
      if (vector.isError()) {
        return vector;
      }
      if (vector.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (wrapCountObject.isError()) {
        return wrapCountObject;
      }
      const wrapCountValue = Math.trunc(+wrapCountObject.getValue());
      if (vectorRowCount > 1 && vectorColumnCount > 1 || Number.isNaN(wrapCountValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (wrapCountValue < 1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const vectorArray = vector.isArray() ? vector.getArrayValue().flat() : [vector];
      const result = this._getWrapArray(vectorArray, wrapCountValue, padWithObject);
      if (maxRowLength > 1 || maxColumnLength > 1 || result.length === 1 && result[0].length === 1) {
        return result[0][0];
      }
      return ArrayValueObject.create({
        calculateValueList: result,
        rowCount: result.length,
        columnCount: result[0].length,
        unitId: this.unitId,
        sheetId: this.subUnitId,
        row: this.row,
        column: this.column
      });
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getWrapArray(vectorArray, wrapCount, padWith) {
    const rows = Math.ceil(vectorArray.length / wrapCount);
    const _wrapCount = rows > 1 ? wrapCount : vectorArray.length;
    const result = [];
    for (let r = 0; r < rows; r++) {
      const row = [];
      for (let c = 0; c < _wrapCount; c++) {
        const index = r * _wrapCount + c;
        if (index < vectorArray.length) {
          row.push(vectorArray[index].isNull() ? NumberValueObject.create(0) : vectorArray[index]);
        } else {
          row.push(padWith);
        }
      }
      result.push(row);
    }
    return result;
  }
};

// ../packages/engine-formula/src/functions/lookup/xlookup/index.ts
var Xlookup = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 6);
  }
  // eslint-disable-next-line
  calculate(lookupValue, lookupArray, returnArray, ifNotFound, matchMode, searchMode) {
    let _ifNotFound = ifNotFound != null ? ifNotFound : ErrorValueObject.create("#N/A" /* NA */);
    if (ifNotFound == null ? void 0 : ifNotFound.isNull()) {
      _ifNotFound = ErrorValueObject.create("#N/A" /* NA */);
    }
    let _matchMode = matchMode != null ? matchMode : NumberValueObject.create(0);
    if (matchMode == null ? void 0 : matchMode.isNull()) {
      _matchMode = NumberValueObject.create(0);
    }
    let _searchMode = searchMode != null ? searchMode : NumberValueObject.create(1);
    if (searchMode == null ? void 0 : searchMode.isNull()) {
      _searchMode = NumberValueObject.create(1);
    }
    if (lookupValue.isError()) {
      return lookupValue;
    }
    if (lookupArray.isError() || returnArray.isError()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (!lookupArray.isArray() || !returnArray.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowCountLookup = lookupArray.getRowCount();
    const columnCountLookup = lookupArray.getColumnCount();
    const rowCountReturn = returnArray.getRowCount();
    const columnCountReturn = returnArray.getColumnCount();
    if (rowCountLookup !== 1 && columnCountLookup !== 1 || rowCountLookup === 1 && columnCountLookup > 1 && columnCountLookup !== columnCountReturn || columnCountLookup === 1 && rowCountLookup > 1 && rowCountLookup !== rowCountReturn) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (_matchMode.isError()) {
      return _matchMode;
    }
    if (_searchMode.isError()) {
      return _searchMode;
    }
    const matchModeValue = this.getIndexNumValue(_matchMode);
    if (matchModeValue instanceof ErrorValueObject) {
      return matchModeValue;
    }
    const searchModeValue = this.getIndexNumValue(_searchMode);
    if (searchModeValue instanceof ErrorValueObject) {
      return searchModeValue;
    }
    return this._getResult(
      lookupValue,
      lookupArray,
      returnArray,
      _ifNotFound,
      matchModeValue,
      searchModeValue,
      rowCountLookup,
      columnCountLookup,
      rowCountReturn,
      columnCountReturn
    );
  }
  _getResult(lookupValue, lookupArray, returnArray, ifNotFound, matchModeValue, searchModeValue, rowCountLookup, columnCountLookup, rowCountReturn, columnCountReturn) {
    const lookupValueRowCount = lookupValue.isArray() ? lookupValue.getRowCount() : 1;
    const lookupValueColumnCount = lookupValue.isArray() ? lookupValue.getColumnCount() : 1;
    if (lookupValueRowCount > 1 || lookupValueColumnCount > 1) {
      let resultArray2;
      if (rowCountLookup === 1) {
        resultArray2 = returnArray.slice([0, 1]);
      } else {
        resultArray2 = returnArray.slice(void 0, [0, 1]);
      }
      if (resultArray2 == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return lookupValue.map((value) => {
        const checkErrorCombination = this._checkErrorCombination(matchModeValue, searchModeValue);
        if (checkErrorCombination) {
          return checkErrorCombination;
        }
        const result = this._handleSingleObject(value, lookupArray, resultArray2, matchModeValue, searchModeValue);
        if (result.isError()) {
          return ifNotFound;
        }
        return result;
      });
    }
    const _lookupValue = lookupValue.isArray() ? lookupValue.get(0, 0) : lookupValue;
    if (columnCountLookup === columnCountReturn && rowCountLookup === rowCountReturn) {
      const checkErrorCombination = this._checkErrorCombination(matchModeValue, searchModeValue);
      if (checkErrorCombination) {
        return checkErrorCombination;
      }
      const result = this._handleSingleObject(_lookupValue, lookupArray, returnArray, matchModeValue, searchModeValue);
      if (result.isError()) {
        return ifNotFound;
      }
      return result;
    }
    let axis = 0;
    if (columnCountLookup === columnCountReturn) {
      axis = 1;
    }
    const resultArray = this._handleExpandObject(_lookupValue, lookupArray, returnArray, matchModeValue, searchModeValue, axis);
    if (resultArray == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    return resultArray;
  }
  _handleExpandObject(value, searchArray2, resultArray, matchModeValue, searchModeValue, axis = 0) {
    if ((searchModeValue === 2 || searchModeValue === -2) && matchModeValue !== 2) {
      const searchType = getSearchModeValue(searchModeValue);
      const matchType = getMatchModeValue(matchModeValue);
      return this.binarySearchExpand(
        value,
        searchArray2,
        resultArray,
        axis,
        searchType,
        matchType
      );
    }
    if (matchModeValue === 2) {
      return this.fuzzySearchExpand(value, searchArray2, resultArray, searchModeValue !== -1, axis);
    }
    if (matchModeValue === -1 || matchModeValue === 1) {
      return this.orderSearchExpand(
        value,
        searchArray2,
        resultArray,
        matchModeValue === 1 ? 2 /* MAX */ : 1 /* MIN */,
        searchModeValue === -1,
        axis
      );
    }
    return this.equalSearchExpand(value, searchArray2, resultArray, searchModeValue !== -1, axis);
  }
  _handleSingleObject(value, searchArray2, resultArray, matchModeValue, searchModeValue) {
    if ((searchModeValue === 2 || searchModeValue === -2) && matchModeValue !== 2) {
      const searchType = getSearchModeValue(searchModeValue);
      const matchType = getMatchModeValue(matchModeValue);
      return this.binarySearch(value, searchArray2, resultArray, searchType, matchType);
    }
    if (matchModeValue === 2) {
      return this.fuzzySearch(value, searchArray2, resultArray, searchModeValue !== -1);
    }
    if (matchModeValue === -1 || matchModeValue === 1) {
      return this.orderSearch(
        value,
        searchArray2,
        resultArray,
        matchModeValue === 1 ? 2 /* MAX */ : 1 /* MIN */,
        searchModeValue === -1
      );
    }
    return this.equalSearch(value, searchArray2, resultArray, searchModeValue !== -1);
  }
  /**
   * Wildcard matching and binary search cannot appear at the same time
   * @param matchModeValue
   * @param searchModeValue
   * @returns
   */
  _checkErrorCombination(matchModeValue, searchModeValue) {
    if (matchModeValue === 2 && (searchModeValue === -2 || searchModeValue === 2)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return null;
  }
};

// ../packages/engine-formula/src/functions/lookup/xmatch/index.ts
var Xmatch = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 4);
  }
  calculate(lookupValue, lookupArray, matchMode, searchMode) {
    if (lookupValue.isError()) {
      return lookupValue;
    }
    if (lookupArray.isError()) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    if (!lookupArray.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const rowCountLookup = lookupArray.getRowCount();
    const columnCountLookup = lookupArray.getColumnCount();
    if (rowCountLookup !== 1 && columnCountLookup !== 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (matchMode == null ? void 0 : matchMode.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (searchMode == null ? void 0 : searchMode.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const matchModeValue = this.getIndexNumValue(matchMode || NumberValueObject.create(0));
    if (matchModeValue instanceof ErrorValueObject) {
      return matchModeValue;
    }
    const searchModeValue = this.getIndexNumValue(searchMode || NumberValueObject.create(1));
    if (searchModeValue instanceof ErrorValueObject) {
      return searchModeValue;
    }
    if (lookupValue.isArray()) {
      return lookupValue.map((value) => this._handleSingleObject(
        value,
        lookupArray,
        matchModeValue,
        searchModeValue
      ));
    }
    return this._handleSingleObject(
      lookupValue,
      lookupArray,
      matchModeValue,
      searchModeValue
    );
  }
  _handleSingleObject(value, searchArray2, matchModeValue, searchModeValue) {
    let rowOrColumn;
    if ((searchModeValue === 2 || searchModeValue === -2) && matchModeValue !== 2) {
      const searchType = getSearchModeValue(searchModeValue);
      const matchType = getMatchModeValue(matchModeValue);
      rowOrColumn = searchArray2.binarySearch(value, searchType, matchType);
    } else if (matchModeValue === 2) {
      const matchObject = searchArray2.compare(value, "=" /* EQUALS */);
      let position;
      if (searchModeValue !== -1) {
        position = matchObject.getFirstTruePosition();
      } else {
        position = matchObject.getLastTruePosition();
      }
      if (position == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      rowOrColumn = searchArray2.getRowCount() === 1 ? position.column : position.row;
    } else if (matchModeValue === -1 || matchModeValue === 1) {
      const position = searchArray2.orderSearch(value, matchModeValue === 1 ? 2 /* MAX */ : 1 /* MIN */, searchModeValue === -1);
      if (position == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (position instanceof ErrorValueObject) {
        return position;
      }
      rowOrColumn = searchArray2.getRowCount() === 1 ? position.column : position.row;
    } else {
      const matchObject = searchArray2.isEqual(value);
      let position;
      if (searchModeValue !== -1) {
        position = matchObject.getFirstTruePosition();
      } else {
        position = matchObject.getLastTruePosition();
      }
      if (position == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      rowOrColumn = searchArray2.getRowCount() === 1 ? position.column : position.row;
    }
    if (rowOrColumn == null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    return NumberValueObject.create(rowOrColumn + 1);
  }
};

// ../packages/engine-formula/src/functions/lookup/function-map.ts
var functionLookup = [
  [Address, "ADDRESS" /* ADDRESS */],
  [Areas, "AREAS" /* AREAS */],
  [Choose, "CHOOSE" /* CHOOSE */],
  [Choosecols, "CHOOSECOLS" /* CHOOSECOLS */],
  [Chooserows, "CHOOSEROWS" /* CHOOSEROWS */],
  [Column, "COLUMN" /* COLUMN */],
  [Columns, "COLUMNS" /* COLUMNS */],
  [Drop, "DROP" /* DROP */],
  [Expand, "EXPAND" /* EXPAND */],
  [Filter, "FILTER" /* FILTER */],
  [Formulatext, "FORMULATEXT" /* FORMULATEXT */],
  [Hlookup, "HLOOKUP" /* HLOOKUP */],
  [Hstack, "HSTACK" /* HSTACK */],
  [Index, "INDEX" /* INDEX */],
  [Indirect, "INDIRECT" /* INDIRECT */],
  [Lookup, "LOOKUP" /* LOOKUP */],
  [Match, "MATCH" /* MATCH */],
  [Offset, "OFFSET" /* OFFSET */],
  [Row, "ROW" /* ROW */],
  [Rows, "ROWS" /* ROWS */],
  [Sort, "SORT" /* SORT */],
  [Sortby, "SORTBY" /* SORTBY */],
  [Take, "TAKE" /* TAKE */],
  [Tocol, "TOCOL" /* TOCOL */],
  [Torow, "TOROW" /* TOROW */],
  [Transpose, "TRANSPOSE" /* TRANSPOSE */],
  [Unique, "UNIQUE" /* UNIQUE */],
  [Vlookup, "VLOOKUP" /* VLOOKUP */],
  [Vstack, "VSTACK" /* VSTACK */],
  [Wrapcols, "WRAPCOLS" /* WRAPCOLS */],
  [Wraprows, "WRAPROWS" /* WRAPROWS */],
  [Xlookup, "XLOOKUP" /* XLOOKUP */],
  [Xmatch, "XMATCH" /* XMATCH */]
];

// ../packages/engine-formula/src/functions/math/abs/index.ts
var Abs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.abs();
  }
};

// ../packages/engine-formula/src/functions/math/acos/index.ts
var Acos = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.acos();
  }
};

// ../packages/engine-formula/src/functions/math/acosh/index.ts
var Acosh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.acosh();
  }
};

// ../packages/engine-formula/src/functions/math/acot/index.ts
var Acot = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    if (_variant.isArray()) {
      return _variant.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return acot(currentValue);
      });
    }
    return acot(_variant);
  }
};
function acot(num) {
  let currentValue = num.getValue();
  if (num.isBoolean()) {
    currentValue = currentValue ? 1 : 0;
  }
  if (!Number.isFinite(currentValue)) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  currentValue = Number(currentValue);
  let result = Math.atan(1 / currentValue);
  if (currentValue < 0) {
    result += Math.PI;
  }
  if (Number.isNaN(result)) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  return NumberValueObject.create(result);
}

// ../packages/engine-formula/src/functions/math/acoth/index.ts
var Acoth = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    if (_variant.isArray()) {
      return _variant.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return acoth(currentValue);
      });
    }
    return acoth(_variant);
  }
};
function acoth(num) {
  let currentValue = num.getValue();
  if (num.isBoolean()) {
    currentValue = currentValue ? 1 : 0;
  }
  if (!Number.isFinite(currentValue)) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  currentValue = Number(currentValue);
  if (Math.abs(currentValue) <= 1) {
    return ErrorValueObject.create("#NUM!" /* NUM */);
  }
  const result = 1 / 2 * Math.log((currentValue + 1) / (currentValue - 1));
  if (Number.isNaN(result)) {
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  return NumberValueObject.create(result);
}

// ../packages/engine-formula/src/functions/math/arabic/index.ts
var Arabic = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  // eslint-disable-next-line
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isNull()) {
      return NumberValueObject.create(0);
    }
    if (text.isBoolean() || text.isNumber()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let textValue = text.getValue().toLocaleString().toLocaleUpperCase();
    if (textValue.length > 255) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const isNegtive = textValue.startsWith("-");
    if (isNegtive) {
      textValue = textValue.slice(1);
    }
    let result = 0;
    for (let i = 0; i < textValue.length; i++) {
      const currentCharValue = romanToArabicMap.get(textValue[i]) || 0;
      const nextCharValue = romanToArabicMap.get(textValue[i + 1]) || 0;
      const nextnextCharValue = romanToArabicMap.get(textValue[i + 2]) || 0;
      const nextnextnextCharValue = romanToArabicMap.get(textValue[i + 3]) || 0;
      if (!currentCharValue || nextnextCharValue >= nextCharValue && nextnextCharValue > currentCharValue || currentCharValue === nextCharValue && currentCharValue === nextnextCharValue && currentCharValue === nextnextnextCharValue || currentCharValue === nextCharValue / 2) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (currentCharValue < nextCharValue) {
        result -= currentCharValue;
      } else {
        result += currentCharValue;
      }
    }
    return NumberValueObject.create(isNegtive ? -result : result);
  }
};

// ../packages/engine-formula/src/functions/math/asin/index.ts
var Asin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.asin();
  }
};

// ../packages/engine-formula/src/functions/math/asinh/index.ts
var Asinh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.asinh();
  }
};

// ../packages/engine-formula/src/functions/math/atan/index.ts
var Atan = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.atan();
  }
};

// ../packages/engine-formula/src/functions/math/atan2/index.ts
var Atan2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(xNum, yNum) {
    let _xNum = xNum;
    let _yNum = yNum;
    if (_xNum.isString()) {
      _xNum = _xNum.convertToNumberObjectValue();
    }
    if (_xNum.isError()) {
      return _xNum;
    }
    if (_yNum.isString()) {
      _yNum = _yNum.convertToNumberObjectValue();
    }
    if (_yNum.isError()) {
      return _yNum;
    }
    return _yNum.atan2(_xNum);
  }
};

// ../packages/engine-formula/src/functions/math/atanh/index.ts
var Atanh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.atanh();
  }
};

// ../packages/engine-formula/src/functions/math/base/index.ts
var Base = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(number, radix, minLength) {
    const _minLength = minLength != null ? minLength : NumberValueObject.create(0);
    if (number.isError()) {
      return number;
    }
    if (radix.isError()) {
      return radix;
    }
    if (_minLength.isError()) {
      return _minLength;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      radix.isArray() ? radix.getRowCount() : 1,
      _minLength.isArray() ? _minLength.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      radix.isArray() ? radix.getColumnCount() : 1,
      _minLength.isArray() ? _minLength.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const radixArray = expandArrayValueObject(maxRowLength, maxColumnLength, radix, ErrorValueObject.create("#N/A" /* NA */));
    const minLengthArray = expandArrayValueObject(maxRowLength, maxColumnLength, _minLength, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      const radixObject = radixArray.get(rowIndex, columnIndex);
      const minLengthObject = minLengthArray.get(rowIndex, columnIndex);
      return this._handleSingleObject(numberObject, radixObject, minLengthObject);
    });
    if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
      return resultArray.getArrayValue()[0][0];
    }
    return resultArray;
  }
  _handleSingleObject(numberObject, radixObject, minLengthObject) {
    let _numberObject = numberObject;
    if (_numberObject.isString()) {
      _numberObject = _numberObject.convertToNumberObjectValue();
    }
    if (_numberObject.isError()) {
      return _numberObject;
    }
    let _radixObject = radixObject;
    if (_radixObject.isString()) {
      _radixObject = _radixObject.convertToNumberObjectValue();
    }
    if (_radixObject.isError()) {
      return _radixObject;
    }
    let _minLengthObject = minLengthObject;
    if (_minLengthObject.isString()) {
      _minLengthObject = _minLengthObject.convertToNumberObjectValue();
    }
    if (_minLengthObject.isError()) {
      return _minLengthObject;
    }
    const numberValue = Math.floor(+_numberObject.getValue());
    const radixValue = Math.floor(+_radixObject.getValue());
    const minLengthValue = Math.floor(+_minLengthObject.getValue());
    if (numberValue < 0 || numberValue >= 2 ** 53) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (radixValue < 2 || radixValue > 36) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (minLengthValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = numberValue.toString(radixValue);
    if (result.length < minLengthValue) {
      result = new Array(minLengthValue - result.length + 1).join("0") + result;
    }
    return StringValueObject.create(result.toLocaleUpperCase());
  }
};

// ../packages/engine-formula/src/functions/math/ceiling/index.ts
var Ceiling = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, significance) {
    if (number.isError()) {
      return number;
    }
    if (significance.isError()) {
      return significance;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      significance.isArray() ? significance.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      significance.isArray() ? significance.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, significance, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let _numberObject = numberObject;
      let significanceObject = significanceArray.get(rowIndex, columnIndex);
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (significanceObject.isString()) {
        significanceObject = significanceObject.convertToNumberObjectValue();
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      const numberValue = +_numberObject.getValue();
      const significanceValue = +significanceObject.getValue();
      if (numberValue > 0 && significanceValue < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (numberValue === 0 || significanceValue === 0) {
        return NumberValueObject.create(0);
      }
      const result = ceil2(numberValue / significanceValue, 0) * significanceValue;
      return NumberValueObject.create(result);
    });
    if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
      return resultArray.getArrayValue()[0][0];
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/ceiling-math/index.ts
var CeilingMath = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 3);
  }
  calculate(number, significance, mode) {
    const _significance = significance != null ? significance : NumberValueObject.create(1);
    const _mode = mode != null ? mode : NumberValueObject.create(0);
    if (number.isError()) {
      return number;
    }
    if (_significance.isError()) {
      return _significance;
    }
    if (_mode.isError()) {
      return _mode;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _significance.isArray() ? _significance.getRowCount() : 1,
      _mode.isArray() ? _mode.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _significance.isArray() ? _significance.getColumnCount() : 1,
      _mode.isArray() ? _mode.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, _significance, ErrorValueObject.create("#N/A" /* NA */));
    const modeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _mode, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let _numberObject = numberObject;
      let significanceObject = significanceArray.get(rowIndex, columnIndex);
      let modeObject = modeArray.get(rowIndex, columnIndex);
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (significanceObject.isString()) {
        significanceObject = significanceObject.convertToNumberObjectValue();
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      if (modeObject.isString()) {
        modeObject = modeObject.convertToNumberObjectValue();
      }
      if (modeObject.isError()) {
        return modeObject;
      }
      const numberValue = +_numberObject.getValue();
      const significanceValue = +significanceObject.getValue();
      const modeValue = +modeObject.getValue();
      if (numberValue === 0 || significanceValue === 0) {
        return NumberValueObject.create(0);
      }
      return this._getResult(numberValue, significanceValue, modeValue);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResult(numberValue, significanceValue, modeValue) {
    let result;
    if (numberValue < 0 && modeValue !== 0) {
      result = (significanceValue < 0 ? ceil2(Math.abs(numberValue) / Math.abs(significanceValue), 0) : -ceil2(Math.abs(numberValue) / significanceValue, 0)) * significanceValue;
    } else {
      result = (significanceValue < 0 ? -ceil2(numberValue / Math.abs(significanceValue), 0) : ceil2(numberValue / significanceValue, 0)) * significanceValue;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/ceiling-precise/index.ts
var CeilingPrecise = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, significance) {
    const _significance = significance != null ? significance : NumberValueObject.create(1);
    if (number.isError()) {
      return number;
    }
    if (_significance.isError()) {
      return _significance;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _significance.isArray() ? _significance.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _significance.isArray() ? _significance.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, _significance, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let significanceObject = significanceArray.get(rowIndex, columnIndex);
      let _numberObject = numberObject;
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (significanceObject.isString()) {
        significanceObject = significanceObject.convertToNumberObjectValue();
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      const numberValue = +_numberObject.getValue();
      const significanceValue = +significanceObject.getValue();
      if (numberValue === 0 || significanceValue === 0) {
        return NumberValueObject.create(0);
      }
      const result = (significanceValue < 0 ? -ceil2(numberValue / Math.abs(significanceValue), 0) : ceil2(numberValue / significanceValue, 0)) * significanceValue;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/combin/index.ts
var Combin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numberChosen) {
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      numberChosen.isArray() ? numberChosen.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      numberChosen.isArray() ? numberChosen.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const numberChosenArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberChosen, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      let _numberObject = numberObject;
      let numberChosenObject = numberChosenArray.get(rowIndex, columnIndex);
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (numberChosenObject.isString()) {
        numberChosenObject = numberChosenObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (numberChosenObject.isError()) {
        return numberChosenObject;
      }
      const numberValue = Math.floor(+_numberObject.getValue());
      const numberChosenValue = Math.floor(+numberChosenObject.getValue());
      if (numberValue < 0 || numberChosenValue < 0 || numberValue < numberChosenValue) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = calculateCombin(numberValue, numberChosenValue);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/combina/index.ts
var Combina = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numberChosen) {
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      numberChosen.isArray() ? numberChosen.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      numberChosen.isArray() ? numberChosen.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const numberChosenArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberChosen, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      let _numberObject = numberObject;
      let numberChosenObject = numberChosenArray.get(rowIndex, columnIndex);
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (numberChosenObject.isString()) {
        numberChosenObject = numberChosenObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (numberChosenObject.isError()) {
        return numberChosenObject;
      }
      const numberValue = Math.floor(+_numberObject.getValue());
      const numberChosenValue = Math.floor(+numberChosenObject.getValue());
      if (numberValue < 0 || numberChosenValue < 0 || numberValue === 0 && numberValue < numberChosenValue) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = calculateCombin(numberValue + numberChosenValue - 1, numberValue - 1);
      if (Number.isNaN(result) || !Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/cos/index.ts
var Cos = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.cos();
  }
};

// ../packages/engine-formula/src/functions/math/cosh/index.ts
var Cosh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    return _number.cosh();
  }
};

// ../packages/engine-formula/src/functions/math/cot/index.ts
var Cot = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    if (variant.isArray()) {
      return variant.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(variant);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (Math.abs(numberValue) >= 2 ** 27) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (numberValue === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return numberObject.tan().getReciprocal();
  }
};

// ../packages/engine-formula/src/functions/math/coth/index.ts
var Coth = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    if (variant.isArray()) {
      return variant.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(variant);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (numberValue === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return numberObject.tanh().getReciprocal();
  }
};

// ../packages/engine-formula/src/functions/math/csc/index.ts
var Csc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    if (variant.isArray()) {
      return variant.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(variant);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (Math.abs(numberValue) >= 2 ** 27) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (numberValue === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return numberObject.sin().getReciprocal();
  }
};

// ../packages/engine-formula/src/functions/math/csch/index.ts
var Csch = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    if (variant.isArray()) {
      return variant.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(variant);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (numberValue === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    if (!Number.isNaN(numberValue) && !Number.isFinite(Math.sinh(numberValue))) {
      return NumberValueObject.create(0);
    }
    return numberObject.sinh().getReciprocal();
  }
};

// ../packages/engine-formula/src/functions/math/decimal/index.ts
var Decimal2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, radix) {
    if (text.isError()) {
      return text;
    }
    if (radix.isError()) {
      return radix;
    }
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      radix.isArray() ? radix.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      radix.isArray() ? radix.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const radixArray = expandArrayValueObject(maxRowLength, maxColumnLength, radix, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = textArray.map((textObject, rowIndex, columnIndex) => {
      if (textObject.isError()) {
        return textObject;
      }
      let radixObject = radixArray.get(rowIndex, columnIndex);
      if (radixObject.isString()) {
        radixObject = radixObject.convertToNumberObjectValue();
      }
      if (radixObject.isError()) {
        return radixObject;
      }
      const textValue = `${textObject.getValue()}`;
      const radixValue = Math.floor(+radixObject.getValue());
      if (isRealNum(textValue) && (+textValue < 0 || +textValue >= 2 ** 53 || !Number.isInteger(+textValue))) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (textValue.toLocaleLowerCase() === "true" || textValue.toLocaleLowerCase() === "false") {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (radixValue < 2 || radixValue > 36) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (textValue.replace(/\s/g, "") === "") {
        return NumberValueObject.create(0);
      }
      if (!this._isValidCharForRadix(textValue, radixValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Number.parseInt(textValue, radixValue);
      if (Number.isNaN(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _isValidCharForRadix(text, radix) {
    for (const char of text) {
      const charCode = char.toUpperCase().charCodeAt(0);
      if (radix <= 10 && !(charCode >= 48 && charCode < 48 + radix)) {
        return false;
      }
      if (radix > 10 && !(charCode >= 48 && charCode < 58 || charCode >= 65 && charCode < 65 + radix - 10)) {
        return false;
      }
    }
    return true;
  }
};

// ../packages/engine-formula/src/functions/math/degrees/index.ts
var Degrees = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(angle) {
    if (angle.isArray()) {
      return angle.map((angleObject) => this._handleSingleObject(angleObject));
    }
    return this._handleSingleObject(angle);
  }
  _handleSingleObject(angle) {
    let angleObject = angle;
    if (angleObject.isString()) {
      angleObject = angleObject.convertToNumberObjectValue();
    }
    if (angleObject.isError()) {
      return angleObject;
    }
    const angleValue = +angleObject.getValue();
    if (!Number.isFinite(angleValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = angleValue * (180 / Math.PI);
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/even/index.ts
var Even = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      return number.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (!Number.isFinite(numberValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = (numberValue < 0 ? -ceil2(Math.abs(numberValue) / 2, 0) : ceil2(numberValue / 2, 0)) * 2;
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (result === 0) {
      return NumberValueObject.create(0);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/exp/index.ts
var Exp = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.exp();
  }
};

// ../packages/engine-formula/src/functions/math/fact/index.ts
var Fact = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      return number.mapValue((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    const numberValue = Math.floor(+_number.getValue());
    const result = calculateFactorial(numberValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/factdouble/index.ts
var Factdouble = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    let _number = number;
    if (number.isArray()) {
      const rowCount = number.getRowCount();
      const columnCount = number.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _number = number.get(0, 0);
    }
    return this._handleSingleObject(_number);
  }
  _handleSingleObject(number) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    const numberValue = Math.floor(+_number.getValue());
    const result = calculateFactorial(numberValue, 2);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/floor/index.ts
var Floor = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, significance) {
    if (number.isError()) {
      return number;
    }
    if (significance.isError()) {
      return significance;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      significance.isArray() ? significance.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      significance.isArray() ? significance.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, significance, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let significanceObject = significanceArray.get(rowIndex, columnIndex);
      let _numberObject = numberObject;
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (significanceObject.isString()) {
        significanceObject = significanceObject.convertToNumberObjectValue();
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      const numberValue = +_numberObject.getValue();
      const significanceValue = +significanceObject.getValue();
      if (numberValue > 0 && significanceValue < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (numberValue === 0) {
        return NumberValueObject.create(0);
      }
      if (significanceValue === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = floor2(numberValue / significanceValue, 0) * significanceValue;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/floor-math/index.ts
var FloorMath = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 3);
  }
  calculate(number, significance, mode) {
    const _significance = significance != null ? significance : NumberValueObject.create(1);
    const _mode = mode != null ? mode : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _significance.isArray() ? _significance.getRowCount() : 1,
      _mode.isArray() ? _mode.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _significance.isArray() ? _significance.getColumnCount() : 1,
      _mode.isArray() ? _mode.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, _significance, ErrorValueObject.create("#N/A" /* NA */));
    const modeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _mode, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let _numberObject = numberObject;
      let significanceObject = significanceArray.get(rowIndex, columnIndex);
      let modeObject = modeArray.get(rowIndex, columnIndex);
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (significanceObject.isString()) {
        significanceObject = significanceObject.convertToNumberObjectValue();
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      if (modeObject.isString()) {
        modeObject = modeObject.convertToNumberObjectValue();
      }
      if (modeObject.isError()) {
        return modeObject;
      }
      const numberValue = +_numberObject.getValue();
      const significanceValue = +significanceObject.getValue();
      const modeValue = +modeObject.getValue();
      if (numberValue === 0 || significanceValue === 0) {
        return NumberValueObject.create(0);
      }
      let result;
      if (numberValue < 0 && modeValue !== 0) {
        result = (significanceValue < 0 ? floor2(Math.abs(numberValue) / Math.abs(significanceValue), 0) : -floor2(Math.abs(numberValue) / significanceValue, 0)) * significanceValue;
      } else {
        result = (significanceValue < 0 ? -floor2(numberValue / Math.abs(significanceValue), 0) : floor2(numberValue / significanceValue, 0)) * significanceValue;
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/floor-precise/index.ts
var FloorPrecise = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, significance) {
    const _significance = significance != null ? significance : NumberValueObject.create(1);
    if (number.isError()) {
      return number;
    }
    if (_significance.isError()) {
      return _significance;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _significance.isArray() ? _significance.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _significance.isArray() ? _significance.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, _significance, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let significanceObject = significanceArray.get(rowIndex, columnIndex);
      let _numberObject = numberObject;
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (significanceObject.isString()) {
        significanceObject = significanceObject.convertToNumberObjectValue();
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      const numberValue = +_numberObject.getValue();
      const significanceValue = +significanceObject.getValue();
      if (numberValue === 0 || significanceValue === 0) {
        return NumberValueObject.create(0);
      }
      const result = (significanceValue < 0 ? -floor2(numberValue / Math.abs(significanceValue), 0) : floor2(numberValue / significanceValue, 0)) * significanceValue;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/gcd/index.ts
var Gcd = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let result = 0;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isNull()) {
        continue;
      }
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((valueObject) => {
          if (valueObject == null ? void 0 : valueObject.isNull()) {
            return true;
          }
          const { isError: _isError, errorObject: _errorObject, number } = this._handleSingleObject(valueObject);
          if (_isError) {
            isError = true;
            errorObject = _errorObject;
            return false;
          }
          result = calculateGcd(result, number);
        });
        if (isError) {
          return errorObject;
        }
      } else {
        const { isError, errorObject, number } = this._handleSingleObject(variant);
        if (isError) {
          return errorObject;
        }
        result = calculateGcd(result, number);
      }
    }
    return NumberValueObject.create(result);
  }
  _handleSingleObject(number) {
    if (number.isBoolean()) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
        number: null
      };
    }
    let _number = number;
    if (number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return {
        isError: true,
        errorObject: _number,
        number: null
      };
    }
    const numberValue = Math.floor(+_number.getValue());
    if (numberValue < 0 || numberValue >= 2 ** 53) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#NUM!" /* NUM */),
        number: null
      };
    }
    return {
      isError: false,
      errorObject: null,
      number: numberValue
    };
  }
};

// ../packages/engine-formula/src/functions/math/int/index.ts
var Int = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      return number.mapValue((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    const numberValue = Math.floor(+_number.getValue());
    return NumberValueObject.create(numberValue);
  }
};

// ../packages/engine-formula/src/functions/math/lcm/index.ts
var Lcm = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let result = 1;
    let noCalculate = true;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isNull()) {
        continue;
      }
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((valueObject) => {
          if (valueObject == null ? void 0 : valueObject.isNull()) {
            return true;
          }
          const { isError: _isError, errorObject: _errorObject, number } = this._handleSingleObject(valueObject);
          if (_isError) {
            isError = true;
            errorObject = _errorObject;
            return false;
          }
          result = calculateLcm(result, number);
          noCalculate = false;
        });
        if (isError) {
          return errorObject;
        }
      } else {
        const { isError, errorObject, number } = this._handleSingleObject(variant);
        if (isError) {
          return errorObject;
        }
        result = calculateLcm(result, number);
        noCalculate = false;
      }
    }
    if (noCalculate) {
      return NumberValueObject.create(0);
    }
    if (Number.isNaN(result) || !Number.isFinite(result) || result >= 2 ** 53) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return NumberValueObject.create(result);
  }
  _handleSingleObject(number) {
    if (number.isBoolean()) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
        number: null
      };
    }
    let _number = number;
    if (number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return {
        isError: true,
        errorObject: _number,
        number: null
      };
    }
    const numberValue = Math.floor(+_number.getValue());
    if (numberValue < 0) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#NUM!" /* NUM */),
        number: null
      };
    }
    return {
      isError: false,
      errorObject: null,
      number: numberValue
    };
  }
};

// ../packages/engine-formula/src/functions/math/ln/index.ts
var Ln = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.log();
  }
};

// ../packages/engine-formula/src/functions/math/log/index.ts
var Log = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, base) {
    const _base = base != null ? base : NumberValueObject.create(10);
    if (number.isError()) {
      return number;
    }
    if (_base.isError()) {
      return _base;
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _base.isArray() ? _base.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _base.isArray() ? _base.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const baseArray = expandArrayValueObject(maxRowLength, maxColumnLength, _base, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let baseObject = baseArray.get(rowIndex, columnIndex);
      let _numberObject = numberObject;
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (baseObject.isString()) {
        baseObject = baseObject.convertToNumberObjectValue();
      }
      if (baseObject.isError()) {
        return baseObject;
      }
      const numberValue = +_numberObject.getValue();
      const baseValue = +baseObject.getValue();
      if (numberValue <= 0 || baseValue <= 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const baseLog = Math.log(baseValue);
      if (baseLog === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = Math.log(numberValue) / baseLog;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/log10/index.ts
var Log10 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.log10();
  }
};

// ../packages/engine-formula/src/functions/math/mdeterm/index.ts
var Mdeterm = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(array) {
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const matrix = [];
    for (let r = 0; r < arrayRowCount; r++) {
      const row = [];
      for (let c = 0; c < arrayColumnCount; c++) {
        let valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        if (valueObject.isString()) {
          valueObject = valueObject.convertToNumberObjectValue();
        }
        if (valueObject.isError()) {
          return valueObject;
        }
        const value = +valueObject.getValue();
        row.push(value);
      }
      matrix.push(row);
    }
    if (arrayRowCount !== arrayColumnCount) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = calculateMdeterm(matrix);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/minverse/index.ts
var Minverse = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(array) {
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    const matrix = [];
    for (let r = 0; r < arrayRowCount; r++) {
      const row = [];
      for (let c = 0; c < arrayColumnCount; c++) {
        let valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        if (valueObject.isString()) {
          valueObject = valueObject.convertToNumberObjectValue();
        }
        if (valueObject.isError()) {
          return valueObject;
        }
        const value = +valueObject.getValue();
        row.push(value);
      }
      matrix.push(row);
    }
    if (arrayRowCount !== arrayColumnCount) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = calculateMinverse(matrix);
    if (result === null) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return ArrayValueObject.createByArray(result);
  }
};

// ../packages/engine-formula/src/functions/math/mmult/index.ts
var Mmult = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array1, array2) {
    const array1RowCount = array1.isArray() ? array1.getRowCount() : 1;
    const array1ColumnCount = array1.isArray() ? array1.getColumnCount() : 1;
    const array2RowCount = array2.isArray() ? array2.getRowCount() : 1;
    const array2ColumnCount = array2.isArray() ? array2.getColumnCount() : 1;
    if (array1ColumnCount !== array2RowCount) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const matrix1 = this._getMatrix(array1, array1RowCount, array1ColumnCount);
    const matrix2 = this._getMatrix(array2, array2RowCount, array2ColumnCount);
    if (matrix1 instanceof ErrorValueObject) {
      return matrix1;
    }
    if (matrix2 instanceof ErrorValueObject) {
      return matrix2;
    }
    const result = calculateMmult(matrix1, matrix2);
    return ArrayValueObject.createByArray(result);
  }
  _getMatrix(array, rowCount, columnCount) {
    const matrix = [];
    for (let r = 0; r < rowCount; r++) {
      const row = [];
      for (let c = 0; c < columnCount; c++) {
        let valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        if (valueObject.isString()) {
          valueObject = valueObject.convertToNumberObjectValue();
        }
        if (valueObject.isError()) {
          return valueObject;
        }
        const value = +valueObject.getValue();
        row.push(value);
      }
      matrix.push(row);
    }
    return matrix;
  }
};

// ../packages/engine-formula/src/functions/math/mod/index.ts
var Mod = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, divisor) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    let _divisor = divisor;
    if (_divisor.isString()) {
      _divisor = _divisor.convertToNumberObjectValue();
    }
    if (_divisor.isError()) {
      return _divisor;
    }
    return _number.mod(_divisor);
  }
};

// ../packages/engine-formula/src/functions/math/mround/index.ts
var Mround = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, multiple) {
    let _number = number;
    if (_number.isArray()) {
      const rowCount = _number.getRowCount();
      const columnCount = _number.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _number = _number.get(0, 0);
    }
    if (_number.isError()) {
      return _number;
    }
    let _multiple = multiple;
    if (_multiple.isArray()) {
      const rowCount = _multiple.getRowCount();
      const columnCount = _multiple.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _multiple = _multiple.get(0, 0);
    }
    if (_multiple.isError()) {
      return _multiple;
    }
    if (_number.isBoolean() || _multiple.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const numberValue = +_number.getValue();
    const multipleValue = +_multiple.getValue();
    if (Number.isNaN(numberValue) || Number.isNaN(multipleValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (multipleValue === 0) {
      return NumberValueObject.create(0);
    }
    if (numberValue > 0 && multipleValue < 0 || numberValue < 0 && multipleValue > 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = round2(numberValue / multipleValue, 0) * multipleValue;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/multinomial/index.ts
var Multinomial = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let sum2 = 0;
    let den = 1;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isNull()) {
        continue;
      }
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((valueObject) => {
          if (valueObject == null ? void 0 : valueObject.isNull()) {
            return true;
          }
          const { isError: _isError, errorObject: _errorObject, number } = this._handleSingleObject(valueObject);
          if (_isError) {
            isError = true;
            errorObject = _errorObject;
            return false;
          }
          sum2 += number;
          if (sum2 > 170) {
            isError = true;
            errorObject = ErrorValueObject.create("#NUM!" /* NUM */);
            return false;
          }
          den *= calculateFactorial(number);
        });
        if (isError) {
          return errorObject;
        }
      } else {
        const { isError, errorObject, number } = this._handleSingleObject(variant);
        if (isError) {
          return errorObject;
        }
        sum2 += number;
        if (sum2 > 170) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        den *= calculateFactorial(number);
      }
    }
    const result = calculateFactorial(sum2) / den;
    return NumberValueObject.create(result);
  }
  _handleSingleObject(number) {
    if (number.isBoolean()) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
        number: null
      };
    }
    let _number = number;
    if (number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return {
        isError: true,
        errorObject: _number,
        number: null
      };
    }
    const numberValue = Math.floor(+_number.getValue());
    if (numberValue < 0) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#NUM!" /* NUM */),
        number: null
      };
    }
    return {
      isError: false,
      errorObject: null,
      number: numberValue
    };
  }
};

// ../packages/engine-formula/src/functions/math/munit/index.ts
var Munit = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(dimension) {
    if (dimension.isArray()) {
      const rowCount = dimension.getRowCount();
      const columnCount = dimension.getColumnCount();
      const resultArray = dimension.mapValue((dimensionObject) => {
        const result = this._handleSingleObject(dimensionObject);
        if (result.isError()) {
          return result;
        }
        if (rowCount > 1 || columnCount > 1) {
          return result.get(0, 0);
        }
        return result;
      });
      if (rowCount === 1 && columnCount === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(dimension);
  }
  _handleSingleObject(dimension) {
    let _dimension = dimension;
    if (_dimension.isString()) {
      _dimension = _dimension.convertToNumberObjectValue();
    }
    if (_dimension.isError()) {
      return _dimension;
    }
    const dimensionValue = Math.floor(+_dimension.getValue());
    if (dimensionValue <= 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = [];
    for (let r = 0; r < dimensionValue; r++) {
      result[r] = [];
      for (let c = 0; c < dimensionValue; c++) {
        result[r][c] = r === c ? 1 : 0;
      }
    }
    return ArrayValueObject.createByArray(result);
  }
};

// ../packages/engine-formula/src/functions/math/odd/index.ts
var Odd = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      return number.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (!Number.isFinite(numberValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let result = numberValue < 0 ? -ceil2(Math.abs(numberValue), 0) : ceil2(numberValue, 0);
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (Math.abs(result) % 2 === 0) {
      numberValue < 0 ? result-- : result++;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/pi/index.ts
var Pi = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
  }
  calculate() {
    return NumberValueObject.create(Math.PI);
  }
};

// ../packages/engine-formula/src/functions/math/power/index.ts
var Power = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, power) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    let _power = power;
    if (_power.isString()) {
      _power = _power.convertToNumberObjectValue();
    }
    if (_power.isError()) {
      return _power;
    }
    return _number.pow(_power);
  }
};

// ../packages/engine-formula/src/functions/math/product/index.ts
var Product = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(1);
    let noCalculate = true;
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        let isError = false;
        let errorObject = null;
        variant.iterator((valueObject) => {
          if (valueObject == null ? void 0 : valueObject.isError()) {
            isError = true;
            errorObject = valueObject;
            return false;
          }
          if (!valueObject || valueObject.isNull() || valueObject.isString() || valueObject.isBoolean()) {
            return true;
          }
          accumulatorAll = accumulatorAll.multiply(valueObject);
          noCalculate = false;
        });
        if (isError) {
          return errorObject;
        }
      } else {
        if (variant.isNull()) {
          continue;
        }
        if (variant.isString()) {
          variant = variant.convertToNumberObjectValue();
        }
        if (variant.isError()) {
          return variant;
        }
        accumulatorAll = accumulatorAll.multiply(variant);
        noCalculate = false;
      }
      if (accumulatorAll.isError()) {
        return accumulatorAll;
      }
    }
    if (noCalculate) {
      return NumberValueObject.create(0);
    }
    return accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/math/quotient/index.ts
var Quotient = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(numerator, denominator) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(numerator, denominator);
    if (isError) {
      return errorObject;
    }
    const [numeratorObject, denominatorObject] = variants;
    const numeratorValue = +numeratorObject.getValue();
    const denominatorValue = +denominatorObject.getValue();
    if (Number.isNaN(numeratorValue) || Number.isNaN(denominatorValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (denominatorValue === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = Math.trunc(numeratorValue / denominatorValue);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/radians/index.ts
var Radians = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(angle) {
    if (angle.isArray()) {
      return angle.map((angleObject) => this._handleSingleObject(angleObject));
    }
    return this._handleSingleObject(angle);
  }
  _handleSingleObject(angle) {
    let angleObject = angle;
    if (angleObject.isString()) {
      angleObject = angleObject.convertToNumberObjectValue();
    }
    if (angleObject.isError()) {
      return angleObject;
    }
    const angleValue = +angleObject.getValue();
    if (!Number.isFinite(angleValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = angleValue * (Math.PI / 180);
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/rand/index.ts
var Rand = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 0);
  }
  calculate() {
    return NumberValueObject.create(Math.random());
  }
};

// ../packages/engine-formula/src/functions/math/randarray/index.ts
var Randarray = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 0);
    __publicField(this, "maxParams", 5);
    __publicField(this, "needsSheetRowColumnCount", true);
  }
  calculate(rows, columns, min2, max2, wholeNumber) {
    if (rows == null ? void 0 : rows.isError()) {
      return rows;
    }
    if (columns == null ? void 0 : columns.isError()) {
      return columns;
    }
    if (min2 == null ? void 0 : min2.isError()) {
      return min2;
    }
    if (max2 == null ? void 0 : max2.isError()) {
      return max2;
    }
    if (wholeNumber == null ? void 0 : wholeNumber.isError()) {
      return wholeNumber;
    }
    const _rows = rows != null ? rows : NumberValueObject.create(1);
    const _columns = columns != null ? columns : NumberValueObject.create(1);
    const _min = min2 != null ? min2 : NumberValueObject.create(0);
    const _max = max2 != null ? max2 : NumberValueObject.create(1);
    const _wholeNumber = wholeNumber != null ? wholeNumber : NumberValueObject.create(0);
    return this._calculateResult(_rows, _columns, _min, _max, _wholeNumber);
  }
  _calculateResult(rows, columns, min2, max2, wholeNumber) {
    const maxRowLength = Math.max(
      rows.isArray() ? rows.getRowCount() : 1,
      columns.isArray() ? columns.getRowCount() : 1,
      min2.isArray() ? min2.getRowCount() : 1,
      max2.isArray() ? max2.getRowCount() : 1,
      wholeNumber.isArray() ? wholeNumber.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      rows.isArray() ? rows.getColumnCount() : 1,
      columns.isArray() ? columns.getColumnCount() : 1,
      min2.isArray() ? min2.getColumnCount() : 1,
      max2.isArray() ? max2.getColumnCount() : 1,
      wholeNumber.isArray() ? wholeNumber.getColumnCount() : 1
    );
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return this._calculateSingleCell(rows, columns, min2, max2, wholeNumber);
    }
    const rowsArray = expandArrayValueObject(maxRowLength, maxColumnLength, rows, ErrorValueObject.create("#N/A" /* NA */));
    const columnsArray = expandArrayValueObject(maxRowLength, maxColumnLength, columns, ErrorValueObject.create("#N/A" /* NA */));
    const minArray = expandArrayValueObject(maxRowLength, maxColumnLength, min2, ErrorValueObject.create("#N/A" /* NA */));
    const maxArray = expandArrayValueObject(maxRowLength, maxColumnLength, max2, ErrorValueObject.create("#N/A" /* NA */));
    const wholeNumberArray = expandArrayValueObject(maxRowLength, maxColumnLength, wholeNumber, ErrorValueObject.create("#N/A" /* NA */));
    return rowsArray.map((rowsObject, rowIndex, columnIndex) => {
      const columnsObject = columnsArray.get(rowIndex, columnIndex);
      const minObject = minArray.get(rowIndex, columnIndex);
      const maxObject = maxArray.get(rowIndex, columnIndex);
      const wholeNumberObject = wholeNumberArray.get(rowIndex, columnIndex);
      const _handleError = this._handleError(rowsObject, columnsObject, minObject, maxObject, wholeNumberObject);
      if (_handleError.errorObject) {
        return _handleError.errorObject;
      }
      let { minValue, maxValue, wholeNumberValue } = _handleError;
      let result;
      if (!wholeNumberValue) {
        result = Math.random() * (maxValue - minValue) + minValue;
      } else {
        minValue = Math.ceil(minValue);
        maxValue = Math.floor(maxValue);
        result = Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue;
      }
      if (result < minValue || result > maxValue) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return NumberValueObject.create(result);
    });
  }
  _calculateSingleCell(rows, columns, min2, max2, wholeNumber) {
    let _rows = rows;
    if (_rows.isArray()) {
      _rows = _rows.get(0, 0);
    }
    let _columns = columns;
    if (_columns.isArray()) {
      _columns = _columns.get(0, 0);
    }
    let _min = min2;
    if (_min.isArray()) {
      _min = _min.get(0, 0);
    }
    let _max = max2;
    if (_max.isArray()) {
      _max = _max.get(0, 0);
    }
    let _wholeNumber = wholeNumber;
    if (_wholeNumber.isArray()) {
      _wholeNumber = _wholeNumber.get(0, 0);
    }
    const _handleError = this._handleError(_rows, _columns, _min, _max, _wholeNumber);
    if (_handleError.errorObject) {
      return _handleError.errorObject;
    }
    let { rowsValue, columnsValue, minValue, maxValue, wholeNumberValue } = _handleError;
    if (wholeNumberValue) {
      minValue = Math.ceil(minValue);
      maxValue = Math.floor(maxValue);
      if (minValue > maxValue) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    const result = [];
    for (let r = 0; r < rowsValue; r++) {
      const row = [];
      for (let c = 0; c < columnsValue; c++) {
        if (wholeNumberValue) {
          row.push(Math.floor(Math.random() * (maxValue - minValue + 1)) + minValue);
        } else {
          row.push(Math.random() * (maxValue - minValue) + minValue);
        }
      }
      result.push(row);
    }
    if (rowsValue === 1 && columnsValue === 1) {
      return NumberValueObject.create(result[0][0]);
    }
    return ArrayValueObject.createByArray(result);
  }
  _handleError(rowsObject, columnsObject, minObject, maxObject, wholeNumberObject) {
    let _rowsObject = rowsObject;
    if (_rowsObject.isString()) {
      _rowsObject = _rowsObject.convertToNumberObjectValue();
    }
    if (_rowsObject.isError()) {
      return {
        errorObject: _rowsObject
      };
    }
    let _columnsObject = columnsObject;
    if (_columnsObject.isString()) {
      _columnsObject = _columnsObject.convertToNumberObjectValue();
    }
    if (_columnsObject.isError()) {
      return {
        errorObject: _columnsObject
      };
    }
    let _minObject = minObject;
    if (_minObject.isString()) {
      _minObject = _minObject.convertToNumberObjectValue();
    }
    if (_minObject.isError()) {
      return {
        errorObject: _minObject
      };
    }
    let _maxObject = maxObject;
    if (_maxObject.isString()) {
      _maxObject = _maxObject.convertToNumberObjectValue();
    }
    if (_maxObject.isError()) {
      return {
        errorObject: _maxObject
      };
    }
    let _wholeNumberObject = wholeNumberObject;
    if (_wholeNumberObject.isString()) {
      _wholeNumberObject = _wholeNumberObject.convertToNumberObjectValue();
    }
    if (_wholeNumberObject.isError()) {
      return {
        errorObject: _wholeNumberObject
      };
    }
    return this._getValue(_rowsObject, _columnsObject, _minObject, _maxObject, _wholeNumberObject);
  }
  _getValue(rowsObject, columnsObject, minObject, maxObject, wholeNumberObject) {
    const rowsValue = Math.floor(+rowsObject.getValue());
    const columnsValue = Math.floor(+columnsObject.getValue());
    if (rowsValue === 0 || columnsValue === 0) {
      return {
        errorObject: ErrorValueObject.create("#CALC!" /* CALC */)
      };
    }
    const maxRows = this._rowCount - this.row;
    const maxColumns = this._columnCount - this.column;
    if (rowsValue < 0 || columnsValue < 0 || rowsValue * columnsValue > 10 ** 7) {
      return {
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    if (rowsValue > maxRows || columnsValue > maxColumns) {
      return {
        errorObject: ErrorValueObject.create("#REF!" /* REF */)
      };
    }
    const minValue = +minObject.getValue();
    const maxValue = +maxObject.getValue();
    const wholeNumberValue = +wholeNumberObject.getValue();
    if (minValue > maxValue) {
      return {
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    if (wholeNumberValue && (!Number.isInteger(minValue) || !Number.isInteger(maxValue))) {
      return {
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */)
      };
    }
    return {
      rowsValue,
      columnsValue,
      minValue,
      maxValue,
      wholeNumberValue
    };
  }
};

// ../packages/engine-formula/src/functions/math/randbetween/index.ts
var Randbetween = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(bottom, top) {
    let _bottom = bottom;
    if (_bottom.isArray()) {
      const rowCount = _bottom.getRowCount();
      const columnCount = _bottom.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _bottom = _bottom.get(0, 0);
    }
    if (_bottom.isError()) {
      return _bottom;
    }
    let _top = top;
    if (_top.isArray()) {
      const rowCount = _top.getRowCount();
      const columnCount = _top.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _top = _top.get(0, 0);
    }
    if (_top.isError()) {
      return _top;
    }
    if (_bottom.isBoolean() || _top.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let bottomValue = +_bottom.getValue();
    let topValue = +_top.getValue();
    if (Number.isNaN(bottomValue) || Number.isNaN(topValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (bottomValue > topValue) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    bottomValue = Math.ceil(bottomValue);
    topValue = Math.floor(topValue);
    const result = Math.floor(Math.random() * (topValue - bottomValue + 1)) + bottomValue;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/roman/index.ts
var Roman = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, form) {
    const _form = form != null ? form : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _form.isArray() ? _form.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _form.isArray() ? _form.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const formArray = expandArrayValueObject(maxRowLength, maxColumnLength, _form, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      const formObject = formArray.get(rowIndex, columnIndex);
      if (numberObject.isError()) {
        return numberObject;
      }
      if (formObject.isError()) {
        return formObject;
      }
      return this._handleSingleObject(numberObject, formObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(number, form) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    let numberValue = Math.floor(+numberObject.getValue());
    let _form = form;
    if (_form.isString()) {
      _form = _form.convertToNumberObjectValue();
      if (_form.isError()) {
        return _form;
      }
    }
    let formValue = Math.floor(+_form.getValue());
    if (_form.isBoolean()) {
      formValue = _form.getValue() ? 0 : 4;
    }
    if (numberValue < 0 || numberValue > 3999 || formValue < 0 || formValue > 4) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const formArray = romanFormArray[formValue];
    let index = formArray.length - 1;
    let result = "";
    while (numberValue > 0) {
      index = this._binarySearch(numberValue, 0, index, formArray);
      const number2 = formArray[index];
      numberValue -= number2;
      result += arabicToRomanMap.get(number2);
    }
    return StringValueObject.create(result);
  }
  _binarySearch(target, left, right, array) {
    let _left = left;
    let _right = right;
    while (_right - _left > 1) {
      const mid = Math.floor((_left + _right) / 2);
      const midValue = array[mid];
      if (midValue === target) {
        return mid;
      }
      if (midValue > target) {
        _right = mid;
      } else {
        _left = mid;
      }
    }
    return _left !== _right && array[_right] <= target ? _right : _left;
  }
};

// ../packages/engine-formula/src/functions/math/round/index.ts
var Round = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numDigits) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    let _numDigits = numDigits;
    if (_numDigits.isString()) {
      _numDigits = _numDigits.convertToNumberObjectValue();
    }
    if (_numDigits.isError()) {
      return _numDigits;
    }
    return _number.round(_numDigits);
  }
};

// ../packages/engine-formula/src/functions/math/roundbank/index.ts
var Roundbank = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numDigits) {
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      numDigits.isArray() ? numDigits.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      numDigits.isArray() ? numDigits.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const numDigitsArray = expandArrayValueObject(maxRowLength, maxColumnLength, numDigits, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      const numDigitsObject = numDigitsArray.get(rowIndex, columnIndex);
      if (numberObject.isError()) {
        return numberObject;
      }
      if (numDigitsObject.isError()) {
        return numDigitsObject;
      }
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numberObject, numDigitsObject);
      if (isError) {
        return errorObject;
      }
      const [_numberObject, _numDigitsObject] = variants;
      const numberValue = +_numberObject.getValue();
      const numDigitsValue = Math.trunc(+_numDigitsObject.getValue());
      const result = this._roundBank(numberValue, numDigitsValue);
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _roundBank(number, numDigits) {
    if (numDigits > 16) {
      return number;
    }
    if (numDigits < -16) {
      return 0;
    }
    const EPSILON = 1e-8;
    const multiplier = 10 ** numDigits;
    const adjustedNum = +(number * multiplier).toFixed(8);
    const integerPart = Math.floor(adjustedNum);
    const decimalPart = adjustedNum - integerPart;
    let result = Math.round(adjustedNum);
    if (decimalPart > 0.5 - EPSILON && decimalPart < 0.5 + EPSILON) {
      result = integerPart % 2 === 0 ? integerPart : integerPart + 1;
    }
    return numDigits ? result / multiplier : result;
  }
};

// ../packages/engine-formula/src/functions/math/rounddown/index.ts
var Rounddown = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numDigits) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    let _numDigits = numDigits;
    if (_numDigits.isString()) {
      _numDigits = _numDigits.convertToNumberObjectValue();
    }
    if (_numDigits.isError()) {
      return _numDigits;
    }
    return _number.floor(_numDigits);
  }
};

// ../packages/engine-formula/src/functions/math/roundup/index.ts
var Roundup = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numDigits) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    let _numDigits = numDigits;
    if (_numDigits.isString()) {
      _numDigits = _numDigits.convertToNumberObjectValue();
    }
    if (_numDigits.isError()) {
      return _numDigits;
    }
    return _number.ceil(_numDigits);
  }
};

// ../packages/engine-formula/src/functions/math/sec/index.ts
var Sec = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      return number.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (Math.abs(numberValue) >= 2 ** 27) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return numberObject.cos().getReciprocal();
  }
};

// ../packages/engine-formula/src/functions/math/sech/index.ts
var Sech = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      return number.map((numberObject) => this._handleSingleObject(numberObject));
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    let numberObject = number;
    if (numberObject.isString()) {
      numberObject = numberObject.convertToNumberObjectValue();
    }
    if (numberObject.isError()) {
      return numberObject;
    }
    const numberValue = +numberObject.getValue();
    if (!Number.isFinite(Math.cosh(numberValue))) {
      return NumberValueObject.create(0);
    }
    if (Math.abs(numberValue) >= 2 ** 27) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return numberObject.cosh().getReciprocal();
  }
};

// ../packages/engine-formula/src/functions/math/sequence/index.ts
var Sequence = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 4);
    __publicField(this, "needsSheetRowColumnCount", true);
  }
  calculate(rows, columns, start, step) {
    let _rows = rows;
    let _columns = columns != null ? columns : NumberValueObject.create(1);
    let _start = start != null ? start : NumberValueObject.create(1);
    let _step = step != null ? step : NumberValueObject.create(1);
    if (_rows.isNull()) {
      _rows = NumberValueObject.create(1);
    }
    if (_columns.isNull()) {
      _columns = NumberValueObject.create(1);
    }
    if (_start.isNull()) {
      _start = NumberValueObject.create(1);
    }
    if (_step.isNull()) {
      _step = NumberValueObject.create(1);
    }
    const maxRowLength = Math.max(
      _rows.isArray() ? _rows.getRowCount() : 1,
      _columns.isArray() ? _columns.getRowCount() : 1,
      _start.isArray() ? _start.getRowCount() : 1,
      _step.isArray() ? _step.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _rows.isArray() ? _rows.getColumnCount() : 1,
      _columns.isArray() ? _columns.getColumnCount() : 1,
      _start.isArray() ? _start.getColumnCount() : 1,
      _step.isArray() ? _step.getColumnCount() : 1
    );
    const rowsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _rows, ErrorValueObject.create("#N/A" /* NA */));
    const columnsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _columns, ErrorValueObject.create("#N/A" /* NA */));
    const startArray = expandArrayValueObject(maxRowLength, maxColumnLength, _start, ErrorValueObject.create("#N/A" /* NA */));
    const stepArray = expandArrayValueObject(maxRowLength, maxColumnLength, _step, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = rowsArray.mapValue((rowsObject, rowIndex, columnIndex) => {
      const columnsObject = columnsArray.get(rowIndex, columnIndex);
      const startObject = startArray.get(rowIndex, columnIndex);
      const stepObject = stepArray.get(rowIndex, columnIndex);
      if (rowsObject.isError()) {
        return rowsObject;
      }
      if (columnsObject.isError()) {
        return columnsObject;
      }
      if (startObject.isError()) {
        return startObject;
      }
      if (stepObject.isError()) {
        return stepObject;
      }
      return this._getResult(rowsObject, columnsObject, startObject, stepObject, maxRowLength, maxColumnLength);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResult(rowsObject, columnsObject, startObject, stepObject, maxRowLength, maxColumnLength) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(rowsObject, columnsObject, startObject, stepObject);
    if (isError) {
      return errorObject;
    }
    const [_rowsObject, _columnsObject, _startObject, _stepObject] = variants;
    const rowsValue = Math.floor(+_rowsObject.getValue());
    const columnsValue = Math.floor(+_columnsObject.getValue());
    const startValue = +_startObject.getValue();
    const stepValue = +_stepObject.getValue();
    if (rowsValue < 0 || columnsValue < 0 || rowsValue * columnsValue > 10 ** 7) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (rowsValue === 0 || columnsValue === 0) {
      return ErrorValueObject.create("#CALC!" /* CALC */);
    }
    const maxRows = this._rowCount - this.row;
    const maxColumns = this._columnCount - this.column;
    if (rowsValue > maxRows || columnsValue > maxColumns) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const result = [];
    for (let r = 0; r < rowsValue; r++) {
      result[r] = [];
      for (let c = 0; c < columnsValue; c++) {
        result[r][c] = startValue + (r * columnsValue + c) * stepValue;
      }
    }
    if (maxRowLength > 1 || maxColumnLength > 1) {
      return NumberValueObject.create(result[0][0]);
    }
    return ArrayValueObject.createByArray(result);
  }
};

// ../packages/engine-formula/src/functions/math/seriessum/index.ts
var Seriessum = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(x, n, m, coefficients) {
    if (x.isNull() || n.isNull() || m.isNull() || coefficients.isNull()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsArrayOrBoolean(x, n, m);
    if (isError) {
      return errorObject;
    }
    const { isError: isError2, errorObject: errorObject2, variants: variants2 } = checkVariantsErrorIsStringToNumber(...variants);
    if (isError2) {
      return errorObject2;
    }
    const [xObject, nObject, mObject] = variants2;
    const xValue = +xObject.getValue();
    const nValue = +nObject.getValue();
    const mValue = +mObject.getValue();
    const coefficientsArray = [];
    if (coefficients.isArray()) {
      let isError_coefficients = false;
      let errorObject_coefficients = ErrorValueObject.create("#VALUE!" /* VALUE */);
      coefficients.iterator((coefficientsObject) => {
        const { isError: _isError, errorObject: _errorObject, coefficientsObject: _coefficientsObject } = this._handleSingleObject(coefficientsObject);
        if (_isError) {
          isError_coefficients = true;
          errorObject_coefficients = _errorObject;
          return false;
        }
        const coefficientsValue = +_coefficientsObject.getValue();
        coefficientsArray.push(coefficientsValue);
      });
      if (isError_coefficients) {
        return errorObject_coefficients;
      }
    } else {
      const { isError: _isError, errorObject: _errorObject, coefficientsObject: _coefficientsObject } = this._handleSingleObject(coefficients);
      if (_isError) {
        return _errorObject;
      }
      const coefficientsValue = +_coefficientsObject.getValue();
      coefficientsArray.push(coefficientsValue);
    }
    let result = 0;
    for (let i = 0; i < coefficientsArray.length; i++) {
      result += coefficientsArray[i] * xValue ** (nValue + i * mValue);
    }
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
  _handleSingleObject(coefficientsObject) {
    if (coefficientsObject.isError()) {
      return {
        isError: true,
        errorObject: coefficientsObject,
        coefficientsObject: null
      };
    }
    if (coefficientsObject == null ? void 0 : coefficientsObject.isBoolean()) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
        coefficientsObject: null
      };
    }
    let _coefficientsObject = coefficientsObject;
    if (_coefficientsObject.isString()) {
      _coefficientsObject = _coefficientsObject.convertToNumberObjectValue();
    }
    if (_coefficientsObject.isError()) {
      return {
        isError: true,
        errorObject: _coefficientsObject,
        coefficientsObject: null
      };
    }
    return {
      isError: false,
      errorObject: null,
      coefficientsObject: _coefficientsObject
    };
  }
};

// ../packages/engine-formula/src/functions/math/sign/index.ts
var Sign = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      const resultArray = number.mapValue((numberObject) => this._handleSingleObject(numberObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    if (number.isError()) {
      return number;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = +numberObject.getValue();
    if (numberValue > 0) {
      return NumberValueObject.create(1);
    }
    if (numberValue < 0) {
      return NumberValueObject.create(-1);
    }
    return NumberValueObject.create(0);
  }
};

// ../packages/engine-formula/src/functions/math/sin/index.ts
var Sin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.sin();
  }
};

// ../packages/engine-formula/src/functions/math/sinh/index.ts
var Sinh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.sinh();
  }
};

// ../packages/engine-formula/src/functions/math/sqrt/index.ts
var Sqrt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    let _number = number;
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    return _number.sqrt();
  }
};

// ../packages/engine-formula/src/functions/math/sqrtpi/index.ts
var Sqrtpi = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    let _number = number;
    if (_number.isArray()) {
      const rowCount = _number.getRowCount();
      const columnCount = _number.getColumnCount();
      if (rowCount > 1 || columnCount > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      _number = _number.get(0, 0);
    }
    if (_number.isString()) {
      _number = _number.convertToNumberObjectValue();
    }
    if (_number.isError()) {
      return _number;
    }
    const numberValue = +_number.getValue();
    if (numberValue < 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.sqrt(numberValue * Math.PI);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/subtotal/index.ts
var Subtotal = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
    __publicField(this, "needsReferenceObject", true);
    __publicField(this, "needsFilteredOutRows", true);
  }
  calculate(functionNum, ...refs) {
    if (functionNum.isError()) {
      return functionNum;
    }
    if (functionNum.isReferenceObject()) {
      return functionNum.toArrayValueObject().mapValue((valueObject) => this._handleSingleObject(valueObject, ...refs));
    }
    return this._handleSingleObject(functionNum, ...refs);
  }
  // eslint-disable-next-line max-lines-per-function, complexity
  _handleSingleObject(functionNum, ...refs) {
    const indexNum = this._getIndexNumValue(functionNum);
    let result;
    if (indexNum instanceof ErrorValueObject) {
      return indexNum;
    }
    switch (indexNum) {
      case 1 /* AVERAGE */:
        result = this._average(false, ...refs);
        break;
      case 2 /* COUNT */:
        result = this._count(false, ...refs);
        break;
      case 3 /* COUNTA */:
        result = this._counta(false, ...refs);
        break;
      case 4 /* MAX */:
        result = this._max(false, ...refs);
        break;
      case 5 /* MIN */:
        result = this._min(false, ...refs);
        break;
      case 6 /* PRODUCT */:
        result = this._product(false, ...refs);
        break;
      case 7 /* STDEV */:
        result = this._stdev(false, ...refs);
        break;
      case 8 /* STDEVP */:
        result = this._stdevp(false, ...refs);
        break;
      case 9 /* SUM */:
        result = this._sum(false, ...refs);
        break;
      case 10 /* VAR */:
        result = this._var(false, ...refs);
        break;
      case 11 /* VARP */:
        result = this._varp(false, ...refs);
        break;
      case 101 /* AVERAGE */:
        result = this._average(true, ...refs);
        break;
      case 102 /* COUNT */:
        result = this._count(true, ...refs);
        break;
      case 103 /* COUNTA */:
        result = this._counta(true, ...refs);
        break;
      case 104 /* MAX */:
        result = this._max(true, ...refs);
        break;
      case 105 /* MIN */:
        result = this._min(true, ...refs);
        break;
      case 106 /* PRODUCT */:
        result = this._product(true, ...refs);
        break;
      case 107 /* STDEV */:
        result = this._stdev(true, ...refs);
        break;
      case 108 /* STDEVP */:
        result = this._stdevp(true, ...refs);
        break;
      case 109 /* SUM */:
        result = this._sum(true, ...refs);
        break;
      case 110 /* VAR */:
        result = this._var(true, ...refs);
        break;
      case 111 /* VARP */:
        result = this._varp(true, ...refs);
        break;
      default:
        result = ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return result;
  }
  _getIndexNumValue(indexNum) {
    const indexNumValue = indexNum ? Number(indexNum.getValue()) : 0;
    if (Number.isNaN(indexNumValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const indexNumValueInt = Math.floor(indexNumValue);
    if (indexNumValueInt >= 1 && indexNumValueInt <= 11 || indexNumValueInt >= 101 && indexNumValueInt <= 111) {
      return indexNumValueInt;
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }
  _average(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.mean();
  }
  _count(ignoreHidden, ...refs) {
    let accumulatorAll = NumberValueObject.create(0);
    for (let i = 0; i < refs.length; i++) {
      const variant = refs[i];
      if (!variant.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const filteredOutRows = variant.getFilteredOutRows();
      const rowData = variant.getRowData();
      variant.iterator((valueObject, rowIndex) => {
        if (filteredOutRows.includes(rowIndex)) {
          return true;
        }
        if (ignoreHidden && this._isRowHidden(rowData, rowIndex)) {
          return true;
        }
        if (valueObject == null ? void 0 : valueObject.isNumber()) {
          accumulatorAll = accumulatorAll.plusBy(1);
        }
      });
    }
    return accumulatorAll;
  }
  _counta(ignoreHidden, ...refs) {
    let accumulatorAll = NumberValueObject.create(0);
    for (let i = 0; i < refs.length; i++) {
      const variant = refs[i];
      if (!variant.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const filteredOutRows = variant.getFilteredOutRows();
      const rowData = variant.getRowData();
      variant.iterator((valueObject, rowIndex) => {
        if (filteredOutRows.includes(rowIndex)) {
          return true;
        }
        if (ignoreHidden && this._isRowHidden(rowData, rowIndex)) {
          return true;
        }
        if (valueObject == null || valueObject.isNull()) {
          return true;
        }
        accumulatorAll = accumulatorAll.plusBy(1);
      });
    }
    return accumulatorAll;
  }
  _max(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    if (this._isBlankArrayObject(flattenArray)) {
      return NumberValueObject.create(0);
    }
    return flattenArray.max();
  }
  _min(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    if (this._isBlankArrayObject(flattenArray)) {
      return NumberValueObject.create(0);
    }
    return flattenArray.min();
  }
  _product(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    if (this._isBlankArrayObject(flattenArray)) {
      return NumberValueObject.create(0);
    }
    let result = NumberValueObject.create(1);
    flattenArray.iterator((valueObject) => {
      result = result.multiply(
        valueObject
      );
    });
    return result;
  }
  _stdev(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    if (this._isBlankArrayObject(flattenArray)) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return flattenArray.std(1);
  }
  _stdevp(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    if (this._isBlankArrayObject(flattenArray)) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return flattenArray.std();
  }
  _sum(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.sum();
  }
  _var(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    if (this._isBlankArrayObject(flattenArray)) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return flattenArray.var(1);
  }
  _varp(ignoreHidden, ...refs) {
    const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    if (this._isBlankArrayObject(flattenArray)) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return flattenArray.var();
  }
  _flattenRefArray(ignoreHidden, ...variants) {
    const flattenValues = [];
    flattenValues[0] = [];
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (!variant.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const filteredOutRows = variant.getFilteredOutRows();
      const rowData = variant.getRowData();
      let errorValue;
      variant.iterator((valueObject, rowIndex) => {
        if (filteredOutRows.includes(rowIndex)) {
          return true;
        }
        if (ignoreHidden && this._isRowHidden(rowData, rowIndex)) {
          return true;
        }
        if (valueObject == null || valueObject.isNull() || valueObject.isString() || valueObject.isBoolean()) {
          return true;
        }
        if (valueObject.isError()) {
          errorValue = valueObject;
          return false;
        }
        flattenValues[0].push(valueObject);
      });
      if (errorValue == null ? void 0 : errorValue.isError()) {
        return errorValue;
      }
    }
    return createNewArray(flattenValues, 1, flattenValues[0].length);
  }
  _isRowHidden(rowData, rowIndex) {
    const row = rowData[rowIndex];
    if (!row) {
      return false;
    }
    return row.hd === 1 /* TRUE */;
  }
  _isBlankArrayObject(arrayObject) {
    return arrayObject.getArrayValue()[0].length === 0;
  }
};

// ../packages/engine-formula/src/functions/math/sum/index.ts
var Sum = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(0);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        variant = variant.sum();
      }
      if (variant.isError()) {
        return variant;
      }
      accumulatorAll = accumulatorAll.plus(variant);
      if (accumulatorAll.isError()) {
        return accumulatorAll;
      }
    }
    return accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/math/sumif/index.ts
var Sumif = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(range, criteria, sumRange) {
    let _criteria = criteria;
    if (criteria.isReferenceObject()) {
      _criteria = criteria.toArrayValueObject();
    }
    if (_criteria.isArray()) {
      const resultArray = _criteria.mapValue((criteriaObject) => this._handleSingleObject(range, criteriaObject, sumRange));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(range, _criteria, sumRange);
  }
  _handleSingleObject(range, criteria, sumRange) {
    if (range.isError()) {
      return range;
    }
    if (criteria.isError()) {
      return criteria;
    }
    if (sumRange == null ? void 0 : sumRange.isError()) {
      return sumRange;
    }
    if (!range.isReferenceObject() || sumRange && !sumRange.isReferenceObject()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const _range = range.toArrayValueObject();
    let resultArrayObject = valueObjectCompare(_range, criteria);
    resultArrayObject = filterSameValueObjectResult(resultArrayObject, _range, criteria);
    const rangeRowCount = _range.getRowCount();
    const rangeColumnCount = _range.getColumnCount();
    let _sumRange = _range;
    if (sumRange) {
      _sumRange = sumRange.toArrayValueObject();
      const sumRangeRowCount = _sumRange.getRowCount();
      const sumRangeColumnCount = _sumRange.getColumnCount();
      if (rangeRowCount !== sumRangeRowCount || rangeColumnCount !== sumRangeColumnCount) {
        const rangeData = sumRange.getRangeData();
        rangeData.endRow = rangeData.startRow + rangeRowCount - 1;
        rangeData.endColumn = rangeData.startColumn + rangeColumnCount - 1;
        sumRange.setRangeData(rangeData);
        _sumRange = sumRange.toArrayValueObject();
      }
    }
    return _sumRange.pick(resultArrayObject).sum();
  }
};

// ../packages/engine-formula/src/functions/math/sumifs/index.ts
var Sumifs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 255);
  }
  calculate(sumRange, ...variants) {
    if (sumRange.isError()) {
      return sumRange;
    }
    if (!sumRange.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.length < 2 || variants.length % 2 !== 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.some((variant, i) => i % 2 === 0 && !variant.isArray())) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const { maxRowLength, maxColumnLength } = calculateMaxDimensions(variants);
    const errorArray = getErrorArray(variants, sumRange, maxRowLength, maxColumnLength);
    if (errorArray) {
      return errorArray;
    }
    const booleanResults = getBooleanResults(variants, maxRowLength, maxColumnLength, true);
    return this._aggregateResults(sumRange, booleanResults);
  }
  _aggregateResults(sumRange, booleanResults) {
    const sumResults = booleanResults.map((row) => {
      return row.map((booleanResult) => {
        return sumRange.pick(booleanResult).sum();
      });
    });
    const arrayValueObjectData = {
      calculateValueList: sumResults,
      rowCount: sumResults.length,
      columnCount: sumResults[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};

// ../packages/engine-formula/src/functions/math/sumproduct/index.ts
var Sumproduct = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(array1, ...variants) {
    if (array1.isError()) {
      return array1;
    }
    const _array1 = this._initArray1(array1);
    if (variants.length > 0) {
      const rowCount = _array1.getRowCount();
      const columnCount = _array1.getColumnCount();
      let resultArray = this._getResultArrayByArray1(rowCount, columnCount, _array1);
      if (resultArray instanceof ErrorValueObject) {
        return resultArray;
      }
      resultArray = resultArray;
      for (let i = 0; i < variants.length; i++) {
        if (variants[i].isError()) {
          return variants[i];
        }
        let variantRowCount = 1;
        let variantColumnCount = 1;
        if (variants[i].isArray()) {
          variantRowCount = variants[i].getRowCount();
          variantColumnCount = variants[i].getColumnCount();
        }
        if (variantRowCount !== rowCount || variantColumnCount !== columnCount) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        for (let r = 0; r < rowCount; r++) {
          const row = [];
          for (let c = 0; c < columnCount; c++) {
            let variantValueObject = variants[i];
            if (variants[i].isArray()) {
              variantValueObject = variants[i].get(r, c);
            }
            if (variantValueObject.isError()) {
              return variantValueObject;
            }
            const variantValue = variantValueObject.getValue();
            if (!variantValue || !isRealNum(variantValue)) {
              row.push(0);
            } else {
              row.push(+variantValue * resultArray[r][c]);
            }
          }
          resultArray[r] = row;
        }
      }
      const result = resultArray.reduce((acc, cur) => acc.concat(cur)).reduce((acc, cur) => acc + cur, 0);
      return NumberValueObject.create(result);
    } else {
      return _array1.sum();
    }
  }
  _initArray1(array1) {
    let _array1 = array1;
    if (!_array1.isArray()) {
      _array1 = ArrayValueObject.create({
        calculateValueList: [[_array1]],
        rowCount: 1,
        columnCount: 1,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      });
    }
    return _array1;
  }
  _getResultArrayByArray1(rowCount, columnCount, array1) {
    const resultArray = [];
    for (let r = 0; r < rowCount; r++) {
      const row = [];
      for (let c = 0; c < columnCount; c++) {
        const array1ValueObject = array1.get(r, c);
        if (array1ValueObject.isError()) {
          return array1ValueObject;
        }
        const array1Value = array1ValueObject.getValue();
        if (!array1Value || !isRealNum(array1Value)) {
          row.push(0);
        } else {
          row.push(+array1Value);
        }
      }
      resultArray.push(row);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/sumsq/index.ts
var Sumsq = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(0);
    const exponent = NumberValueObject.create(2);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        variant.iterator((valueObject) => {
          if (valueObject == null || valueObject.isString() || valueObject.isBoolean() || valueObject.isNull()) {
            return true;
          }
          if (valueObject.isError()) {
            accumulatorAll = valueObject;
            return false;
          }
          accumulatorAll = accumulatorAll.plus(
            valueObject.pow(exponent)
          );
        });
      } else {
        accumulatorAll = accumulatorAll.plus(variant.pow(exponent));
      }
      if (accumulatorAll.isError()) {
        return accumulatorAll;
      }
    }
    return accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/math/sumx2my2/index.ts
var Sumx2my2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(arrayX, arrayY) {
    if (arrayX.isError()) {
      return arrayX;
    }
    if (arrayY.isError()) {
      return arrayY;
    }
    const arrayXRowCount = arrayX.isArray() ? arrayX.getRowCount() : 1;
    const arrayXColumnCount = arrayX.isArray() ? arrayX.getColumnCount() : 1;
    const arrayXCount = arrayXRowCount * arrayXColumnCount;
    const arrayYRowCount = arrayY.isArray() ? arrayY.getRowCount() : 1;
    const arrayYColumnCount = arrayY.isArray() ? arrayY.getColumnCount() : 1;
    const arrayYCount = arrayYRowCount * arrayYColumnCount;
    if (arrayXCount !== arrayYCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (arrayXCount === 1) {
      return this._calculateSingleCell(arrayX, arrayY);
    } else {
      const arrayXFlatten = arrayX.flatten();
      const arrayYFlatten = arrayY.flatten();
      let errorObject = NullValueObject.create();
      const arrayXValidValue = [];
      const arrayYValidValue = [];
      let result = 0;
      arrayXFlatten.iterator((arrayXObject, rowIndex, columnIndex) => {
        const arrayYObject = arrayYFlatten.get(rowIndex, columnIndex);
        if (arrayXObject == null || arrayXObject.isString() || arrayXObject.isBoolean() || arrayXObject.isNull()) {
          return true;
        }
        if (arrayXObject == null ? void 0 : arrayXObject.isError()) {
          errorObject = arrayXObject;
          return false;
        }
        if (arrayYObject == null || arrayYObject.isString() || arrayYObject.isBoolean() || arrayYObject.isNull()) {
          return true;
        }
        if (arrayYObject == null ? void 0 : arrayYObject.isError()) {
          errorObject = arrayYObject;
          return false;
        }
        const arrayXValue = +arrayXObject.getValue();
        const arrayYValue = +arrayYObject.getValue();
        arrayXValidValue.push(arrayXValue);
        arrayYValidValue.push(arrayYValue);
        result += arrayXValue ** 2 - arrayYValue ** 2;
      });
      if (errorObject.isError()) {
        return errorObject;
      }
      if (arrayXValidValue.length === 0 || arrayYValidValue.length === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return NumberValueObject.create(result);
    }
  }
  _calculateSingleCell(arrayX, arrayY) {
    let _arrayX = arrayX;
    if (_arrayX.isArray()) {
      _arrayX = _arrayX.get(0, 0);
    }
    if (_arrayX.isError()) {
      return _arrayX;
    }
    let _arrayY = arrayY;
    if (_arrayY.isArray()) {
      _arrayY = _arrayY.get(0, 0);
    }
    if (_arrayY.isError()) {
      return _arrayY;
    }
    if (_arrayX.isNull() || _arrayY.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const arrayXValue = +_arrayX.getValue();
    const arrayYValue = +_arrayY.getValue();
    if (_arrayX.isString() && !isRealNum(arrayXValue) || _arrayX.isBoolean() || _arrayY.isString() && !isRealNum(arrayYValue) || _arrayY.isBoolean()) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = arrayXValue ** 2 - arrayYValue ** 2;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/sumx2py2/index.ts
var Sumx2py2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(arrayX, arrayY) {
    if (arrayX.isError()) {
      return arrayX;
    }
    if (arrayY.isError()) {
      return arrayY;
    }
    const arrayXRowCount = arrayX.isArray() ? arrayX.getRowCount() : 1;
    const arrayXColumnCount = arrayX.isArray() ? arrayX.getColumnCount() : 1;
    const arrayXCount = arrayXRowCount * arrayXColumnCount;
    const arrayYRowCount = arrayY.isArray() ? arrayY.getRowCount() : 1;
    const arrayYColumnCount = arrayY.isArray() ? arrayY.getColumnCount() : 1;
    const arrayYCount = arrayYRowCount * arrayYColumnCount;
    if (arrayXCount !== arrayYCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (arrayXCount === 1) {
      return this._calculateSingleCell(arrayX, arrayY);
    } else {
      const arrayXFlatten = arrayX.flatten();
      const arrayYFlatten = arrayY.flatten();
      let errorObject = NullValueObject.create();
      const arrayXValidValue = [];
      const arrayYValidValue = [];
      let result = 0;
      arrayXFlatten.iterator((arrayXObject, rowIndex, columnIndex) => {
        const arrayYObject = arrayYFlatten.get(rowIndex, columnIndex);
        if (arrayXObject == null || arrayXObject.isString() || arrayXObject.isBoolean() || arrayXObject.isNull()) {
          return true;
        }
        if (arrayXObject == null ? void 0 : arrayXObject.isError()) {
          errorObject = arrayXObject;
          return false;
        }
        if (arrayYObject == null || arrayYObject.isString() || arrayYObject.isBoolean() || arrayYObject.isNull()) {
          return true;
        }
        if (arrayYObject == null ? void 0 : arrayYObject.isError()) {
          errorObject = arrayYObject;
          return false;
        }
        const arrayXValue = +arrayXObject.getValue();
        const arrayYValue = +arrayYObject.getValue();
        arrayXValidValue.push(arrayXValue);
        arrayYValidValue.push(arrayYValue);
        result += arrayXValue ** 2 + arrayYValue ** 2;
      });
      if (errorObject.isError()) {
        return errorObject;
      }
      if (arrayXValidValue.length === 0 || arrayYValidValue.length === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return NumberValueObject.create(result);
    }
  }
  _calculateSingleCell(arrayX, arrayY) {
    let _arrayX = arrayX;
    if (_arrayX.isArray()) {
      _arrayX = _arrayX.get(0, 0);
    }
    if (_arrayX.isError()) {
      return _arrayX;
    }
    let _arrayY = arrayY;
    if (_arrayY.isArray()) {
      _arrayY = _arrayY.get(0, 0);
    }
    if (_arrayY.isError()) {
      return _arrayY;
    }
    if (_arrayX.isNull() || _arrayY.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const arrayXValue = +_arrayX.getValue();
    const arrayYValue = +_arrayY.getValue();
    if (_arrayX.isString() && !isRealNum(arrayXValue) || _arrayX.isBoolean() || _arrayY.isString() && !isRealNum(arrayYValue) || _arrayY.isBoolean()) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = arrayXValue ** 2 + arrayYValue ** 2;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/sumxmy2/index.ts
var Sumxmy2 = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(arrayX, arrayY) {
    if (arrayX.isError()) {
      return arrayX;
    }
    if (arrayY.isError()) {
      return arrayY;
    }
    const arrayXRowCount = arrayX.isArray() ? arrayX.getRowCount() : 1;
    const arrayXColumnCount = arrayX.isArray() ? arrayX.getColumnCount() : 1;
    const arrayXCount = arrayXRowCount * arrayXColumnCount;
    const arrayYRowCount = arrayY.isArray() ? arrayY.getRowCount() : 1;
    const arrayYColumnCount = arrayY.isArray() ? arrayY.getColumnCount() : 1;
    const arrayYCount = arrayYRowCount * arrayYColumnCount;
    if (arrayXCount !== arrayYCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (arrayXCount === 1) {
      return this._calculateSingleCell(arrayX, arrayY);
    } else {
      const arrayXFlatten = arrayX.flatten();
      const arrayYFlatten = arrayY.flatten();
      let errorObject = NullValueObject.create();
      const arrayXValidValue = [];
      const arrayYValidValue = [];
      let result = 0;
      arrayXFlatten.iterator((arrayXObject, rowIndex, columnIndex) => {
        const arrayYObject = arrayYFlatten.get(rowIndex, columnIndex);
        if (arrayXObject == null || arrayXObject.isString() || arrayXObject.isBoolean() || arrayXObject.isNull()) {
          return true;
        }
        if (arrayXObject == null ? void 0 : arrayXObject.isError()) {
          errorObject = arrayXObject;
          return false;
        }
        if (arrayYObject == null || arrayYObject.isString() || arrayYObject.isBoolean() || arrayYObject.isNull()) {
          return true;
        }
        if (arrayYObject == null ? void 0 : arrayYObject.isError()) {
          errorObject = arrayYObject;
          return false;
        }
        const arrayXValue = +arrayXObject.getValue();
        const arrayYValue = +arrayYObject.getValue();
        arrayXValidValue.push(arrayXValue);
        arrayYValidValue.push(arrayYValue);
        result += (arrayXValue - arrayYValue) ** 2;
      });
      if (errorObject.isError()) {
        return errorObject;
      }
      if (arrayXValidValue.length === 0 || arrayYValidValue.length === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return NumberValueObject.create(result);
    }
  }
  _calculateSingleCell(arrayX, arrayY) {
    let _arrayX = arrayX;
    if (_arrayX.isArray()) {
      _arrayX = _arrayX.get(0, 0);
    }
    if (_arrayX.isError()) {
      return _arrayX;
    }
    let _arrayY = arrayY;
    if (_arrayY.isArray()) {
      _arrayY = _arrayY.get(0, 0);
    }
    if (_arrayY.isError()) {
      return _arrayY;
    }
    if (_arrayX.isNull() || _arrayY.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const arrayXValue = +_arrayX.getValue();
    const arrayYValue = +_arrayY.getValue();
    if (_arrayX.isString() && !isRealNum(arrayXValue) || _arrayX.isBoolean() || _arrayY.isString() && !isRealNum(arrayYValue) || _arrayY.isBoolean()) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = (arrayXValue - arrayYValue) ** 2;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/math/tan/index.ts
var Tan = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.tan();
  }
};

// ../packages/engine-formula/src/functions/math/tanh/index.ts
var Tanh = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    let _variant = variant;
    if (_variant.isString()) {
      _variant = _variant.convertToNumberObjectValue();
    }
    if (_variant.isError()) {
      return _variant;
    }
    return _variant.tanh();
  }
};

// ../packages/engine-formula/src/functions/math/trunc/index.ts
var Trunc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numDigits) {
    const _numDigits = numDigits != null ? numDigits : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _numDigits.isArray() ? _numDigits.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _numDigits.isArray() ? _numDigits.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const numDigitsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _numDigits, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      let numDigitsObject = numDigitsArray.get(rowIndex, columnIndex);
      let _numberObject = numberObject;
      if (_numberObject.isString()) {
        _numberObject = _numberObject.convertToNumberObjectValue();
      }
      if (_numberObject.isError()) {
        return _numberObject;
      }
      if (numDigitsObject.isString()) {
        numDigitsObject = numDigitsObject.convertToNumberObjectValue();
      }
      if (numDigitsObject.isError()) {
        return numDigitsObject;
      }
      const numberValue = +_numberObject.getValue();
      const numDigitsValue = +numDigitsObject.getValue();
      const factor = 10 ** Math.trunc(numDigitsValue);
      const epsilon = baseEpsilon(numberValue, factor);
      const result = Math.trunc(multiply(numberValue, factor) + epsilon) / factor;
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/math/function-map.ts
var functionMath = [
  [Abs, "ABS" /* ABS */],
  [Acos, "ACOS" /* ACOS */],
  [Acosh, "ACOSH" /* ACOSH */],
  [Acot, "ACOT" /* ACOT */],
  [Acoth, "ACOTH" /* ACOTH */],
  [Arabic, "ARABIC" /* ARABIC */],
  [Asin, "ASIN" /* ASIN */],
  [Asinh, "ASINH" /* ASINH */],
  [Atan, "ATAN" /* ATAN */],
  [Atan2, "ATAN2" /* ATAN2 */],
  [Atanh, "ATANH" /* ATANH */],
  [Base, "BASE" /* BASE */],
  [Ceiling, "CEILING" /* CEILING */],
  [CeilingMath, "CEILING.MATH" /* CEILING_MATH */],
  [CeilingPrecise, "CEILING.PRECISE" /* CEILING_PRECISE */],
  [Combin, "COMBIN" /* COMBIN */],
  [Combina, "COMBINA" /* COMBINA */],
  [Cos, "COS" /* COS */],
  [Cosh, "COSH" /* COSH */],
  [Cot, "COT" /* COT */],
  [Coth, "COTH" /* COTH */],
  [Csc, "CSC" /* CSC */],
  [Csch, "CSCH" /* CSCH */],
  [Decimal2, "DECIMAL" /* DECIMAL */],
  [Degrees, "DEGREES" /* DEGREES */],
  [Even, "EVEN" /* EVEN */],
  [Exp, "EXP" /* EXP */],
  [Fact, "FACT" /* FACT */],
  [Factdouble, "FACTDOUBLE" /* FACTDOUBLE */],
  [Floor, "FLOOR" /* FLOOR */],
  [FloorMath, "FLOOR.MATH" /* FLOOR_MATH */],
  [FloorPrecise, "FLOOR.PRECISE" /* FLOOR_PRECISE */],
  [Gcd, "GCD" /* GCD */],
  [Int, "INT" /* INT */],
  [Lcm, "LCM" /* LCM */],
  [Ln, "LN" /* LN */],
  [Log, "LOG" /* LOG */],
  [Log10, "LOG10" /* LOG10 */],
  [Mdeterm, "MDETERM" /* MDETERM */],
  [Minverse, "MINVERSE" /* MINVERSE */],
  [Mmult, "MMULT" /* MMULT */],
  [Mod, "MOD" /* MOD */],
  [Mround, "MROUND" /* MROUND */],
  [Multinomial, "MULTINOMIAL" /* MULTINOMIAL */],
  [Munit, "MUNIT" /* MUNIT */],
  [Odd, "ODD" /* ODD */],
  [Pi, "PI" /* PI */],
  [Power, "POWER" /* POWER */],
  [Product, "PRODUCT" /* PRODUCT */],
  [Quotient, "QUOTIENT" /* QUOTIENT */],
  [Radians, "RADIANS" /* RADIANS */],
  [Rand, "RAND" /* RAND */],
  [Randarray, "RANDARRAY" /* RANDARRAY */],
  [Randbetween, "RANDBETWEEN" /* RANDBETWEEN */],
  [Roman, "ROMAN" /* ROMAN */],
  [Round, "ROUND" /* ROUND */],
  [Roundbank, "ROUNDBANK" /* ROUNDBANK */],
  [Rounddown, "ROUNDDOWN" /* ROUNDDOWN */],
  [Roundup, "ROUNDUP" /* ROUNDUP */],
  [Sec, "SEC" /* SEC */],
  [Sech, "SECH" /* SECH */],
  [Seriessum, "SERIESSUM" /* SERIESSUM */],
  [Sequence, "SEQUENCE" /* SEQUENCE */],
  [Sign, "SIGN" /* SIGN */],
  [Sin, "SIN" /* SIN */],
  [Sinh, "SINH" /* SINH */],
  [Sqrt, "SQRT" /* SQRT */],
  [Sqrtpi, "SQRTPI" /* SQRTPI */],
  [Subtotal, "SUBTOTAL" /* SUBTOTAL */],
  [Sum, "SUM" /* SUM */],
  [Sumif, "SUMIF" /* SUMIF */],
  [Sumifs, "SUMIFS" /* SUMIFS */],
  [Sumproduct, "SUMPRODUCT" /* SUMPRODUCT */],
  [Sumsq, "SUMSQ" /* SUMSQ */],
  [Sumx2my2, "SUMX2MY2" /* SUMX2MY2 */],
  [Sumx2py2, "SUMX2PY2" /* SUMX2PY2 */],
  [Sumxmy2, "SUMXMY2" /* SUMXMY2 */],
  [Tan, "TAN" /* TAN */],
  [Tanh, "TANH" /* TANH */],
  [Trunc, "TRUNC" /* TRUNC */]
];

// ../packages/engine-formula/src/functions/meta/compare/index.ts
var Compare = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
    __publicField(this, "_compareType", "=" /* EQUALS */);
  }
  setCompareType(token) {
    this._compareType = token;
  }
  calculate(variant1, variant2) {
    if (variant1.isError()) {
      return variant1;
    }
    if (variant2.isError()) {
      return variant2;
    }
    return variant1.compare(variant2, this._compareType);
  }
};

// ../packages/engine-formula/src/engine/value-object/cube-value-object.ts
var CubeValueObject = class _CubeValueObject extends BaseValueObject {
  constructor(values) {
    super("");
    __publicField(this, "_values", []);
    this._values = values;
  }
  static create(values) {
    return new _CubeValueObject(values);
  }
  isCube() {
    return true;
  }
  dispose() {
    this._values.forEach((value) => {
      value.dispose();
    });
    this._values = [];
  }
  sum() {
    const result = NumberValueObject.create(0);
    this._values.forEach((arr) => {
      result.plus(arr.sum());
    });
    return result;
  }
  max() {
    let result = NumberValueObject.create(Number.NEGATIVE_INFINITY);
    this._values.forEach((arr) => {
      const compare = arr.max();
      if (result.isLessThan(compare)) {
        result = compare;
      }
    });
    return result;
  }
  min() {
    let result = NumberValueObject.create(Number.POSITIVE_INFINITY);
    this._values.forEach((arr) => {
      const compare = arr.max();
      if (result.isGreaterThan(compare)) {
        result = compare;
      }
    });
    return result;
  }
  count() {
    const count = NumberValueObject.create(0);
    this._values.forEach((arr) => {
      count.plus(arr.count());
    });
    return count;
  }
  countA() {
    const count = NumberValueObject.create(0);
    this._values.forEach((arr) => {
      count.plus(arr.countA());
    });
    return count;
  }
  countBlank() {
    const count = NumberValueObject.create(0);
    this._values.forEach((arr) => {
      count.plus(arr.countBlank());
    });
    return count;
  }
};

// ../packages/engine-formula/src/functions/meta/cube/index.ts
var Cube = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const values = [];
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (!variant.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      values.push(variant);
    }
    return CubeValueObject.create(values);
  }
};

// ../packages/engine-formula/src/functions/meta/divided/index.ts
var Divided = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(variant1, variant2) {
    if (variant1.isError()) {
      return variant1;
    }
    if (variant2.isError()) {
      return variant2;
    }
    if (!variant2.isArray() && variant2.getValue() === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return variant1.divided(variant2);
  }
};

// ../packages/engine-formula/src/functions/meta/minus/index.ts
var Minus = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(variant1, variant2) {
    if (variant1.isError()) {
      return variant1;
    }
    if (variant2.isError()) {
      return variant2;
    }
    return variant1.minus(variant2);
  }
};

// ../packages/engine-formula/src/functions/meta/multiply/index.ts
var Multiply = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(variant1, variant2) {
    if (variant1.isError()) {
      return variant1;
    }
    if (variant2.isError()) {
      return variant2;
    }
    return variant1.multiply(variant2);
  }
};

// ../packages/engine-formula/src/functions/meta/plus/index.ts
var Plus = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(variant1, variant2) {
    if (variant1.isError()) {
      return variant1;
    }
    if (variant2.isError()) {
      return variant2;
    }
    return variant1.plus(variant2);
  }
};

// ../packages/engine-formula/src/functions/meta/function-map.ts
var functionMeta = [
  [Compare, "COMPARE" /* COMPARE */],
  [Divided, "DIVIDED" /* DIVIDED */],
  [Minus, "MINUS" /* MINUS */],
  [Multiply, "MULTIPLY" /* MULTIPLY */],
  [Plus, "PLUS" /* PLUS */],
  [Cube, "CUBE" /* CUBE */]
];

// ../packages/engine-formula/src/functions/statistical/avedev/index.ts
var Avedev = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorSum = NumberValueObject.create(0);
    let accumulatorCount = NumberValueObject.create(0);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        variant = filterNumberValueObject(variant);
        if (variant.isError()) {
          return variant;
        }
        variants[i] = variant;
        accumulatorSum = accumulatorSum.plus(variant.sum());
        if (accumulatorSum.isError()) {
          return accumulatorSum;
        }
        accumulatorCount = accumulatorCount.plus(variant.count());
      } else if (!variant.isNull()) {
        accumulatorSum = accumulatorSum.plus(variant);
        accumulatorCount = accumulatorCount.plus(NumberValueObject.create(1));
      }
    }
    if (accumulatorCount.getValue() === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const average = accumulatorSum.divided(accumulatorCount);
    if (average.isError()) {
      return average;
    }
    let accumulatorAveDev = NumberValueObject.create(0);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        accumulatorAveDev = accumulatorAveDev.plus(variant.minus(average).abs().sum());
        if (accumulatorAveDev.isError()) {
          return accumulatorAveDev;
        }
      } else if (!variant.isNull()) {
        accumulatorAveDev = accumulatorAveDev.plus(variant.minus(average).abs());
      }
    }
    return accumulatorAveDev.divided(accumulatorCount);
  }
};
function filterNumberValueObject(array) {
  const newArray = [];
  newArray[0] = [];
  let isError = null;
  array.iterator((valueObject, _rowIndex, _columnIndex) => {
    if (valueObject == null ? void 0 : valueObject.isError()) {
      isError = valueObject;
      return false;
    }
    if (valueObject == null ? void 0 : valueObject.isNumber()) {
      newArray[0].push(valueObject);
    }
  });
  if (isError) {
    return isError;
  }
  return createNewArray(newArray, 1, newArray[0].length);
}

// ../packages/engine-formula/src/functions/statistical/average/index.ts
var Average = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorSum = NumberValueObject.create(0);
    let accumulatorCount = NumberValueObject.create(0);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString() || variant.isBoolean()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        accumulatorSum = accumulatorSum.plus(variant.sum());
        if (accumulatorSum.isError()) {
          return accumulatorSum;
        }
        accumulatorCount = accumulatorCount.plus(variant.count());
      } else if (!variant.isNull()) {
        accumulatorSum = accumulatorSum.plus(variant);
        accumulatorCount = accumulatorCount.plus(NumberValueObject.create(1));
      }
    }
    return accumulatorSum.divided(accumulatorCount);
  }
};

// ../packages/engine-formula/src/functions/statistical/average-weighted/index.ts
var AverageWeighted = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 254);
  }
  // eslint-disable-next-line
  calculate(...variants) {
    let isOtherError = false;
    let otherErrorObject;
    if (variants.length % 2 !== 0) {
      isOtherError = true;
      otherErrorObject = ErrorValueObject.create("#N/A" /* NA */);
    }
    const values = [];
    const weights = [];
    for (let i = 0; i < variants.length; i += 2) {
      const valueObject = variants[i];
      const valueObjectRowCount = valueObject.isArray() ? valueObject.getRowCount() : 1;
      const valueObjectColumnCount = valueObject.isArray() ? valueObject.getColumnCount() : 1;
      for (let r = 0; r < valueObjectRowCount; r++) {
        for (let c = 0; c < valueObjectColumnCount; c++) {
          const obj = valueObject.isArray() ? valueObject.get(r, c) : valueObject;
          if (obj.isError()) {
            return obj;
          }
          if (isOtherError) {
            continue;
          }
          const value = obj.isNull() ? "" : obj.getValue();
          values.push(value);
        }
      }
      if (i + 1 >= variants.length) {
        continue;
      }
      const weightObject = variants[i + 1];
      const weightObjectRowCount = weightObject.isArray() ? weightObject.getRowCount() : 1;
      const weightObjectColumnCount = weightObject.isArray() ? weightObject.getColumnCount() : 1;
      if (weightObjectRowCount !== valueObjectRowCount || weightObjectColumnCount !== valueObjectColumnCount) {
        isOtherError = true;
        otherErrorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      for (let r = 0; r < weightObjectRowCount; r++) {
        for (let c = 0; c < weightObjectColumnCount; c++) {
          const obj = weightObject.isArray() ? weightObject.get(r, c) : weightObject;
          if (obj.isError()) {
            return obj;
          }
          if (isOtherError) {
            continue;
          }
          const weight = obj.isNull() ? "" : obj.getValue();
          weights.push(weight);
        }
      }
    }
    if (isOtherError) {
      return otherErrorObject;
    }
    return this._getResult(values, weights);
  }
  _getResult(values, weights) {
    const n = values.length;
    let sum2 = 0;
    let sumWeight = 0;
    for (let i = 0; i < n; i++) {
      const value = values[i];
      const weight = weights[i];
      if (typeof value !== "number" && typeof weight !== "number") {
        continue;
      }
      if (typeof value !== "number" || typeof weight !== "number" || weight < 0) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      sum2 += value * weight;
      sumWeight += weight;
    }
    if (sumWeight === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = sum2 / sumWeight;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/averagea/index.ts
var Averagea = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorSum = NumberValueObject.create(0);
    let accumulatorCount = NumberValueObject.create(0);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString() || variant.isBoolean()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        variant.iterator((valueObject) => {
          if (valueObject == null || valueObject.isNull()) {
            return true;
          }
          let _valueObject = valueObject;
          if (_valueObject.isString()) {
            _valueObject = _valueObject.convertToNumberObjectValue();
            if (_valueObject.isError()) {
              _valueObject = NumberValueObject.create(0);
            }
          }
          if (_valueObject.isBoolean()) {
            _valueObject = _valueObject.convertToNumberObjectValue();
          }
          if (_valueObject.isError()) {
            accumulatorSum = _valueObject;
            return false;
          }
          accumulatorSum = accumulatorSum.plus(_valueObject);
          accumulatorCount = accumulatorCount.plus(NumberValueObject.create(1));
        });
        if (accumulatorSum.isError()) {
          return accumulatorSum;
        }
      } else if (!variant.isNull()) {
        accumulatorSum = accumulatorSum.plus(variant);
        accumulatorCount = accumulatorCount.plus(NumberValueObject.create(1));
      }
    }
    return accumulatorSum.divided(accumulatorCount);
  }
};

// ../packages/engine-formula/src/functions/statistical/averageif/index.ts
var Averageif = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(range, criteria, averageRange) {
    if (range.isError()) {
      return range;
    }
    if (criteria.isError()) {
      return criteria;
    }
    if (averageRange == null ? void 0 : averageRange.isError()) {
      return averageRange;
    }
    let _range = range;
    if (_range.isReferenceObject()) {
      _range = _range.toArrayValueObject();
    }
    if (!_range.isArray()) {
      _range = createNewArray([[_range]], 1, 1);
    }
    let _criteria = criteria;
    if (_criteria.isReferenceObject()) {
      _criteria = _criteria.toArrayValueObject();
    }
    if (averageRange && !(averageRange == null ? void 0 : averageRange.isReferenceObject())) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    _criteria = _criteria;
    if (_criteria.isArray()) {
      return _criteria.map((criteriaItem) => this._handleSingleObject(_range, criteriaItem, averageRange));
    }
    return this._handleSingleObject(_range, _criteria, averageRange);
  }
  _handleSingleObject(range, criteria, averageRange) {
    let resultArrayObject = valueObjectCompare(range, criteria);
    resultArrayObject = filterSameValueObjectResult(resultArrayObject, range, criteria);
    let averageRangeArray = averageRange ? this._createRangeReferenceObject(averageRange, range) : range;
    if (!averageRangeArray) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (averageRangeArray.isError()) {
      return averageRangeArray;
    }
    if (averageRangeArray.isReferenceObject()) {
      averageRangeArray = averageRangeArray.toArrayValueObject();
    }
    averageRangeArray = averageRangeArray;
    const picked = averageRangeArray.pick(resultArrayObject);
    const sum2 = picked.sum();
    const count = picked.count();
    return sum2.divided(count);
  }
  /**
   * Create reference object, starting from the first cell in the upper left corner, the height is rowCount and the width is columnCount
   * @param averageRange
   * @param rowCount
   * @param columnCount
   * @returns
   */
  _createRangeReferenceObject(averageRange, range) {
    const averageRangeRow = averageRange.getRowCount();
    const averageRangeColumn = averageRange.getColumnCount();
    const rowCount = range.isArray() ? range.getRowCount() : 1;
    const columnCount = range.isArray() ? range.getColumnCount() : 1;
    if (averageRangeRow === rowCount && averageRangeColumn === columnCount) {
      return averageRange;
    }
    const { startRow, startColumn } = averageRange.getRangePosition();
    const rangeData = {
      startRow,
      startColumn,
      endRow: startRow + rowCount - 1,
      endColumn: startColumn + columnCount - 1
    };
    return this.createReferenceObject(averageRange, rangeData);
  }
};

// ../packages/engine-formula/src/functions/statistical/averageifs/index.ts
var Averageifs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 255);
  }
  calculate(averageRange, ...variants) {
    if (averageRange.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (!averageRange.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.length % 2 !== 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.some((variant, i) => i % 2 === 0 && !variant.isArray())) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const { maxRowLength, maxColumnLength } = calculateMaxDimensions(variants);
    const errorArray = getErrorArray(variants, averageRange, maxRowLength, maxColumnLength);
    if (errorArray) {
      return errorArray;
    }
    const booleanResults = getBooleanResults(variants, maxRowLength, maxColumnLength, true);
    return this._aggregateResults(averageRange, booleanResults);
  }
  _aggregateResults(averageRange, booleanResults) {
    const maxResults = booleanResults.map((row) => {
      return row.map((booleanResult) => {
        const picked = averageRange.pick(booleanResult);
        const sum2 = picked.sum();
        const count = picked.count();
        return sum2.divided(count);
      });
    });
    const arrayValueObjectData = {
      calculateValueList: maxResults,
      rowCount: maxResults.length,
      columnCount: maxResults[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};

// ../packages/engine-formula/src/functions/statistical/beta-dist/index.ts
var BetaDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 6);
  }
  calculate(x, alpha, beta, cumulative, A, B) {
    let _A = A != null ? A : NumberValueObject.create(0);
    let _B = B != null ? B : NumberValueObject.create(1);
    if (_A.isNull()) {
      _A = NumberValueObject.create(0);
    }
    if (_B.isNull()) {
      _B = NumberValueObject.create(1);
    }
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      alpha.isArray() ? alpha.getRowCount() : 1,
      beta.isArray() ? beta.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1,
      _A.isArray() ? _A.getRowCount() : 1,
      _B.isArray() ? _B.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      alpha.isArray() ? alpha.getColumnCount() : 1,
      beta.isArray() ? beta.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1,
      _A.isArray() ? _A.getColumnCount() : 1,
      _B.isArray() ? _B.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const betaArray = expandArrayValueObject(maxRowLength, maxColumnLength, beta, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const AArray = expandArrayValueObject(maxRowLength, maxColumnLength, _A, ErrorValueObject.create("#N/A" /* NA */));
    const BArray = expandArrayValueObject(maxRowLength, maxColumnLength, _B, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const alphaObject = alphaArray.get(rowIndex, columnIndex);
      const betaObject = betaArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      const AObject = AArray.get(rowIndex, columnIndex);
      const BObject = BArray.get(rowIndex, columnIndex);
      return this._handleSignleObject(xObject, alphaObject, betaObject, cumulativeObject, AObject, BObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, alphaObject, betaObject, cumulativeObject, AObject, BObject) {
    if (xObject.isError()) {
      return xObject;
    }
    if (alphaObject.isError()) {
      return alphaObject;
    }
    if (betaObject.isError()) {
      return betaObject;
    }
    if (cumulativeObject.isError()) {
      return cumulativeObject;
    }
    if (AObject.isError()) {
      return AObject;
    }
    if (BObject.isError()) {
      return BObject;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, alphaObject, betaObject, cumulativeObject, AObject, BObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _alphaObject, _betaObject, _cumulativeObject, _AObject, _BObject] = variants;
    const xValue = +_xObject.getValue();
    const alphaValue = +_alphaObject.getValue();
    const betaValue = +_betaObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    const AValue = +_AObject.getValue();
    const BValue = +_BObject.getValue();
    if (alphaValue <= 0 || betaValue <= 0 || xValue < AValue || xValue > BValue || AValue === BValue) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = betaCDF((xValue - AValue) / (BValue - AValue), alphaValue, betaValue);
    } else {
      result = betaPDF((xValue - AValue) / (BValue - AValue), alphaValue, betaValue) / (BValue - AValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/binom-dist-range/index.ts
var BinomDistRange = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(trials, probabilityS, numberS, numberS2) {
    let _numberS2 = numberS2 != null ? numberS2 : numberS;
    if (_numberS2.isNull()) {
      _numberS2 = numberS;
    }
    const maxRowLength = Math.max(
      trials.isArray() ? trials.getRowCount() : 1,
      probabilityS.isArray() ? probabilityS.getRowCount() : 1,
      numberS.isArray() ? numberS.getRowCount() : 1,
      _numberS2.isArray() ? _numberS2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      trials.isArray() ? trials.getColumnCount() : 1,
      probabilityS.isArray() ? probabilityS.getColumnCount() : 1,
      numberS.isArray() ? numberS.getColumnCount() : 1,
      _numberS2.isArray() ? _numberS2.getColumnCount() : 1
    );
    const trialsArray = expandArrayValueObject(maxRowLength, maxColumnLength, trials, ErrorValueObject.create("#N/A" /* NA */));
    const probabilitySArray = expandArrayValueObject(maxRowLength, maxColumnLength, probabilityS, ErrorValueObject.create("#N/A" /* NA */));
    const numberSArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberS, ErrorValueObject.create("#N/A" /* NA */));
    const numberS2Array = expandArrayValueObject(maxRowLength, maxColumnLength, _numberS2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = trialsArray.mapValue((trialsObject, rowIndex, columnIndex) => {
      const probabilitySObject = probabilitySArray.get(rowIndex, columnIndex);
      const numberSObject = numberSArray.get(rowIndex, columnIndex);
      const numberS2Object = numberS2Array.get(rowIndex, columnIndex);
      if (trialsObject.isError()) {
        return trialsObject;
      }
      if (probabilitySObject.isError()) {
        return probabilitySObject;
      }
      if (numberSObject.isError()) {
        return numberSObject;
      }
      if (numberS2Object.isError()) {
        return numberS2Object;
      }
      return this._handleSignleObject(trialsObject, probabilitySObject, numberSObject, numberS2Object);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(trialsObject, probabilitySObject, numberSObject, numberS2Object) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(trialsObject, probabilitySObject, numberSObject, numberS2Object);
    if (isError) {
      return errorObject;
    }
    const [_trialsObject, _probabilitySObject, _numberSObject, _numberS2Object] = variants;
    const trialsValue = Math.floor(+_trialsObject.getValue());
    const probabilitySValue = +_probabilitySObject.getValue();
    const numberSValue = Math.floor(+_numberSObject.getValue());
    const numberS2Value = Math.floor(+_numberS2Object.getValue());
    if (trialsValue < 0 || probabilitySValue < 0 || probabilitySValue > 1 || numberSValue < 0 || numberSValue > trialsValue || numberS2Value < 0 || numberS2Value < numberSValue || numberS2Value > trialsValue) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result = 0;
    for (let i = numberSValue; i <= numberS2Value; i++) {
      result += binomialPDF(i, trialsValue, probabilitySValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/chisq-dist/index.ts
var ChisqDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, degFreedom, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, degFreedomObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedomObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedomObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedomObject, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    const cumulativeValue = +_cumulativeObject.getValue();
    if (xValue < 0 || degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = chisquareCDF(xValue, degFreedomValue);
    } else {
      result = chisquarePDF(xValue, degFreedomValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/chisq-inv/index.ts
var ChisqInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(probability, degFreedom) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      return this._handleSignleObject(probabilityObject, degFreedomObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, degFreedomObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, degFreedomObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _degFreedomObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    if (probabilityValue < 0 || probabilityValue > 1 || degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = chisquareINV(probabilityValue, degFreedomValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/confidence-t/index.ts
var ConfidenceT = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(alpha, standardDev, size) {
    const maxRowLength = Math.max(
      alpha.isArray() ? alpha.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1,
      size.isArray() ? size.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      alpha.isArray() ? alpha.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1,
      size.isArray() ? size.getColumnCount() : 1
    );
    const alphaArray = expandArrayValueObject(maxRowLength, maxColumnLength, alpha, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const sizeArray = expandArrayValueObject(maxRowLength, maxColumnLength, size, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = alphaArray.mapValue((alphaObject, rowIndex, columnIndex) => {
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      const sizeObject = sizeArray.get(rowIndex, columnIndex);
      if (alphaObject.isError()) {
        return alphaObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      if (sizeObject.isError()) {
        return sizeObject;
      }
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(alphaObject, standardDevObject, sizeObject);
      if (isError) {
        return errorObject;
      }
      const [_alphaObject, _standardDevObject, _sizeObject] = variants;
      const alphaValue = +_alphaObject.getValue();
      const standardDevValue = +_standardDevObject.getValue();
      const sizeValue = Math.floor(+_sizeObject.getValue());
      if (alphaValue <= 0 || alphaValue >= 1 || standardDevValue <= 0 || sizeValue < 1) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (sizeValue === 1) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      const result = Math.abs(studentTINV(alphaValue / 2, sizeValue - 1) * standardDevValue / Math.sqrt(sizeValue));
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/statistical/correl/index.ts
var Correl = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array1, array2) {
    const array1RowCount = array1.isArray() ? array1.getRowCount() : 1;
    const array1ColumnCount = array1.isArray() ? array1.getColumnCount() : 1;
    const array2RowCount = array2.isArray() ? array2.getRowCount() : 1;
    const array2ColumnCount = array2.isArray() ? array2.getColumnCount() : 1;
    let _array1 = array1;
    if (array1.isArray() && array1RowCount === 1 && array1ColumnCount === 1) {
      _array1 = array1.get(0, 0);
    }
    if (_array1.isError()) {
      return _array1;
    }
    let _array2 = array2;
    if (array2.isArray() && array2RowCount === 1 && array2ColumnCount === 1) {
      _array2 = array2.get(0, 0);
    }
    if (_array2.isError()) {
      return _array2;
    }
    if (array1RowCount * array1ColumnCount === 1 || array2RowCount * array2ColumnCount === 1) {
      if (_array1.isNull() || _array2.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    if (array1RowCount * array1ColumnCount !== array2RowCount * array2ColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      array1,
      array2,
      array1RowCount * array1ColumnCount,
      array1ColumnCount,
      array2ColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(array1Values, array2Values) {
    const n = array1Values.length;
    let array1Sum = 0;
    let array2Sum = 0;
    for (let i = 0; i < n; i++) {
      array1Sum += array1Values[i];
      array2Sum += array2Values[i];
    }
    const array1Mean = array1Sum / n;
    const array2Mean = array2Sum / n;
    let numerator = 0;
    let array1DiffSum = 0;
    let array2DiffSum = 0;
    for (let i = 0; i < n; i++) {
      const array1Diff = array1Values[i] - array1Mean;
      const array2Diff = array2Values[i] - array2Mean;
      numerator += array1Diff * array2Diff;
      array1DiffSum += array1Diff ** 2;
      array2DiffSum += array2Diff ** 2;
    }
    const denominator = Math.sqrt(array1DiffSum * array2DiffSum);
    if (denominator === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return NumberValueObject.create(numerator / denominator);
  }
};

// ../packages/engine-formula/src/functions/statistical/count/index.ts
var Count = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(0);
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        continue;
      }
      if (variant.isArray()) {
        accumulatorAll = accumulatorAll.plus(variant.count());
      } else if (variant.isString()) {
        if (!variant.convertToNumberObjectValue().isError()) {
          accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
        }
      } else if (!variant.isNull()) {
        accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
      }
    }
    return accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/statistical/counta/index.ts
var Counta = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(0);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isError()) {
        accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
        continue;
      }
      if (variant.isArray()) {
        variant = variant.countA();
        accumulatorAll = accumulatorAll.plus(variant);
      } else if (!variant.isNull()) {
        accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
      }
    }
    return accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/statistical/countblank/index.ts
var Countblank = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(variant) {
    if (variant.isError()) {
      return variant;
    }
    if (variant.getValue() === "" || variant.isNull()) {
      return NumberValueObject.create(1);
    }
    if (!variant.isArray()) {
      return NumberValueObject.create(0);
    }
    return variant.countBlank();
  }
};

// ../packages/engine-formula/src/functions/statistical/countif/index.ts
var Countif = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(range, criteria) {
    if (range.isError() || criteria.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (!range.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (criteria.isArray()) {
      return criteria.mapValue((criteriaItem) => this._handleSingleObject(range, criteriaItem));
    }
    return this._handleSingleObject(range, criteria);
  }
  _handleSingleObject(range, criteria) {
    let resultArrayObject = valueObjectCompare(range, criteria);
    resultArrayObject = filterSameValueObjectResult(resultArrayObject, range, criteria);
    const picked = range.pick(resultArrayObject);
    return this._countA(picked);
  }
  _countA(array) {
    let accumulatorAll = NumberValueObject.create(0);
    array.iterator((valueObject) => {
      if (valueObject == null) {
        return true;
      }
      accumulatorAll = accumulatorAll.plusBy(1);
    });
    return accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/statistical/countifs/index.ts
var Countifs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    if (variants.length % 2 !== 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.some((variant, i) => i % 2 === 0 && !variant.isArray())) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const { maxRowLength, maxColumnLength } = calculateMaxDimensions(variants);
    const errorArray = getErrorArray(variants, variants[0], maxRowLength, maxColumnLength);
    if (errorArray) {
      return errorArray;
    }
    const booleanResults = getBooleanResults(variants, maxRowLength, maxColumnLength, true);
    return this._aggregateResults(booleanResults);
  }
  _aggregateResults(booleanResults) {
    const maxResults = booleanResults.map((row) => {
      return row.map((booleanResult) => {
        return countTrueValue(booleanResult);
      });
    });
    const arrayValueObjectData = {
      calculateValueList: maxResults,
      rowCount: maxResults.length,
      columnCount: maxResults[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};
function countTrueValue(array) {
  let count = 0;
  array.iterator((value) => {
    if ((value == null ? void 0 : value.isBoolean()) && value.getValue() === true) {
      count++;
    }
  });
  return NumberValueObject.create(count);
}

// ../packages/engine-formula/src/functions/statistical/covariance-s/index.ts
var CovarianceS = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array1, array2) {
    const array1RowCount = array1.isArray() ? array1.getRowCount() : 1;
    const array1ColumnCount = array1.isArray() ? array1.getColumnCount() : 1;
    const array2RowCount = array2.isArray() ? array2.getRowCount() : 1;
    const array2ColumnCount = array2.isArray() ? array2.getColumnCount() : 1;
    let _array1 = array1;
    if (array1.isArray() && array1RowCount === 1 && array1ColumnCount === 1) {
      _array1 = array1.get(0, 0);
    }
    if (_array1.isError()) {
      return _array1;
    }
    let _array2 = array2;
    if (array2.isArray() && array2RowCount === 1 && array2ColumnCount === 1) {
      _array2 = array2.get(0, 0);
    }
    if (_array2.isError()) {
      return _array2;
    }
    if (array1RowCount * array1ColumnCount === 1 || array2RowCount * array2ColumnCount === 1) {
      if (_array1.isNull() || _array2.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    if (array1RowCount * array1ColumnCount !== array2RowCount * array2ColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      array1,
      array2,
      array1RowCount * array1ColumnCount,
      array1ColumnCount,
      array2ColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(array1Values, array2Values) {
    if (array1Values.length <= 1) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const n = array1Values.length;
    let array1Sum = 0;
    let array2Sum = 0;
    for (let i = 0; i < n; i++) {
      array1Sum += array1Values[i];
      array2Sum += array2Values[i];
    }
    const array1Mean = array1Sum / n;
    const array2Mean = array2Sum / n;
    let numerator = 0;
    for (let i = 0; i < n; i++) {
      const array1Diff = array1Values[i] - array1Mean;
      const array2Diff = array2Values[i] - array2Mean;
      numerator += array1Diff * array2Diff;
    }
    return NumberValueObject.create(numerator / (n - 1));
  }
};

// ../packages/engine-formula/src/functions/statistical/devsq/index.ts
var Devsq = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const values = [];
    let sum2 = 0;
    let noCalculate = true;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((valueObject) => {
          const _valueObject = this._handleSingleObject(valueObject);
          if (_valueObject.isError()) {
            isError = true;
            errorObject = _valueObject;
            return false;
          }
          if (_valueObject.isNull()) {
            return true;
          }
          const value = _valueObject.getValue();
          values.push(value);
          sum2 += value;
          noCalculate = false;
        });
        if (isError) {
          return errorObject;
        }
      } else {
        const _variant = this._handleSingleObject(variant);
        if (_variant.isError()) {
          return _variant;
        }
        if (_variant.isNull()) {
          continue;
        }
        const value = _variant.getValue();
        values.push(value);
        sum2 += value;
        noCalculate = false;
      }
    }
    if (noCalculate) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const mean = sum2 / values.length;
    let result = 0;
    for (let i = 0; i < values.length; i++) {
      result += (values[i] - mean) ** 2;
    }
    return NumberValueObject.create(result);
  }
  _handleSingleObject(variant) {
    if (variant.isError()) {
      return variant;
    }
    if (variant.isNull() || variant.isBoolean()) {
      return NullValueObject.create();
    }
    const value = variant.getValue();
    if (!isRealNum(value)) {
      return NullValueObject.create();
    }
    return NumberValueObject.create(+value);
  }
};

// ../packages/engine-formula/src/functions/statistical/f-dist/index.ts
var FDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(x, degFreedom1, degFreedom2, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getRowCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getColumnCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom1Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom1, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom2Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom2, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedom1Object = degFreedom1Array.get(rowIndex, columnIndex);
      const degFreedom2Object = degFreedom2Array.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedom1Object.isError()) {
        return degFreedom1Object;
      }
      if (degFreedom2Object.isError()) {
        return degFreedom2Object;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, degFreedom1Object, degFreedom2Object, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedom1Object, degFreedom2Object, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedom1Object, degFreedom2Object, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedom1Object, _degFreedom2Object, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const degFreedom1Value = Math.floor(+_degFreedom1Object.getValue());
    const degFreedom2Value = Math.floor(+_degFreedom2Object.getValue());
    const cumulativeValue = +_cumulativeObject.getValue();
    if (xValue < 0 || degFreedom1Value < 1 || degFreedom1Value > 10 ** 10 || degFreedom2Value < 1 || degFreedom2Value > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = centralFCDF(xValue, degFreedom1Value, degFreedom2Value);
    } else {
      result = centralFPDF(xValue, degFreedom1Value, degFreedom2Value);
    }
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/f-inv/index.ts
var FInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(probability, degFreedom1, degFreedom2) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getRowCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      degFreedom1.isArray() ? degFreedom1.getColumnCount() : 1,
      degFreedom2.isArray() ? degFreedom2.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom1Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom1, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedom2Array = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const degFreedom1Object = degFreedom1Array.get(rowIndex, columnIndex);
      const degFreedom2Object = degFreedom2Array.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (degFreedom1Object.isError()) {
        return degFreedom1Object;
      }
      if (degFreedom2Object.isError()) {
        return degFreedom2Object;
      }
      return this._handleSignleObject(probabilityObject, degFreedom1Object, degFreedom2Object);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, degFreedom1Object, degFreedom2Object) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, degFreedom1Object, degFreedom2Object);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _degFreedom1Object, _degFreedom2Object] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const degFreedom1Value = Math.floor(+_degFreedom1Object.getValue());
    const degFreedom2Value = Math.floor(+_degFreedom2Object.getValue());
    if (probabilityValue < 0 || probabilityValue > 1 || degFreedom1Value < 1 || degFreedom1Value > 10 ** 10 || degFreedom2Value < 1 || degFreedom2Value > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = centralFINV(probabilityValue, degFreedom1Value, degFreedom2Value);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/fisher/index.ts
var Fisher = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(x) {
    if (x.isArray()) {
      return x.mapValue((xObject) => this._handleSingleObject(xObject));
    }
    return this._handleSingleObject(x);
  }
  _handleSingleObject(x) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(x);
    if (isError) {
      return errorObject;
    }
    const [xObject] = variants;
    const xValue = xObject.getValue();
    if (xValue <= -1 || xValue >= 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.log((1 + xValue) / (1 - xValue)) / 2;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/fisherinv/index.ts
var Fisherinv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(y) {
    if (y.isArray()) {
      return y.mapValue((yObject) => this._handleSingleObject(yObject));
    }
    return this._handleSingleObject(y);
  }
  _handleSingleObject(y) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(y);
    if (isError) {
      return errorObject;
    }
    const [yObject] = variants;
    const yValue = +yObject.getValue();
    const num = Math.exp(2 * yValue) - 1;
    const den = Math.exp(2 * yValue) + 1;
    if (!Number.isFinite(num) && num > 0 && !Number.isFinite(den) && den > 0) {
      return NumberValueObject.create(1);
    }
    return NumberValueObject.create(num / den);
  }
};

// ../packages/engine-formula/src/functions/statistical/forecast/index.ts
var Forecast = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, knownYs, knownXs) {
    const knownYsRowCount = knownYs.isArray() ? knownYs.getRowCount() : 1;
    const knownYsColumnCount = knownYs.isArray() ? knownYs.getColumnCount() : 1;
    const knownXsRowCount = knownXs.isArray() ? knownXs.getRowCount() : 1;
    const knownXsColumnCount = knownXs.isArray() ? knownXs.getColumnCount() : 1;
    let _knownYs = knownYs;
    if (knownYs.isArray() && knownYsRowCount === 1 && knownYsColumnCount === 1) {
      _knownYs = knownYs.get(0, 0);
    }
    let _knownXs = knownXs;
    if (knownXs.isArray() && knownXsRowCount === 1 && knownXsColumnCount === 1) {
      _knownXs = knownXs.get(0, 0);
    }
    if (x.isArray()) {
      return x.mapValue(
        (xObject) => this._handleSignleObject(xObject, _knownYs, _knownXs, knownYsRowCount, knownYsColumnCount, knownXsRowCount, knownXsColumnCount)
      );
    }
    return this._handleSignleObject(x, _knownYs, _knownXs, knownYsRowCount, knownYsColumnCount, knownXsRowCount, knownXsColumnCount);
  }
  _handleSignleObject(x, knownYs, knownXs, knownYsRowCount, knownYsColumnCount, knownXsRowCount, knownXsColumnCount) {
    if (x.isError()) {
      return x;
    }
    if (knownYs.isError()) {
      return knownYs;
    }
    if (knownXs.isError()) {
      return knownXs;
    }
    let _x = x;
    if (x.isString()) {
      _x = x.convertToNumberObjectValue();
    }
    if (_x.isError()) {
      return _x;
    }
    const xValue = +_x.getValue();
    if (knownYsRowCount * knownYsColumnCount === 1 || knownXsRowCount * knownXsColumnCount === 1) {
      if (knownYs.isNull() || knownXs.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    if (knownYsRowCount * knownYsColumnCount !== knownXsRowCount * knownXsColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      knownYs,
      knownXs,
      knownYsRowCount * knownYsColumnCount,
      knownYsColumnCount,
      knownXsColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = forecastLinear(xValue, array1Values, array2Values);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/frequency/index.ts
var Frequency = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(dataArray, binsArray) {
    const { isError, errorObject, values: dataArrayValues } = this._getValues(dataArray);
    if (isError) {
      return errorObject;
    }
    if (dataArray.isNull() || binsArray.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let { values: binsArrayValues } = this._getValues(binsArray, true);
    if (binsArrayValues.length === 0) {
      binsArrayValues = [0];
    }
    const newBinsArrayValues = this._getNewBinsArrayValues(binsArrayValues);
    const result = new Array(newBinsArrayValues.length).fill(0);
    for (let i = 0; i < dataArrayValues.length; i++) {
      const value = dataArrayValues[i];
      const index = newBinsArrayValues.findIndex((item) => value > item.start && value <= item.end);
      result[index]++;
    }
    return ArrayValueObject.createByArray(result.map((item) => [item]));
  }
  _getValues(array, isIgnoreError = false) {
    const values = [];
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    for (let r = 0; r < arrayRowCount; r++) {
      for (let c = 0; c < arrayColumnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          if (!isIgnoreError) {
            return {
              isError: true,
              errorObject: valueObject,
              values
            };
          }
          continue;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    return {
      isError: false,
      errorObject: null,
      values
    };
  }
  _getNewBinsArrayValues(binsArrayValues) {
    const _binsArrayValues = binsArrayValues.map((value, index) => {
      return {
        value,
        index
      };
    }).sort((a2, b) => a2.value - b.value);
    const newBinsArrayValues = [];
    for (let i = 0; i < _binsArrayValues.length; i++) {
      const index = _binsArrayValues[i].index;
      if (i === 0) {
        newBinsArrayValues[index] = {
          start: -Infinity,
          end: _binsArrayValues[i].value
        };
        continue;
      }
      newBinsArrayValues[index] = {
        start: _binsArrayValues[i - 1].value,
        end: _binsArrayValues[i].value
      };
    }
    newBinsArrayValues.push({
      start: _binsArrayValues[_binsArrayValues.length - 1].value,
      end: Infinity
    });
    return newBinsArrayValues;
  }
};

// ../packages/engine-formula/src/functions/statistical/gamma/index.ts
var Gamma = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      const resultArray = number.mapValue((numberObject) => this._handleSingleObject(numberObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = +numberObject.getValue();
    if (numberValue === 0 || numberValue < 0 && numberValue % 1 === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = gamma(numberValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/gammaln/index.ts
var Gammaln = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(x) {
    if (x.isArray()) {
      const resultArray = x.mapValue((xObject) => this._handleSingleObject(xObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(x);
  }
  _handleSingleObject(x) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(x);
    if (isError) {
      return errorObject;
    }
    const [xObject] = variants;
    const xValue = +xObject.getValue();
    if (xValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = gammaln(xValue);
    if (Math.abs(result) < 1e-15) {
      return NumberValueObject.create(0);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/gauss/index.ts
var Gauss = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(z) {
    if (z.isArray()) {
      const resultArray = z.mapValue((zObject) => this._handleSingleObject(zObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(z);
  }
  _handleSingleObject(z) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(z);
    if (isError) {
      return errorObject;
    }
    const [zObject] = variants;
    const zValue = +zObject.getValue();
    const result = normalCDF(zValue, 0, 1) - 0.5;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/geomean/index.ts
var Geomean = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let sum2 = 1;
    let len = 0;
    let isNonPositive = false;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((valueObject) => {
          if (valueObject == null ? void 0 : valueObject.isError()) {
            isError = true;
            errorObject = valueObject;
            return false;
          }
          if ((valueObject == null ? void 0 : valueObject.isNull()) || (valueObject == null ? void 0 : valueObject.isBoolean())) {
            return true;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            return true;
          }
          if (+value <= 0) {
            isNonPositive = true;
          }
          sum2 *= +value;
          len++;
        });
        if (isError) {
          return errorObject;
        }
      } else {
        if (variant.isError()) {
          return variant;
        }
        if (variant.isString()) {
          const _variant = variant.convertToNumberObjectValue();
          if (_variant.isError()) {
            return _variant;
          }
        }
        if (variant.isNull() || variant.isBoolean()) {
          continue;
        }
        const value = variant.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        if (+value <= 0) {
          isNonPositive = true;
        }
        sum2 *= +value;
        len++;
      }
    }
    if (len === 0 || isNonPositive) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = sum2 ** (1 / len);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/growth/index.ts
var Growth = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 4);
  }
  calculate(knownYs, knownXs, newXs, constb) {
    const { isError, errorObject } = checkKnownsArrayDimensions(knownYs, knownXs, newXs);
    if (isError) {
      return errorObject;
    }
    const knownYsValues = getKnownsArrayValues(knownYs);
    if (knownYsValues instanceof ErrorValueObject) {
      return knownYsValues;
    }
    const knownXsValues = this._getKnownXsValues(knownYsValues, knownXs);
    if (knownXsValues instanceof ErrorValueObject) {
      return knownXsValues;
    }
    const newXsValues = this._getNewXsValues(knownXsValues, newXs);
    if (newXsValues instanceof ErrorValueObject) {
      return newXsValues;
    }
    let _constb = constb != null ? constb : BooleanValueObject.create(true);
    if (_constb.isArray()) {
      _constb = _constb.get(0, 0);
    }
    if (_constb.isString()) {
      _constb = _constb.convertToNumberObjectValue();
    }
    if (_constb.isError()) {
      return _constb;
    }
    const constbValue = +_constb.getValue();
    return this._getResult(knownYsValues, knownXsValues, newXsValues, constbValue);
  }
  _getResult(knownYsValues, knownXsValues, newXsValues, constb) {
    if (knownYsValues.length === 1 && knownXsValues.length > 1 || knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
      if (knownYsValues.length === 1 && knownXsValues.length > 1) {
        const count = constb ? knownXsValues.length + 1 : knownXsValues.length;
        if (count > knownYsValues[0].length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      if (knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
        const count = constb ? knownXsValues[0].length + 1 : knownXsValues[0].length;
        if (count > knownYsValues.length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      return this._getResultByMultipleVariables(knownYsValues, knownXsValues, newXsValues, constb);
    }
    return this._getResultBySimpleVariables(knownYsValues, knownXsValues, newXsValues, constb);
  }
  _getResultByMultipleVariables(knownYsValues, knownXsValues, newXsValues, constb) {
    const isOneRow = knownYsValues.length === 1 && knownYsValues[0].length > 1;
    const _coefficients = getKnownsArrayCoefficients(knownYsValues, knownXsValues, newXsValues, constb, true);
    if (_coefficients instanceof ErrorValueObject) {
      return _coefficients;
    }
    const { coefficients, newX } = _coefficients;
    const cl = coefficients[0].length;
    const b = coefficients[0][cl - 1];
    let result = [];
    for (let i = 0; i < newX.length; i++) {
      result[i] = [];
      let value = b;
      for (let j = cl - 2; j >= 0; j--) {
        value *= coefficients[0][cl - 2 - j] ** newX[i][j];
      }
      result[i].push(value);
    }
    if (isOneRow) {
      result = matrixTranspose(result);
    }
    return ArrayValueObject.createByArray(result);
  }
  _getResultBySimpleVariables(knownYsValues, knownXsValues, newXsValues, constb) {
    const knownYsValuesFlat = knownYsValues.flat();
    const knownXsValuesFlat = knownXsValues.flat();
    const { slope, intercept } = getSlopeAndIntercept(knownXsValuesFlat, knownYsValuesFlat, constb, true);
    const result = newXsValues.map((row) => {
      return row.map((value) => intercept * slope ** value);
    });
    return ArrayValueObject.createByArray(result);
  }
  _getKnownXsValues(knownYsValues, knownXs) {
    if (!knownXs || knownXs.isNull()) {
      return getSerialNumbersByRowsColumns(knownYsValues.length, knownYsValues[0].length);
    }
    return getKnownsArrayValues(knownXs);
  }
  _getNewXsValues(knownXsValues, newXs) {
    if (!newXs || newXs.isNull()) {
      return knownXsValues;
    }
    return getKnownsArrayValues(newXs);
  }
};

// ../packages/engine-formula/src/functions/statistical/harmean/index.ts
var Harmean = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let sum2 = 0;
    let len = 0;
    let isNonPositive = false;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((valueObject) => {
          if (valueObject == null ? void 0 : valueObject.isError()) {
            isError = true;
            errorObject = valueObject;
            return false;
          }
          if ((valueObject == null ? void 0 : valueObject.isNull()) || (valueObject == null ? void 0 : valueObject.isBoolean())) {
            return true;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            return true;
          }
          if (+value <= 0) {
            isNonPositive = true;
          }
          sum2 += 1 / +value;
          len++;
        });
        if (isError) {
          return errorObject;
        }
      } else {
        if (variant.isError()) {
          return variant;
        }
        if (variant.isString()) {
          const _variant = variant.convertToNumberObjectValue();
          if (_variant.isError()) {
            return _variant;
          }
        }
        if (variant.isNull() || variant.isBoolean()) {
          continue;
        }
        const value = variant.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        if (+value <= 0) {
          isNonPositive = true;
        }
        sum2 += 1 / +value;
        len++;
      }
    }
    if (len === 0) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (isNonPositive) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = len / sum2;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/hypgeom-dist/index.ts
var HypgeomDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 5);
    __publicField(this, "maxParams", 5);
  }
  calculate(sampleS, numberSample, populationS, numberPop, cumulative) {
    const maxRowLength = Math.max(
      sampleS.isArray() ? sampleS.getRowCount() : 1,
      numberSample.isArray() ? numberSample.getRowCount() : 1,
      populationS.isArray() ? populationS.getRowCount() : 1,
      numberPop.isArray() ? numberPop.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      sampleS.isArray() ? sampleS.getColumnCount() : 1,
      numberSample.isArray() ? numberSample.getColumnCount() : 1,
      populationS.isArray() ? populationS.getColumnCount() : 1,
      numberPop.isArray() ? numberPop.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const sampleSArray = expandArrayValueObject(maxRowLength, maxColumnLength, sampleS, ErrorValueObject.create("#N/A" /* NA */));
    const numberSampleArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberSample, ErrorValueObject.create("#N/A" /* NA */));
    const populationSArray = expandArrayValueObject(maxRowLength, maxColumnLength, populationS, ErrorValueObject.create("#N/A" /* NA */));
    const numberPopArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberPop, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = sampleSArray.mapValue((sampleSObject, rowIndex, columnIndex) => {
      const numberSampleObject = numberSampleArray.get(rowIndex, columnIndex);
      const populationSObject = populationSArray.get(rowIndex, columnIndex);
      const numberPopObject = numberPopArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (sampleSObject.isError()) {
        return sampleSObject;
      }
      if (numberSampleObject.isError()) {
        return numberSampleObject;
      }
      if (populationSObject.isError()) {
        return populationSObject;
      }
      if (numberPopObject.isError()) {
        return numberPopObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(sampleSObject, numberSampleObject, populationSObject, numberPopObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(sampleSObject, numberSampleObject, populationSObject, numberPopObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(sampleSObject, numberSampleObject, populationSObject, numberPopObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_sampleSObject, _numberSampleObject, _populationSObject, _numberPopObject, _cumulativeObject] = variants;
    const sampleSValue = Math.floor(+_sampleSObject.getValue());
    const numberSampleValue = Math.floor(+_numberSampleObject.getValue());
    const populationSValue = Math.floor(+_populationSObject.getValue());
    const numberPopValue = Math.floor(+_numberPopObject.getValue());
    const cumulativeValue = +_cumulativeObject.getValue();
    if (sampleSValue < 0 || sampleSValue > numberSampleValue || sampleSValue > populationSValue || sampleSValue < numberSampleValue - numberPopValue + populationSValue || numberSampleValue <= 0 || numberSampleValue > numberPopValue || populationSValue <= 0 || populationSValue > numberPopValue || numberPopValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = hypergeometricCDF(sampleSValue, numberSampleValue, populationSValue, numberPopValue);
    } else {
      result = hypergeometricPDF(sampleSValue, numberSampleValue, populationSValue, numberPopValue);
    }
    if (Number.isNaN(result)) {
      result = 0;
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/intercept/index.ts
var Intercept = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(knownYs, knownXs) {
    const knownYsRowCount = knownYs.isArray() ? knownYs.getRowCount() : 1;
    const knownYsColumnCount = knownYs.isArray() ? knownYs.getColumnCount() : 1;
    const knownXsRowCount = knownXs.isArray() ? knownXs.getRowCount() : 1;
    const knownXsColumnCount = knownXs.isArray() ? knownXs.getColumnCount() : 1;
    let _knownYs = knownYs;
    if (knownYs.isArray() && knownYsRowCount === 1 && knownYsColumnCount === 1) {
      _knownYs = knownYs.get(0, 0);
    }
    if (_knownYs.isError()) {
      return _knownYs;
    }
    let _knownXs = knownXs;
    if (knownXs.isArray() && knownXsRowCount === 1 && knownXsColumnCount === 1) {
      _knownXs = knownXs.get(0, 0);
    }
    if (_knownXs.isError()) {
      return _knownXs;
    }
    if (knownYsRowCount * knownYsColumnCount === 1 || knownXsRowCount * knownXsColumnCount === 1) {
      if (_knownYs.isNull() || _knownXs.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    if (knownYsRowCount * knownYsColumnCount !== knownXsRowCount * knownXsColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      knownYs,
      knownXs,
      knownYsRowCount * knownYsColumnCount,
      knownYsColumnCount,
      knownXsColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(knownYs, knownXs) {
    const result = forecastLinear(0, knownYs, knownXs);
    if (!Number.isFinite(result)) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/kurt/index.ts
var Kurt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const values = [];
    let sum2 = 0;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (variant.isString()) {
        const _variant = variant.convertToNumberObjectValue();
        if (_variant.isError()) {
          return _variant;
        }
      }
      const rowCount = variant.isArray() ? variant.getRowCount() : 1;
      const columnCount = variant.isArray() ? variant.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const valueObject = variant.isArray() ? variant.get(r, c) : variant;
          if (valueObject.isError()) {
            return valueObject;
          }
          if (valueObject.isNull() || valueObject.isBoolean()) {
            continue;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            continue;
          }
          values.push(+value);
          sum2 += +value;
        }
      }
    }
    if (values.length <= 3) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(values, sum2);
  }
  _getResult(values, sum2) {
    const n = values.length;
    const mean = sum2 / n;
    let sum22 = 0;
    for (let i = 0; i < n; i++) {
      sum22 += (values[i] - mean) ** 2;
    }
    const stdev = Math.sqrt(sum22 / (n - 1));
    if (stdev === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    let sum3 = 0;
    for (let i = 0; i < n; i++) {
      sum3 += ((values[i] - mean) / stdev) ** 4;
    }
    const result = n * (n + 1) / ((n - 1) * (n - 2) * (n - 3)) * sum3 - 3 * (n - 1) ** 2 / ((n - 2) * (n - 3));
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/large/index.ts
var Large = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, k) {
    const arrayValues = this._getValues(array);
    if (k.isArray()) {
      const resultArray = k.mapValue((kObject) => this._handleSingleObject(arrayValues, kObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(arrayValues, k);
  }
  _handleSingleObject(array, k) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(k);
    if (isError) {
      return errorObject;
    }
    const [kObject] = variants;
    let kValue = +kObject.getValue();
    if (kValue < 1 || kValue > array.length) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    kValue = Math.ceil(kValue);
    return NumberValueObject.create(array[kValue - 1]);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return values.sort((a2, b) => b - a2);
  }
};

// ../packages/engine-formula/src/functions/statistical/linest/index.ts
var Linest = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 4);
  }
  calculate(knownYs, knownXs, constb, stats) {
    const { isError, errorObject } = checkKnownsArrayDimensions(knownYs, knownXs);
    if (isError) {
      return errorObject;
    }
    const knownYsValues = getKnownsArrayValues(knownYs);
    if (knownYsValues instanceof ErrorValueObject) {
      return knownYsValues;
    }
    const knownXsValues = this._getKnownXsValues(knownYsValues, knownXs);
    if (knownXsValues instanceof ErrorValueObject) {
      return knownXsValues;
    }
    let _constb = constb != null ? constb : BooleanValueObject.create(true);
    if (_constb.isArray()) {
      _constb = _constb.get(0, 0);
    }
    let _stats = stats != null ? stats : BooleanValueObject.create(false);
    if (_stats.isArray()) {
      _stats = _stats.get(0, 0);
    }
    const { isError: _isError, errorObject: _errorObject, variants } = checkVariantsErrorIsStringToNumber(_constb, _stats);
    if (_isError) {
      return _errorObject;
    }
    const [constbObject, statsObject] = variants;
    return this._getResult(knownYsValues, knownXsValues, +constbObject.getValue(), +statsObject.getValue());
  }
  _getResult(knownYsValues, knownXsValues, constb, stats) {
    if (knownYsValues.length === 1 && knownXsValues.length > 1 || knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
      if (knownYsValues.length === 1 && knownXsValues.length > 1) {
        const count = constb ? knownXsValues.length + 1 : knownXsValues.length;
        if (count > knownYsValues[0].length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      if (knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
        const count = constb ? knownXsValues[0].length + 1 : knownXsValues[0].length;
        if (count > knownYsValues.length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      return this._getResultByMultipleVariables(knownYsValues, knownXsValues, constb, stats);
    }
    return this._getResultBySimpleVariables(knownYsValues, knownXsValues, constb, stats);
  }
  _getResultByMultipleVariables(knownYsValues, knownXsValues, constb, stats) {
    const _coefficients = getKnownsArrayCoefficients(knownYsValues, knownXsValues, knownXsValues, constb, false);
    if (_coefficients instanceof ErrorValueObject) {
      return _coefficients;
    }
    const { coefficients, X, XTXInverse } = _coefficients;
    let result = [];
    if (stats) {
      const _knownYsValues = knownYsValues.flat();
      const n = _knownYsValues.length;
      const meanY = !constb ? 0 : _knownYsValues.reduce((acc, value) => acc + value, 0) / n;
      const k = XTXInverse.length;
      const df = n - k;
      const cl = coefficients[0].length;
      const fillNa = new Array(cl - 2).fill("#N/A" /* NA */);
      const b = coefficients[0][cl - 1];
      const newY = [];
      for (let i = 0; i < X.length; i++) {
        let value = b;
        for (let j = cl - 2; j >= 0; j--) {
          value += coefficients[0][cl - 2 - j] * X[i][j];
        }
        newY.push(value);
      }
      let sstotal = 0;
      let ssresid = 0;
      for (let i = 0; i < n; i++) {
        sstotal += (_knownYsValues[i] - meanY) ** 2;
        ssresid += (_knownYsValues[i] - newY[i]) ** 2;
      }
      const ssreg = sstotal - ssresid;
      const r2 = sstotal === 0 ? 0 : ssreg / sstotal;
      const seList = [];
      for (let i = k - 1; i >= 0; i--) {
        const se = df > 0 ? Math.sqrt(ssresid / df * XTXInverse[i][i]) : 0;
        seList.push(se);
      }
      if (constb) {
        const seb = seList.shift();
        seList.push(seb);
      } else {
        seList.push("#N/A" /* NA */);
      }
      const sey = df > 0 ? Math.sqrt(ssresid / df) : 0;
      const F = df > 0 ? ssreg / (cl - 1) / (ssresid / df) : "#NUM!" /* NUM */;
      result = [
        coefficients[0],
        // [mn, mn-1, ..., m1, b]
        [...seList],
        // [sen, sen-1, ..., se1, seb]
        [r2, sey, ...fillNa],
        // [r2, sey]
        [F, df, ...fillNa],
        // [F, df]
        [ssreg, ssresid, ...fillNa]
        // [ssreg, ssresid]
      ];
    } else {
      result = [
        coefficients[0]
        // [mn, mn-1, ..., m1, b]
      ];
    }
    return ArrayValueObject.createByArray(result);
  }
  _getResultBySimpleVariables(knownYsValues, knownXsValues, constb, stats) {
    const knownYsValuesFlat = knownYsValues.flat();
    const knownXsValuesFlat = knownXsValues.flat();
    const { slope: m, intercept: b } = getSlopeAndIntercept(knownXsValuesFlat, knownYsValuesFlat, constb, false);
    if (Number.isNaN(m)) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let result = [];
    if (stats) {
      const n = knownYsValuesFlat.length;
      let meanY = 0;
      let meanX = 0;
      let df = n - 1;
      if (constb) {
        let sumY = 0;
        let sumX = 0;
        for (let i = 0; i < n; i++) {
          sumY += knownYsValuesFlat[i];
          sumX += knownXsValuesFlat[i];
        }
        meanY = sumY / n;
        meanX = sumX / n;
        df = n - 2;
      }
      let sstotal = 0;
      let ssresid = 0;
      let ssx = 0;
      for (let i = 0; i < n; i++) {
        sstotal += (knownYsValuesFlat[i] - meanY) ** 2;
        ssresid += (knownYsValuesFlat[i] - (m * knownXsValuesFlat[i] + b)) ** 2;
        ssx += (knownXsValuesFlat[i] - meanX) ** 2;
      }
      const ssreg = sstotal - ssresid;
      const r2 = ssreg === sstotal ? 1 : ssreg / sstotal;
      let se = 0;
      let seb = 0;
      let sey = 0;
      if (df > 0) {
        if (ssx > 0) {
          se = Math.sqrt(ssresid / df / ssx);
          seb = Math.sqrt(ssresid / df * (1 / n + meanX ** 2 / ssx));
        }
        sey = Math.sqrt(ssresid / df);
      }
      const F = df > 0 ? ssreg / 1 / (ssresid / df) : "#NUM!" /* NUM */;
      if (!constb) {
        seb = "#N/A" /* NA */;
      }
      result = [
        [m, b],
        // [m, b]
        [se, seb],
        // [se, seb]
        [r2, sey],
        // [r2, sey]
        [F, df],
        // [F, df]
        [ssreg, ssresid]
        // [ssreg, ssresid]
      ];
    } else {
      result = [
        [m, b]
        // [m, b]
      ];
    }
    return ArrayValueObject.createByArray(result);
  }
  _getKnownXsValues(knownYsValues, knownXs) {
    if (!knownXs || knownXs.isNull()) {
      return getSerialNumbersByRowsColumns(knownYsValues.length, knownYsValues[0].length);
    }
    return getKnownsArrayValues(knownXs);
  }
};

// ../packages/engine-formula/src/functions/statistical/logest/index.ts
var Logest = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 4);
  }
  calculate(knownYs, knownXs, constb, stats) {
    const { isError, errorObject } = checkKnownsArrayDimensions(knownYs, knownXs);
    if (isError) {
      return errorObject;
    }
    const knownYsValues = getKnownsArrayValues(knownYs);
    if (knownYsValues instanceof ErrorValueObject) {
      return knownYsValues;
    }
    const knownXsValues = this._getKnownXsValues(knownYsValues, knownXs);
    if (knownXsValues instanceof ErrorValueObject) {
      return knownXsValues;
    }
    let _constb = constb != null ? constb : BooleanValueObject.create(true);
    if (_constb.isArray()) {
      _constb = _constb.get(0, 0);
    }
    let _stats = stats != null ? stats : BooleanValueObject.create(false);
    if (_stats.isArray()) {
      _stats = _stats.get(0, 0);
    }
    const { isError: _isError, errorObject: _errorObject, variants } = checkVariantsErrorIsStringToNumber(_constb, _stats);
    if (_isError) {
      return _errorObject;
    }
    const [constbObject, statsObject] = variants;
    return this._getResult(knownYsValues, knownXsValues, +constbObject.getValue(), +statsObject.getValue());
  }
  _getResult(knownYsValues, knownXsValues, constb, stats) {
    if (knownYsValues.length === 1 && knownXsValues.length > 1 || knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
      if (knownYsValues.length === 1 && knownXsValues.length > 1) {
        const count = constb ? knownXsValues.length + 1 : knownXsValues.length;
        if (count > knownYsValues[0].length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      if (knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
        const count = constb ? knownXsValues[0].length + 1 : knownXsValues[0].length;
        if (count > knownYsValues.length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      return this._getResultByMultipleVariables(knownYsValues, knownXsValues, constb, stats);
    }
    return this._getResultBySimpleVariables(knownYsValues, knownXsValues, constb, stats);
  }
  // eslint-disable-next-line max-lines-per-function
  _getResultByMultipleVariables(knownYsValues, knownXsValues, constb, stats) {
    const _coefficients = getKnownsArrayCoefficients(knownYsValues, knownXsValues, knownXsValues, constb, true);
    if (_coefficients instanceof ErrorValueObject) {
      return _coefficients;
    }
    const { coefficients, Y, X, XTXInverse } = _coefficients;
    let result = [];
    if (stats) {
      const _knownYsValues = Y.flat();
      const n = _knownYsValues.length;
      const meanY = !constb ? 0 : _knownYsValues.reduce((acc, value) => acc + value, 0) / n;
      const k = XTXInverse.length;
      const df = n - k;
      const cl = coefficients[0].length;
      const fillNa = new Array(cl - 2).fill("#N/A" /* NA */);
      const b = coefficients[0][cl - 1];
      const newY = [];
      for (let i = 0; i < X.length; i++) {
        let value = b;
        for (let j = cl - 2; j >= 0; j--) {
          value *= coefficients[0][cl - 2 - j] ** X[i][j];
        }
        newY.push(Math.log(value));
      }
      let sstotal = 0;
      let ssresid = 0;
      for (let i = 0; i < n; i++) {
        sstotal += (_knownYsValues[i] - meanY) ** 2;
        if (!constb && !Number.isFinite(newY[i])) {
          continue;
        }
        ssresid += (_knownYsValues[i] - newY[i]) ** 2;
      }
      if (!Number.isFinite(ssresid)) {
        ssresid = 0;
      }
      const ssreg = sstotal - ssresid;
      const r2 = sstotal === 0 ? 0 : ssreg / sstotal;
      const seList = [];
      for (let i = k - 1; i >= 0; i--) {
        const se = df > 0 ? Math.sqrt(ssresid / df * XTXInverse[i][i]) : 0;
        seList.push(se);
      }
      if (constb) {
        const seb = seList.shift();
        seList.push(seb);
      } else {
        seList.push("#N/A" /* NA */);
      }
      const sey = df > 0 ? Math.sqrt(ssresid / df) : 0;
      const F = df > 0 ? ssreg / (cl - 1) / (ssresid / df) : "#NUM!" /* NUM */;
      result = [
        coefficients[0],
        // [mn, mn-1, ..., m1, b]
        [...seList],
        // [sen, sen-1, ..., se1, seb]
        [r2, sey, ...fillNa],
        // [r2, sey]
        [F, df, ...fillNa],
        // [F, df]
        [ssreg, ssresid, ...fillNa]
        // [ssreg, ssresid]
      ];
    } else {
      result = [
        coefficients[0]
        // [mn, mn-1, ..., m1, b]
      ];
    }
    return ArrayValueObject.createByArray(result);
  }
  _getResultBySimpleVariables(knownYsValues, knownXsValues, constb, stats) {
    const knownYsValuesFlat = knownYsValues.flat();
    const knownXsValuesFlat = knownXsValues.flat();
    const { slope: m, intercept: b, Y } = getSlopeAndIntercept(knownXsValuesFlat, knownYsValuesFlat, constb, true);
    if (Number.isNaN(m)) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let result = [];
    if (stats) {
      const n = Y.length;
      let meanY = 0;
      let meanX = 0;
      let df = n - 1;
      if (constb) {
        let sumY = 0;
        let sumX = 0;
        for (let i = 0; i < n; i++) {
          sumY += Y[i];
          sumX += knownXsValuesFlat[i];
        }
        meanY = sumY / n;
        meanX = sumX / n;
        df = n - 2;
      }
      let sstotal = 0;
      let ssresid = 0;
      let ssx = 0;
      for (let i = 0; i < n; i++) {
        sstotal += (Y[i] - meanY) ** 2;
        ssresid += (Y[i] - Math.log(b * m ** knownXsValuesFlat[i])) ** 2;
        ssx += (knownXsValuesFlat[i] - meanX) ** 2;
      }
      const ssreg = sstotal - ssresid;
      const r2 = sstotal === 0 ? 0 : ssreg / sstotal;
      let se = 0;
      let seb = 0;
      let sey = 0;
      let F = 0;
      if (df > 0) {
        if (ssx > 0) {
          se = Math.sqrt(ssresid / df / ssx);
          seb = Math.sqrt(ssresid / df * (1 / n + meanX ** 2 / ssx));
        }
        sey = Math.sqrt(ssresid / df);
        F = ssreg / 1 / (ssresid / df);
      }
      if (!constb) {
        seb = "#N/A" /* NA */;
      }
      result = [
        [m, b],
        // [m, b]
        [se, seb],
        // [se, seb]
        [r2, sey],
        // [r2, sey]
        [F, df],
        // [F, df]
        [ssreg, ssresid]
        // [ssreg, ssresid]
      ];
    } else {
      result = [
        [m, b]
        // [m, b]
      ];
    }
    return ArrayValueObject.createByArray(result);
  }
  _getKnownXsValues(knownYsValues, knownXs) {
    if (!knownXs || knownXs.isNull()) {
      return getSerialNumbersByRowsColumns(knownYsValues.length, knownYsValues[0].length);
    }
    return getKnownsArrayValues(knownXs);
  }
};

// ../packages/engine-formula/src/functions/statistical/lognorm-dist/index.ts
var LognormDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(x, mean, standardDev, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      mean.isArray() ? mean.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      mean.isArray() ? mean.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const meanArray = expandArrayValueObject(maxRowLength, maxColumnLength, mean, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const meanObject = meanArray.get(rowIndex, columnIndex);
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (meanObject.isError()) {
        return meanObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, meanObject, standardDevObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, meanObject, standardDevObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, meanObject, standardDevObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _meanObject, _standardDevObject, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const meanValue = +_meanObject.getValue();
    const standardDevValue = +_standardDevObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (xValue <= 0 || standardDevValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = lognormalCDF(xValue, meanValue, standardDevValue);
    } else {
      result = lognormalPDF(xValue, meanValue, standardDevValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/marginoferror/index.ts
var Marginoferror = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(range, confidence) {
    const rangeValues = this._getRangeValues(range);
    if (rangeValues instanceof ErrorValueObject) {
      return rangeValues;
    }
    const _confidence = checkVariantErrorIsArray(confidence);
    if (_confidence.isError()) {
      return _confidence;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(_confidence);
    if (isError) {
      return errorObject;
    }
    const [confidenceObject] = variants;
    const confidenceValue = +confidenceObject.getValue();
    if (confidenceValue <= 0 || confidenceValue >= 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    if (rangeValues.length < 2) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const alpha = 1 - confidenceValue;
    const size = rangeValues.length;
    const mean = rangeValues.reduce((acc, value) => acc + value, 0) / size;
    const variance = rangeValues.reduce((acc, value) => acc + (value - mean) ** 2, 0) / (size - 1);
    const standardDev = Math.sqrt(variance);
    if (standardDev <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = Math.abs(studentTINV(alpha / 2, size - 1) * standardDev / Math.sqrt(size));
    return NumberValueObject.create(result);
  }
  _getRangeValues(range) {
    const rangeValues = [];
    const rowCount = range.isArray() ? range.getRowCount() : 1;
    const columnCount = range.isArray() ? range.getColumnCount() : 1;
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = range.isArray() ? range.get(r, c) : range;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
          continue;
        }
        rangeValues.push(+valueObject.getValue());
      }
    }
    return rangeValues;
  }
};

// ../packages/engine-formula/src/functions/statistical/max/index.ts
var Max = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(Number.NEGATIVE_INFINITY);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isNull()) {
        continue;
      }
      if (variant.isString() || variant.isBoolean()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isArray()) {
        variant = variant.max();
      }
      if (variant.isError()) {
        return variant;
      }
      accumulatorAll = this._validator(accumulatorAll, variant);
    }
    if (accumulatorAll.getValue() === Number.NEGATIVE_INFINITY) {
      return NumberValueObject.create(0);
    }
    return accumulatorAll;
  }
  _validator(accumulatorAll, valueObject) {
    const validator = accumulatorAll.isLessThan(valueObject);
    let _accumulatorAll = accumulatorAll;
    if (validator.getValue()) {
      _accumulatorAll = valueObject;
    }
    return _accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/statistical/maxa/index.ts
var Maxa = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(Number.NEGATIVE_INFINITY);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isNull()) {
        continue;
      }
      if (variant.isString() || variant.isBoolean()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        variant.iterator((valueObject) => {
          let _valueObject = valueObject;
          if (_valueObject == null || _valueObject.isNull() || _valueObject.isString()) {
            _valueObject = NumberValueObject.create(0);
          }
          if (_valueObject.isBoolean()) {
            _valueObject = _valueObject.convertToNumberObjectValue();
          }
          if (_valueObject.isError()) {
            accumulatorAll = _valueObject;
            return false;
          }
          accumulatorAll = this._validator(accumulatorAll, _valueObject);
        });
      }
      if (accumulatorAll.isError()) {
        return accumulatorAll;
      }
      accumulatorAll = this._validator(accumulatorAll, variant);
    }
    if (accumulatorAll.getValue() === Number.NEGATIVE_INFINITY) {
      return NumberValueObject.create(0);
    }
    return accumulatorAll;
  }
  _validator(accumulatorAll, valueObject) {
    const validator = accumulatorAll.isLessThan(valueObject);
    let _accumulatorAll = accumulatorAll;
    if (validator.getValue()) {
      _accumulatorAll = valueObject;
    }
    return _accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/statistical/maxifs/index.ts
var Maxifs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 255);
  }
  calculate(maxRange, ...variants) {
    if (maxRange.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (!maxRange.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.length % 2 !== 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.some((variant, i) => i % 2 === 0 && !variant.isArray())) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const { maxRowLength, maxColumnLength } = calculateMaxDimensions(variants);
    const errorArray = getErrorArray(variants, maxRange, maxRowLength, maxColumnLength);
    if (errorArray) {
      return errorArray;
    }
    const booleanResults = getBooleanResults(variants, maxRowLength, maxColumnLength, true);
    return this._aggregateResults(maxRange, booleanResults);
  }
  _aggregateResults(maxRange, booleanResults) {
    const maxResults = booleanResults.map((row) => {
      return row.map((booleanResult) => {
        const picked = maxRange.pick(booleanResult);
        if (picked.getColumnCount() === 0) {
          return ArrayValueObject.create("0");
        }
        return picked.max();
      });
    });
    const arrayValueObjectData = {
      calculateValueList: maxResults,
      rowCount: maxResults.length,
      columnCount: maxResults[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};

// ../packages/engine-formula/src/functions/statistical/median/index.ts
var Median = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const values = [];
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isArray()) {
        let isError = false;
        let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
        variant.iterator((valueObject) => {
          if (valueObject == null ? void 0 : valueObject.isError()) {
            isError = true;
            errorObject = valueObject;
            return false;
          }
          if ((valueObject == null ? void 0 : valueObject.isNull()) || (valueObject == null ? void 0 : valueObject.isBoolean())) {
            return true;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            return true;
          }
          values.push(+value);
        });
        if (isError) {
          return errorObject;
        }
      } else {
        if (variant.isError()) {
          return variant;
        }
        if (variant.isNull() || variant.isBoolean()) {
          continue;
        }
        if (variant.isString()) {
          const _variant = variant.convertToNumberObjectValue();
          if (_variant.isError()) {
            return _variant;
          }
        }
        const value = variant.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return this._getResult(values.sort((a2, b) => a2 - b));
  }
  _getResult(values) {
    const n = values.length;
    let result;
    if (n % 2 === 0) {
      const mid = n / 2;
      result = (values[mid - 1] + values[mid]) / 2;
    } else {
      result = values[Math.floor(n / 2)];
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/min/index.ts
var Min = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(Number.POSITIVE_INFINITY);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isNull()) {
        continue;
      }
      if (variant.isString() || variant.isBoolean()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isArray()) {
        variant = variant.min();
      }
      if (variant.isError()) {
        return variant;
      }
      accumulatorAll = this._validator(accumulatorAll, variant);
    }
    if (accumulatorAll.getValue() === Number.POSITIVE_INFINITY) {
      return NumberValueObject.create(0);
    }
    return accumulatorAll;
  }
  _validator(accumulatorAll, valueObject) {
    const validator = accumulatorAll.isGreaterThan(valueObject);
    let _accumulatorAll = accumulatorAll;
    if (validator.getValue()) {
      _accumulatorAll = valueObject;
    }
    return _accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/statistical/mina/index.ts
var Mina = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    let accumulatorAll = NumberValueObject.create(Number.POSITIVE_INFINITY);
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isNull()) {
        continue;
      }
      if (variant.isString() || variant.isBoolean()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        variant.iterator((valueObject) => {
          let _valueObject = valueObject;
          if (_valueObject == null || _valueObject.isNull() || _valueObject.isString()) {
            _valueObject = NumberValueObject.create(0);
          }
          if (_valueObject.isBoolean()) {
            _valueObject = _valueObject.convertToNumberObjectValue();
          }
          if (_valueObject.isError()) {
            accumulatorAll = _valueObject;
            return false;
          }
          accumulatorAll = this._validator(accumulatorAll, _valueObject);
        });
      }
      if (accumulatorAll.isError()) {
        return accumulatorAll;
      }
      accumulatorAll = this._validator(accumulatorAll, variant);
    }
    if (accumulatorAll.getValue() === Number.POSITIVE_INFINITY) {
      return NumberValueObject.create(0);
    }
    return accumulatorAll;
  }
  _validator(accumulatorAll, valueObject) {
    const validator = accumulatorAll.isGreaterThan(valueObject);
    let _accumulatorAll = accumulatorAll;
    if (validator.getValue()) {
      _accumulatorAll = valueObject;
    }
    return _accumulatorAll;
  }
};

// ../packages/engine-formula/src/functions/statistical/minifs/index.ts
var Minifs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 255);
  }
  calculate(minRange, ...variants) {
    if (minRange.isError()) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (!minRange.isArray()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.length % 2 !== 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (variants.some((variant, i) => i % 2 === 0 && !variant.isArray())) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const { maxRowLength, maxColumnLength } = calculateMaxDimensions(variants);
    const errorArray = getErrorArray(variants, minRange, maxRowLength, maxColumnLength);
    if (errorArray) {
      return errorArray;
    }
    const booleanResults = getBooleanResults(variants, maxRowLength, maxColumnLength, true);
    return this._aggregateResults(minRange, booleanResults);
  }
  _aggregateResults(minRange, booleanResults) {
    const maxResults = booleanResults.map((row) => {
      return row.map((booleanResult) => {
        const picked = minRange.pick(booleanResult);
        if (picked.getColumnCount() === 0) {
          return ArrayValueObject.create("0");
        }
        return picked.min();
      });
    });
    const arrayValueObjectData = {
      calculateValueList: maxResults,
      rowCount: maxResults.length,
      columnCount: maxResults[0].length,
      unitId: this.unitId || "",
      sheetId: this.subUnitId || "",
      row: this.row,
      column: this.column
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }
};

// ../packages/engine-formula/src/functions/statistical/mode-mult/index.ts
var ModeMult = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const valueMap = {};
    let order = 0;
    let maxCount = 1;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (variant.isString()) {
        const _variant = variant.convertToNumberObjectValue();
        if (_variant.isError()) {
          return _variant;
        }
      }
      const rowCount = variant.isArray() ? variant.getRowCount() : 1;
      const columnCount = variant.isArray() ? variant.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const valueObject = variant.isArray() ? variant.get(r, c) : variant;
          if (valueObject.isError()) {
            return valueObject;
          }
          if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
            continue;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            continue;
          }
          if (valueMap[+value]) {
            valueMap[+value].count++;
            if (valueMap[+value].count > maxCount) {
              maxCount = valueMap[+value].count;
            }
          } else {
            valueMap[+value] = { count: 1, order: order++ };
          }
        }
      }
    }
    if (order === 0 || maxCount === 1) {
      return new ErrorValueObject("#N/A" /* NA */);
    }
    return this._getResult(valueMap, maxCount);
  }
  _getResult(valueMap, maxCount) {
    const result = Object.entries(valueMap).filter(([_, { count }]) => count === maxCount).sort((a2, b) => a2[1].order - b[1].order).map(([value]) => +value);
    if (result.length === 1) {
      return NumberValueObject.create(result[0]);
    }
    return ArrayValueObject.createByArray(result.map((value) => [value]));
  }
};

// ../packages/engine-formula/src/functions/statistical/negbinom-dist/index.ts
var NegbinomDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(numberF, numberS, probabilityS, cumulative) {
    const maxRowLength = Math.max(
      numberF.isArray() ? numberF.getRowCount() : 1,
      numberS.isArray() ? numberS.getRowCount() : 1,
      probabilityS.isArray() ? probabilityS.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      numberF.isArray() ? numberF.getColumnCount() : 1,
      numberS.isArray() ? numberS.getColumnCount() : 1,
      probabilityS.isArray() ? probabilityS.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const numberFArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberF, ErrorValueObject.create("#N/A" /* NA */));
    const numberSArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberS, ErrorValueObject.create("#N/A" /* NA */));
    const probabilitySArray = expandArrayValueObject(maxRowLength, maxColumnLength, probabilityS, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberFArray.mapValue((numberFObject, rowIndex, columnIndex) => {
      const numberSObject = numberSArray.get(rowIndex, columnIndex);
      const probabilitySObject = probabilitySArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (numberFObject.isError()) {
        return numberFObject;
      }
      if (numberSObject.isError()) {
        return numberSObject;
      }
      if (probabilitySObject.isError()) {
        return probabilitySObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(numberFObject, numberSObject, probabilitySObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(numberFObject, numberSObject, probabilitySObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numberFObject, numberSObject, probabilitySObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_numberFObject, _numberSObject, _probabilitySObject, _cumulativeObject] = variants;
    const numberFValue = Math.floor(+_numberFObject.getValue());
    const numberSValue = Math.floor(+_numberSObject.getValue());
    const probabilitySValue = +_probabilitySObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    if (numberFValue < 0 || numberSValue < 1 || probabilitySValue <= 0 || probabilitySValue >= 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = negbinomialCDF(numberFValue, numberSValue, probabilitySValue);
    } else {
      result = negbinomialPDF(numberFValue, numberSValue, probabilitySValue);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/norm-s-dist/index.ts
var NormSDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(z, cumulative) {
    const maxRowLength = Math.max(
      z.isArray() ? z.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      z.isArray() ? z.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const zArray = expandArrayValueObject(maxRowLength, maxColumnLength, z, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = zArray.mapValue((zObject, rowIndex, columnIndex) => {
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (zObject.isError()) {
        return zObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(zObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(zObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(zObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_zObject, _cumulativeObject] = variants;
    const zValue = +_zObject.getValue();
    const cumulativeValue = +_cumulativeObject.getValue();
    let result;
    if (cumulativeValue) {
      result = normalCDF(zValue, 0, 1);
    } else {
      result = normalPDF(zValue, 0, 1);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/pearson/index.ts
var Pearson = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array1, array2) {
    const array1RowCount = array1.isArray() ? array1.getRowCount() : 1;
    const array1ColumnCount = array1.isArray() ? array1.getColumnCount() : 1;
    const array2RowCount = array2.isArray() ? array2.getRowCount() : 1;
    const array2ColumnCount = array2.isArray() ? array2.getColumnCount() : 1;
    let _array1 = array1;
    if (array1.isArray() && array1RowCount === 1 && array1ColumnCount === 1) {
      _array1 = array1.get(0, 0);
    }
    if (_array1.isError()) {
      return _array1;
    }
    let _array2 = array2;
    if (array2.isArray() && array2RowCount === 1 && array2ColumnCount === 1) {
      _array2 = array2.get(0, 0);
    }
    if (_array2.isError()) {
      return _array2;
    }
    if (array1RowCount * array1ColumnCount === 1 || array2RowCount * array2ColumnCount === 1) {
      if (_array1.isNull() || _array2.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    if (array1RowCount * array1ColumnCount !== array2RowCount * array2ColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      array1,
      array2,
      array1RowCount * array1ColumnCount,
      array1ColumnCount,
      array2ColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(array1, array2) {
    const n = array1.length;
    let sumX = 0;
    let sumY = 0;
    for (let i = 0; i < n; i++) {
      sumX += array1[i];
      sumY += array2[i];
    }
    const meanX = sumX / n;
    const meanY = sumY / n;
    let num = 0;
    let den1 = 0;
    let den2 = 0;
    for (let i = 0; i < n; i++) {
      num += (array1[i] - meanX) * (array2[i] - meanY);
      den1 += (array1[i] - meanX) ** 2;
      den2 += (array2[i] - meanY) ** 2;
    }
    if (den1 === 0 || den2 === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = num / Math.sqrt(den1 * den2);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/percentile-exc/index.ts
var PercentileExc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, k) {
    const arrayValues = this._getValues(array);
    if (k.isArray()) {
      const resultArray = k.mapValue((kObject) => this._handleSingleObject(arrayValues, kObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(arrayValues, k);
  }
  _handleSingleObject(array, k) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(k);
    if (isError) {
      return errorObject;
    }
    const [kObject] = variants;
    const kValue = +kObject.getValue();
    const n = array.length;
    if (kValue < 1 / (n + 1) || kValue > 1 - 1 / (n + 1)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const kValueIndex = kValue * (n + 1) - 1;
    const integerPart = Math.floor(kValueIndex);
    const fractionPart = kValueIndex - integerPart;
    if (fractionPart === 0) {
      return NumberValueObject.create(array[integerPart]);
    }
    const result = array[integerPart] + fractionPart * (array[integerPart + 1] - array[integerPart]);
    return NumberValueObject.create(result);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/percentrank-exc/index.ts
var PercentrankExc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(array, x, significance) {
    const arrayValues = this._getValues(array);
    let _significance = significance != null ? significance : NumberValueObject.create(3);
    if (_significance.isNull()) {
      _significance = NumberValueObject.create(3);
    }
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      _significance.isArray() ? _significance.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      _significance.isArray() ? _significance.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const significanceArray = expandArrayValueObject(maxRowLength, maxColumnLength, _significance, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const significanceObject = significanceArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (significanceObject.isError()) {
        return significanceObject;
      }
      return this._handleSingleObject(arrayValues, xObject, significanceObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(array, x, significance) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(x, significance);
    if (isError) {
      return errorObject;
    }
    const [xObject, significanceObject] = variants;
    const xValue = +xObject.getValue();
    const significanceValue = Math.floor(+significanceObject.getValue());
    const n = array.length;
    if (n === 0 || xValue < array[0] || xValue > array[n - 1]) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (n === 1) {
      if (xValue === array[0]) {
        return NumberValueObject.create(1);
      } else {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
    }
    let result = 0;
    let match = false;
    let i = 0;
    while (!match && i < n) {
      if (xValue === array[i]) {
        result = (i + 1) / (n + 1);
        match = true;
      } else if (xValue > array[i] && i + 1 < n && xValue < array[i + 1]) {
        result = (i + 1 + (xValue - array[i]) / (array[i + 1] - array[i])) / (n + 1);
        match = true;
      }
      i++;
    }
    if (!match) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (significanceValue < 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    result = floor2(result, significanceValue);
    return NumberValueObject.create(result);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/permut/index.ts
var Permut = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numberChosen) {
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      numberChosen.isArray() ? numberChosen.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      numberChosen.isArray() ? numberChosen.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const numberChosenArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberChosen, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      const numberChosenObject = numberChosenArray.get(rowIndex, columnIndex);
      if (numberObject.isError()) {
        return numberObject;
      }
      if (numberChosenObject.isError()) {
        return numberChosenObject;
      }
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numberObject, numberChosenObject);
      if (isError) {
        return errorObject;
      }
      const [_numberObject, _numberChosenObject] = variants;
      const numberValue = Math.floor(+_numberObject.getValue());
      const numberChosenValue = Math.floor(+_numberChosenObject.getValue());
      if (numberValue < 0 || numberValue >= 2147483647 || numberChosenValue < 0 || numberValue < numberChosenValue) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      let result = 1;
      for (let i = numberValue - numberChosenValue + 1; i <= numberValue; i++) {
        result *= i;
      }
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/statistical/permutationa/index.ts
var Permutationa = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, numberChosen) {
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      numberChosen.isArray() ? numberChosen.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      numberChosen.isArray() ? numberChosen.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const numberChosenArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberChosen, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      const numberChosenObject = numberChosenArray.get(rowIndex, columnIndex);
      if (numberObject.isError()) {
        return numberObject;
      }
      if (numberChosenObject.isError()) {
        return numberChosenObject;
      }
      const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numberObject, numberChosenObject);
      if (isError) {
        return errorObject;
      }
      const [_numberObject, _numberChosenObject] = variants;
      const numberValue = Math.floor(+_numberObject.getValue());
      const numberChosenValue = Math.floor(+_numberChosenObject.getValue());
      if (numberValue < 0 || numberValue >= 2147483647 || numberChosenValue < 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (numberValue === 0) {
        if (numberChosenValue === 0) {
          return NumberValueObject.create(1);
        } else {
          return NumberValueObject.create(0);
        }
      }
      const result = numberValue ** numberChosenValue;
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/statistical/phi/index.ts
var Phi = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(x) {
    if (x.isArray()) {
      const resultArray = x.mapValue((xObject) => this._handleSingleObject(xObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(x);
  }
  _handleSingleObject(x) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(x);
    if (isError) {
      return errorObject;
    }
    const [xObject] = variants;
    const xValue = +xObject.getValue();
    const result = Math.exp(-0.5 * xValue * xValue) / Math.sqrt(2 * Math.PI);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/prob/index.ts
var Prob = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(xRange, probRange, lowerLimit, upperLimit) {
    const { isError, errorObject, xRangeValues, probRangeValues } = this._handleXRangeAndProbRange(xRange, probRange);
    let _upperLimit = upperLimit != null ? upperLimit : lowerLimit;
    if (upperLimit == null ? void 0 : upperLimit.isNull()) {
      _upperLimit = lowerLimit;
    }
    const maxRowLength = Math.max(
      lowerLimit.isArray() ? lowerLimit.getRowCount() : 1,
      _upperLimit.isArray() ? _upperLimit.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      lowerLimit.isArray() ? lowerLimit.getColumnCount() : 1,
      _upperLimit.isArray() ? _upperLimit.getColumnCount() : 1
    );
    const lowerLimitArray = expandArrayValueObject(maxRowLength, maxColumnLength, lowerLimit, ErrorValueObject.create("#N/A" /* NA */));
    const upperLimitArray = expandArrayValueObject(maxRowLength, maxColumnLength, _upperLimit, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = lowerLimitArray.mapValue((lowerLimitObject, rowIndex, columnIndex) => {
      const upperLimitObject = upperLimitArray.get(rowIndex, columnIndex);
      if (xRange.isError()) {
        return xRange;
      }
      if (probRange.isError()) {
        return probRange;
      }
      if (lowerLimitObject.isError()) {
        return lowerLimitObject;
      }
      if (upperLimitObject.isError()) {
        return upperLimitObject;
      }
      if (isError) {
        return errorObject;
      }
      return this._handleSignleObject(xRangeValues, probRangeValues, lowerLimitObject, upperLimitObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xRangeValues, probRangeValues, lowerLimit, upperLimit) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(lowerLimit, upperLimit);
    if (isError) {
      return errorObject;
    }
    const [lowerLimitObject, upperLimitObject] = variants;
    const lowerLimitValue = +lowerLimitObject.getValue();
    const upperLimitValue = +upperLimitObject.getValue();
    if (probRangeValues.reduce((acc, val) => acc + val, 0) !== 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let sum2 = 0;
    for (let i = 0; i < xRangeValues.length; i++) {
      if (xRangeValues[i] >= lowerLimitValue && xRangeValues[i] <= upperLimitValue) {
        sum2 += probRangeValues[i];
      }
    }
    return NumberValueObject.create(sum2);
  }
  // eslint-disable-next-line
  _handleXRangeAndProbRange(xRange, probRange) {
    const xRangeRowCount = xRange.isArray() ? xRange.getRowCount() : 1;
    const xRangeColumnCount = xRange.isArray() ? xRange.getColumnCount() : 1;
    const probRangeRowCount = probRange.isArray() ? probRange.getRowCount() : 1;
    const probRangeColumnCount = probRange.isArray() ? probRange.getColumnCount() : 1;
    let _xRange = xRange;
    if (xRange.isArray() && xRangeRowCount === 1 && xRangeColumnCount === 1) {
      _xRange = xRange.get(0, 0);
    }
    if (_xRange.isError()) {
      return {
        isError: true,
        errorObject: _xRange,
        xRangeValues: [],
        probRangeValues: []
      };
    }
    let _probRange = probRange;
    if (probRange.isArray() && probRangeRowCount === 1 && probRangeColumnCount === 1) {
      _probRange = probRange.get(0, 0);
    }
    if (_probRange.isError()) {
      return {
        isError: true,
        errorObject: _probRange,
        xRangeValues: [],
        probRangeValues: []
      };
    }
    if (xRangeRowCount * xRangeColumnCount === 1 || probRangeRowCount * probRangeColumnCount === 1) {
      if (_xRange.isNull() || _probRange.isNull()) {
        return {
          isError: true,
          errorObject: ErrorValueObject.create("#VALUE!" /* VALUE */),
          xRangeValues: [],
          probRangeValues: []
        };
      }
    }
    if (xRangeRowCount * xRangeColumnCount !== probRangeRowCount * probRangeColumnCount) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#N/A" /* NA */),
        xRangeValues: [],
        probRangeValues: []
      };
    }
    const {
      isError,
      errorObject,
      array1Values: xRangeValues,
      array2Values: probRangeValues,
      noCalculate
    } = getTwoArrayNumberValues(
      xRange,
      probRange,
      xRangeRowCount * xRangeColumnCount,
      xRangeColumnCount,
      probRangeColumnCount
    );
    if (isError) {
      return {
        isError: true,
        errorObject,
        xRangeValues: [],
        probRangeValues: []
      };
    }
    if (noCalculate) {
      return {
        isError: true,
        errorObject: ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */),
        xRangeValues: [],
        probRangeValues: []
      };
    }
    return {
      isError: false,
      errorObject: null,
      xRangeValues,
      probRangeValues
    };
  }
};

// ../packages/engine-formula/src/functions/statistical/quartile-exc/index.ts
var QuartileExc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, quart) {
    const arrayValues = this._getValues(array);
    if (quart.isArray()) {
      const resultArray = quart.mapValue((quartObject) => this._handleSingleObject(arrayValues, quartObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(arrayValues, quart);
  }
  _handleSingleObject(array, quart) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(quart);
    if (isError) {
      return errorObject;
    }
    const [quartObject] = variants;
    const quartValue = Math.floor(+quartObject.getValue());
    if (quartValue <= 0 || quartValue >= 4) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const k = quartValue / 4;
    const n = array.length;
    if (k < 1 / (n + 1) || k > 1 - 1 / (n + 1)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const kIndex = k * (n + 1) - 1;
    const integerPart = Math.floor(kIndex);
    const fractionPart = kIndex - integerPart;
    if (fractionPart === 0) {
      return NumberValueObject.create(array[integerPart]);
    }
    const result = array[integerPart] + fractionPart * (array[integerPart + 1] - array[integerPart]);
    return NumberValueObject.create(result);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/rank-avg/index.ts
var RankAvg = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(number, ref, order) {
    let _number = number;
    if (_number.isReferenceObject()) {
      _number = _number.toArrayValueObject();
    }
    const { refHasError, refErrorObject, refNumbers } = this._checkRefReferenceObject(ref);
    let _order = order != null ? order : NumberValueObject.create(0);
    if (_order.isReferenceObject()) {
      _order = _order.toArrayValueObject();
    }
    const maxRowLength = Math.max(
      _number.isArray() ? _number.getRowCount() : 1,
      _order.isArray() ? _order.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _number.isArray() ? _number.getColumnCount() : 1,
      _order.isArray() ? _order.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, _number, ErrorValueObject.create("#N/A" /* NA */));
    const orderArray = expandArrayValueObject(maxRowLength, maxColumnLength, _order, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      const orderObject = orderArray.get(rowIndex, columnIndex);
      if (!number.isReferenceObject() && number.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (refHasError) {
        return refErrorObject;
      }
      if (orderObject.isError()) {
        return orderObject;
      }
      const numberValue = +numberObject.getValue();
      const orderValue = +orderObject.getValue();
      if (Number.isNaN(numberValue) || Number.isNaN(orderValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return this._getResult(numberValue, orderValue, refNumbers);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResult(numberValue, orderValue, refNumbers) {
    const refOrderNumbers = refNumbers.sort((a2, b) => !orderValue ? b - a2 : a2 - b);
    let index = refOrderNumbers.indexOf(numberValue);
    const results = [];
    while (index >= 0) {
      const start = index + 1;
      results.push(start);
      index = refOrderNumbers.indexOf(numberValue, start);
    }
    if (results.length === 0) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const result = results.reduce((acc, cur) => acc + cur, 0) / results.length;
    return NumberValueObject.create(result);
  }
  _checkRefReferenceObject(ref) {
    let refHasError = false;
    let refErrorObject = ErrorValueObject.create("#N/A" /* NA */);
    const refNumbers = [];
    if (!ref.isReferenceObject()) {
      return {
        refHasError: true,
        refErrorObject,
        refNumbers
      };
    }
    const _ref = ref.toArrayValueObject();
    _ref.iterator((refObject) => {
      const _refObject = refObject;
      if (_refObject.isError()) {
        refHasError = true;
        refErrorObject = _refObject;
        return false;
      }
      if (_refObject.isNull() || _refObject.isBoolean()) {
        return true;
      }
      const refValue = +_refObject.getValue();
      if (Number.isNaN(refValue)) {
        return true;
      }
      refNumbers.push(refValue);
    });
    return {
      refHasError,
      refErrorObject,
      refNumbers
    };
  }
};

// ../packages/engine-formula/src/functions/statistical/rank-eq/index.ts
var RankEq = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(number, ref, order) {
    let _number = number;
    if (_number.isReferenceObject()) {
      _number = _number.toArrayValueObject();
    }
    const { refHasError, refErrorObject, refNumbers } = this._checkRefReferenceObject(ref);
    let _order = order != null ? order : NumberValueObject.create(0);
    if (_order.isReferenceObject()) {
      _order = _order.toArrayValueObject();
    }
    const maxRowLength = Math.max(
      _number.isArray() ? _number.getRowCount() : 1,
      _order.isArray() ? _order.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      _number.isArray() ? _number.getColumnCount() : 1,
      _order.isArray() ? _order.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, _number, ErrorValueObject.create("#N/A" /* NA */));
    const orderArray = expandArrayValueObject(maxRowLength, maxColumnLength, _order, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.map((numberObject, rowIndex, columnIndex) => {
      const orderObject = orderArray.get(rowIndex, columnIndex);
      if (!number.isReferenceObject() && number.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (refHasError) {
        return refErrorObject;
      }
      if (orderObject.isError()) {
        return orderObject;
      }
      const numberValue = +numberObject.getValue();
      const orderValue = +orderObject.getValue();
      if (Number.isNaN(numberValue) || Number.isNaN(orderValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const refOrderNumbers = refNumbers.sort((a2, b) => !orderValue ? b - a2 : a2 - b);
      const result = refOrderNumbers.indexOf(numberValue);
      if (result === -1) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return NumberValueObject.create(result + 1);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _checkRefReferenceObject(ref) {
    let refHasError = false;
    let refErrorObject = ErrorValueObject.create("#N/A" /* NA */);
    const refNumbers = [];
    if (!ref.isReferenceObject()) {
      return {
        refHasError: true,
        refErrorObject,
        refNumbers
      };
    }
    const _ref = ref.toArrayValueObject();
    _ref.iterator((refObject) => {
      const _refObject = refObject;
      if (_refObject.isError()) {
        refHasError = true;
        refErrorObject = _refObject;
        return false;
      }
      if (_refObject.isNull() || _refObject.isBoolean()) {
        return true;
      }
      const refValue = +_refObject.getValue();
      if (Number.isNaN(refValue)) {
        return true;
      }
      refNumbers.push(refValue);
    });
    return {
      refHasError,
      refErrorObject,
      refNumbers
    };
  }
};

// ../packages/engine-formula/src/functions/statistical/rsq/index.ts
var Rsq = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array1, array2) {
    const array1RowCount = array1.isArray() ? array1.getRowCount() : 1;
    const array1ColumnCount = array1.isArray() ? array1.getColumnCount() : 1;
    const array2RowCount = array2.isArray() ? array2.getRowCount() : 1;
    const array2ColumnCount = array2.isArray() ? array2.getColumnCount() : 1;
    let _array1 = array1;
    if (array1.isArray() && array1RowCount === 1 && array1ColumnCount === 1) {
      _array1 = array1.get(0, 0);
    }
    if (_array1.isError()) {
      return _array1;
    }
    let _array2 = array2;
    if (array2.isArray() && array2RowCount === 1 && array2ColumnCount === 1) {
      _array2 = array2.get(0, 0);
    }
    if (_array2.isError()) {
      return _array2;
    }
    if (array1RowCount * array1ColumnCount === 1 || array2RowCount * array2ColumnCount === 1) {
      if (_array1.isNull() || _array2.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    if (array1RowCount * array1ColumnCount !== array2RowCount * array2ColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      array1,
      array2,
      array1RowCount * array1ColumnCount,
      array1ColumnCount,
      array2ColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(array1, array2) {
    if (array1.length === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const n = array1.length;
    let sumX = 0;
    let sumY = 0;
    for (let i = 0; i < n; i++) {
      sumX += array1[i];
      sumY += array2[i];
    }
    const meanX = sumX / n;
    const meanY = sumY / n;
    let num = 0;
    let den1 = 0;
    let den2 = 0;
    for (let i = 0; i < n; i++) {
      num += (array1[i] - meanX) * (array2[i] - meanY);
      den1 += (array1[i] - meanX) ** 2;
      den2 += (array2[i] - meanY) ** 2;
    }
    if (den1 === 0 || den2 === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = (num / Math.sqrt(den1 * den2)) ** 2;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/skew/index.ts
var Skew = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const values = [];
    let sum2 = 0;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (variant.isString()) {
        const _variant = variant.convertToNumberObjectValue();
        if (_variant.isError()) {
          return _variant;
        }
      }
      const rowCount = variant.isArray() ? variant.getRowCount() : 1;
      const columnCount = variant.isArray() ? variant.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const valueObject = variant.isArray() ? variant.get(r, c) : variant;
          if (valueObject.isError()) {
            return valueObject;
          }
          if (valueObject.isNull() || valueObject.isBoolean()) {
            continue;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            continue;
          }
          values.push(+value);
          sum2 += +value;
        }
      }
    }
    if (values.length <= 2) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(values, sum2);
  }
  _getResult(values, sum2) {
    const n = values.length;
    const mean = sum2 / n;
    let sum22 = 0;
    for (let i = 0; i < n; i++) {
      sum22 += (values[i] - mean) ** 2;
    }
    const stdev = Math.sqrt(sum22 / (n - 1));
    if (stdev === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    let sum3 = 0;
    for (let i = 0; i < n; i++) {
      sum3 += ((values[i] - mean) / stdev) ** 3;
    }
    const result = n / ((n - 1) * (n - 2)) * sum3;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/skew-p/index.ts
var SkewP = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const values = [];
    let sum2 = 0;
    for (let i = 0; i < variants.length; i++) {
      const variant = variants[i];
      if (variant.isError()) {
        return variant;
      }
      if (variant.isString()) {
        const _variant = variant.convertToNumberObjectValue();
        if (_variant.isError()) {
          return _variant;
        }
      }
      const rowCount = variant.isArray() ? variant.getRowCount() : 1;
      const columnCount = variant.isArray() ? variant.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const valueObject = variant.isArray() ? variant.get(r, c) : variant;
          if (valueObject.isError()) {
            return valueObject;
          }
          if (valueObject.isNull() || valueObject.isBoolean()) {
            continue;
          }
          const value = valueObject.getValue();
          if (!isRealNum(value)) {
            continue;
          }
          values.push(+value);
          sum2 += +value;
        }
      }
    }
    if (values.length <= 2) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(values, sum2);
  }
  _getResult(values, sum2) {
    const n = values.length;
    const mean = sum2 / n;
    let sum22 = 0;
    for (let i = 0; i < n; i++) {
      sum22 += (values[i] - mean) ** 2;
    }
    const stdev = Math.sqrt(sum22 / n);
    if (stdev === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    let sum3 = 0;
    for (let i = 0; i < n; i++) {
      sum3 += ((values[i] - mean) / stdev) ** 3;
    }
    const result = sum3 / n;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/slope/index.ts
var Slope = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(knownYs, knownXs) {
    const knownYsRowCount = knownYs.isArray() ? knownYs.getRowCount() : 1;
    const knownYsColumnCount = knownYs.isArray() ? knownYs.getColumnCount() : 1;
    const knownXsRowCount = knownXs.isArray() ? knownXs.getRowCount() : 1;
    const knownXsColumnCount = knownXs.isArray() ? knownXs.getColumnCount() : 1;
    let _knownYs = knownYs;
    if (knownYs.isArray() && knownYsRowCount === 1 && knownYsColumnCount === 1) {
      _knownYs = knownYs.get(0, 0);
    }
    if (_knownYs.isError()) {
      return _knownYs;
    }
    let _knownXs = knownXs;
    if (knownXs.isArray() && knownXsRowCount === 1 && knownXsColumnCount === 1) {
      _knownXs = knownXs.get(0, 0);
    }
    if (_knownXs.isError()) {
      return _knownXs;
    }
    if (knownYsRowCount * knownYsColumnCount === 1 || knownXsRowCount * knownXsColumnCount === 1) {
      if (_knownYs.isNull() || _knownXs.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    if (knownYsRowCount * knownYsColumnCount !== knownXsRowCount * knownXsColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      knownYs,
      knownXs,
      knownYsRowCount * knownYsColumnCount,
      knownYsColumnCount,
      knownXsColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(knownYs, knownXs) {
    const n = knownYs.length;
    let knownYsSum = 0;
    let knownXsSum = 0;
    for (let i = 0; i < n; i++) {
      knownYsSum += knownYs[i];
      knownXsSum += knownXs[i];
    }
    const knownYsMean = knownYsSum / n;
    const knownXsMean = knownXsSum / n;
    let num = 0;
    let den = 0;
    for (let i = 0; i < n; i++) {
      num += (knownYs[i] - knownYsMean) * (knownXs[i] - knownXsMean);
      den += (knownXs[i] - knownXsMean) ** 2;
    }
    if (den === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = num / den;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/small/index.ts
var Small = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, k) {
    const arrayValues = this._getValues(array);
    if (k.isArray()) {
      const resultArray = k.mapValue((kObject) => this._handleSingleObject(arrayValues, kObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(arrayValues, k);
  }
  _handleSingleObject(array, k) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(k);
    if (isError) {
      return errorObject;
    }
    const [kObject] = variants;
    let kValue = +kObject.getValue();
    if (kValue < 1 || kValue > array.length) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    kValue = Math.floor(kValue);
    return NumberValueObject.create(array[kValue - 1]);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean() || valueObject.isString()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/standardize/index.ts
var Standardize = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, mean, standardDev) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      mean.isArray() ? mean.getRowCount() : 1,
      standardDev.isArray() ? standardDev.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      mean.isArray() ? mean.getColumnCount() : 1,
      standardDev.isArray() ? standardDev.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const meanArray = expandArrayValueObject(maxRowLength, maxColumnLength, mean, ErrorValueObject.create("#N/A" /* NA */));
    const standardDevArray = expandArrayValueObject(maxRowLength, maxColumnLength, standardDev, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const meanObject = meanArray.get(rowIndex, columnIndex);
      const standardDevObject = standardDevArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (meanObject.isError()) {
        return meanObject;
      }
      if (standardDevObject.isError()) {
        return standardDevObject;
      }
      return this._handleSignleObject(xObject, meanObject, standardDevObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, meanObject, standardDevObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, meanObject, standardDevObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _meanObject, _standardDevObject] = variants;
    const xValue = +_xObject.getValue();
    const meanValue = +_meanObject.getValue();
    const standardDevValue = +_standardDevObject.getValue();
    if (standardDevValue <= 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = (xValue - meanValue) / standardDevValue;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/stdeva/index.ts
var Stdeva = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants, false);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.std(1);
  }
};

// ../packages/engine-formula/src/functions/statistical/stdevpa/index.ts
var Stdevpa = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants, false);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.std();
  }
};

// ../packages/engine-formula/src/functions/statistical/steyx/index.ts
var Steyx = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(knownYs, knownXs) {
    const knownYsRowCount = knownYs.isArray() ? knownYs.getRowCount() : 1;
    const knownYsColumnCount = knownYs.isArray() ? knownYs.getColumnCount() : 1;
    const knownXsRowCount = knownXs.isArray() ? knownXs.getRowCount() : 1;
    const knownXsColumnCount = knownXs.isArray() ? knownXs.getColumnCount() : 1;
    let _knownYs = knownYs;
    if (knownYs.isArray() && knownYsRowCount === 1 && knownYsColumnCount === 1) {
      _knownYs = knownYs.get(0, 0);
    }
    if (_knownYs.isError()) {
      return _knownYs;
    }
    let _knownXs = knownXs;
    if (knownXs.isArray() && knownXsRowCount === 1 && knownXsColumnCount === 1) {
      _knownXs = knownXs.get(0, 0);
    }
    if (_knownXs.isError()) {
      return _knownXs;
    }
    if (knownYsRowCount * knownYsColumnCount === 1 || knownXsRowCount * knownXsColumnCount === 1) {
      if (_knownYs.isNull() || _knownXs.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    if (knownYsRowCount * knownYsColumnCount !== knownXsRowCount * knownXsColumnCount) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const {
      isError,
      errorObject,
      array1Values,
      array2Values,
      noCalculate
    } = getTwoArrayNumberValues(
      knownYs,
      knownXs,
      knownYsRowCount * knownYsColumnCount,
      knownYsColumnCount,
      knownXsColumnCount
    );
    if (isError) {
      return errorObject;
    }
    if (noCalculate) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    return this._getResult(array1Values, array2Values);
  }
  _getResult(knownYs, knownXs) {
    const n = knownYs.length;
    if (n <= 2) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    let knownYsSum = 0;
    let knownXsSum = 0;
    for (let i = 0; i < n; i++) {
      knownYsSum += knownYs[i];
      knownXsSum += knownXs[i];
    }
    const knownYsMean = knownYsSum / n;
    const knownXsMean = knownXsSum / n;
    let num = 0;
    let knownYsPowSum = 0;
    let knownXsPowSum = 0;
    for (let i = 0; i < n; i++) {
      num += (knownYs[i] - knownYsMean) * (knownXs[i] - knownXsMean);
      knownYsPowSum += (knownYs[i] - knownYsMean) ** 2;
      knownXsPowSum += (knownXs[i] - knownXsMean) ** 2;
    }
    if (knownXsPowSum === 0) {
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    const result = Math.sqrt((knownYsPowSum - num ** 2 / knownXsPowSum) / (n - 2));
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/t-dist/index.ts
var TDist = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(x, degFreedom, cumulative) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1,
      cumulative.isArray() ? cumulative.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1,
      cumulative.isArray() ? cumulative.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const cumulativeArray = expandArrayValueObject(maxRowLength, maxColumnLength, cumulative, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      const cumulativeObject = cumulativeArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      if (cumulativeObject.isError()) {
        return cumulativeObject;
      }
      return this._handleSignleObject(xObject, degFreedomObject, cumulativeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedomObject, cumulativeObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedomObject, cumulativeObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedomObject, _cumulativeObject] = variants;
    const xValue = +_xObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    const cumulativeValue = +_cumulativeObject.getValue();
    if (degFreedomValue < 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    let result;
    if (cumulativeValue) {
      result = studentTCDF(xValue, degFreedomValue);
    } else {
      result = studentTPDF(xValue, degFreedomValue);
    }
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/t-dist-2t/index.ts
var TDist2t = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(x, degFreedom) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      return this._handleSignleObject(xObject, degFreedomObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedomObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedomObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedomObject] = variants;
    const xValue = +_xObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    if (xValue < 0 || degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = studentTCDF(-xValue, degFreedomValue) * 2;
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/t-dist-rt/index.ts
var TDistRt = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(x, degFreedom) {
    const maxRowLength = Math.max(
      x.isArray() ? x.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      x.isArray() ? x.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1
    );
    const xArray = expandArrayValueObject(maxRowLength, maxColumnLength, x, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = xArray.mapValue((xObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      if (xObject.isError()) {
        return xObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      return this._handleSignleObject(xObject, degFreedomObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(xObject, degFreedomObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(xObject, degFreedomObject);
    if (isError) {
      return errorObject;
    }
    const [_xObject, _degFreedomObject] = variants;
    const xValue = +_xObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    if (degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = studentTCDF(-xValue, degFreedomValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/t-inv/index.ts
var TInv = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(probability, degFreedom) {
    const maxRowLength = Math.max(
      probability.isArray() ? probability.getRowCount() : 1,
      degFreedom.isArray() ? degFreedom.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      probability.isArray() ? probability.getColumnCount() : 1,
      degFreedom.isArray() ? degFreedom.getColumnCount() : 1
    );
    const probabilityArray = expandArrayValueObject(maxRowLength, maxColumnLength, probability, ErrorValueObject.create("#N/A" /* NA */));
    const degFreedomArray = expandArrayValueObject(maxRowLength, maxColumnLength, degFreedom, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = probabilityArray.mapValue((probabilityObject, rowIndex, columnIndex) => {
      const degFreedomObject = degFreedomArray.get(rowIndex, columnIndex);
      if (probabilityObject.isError()) {
        return probabilityObject;
      }
      if (degFreedomObject.isError()) {
        return degFreedomObject;
      }
      return this._handleSignleObject(probabilityObject, degFreedomObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSignleObject(probabilityObject, degFreedomObject) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(probabilityObject, degFreedomObject);
    if (isError) {
      return errorObject;
    }
    const [_probabilityObject, _degFreedomObject] = variants;
    const probabilityValue = +_probabilityObject.getValue();
    const degFreedomValue = Math.floor(+_degFreedomObject.getValue());
    if (probabilityValue <= 0 || probabilityValue > 1 || degFreedomValue < 1 || degFreedomValue > 10 ** 10) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const result = studentTINV(probabilityValue, degFreedomValue);
    if (Number.isNaN(result) || !Number.isFinite(result)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/statistical/trend/index.ts
var Trend = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 4);
  }
  calculate(knownYs, knownXs, newXs, constb) {
    const { isError, errorObject } = checkKnownsArrayDimensions(knownYs, knownXs, newXs);
    if (isError) {
      return errorObject;
    }
    const knownYsValues = getKnownsArrayValues(knownYs);
    if (knownYsValues instanceof ErrorValueObject) {
      return knownYsValues;
    }
    const knownXsValues = this._getKnownXsValues(knownYsValues, knownXs);
    if (knownXsValues instanceof ErrorValueObject) {
      return knownXsValues;
    }
    const newXsValues = this._getNewXsValues(knownXsValues, newXs);
    if (newXsValues instanceof ErrorValueObject) {
      return newXsValues;
    }
    let _constb = constb != null ? constb : BooleanValueObject.create(true);
    if (_constb.isArray()) {
      _constb = _constb.get(0, 0);
    }
    if (_constb.isString()) {
      _constb = _constb.convertToNumberObjectValue();
    }
    if (_constb.isError()) {
      return _constb;
    }
    const constbValue = +_constb.getValue();
    return this._getResult(knownYsValues, knownXsValues, newXsValues, constbValue);
  }
  _getResult(knownYsValues, knownXsValues, newXsValues, constb) {
    if (knownYsValues.length === 1 && knownXsValues.length > 1 || knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
      if (knownYsValues.length === 1 && knownXsValues.length > 1) {
        const count = constb ? knownXsValues.length + 1 : knownXsValues.length;
        if (count > knownYsValues[0].length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      if (knownYsValues[0].length === 1 && knownXsValues[0].length > 1) {
        const count = constb ? knownXsValues[0].length + 1 : knownXsValues[0].length;
        if (count > knownYsValues.length) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
      }
      return this._getResultByMultipleVariables(knownYsValues, knownXsValues, newXsValues, constb);
    }
    return this._getResultBySimpleVariables(knownYsValues, knownXsValues, newXsValues, constb);
  }
  _getResultByMultipleVariables(knownYsValues, knownXsValues, newXsValues, constb) {
    const isOneRow = knownYsValues.length === 1 && knownYsValues[0].length > 1;
    const _coefficients = getKnownsArrayCoefficients(knownYsValues, knownXsValues, newXsValues, constb, false);
    if (_coefficients instanceof ErrorValueObject) {
      return _coefficients;
    }
    const { coefficients, newX } = _coefficients;
    const cl = coefficients[0].length;
    const b = coefficients[0][cl - 1];
    let result = [];
    for (let i = 0; i < newX.length; i++) {
      result[i] = [];
      let value = b;
      for (let j = cl - 2; j >= 0; j--) {
        value += coefficients[0][cl - 2 - j] * newX[i][j];
      }
      result[i].push(value);
    }
    if (isOneRow) {
      result = matrixTranspose(result);
    }
    return ArrayValueObject.createByArray(result);
  }
  _getResultBySimpleVariables(knownYsValues, knownXsValues, newXsValues, constb) {
    const knownYsValuesFlat = knownYsValues.flat();
    const knownXsValuesFlat = knownXsValues.flat();
    const { slope: m, intercept: b } = getSlopeAndIntercept(knownXsValuesFlat, knownYsValuesFlat, constb, false);
    if (Number.isNaN(m)) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    const result = newXsValues.map((row) => {
      return row.map((value) => m * value + b);
    });
    return ArrayValueObject.createByArray(result);
  }
  _getKnownXsValues(knownYsValues, knownXs) {
    if (!knownXs || knownXs.isNull()) {
      return getSerialNumbersByRowsColumns(knownYsValues.length, knownYsValues[0].length);
    }
    return getKnownsArrayValues(knownXs);
  }
  _getNewXsValues(knownXsValues, newXs) {
    if (!newXs || newXs.isNull()) {
      return knownXsValues;
    }
    return getKnownsArrayValues(newXs);
  }
};

// ../packages/engine-formula/src/functions/statistical/trimmean/index.ts
var Trimmean = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, percent) {
    const arrayValues = this._getValues(array);
    if (percent.isArray()) {
      const resultArray = percent.mapValue((percentObject) => this._handleSingleObject(arrayValues, percentObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(arrayValues, percent);
  }
  _handleSingleObject(array, percent) {
    if (array instanceof ErrorValueObject) {
      return array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(percent);
    if (isError) {
      return errorObject;
    }
    const [percentObject] = variants;
    const percentValue = +percentObject.getValue();
    if (percentValue < 0 || percentValue >= 1) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    const count = floor2(array.length * percentValue / 2, 0) * 2;
    const newArray = array.slice(count / 2, array.length - count / 2);
    const result = newArray.reduce((acc, cur) => acc + cur, 0) / newArray.length;
    return NumberValueObject.create(result);
  }
  _getValues(array) {
    const rowCount = array.isArray() ? array.getRowCount() : 1;
    const columnCount = array.isArray() ? array.getColumnCount() : 1;
    const values = [];
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        if (valueObject.isError()) {
          return valueObject;
        }
        if (valueObject.isNull() || valueObject.isBoolean()) {
          continue;
        }
        const value = valueObject.getValue();
        if (!isRealNum(value)) {
          continue;
        }
        values.push(+value);
      }
    }
    if (values.length === 0) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    return values.sort((a2, b) => a2 - b);
  }
};

// ../packages/engine-formula/src/functions/statistical/vara/index.ts
var Vara = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants, false);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.var(1);
  }
};

// ../packages/engine-formula/src/functions/statistical/varpa/index.ts
var Varpa = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...variants) {
    const flattenArray = this.flattenArray(variants, false);
    if (flattenArray.isError()) {
      return flattenArray;
    }
    return flattenArray.var();
  }
};

// ../packages/engine-formula/src/functions/statistical/function-map.ts
var functionStatistical = [
  [Avedev, "AVEDEV" /* AVEDEV */],
  [Average, "AVERAGE" /* AVERAGE */],
  [AverageWeighted, "AVERAGE.WEIGHTED" /* AVERAGE_WEIGHTED */],
  [Averagea, "AVERAGEA" /* AVERAGEA */],
  [Averageif, "AVERAGEIF" /* AVERAGEIF */],
  [Averageifs, "AVERAGEIFS" /* AVERAGEIFS */],
  [BetaDist, "BETA.DIST" /* BETA_DIST */],
  [BetaInv, "BETA.INV" /* BETA_INV */],
  [BinomDist, "BINOM.DIST" /* BINOM_DIST */],
  [BinomDistRange, "BINOM.DIST.RANGE" /* BINOM_DIST_RANGE */],
  [BinomInv, "BINOM.INV" /* BINOM_INV */],
  [ChisqDist, "CHISQ.DIST" /* CHISQ_DIST */],
  [ChisqDistRt, "CHISQ.DIST.RT" /* CHISQ_DIST_RT */],
  [ChisqInv, "CHISQ.INV" /* CHISQ_INV */],
  [ChisqInvRt, "CHISQ.INV.RT" /* CHISQ_INV_RT */],
  [ChisqTest, "CHISQ.TEST" /* CHISQ_TEST */],
  [ConfidenceNorm, "CONFIDENCE.NORM" /* CONFIDENCE_NORM */],
  [ConfidenceT, "CONFIDENCE.T" /* CONFIDENCE_T */],
  [Correl, "CORREL" /* CORREL */],
  [Count, "COUNT" /* COUNT */],
  [Counta, "COUNTA" /* COUNTA */],
  [Countblank, "COUNTBLANK" /* COUNTBLANK */],
  [Countif, "COUNTIF" /* COUNTIF */],
  [Countifs, "COUNTIFS" /* COUNTIFS */],
  [CovarianceP, "COVARIANCE.P" /* COVARIANCE_P */],
  [CovarianceS, "COVARIANCE.S" /* COVARIANCE_S */],
  [Devsq, "DEVSQ" /* DEVSQ */],
  [ExponDist, "EXPON.DIST" /* EXPON_DIST */],
  [FDist, "F.DIST" /* F_DIST */],
  [FDistRt, "F.DIST.RT" /* F_DIST_RT */],
  [FInv, "F.INV" /* F_INV */],
  [FInvRt, "F.INV.RT" /* F_INV_RT */],
  [FTest, "F.TEST" /* F_TEST */],
  [Fisher, "FISHER" /* FISHER */],
  [Fisherinv, "FISHERINV" /* FISHERINV */],
  [Forecast, "FORECAST" /* FORECAST */],
  [Forecast, "FORECAST.LINEAR" /* FORECAST_LINEAR */],
  [Frequency, "FREQUENCY" /* FREQUENCY */],
  [Gamma, "GAMMA" /* GAMMA */],
  [GammaDist, "GAMMA.DIST" /* GAMMA_DIST */],
  [GammaInv, "GAMMA.INV" /* GAMMA_INV */],
  [Gammaln, "GAMMALN" /* GAMMALN */],
  [Gammaln, "GAMMALN.PRECISE" /* GAMMALN_PRECISE */],
  [Gauss, "GAUSS" /* GAUSS */],
  [Geomean, "GEOMEAN" /* GEOMEAN */],
  [Growth, "GROWTH" /* GROWTH */],
  [Harmean, "HARMEAN" /* HARMEAN */],
  [HypgeomDist, "HYPGEOM.DIST" /* HYPGEOM_DIST */],
  [Intercept, "INTERCEPT" /* INTERCEPT */],
  [Kurt, "KURT" /* KURT */],
  [Large, "LARGE" /* LARGE */],
  [Linest, "LINEST" /* LINEST */],
  [Logest, "LOGEST" /* LOGEST */],
  [LognormDist, "LOGNORM.DIST" /* LOGNORM_DIST */],
  [LognormInv, "LOGNORM.INV" /* LOGNORM_INV */],
  [Marginoferror, "MARGINOFERROR" /* MARGINOFERROR */],
  [Max, "MAX" /* MAX */],
  [Maxa, "MAXA" /* MAXA */],
  [Maxifs, "MAXIFS" /* MAXIFS */],
  [Median, "MEDIAN" /* MEDIAN */],
  [Min, "MIN" /* MIN */],
  [Mina, "MINA" /* MINA */],
  [Minifs, "MINIFS" /* MINIFS */],
  [ModeMult, "MODE.MULT" /* MODE_MULT */],
  [ModeSngl, "MODE.SNGL" /* MODE_SNGL */],
  [NegbinomDist, "NEGBINOM.DIST" /* NEGBINOM_DIST */],
  [NormDist, "NORM.DIST" /* NORM_DIST */],
  [NormInv, "NORM.INV" /* NORM_INV */],
  [NormSDist, "NORM.S.DIST" /* NORM_S_DIST */],
  [NormSInv, "NORM.S.INV" /* NORM_S_INV */],
  [Pearson, "PEARSON" /* PEARSON */],
  [PercentileExc, "PERCENTILE.EXC" /* PERCENTILE_EXC */],
  [PercentileInc, "PERCENTILE.INC" /* PERCENTILE_INC */],
  [PercentrankExc, "PERCENTRANK.EXC" /* PERCENTRANK_EXC */],
  [PercentrankInc, "PERCENTRANK.INC" /* PERCENTRANK_INC */],
  [Permut, "PERMUT" /* PERMUT */],
  [Permutationa, "PERMUTATIONA" /* PERMUTATIONA */],
  [Phi, "PHI" /* PHI */],
  [PoissonDist, "POISSON.DIST" /* POISSON_DIST */],
  [Prob, "PROB" /* PROB */],
  [QuartileExc, "QUARTILE.EXC" /* QUARTILE_EXC */],
  [QuartileInc, "QUARTILE.INC" /* QUARTILE_INC */],
  [RankAvg, "RANK.AVG" /* RANK_AVG */],
  [RankEq, "RANK.EQ" /* RANK_EQ */],
  [Rsq, "RSQ" /* RSQ */],
  [Skew, "SKEW" /* SKEW */],
  [SkewP, "SKEW.P" /* SKEW_P */],
  [Slope, "SLOPE" /* SLOPE */],
  [Small, "SMALL" /* SMALL */],
  [Standardize, "STANDARDIZE" /* STANDARDIZE */],
  [StdevP, "STDEV.P" /* STDEV_P */],
  [StdevS, "STDEV.S" /* STDEV_S */],
  [Stdeva, "STDEVA" /* STDEVA */],
  [Stdevpa, "STDEVPA" /* STDEVPA */],
  [Steyx, "STEYX" /* STEYX */],
  [TDist, "T.DIST" /* T_DIST */],
  [TDist2t, "T.DIST.2T" /* T_DIST_2T */],
  [TDistRt, "T.DIST.RT" /* T_DIST_RT */],
  [TInv, "T.INV" /* T_INV */],
  [TInv2t, "T.INV.2T" /* T_INV_2T */],
  [TTest, "T.TEST" /* T_TEST */],
  [Trend, "TREND" /* TREND */],
  [Trimmean, "TRIMMEAN" /* TRIMMEAN */],
  [VarP, "VAR.P" /* VAR_P */],
  [VarS, "VAR.S" /* VAR_S */],
  [Vara, "VARA" /* VARA */],
  [Varpa, "VARPA" /* VARPA */],
  [WeibullDist, "WEIBULL.DIST" /* WEIBULL_DIST */],
  [ZTest, "Z.TEST" /* Z_TEST */]
];

// ../packages/engine-formula/src/functions/text/arraytotext/index.ts
var Arraytotext = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(array, format) {
    let _format = format != null ? format : NumberValueObject.create(0);
    if (format == null ? void 0 : format.isNull()) {
      _format = NumberValueObject.create(0);
    }
    if (_format.isArray()) {
      const resultArray = _format.mapValue((formatObject) => this._handleSingleObject(array, formatObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(array, _format);
  }
  _handleSingleObject(array, format) {
    const _array = this._checkArray(array);
    if (_array.isError()) {
      return _array;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(format);
    if (isError) {
      return errorObject;
    }
    const [formatObject] = variants;
    const formatValue = +formatObject.getValue();
    const arrayRowCount = array.isArray() ? array.getRowCount() : 1;
    const arrayColumnCount = array.isArray() ? array.getColumnCount() : 1;
    let result = "";
    for (let r = 0; r < arrayRowCount; r++) {
      for (let c = 0; c < arrayColumnCount; c++) {
        const valueObject = array.isArray() ? array.get(r, c) : array;
        let value = `${valueObject.getValue()}`;
        if (valueObject.isNull()) {
          value = "";
        }
        if (valueObject.isBoolean()) {
          value = value.toLocaleUpperCase();
        }
        if (valueObject.isString() && formatValue) {
          result += `"${value}"`;
        } else {
          result += value;
        }
        if (!(r === arrayRowCount - 1 && c === arrayColumnCount - 1)) {
          if (formatValue) {
            if (c === arrayColumnCount - 1) {
              result += ";";
            } else {
              result += ",";
            }
          } else {
            result += ", ";
          }
        }
      }
    }
    if (formatValue) {
      result = `{${result}}`;
    }
    if (result.length > 32767) {
      return ErrorValueObject.create("#CALC!" /* CALC */);
    }
    return StringValueObject.create(result);
  }
  _checkArray(array) {
    if (array.isArray()) {
      const arrayRowCount = array.getRowCount();
      const arrayColumnCount = array.getColumnCount();
      if (arrayRowCount > 1 || arrayColumnCount > 1) {
        return array;
      }
      return array.get(0, 0);
    }
    return array;
  }
};

// ../packages/engine-formula/src/functions/text/asc/index.ts
var Asc = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError() || text.isNull() || text.isBoolean() || text.isNumber()) {
      return text;
    }
    const textValue = text.getValue().toLocaleString();
    let result = "";
    for (let i = 0; i < textValue.length; i++) {
      let charCode = textValue.charCodeAt(i);
      if (charCode === 12288) {
        charCode = 32;
      } else if (charCode >= 65281 && charCode <= 65374) {
        charCode -= 65248;
      }
      result += String.fromCharCode(charCode);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/bahttext/index.ts
var Bahttext = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      const resultArray = number.mapValue((numberObject) => this._handleSingleObject(numberObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = +numberObject.getValue();
    const integerPart = Math.abs(Number.parseInt(numberValue.toString(), 10));
    const decimalPart = Number.parseFloat((Math.abs(numberValue) - integerPart).toFixed(2));
    let result = "";
    if (integerPart === 0) {
      if (decimalPart !== 0) {
        result = `${numberValue < 0 ? "\u0E25\u0E1A" : ""}${this._convertNumberToThaiText(decimalPart * 100)}\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C`;
      } else {
        result = "\u0E28\u0E39\u0E19\u0E22\u0E4C\u0E1A\u0E32\u0E17\u0E16\u0E49\u0E27\u0E19";
      }
    } else {
      if (decimalPart === 0) {
        result = `${numberValue < 0 ? "\u0E25\u0E1A" : ""}${this._convertNumberToThaiText(integerPart)}\u0E1A\u0E32\u0E17\u0E16\u0E49\u0E27\u0E19`;
      } else {
        result = `${numberValue < 0 ? "\u0E25\u0E1A" : ""}${this._convertNumberToThaiText(integerPart)}\u0E1A\u0E32\u0E17${this._convertNumberToThaiText(decimalPart * 100)}\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C`;
      }
    }
    return StringValueObject.create(result);
  }
  _convertNumberToThaiText(number) {
    const units = ["\u0E25\u0E49\u0E32\u0E19", "\u0E2A\u0E34\u0E1A", "\u0E23\u0E49\u0E2D\u0E22", "\u0E1E\u0E31\u0E19", "\u0E2B\u0E21\u0E37\u0E48\u0E19", "\u0E41\u0E2A\u0E19", ""];
    const digits = ["\u0E28\u0E39\u0E19\u0E22\u0E4C", "\u0E2B\u0E19\u0E36\u0E48\u0E07", "\u0E2A\u0E2D\u0E07", "\u0E2A\u0E32\u0E21", "\u0E2A\u0E35\u0E48", "\u0E2B\u0E49\u0E32", "\u0E2B\u0E01", "\u0E40\u0E08\u0E47\u0E14", "\u0E41\u0E1B\u0E14", "\u0E40\u0E01\u0E49\u0E32"];
    const special = ["\u0E25\u0E1A", "\u0E1A\u0E32\u0E17", "\u0E16\u0E49\u0E27\u0E19", "\u0E2A\u0E15\u0E32\u0E07\u0E04\u0E4C", "\u0E22\u0E35\u0E48", "\u0E40\u0E2D\u0E47\u0E14", ",", " ", "\u0E3F"];
    const numberText = number.toString();
    const n = numberText.length;
    let result = "";
    for (let i = n; i > 0; i--) {
      const digit = Number.parseInt(numberText.charAt(n - i), 10);
      let digitText = digits[digit];
      const position = i > 1 ? (i - 1) % 6 : 6;
      if (position === 1 && digit === 2) {
        digitText = special[4];
      }
      if (digit === 1) {
        switch (position) {
          case 0:
          case 6:
            result += i < n ? special[5] : digitText;
            break;
          case 1:
            break;
          default:
            result += digitText;
            break;
        }
      } else if (digit === 0) {
        if (position === 0) {
          result += units[position];
        }
        continue;
      } else {
        result += digitText;
      }
      result += units[position];
    }
    return result;
  }
};

// ../packages/engine-formula/src/functions/text/char/index.ts
var filterCodeArray = Object.values(DataStreamTreeTokenType).filter((value) => {
  return [
    "" /* TABLE_START */,
    "\x1B" /* TABLE_ROW_START */,
    "" /* TABLE_CELL_START */,
    "" /* TABLE_CELL_END */,
    "" /* TABLE_ROW_END */,
    "" /* TABLE_END */,
    "\b" /* CUSTOM_BLOCK */
  ].includes(value);
});
var Char = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      const resultArray = number.mapValue((numberObject) => this._handleSingleObject(numberObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = Math.floor(+numberObject.getValue());
    if (numberValue <= 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let result = String.fromCharCode(numberValue);
    if (filterCodeArray.some((value) => value === result)) {
      result = String.fromCharCode(1);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/clean/index.ts
var Clean = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError() || text.isBoolean() || text.isNumber()) {
      return text;
    }
    if (text.isNull()) {
      return StringValueObject.create("");
    }
    const textValue = `${text.getValue()}`;
    const result = textValue.replace(/[\0-\x1F]/g, "");
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/code/index.ts
var Code = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let textValue = text.getValue().toLocaleString();
    if (text.isBoolean()) {
      textValue = textValue.toLocaleUpperCase();
    }
    if (textValue === "") {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = textValue.charCodeAt(0);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/concat/index.ts
var Concat = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...textValues) {
    let concatenatedString = "";
    let isError = null;
    for (const textValue of textValues) {
      if (textValue.isArray()) {
        textValue.iterator((valueObject) => {
          if (valueObject == null || valueObject.isNull()) {
            return true;
          }
          if (valueObject.isError()) {
            isError = valueObject;
            return false;
          }
          if (valueObject.isBoolean()) {
            concatenatedString += `${valueObject.getValue()}`.toLocaleUpperCase();
          } else if (valueObject.isString() || valueObject.isNumber()) {
            concatenatedString += valueObject.getValue();
          }
        });
        if (isError) {
          return isError;
        }
      } else if (!textValue.isError() && !textValue.isNull()) {
        concatenatedString += textValue.getValue();
      }
    }
    return StringValueObject.create(concatenatedString);
  }
};

// ../packages/engine-formula/src/functions/text/concatenate/index.ts
var Concatenate = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 255);
  }
  calculate(...textValues) {
    let maxRowLength = 0;
    let maxColumnLength = 0;
    textValues.forEach((textValue) => {
      if (textValue.isArray()) {
        const arrayValue = textValue;
        maxRowLength = Math.max(maxRowLength, arrayValue.getRowCount());
        maxColumnLength = Math.max(maxColumnLength, arrayValue.getColumnCount());
      } else {
        maxRowLength = Math.max(maxRowLength, 1);
        maxColumnLength = Math.max(maxColumnLength, 1);
      }
    });
    let result = null;
    for (const textValue of textValues) {
      const textValueArray = expandArrayValueObject(maxRowLength, maxColumnLength, textValue, ErrorValueObject.create("#N/A" /* NA */));
      result = textValueArray.mapValue((textValueObject, rowIndex, columnIndex) => {
        const resultValueObject = result && result.get(rowIndex, columnIndex);
        if (resultValueObject == null ? void 0 : resultValueObject.isError()) {
          return resultValueObject;
        }
        if (textValueObject.isError()) {
          return textValueObject;
        }
        let resultValue = resultValueObject == null ? void 0 : resultValueObject.getValue();
        let textValue2 = textValueObject == null ? void 0 : textValueObject.getValue();
        if (resultValueObject == null ? void 0 : resultValueObject.isBoolean()) {
          resultValue = `${resultValue}`.toLocaleUpperCase();
        }
        if (textValueObject == null ? void 0 : textValueObject.isBoolean()) {
          textValue2 = `${textValue2}`.toLocaleUpperCase();
        }
        const resultValueObjectString = (resultValueObject == null ? void 0 : resultValueObject.isNull()) ? "" : resultValue != null ? resultValue : "";
        const textValueObjectString = (textValueObject == null ? void 0 : textValueObject.isNull()) ? "" : textValue2 != null ? textValue2 : "";
        return StringValueObject.create(`${resultValueObjectString}${textValueObjectString}`);
      });
    }
    if (!result) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return result;
  }
};

// ../packages/engine-formula/src/functions/text/dbcs/index.ts
var Dbcs = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isNull()) {
      return StringValueObject.create("");
    }
    let textValue = `${text.getValue()}`;
    if (text.isBoolean()) {
      textValue = textValue.toLocaleUpperCase();
    }
    let result = "";
    for (let i = 0; i < textValue.length; i++) {
      const char = textValue.charCodeAt(i);
      if (char >= 33 && char <= 126) {
        result += String.fromCharCode(char + 65248);
      } else if (char === 32) {
        result += String.fromCharCode(12288);
      } else {
        result += textValue.charAt(i);
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/dollar/index.ts
var Dollar = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
    __publicField(this, "needsLocale", true);
  }
  calculate(number, decimals) {
    let _decimals = decimals != null ? decimals : NumberValueObject.create(2);
    if (_decimals.isNull()) {
      _decimals = NumberValueObject.create(2);
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _decimals.isArray() ? _decimals.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _decimals.isArray() ? _decimals.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const decimalsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _decimals, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      const decimalsObject = decimalsArray.get(rowIndex, columnIndex);
      if (numberObject.isError()) {
        return numberObject;
      }
      if (decimalsObject.isError()) {
        return decimalsObject;
      }
      return this._handleSingleObject(numberObject, decimalsObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(number, decimals) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number, decimals);
    if (isError) {
      return errorObject;
    }
    const [numberObject, decimalsObject] = variants;
    let numberValue = +numberObject.getValue();
    let decimalsValue = Math.trunc(+decimalsObject.getValue());
    if (decimalsValue > 127) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (decimalsValue < 0) {
      if (`${numberValue}`.length < Math.abs(decimalsValue)) {
        numberValue = 0;
      } else {
        numberValue = numberValue < 0 ? -round2(Math.abs(numberValue), decimalsValue) : round2(numberValue, decimalsValue);
      }
      decimalsValue = 0;
    }
    const result = applyCurrencyFormat(this.getLocale(), numberValue, decimalsValue);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/exact/index.ts
var Exact = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(text1, text2) {
    const maxRowLength = Math.max(
      text1.isArray() ? text1.getRowCount() : 1,
      text2.isArray() ? text2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text1.isArray() ? text1.getColumnCount() : 1,
      text2.isArray() ? text2.getColumnCount() : 1
    );
    const text1Array = expandArrayValueObject(maxRowLength, maxColumnLength, text1, NullValueObject.create());
    const text2Array = expandArrayValueObject(maxRowLength, maxColumnLength, text2, NullValueObject.create());
    const resultArray = text1Array.mapValue((text1Object, rowIndex, columnIndex) => {
      const text2Object = text2Array.get(rowIndex, columnIndex);
      if (text1Object.isError()) {
        return text1Object;
      }
      if (text2Object.isError()) {
        return text2Object;
      }
      return this._handleSingleObject(text1Object, text2Object);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text1, text2) {
    if (text1.isNull() || text2.isNull()) {
      const result2 = text1.isNull() && text2.isNull();
      return BooleanValueObject.create(result2);
    }
    let text1Value = `${text1.getValue()}`;
    if (text1.isBoolean()) {
      text1Value = text1Value.toLocaleUpperCase();
    }
    let text2Value = `${text2.getValue()}`;
    if (text2.isBoolean()) {
      text2Value = text2Value.toLocaleUpperCase();
    }
    const result = text1Value === text2Value;
    return BooleanValueObject.create(result);
  }
};

// ../packages/engine-formula/src/basics/format.ts
var getFormatPreview = (pattern, value) => {
  return numfmt.format(pattern, value, { throws: false });
};
var getTextValueOfNumberFormat = (text) => {
  let textValue = `${text.getValue()}`;
  if (text.isNull()) {
    textValue = "";
  }
  if (text.isBoolean()) {
    textValue = textValue.toLocaleUpperCase();
  }
  if (text.isNumber()) {
    if (text.getPattern() !== "") {
      textValue = getFormatPreview(text.getPattern(), +text.getValue());
    } else {
      textValue = `${stripErrorMargin(+text.getValue())}`;
    }
  }
  return textValue;
};

// ../packages/engine-formula/src/functions/text/find/index.ts
var Find = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(findText, withinText, startNum) {
    const _startNum = startNum != null ? startNum : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      findText.isArray() ? findText.getRowCount() : 1,
      withinText.isArray() ? withinText.getRowCount() : 1,
      _startNum.isArray() ? _startNum.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      findText.isArray() ? findText.getColumnCount() : 1,
      withinText.isArray() ? withinText.getColumnCount() : 1,
      _startNum.isArray() ? _startNum.getColumnCount() : 1
    );
    const findTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, findText, ErrorValueObject.create("#N/A" /* NA */));
    const withinTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, withinText, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _startNum, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = findTextArray.mapValue((findTextObject, rowIndex, columnIndex) => {
      const withinTextObject = withinTextArray.get(rowIndex, columnIndex);
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      if (findTextObject.isError()) {
        return findTextObject;
      }
      if (withinTextObject.isError()) {
        return withinTextObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      return this._handleSingleObject(findTextObject, withinTextObject, startNumObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(findText, withinText, startNum) {
    const findTextValue = getTextValueOfNumberFormat(findText);
    const withinTextValue = getTextValueOfNumberFormat(withinText);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum);
    if (isError) {
      return errorObject;
    }
    const [startNumObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    if (withinText.isNull() || startNumValue <= 0 || startNumValue > withinTextValue.length) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (findText.isNull() || findTextValue.length === 0) {
      return NumberValueObject.create(startNumValue);
    }
    const result = withinTextValue.indexOf(findTextValue, startNumValue - 1);
    if (result === -1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return NumberValueObject.create(result + 1);
  }
};

// ../packages/engine-formula/src/engine/utils/char-kit.ts
function charLenByte(text) {
  let byteCount = 0;
  for (let i = 0; i < text.length; i++) {
    byteCount += getCharLenByteInText(text, i);
  }
  return byteCount;
}
function getCharLenByteInText(text, charIndex, direction = "ltr") {
  const codePoint = getCodePoint(text, charIndex, direction);
  return codePoint > 255 ? 2 : 1;
}
function highSurrogate(charCode) {
  return charCode >= 55296 && charCode <= 56319;
}
function lowSurrogate(charCode) {
  return charCode >= 56320 && charCode <= 57343;
}
function surrogatePair(highSurrogate2, lowSurrogate2) {
  const highBits = (highSurrogate2 & 1023) << 10;
  const lowBits = lowSurrogate2 & 1023;
  return highBits + lowBits + 65536;
}
function getCodePoint(str, index, direction = "ltr") {
  const charCode = str.charCodeAt(index);
  if (direction === "ltr" && highSurrogate(charCode) && index + 1 < str.length) {
    const nextCharCode = str.charCodeAt(index + 1);
    if (lowSurrogate(nextCharCode)) {
      return surrogatePair(charCode, nextCharCode);
    }
  }
  if (direction === "rtl" && lowSurrogate(charCode) && index - 1 >= 0) {
    const prevCharCode = str.charCodeAt(index - 1);
    if (highSurrogate(prevCharCode)) {
      return surrogatePair(prevCharCode, charCode);
    }
  }
  return charCode;
}

// ../packages/engine-formula/src/functions/text/findb/index.ts
var Findb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(findText, withinText, startNum) {
    const _startNum = startNum != null ? startNum : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      findText.isArray() ? findText.getRowCount() : 1,
      withinText.isArray() ? withinText.getRowCount() : 1,
      _startNum.isArray() ? _startNum.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      findText.isArray() ? findText.getColumnCount() : 1,
      withinText.isArray() ? withinText.getColumnCount() : 1,
      _startNum.isArray() ? _startNum.getColumnCount() : 1
    );
    const findTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, findText, ErrorValueObject.create("#N/A" /* NA */));
    const withinTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, withinText, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _startNum, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = findTextArray.mapValue((findTextObject, rowIndex, columnIndex) => {
      const withinTextObject = withinTextArray.get(rowIndex, columnIndex);
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      if (findTextObject.isError()) {
        return findTextObject;
      }
      if (withinTextObject.isError()) {
        return withinTextObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      return this._handleSingleObject(findTextObject, withinTextObject, startNumObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(findText, withinText, startNum) {
    const findTextValue = getTextValueOfNumberFormat(findText);
    const withinTextValue = getTextValueOfNumberFormat(withinText);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum);
    if (isError) {
      return errorObject;
    }
    const [startNumObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    if (withinText.isNull() || startNumValue <= 0 || startNumValue > withinTextValue.length) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (findText.isNull() || findTextValue.length === 0) {
      return NumberValueObject.create(startNumValue);
    }
    const index = withinTextValue.indexOf(findTextValue, startNumValue - 1);
    if (index === -1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = charLenByte(withinTextValue.substring(0, index)) + 1;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/fixed/index.ts
var Fixed = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 3);
  }
  calculate(number, decimals, noCommas) {
    let _decimals = decimals != null ? decimals : NumberValueObject.create(2);
    if (_decimals.isNull()) {
      _decimals = NumberValueObject.create(2);
    }
    let _noCommas = noCommas != null ? noCommas : BooleanValueObject.create(false);
    if (_noCommas.isNull()) {
      _noCommas = BooleanValueObject.create(false);
    }
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      _decimals.isArray() ? _decimals.getRowCount() : 1,
      _noCommas.isArray() ? _noCommas.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      _decimals.isArray() ? _decimals.getColumnCount() : 1,
      _noCommas.isArray() ? _noCommas.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const decimalsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _decimals, ErrorValueObject.create("#N/A" /* NA */));
    const noCommasArray = expandArrayValueObject(maxRowLength, maxColumnLength, _noCommas, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      const decimalsObject = decimalsArray.get(rowIndex, columnIndex);
      const noCommasObject = noCommasArray.get(rowIndex, columnIndex);
      if (numberObject.isError()) {
        return numberObject;
      }
      if (decimalsObject.isError()) {
        return decimalsObject;
      }
      if (noCommasObject.isError()) {
        return noCommasObject;
      }
      return this._handleSingleObject(numberObject, decimalsObject, noCommasObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(number, decimals, noCommas) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number, decimals, noCommas);
    if (isError) {
      return errorObject;
    }
    const [numberObject, decimalsObject, noCommasObject] = variants;
    let numberValue = +numberObject.getValue();
    let decimalsValue = Math.trunc(+decimalsObject.getValue());
    const noCommasValue = +noCommasObject.getValue();
    if (decimalsValue > 127) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (decimalsValue < 0) {
      if (`${numberValue}`.length < Math.abs(decimalsValue)) {
        numberValue = 0;
      } else {
        numberValue = numberValue < 0 ? -round2(Math.abs(numberValue), decimalsValue) : round2(numberValue, decimalsValue);
      }
      decimalsValue = 0;
    }
    let pattern = noCommasValue ? "###0" : "#,##0";
    if (decimalsValue > 0) {
      pattern += `.${"0".repeat(decimalsValue)}`;
    }
    const result = getFormatPreview(pattern, numberValue);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/left/index.ts
var Left = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, numChars) {
    const _numChars = numChars != null ? numChars : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _numChars.isArray() ? _numChars.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _numChars.isArray() ? _numChars.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const numCharsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _numChars, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const numCharsObject = numCharsArray.get(rowIndex, columnIndex);
      if (textObject.isError()) {
        return textObject;
      }
      if (numCharsObject.isError()) {
        return numCharsObject;
      }
      return this._handleSingleObject(textObject, numCharsObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text, numChars) {
    const textValue = getTextValueOfNumberFormat(text);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numChars);
    if (isError) {
      return errorObject;
    }
    const [numCharsObject] = variants;
    const numCharsValue = Math.floor(+numCharsObject.getValue());
    if (numCharsValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (text.isNull() || numCharsValue === 0) {
      return StringValueObject.create("");
    }
    if (numCharsValue >= textValue.length) {
      return StringValueObject.create(textValue);
    }
    const result = textValue.substring(0, numCharsValue);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/leftb/index.ts
var Leftb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, numBytes) {
    const _numBytes = numBytes != null ? numBytes : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _numBytes.isArray() ? _numBytes.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _numBytes.isArray() ? _numBytes.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, NullValueObject.create());
    const numBytesArray = expandArrayValueObject(maxRowLength, maxColumnLength, _numBytes, NullValueObject.create());
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const numBytesObject = numBytesArray.get(rowIndex, columnIndex);
      if (textObject.isError()) {
        return textObject;
      }
      if (numBytesObject.isError()) {
        return numBytesObject;
      }
      return this._handleSingleObject(textObject, numBytesObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text, numBytes) {
    const textValue = getTextValueOfNumberFormat(text);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numBytes);
    if (isError) {
      return errorObject;
    }
    const [numBytesObject] = variants;
    const numBytesValue = Math.floor(+numBytesObject.getValue());
    if (numBytesValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (text.isNull() || numBytesValue === 0) {
      return StringValueObject.create("");
    }
    let index = 0;
    let lenByte = 0;
    let result = "";
    while (lenByte < numBytesValue && index < textValue.length) {
      lenByte += getCharLenByteInText(textValue, index);
      result += textValue.charAt(index);
      index++;
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/len/index.ts
var Len = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textValue) => this._handleSingleText(textValue));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleText(text);
  }
  _handleSingleText(text) {
    if (text.isError()) {
      return text;
    }
    const textValue = getTextValueOfNumberFormat(text);
    return NumberValueObject.create(textValue.length);
  }
};

// ../packages/engine-formula/src/functions/text/lenb/index.ts
var Lenb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textValue) => this._handleSingleText(textValue));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleText(text);
  }
  _handleSingleText(text) {
    if (text.isError()) {
      return text;
    }
    const textValue = getTextValueOfNumberFormat(text);
    const textByteLen = charLenByte(textValue);
    return NumberValueObject.create(textByteLen);
  }
};

// ../packages/engine-formula/src/functions/text/lower/index.ts
var Lower = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isNull()) {
      return StringValueObject.create("");
    }
    const result = `${text.getValue()}`.toLocaleLowerCase();
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/mid/index.ts
var Mid = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(text, startNum, numChars) {
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      startNum.isArray() ? startNum.getRowCount() : 1,
      numChars.isArray() ? numChars.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      startNum.isArray() ? startNum.getColumnCount() : 1,
      numChars.isArray() ? numChars.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, startNum, ErrorValueObject.create("#N/A" /* NA */));
    const numCharsArray = expandArrayValueObject(maxRowLength, maxColumnLength, numChars, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      const numCharsObject = numCharsArray.get(rowIndex, columnIndex);
      if (textObject.isError()) {
        return textObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      if (numCharsObject.isError()) {
        return numCharsObject;
      }
      return this._handleSingleObject(textObject, startNumObject, numCharsObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text, startNum, numChars) {
    const textValue = getTextValueOfNumberFormat(text);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum, numChars);
    if (isError) {
      return errorObject;
    }
    const [startNumObject, numCharsObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    const numCharsValue = Math.floor(+numCharsObject.getValue());
    if (startNumValue <= 0 || numCharsValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (text.isNull() || startNumValue > textValue.length || numCharsValue === 0) {
      return StringValueObject.create("");
    }
    const result = textValue.substring(startNumValue - 1, startNumValue - 1 + numCharsValue);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/midb/index.ts
var Midb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(text, startNum, numBytes) {
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      startNum.isArray() ? startNum.getRowCount() : 1,
      numBytes.isArray() ? numBytes.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      startNum.isArray() ? startNum.getColumnCount() : 1,
      numBytes.isArray() ? numBytes.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, startNum, ErrorValueObject.create("#N/A" /* NA */));
    const numBytesArray = expandArrayValueObject(maxRowLength, maxColumnLength, numBytes, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      const numBytesObject = numBytesArray.get(rowIndex, columnIndex);
      if (textObject.isError()) {
        return textObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      if (numBytesObject.isError()) {
        return numBytesObject;
      }
      return this._handleSingleObject(textObject, startNumObject, numBytesObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text, startNum, numBytes) {
    let textValue = getTextValueOfNumberFormat(text);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum, numBytes);
    if (isError) {
      return errorObject;
    }
    const [startNumObject, numBytesObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    const numBytesValue = Math.floor(+numBytesObject.getValue());
    if (startNumValue <= 0 || numBytesValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (text.isNull() || startNumValue > textValue.length || numBytesValue === 0) {
      return StringValueObject.create("");
    }
    textValue = textValue.substring(startNumValue - 1);
    let index = 0;
    let lenByte = 0;
    let result = "";
    while (lenByte < numBytesValue && index < textValue.length) {
      lenByte += getCharLenByteInText(textValue, index);
      result += textValue.charAt(index);
      index++;
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/numberstring/index.ts
var chineseLowercaseNumbers = ["\u3007", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u4E03", "\u516B", "\u4E5D"];
var chineseUppercaseNumbers = ["\u96F6", "\u58F9", "\u8D30", "\u53C1", "\u8086", "\u4F0D", "\u9646", "\u67D2", "\u634C", "\u7396"];
var chineseLowercaseUnits = ["", "\u5341", "\u767E", "\u5343"];
var chineseUppercaseUnits = ["", "\u62FE", "\u4F70", "\u4EDF"];
var suffixUnits = ["", "\u4E07", "\u4EBF", "\u5146"];
var Numberstring = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(number, type2) {
    const maxRowLength = Math.max(
      number.isArray() ? number.getRowCount() : 1,
      type2.isArray() ? type2.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      number.isArray() ? number.getColumnCount() : 1,
      type2.isArray() ? type2.getColumnCount() : 1
    );
    const numberArray = expandArrayValueObject(maxRowLength, maxColumnLength, number, ErrorValueObject.create("#N/A" /* NA */));
    const typeArray = expandArrayValueObject(maxRowLength, maxColumnLength, type2, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = numberArray.mapValue((numberObject, rowIndex, columnIndex) => {
      const typeObject = typeArray.get(rowIndex, columnIndex);
      if (numberObject.isError()) {
        return numberObject;
      }
      if (typeObject.isError()) {
        return typeObject;
      }
      return this._handleSingleObject(numberObject, typeObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  // eslint-disable-next-line
  _handleSingleObject(number, type2) {
    const _number = number.convertToNumberObjectValue();
    if (_number.isError()) {
      return _number;
    }
    const _type = type2.convertToNumberObjectValue();
    if (_type.isError()) {
      return _type;
    }
    let numberValue = _number.getValue();
    const typeValue = Math.trunc(_type.getValue());
    if (numberValue < 0 || ![1, 2, 3].includes(typeValue)) {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    numberValue = Math.round(numberValue);
    const numberString = numberValue.toString();
    const len = numberString.length;
    let result = "";
    let hasZero = false;
    for (let i = 0; i < len; i++) {
      const num = Number(numberString[i]);
      if (len === 1 && num === 0) {
        result += typeValue === 2 ? chineseUppercaseNumbers[0] : chineseLowercaseNumbers[0];
        break;
      }
      if (typeValue === 3) {
        result += chineseLowercaseNumbers[num];
        continue;
      }
      const pos = len - i - 1;
      const unit = pos % 4;
      const suffixUnit = Math.trunc(pos / 4);
      if (len >= 17 && suffixUnit > 2) {
        result += typeValue === 1 ? chineseLowercaseNumbers[num] : chineseUppercaseNumbers[num];
        if (suffixUnit > 3) {
          continue;
        }
      } else {
        if (num === 0) {
          hasZero = unit !== 0;
        } else {
          if (hasZero) {
            result += typeValue === 1 ? chineseLowercaseNumbers[0] : chineseUppercaseNumbers[0];
            hasZero = false;
          }
          result += typeValue === 1 ? chineseLowercaseNumbers[num] + chineseLowercaseUnits[unit] : chineseUppercaseNumbers[num] + chineseUppercaseUnits[unit];
        }
      }
      if (unit === 0 && suffixUnit > 0) {
        const segment = numberString.slice(Math.max(0, i - 3), i + 1);
        if (segment !== "0000") {
          result += suffixUnits[suffixUnit];
        }
      }
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/numbervalue/index.ts
var Numbervalue = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 3);
  }
  calculate(text, decimalSeparator, groupSeparator) {
    const _decimalSeparator = decimalSeparator != null ? decimalSeparator : StringValueObject.create(".");
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _decimalSeparator.isArray() ? _decimalSeparator.getRowCount() : 1,
      (groupSeparator == null ? void 0 : groupSeparator.isArray()) ? groupSeparator.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _decimalSeparator.isArray() ? _decimalSeparator.getColumnCount() : 1,
      (groupSeparator == null ? void 0 : groupSeparator.isArray()) ? groupSeparator.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const decimalSeparatorArray = expandArrayValueObject(maxRowLength, maxColumnLength, _decimalSeparator, ErrorValueObject.create("#N/A" /* NA */));
    const groupSeparatorArray = groupSeparator ? expandArrayValueObject(maxRowLength, maxColumnLength, groupSeparator, ErrorValueObject.create("#N/A" /* NA */)) : void 0;
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const decimalSeparatorObject = decimalSeparatorArray.get(rowIndex, columnIndex);
      const groupSeparatorObject = groupSeparator ? groupSeparatorArray.get(rowIndex, columnIndex) : void 0;
      if (textObject.isError()) {
        return textObject;
      }
      if (decimalSeparatorObject.isError()) {
        return decimalSeparatorObject;
      }
      if (groupSeparatorObject == null ? void 0 : groupSeparatorObject.isError()) {
        return groupSeparatorObject;
      }
      if (decimalSeparatorObject.isNull() || (groupSeparatorObject == null ? void 0 : groupSeparatorObject.isNull())) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (textObject.isNull()) {
        return NumberValueObject.create(0);
      }
      return this._handleSingleObject(textObject, decimalSeparatorObject, groupSeparatorObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  // eslint-disable-next-line
  _handleSingleObject(text, decimalSeparator, groupSeparator) {
    let textValue = `${text.getValue()}`;
    textValue = textValue.replace(/\s+/g, "");
    let decimalSeparatorValue = `${decimalSeparator.getValue()}`;
    if (decimalSeparator.isBoolean()) {
      decimalSeparatorValue = decimalSeparatorValue.toLocaleUpperCase();
    }
    decimalSeparatorValue = decimalSeparatorValue.charAt(0);
    let groupSeparatorValue;
    if (groupSeparator) {
      groupSeparatorValue = `${groupSeparator.getValue()}`;
      if (groupSeparator.isBoolean()) {
        groupSeparatorValue = groupSeparatorValue.toLocaleUpperCase();
      }
      groupSeparatorValue = groupSeparatorValue.charAt(0);
      if (decimalSeparatorValue === groupSeparatorValue) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
    }
    if (textValue.trim() === "") {
      return NumberValueObject.create(0);
    }
    if (!textValue.match(/^\s*[+-]?\s*(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:[eE][+-]?\d+)?[ \t]*/)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const splitText = textValue.split(decimalSeparatorValue);
    if (splitText.length > 2) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let integerPart = splitText[0].replace(/,/g, "");
    if (groupSeparator) {
      integerPart = integerPart.split(groupSeparatorValue).join("");
    }
    let result = 0;
    if (splitText.length === 1) {
      if (decimalSeparatorValue === ",") {
        integerPart = integerPart.replace(/\./g, "");
      }
      let percentageCount = 0;
      while (integerPart.endsWith("%")) {
        integerPart = integerPart.slice(0, -1);
        percentageCount++;
      }
      if (percentageCount > 0) {
        result = +integerPart / 100 ** percentageCount;
      } else {
        result = +integerPart;
      }
    } else {
      if (!isRealNum(integerPart)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let decimalPart = splitText[1];
      let percentageCount = 0;
      while (decimalPart.endsWith("%")) {
        decimalPart = decimalPart.slice(0, -1);
        percentageCount++;
      }
      const resultText = `${integerPart}.${decimalPart}`;
      if (!isRealNum(resultText)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (percentageCount > 0) {
        result = +resultText / 100 ** percentageCount;
      } else {
        result = +resultText;
      }
    }
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/proper/index.ts
var Proper = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError() || text.isNull() || text.isBoolean() || text.isNumber()) {
      return text;
    }
    const textValue = text.getValue().toLocaleString();
    const result = textValue.toLocaleLowerCase().replace(/(^|\b|\W|\d|_)[a-z]/g, (txt) => txt.toLocaleUpperCase());
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/engine/utils/regexp-check.ts
var numberRange = () => [
  {
    type: 4 /* RANGE */,
    from: 48,
    to: 57
  }
];
var alphaNumericChars = () => [
  {
    type: 7 /* CHAR */,
    value: 95
  },
  {
    type: 4 /* RANGE */,
    from: 97,
    to: 122
  },
  {
    type: 4 /* RANGE */,
    from: 65,
    to: 90
  },
  {
    type: 4 /* RANGE */,
    from: 48,
    to: 57
  }
];
var whitespaceChars = () => [
  {
    type: 7 /* CHAR */,
    value: 9
  },
  {
    type: 7 /* CHAR */,
    value: 10
  },
  {
    type: 7 /* CHAR */,
    value: 11
  },
  {
    type: 7 /* CHAR */,
    value: 12
  },
  {
    type: 7 /* CHAR */,
    value: 13
  },
  {
    type: 7 /* CHAR */,
    value: 32
  },
  {
    type: 7 /* CHAR */,
    value: 160
  },
  {
    type: 7 /* CHAR */,
    value: 5760
  },
  {
    type: 4 /* RANGE */,
    from: 8192,
    to: 8202
  },
  {
    type: 7 /* CHAR */,
    value: 8232
  },
  {
    type: 7 /* CHAR */,
    value: 8233
  },
  {
    type: 7 /* CHAR */,
    value: 8239
  },
  {
    type: 7 /* CHAR */,
    value: 8287
  },
  {
    type: 7 /* CHAR */,
    value: 12288
  },
  {
    type: 7 /* CHAR */,
    value: 65279
  }
];
var words = () => ({
  type: 3 /* SET */,
  set: alphaNumericChars(),
  not: false
});
var notWords = () => ({
  type: 3 /* SET */,
  set: alphaNumericChars(),
  not: true
});
var ints = () => ({
  type: 3 /* SET */,
  set: numberRange(),
  not: false
});
var notInts = () => ({
  type: 3 /* SET */,
  set: numberRange(),
  not: true
});
var whitespace = () => ({
  type: 3 /* SET */,
  set: whitespaceChars(),
  not: false
});
var notWhitespace = () => ({
  type: 3 /* SET */,
  set: whitespaceChars(),
  not: true
});
var anyChar = () => ({
  type: 3 /* SET */,
  set: [
    {
      type: 7 /* CHAR */,
      value: 10
    },
    {
      type: 7 /* CHAR */,
      value: 13
    },
    {
      type: 7 /* CHAR */,
      value: 8232
    },
    {
      type: 7 /* CHAR */,
      value: 8233
    }
  ],
  not: true
});
function tokenizer(regExpString) {
  const root2 = {
    type: 0 /* ROOT */,
    stack: []
  };
  let currentScope = root2;
  let stack = root2.stack;
  const groups = [];
  const references = [];
  let captureCount = 0;
  const throwError = (index) => {
    throw new SyntaxError(`Invalid regular expression: /${regExpString}/: Nothing to repeat at column ${index - 1}`);
  };
  const strChars = strToChars(regExpString);
  let i = 0;
  let char;
  while (i < strChars.length) {
    char = strChars[i++];
    switch (char) {
      case "\\":
        if (i === strChars.length) {
          throw new SyntaxError(`Invalid regular expression: /${regExpString}/: \\ at end of pattern`);
        }
        char = strChars[i++];
        switch (char) {
          case "b":
            stack.push({
              type: 2 /* POSITION */,
              value: "b"
            });
            break;
          case "B":
            stack.push({
              type: 2 /* POSITION */,
              value: "B"
            });
            break;
          case "w":
            stack.push(words());
            break;
          case "W":
            stack.push(notWords());
            break;
          case "d":
            stack.push(ints());
            break;
          case "D":
            stack.push(notInts());
            break;
          case "s":
            stack.push(whitespace());
            break;
          case "S":
            stack.push(notWhitespace());
            break;
          default:
            if (/\d/.test(char)) {
              while (/\d/.test(strChars[i]) && i < strChars.length) {
                char += strChars[i++];
              }
              const num = Number.parseInt(char, 10);
              stack.push({
                type: 6 /* REFERENCE */,
                value: num
              });
              references.push({
                reference: {
                  type: 6 /* REFERENCE */,
                  value: num
                },
                stack,
                index: stack.length - 1
              });
            } else {
              stack.push({
                type: 7 /* CHAR */,
                value: char.charCodeAt(0)
              });
            }
        }
        break;
      case "^":
        stack.push({
          type: 2 /* POSITION */,
          value: "^"
        });
        break;
      case "$":
        stack.push({
          type: 2 /* POSITION */,
          value: "$"
        });
        break;
      case "[": {
        const negated = strChars[i] === "^";
        if (negated) {
          i++;
        }
        const classTokens = tokenizeClass(strChars.slice(i), regExpString);
        i += classTokens[1];
        stack.push({
          type: 3 /* SET */,
          set: classTokens[0],
          not: negated
        });
        break;
      }
      case ".":
        stack.push(anyChar());
        break;
      case "(": {
        const group = {
          type: 1 /* GROUP */,
          stack: [],
          remember: true
          // 默认情况下，捕获组是需要记住（捕获）的
        };
        if (strChars[i] === "?") {
          const nextChar = strChars[i + 1];
          i += 2;
          if (nextChar === "=") {
            group.followedBy = true;
          } else if (nextChar === "!") {
            group.notFollowedBy = true;
          } else if (nextChar !== ":") {
            throw new SyntaxError(`Invalid regular expression: /${regExpString}/: Invalid group, character '${nextChar}' after '?' at column ${i - 1}`);
          }
          group.remember = false;
        } else {
          captureCount += 1;
        }
        stack.push(group);
        groups.push(currentScope);
        currentScope = group;
        stack = group.stack;
        break;
      }
      case ")":
        if (groups.length === 0) {
          throw new SyntaxError(`Invalid regular expression: /${regExpString}/: Unmatched ) at column ${i - 1}`);
        }
        currentScope = groups.pop();
        stack = currentScope.options ? currentScope.options[currentScope.options.length - 1] : currentScope.stack;
        break;
      case "|": {
        if (!currentScope.options) {
          currentScope.options = [currentScope.stack];
          delete currentScope.stack;
        }
        const newOption = [];
        currentScope.options.push(newOption);
        stack = newOption;
        break;
      }
      case "{": {
        const match = /^(\d+)(,(\d+)?)?\}/.exec(strChars.slice(i));
        if (match) {
          if (stack.length === 0) {
            throwError(i);
          }
          const min2 = Number.parseInt(match[1], 10);
          const max2 = match[2] ? match[3] ? Number.parseInt(match[3], 10) : Infinity : min2;
          i += match[0].length;
          stack.push({
            type: 5 /* REPETITION */,
            min: min2,
            max: max2,
            value: stack.pop()
          });
        } else {
          stack.push({
            // Assuming 123 is the character code for '{'
            type: 7 /* CHAR */,
            value: 123
          });
        }
        break;
      }
      case "?":
        if (stack.length === 0) {
          throwError(i);
        }
        stack.push({
          type: 5 /* REPETITION */,
          min: 0,
          max: 1,
          value: stack.pop()
        });
        break;
      case "+":
        if (stack.length === 0) {
          throwError(i);
        }
        stack.push({
          type: 5 /* REPETITION */,
          min: 1,
          max: Infinity,
          value: stack.pop()
        });
        break;
      case "*":
        if (stack.length === 0) {
          throwError(i);
        }
        stack.push({
          type: 5 /* REPETITION */,
          min: 0,
          max: Infinity,
          value: stack.pop()
        });
        break;
      default:
        stack.push({
          type: 7 /* CHAR */,
          value: char.charCodeAt(0)
        });
    }
  }
  if (groups.length > 0) {
    throw new SyntaxError(`Invalid regular expression: /${regExpString}/: Unterminated group`);
  }
  processReferences(references, captureCount);
  return root2;
}
function tokenizeClass(input, pattern) {
  let match;
  const tokens = [];
  const regex = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
  while ((match = regex.exec(input)) !== null) {
    let token = null;
    const [, _words, _digit, _space, _notWords, _notDigit, _notSpace, range, rangeFrom, rangeTo, char] = match;
    if (_words || _digit || _space || _notWords || _notDigit || _notSpace) {
      token = (() => {
        let result = {
          type: 3 /* SET */,
          set: [],
          not: false
        };
        if (_words) {
          result = words();
        } else if (_digit) {
          result = ints();
        } else if (_space) {
          result = whitespace();
        } else if (_notWords) {
          result = notWords();
        } else if (_notDigit) {
          result = notInts();
        } else if (_notSpace) {
          result = notWhitespace();
        }
        return result;
      })();
    } else if (range && char) {
      token = {
        type: 4 /* RANGE */,
        from: (rangeFrom || rangeTo).charCodeAt(0),
        to: char.charCodeAt(char.length - 1)
      };
    } else if (match[16]) {
      token = {
        type: 7 /* CHAR */,
        value: match[16].charCodeAt(0)
      };
    }
    if (!token) {
      return [tokens, regex.lastIndex];
    }
    tokens.push(token);
  }
  throw new SyntaxError(`Invalid regular expression: /${pattern}/: Unterminated character class`);
}
function strToChars(str) {
  return str.replace(
    /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g,
    (match, backspace, escapeChar, unicode, hex, ctrl, special) => {
      if (escapeChar) {
        return match;
      }
      let charCode;
      if (backspace) {
        charCode = 8;
      } else if (unicode) {
        charCode = Number.parseInt(unicode, 16);
      } else if (hex) {
        charCode = Number.parseInt(hex, 16);
      } else if (ctrl) {
        charCode = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?".indexOf(ctrl);
      } else {
        const specialMode = {
          0: 0,
          t: 9,
          n: 10,
          v: 11,
          f: 12,
          r: 13
        };
        charCode = specialMode[special];
      }
      const char = String.fromCharCode(charCode);
      return /[[\]{}^$.|?*+()]/.test(char) ? `\\${char}` : char;
    }
  );
}
function processReferences(references, captureCount) {
  for (const ref of references.reverse()) {
    const value = ref.reference.value;
    if (captureCount < value) {
      ref.reference.type = 7 /* CHAR */;
      const valueStr = value.toString();
      ref.reference.value = Number.parseInt(valueStr, 8);
      if (!/^[0-7]+$/.test(valueStr)) {
        let startIndex = 0;
        while (valueStr[startIndex] !== "8" && valueStr[startIndex] !== "9" && startIndex < valueStr.length) {
          startIndex += 1;
        }
        if (startIndex === 0) {
          ref.reference.value = valueStr.charCodeAt(0);
          startIndex += 1;
        } else {
          ref.reference.value = Number.parseInt(valueStr.slice(0, startIndex), 8);
        }
        if (valueStr.length > startIndex) {
          const remainingStack = ref.stack.splice(ref.index + 1);
          for (const char of valueStr.slice(startIndex)) {
            ref.stack.push({
              type: 7 /* CHAR */,
              value: char.charCodeAt(0)
            });
          }
          ref.stack.push(...remainingStack);
        }
      }
    }
  }
}
function handleRegExp(regExpString, isGlobal) {
  if (!isValidRegExp(regExpString)) {
    return {
      isError: true,
      regExp: null
    };
  }
  try {
    const regExp = new RegExp(regExpString, isGlobal ? "ug" : "u");
    if (!isSafeRegExp(regExp)) {
      return {
        isError: true,
        regExp: null
      };
    }
    return {
      isError: false,
      regExp
    };
  } catch (error) {
    return {
      isError: true,
      regExp: null
    };
  }
}
function isValidRegExp(regExpString) {
  return !(/\(\?<=.*?\)/g.test(regExpString) && !/\[.*?(\?<=.*?)\]/g.test(regExpString) || /\(\?<!.*?\)/g.test(regExpString) && !/\[.*?(\?<!.*?)\]/g.test(regExpString));
}
function isSafeRegExp(regExp, options) {
  var _a2;
  const limit = (_a2 = options == null ? void 0 : options.limit) != null ? _a2 : 25;
  let str;
  if (Object.prototype.toString.call(regExp) === "[object RegExp]") {
    str = regExp.source;
  } else if (regExp && typeof regExp !== "string") {
    str = `${regExp}`;
  }
  let tokens;
  try {
    tokens = tokenizer(str);
  } catch (error) {
    return false;
  }
  let count = 0;
  const validateToken = (token, depth) => {
    let _depth = depth;
    if (token.type === 5 /* REPETITION */) {
      _depth++;
      count++;
      if (_depth > 1) {
        return false;
      }
      if (count > limit) {
        return false;
      }
    }
    if (token.options) {
      for (const option of token.options) {
        const result = validateToken({ stack: option }, _depth);
        if (!result) {
          return false;
        }
      }
    }
    const stack = token.stack || token.value && token.value.stack;
    if (!stack) {
      return true;
    }
    for (const item of stack) {
      const result = validateToken(item, _depth);
      if (!result) {
        return false;
      }
    }
    return true;
  };
  return validateToken(tokens, 0);
}

// ../packages/engine-formula/src/functions/text/regexextract/index.ts
var Regexextract = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, regularExpression) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArray(text, regularExpression);
    if (isError) {
      return errorObject;
    }
    const [textObject, regularExpressionObject] = variants;
    let textValue = textObject.getValue();
    if (textObject.isNull()) {
      textValue = "";
    }
    if (textObject.isBoolean()) {
      textValue = textValue ? "TRUE" : "FALSE";
    }
    textValue = `${textValue}`;
    let regularExpressionValue = regularExpressionObject.getValue();
    if (regularExpressionObject.isNull()) {
      regularExpressionValue = "";
    }
    if (regularExpressionObject.isBoolean()) {
      regularExpressionValue = regularExpressionValue ? "TRUE" : "FALSE";
    }
    regularExpressionValue = `${regularExpressionValue}`;
    const { isError: isError_regExp, regExp } = handleRegExp(regularExpressionValue, false);
    if (isError_regExp) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const result = textValue.match(regExp);
    if (result === null) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (result.length > 1) {
      const resultArray = result.slice(1).map((item) => StringValueObject.create(item));
      if (resultArray.length > 1) {
        return ArrayValueObject.create({
          calculateValueList: [resultArray],
          rowCount: 1,
          columnCount: resultArray.length,
          unitId: this.unitId,
          sheetId: this.subUnitId,
          row: this.row,
          column: this.column
        });
      }
      return resultArray[0];
    }
    return StringValueObject.create(result[0]);
  }
};

// ../packages/engine-formula/src/functions/text/regexmatch/index.ts
var Regexmatch = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, regularExpression) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArray(text, regularExpression);
    if (isError) {
      return errorObject;
    }
    const [textObject, regularExpressionObject] = variants;
    let textValue = textObject.getValue();
    if (textObject.isNull()) {
      textValue = "";
    }
    if (textObject.isBoolean()) {
      textValue = textValue ? "TRUE" : "FALSE";
    }
    textValue = `${textValue}`;
    let regularExpressionValue = regularExpressionObject.getValue();
    if (regularExpressionObject.isNull()) {
      regularExpressionValue = "";
    }
    if (regularExpressionObject.isBoolean()) {
      regularExpressionValue = regularExpressionValue ? "TRUE" : "FALSE";
    }
    regularExpressionValue = `${regularExpressionValue}`;
    const { isError: isError_regExp, regExp } = handleRegExp(regularExpressionValue, false);
    if (isError_regExp) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const result = textValue.match(regExp);
    if (result === null) {
      return BooleanValueObject.create(false);
    }
    return BooleanValueObject.create(true);
  }
};

// ../packages/engine-formula/src/functions/text/regexreplace/index.ts
var Regexreplace = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 3);
  }
  calculate(text, regularExpression, replacement) {
    const { isError, errorObject, variants } = checkVariantsErrorIsArray(text, regularExpression, replacement);
    if (isError) {
      return errorObject;
    }
    const [textObject, regularExpressionObject, replacementObject] = variants;
    let textValue = textObject.getValue();
    if (textObject.isNull()) {
      textValue = "";
    }
    if (textObject.isBoolean()) {
      textValue = textValue ? "TRUE" : "FALSE";
    }
    textValue = `${textValue}`;
    let regularExpressionValue = regularExpressionObject.getValue();
    if (regularExpressionObject.isNull()) {
      regularExpressionValue = "";
    }
    if (regularExpressionObject.isBoolean()) {
      regularExpressionValue = regularExpressionValue ? "TRUE" : "FALSE";
    }
    regularExpressionValue = `${regularExpressionValue}`;
    let replacementValue = replacementObject.getValue();
    if (replacementObject.isNull()) {
      replacementValue = "";
    }
    if (replacementObject.isBoolean()) {
      replacementValue = replacementValue ? "TRUE" : "FALSE";
    }
    replacementValue = `${replacementValue}`;
    const { isError: isError_regExp, regExp } = handleRegExp(regularExpressionValue, true);
    if (isError_regExp) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    const result = textValue.replace(regExp, replacementValue);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/replace/index.ts
var Replace = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(oldText, startNum, numChars, newText) {
    const maxRowLength = Math.max(
      oldText.isArray() ? oldText.getRowCount() : 1,
      startNum.isArray() ? startNum.getRowCount() : 1,
      numChars.isArray() ? numChars.getRowCount() : 1,
      newText.isArray() ? newText.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      oldText.isArray() ? oldText.getColumnCount() : 1,
      startNum.isArray() ? startNum.getColumnCount() : 1,
      numChars.isArray() ? numChars.getColumnCount() : 1,
      newText.isArray() ? newText.getColumnCount() : 1
    );
    const oldTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, oldText, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, startNum, ErrorValueObject.create("#N/A" /* NA */));
    const numCharsArray = expandArrayValueObject(maxRowLength, maxColumnLength, numChars, ErrorValueObject.create("#N/A" /* NA */));
    const newTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, newText, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = oldTextArray.mapValue((oldTextObject, rowIndex, columnIndex) => {
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      const numCharsObject = numCharsArray.get(rowIndex, columnIndex);
      const newTextObject = newTextArray.get(rowIndex, columnIndex);
      if (oldTextObject.isError()) {
        return oldTextObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      if (numCharsObject.isError()) {
        return numCharsObject;
      }
      if (newTextObject.isError()) {
        return newTextObject;
      }
      return this._handleSingleObject(oldTextObject, startNumObject, numCharsObject, newTextObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(oldText, startNum, numChars, newText) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum, numChars);
    if (isError) {
      return errorObject;
    }
    const [startNumObject, numCharsObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    const numCharsValue = Math.floor(+numCharsObject.getValue());
    if (startNumValue <= 0 || numCharsValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const oldTextValue = getTextValueOfNumberFormat(oldText);
    const newTextValue = getTextValueOfNumberFormat(newText);
    const result = oldTextValue.substring(0, startNumValue - 1) + newTextValue + oldTextValue.substring(startNumValue - 1 + numCharsValue);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/replaceb/index.ts
var Replaceb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 4);
    __publicField(this, "maxParams", 4);
  }
  calculate(oldText, startNum, numBytes, newText) {
    const maxRowLength = Math.max(
      oldText.isArray() ? oldText.getRowCount() : 1,
      startNum.isArray() ? startNum.getRowCount() : 1,
      numBytes.isArray() ? numBytes.getRowCount() : 1,
      newText.isArray() ? newText.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      oldText.isArray() ? oldText.getColumnCount() : 1,
      startNum.isArray() ? startNum.getColumnCount() : 1,
      numBytes.isArray() ? numBytes.getColumnCount() : 1,
      newText.isArray() ? newText.getColumnCount() : 1
    );
    const oldTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, oldText, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, startNum, ErrorValueObject.create("#N/A" /* NA */));
    const numBytesArray = expandArrayValueObject(maxRowLength, maxColumnLength, numBytes, ErrorValueObject.create("#N/A" /* NA */));
    const newTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, newText, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = oldTextArray.mapValue((oldTextObject, rowIndex, columnIndex) => {
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      const numBytesObject = numBytesArray.get(rowIndex, columnIndex);
      const newTextObject = newTextArray.get(rowIndex, columnIndex);
      if (oldTextObject.isError()) {
        return oldTextObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      if (numBytesObject.isError()) {
        return numBytesObject;
      }
      if (newTextObject.isError()) {
        return newTextObject;
      }
      return this._handleSingleObject(oldTextObject, startNumObject, numBytesObject, newTextObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(oldText, startNum, numBytes, newText) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum, numBytes);
    if (isError) {
      return errorObject;
    }
    const [startNumObject, numBytesObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    const numBytesValue = Math.floor(+numBytesObject.getValue());
    if (startNumValue <= 0 || numBytesValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let oldTextValue = getTextValueOfNumberFormat(oldText);
    const newTextValue = getTextValueOfNumberFormat(newText);
    let result = oldTextValue.substring(0, startNumValue - 1);
    oldTextValue = oldTextValue.substring(startNumValue - 1);
    let index = 0;
    let lenByte = 0;
    while (lenByte < numBytesValue && index < oldTextValue.length) {
      lenByte += getCharLenByteInText(oldTextValue, index);
      index++;
    }
    result += newTextValue + oldTextValue.substring(index);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/rept/index.ts
var Rept = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, numberTimes) {
    if (text.isError()) {
      return text;
    }
    if (numberTimes.isError()) {
      return numberTimes;
    }
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      numberTimes.isArray() ? numberTimes.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      numberTimes.isArray() ? numberTimes.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const numberTimesArray = expandArrayValueObject(maxRowLength, maxColumnLength, numberTimes, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = textArray.map((textObject, rowIndex, columnIndex) => {
      let numberTimesObject = numberTimesArray.get(rowIndex, columnIndex);
      if (textObject.isError()) {
        return textObject;
      }
      let textValue = textObject.getValue();
      if (textObject.isNull()) {
        textValue = "";
      }
      if (textObject.isBoolean()) {
        textValue = textValue ? "TRUE" : "FALSE";
      }
      textValue += "";
      if (numberTimesObject.isString()) {
        numberTimesObject = numberTimesObject.convertToNumberObjectValue();
      }
      if (numberTimesObject.isError()) {
        return numberTimesObject;
      }
      const stringMaxLength = 32767;
      const numberTimesValue = Math.floor(+numberTimesObject.getValue());
      if (numberTimesValue < 0 || numberTimesValue > stringMaxLength / textValue.length) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const result = textValue.repeat(numberTimesValue);
      return StringValueObject.create(result);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
};

// ../packages/engine-formula/src/functions/text/right/index.ts
var Right = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, numChars) {
    const _numChars = numChars != null ? numChars : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _numChars.isArray() ? _numChars.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _numChars.isArray() ? _numChars.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const numCharsArray = expandArrayValueObject(maxRowLength, maxColumnLength, _numChars, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const numCharsObject = numCharsArray.get(rowIndex, columnIndex);
      if (textObject.isError()) {
        return textObject;
      }
      if (numCharsObject.isError()) {
        return numCharsObject;
      }
      return this._handleSingleObject(textObject, numCharsObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text, numChars) {
    const textValue = getTextValueOfNumberFormat(text);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numChars);
    if (isError) {
      return errorObject;
    }
    const [numCharsObject] = variants;
    const numCharsValue = Math.floor(+numCharsObject.getValue());
    if (numCharsValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (text.isNull() || numCharsValue === 0) {
      return StringValueObject.create("");
    }
    if (numCharsValue >= textValue.length) {
      return StringValueObject.create(textValue);
    }
    const result = textValue.substring(textValue.length - numCharsValue);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/rightb/index.ts
var Rightb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, numBytes) {
    const _numBytes = numBytes != null ? numBytes : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _numBytes.isArray() ? _numBytes.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _numBytes.isArray() ? _numBytes.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const numBytesArray = expandArrayValueObject(maxRowLength, maxColumnLength, _numBytes, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const numBytesObject = numBytesArray.get(rowIndex, columnIndex);
      if (textObject.isError()) {
        return textObject;
      }
      if (numBytesObject.isError()) {
        return numBytesObject;
      }
      return this._handleSingleObject(textObject, numBytesObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text, numBytes) {
    const textValue = getTextValueOfNumberFormat(text);
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(numBytes);
    if (isError) {
      return errorObject;
    }
    const [numBytesObject] = variants;
    const numBytesValue = Math.floor(+numBytesObject.getValue());
    if (numBytesValue < 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (text.isNull() || numBytesValue === 0) {
      return StringValueObject.create("");
    }
    let index = textValue.length - 1;
    let lenByte = 0;
    let result = "";
    while (lenByte < numBytesValue && index >= 0) {
      lenByte += getCharLenByteInText(textValue, index, "rtl");
      result = textValue.charAt(index) + result;
      index--;
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/search/index.ts
var Search = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(findText, withinText, startNum) {
    const _startNum = startNum != null ? startNum : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      findText.isArray() ? findText.getRowCount() : 1,
      withinText.isArray() ? withinText.getRowCount() : 1,
      _startNum.isArray() ? _startNum.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      findText.isArray() ? findText.getColumnCount() : 1,
      withinText.isArray() ? withinText.getColumnCount() : 1,
      _startNum.isArray() ? _startNum.getColumnCount() : 1
    );
    const findTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, findText, ErrorValueObject.create("#N/A" /* NA */));
    const withinTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, withinText, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _startNum, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = findTextArray.mapValue((findTextObject, rowIndex, columnIndex) => {
      const withinTextObject = withinTextArray.get(rowIndex, columnIndex);
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      if (findTextObject.isError()) {
        return findTextObject;
      }
      if (withinTextObject.isError()) {
        return withinTextObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      return this._handleSingleObject(findTextObject, withinTextObject, startNumObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(findText, withinText, startNum) {
    const findTextValue = getTextValueOfNumberFormat(findText).toLocaleUpperCase();
    const withinTextValue = getTextValueOfNumberFormat(withinText).toLocaleUpperCase();
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum);
    if (isError) {
      return errorObject;
    }
    const [startNumObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    if (withinText.isNull() || startNumValue <= 0 || startNumValue > withinTextValue.length) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (findText.isNull() || findTextValue.length === 0) {
      return NumberValueObject.create(startNumValue);
    }
    const result = withinTextValue.indexOf(findTextValue, startNumValue - 1);
    if (result === -1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return NumberValueObject.create(result + 1);
  }
};

// ../packages/engine-formula/src/functions/text/searchb/index.ts
var Searchb = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 3);
  }
  calculate(findText, withinText, startNum) {
    const _startNum = startNum != null ? startNum : NumberValueObject.create(1);
    const maxRowLength = Math.max(
      findText.isArray() ? findText.getRowCount() : 1,
      withinText.isArray() ? withinText.getRowCount() : 1,
      _startNum.isArray() ? _startNum.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      findText.isArray() ? findText.getColumnCount() : 1,
      withinText.isArray() ? withinText.getColumnCount() : 1,
      _startNum.isArray() ? _startNum.getColumnCount() : 1
    );
    const findTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, findText, ErrorValueObject.create("#N/A" /* NA */));
    const withinTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, withinText, ErrorValueObject.create("#N/A" /* NA */));
    const startNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _startNum, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = findTextArray.mapValue((findTextObject, rowIndex, columnIndex) => {
      const withinTextObject = withinTextArray.get(rowIndex, columnIndex);
      const startNumObject = startNumArray.get(rowIndex, columnIndex);
      if (findTextObject.isError()) {
        return findTextObject;
      }
      if (withinTextObject.isError()) {
        return withinTextObject;
      }
      if (startNumObject.isError()) {
        return startNumObject;
      }
      return this._handleSingleObject(findTextObject, withinTextObject, startNumObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(findText, withinText, startNum) {
    const findTextValue = getTextValueOfNumberFormat(findText).toLocaleUpperCase();
    const withinTextValue = getTextValueOfNumberFormat(withinText).toLocaleUpperCase();
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(startNum);
    if (isError) {
      return errorObject;
    }
    const [startNumObject] = variants;
    const startNumValue = Math.floor(+startNumObject.getValue());
    if (withinText.isNull() || startNumValue <= 0 || startNumValue > withinTextValue.length) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (findText.isNull() || findTextValue.length === 0) {
      return NumberValueObject.create(startNumValue);
    }
    const index = withinTextValue.indexOf(findTextValue, startNumValue - 1);
    if (index === -1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = charLenByte(withinTextValue.substring(0, index)) + 1;
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/substitute/index.ts
var Substitute = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 4);
  }
  calculate(text, oldText, newText, instanceNum) {
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      oldText.isArray() ? oldText.getRowCount() : 1,
      newText.isArray() ? newText.getRowCount() : 1,
      (instanceNum == null ? void 0 : instanceNum.isArray()) ? instanceNum.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      oldText.isArray() ? oldText.getColumnCount() : 1,
      newText.isArray() ? newText.getColumnCount() : 1,
      (instanceNum == null ? void 0 : instanceNum.isArray()) ? instanceNum.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const oldTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, oldText, ErrorValueObject.create("#N/A" /* NA */));
    const newTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, newText, ErrorValueObject.create("#N/A" /* NA */));
    const instanceNumArray = instanceNum ? expandArrayValueObject(maxRowLength, maxColumnLength, instanceNum, ErrorValueObject.create("#N/A" /* NA */)) : void 0;
    const resultArray = textArray.mapValue((textObject, rowIndex, columnIndex) => {
      const oldTextObject = oldTextArray.get(rowIndex, columnIndex);
      const newTextObject = newTextArray.get(rowIndex, columnIndex);
      let instanceNumObject = instanceNum ? instanceNumArray.get(rowIndex, columnIndex) : void 0;
      if (textObject.isError()) {
        return textObject;
      }
      if (oldTextObject.isError()) {
        return oldTextObject;
      }
      if (newTextObject.isError()) {
        return newTextObject;
      }
      if (instanceNumObject == null ? void 0 : instanceNumObject.isError()) {
        return instanceNumObject;
      }
      if ((instanceNumObject == null ? void 0 : instanceNumObject.isNull()) || (instanceNumObject == null ? void 0 : instanceNumObject.isBoolean())) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (instanceNumObject == null ? void 0 : instanceNumObject.isString()) {
        instanceNumObject = instanceNumObject.convertToNumberObjectValue();
      }
      if (instanceNumObject == null ? void 0 : instanceNumObject.isError()) {
        return instanceNumObject;
      }
      return this._handleSingleObject(textObject, oldTextObject, newTextObject, instanceNumObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(text, oldText, newText, instanceNum) {
    const textValue = this._getObjectString(text);
    const oldTextValue = this._getObjectString(oldText);
    const newTextValue = this._getObjectString(newText);
    const instanceNumValue = instanceNum ? Math.floor(+instanceNum.getValue()) : void 0;
    if (instanceNum && instanceNumValue <= 0) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (oldTextValue === "") {
      return StringValueObject.create(textValue);
    }
    let result = "";
    let num = 0;
    for (let i = 0; i < textValue.length; i++) {
      const str = textValue.substr(i, oldTextValue.length);
      if (str === oldTextValue || str.length === oldTextValue.length && str.trim() === oldTextValue.trim()) {
        num++;
        if (num === instanceNumValue) {
          result = textValue.substr(0, i) + newTextValue + textValue.substr(i + oldTextValue.length);
          break;
        }
        if (instanceNumValue === void 0) {
          result += newTextValue;
        }
        i += oldTextValue.length - 1;
      } else {
        if (instanceNumValue === void 0) {
          result += textValue[i];
        }
      }
    }
    if (instanceNumValue && num < instanceNumValue) {
      result = textValue;
    }
    return StringValueObject.create(result);
  }
  _getObjectString(variant) {
    let value = `${variant.getValue()}`;
    if (variant.isNull()) {
      value = "";
    }
    if (variant.isBoolean()) {
      value = value.toLocaleUpperCase();
    }
    return value;
  }
};

// ../packages/engine-formula/src/functions/text/t/index.ts
var T = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
    __publicField(this, "needsReferenceObject", true);
  }
  calculate(value) {
    let _value = value;
    if (value.isReferenceObject()) {
      _value = value.toArrayValueObject().get(0, 0);
    }
    if (_value.isArray()) {
      return _value.mapValue((valueObject) => this._handleSingleObject(valueObject));
    }
    return this._handleSingleObject(_value);
  }
  _handleSingleObject(value) {
    if (value.isError()) {
      return value;
    }
    if (value.isNull() || value.isBoolean() || value.isNumber()) {
      return StringValueObject.create("");
    }
    return value;
  }
};

// ../packages/engine-formula/src/functions/text/text/index.ts
var Text = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 2);
  }
  calculate(text, formatText) {
    if (text.isError()) {
      return text;
    }
    if (formatText.isError()) {
      return formatText;
    }
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      formatText.isArray() ? formatText.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      formatText.isArray() ? formatText.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text);
    const formatTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, formatText);
    return textArray.map((textValue, rowIndex, columnIndex) => {
      if (textValue.isError()) {
        return textValue;
      }
      let formatTextValue = formatTextArray.get(rowIndex, columnIndex) || StringValueObject.create(" ");
      if (formatTextValue.isError()) {
        return formatTextValue;
      }
      if (formatTextValue.isBoolean()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (textValue.isBoolean()) {
        return textValue;
      }
      let textValueNumber = textValue.getValue();
      if (textValue.isNull()) {
        textValueNumber = 0;
      }
      if (textValue.isString()) {
        if (!isRealNum(textValueNumber)) {
          return textValue;
        }
        textValueNumber = Number(textValueNumber);
      }
      if (formatTextValue.isNull()) {
        formatTextValue = StringValueObject.create(" ");
      }
      const formatTextValueString = `${formatTextValue.getValue()}`;
      const previewText = getFormatPreview(formatTextValueString, textValueNumber);
      return StringValueObject.create(formatTextValueString === " " ? previewText.trimEnd() : previewText);
    });
  }
};

// ../packages/engine-formula/src/functions/text/textafter/index.ts
var Textafter = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 6);
  }
  calculate(text, delimiter, instanceNum, matchMode, matchEnd, ifNotFound) {
    let instanceNumIsNull = false;
    let _instanceNum = instanceNum != null ? instanceNum : NumberValueObject.create(1);
    if (_instanceNum.isNull()) {
      instanceNumIsNull = true;
      _instanceNum = NumberValueObject.create(1);
    }
    const onlyThreeVariant = !matchMode;
    const _matchMode = matchMode != null ? matchMode : NumberValueObject.create(0);
    const _matchEnd = matchEnd != null ? matchEnd : NumberValueObject.create(0);
    const _ifNotFound = ifNotFound != null ? ifNotFound : ErrorValueObject.create("#N/A" /* NA */);
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _instanceNum.isArray() ? _instanceNum.getRowCount() : 1,
      _matchMode.isArray() ? _matchMode.getRowCount() : 1,
      _matchEnd.isArray() ? _matchEnd.getRowCount() : 1,
      _ifNotFound.isArray() ? _ifNotFound.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _instanceNum.isArray() ? _instanceNum.getColumnCount() : 1,
      _matchMode.isArray() ? _matchMode.getColumnCount() : 1,
      _matchEnd.isArray() ? _matchEnd.getColumnCount() : 1,
      _ifNotFound.isArray() ? _ifNotFound.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const instanceNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _instanceNum, ErrorValueObject.create("#N/A" /* NA */));
    const matchModeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _matchMode, ErrorValueObject.create("#N/A" /* NA */));
    const matchEndArray = expandArrayValueObject(maxRowLength, maxColumnLength, _matchEnd, ErrorValueObject.create("#N/A" /* NA */));
    const ifNotFoundArray = expandArrayValueObject(maxRowLength, maxColumnLength, _ifNotFound, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = this._getResultArray(textArray, delimiter, instanceNumArray, matchModeArray, matchEndArray, ifNotFoundArray, instanceNumIsNull, onlyThreeVariant);
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResultArray(textArray, delimiter, instanceNumArray, matchModeArray, matchEndArray, ifNotFoundArray, instanceNumIsNull, onlyThreeVariant) {
    const resultArray = textArray.map((textObject, rowIndex, columnIndex) => {
      const instanceNumObject = instanceNumArray.get(rowIndex, columnIndex);
      const matchModeObject = matchModeArray.get(rowIndex, columnIndex);
      const matchEndObject = matchEndArray.get(rowIndex, columnIndex);
      const ifNotFoundObject = ifNotFoundArray.get(rowIndex, columnIndex);
      const _variantsError = this._checkVariantsError(textObject, instanceNumObject, matchModeObject, matchEndObject);
      if (_variantsError.isError()) {
        return _variantsError;
      }
      const textValue = this._getStringValue(textObject);
      const delimiterValue = this._getDelimiterValue(delimiter);
      if (delimiterValue instanceof ErrorValueObject) {
        return delimiterValue;
      }
      const _variantsNumberFloorValue = this._getVariantsNumberFloorValue(instanceNumObject, matchModeObject, matchEndObject);
      if (_variantsNumberFloorValue instanceof ErrorValueObject) {
        return _variantsNumberFloorValue;
      }
      const [instanceNumValue, matchModeValue, matchEndValue] = _variantsNumberFloorValue;
      if (instanceNumValue === 0 || matchModeValue < 0 || matchModeValue > 1 || matchEndValue < 0 || matchEndValue > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (delimiterValue.includes("")) {
        if (instanceNumValue > 0) {
          return StringValueObject.create(textValue);
        } else {
          return StringValueObject.create("");
        }
      }
      if (!instanceNumIsNull && Math.abs(instanceNumValue) > textValue.length) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (delimiterValue.every((item) => item.length > textValue.length)) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return this._getResult(textValue, delimiterValue, instanceNumValue, matchModeValue, matchEndValue, ifNotFoundObject, onlyThreeVariant);
    });
    return resultArray;
  }
  _checkVariantsError(...variantas) {
    for (let i = 0; i < variantas.length; i++) {
      const variant = variantas[i];
      if (variant.isError()) {
        return variant;
      }
    }
    return BooleanValueObject.create(true);
  }
  _getStringValue(variant) {
    let value = `${variant.getValue()}`;
    if (variant.isNull()) {
      value = "";
    }
    if (variant.isBoolean()) {
      value = value.toLocaleUpperCase();
    }
    return value;
  }
  _getDelimiterValue(delimiter) {
    const delimiterValue = [];
    if (delimiter.isArray()) {
      let isError = false;
      let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
      delimiter.iterator((delimiterObject) => {
        const _delimiterObject = delimiterObject;
        if (_delimiterObject.isError()) {
          isError = true;
          errorObject = _delimiterObject;
          return false;
        }
        delimiterValue.push(this._getStringValue(_delimiterObject));
      });
      if (isError) {
        return errorObject;
      }
    } else {
      if (delimiter.isError()) {
        return delimiter;
      }
      delimiterValue.push(this._getStringValue(delimiter));
    }
    return delimiterValue;
  }
  _getVariantsNumberFloorValue(...variants) {
    const values = [];
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      const value = Math.floor(+variant.getValue());
      values.push(value);
    }
    return values;
  }
  _getResult(textValue, delimiterValue, instanceNumValue, matchModeValue, matchEndValue, ifNotFoundObject, onlyThreeVariant) {
    let substrText = !matchModeValue ? textValue : textValue.toLocaleLowerCase();
    const _delimiterValue = !matchModeValue ? delimiterValue : delimiterValue.map((item) => item.toLocaleLowerCase());
    let resultIndex = 0;
    let matchNum = 0;
    let preDelimiterLength = 0;
    for (let i = 0; i < Math.abs(instanceNumValue); i++) {
      if (instanceNumValue < 0) {
        const delimiterItem = _delimiterValue.map((item) => {
          return {
            index: substrText.lastIndexOf(item),
            length: item.length
          };
        }).filter((item) => item.index !== -1).sort((a2, b) => b.index - a2.index)[0];
        if (!delimiterItem) {
          break;
        }
        resultIndex = delimiterItem.index;
        substrText = substrText.substr(0, delimiterItem.index);
        preDelimiterLength = delimiterItem.length;
        matchNum++;
      } else {
        const delimiterItem = _delimiterValue.map((item) => {
          return {
            index: substrText.indexOf(item),
            length: item.length
          };
        }).filter((item) => item.index !== -1).sort((a2, b) => a2.index - b.index)[0];
        if (!delimiterItem) {
          break;
        }
        resultIndex += delimiterItem.index + preDelimiterLength;
        substrText = substrText.substr(delimiterItem.index + delimiterItem.length);
        preDelimiterLength = delimiterItem.length;
        matchNum++;
      }
    }
    if (matchNum && matchNum < Math.abs(instanceNumValue) && onlyThreeVariant) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (!matchNum || matchNum < Math.abs(instanceNumValue)) {
      if (matchEndValue) {
        if (instanceNumValue > 0) {
          return StringValueObject.create("");
        } else {
          return StringValueObject.create(textValue);
        }
      }
      return ifNotFoundObject;
    }
    const result = textValue.substr(resultIndex + preDelimiterLength);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/textbefore/index.ts
var Textbefore = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 6);
  }
  calculate(text, delimiter, instanceNum, matchMode, matchEnd, ifNotFound) {
    let instanceNumIsNull = false;
    let _instanceNum = instanceNum != null ? instanceNum : NumberValueObject.create(1);
    if (_instanceNum.isNull()) {
      instanceNumIsNull = true;
      _instanceNum = NumberValueObject.create(1);
    }
    const onlyThreeVariant = !matchMode;
    const _matchMode = matchMode != null ? matchMode : NumberValueObject.create(0);
    const _matchEnd = matchEnd != null ? matchEnd : NumberValueObject.create(0);
    const _ifNotFound = ifNotFound != null ? ifNotFound : ErrorValueObject.create("#N/A" /* NA */);
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _instanceNum.isArray() ? _instanceNum.getRowCount() : 1,
      _matchMode.isArray() ? _matchMode.getRowCount() : 1,
      _matchEnd.isArray() ? _matchEnd.getRowCount() : 1,
      _ifNotFound.isArray() ? _ifNotFound.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _instanceNum.isArray() ? _instanceNum.getColumnCount() : 1,
      _matchMode.isArray() ? _matchMode.getColumnCount() : 1,
      _matchEnd.isArray() ? _matchEnd.getColumnCount() : 1,
      _ifNotFound.isArray() ? _ifNotFound.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const instanceNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, _instanceNum, ErrorValueObject.create("#N/A" /* NA */));
    const matchModeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _matchMode, ErrorValueObject.create("#N/A" /* NA */));
    const matchEndArray = expandArrayValueObject(maxRowLength, maxColumnLength, _matchEnd, ErrorValueObject.create("#N/A" /* NA */));
    const ifNotFoundArray = expandArrayValueObject(maxRowLength, maxColumnLength, _ifNotFound, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = this._getResultArray(textArray, delimiter, instanceNumArray, matchModeArray, matchEndArray, ifNotFoundArray, instanceNumIsNull, onlyThreeVariant);
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _getResultArray(textArray, delimiter, instanceNumArray, matchModeArray, matchEndArray, ifNotFoundArray, instanceNumIsNull, onlyThreeVariant) {
    const resultArray = textArray.map((textObject, rowIndex, columnIndex) => {
      const instanceNumObject = instanceNumArray.get(rowIndex, columnIndex);
      const matchModeObject = matchModeArray.get(rowIndex, columnIndex);
      const matchEndObject = matchEndArray.get(rowIndex, columnIndex);
      const ifNotFoundObject = ifNotFoundArray.get(rowIndex, columnIndex);
      const _variantsError = this._checkVariantsError(textObject, instanceNumObject, matchModeObject, matchEndObject);
      if (_variantsError.isError()) {
        return _variantsError;
      }
      const textValue = this._getStringValue(textObject);
      const delimiterValue = this._getDelimiterValue(delimiter);
      if (delimiterValue instanceof ErrorValueObject) {
        return delimiterValue;
      }
      const _variantsNumberFloorValue = this._getVariantsNumberFloorValue(instanceNumObject, matchModeObject, matchEndObject);
      if (_variantsNumberFloorValue instanceof ErrorValueObject) {
        return _variantsNumberFloorValue;
      }
      const [instanceNumValue, matchModeValue, matchEndValue] = _variantsNumberFloorValue;
      if (instanceNumValue === 0 || matchModeValue < 0 || matchModeValue > 1 || matchEndValue < 0 || matchEndValue > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (delimiterValue.includes("")) {
        if (instanceNumValue > 0) {
          return StringValueObject.create("");
        } else {
          return StringValueObject.create(textValue);
        }
      }
      if (!instanceNumIsNull && Math.abs(instanceNumValue) > textValue.length) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (delimiterValue.every((item) => item.length > textValue.length)) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return this._getResult(textValue, delimiterValue, instanceNumValue, matchModeValue, matchEndValue, ifNotFoundObject, onlyThreeVariant);
    });
    return resultArray;
  }
  _checkVariantsError(...variantas) {
    for (let i = 0; i < variantas.length; i++) {
      const variant = variantas[i];
      if (variant.isError()) {
        return variant;
      }
    }
    return BooleanValueObject.create(true);
  }
  _getStringValue(variant) {
    let value = `${variant.getValue()}`;
    if (variant.isNull()) {
      value = "";
    }
    if (variant.isBoolean()) {
      value = value.toLocaleUpperCase();
    }
    return value;
  }
  _getDelimiterValue(delimiter) {
    const delimiterValue = [];
    if (delimiter.isArray()) {
      let isError = false;
      let errorObject = ErrorValueObject.create("#VALUE!" /* VALUE */);
      delimiter.iterator((delimiterObject) => {
        const _delimiterObject = delimiterObject;
        if (_delimiterObject.isError()) {
          isError = true;
          errorObject = _delimiterObject;
          return false;
        }
        delimiterValue.push(this._getStringValue(_delimiterObject));
      });
      if (isError) {
        return errorObject;
      }
    } else {
      if (delimiter.isError()) {
        return delimiter;
      }
      delimiterValue.push(this._getStringValue(delimiter));
    }
    return delimiterValue;
  }
  _getVariantsNumberFloorValue(...variants) {
    const values = [];
    for (let i = 0; i < variants.length; i++) {
      let variant = variants[i];
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      const value = Math.floor(+variant.getValue());
      values.push(value);
    }
    return values;
  }
  _getResult(textValue, delimiterValue, instanceNumValue, matchModeValue, matchEndValue, ifNotFoundObject, onlyThreeVariant) {
    let substrText = !matchModeValue ? textValue : textValue.toLocaleLowerCase();
    const _delimiterValue = !matchModeValue ? delimiterValue : delimiterValue.map((item) => item.toLocaleLowerCase());
    let resultIndex = 0;
    let matchNum = 0;
    let preDelimiterLength = 0;
    for (let i = 0; i < Math.abs(instanceNumValue); i++) {
      if (instanceNumValue < 0) {
        const delimiterItem = _delimiterValue.map((item) => {
          return {
            index: substrText.lastIndexOf(item),
            length: item.length
          };
        }).filter((item) => item.index !== -1).sort((a2, b) => b.index - a2.index)[0];
        if (!delimiterItem) {
          break;
        }
        resultIndex = delimiterItem.index;
        substrText = substrText.substr(0, delimiterItem.index);
        matchNum++;
      } else {
        const delimiterItem = _delimiterValue.map((item) => {
          return {
            index: substrText.indexOf(item),
            length: item.length
          };
        }).filter((item) => item.index !== -1).sort((a2, b) => a2.index - b.index)[0];
        if (!delimiterItem) {
          break;
        }
        resultIndex += delimiterItem.index + preDelimiterLength;
        substrText = substrText.substr(delimiterItem.index + delimiterItem.length);
        preDelimiterLength = delimiterItem.length;
        matchNum++;
      }
    }
    if (matchNum && matchNum < Math.abs(instanceNumValue) && onlyThreeVariant) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    if (!matchNum || matchNum < Math.abs(instanceNumValue)) {
      if (matchEndValue) {
        if (instanceNumValue > 0) {
          return StringValueObject.create(textValue);
        } else {
          return StringValueObject.create("");
        }
      }
      return ifNotFoundObject;
    }
    const result = textValue.substr(0, resultIndex);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/textjoin/index.ts
var Textjoin = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 3);
    __publicField(this, "maxParams", 255);
  }
  calculate(delimiter, ignoreEmpty, ...variants) {
    const delimiterValues = this._getDelimiterValues(delimiter);
    const textValues = this._getTextValues(variants);
    if (ignoreEmpty.isArray()) {
      const resultArray = ignoreEmpty.mapValue((ignoreEmptyObject) => this._handleSingleObject(delimiterValues, ignoreEmptyObject, textValues));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    const _ignoreEmpty = ignoreEmpty;
    if (_ignoreEmpty.isString()) {
      const ignoreEmptyValue = `${_ignoreEmpty.getValue()}`.toLocaleUpperCase();
      if (ignoreEmptyValue === "TRUE") {
        return this._handleSingleObject(delimiterValues, BooleanValueObject.create(true), textValues);
      }
      if (ignoreEmptyValue === "FALSE") {
        return this._handleSingleObject(delimiterValues, BooleanValueObject.create(false), textValues);
      }
    }
    return this._handleSingleObject(delimiterValues, ignoreEmpty, textValues);
  }
  _handleSingleObject(delimiterValues, ignoreEmpty, textValues) {
    if (delimiterValues instanceof ErrorValueObject) {
      return delimiterValues;
    }
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(ignoreEmpty);
    if (isError) {
      return errorObject;
    }
    if (textValues instanceof ErrorValueObject) {
      return textValues;
    }
    const [ignoreEmptyObject] = variants;
    const ignoreEmptyValue = +ignoreEmptyObject.getValue();
    let _textValues = textValues;
    if (ignoreEmptyValue) {
      _textValues = textValues.filter((value) => value !== null);
    }
    let result = "";
    for (let i = 0; i < _textValues.length; i++) {
      if (_textValues[i] !== null) {
        result += _textValues[i];
      }
      if (i < _textValues.length - 1) {
        result += delimiterValues[i % delimiterValues.length];
      }
    }
    return StringValueObject.create(result);
  }
  _getDelimiterValues(delimiter) {
    const delimiterValues = [];
    const rowCount = delimiter.isArray() ? delimiter.getRowCount() : 1;
    const columnCount = delimiter.isArray() ? delimiter.getColumnCount() : 1;
    for (let r = 0; r < rowCount; r++) {
      for (let c = 0; c < columnCount; c++) {
        const valueObject = delimiter.isArray() ? delimiter.get(r, c) : delimiter;
        if (valueObject.isError()) {
          return valueObject;
        }
        let value = `${valueObject.getValue()}`;
        if (valueObject.isNull()) {
          value = "";
        }
        if (valueObject.isBoolean()) {
          value = value.toLocaleUpperCase();
        }
        delimiterValues.push(value);
      }
    }
    return delimiterValues;
  }
  _getTextValues(variants) {
    const textValues = [];
    for (const variant of variants) {
      const rowCount = variant.isArray() ? variant.getRowCount() : 1;
      const columnCount = variant.isArray() ? variant.getColumnCount() : 1;
      for (let r = 0; r < rowCount; r++) {
        for (let c = 0; c < columnCount; c++) {
          const valueObject = variant.isArray() ? variant.get(r, c) : variant;
          if (valueObject.isError()) {
            return valueObject;
          }
          if (valueObject.isNull()) {
            textValues.push(null);
            continue;
          }
          let value = `${valueObject.getValue()}`;
          if (valueObject.isBoolean()) {
            value = value.toLocaleUpperCase();
          }
          textValues.push(value);
        }
      }
    }
    return textValues;
  }
};

// ../packages/engine-formula/src/functions/text/textsplit/index.ts
var Textsplit = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 2);
    __publicField(this, "maxParams", 6);
  }
  calculate(text, colDelimiter, rowDelimiter, ignoreEmpty, matchMode, padWith) {
    let _rowDelimiter = rowDelimiter != null ? rowDelimiter : StringValueObject.create("\\s");
    const _ignoreEmpty = ignoreEmpty != null ? ignoreEmpty : NumberValueObject.create(0);
    const _matchMode = matchMode != null ? matchMode : NumberValueObject.create(0);
    const _padWith = padWith != null ? padWith : StringValueObject.create("#N/A" /* NA */);
    const { _variant: _colDelimiter, values: colDelimiterValue } = this._getStringValues(colDelimiter);
    const { _variant, values: rowDelimiterValue } = this._getStringValues(_rowDelimiter, false);
    _rowDelimiter = _variant;
    const maxRowLength = Math.max(
      text.isArray() ? text.getRowCount() : 1,
      _ignoreEmpty.isArray() ? _ignoreEmpty.getRowCount() : 1,
      _matchMode.isArray() ? _matchMode.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      text.isArray() ? text.getColumnCount() : 1,
      _ignoreEmpty.isArray() ? _ignoreEmpty.getColumnCount() : 1,
      _matchMode.isArray() ? _matchMode.getColumnCount() : 1
    );
    const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text, ErrorValueObject.create("#N/A" /* NA */));
    const ignoreEmptyArray = expandArrayValueObject(maxRowLength, maxColumnLength, _ignoreEmpty, ErrorValueObject.create("#N/A" /* NA */));
    const matchModeArray = expandArrayValueObject(maxRowLength, maxColumnLength, _matchMode, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = this._getResultArray(
      textArray,
      _colDelimiter,
      _rowDelimiter,
      ignoreEmptyArray,
      matchModeArray,
      _padWith,
      colDelimiterValue,
      rowDelimiterValue
    );
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    } else {
      return resultArray.map((item) => item.get(0, 0));
    }
  }
  _getStringValues(variant, isNotNull = true) {
    let _variant = variant;
    const values = [];
    if (_variant.isArray()) {
      _variant.iterator((variantObject) => {
        if (variantObject == null ? void 0 : variantObject.isError()) {
          _variant = variantObject;
          return false;
        }
        if ((variantObject == null ? void 0 : variantObject.isNull()) && isNotNull) {
          _variant = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        const value = this._getRegExpStringValue(variantObject);
        if (value === "") {
          _variant = ErrorValueObject.create("#VALUE!" /* VALUE */);
          return false;
        }
        values.push(value);
      });
    } else {
      if (_variant.isNull() && isNotNull) {
        _variant = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const value = this._getRegExpStringValue(_variant);
      if (value === "") {
        _variant = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      values.push(value);
    }
    return {
      _variant,
      values
    };
  }
  _getResultArray(textArray, colDelimiter, rowDelimiter, ignoreEmptyArray, matchModeArray, padWith, colDelimiterValue, rowDelimiterValue) {
    const resultArray = textArray.map((textObject, rowIndex, columnIndex) => {
      let ignoreEmptyObject = ignoreEmptyArray.get(rowIndex, columnIndex);
      let matchModeObject = matchModeArray.get(rowIndex, columnIndex);
      const _variantsError = this._checkVariantsError(textObject, colDelimiter, rowDelimiter, ignoreEmptyObject, matchModeObject);
      if (_variantsError.isError()) {
        return _variantsError;
      }
      if (textObject.isNull()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let _padWith = padWith;
      if (_padWith.isArray()) {
        const padWithRowCount = _padWith.getRowCount();
        const padWithColumnCount = _padWith.getColumnCount();
        if (padWithRowCount > 1 || padWithColumnCount > 1) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        _padWith = _padWith.get(0, 0);
      }
      let textValue = `${textObject.getValue()}`;
      if (textObject.isBoolean()) {
        textValue = textValue.toLocaleUpperCase();
      }
      if (ignoreEmptyObject.isString()) {
        ignoreEmptyObject = ignoreEmptyObject.convertToNumberObjectValue();
        if (ignoreEmptyObject.isError()) {
          return ignoreEmptyObject;
        }
      }
      const ignoreEmptyValue = Math.floor(+ignoreEmptyObject.getValue());
      if (matchModeObject.isString()) {
        matchModeObject = matchModeObject.convertToNumberObjectValue();
        if (matchModeObject.isError()) {
          return matchModeObject;
        }
      }
      const matchModeValue = Math.floor(+matchModeObject.getValue());
      if (matchModeValue < 0 || matchModeValue > 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      let padWithValue = `${_padWith.getValue()}`;
      if (_padWith.isBoolean()) {
        padWithValue = padWithValue.toLocaleUpperCase();
      }
      return this._getResult(textValue, colDelimiterValue, rowDelimiterValue, ignoreEmptyValue, matchModeValue, padWithValue);
    });
    return resultArray;
  }
  _getResult(textValue, colDelimiterValue, rowDelimiterValue, ignoreEmptyValue, matchModeValue, padWithValue) {
    const rowDelimiterRegExp = new RegExp(rowDelimiterValue.join("|"), `g${!matchModeValue ? "" : "i"}`);
    const colDelimiterRegExp = new RegExp(colDelimiterValue.join("|"), `g${!matchModeValue ? "" : "i"}`);
    const resultRows = textValue.split(rowDelimiterRegExp);
    let resultColsMaxCount = 1;
    let result = resultRows.map((row) => {
      let cols = row.split(colDelimiterRegExp);
      if (ignoreEmptyValue) {
        cols = cols.filter((col) => col !== "");
      }
      resultColsMaxCount = Math.max(resultColsMaxCount, cols.length);
      return cols;
    });
    result = result.map((row) => {
      let _row = row;
      if (_row.length < resultColsMaxCount) {
        _row = _row.concat(new Array(resultColsMaxCount - _row.length).fill(padWithValue));
      }
      return _row;
    });
    return ArrayValueObject.createByArray(result);
  }
  _checkVariantsError(...variantas) {
    for (let i = 0; i < variantas.length; i++) {
      const variant = variantas[i];
      if (variant.isError()) {
        return variant;
      }
    }
    return BooleanValueObject.create(true);
  }
  _getRegExpStringValue(valueObject) {
    let value = valueObject.getValue();
    if (valueObject.isNull()) {
      value = "\\s";
    }
    if (valueObject.isBoolean()) {
      value = value ? "TRUE" : "FALSE";
    }
    value += "";
    return this._escapeRegExp(value);
  }
  _escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};

// ../packages/engine-formula/src/functions/text/trim/index.ts
var Trim = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isNull()) {
      return StringValueObject.create("");
    }
    let textValue = `${text.getValue()}`;
    if (text.isBoolean()) {
      textValue = textValue.toLocaleUpperCase();
    }
    textValue = textValue.trim().replace(/\s+/g, " ");
    return StringValueObject.create(textValue);
  }
};

// ../packages/engine-formula/src/functions/text/unichar/index.ts
var filterCodeArray2 = Object.values(DataStreamTreeTokenType).filter((value) => {
  return [
    "" /* TABLE_START */,
    "\x1B" /* TABLE_ROW_START */,
    "" /* TABLE_CELL_START */,
    "" /* TABLE_CELL_END */,
    "" /* TABLE_ROW_END */,
    "" /* TABLE_END */,
    "\b" /* CUSTOM_BLOCK */
  ].includes(value);
});
var Unichar = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(number) {
    if (number.isArray()) {
      const resultArray = number.mapValue((numberObject) => this._handleSingleObject(numberObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(number);
  }
  _handleSingleObject(number) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(number);
    if (isError) {
      return errorObject;
    }
    const [numberObject] = variants;
    const numberValue = Math.floor(+numberObject.getValue());
    if (numberValue < 1 || numberValue > 1114111) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (numberValue === 1114111 || numberValue === 1114110) {
      return ErrorValueObject.create("#N/A" /* NA */);
    }
    let result = String.fromCharCode(numberValue);
    if (filterCodeArray2.some((value) => value === result)) {
      result = String.fromCharCode(1);
    }
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/unicode/index.ts
var Unicode = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isNull()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let textValue = text.getValue().toLocaleString();
    if (text.isBoolean()) {
      textValue = textValue.toLocaleUpperCase();
    }
    const result = textValue.charCodeAt(0);
    return NumberValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/upper/index.ts
var Upper = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isNull()) {
      return StringValueObject.create("");
    }
    const result = `${text.getValue()}`.toLocaleUpperCase();
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/value/index.ts
var Value = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    if (text.isBoolean()) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    let _text = text;
    if (text.isString()) {
      _text = _text.convertToNumberObjectValue();
      if (_text.isError()) {
        return _text;
      }
    }
    const textValue = +_text.getValue();
    return NumberValueObject.create(textValue);
  }
};

// ../packages/engine-formula/src/functions/text/valuetotext/index.ts
var Valuetotext = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 2);
  }
  calculate(value, format) {
    const _format = format != null ? format : NumberValueObject.create(0);
    const maxRowLength = Math.max(
      value.isArray() ? value.getRowCount() : 1,
      _format.isArray() ? _format.getRowCount() : 1
    );
    const maxColumnLength = Math.max(
      value.isArray() ? value.getColumnCount() : 1,
      _format.isArray() ? _format.getColumnCount() : 1
    );
    const valueArray = expandArrayValueObject(maxRowLength, maxColumnLength, value, ErrorValueObject.create("#N/A" /* NA */));
    const formatArray = expandArrayValueObject(maxRowLength, maxColumnLength, _format, ErrorValueObject.create("#N/A" /* NA */));
    const resultArray = valueArray.mapValue((valueObject, rowIndex, columnIndex) => {
      const formatObject = formatArray.get(rowIndex, columnIndex);
      if (valueObject.isError()) {
        return valueObject;
      }
      if (formatObject.isError()) {
        return formatObject;
      }
      return this._handleSingleObject(valueObject, formatObject);
    });
    if (maxRowLength === 1 && maxColumnLength === 1) {
      return resultArray.get(0, 0);
    }
    return resultArray;
  }
  _handleSingleObject(value, format) {
    const { isError, errorObject, variants } = checkVariantsErrorIsStringToNumber(format);
    if (isError) {
      return errorObject;
    }
    const [formatObject] = variants;
    const formatValue = Math.floor(+formatObject.getValue());
    if (formatValue < 0 || formatValue > 1) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    if (value.isNull()) {
      return StringValueObject.create("");
    }
    if (value.isBoolean()) {
      return value;
    }
    if (value.isNumber()) {
      return NumberValueObject.create(value.getValue());
    }
    const result = formatValue ? `"${value.getValue()}"` : `${value.getValue()}`;
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/text/function-map.ts
var functionText = [
  [Asc, "ASC" /* ASC */],
  [Arraytotext, "ARRAYTOTEXT" /* ARRAYTOTEXT */],
  [Bahttext, "BAHTTEXT" /* BAHTTEXT */],
  [Char, "CHAR" /* CHAR */],
  [Clean, "CLEAN" /* CLEAN */],
  [Code, "CODE" /* CODE */],
  [Concat, "CONCAT" /* CONCAT */],
  [Concatenate, "CONCATENATE" /* CONCATENATE */],
  [Dbcs, "DBCS" /* DBCS */],
  [Dollar, "DOLLAR" /* DOLLAR */],
  [Exact, "EXACT" /* EXACT */],
  [Find, "FIND" /* FIND */],
  [Findb, "FINDB" /* FINDB */],
  [Fixed, "FIXED" /* FIXED */],
  [Left, "LEFT" /* LEFT */],
  [Leftb, "LEFTB" /* LEFTB */],
  [Len, "LEN" /* LEN */],
  [Lenb, "LENB" /* LENB */],
  [Lower, "LOWER" /* LOWER */],
  [Mid, "MID" /* MID */],
  [Midb, "MIDB" /* MIDB */],
  [Numberstring, "NUMBERSTRING" /* NUMBERSTRING */],
  [Numbervalue, "NUMBERVALUE" /* NUMBERVALUE */],
  [Regexextract, "REGEXEXTRACT" /* REGEXEXTRACT */],
  [Regexmatch, "REGEXMATCH" /* REGEXMATCH */],
  [Regexreplace, "REGEXREPLACE" /* REGEXREPLACE */],
  [Proper, "PROPER" /* PROPER */],
  [Replace, "REPLACE" /* REPLACE */],
  [Replaceb, "REPLACEB" /* REPLACEB */],
  [Rept, "REPT" /* REPT */],
  [Right, "RIGHT" /* RIGHT */],
  [Rightb, "RIGHTB" /* RIGHTB */],
  [Search, "SEARCH" /* SEARCH */],
  [Searchb, "SEARCHB" /* SEARCHB */],
  [Substitute, "SUBSTITUTE" /* SUBSTITUTE */],
  [T, "T" /* T */],
  [Text, "TEXT" /* TEXT */],
  [Textafter, "TEXTAFTER" /* TEXTAFTER */],
  [Textbefore, "TEXTBEFORE" /* TEXTBEFORE */],
  [Textjoin, "TEXTJOIN" /* TEXTJOIN */],
  [Textsplit, "TEXTSPLIT" /* TEXTSPLIT */],
  [Trim, "TRIM" /* TRIM */],
  [Unichar, "UNICHAR" /* UNICHAR */],
  [Unicode, "UNICODE" /* UNICODE */],
  [Upper, "UPPER" /* UPPER */],
  [Value, "VALUE" /* VALUE */],
  [Valuetotext, "VALUETOTEXT" /* VALUETOTEXT */]
];

// ../packages/engine-formula/src/functions/univer/function-map.ts
var functionUniver = [];

// ../packages/engine-formula/src/functions/web/encodeurl/index.ts
var Encodeurl = class extends BaseFunction {
  constructor() {
    super(...arguments);
    __publicField(this, "minParams", 1);
    __publicField(this, "maxParams", 1);
  }
  calculate(text) {
    if (text.isArray()) {
      const resultArray = text.mapValue((textObject) => this._handleSingleObject(textObject));
      if (resultArray.getRowCount() === 1 && resultArray.getColumnCount() === 1) {
        return resultArray.get(0, 0);
      }
      return resultArray;
    }
    return this._handleSingleObject(text);
  }
  _handleSingleObject(text) {
    if (text.isError()) {
      return text;
    }
    const textValue = getTextValueOfNumberFormat(text);
    const result = encodeURIComponent(textValue).replace(/[!~'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toLocaleUpperCase()}`);
    return StringValueObject.create(result);
  }
};

// ../packages/engine-formula/src/functions/web/function-map.ts
var functionWeb = [
  [Encodeurl, "ENCODEURL" /* ENCODEURL */]
];

// ../packages/engine-formula/src/controller/computing-status.controller.ts
var import_rxjs25 = __toESM(require_cjs());

// ../packages/engine-formula/src/services/global-computing-status.service.ts
var import_rxjs24 = __toESM(require_cjs());
var GlobalComputingStatusService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_allSubjects", []);
    __publicField(this, "_computingStatus$", new import_rxjs24.BehaviorSubject(true));
    __publicField(this, "computingStatus$", this._computingStatus$.pipe((0, import_rxjs24.distinctUntilChanged)()));
    __publicField(this, "_computingSubscription");
  }
  get computingStatus() {
    return this._computingStatus$.getValue();
  }
  dispose() {
    var _a2;
    super.dispose();
    (_a2 = this._computingSubscription) == null ? void 0 : _a2.unsubscribe();
    this._computingStatus$.next(true);
    this._computingStatus$.complete();
    this._allSubjects.forEach((subject) => {
      subject.complete();
    });
  }
  pushComputingStatusSubject(subject) {
    this._allSubjects.push(subject);
    this._updateComputingObservable();
    return {
      dispose: () => {
        const index = this._allSubjects.indexOf(subject);
        if (index !== -1) {
          this._allSubjects.splice(index, 1);
        }
        this._updateComputingObservable();
      }
    };
  }
  _updateComputingObservable() {
    var _a2;
    (_a2 = this._computingSubscription) == null ? void 0 : _a2.unsubscribe();
    if (this._allSubjects.length === 0) {
      this._computingStatus$.next(true);
      return;
    }
    this._computingSubscription = (0, import_rxjs24.combineLatest)(this._allSubjects).pipe((0, import_rxjs24.map)((values) => values.every((v) => v))).subscribe((computing) => this._computingStatus$.next(computing));
  }
};

// ../packages/engine-formula/src/controller/computing-status.controller.ts
var ComputingStatusReporterController = class extends Disposable {
  constructor(_commandService, _globalComputingSrv) {
    super();
    this._commandService = _commandService;
    this._globalComputingSrv = _globalComputingSrv;
    __publicField(this, "_computingCompleted$", new import_rxjs25.Observable((observe) => {
      this._commandService.onCommandExecuted((command) => {
        if (command.id !== SetFormulaCalculationNotificationMutation.id) return;
        const params = command.params;
        if (params.stageInfo) {
          return observe.next(
            params.stageInfo.stage === 0 /* IDLE */ || params.stageInfo.stage === 8 /* CALCULATION_COMPLETED */
          );
        }
      });
    }).pipe(
      (0, import_rxjs25.distinctUntilChanged)(),
      (0, import_rxjs25.shareReplay)()
    ));
    const disposables = new DisposableCollection();
    const subject = new import_rxjs25.BehaviorSubject(true);
    disposables.add(this._globalComputingSrv.pushComputingStatusSubject(subject));
    disposables.add(this._computingCompleted$.subscribe((completed) => subject.next(completed)));
    disposables.add(() => subject.complete());
    this.disposeWithMe(disposables);
  }
};
ComputingStatusReporterController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, Inject(GlobalComputingStatusService))
], ComputingStatusReporterController);

// ../packages/rpc/src/controllers/config.schema.ts
var PLUGIN_CONFIG_KEY_MAIN_THREAD = "rpc.main-thread.config";
var configSymbolMainThread = Symbol(PLUGIN_CONFIG_KEY_MAIN_THREAD);
var defaultPluginMainThreadConfig = {};
var PLUGIN_CONFIG_KEY_WORKER_THREAD = "rpc.worker-thread.config";
var configSymbolWorkerThread = Symbol(PLUGIN_CONFIG_KEY_WORKER_THREAD);
var defaultPluginWorkerThreadConfig = {};

// ../packages/rpc/src/controllers/data-sync/data-sync-primary.controller.ts
var import_operators3 = __toESM(require_operators());

// ../packages/rpc/src/services/remote-instance/remote-instance.service.ts
var RemoteSyncServiceName = "rpc.remote-sync.service";
var IRemoteSyncService = createIdentifier(RemoteSyncServiceName);
var RemoteSyncPrimaryService = class {
  constructor(_commandService) {
    this._commandService = _commandService;
  }
  async syncMutation(params) {
    return this._commandService.syncExecuteCommand(params.mutationInfo.id, params.mutationInfo.params, {
      onlyLocal: true,
      fromSync: true
    });
  }
};
RemoteSyncPrimaryService = __decorateClass([
  __decorateParam(0, ICommandService)
], RemoteSyncPrimaryService);
var RemoteInstanceServiceName = "univer.remote-instance-service";
var IRemoteInstanceService = createIdentifier(RemoteInstanceServiceName);
var WebWorkerRemoteInstanceService = class {
  constructor(_univerInstanceService, _commandService, _logService) {
    this._univerInstanceService = _univerInstanceService;
    this._commandService = _commandService;
    this._logService = _logService;
  }
  whenReady() {
    return Promise.resolve(true);
  }
  async syncMutation(params) {
    return this._applyMutation(params.mutationInfo);
  }
  async createInstance(params) {
    const { type: type2, snapshot } = params;
    try {
      switch (type2) {
        case O.UNIVER_SHEET:
          this._univerInstanceService.createUnit(O.UNIVER_SHEET, snapshot);
          return true;
        default:
          throw new Error(
            `[WebWorkerRemoteInstanceService]: cannot create replica for document type: ${type2}.`
          );
      }
    } catch (err) {
      if (err instanceof Error) {
        throw err;
      } else {
        throw new TypeError(`${err}`);
      }
    }
  }
  async disposeInstance(params) {
    return this._univerInstanceService.disposeUnit(params.unitID);
  }
  _applyMutation(mutationInfo) {
    const { id, params: mutationParams } = mutationInfo;
    return this._commandService.syncExecuteCommand(id, mutationParams, {
      onlyLocal: true,
      fromSync: true
    });
  }
};
WebWorkerRemoteInstanceService = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, ICommandService),
  __decorateParam(2, ILogService)
], WebWorkerRemoteInstanceService);

// ../packages/rpc/src/services/rpc/rpc.service.ts
var import_rxjs26 = __toESM(require_cjs());
var import_operators2 = __toESM(require_operators());
function fromModule(module2) {
  const handler = module2;
  return new class {
    call(method, args) {
      const target = handler[method];
      if (typeof target === "function") {
        let res = args ? target.apply(handler, args) : target.call(handler);
        if (!(res instanceof Promise)) {
          res = Promise.resolve(res);
        }
        return res;
      }
      throw new Error(`[RPC]: method not found for ${method}!`);
    }
    subscribe(eventMethod, args) {
      const target = handler[eventMethod];
      if (typeof target === "function") {
        const res = args ? target.apply(handler, args) : target.call(handler);
        if (!(0, import_rxjs26.isObservable)(res)) {
          return (0, import_rxjs26.of)(res);
        }
        return res;
      }
      throw new Error(`[RPC]: observable method not found for ${eventMethod}!`);
    }
  }();
}
function toModule(channel) {
  return new Proxy({}, {
    get(_, propKey) {
      if (propKey === "dispose") {
        return void 0;
      }
      return function(...args) {
        const isObservable2 = propertyIsEventSource(propKey);
        if (isObservable2) {
          const observable = channel.subscribe(propKey, args);
          return observable;
        }
        return channel.call(propKey, args);
      };
    }
  });
}
function propertyIsEventSource(name) {
  return name.endsWith("$");
}
var ChannelClient = class extends RxDisposable {
  constructor(_protocol) {
    super();
    this._protocol = _protocol;
    __publicField(this, "_initialized", new import_rxjs26.BehaviorSubject(false));
    __publicField(this, "_lastRequestCounter", 0);
    __publicField(this, "_pendingRequests", /* @__PURE__ */ new Map());
    this._protocol.send({ type: 50 /* REQUEST_INITIALIZATION */ });
    this._protocol.onMessage.pipe((0, import_operators2.takeUntil)(this.dispose$)).subscribe((message) => this._onMessage(message));
  }
  dispose() {
    this._pendingRequests.clear();
  }
  getChannel(channelName) {
    const self2 = this;
    return {
      call(method, args) {
        if (self2._disposed) {
          return Promise.reject();
        }
        return self2._remoteCall(channelName, method, args);
      },
      subscribe(eventMethod, args) {
        if (self2._disposed) {
          throw new Error("[ChannelClient]: client is disposed!");
        }
        return self2._remoteSubscribe(channelName, eventMethod, args);
      }
    };
  }
  _whenReady() {
    return (0, import_rxjs26.firstValueFrom)(
      this._initialized.pipe(
        (0, import_operators2.filter)((v) => v),
        (0, import_operators2.take)(1)
      )
    );
  }
  async _remoteCall(channelName, method, args) {
    await this._whenReady();
    const sequence2 = ++this._lastRequestCounter;
    const type2 = 100 /* CALL */;
    const request = { seq: sequence2, type: type2, channelName, method, args };
    const client = this;
    return new Promise((resolve, reject) => {
      const responseHandler = {
        handle(response) {
          switch (response.type) {
            case 201 /* CALL_SUCCESS */:
              client._pendingRequests.delete(sequence2);
              resolve(response.data);
              break;
            case 202 /* CALL_FAILURE */:
              client._pendingRequests.delete(sequence2);
              reject(response.data);
              break;
            default:
              throw new Error("[ChannelClient]: unknown response type!");
          }
        }
      };
      this._pendingRequests.set(sequence2, responseHandler);
      this._sendRequest(request);
    });
  }
  _remoteSubscribe(channelName, method, args) {
    return new import_rxjs26.Observable((subscriber) => {
      let sequence2 = -1;
      this._whenReady().then(() => {
        sequence2 = ++this._lastRequestCounter;
        const type2 = 101 /* SUBSCRIBE */;
        const request = { seq: sequence2, type: type2, channelName, method, args };
        const responseHandler = {
          handle(response) {
            switch (response.type) {
              case 300 /* SUBSCRIBE_NEXT */:
                subscriber.next(response.data);
                break;
              case 301 /* SUBSCRIBE_ERROR */:
                subscriber.error(response.data);
                break;
              case 302 /* SUBSCRIBE_COMPLETE */:
                subscriber.complete();
                break;
              default:
                throw new Error("[ChannelClient]: unknown response type!");
            }
          }
        };
        this._pendingRequests.set(sequence2, responseHandler);
        this._sendRequest(request);
      });
      return () => {
        if (sequence2 === -1) {
          return;
        }
        const cancelSubscriptionRequest = {
          type: 102 /* UNSUBSCRIBE */,
          seq: sequence2,
          channelName,
          method
        };
        this._sendRequest(cancelSubscriptionRequest);
      };
    });
  }
  _sendRequest(request) {
    this._protocol.send(request);
  }
  _onMessage(response) {
    var _a2;
    switch (response.type) {
      case 0 /* INITIALIZE */:
        this._initialized.next(true);
        break;
      case 201 /* CALL_SUCCESS */:
      case 202 /* CALL_FAILURE */:
      case 300 /* SUBSCRIBE_NEXT */:
      case 302 /* SUBSCRIBE_COMPLETE */:
      case 301 /* SUBSCRIBE_ERROR */:
        (_a2 = this._pendingRequests.get(response.seq)) == null ? void 0 : _a2.handle(response);
        break;
    }
  }
};
var ChannelServer = class extends RxDisposable {
  constructor(_protocol) {
    super();
    this._protocol = _protocol;
    __publicField(this, "_channels", /* @__PURE__ */ new Map());
    __publicField(this, "_subscriptions", /* @__PURE__ */ new Map());
    this._protocol.onMessage.pipe((0, import_operators2.takeUntil)(this.dispose$)).subscribe((message) => this._onRequest(message));
    this._sendInitialize();
  }
  dispose() {
    super.dispose();
    this._subscriptions.clear();
    this._channels.clear();
  }
  registerChannel(channelName, channel) {
    this._channels.set(channelName, channel);
  }
  _onRequest(request) {
    switch (request.type) {
      case 50 /* REQUEST_INITIALIZATION */:
        this._sendInitialize();
        break;
      case 100 /* CALL */:
        this._onMethodCall(request);
        break;
      case 101 /* SUBSCRIBE */:
        this._onSubscribe(request);
        break;
      case 102 /* UNSUBSCRIBE */:
        this._onUnsubscribe(request);
        break;
      default:
        break;
    }
  }
  _sendInitialize() {
    this._sendResponse({ seq: -1, type: 0 /* INITIALIZE */ });
  }
  _onMethodCall(request) {
    const { channelName, method, args } = request;
    const channel = this._channels.get(channelName);
    let promise;
    try {
      if (!channel) {
        throw new Error(`[ChannelServer]: Channel ${channelName} not found!`);
      }
      promise = args ? channel.call(method, args) : channel.call(method);
    } catch (err) {
      promise = Promise.reject(err);
    }
    promise.then((data) => {
      this._sendResponse({ seq: request.seq, type: 201 /* CALL_SUCCESS */, data });
    }).catch((err) => {
      if (err instanceof Error) {
        this._sendResponse({ seq: request.seq, type: 202 /* CALL_FAILURE */, data: err.message });
      } else {
        this._sendResponse({ seq: request.seq, type: 202 /* CALL_FAILURE */, data: String(err) });
      }
    });
  }
  _onSubscribe(request) {
    const { channelName, seq } = request;
    const channel = this._channels.get(channelName);
    try {
      if (!channel) {
        throw new Error(`[ChannelServer]: Channel ${channelName} not found!`);
      }
      const observable = channel.subscribe(request.method, request.args);
      const subscription = observable.subscribe({
        next: (data) => {
          this._sendResponse({ seq, type: 300 /* SUBSCRIBE_NEXT */, data });
        },
        error: (err) => {
          this._sendResponse({ seq, type: 301 /* SUBSCRIBE_ERROR */, data: err.message });
          this._sendResponse({ seq, type: 302 /* SUBSCRIBE_COMPLETE */ });
        },
        complete: () => {
          this._sendResponse({ seq, type: 302 /* SUBSCRIBE_COMPLETE */ });
        }
      });
      this._subscriptions.set(request.seq, subscription);
    } catch (err) {
      if (err instanceof Error) {
        this._sendResponse({ seq: request.seq, type: 301 /* SUBSCRIBE_ERROR */, data: err.message });
      } else {
        this._sendResponse({ seq: request.seq, type: 301 /* SUBSCRIBE_ERROR */, data: String(err) });
      }
    }
  }
  _onUnsubscribe(request) {
    const subscription = this._subscriptions.get(request.seq);
    if (subscription) {
      subscription.unsubscribe();
      this._subscriptions.delete(request.seq);
    }
  }
  _sendResponse(response) {
    this._protocol.send(response);
  }
};

// ../packages/rpc/src/services/rpc/channel.service.ts
var IRPCChannelService = createIdentifier("IRPCChannelService");
var ChannelService = class {
  constructor(_messageProtocol) {
    __publicField(this, "_client");
    __publicField(this, "_server");
    this._client = new ChannelClient(_messageProtocol);
    this._server = new ChannelServer(_messageProtocol);
  }
  dispose() {
    this._client.dispose();
    this._server.dispose();
  }
  requestChannel(name) {
    return this._client.getChannel(name);
  }
  registerChannel(name, channel) {
    this._server.registerChannel(name, channel);
  }
};

// ../packages/rpc/src/controllers/data-sync/data-sync-primary.controller.ts
var DataSyncPrimaryController = class extends RxDisposable {
  constructor(_injector, _commandService, _univerInstanceService, _rpcChannelService, _remoteSyncService) {
    super();
    this._injector = _injector;
    this._commandService = _commandService;
    this._univerInstanceService = _univerInstanceService;
    this._rpcChannelService = _rpcChannelService;
    this._remoteSyncService = _remoteSyncService;
    __publicField(this, "_remoteInstanceService");
    __publicField(this, "_syncingUnits", /* @__PURE__ */ new Set());
    __publicField(this, "_syncingMutations", /* @__PURE__ */ new Set());
    this._initRPCChannels();
    this._init();
  }
  registerSyncingMutations(mutation) {
    this._syncingMutations.add(mutation.id);
  }
  /**
   * Only spreadsheets would be synced to the web worker in normal situations. If you would like to
   * sync other types of documents, you should manually call this method with that document's id.
   */
  syncUnit(unitId) {
    this._syncingUnits.add(unitId);
    return toDisposable(() => this._syncingUnits.delete(unitId));
  }
  _initRPCChannels() {
    this._rpcChannelService.registerChannel(RemoteSyncServiceName, fromModule(this._remoteSyncService));
    this._injector.add([
      IRemoteInstanceService,
      { useFactory: () => toModule(this._rpcChannelService.requestChannel(RemoteInstanceServiceName)) }
    ]);
    this._remoteInstanceService = this._injector.get(IRemoteInstanceService);
  }
  _init() {
    this._univerInstanceService.getTypeOfUnitAdded$(O.UNIVER_SHEET).pipe((0, import_operators3.takeUntil)(this.dispose$)).subscribe((sheet) => {
      this._syncingUnits.add(sheet.getUnitId());
      this._remoteInstanceService.createInstance({
        unitID: sheet.getUnitId(),
        type: O.UNIVER_SHEET,
        snapshot: sheet.getSnapshot()
      });
    });
    this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET).pipe((0, import_operators3.takeUntil)(this.dispose$)).subscribe((workbook) => {
      this._syncingUnits.delete(workbook.getUnitId());
      this._remoteInstanceService.disposeInstance({
        unitID: workbook.getUnitId()
      });
    });
    this.disposeWithMe(this._commandService.onCommandExecuted((commandInfo, options) => {
      const { type: type2, params, id } = commandInfo;
      const unitId = (params == null ? void 0 : params.unitId) || "";
      if (type2 === 2 /* MUTATION */ && // only sync mutations to the worker thread
      (!unitId || this._syncingUnits.has(unitId)) && // do not sync mutations from the web worker back to the web worker
      !(options == null ? void 0 : options.fromSync) && // do not sync mutations those are not meant to be synced
      this._syncingMutations.has(id)) {
        this._remoteInstanceService.syncMutation({ mutationInfo: commandInfo });
      }
    }));
  }
};
DataSyncPrimaryController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, ICommandService),
  __decorateParam(2, IUniverInstanceService),
  __decorateParam(3, IRPCChannelService),
  __decorateParam(4, IRemoteSyncService)
], DataSyncPrimaryController);

// ../packages/rpc/src/controllers/data-sync/data-sync-replica.controller.ts
var DataSyncReplicaController = class extends Disposable {
  constructor(_injector, _remoteInstanceService, _commandService, _rpcChannelService) {
    super();
    this._injector = _injector;
    this._remoteInstanceService = _remoteInstanceService;
    this._commandService = _commandService;
    this._rpcChannelService = _rpcChannelService;
    __publicField(this, "_remoteSyncService");
    this._initRPCChannels();
    this._init();
  }
  _initRPCChannels() {
    this._rpcChannelService.registerChannel(RemoteInstanceServiceName, fromModule(this._remoteInstanceService));
    this._injector.add([
      IRemoteSyncService,
      { useFactory: () => toModule(this._rpcChannelService.requestChannel(RemoteSyncServiceName)) }
    ]);
    this._remoteSyncService = this._injector.get(IRemoteSyncService);
  }
  _init() {
    this.disposeWithMe(
      // Mutations executed on the main thread should be synced to the worker thread.
      this._commandService.onCommandExecuted((commandInfo, options) => {
        if (commandInfo.type === 2 /* MUTATION */ && !(options == null ? void 0 : options.fromSync)) {
          this._remoteSyncService.syncMutation({
            mutationInfo: commandInfo
          });
        }
      })
    );
  }
};
DataSyncReplicaController = __decorateClass([
  __decorateParam(0, Inject(Injector)),
  __decorateParam(1, IRemoteInstanceService),
  __decorateParam(2, ICommandService),
  __decorateParam(3, IRPCChannelService)
], DataSyncReplicaController);

// ../packages/rpc/src/services/rpc/implementations/web-worker-rpc.service.ts
var import_rxjs27 = __toESM(require_cjs());
function createWebWorkerMessagePortOnWorker() {
  return {
    send(message) {
      postMessage(message);
    },
    onMessage: new import_rxjs27.Observable((subscriber) => {
      const handler = (event) => {
        subscriber.next(event.data);
      };
      addEventListener("message", handler);
      return () => removeEventListener("message", handler);
    }).pipe((0, import_rxjs27.shareReplay)(1))
  };
}
function createWebWorkerMessagePortOnMain(worker) {
  return {
    send(message) {
      worker.postMessage(message);
    },
    onMessage: new import_rxjs27.Observable((subscriber) => {
      const handler = (event) => {
        subscriber.next(event.data);
      };
      worker.addEventListener("message", handler);
      return () => worker.removeEventListener("message", handler);
    }).pipe((0, import_rxjs27.shareReplay)(1))
  };
}

// ../packages/rpc/src/plugin.ts
var UniverRPCMainThreadPlugin = class extends Plugin {
  constructor(_config = defaultPluginMainThreadConfig, _injector, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    __publicField(this, "_internalWorker", null);
    const { ...rest } = merge_default(
      {},
      defaultPluginMainThreadConfig,
      this._config
    );
    this._configService.setConfig(PLUGIN_CONFIG_KEY_MAIN_THREAD, rest);
  }
  dispose() {
    super.dispose();
    if (this._internalWorker) {
      this._internalWorker.terminate();
      this._internalWorker = null;
    }
  }
  onStarting() {
    const { workerURL } = this._config;
    if (!workerURL) {
      throw new Error("[UniverRPCMainThreadPlugin]: The workerURL is required for the RPC main thread plugin.");
    }
    const worker = workerURL instanceof Worker ? workerURL : new Worker(workerURL);
    this._internalWorker = workerURL instanceof Worker ? null : worker;
    const messageProtocol = createWebWorkerMessagePortOnMain(worker);
    const dependencies = [
      [
        IRPCChannelService,
        {
          useFactory: () => new ChannelService(messageProtocol)
        }
      ],
      [DataSyncPrimaryController],
      [IRemoteSyncService, { useClass: RemoteSyncPrimaryService }]
    ];
    dependencies.forEach((dependency) => this._injector.add(dependency));
    this._injector.get(DataSyncPrimaryController);
  }
};
__publicField(UniverRPCMainThreadPlugin, "pluginName", "UNIVER_RPC_MAIN_THREAD_PLUGIN");
UniverRPCMainThreadPlugin = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], UniverRPCMainThreadPlugin);
var UniverRPCWorkerThreadPlugin = class extends Plugin {
  constructor(_config = defaultPluginWorkerThreadConfig, _injector, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    const { ...rest } = merge_default(
      {},
      defaultPluginWorkerThreadConfig,
      this._config
    );
    this._configService.setConfig(PLUGIN_CONFIG_KEY_WORKER_THREAD, rest);
  }
  onStarting() {
    [
      [DataSyncReplicaController],
      [
        IRPCChannelService,
        {
          useFactory: () => new ChannelService(createWebWorkerMessagePortOnWorker())
        }
      ],
      [IRemoteInstanceService, { useClass: WebWorkerRemoteInstanceService }]
    ].forEach((dependency) => this._injector.add(dependency));
    this._injector.get(DataSyncReplicaController);
  }
};
__publicField(UniverRPCWorkerThreadPlugin, "pluginName", "UNIVER_RPC_WORKER_THREAD_PLUGIN");
UniverRPCWorkerThreadPlugin = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], UniverRPCWorkerThreadPlugin);

// ../packages/engine-formula/src/controller/formula.controller.ts
var FormulaController = class extends Disposable {
  constructor(_commandService, _functionService, _configService, _dataSyncPrimaryController) {
    super();
    this._commandService = _commandService;
    this._functionService = _functionService;
    this._configService = _configService;
    this._dataSyncPrimaryController = _dataSyncPrimaryController;
    this._initialize();
  }
  _initialize() {
    this._registerCommands();
    this._registerFunctions();
  }
  _registerCommands() {
    [
      SetFormulaDataMutation,
      SetArrayFormulaDataMutation,
      SetFormulaCalculationStartMutation,
      SetFormulaCalculationStopMutation,
      SetFormulaCalculationNotificationMutation,
      SetFormulaCalculationResultMutation,
      SetDefinedNameMutation,
      RemoveDefinedNameMutation,
      SetFeatureCalculationMutation,
      RemoveFeatureCalculationMutation,
      SetOtherFormulaMutation,
      RemoveOtherFormulaMutation,
      SetSuperTableMutation,
      RemoveSuperTableMutation,
      SetSuperTableOptionMutation,
      RegisterFunctionMutation
    ].forEach((mutation) => {
      var _a2;
      this._commandService.registerCommand(mutation);
      (_a2 = this._dataSyncPrimaryController) == null ? void 0 : _a2.registerSyncingMutations(mutation);
    });
  }
  _registerFunctions() {
    var _a2;
    const config2 = this._configService.getConfig(ENGINE_FORMULA_PLUGIN_CONFIG_KEY);
    const functions = [
      ...functionArray,
      ...functionCompatibility,
      ...functionCube,
      ...functionDatabase,
      ...functionDate,
      ...functionEngineering,
      ...functionFinancial,
      ...functionInformation,
      ...functionLogical,
      ...functionLookup,
      ...functionMath,
      ...functionMeta,
      ...functionStatistical,
      ...functionText,
      ...functionUniver,
      ...functionWeb
    ].concat((_a2 = config2 == null ? void 0 : config2.function) != null ? _a2 : []).map((registerObject) => {
      const Func = registerObject[0];
      const name = registerObject[1];
      return new Func(name);
    });
    this._functionService.registerExecutors(...functions);
  }
};
FormulaController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IFunctionService),
  __decorateParam(2, IConfigService),
  __decorateParam(3, Optional(DataSyncPrimaryController))
], FormulaController);

// ../packages/engine-formula/src/controller/set-dependency.controller.ts
var SetDependencyController = class extends Disposable {
  constructor(_commandService, _dependencyManagerService, _featureCalculationManagerService) {
    super();
    this._commandService = _commandService;
    this._dependencyManagerService = _dependencyManagerService;
    this._featureCalculationManagerService = _featureCalculationManagerService;
    this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
    this._featureCalculationManagerServiceListener();
  }
  _featureCalculationManagerServiceListener() {
    this.disposeWithMe(
      this._featureCalculationManagerService.onChanged$.subscribe((params) => {
        const { unitId, subUnitId, featureIds } = params;
        this._dependencyManagerService.removeFeatureFormulaDependency(unitId, subUnitId, featureIds);
      })
    );
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === RemoveFeatureCalculationMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { featureIds, unitId, subUnitId } = params;
          this._dependencyManagerService.removeFeatureFormulaDependency(unitId, subUnitId, featureIds);
        } else if (command.id === SetFeatureCalculationMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { featureId, calculationParam } = params;
          const { unitId, subUnitId } = calculationParam;
          this._dependencyManagerService.removeFeatureFormulaDependency(unitId, subUnitId, [featureId]);
        } else if (command.id === RemoveOtherFormulaMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          this._dependencyManagerService.removeOtherFormulaDependency(params.unitId, params.subUnitId, params.formulaIdList);
        } else if (command.id === SetOtherFormulaMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const formulaMap = params.formulaMap;
          const formulaIdList = [];
          Object.keys(formulaMap).forEach((formulaId) => {
            formulaIdList.push(formulaId);
          });
          this._dependencyManagerService.removeOtherFormulaDependency(params.unitId, params.subUnitId, formulaIdList);
        } else if (command.id === SetFormulaDataMutation.id) {
          const formulaData = command.params.formulaData;
          Object.keys(formulaData).forEach((unitId) => {
            const unitFormulaData = formulaData[unitId];
            if (unitFormulaData === void 0) {
              return;
            }
            if (unitFormulaData === null) {
              this._dependencyManagerService.clearFormulaDependency(unitId);
              return;
            }
            Object.keys(unitFormulaData).forEach((subUnitId) => {
              const formulaDataItem = unitFormulaData[subUnitId];
              if (formulaDataItem === void 0) {
                return;
              }
              if (formulaDataItem === null) {
                this._dependencyManagerService.clearFormulaDependency(unitId, subUnitId);
                return true;
              }
              new ObjectMatrix(formulaDataItem).forValue((row, column) => {
                this._dependencyManagerService.removeFormulaDependency(unitId, subUnitId, row, column);
              });
            });
          });
        } else if (command.id === SetDefinedNameMutation.id) {
          this._handleSetDefinedName(command);
        }
      })
    );
  }
  _handleSetDefinedName(command) {
    const params = command.params;
    if (params == null) {
      return;
    }
    const { unitId, name } = params;
    this._dependencyManagerService.removeFormulaDependencyByDefinedName(unitId, name);
  }
};
SetDependencyController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IFeatureCalculationManagerService),
  __decorateParam(1, IDependencyManagerService),
  __decorateParam(2, IFeatureCalculationManagerService)
], SetDependencyController);

// ../packages/engine-formula/src/controller/set-feature-calculation.controller.ts
var SetFeatureCalculationController = class extends Disposable {
  constructor(_commandService, _featureCalculationManagerService) {
    super();
    this._commandService = _commandService;
    this._featureCalculationManagerService = _featureCalculationManagerService;
    this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === SetFeatureCalculationMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { featureId, calculationParam } = params;
          const { unitId, subUnitId } = calculationParam;
          this._featureCalculationManagerService.register(unitId, subUnitId, featureId, calculationParam);
        } else if (command.id === RemoveFeatureCalculationMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { featureIds, unitId, subUnitId } = params;
          this._featureCalculationManagerService.remove(unitId, subUnitId, featureIds);
        }
      })
    );
  }
};
SetFeatureCalculationController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IFeatureCalculationManagerService)
], SetFeatureCalculationController);

// ../packages/engine-formula/src/controller/set-other-formula.controller.ts
var SetOtherFormulaController = class extends Disposable {
  constructor(_commandService, _otherFormulaManagerService, _dependencyManagerService) {
    super();
    this._commandService = _commandService;
    this._otherFormulaManagerService = _otherFormulaManagerService;
    this._dependencyManagerService = _dependencyManagerService;
    this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === SetOtherFormulaMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const config2 = { [params.unitId]: { [params.subUnitId]: params.formulaMap } };
          this._otherFormulaManagerService.batchRegister(config2);
        } else if (command.id === RemoveOtherFormulaMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const obj = {};
          params.formulaIdList.forEach((id) => obj[id] = true);
          const config2 = { [params.unitId]: { [params.subUnitId]: obj } };
          this._otherFormulaManagerService.batchRemove(config2);
        }
      })
    );
  }
};
SetOtherFormulaController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IOtherFormulaManagerService),
  __decorateParam(2, IDependencyManagerService)
], SetOtherFormulaController);

// ../packages/engine-formula/src/services/super-table.service.ts
var SuperTableService = class extends Disposable {
  constructor() {
    super(...arguments);
    // 18.5.1.2 table (Table)
    __publicField(this, "_tableMap", /* @__PURE__ */ new Map());
    // 18.5.1.2 table (Table) for I18N
    __publicField(this, "_tableOptionMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    super.dispose();
    this._tableMap.clear();
    this._tableOptionMap.clear();
  }
  remove(unitId, tableName) {
    var _a2;
    (_a2 = this._tableMap.get(unitId)) == null ? void 0 : _a2.delete(tableName);
  }
  getTableMap(unitId) {
    return this._tableMap.get(unitId);
  }
  getTableOptionMap() {
    return this._tableOptionMap;
  }
  registerTable(unitId, tableName, reference) {
    var _a2;
    if (this._tableMap.get(unitId) == null) {
      this._tableMap.set(unitId, /* @__PURE__ */ new Map());
    }
    (_a2 = this._tableMap.get(unitId)) == null ? void 0 : _a2.set(tableName, reference);
  }
  registerTableOptionMap(tableOption, tableOptionType) {
    this._tableOptionMap.set(tableOption, tableOptionType);
  }
};
var ISuperTableService = createIdentifier("univer.formula.super-table.service");

// ../packages/engine-formula/src/controller/set-super-table.controller.ts
var SetSuperTableController = class extends Disposable {
  constructor(_commandService, _superTableService) {
    super();
    this._commandService = _commandService;
    this._superTableService = _superTableService;
    this._initialize();
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id === SetDefinedNameMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { unitId, tableName, reference } = params;
          this._superTableService.registerTable(unitId, tableName, reference);
        } else if (command.id === RemoveDefinedNameMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { unitId, tableName } = params;
          this._superTableService.remove(unitId, tableName);
        } else if (command.id === SetSuperTableOptionMutation.id) {
          const params = command.params;
          if (params == null) {
            return;
          }
          const { tableOption, tableOptionType } = params;
          this._superTableService.registerTableOptionMap(tableOption, tableOptionType);
        }
      })
    );
  }
};
SetSuperTableController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, ISuperTableService)
], SetSuperTableController);

// ../packages/engine-formula/src/services/active-dirty-manager.service.ts
var ActiveDirtyManagerService = class extends Disposable {
  constructor() {
    super(...arguments);
    __publicField(this, "_dirtyConversionMap", /* @__PURE__ */ new Map());
  }
  dispose() {
    this._dirtyConversionMap.clear();
  }
  remove(commandId) {
    this._dirtyConversionMap.delete(commandId);
  }
  get(commandId) {
    return this._dirtyConversionMap.get(commandId);
  }
  has(commandId) {
    return this._dirtyConversionMap.has(commandId);
  }
  register(commandId, dirtyConversion) {
    this._dirtyConversionMap.set(commandId, dirtyConversion);
  }
  getDirtyConversionMap() {
    return this._dirtyConversionMap;
  }
};
var IActiveDirtyManagerService = createIdentifier(
  "univer.formula.active-dirty-manager.service"
);

// ../packages/engine-formula/src/plugin.ts
var PLUGIN_NAME = "UNIVER_ENGINE_FORMULA_PLUGIN";
var UniverFormulaEnginePlugin = class extends Plugin {
  constructor(_config = defaultPluginConfig, _injector, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    const { ...rest } = merge_default(
      {},
      defaultPluginConfig,
      this._config
    );
    this._configService.setConfig(ENGINE_FORMULA_PLUGIN_CONFIG_KEY, rest);
  }
  onStarting() {
    this._initialize();
    this._initializeWithOverride();
  }
  onReady() {
    var _a2;
    touchDependencies(this._injector, [
      [FormulaController],
      [SetSuperTableController]
    ]);
    if (!((_a2 = this._config) == null ? void 0 : _a2.notExecuteFormula)) {
      touchDependencies(this._injector, [
        [SetOtherFormulaController],
        [SetFeatureCalculationController],
        [SetDependencyController],
        [CalculateController]
      ]);
    }
  }
  onRendered() {
    var _a2;
    if (!((_a2 = this._config) == null ? void 0 : _a2.notExecuteFormula)) {
      touchDependencies(this._injector, [
        [ICalculateFormulaService],
        [IFormulaDependencyGenerator]
      ]);
    }
  }
  _initialize() {
    const shouldPerformComputing = !this._config.notExecuteFormula;
    const dependencies = [
      // Services
      [IFunctionService, { useClass: FunctionService }],
      [IDefinedNamesService, { useClass: DefinedNamesService }],
      [IActiveDirtyManagerService, { useClass: ActiveDirtyManagerService }],
      [ISheetRowFilteredService, { useClass: SheetRowFilteredService }],
      [ISuperTableService, { useClass: SuperTableService }],
      [GlobalComputingStatusService],
      // Models
      [FormulaDataModel],
      // Engine
      [LexerTreeBuilder],
      //Controllers
      [FormulaController],
      [SetSuperTableController],
      [ComputingStatusReporterController]
    ];
    if (shouldPerformComputing) {
      dependencies.push(
        // Services
        [IOtherFormulaManagerService, { useClass: OtherFormulaManagerService }],
        [IFormulaRuntimeService, { useClass: FormulaRuntimeService }],
        [IFormulaCurrentConfigService, { useClass: FormulaCurrentConfigService }],
        [IFeatureCalculationManagerService, { useClass: FeatureCalculationManagerService }],
        //Controller
        [CalculateController],
        [SetOtherFormulaController],
        [SetDependencyController],
        [SetFeatureCalculationController],
        // Calculation engine
        [Interpreter],
        [AstTreeBuilder],
        [Lexer],
        // AstNode factory
        [AstRootNodeFactory],
        [FunctionNodeFactory],
        [LambdaNodeFactory],
        [LambdaParameterNodeFactory],
        [OperatorNodeFactory],
        [PrefixNodeFactory],
        [ReferenceNodeFactory],
        [SuffixNodeFactory],
        [UnionNodeFactory],
        [ValueNodeFactory]
      );
    }
    dependencies.forEach((dependency) => this._injector.add(dependency));
  }
  _initializeWithOverride() {
    var _a2;
    if (!((_a2 = this._config) == null ? void 0 : _a2.notExecuteFormula)) {
      const dependencies = [
        [ICalculateFormulaService, { useClass: CalculateFormulaService }],
        [IDependencyManagerService, { useClass: DependencyManagerService }],
        [IFormulaDependencyGenerator, { useClass: FormulaDependencyGenerator }]
      ];
      dependencies.forEach((dependency) => this._injector.add(dependency));
    }
  }
};
__publicField(UniverFormulaEnginePlugin, "pluginName", PLUGIN_NAME);
UniverFormulaEnginePlugin = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], UniverFormulaEnginePlugin);

// ../packages/rpc-node/src/plugin.ts
var import_node_child_process = require("child_process");
var import_node_process = __toESM(require("process"));
var import_rxjs28 = __toESM(require_cjs());
var UNIVER_RPC_NODE_MAIN_PLUGIN_CONFIG_KEY = "node-rpc.main.config";
var UniverRPCNodeMainPlugin = class extends Plugin {
  constructor(_config, _injector, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    this._configService.setConfig(UNIVER_RPC_NODE_MAIN_PLUGIN_CONFIG_KEY, this._config);
  }
  onStarting() {
    const { workerSrc } = this._config;
    const messageProtocol = createNodeMessagePortOnMain(this._injector, workerSrc);
    const dependencies = [
      [IRPCChannelService, {
        useFactory: () => new ChannelService(messageProtocol)
      }],
      [DataSyncPrimaryController],
      [IRemoteSyncService, { useClass: RemoteSyncPrimaryService }]
    ];
    dependencies.forEach((dependency) => this._injector.add(dependency));
    this._injector.get(DataSyncPrimaryController);
  }
};
__publicField(UniverRPCNodeMainPlugin, "pluginName", "UNIVER_RPC_NODE_MAIN_PLUGIN");
UniverRPCNodeMainPlugin = __decorateClass([
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], UniverRPCNodeMainPlugin);
var UniverRPCNodeWorkerPlugin = class extends Plugin {
  constructor(_config, _injector) {
    super();
    this._config = _config;
    this._injector = _injector;
  }
  onStarting() {
    [
      [DataSyncReplicaController],
      [IRPCChannelService, {
        useFactory: () => new ChannelService(createNodeWorkerMessageProtocol())
      }],
      [IRemoteInstanceService, { useClass: WebWorkerRemoteInstanceService }]
    ].forEach((d) => this._injector.add(d));
    this._injector.get(DataSyncReplicaController);
  }
};
__publicField(UniverRPCNodeWorkerPlugin, "pluginName", "UNIVER_RPC_NODE_WORKER_PLUGIN");
UniverRPCNodeWorkerPlugin = __decorateClass([
  __decorateParam(1, Inject(Injector))
], UniverRPCNodeWorkerPlugin);
function createNodeMessagePortOnMain(injector, path) {
  const logService = injector.get(ILogService);
  const child = (0, import_node_child_process.fork)(path);
  child.on("spawn", () => logService.log("Child computing process spawned!"));
  child.on("error", (error) => logService.error(error));
  const messageProtocol = {
    send(message) {
      child.send(message);
    },
    onMessage: new import_rxjs28.Observable((subscriber) => {
      const handler = (message) => {
        subscriber.next(message);
      };
      child.on("message", handler);
      return () => child.off("message", handler);
    }).pipe((0, import_rxjs28.shareReplay)(1))
  };
  return messageProtocol;
}
function createNodeWorkerMessageProtocol() {
  return {
    send(message) {
      import_node_process.default.send(message);
    },
    onMessage: new import_rxjs28.Observable((subscriber) => {
      const handler = (event) => {
        subscriber.next(event);
      };
      import_node_process.default.on("message", handler);
      return () => import_node_process.default.off("message", handler);
    }).pipe((0, import_rxjs28.shareReplay)(1))
  };
}

// ../packages/sheets/src/model/range-protection-rule.model.ts
var import_rxjs29 = __toESM(require_cjs());
var RangeProtectionRuleModel = class {
  constructor() {
    /**
     * Map<unitId, Map<subUnitId, Map<ruleId, IRangeProtectionRule>>>
     */
    __publicField(this, "_model", /* @__PURE__ */ new Map());
    __publicField(this, "_ruleChange$", new import_rxjs29.Subject());
    __publicField(this, "ruleChange$", this._ruleChange$.asObservable());
    __publicField(this, "_ruleRefresh$", new import_rxjs29.Subject());
    __publicField(this, "ruleRefresh$", this._ruleRefresh$.asObservable());
    __publicField(this, "_rangeRuleInitStateChange", new import_rxjs29.BehaviorSubject(false));
    __publicField(this, "rangeRuleInitStateChange$", this._rangeRuleInitStateChange.asObservable());
  }
  dispose() {
    this._ruleChange$.complete();
    this._ruleRefresh$.complete();
  }
  ruleRefresh(id) {
    this._ruleRefresh$.next(id);
  }
  getRangeRuleInitState() {
    return this._rangeRuleInitStateChange.value;
  }
  changeRuleInitState(state) {
    this._rangeRuleInitStateChange.next(state);
  }
  addRule(unitId, subUnitId, rule) {
    const ruleMap = this._ensureRuleMap(unitId, subUnitId);
    ruleMap.set(rule.id, rule);
    this._ruleChange$.next({ unitId, subUnitId, rule, type: "add" });
  }
  deleteRule(unitId, subUnitId, id) {
    var _a2, _b2, _c, _d;
    const rule = (_b2 = (_a2 = this._model.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.get(id);
    if (rule) {
      (_d = (_c = this._model.get(unitId)) == null ? void 0 : _c.get(subUnitId)) == null ? void 0 : _d.delete(id);
      this._ruleChange$.next({ unitId, subUnitId, rule, type: "delete" });
    }
  }
  setRule(unitId, subUnitId, id, rule) {
    var _a2, _b2;
    const oldRule = this.getRule(unitId, subUnitId, id);
    if (oldRule) {
      (_b2 = (_a2 = this._model.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.set(id, rule);
      this._ruleChange$.next({ unitId, subUnitId, oldRule, rule, type: "set" });
    }
  }
  getRule(unitId, subUnitId, id) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._model.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.get(id);
  }
  getSubunitRuleList(unitId, subUnitId) {
    var _a2;
    const map9 = ((_a2 = this._model.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) || /* @__PURE__ */ new Map();
    return [...map9.values()];
  }
  getSubunitRuleListLength(unitId, subUnitId) {
    var _a2;
    const map9 = (_a2 = this._model.get(unitId)) == null ? void 0 : _a2.get(subUnitId);
    return map9 ? map9.size : 0;
  }
  _ensureRuleMap(unitId, subUnitId) {
    let subUnitMap = this._model.get(unitId);
    if (!subUnitMap) {
      subUnitMap = /* @__PURE__ */ new Map();
      this._model.set(unitId, subUnitMap);
    }
    let ruleMap = subUnitMap.get(subUnitId);
    if (!ruleMap) {
      ruleMap = /* @__PURE__ */ new Map();
      subUnitMap.set(subUnitId, ruleMap);
    }
    return ruleMap;
  }
  toObject() {
    const result = {};
    const unitKeys = [...this._model.keys()];
    unitKeys.forEach((unitId) => {
      const submitMap = this._model.get(unitId);
      const subUnitKeys = [...submitMap.keys()];
      result[unitId] = {};
      subUnitKeys.forEach((subunitId) => {
        const ruleMap = submitMap.get(subunitId);
        result[unitId][subunitId] = [...ruleMap.values()];
      });
    });
    return result;
  }
  fromObject(obj) {
    const result = /* @__PURE__ */ new Map();
    Object.keys(obj).forEach((unitId) => {
      const subUnitObj = obj[unitId];
      const map9 = /* @__PURE__ */ new Map();
      Object.keys(subUnitObj).forEach((subunitId) => {
        const ruleMap = subUnitObj[subunitId].reduce((result2, cur) => {
          result2.set(cur.id, cur);
          return result2;
        }, /* @__PURE__ */ new Map());
        map9.set(subunitId, ruleMap);
      });
      result.set(unitId, map9);
    });
    this._model = result;
  }
  deleteUnitModel(unitId) {
    this._model.delete(unitId);
  }
  createRuleId(unitId, subUnitId) {
    let id = Tools.generateRandomId(4);
    const ruleMap = this._ensureRuleMap(unitId, subUnitId);
    while (ruleMap.has(id)) {
      id = Tools.generateRandomId(4);
    }
    return id;
  }
  getTargetByPermissionId(unitId, permissionId) {
    const subUnitMap = this._model.get(unitId);
    if (!subUnitMap) return null;
    for (const [subUnitId, ruleMap] of subUnitMap) {
      for (const rule of ruleMap.values()) {
        if (rule.permissionId === permissionId) {
          return [unitId, subUnitId];
        }
      }
    }
    return null;
  }
};

// ../packages/sheets/src/commands/mutations/delete-range-protection.mutation.ts
var DeleteRangeProtectionMutation = {
  id: "sheet.mutation.delete-range-protection",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, ruleIds } = params;
    const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
    ruleIds.forEach((id) => {
      selectionProtectionRuleModel.deleteRule(unitId, subUnitId, id);
    });
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/add-range-protection.mutation.ts
var AddRangeProtectionMutation = {
  id: "sheet.mutation.add-range-protection",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, rules } = params;
    const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
    rules.forEach((rule) => {
      selectionProtectionRuleModel.addRule(unitId, subUnitId, rule);
    });
    return true;
  }
};

// ../packages/sheets/src/commands/commands/add-range-protection.command.ts
var AddRangeProtectionCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-range-protection",
  async handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const selectionProtectionModel = accessor.get(RangeProtectionRuleModel);
    const { rule, permissionId } = params;
    const { unitId, subUnitId, ranges, description, viewState, editState } = rule;
    const rules = [{
      ranges,
      permissionId,
      id: selectionProtectionModel.createRuleId(unitId, subUnitId),
      description,
      unitType: rule.unitType,
      unitId,
      subUnitId,
      viewState,
      editState
    }];
    const result = await commandService.executeCommand(AddRangeProtectionMutation.id, {
      unitId,
      subUnitId,
      rules
    });
    if (result) {
      const redoMutations = [{ id: AddRangeProtectionMutation.id, params: { unitId, subUnitId, rules } }];
      const undoMutations = [{ id: DeleteRangeProtectionMutation.id, params: { unitId, subUnitId, ruleIds: rules.map((rule2) => rule2.id) } }];
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        redoMutations,
        undoMutations
      });
    }
    return true;
  }
};

// ../packages/sheets/src/services/permission/worksheet-permission/worksheet-permission-rule.model.ts
var import_rxjs30 = __toESM(require_cjs());
var WorksheetProtectionRuleModel = class {
  constructor() {
    /**
     *
     * Map<unitId, Map<subUnitId, Map<subUnitId, IWorksheetProtectionRule>>>
     */
    __publicField(this, "_model", /* @__PURE__ */ new Map());
    __publicField(this, "_ruleChange", new import_rxjs30.Subject());
    __publicField(this, "_ruleRefresh", new import_rxjs30.Subject());
    __publicField(this, "_resetOrder", new import_rxjs30.Subject());
    __publicField(this, "ruleChange$", this._ruleChange.asObservable());
    __publicField(this, "ruleRefresh$", this._ruleRefresh.asObservable());
    __publicField(this, "resetOrder$", this._resetOrder.asObservable());
    __publicField(this, "_worksheetRuleInitStateChange", new import_rxjs30.BehaviorSubject(false));
    __publicField(this, "worksheetRuleInitStateChange$", this._worksheetRuleInitStateChange.asObservable());
  }
  changeRuleInitState(state) {
    this._worksheetRuleInitStateChange.next(state);
  }
  getSheetRuleInitState() {
    return this._worksheetRuleInitStateChange.value;
  }
  addRule(unitId, rule) {
    const subUnitMap = this._ensureSubUnitMap(unitId);
    subUnitMap.set(rule.subUnitId, rule);
    this._ruleChange.next({ unitId, rule, type: "add", subUnitId: rule.subUnitId });
  }
  deleteRule(unitId, subUnitId) {
    var _a2, _b2, _c;
    const rule = (_b2 = (_a2 = this._model) == null ? void 0 : _a2.get(unitId)) == null ? void 0 : _b2.get(subUnitId);
    if (rule) {
      (_c = this._model.get(unitId)) == null ? void 0 : _c.delete(subUnitId);
      this._ruleChange.next({ unitId, rule, type: "delete", subUnitId });
    }
  }
  setRule(unitId, subUnitId, rule) {
    var _a2, _b2;
    const oldRule = this.getRule(unitId, subUnitId);
    if (oldRule) {
      (_b2 = (_a2 = this._model) == null ? void 0 : _a2.get(unitId)) == null ? void 0 : _b2.set(subUnitId, rule);
      this._ruleChange.next({ unitId, oldRule, rule, type: "set", subUnitId });
    }
  }
  getRule(unitId, subUnitId) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._model) == null ? void 0 : _a2.get(unitId)) == null ? void 0 : _b2.get(subUnitId);
  }
  toObject() {
    const result = {};
    const unitKeys = [...this._model.keys()];
    unitKeys.forEach((unitId) => {
      const subUnitMap = this._model.get(unitId);
      if (subUnitMap == null ? void 0 : subUnitMap.size) {
        result[unitId] = [];
        const subUnitKeys = [...subUnitMap.keys()];
        subUnitKeys.forEach((subUnitId) => {
          const rule = subUnitMap.get(subUnitId);
          if (rule) {
            result[unitId].push(rule);
          }
        });
      }
    });
    return result;
  }
  fromObject(obj) {
    const result = /* @__PURE__ */ new Map();
    Object.keys(obj).forEach((unitId) => {
      const subUnitList = obj[unitId];
      if (subUnitList == null ? void 0 : subUnitList.length) {
        const subUnitMap = /* @__PURE__ */ new Map();
        subUnitList.forEach((rule) => {
          subUnitMap.set(rule.subUnitId, rule);
        });
        result.set(unitId, subUnitMap);
      }
    });
    this._model = result;
  }
  deleteUnitModel(unitId) {
    this._model.delete(unitId);
  }
  _ensureSubUnitMap(unitId) {
    let subUnitMap = this._model.get(unitId);
    if (!subUnitMap) {
      subUnitMap = /* @__PURE__ */ new Map();
      this._model.set(unitId, subUnitMap);
    }
    return subUnitMap;
  }
  ruleRefresh(permissionId) {
    this._ruleRefresh.next(permissionId);
  }
  resetOrder() {
    this._resetOrder.next(Math.random());
  }
  getTargetByPermissionId(unitId, permissionId) {
    const subUnitMap = this._model.get(unitId);
    if (!subUnitMap) return null;
    for (const [subUnitId, rule] of subUnitMap) {
      if (rule.permissionId === permissionId) {
        return [unitId, subUnitId];
      }
    }
  }
};

// ../packages/sheets/src/commands/mutations/add-worksheet-protection.mutation.ts
var AddWorksheetProtectionMutation = {
  id: "sheet.mutation.add-worksheet-protection",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, rule } = params;
    const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
    worksheetProtectionRuleModel.addRule(unitId, rule);
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/delete-worksheet-protection.mutation.ts
var DeleteWorksheetProtectionMutation = {
  id: "sheet.mutation.delete-worksheet-protection",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId } = params;
    const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
    worksheetProtectionRuleModel.deleteRule(unitId, subUnitId);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/add-worksheet-protection.command.ts
var AddWorksheetProtectionCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-protection",
  async handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { rule, unitId } = params;
    const subUnitId = rule.subUnitId;
    const result = await commandService.executeCommand(AddWorksheetProtectionMutation.id, {
      unitId,
      rule,
      subUnitId: rule.subUnitId
    });
    if (result) {
      const redoMutations = [{ id: AddWorksheetProtectionMutation.id, params: { unitId, rule, subUnitId: rule.subUnitId } }];
      const undoMutations = [{ id: DeleteWorksheetProtectionMutation.id, params: { unitId, subUnitId } }];
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        redoMutations,
        undoMutations
      });
    }
    return true;
  }
};

// ../packages/sheets/src/services/sheet-interceptor/interceptor-const.ts
var CELL_CONTENT = createInterceptorKey("CELL_CONTENT");
var ROW_FILTERED = createInterceptorKey("ROW_FILTERED");
var INTERCEPTOR_POINT = {
  CELL_CONTENT,
  ROW_FILTERED
};
var RangeThemeInterceptorId = "sheet.interceptor.range-theme-id";
var IgnoreRangeThemeInterceptorKey = "sheet.interceptor.ignore-range-theme";

// ../packages/sheets/src/services/sheet-interceptor/sheet-interceptor.service.ts
var BEFORE_CELL_EDIT = createInterceptorKey("BEFORE_CELL_EDIT");
var AFTER_CELL_EDIT = createInterceptorKey("AFTER_CELL_EDIT");
var VALIDATE_CELL = createInterceptorKey("VALIDATE_CELL");
var SheetInterceptorService = class extends Disposable {
  /** @ignore */
  constructor(_univerInstanceService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_interceptorsByName", /* @__PURE__ */ new Map());
    __publicField(this, "_commandInterceptors", []);
    __publicField(this, "_rangeInterceptors", []);
    __publicField(this, "_beforeCommandInterceptor", []);
    __publicField(this, "_afterCommandInterceptors", []);
    __publicField(this, "_workbookDisposables", /* @__PURE__ */ new Map());
    __publicField(this, "_worksheetDisposables", /* @__PURE__ */ new Map());
    __publicField(this, "_interceptorsDirty", false);
    __publicField(this, "_composedInterceptorByKey", /* @__PURE__ */ new Map());
    __publicField(this, "writeCellInterceptor", new InterceptorManager({
      BEFORE_CELL_EDIT,
      AFTER_CELL_EDIT,
      VALIDATE_CELL
    }));
    this.disposeWithMe(this._univerInstanceService.getTypeOfUnitAdded$(O.UNIVER_SHEET).subscribe((workbook) => {
      this._interceptWorkbook(workbook);
    }));
    this.disposeWithMe(this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET).subscribe(
      (workbook) => this._disposeWorkbookInterceptor(workbook)
    ));
    this.intercept(INTERCEPTOR_POINT.CELL_CONTENT, {
      priority: -1,
      effect: 1 /* Style */ | 2 /* Value */,
      handler(value, context) {
        const rawData = context.worksheet.getCellRaw(context.row, context.col);
        if (value) {
          return { ...rawData, ...value };
        }
        return rawData;
      }
    });
    this.disposeWithMe(this.writeCellInterceptor.intercept(AFTER_CELL_EDIT, {
      priority: -1,
      handler: (_value) => _value
    }));
    this.disposeWithMe(this.writeCellInterceptor.intercept(BEFORE_CELL_EDIT, {
      priority: -1,
      handler: (_value) => _value
    }));
    this.disposeWithMe(this.writeCellInterceptor.intercept(VALIDATE_CELL, {
      priority: -1,
      handler: (_value) => _value
    }));
  }
  dispose() {
    super.dispose();
    this._workbookDisposables.forEach((disposable) => disposable.dispose());
    this._workbookDisposables.clear();
    this._worksheetDisposables.clear();
    this._interceptorsByName.clear();
  }
  // #region intercept command execution
  /**
   * Add a listener function to a specific command to add affiliated mutations. It should be called in controllers.
   *
   * Pairs with {@link onCommandExecute}.
   *
   * @param interceptor
   * @returns
   */
  interceptCommand(interceptor) {
    if (this._commandInterceptors.includes(interceptor)) {
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    }
    this._commandInterceptors.push(interceptor);
    this._commandInterceptors.sort((a2, b) => {
      var _a2, _b2;
      return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a2.priority) != null ? _b2 : 0);
    });
    return this.disposeWithMe(toDisposable(() => remove(this._commandInterceptors, interceptor)));
  }
  /**
   * When command is executing, call this method to gether undo redo mutations from upper features.
   * @param command
   * @returns
   */
  onCommandExecute(info) {
    const infos = this._commandInterceptors.map((i) => i.getMutations(info));
    return {
      preUndos: infos.map((i) => {
        var _a2;
        return (_a2 = i.preUndos) != null ? _a2 : [];
      }).flat(),
      undos: infos.map((i) => i.undos).flat(),
      preRedos: infos.map((i) => {
        var _a2;
        return (_a2 = i.preRedos) != null ? _a2 : [];
      }).flat(),
      redos: infos.map((i) => i.redos).flat()
    };
  }
  interceptAfterCommand(interceptor) {
    if (this._afterCommandInterceptors.includes(interceptor)) {
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    }
    this._afterCommandInterceptors.push(interceptor);
    this._afterCommandInterceptors.sort((a2, b) => {
      var _a2, _b2;
      return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a2.priority) != null ? _b2 : 0);
    });
    return this.disposeWithMe(toDisposable(() => remove(this._afterCommandInterceptors, interceptor)));
  }
  afterCommandExecute(info) {
    const infos = this._afterCommandInterceptors.map((i) => i.getMutations(info));
    return {
      undos: infos.map((i) => i.undos).flat(),
      redos: infos.map((i) => i.redos).flat()
    };
  }
  /**
   * Add a listener function to a specific command to determine if the command can execute mutations. It should be
   * called in controllers.
   *
   * Pairs with {@link beforeCommandExecute}.
   *
   * @param interceptor
   * @returns
   */
  interceptBeforeCommand(interceptor) {
    if (this._beforeCommandInterceptor.includes(interceptor)) {
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    }
    this._beforeCommandInterceptor.push(interceptor);
    this._beforeCommandInterceptor.sort((a2, b) => {
      var _a2, _b2;
      return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a2.priority) != null ? _b2 : 0);
    });
    return this.disposeWithMe(toDisposable(() => remove(this._beforeCommandInterceptor, interceptor)));
  }
  /**
   * before command execute, call this method to get the flag of whether it can be executed the command，
   * @param info ICommandInfo
   * @returns Promise<boolean>
   */
  async beforeCommandExecute(info) {
    const allPerformCheckRes = await Promise.all(this._beforeCommandInterceptor.map((i) => i.performCheck(info)));
    return allPerformCheckRes.every((perform) => perform);
  }
  // #endregion
  // #region intercept ranges - mainly for pivot table currently (2024/10/28).
  /**
   * By adding callbacks to some Ranges can get some additional mutations, such as clearing all plugin data in a certain area.
   * @param interceptor IRangeInterceptors
   * @returns IDisposable
   */
  interceptRanges(interceptor) {
    if (this._rangeInterceptors.includes(interceptor)) {
      throw new Error("[SheetInterceptorService]: Interceptor already exists!");
    }
    this._rangeInterceptors.push(interceptor);
    this._rangeInterceptors.sort((a2, b) => {
      var _a2, _b2;
      return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a2.priority) != null ? _b2 : 0);
    });
    return this.disposeWithMe(toDisposable(() => remove(this._rangeInterceptors, interceptor)));
  }
  generateMutationsByRanges(info) {
    const infos = this._rangeInterceptors.map((i) => i.getMutations(info));
    return {
      preUndos: infos.map((i) => {
        var _a2;
        return (_a2 = i.preUndos) != null ? _a2 : [];
      }).flat(),
      undos: infos.map((i) => i.undos).flat(),
      preRedos: infos.map((i) => {
        var _a2;
        return (_a2 = i.preRedos) != null ? _a2 : [];
      }).flat(),
      redos: infos.map((i) => i.redos).flat()
    };
  }
  // #endregion
  // #region intercept on writing cell
  onWriteCell(workbook, worksheet, row, col, cellData) {
    const context = {
      subUnitId: worksheet.getSheetId(),
      unitId: workbook.getUnitId(),
      workbook,
      worksheet,
      row,
      col,
      origin: Tools.deepClone(cellData)
    };
    return this.writeCellInterceptor.fetchThroughInterceptors(AFTER_CELL_EDIT)(cellData, context);
  }
  // #endregion
  onValidateCell(workbook, worksheet, row, col) {
    const context = {
      subUnitId: worksheet.getSheetId(),
      unitId: workbook.getUnitId(),
      workbook,
      worksheet,
      row,
      col
    };
    return this.writeCellInterceptor.fetchThroughInterceptors(VALIDATE_CELL)(Promise.resolve(true), context);
  }
  intercept(name, interceptor) {
    const key = name;
    if (!this._interceptorsByName.has(key)) {
      this._interceptorsByName.set(key, []);
    }
    const interceptors = this._interceptorsByName.get(key);
    interceptors.push(interceptor);
    const sortedInterceptors = interceptors.sort((a2, b) => {
      var _a2, _b2;
      return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a2.priority) != null ? _b2 : 0);
    });
    this._interceptorsDirty = true;
    if (key === INTERCEPTOR_POINT.CELL_CONTENT) {
      const JOINED_EFFECT = 1 /* Style */ | 2 /* Value */;
      this._interceptorsByName.set(`${key}-${JOINED_EFFECT}`, sortedInterceptors);
      const BOTH_EFFECT = 1 /* Style */ | 2 /* Value */;
      this._interceptorsByName.set(
        `${key}-${1 /* Style */}`,
        sortedInterceptors.filter((i) => ((i.effect || BOTH_EFFECT) & 1 /* Style */) > 0)
      );
      this._interceptorsByName.set(
        `${key}-${2 /* Value */}`,
        sortedInterceptors.filter((i) => ((i.effect || BOTH_EFFECT) & 2 /* Value */) > 0)
      );
      return this.disposeWithMe(toDisposable(() => {
        remove(this._interceptorsByName.get(key), interceptor);
        remove(this._interceptorsByName.get(`${key}-${JOINED_EFFECT}`), interceptor);
        remove(this._interceptorsByName.get(`${key}-${1 /* Style */}`), interceptor);
        remove(this._interceptorsByName.get(`${key}-${2 /* Value */}`), interceptor);
      }));
    } else {
      this._interceptorsByName.set(key, sortedInterceptors);
      return this.disposeWithMe(toDisposable(() => remove(this._interceptorsByName.get(key), interceptor)));
    }
  }
  fetchThroughInterceptors(name, effect, _key, filter8) {
    const byNamesKey = effect === void 0 ? name : `${name}-${effect}`;
    const key = _key != null ? _key : byNamesKey;
    let composed = this._composedInterceptorByKey.get(key);
    if (!composed || this._interceptorsDirty) {
      let interceptors = this._interceptorsByName.get(byNamesKey);
      if (interceptors && filter8) {
        interceptors = interceptors.filter(filter8);
      }
      composed = composeInterceptors(interceptors || []);
      this._composedInterceptorByKey.set(key, composed);
    }
    return composed;
  }
  _interceptWorkbook(workbook) {
    const disposables = new DisposableCollection();
    const unitId = workbook.getUnitId();
    const sheetInterceptorService = this;
    const interceptViewModel = (worksheet) => {
      const subUnitId = worksheet.getSheetId();
      worksheet.__interceptViewModel((viewModel) => {
        const sheetDisposables = new DisposableCollection();
        sheetInterceptorService._worksheetDisposables.set(getWorksheetDisposableID(unitId, worksheet), sheetDisposables);
        sheetDisposables.add(viewModel.registerCellContentInterceptor({
          getCell(row, col, effect, key, filter8) {
            const rawData = worksheet.getCellRaw(row, col);
            return sheetInterceptorService.fetchThroughInterceptors(INTERCEPTOR_POINT.CELL_CONTENT, effect, key, filter8)(
              rawData,
              {
                unitId,
                subUnitId,
                row,
                col,
                worksheet,
                workbook,
                rawData
              }
            );
          }
        }));
        sheetDisposables.add(viewModel.registerRowFilteredInterceptor({
          getRowFiltered(row) {
            return !!sheetInterceptorService.fetchThroughInterceptors(INTERCEPTOR_POINT.ROW_FILTERED)(
              false,
              {
                unitId,
                subUnitId,
                row,
                workbook,
                worksheet
              }
            );
          }
        }));
      });
    };
    workbook.getSheets().forEach((worksheet) => interceptViewModel(worksheet));
    disposables.add(workbook.sheetCreated$.subscribe((worksheet) => interceptViewModel(worksheet)));
    disposables.add(toDisposable(() => workbook.getSheets().forEach((worksheet) => this._disposeSheetInterceptor(unitId, worksheet))));
    disposables.add(workbook.sheetDisposed$.subscribe((worksheet) => this._disposeSheetInterceptor(unitId, worksheet)));
    this._workbookDisposables.set(unitId, disposables);
  }
  _disposeWorkbookInterceptor(workbook) {
    const unitId = workbook.getUnitId();
    const disposable = this._workbookDisposables.get(unitId);
    if (disposable) {
      disposable.dispose();
      this._workbookDisposables.delete(unitId);
    }
  }
  _disposeSheetInterceptor(unitId, worksheet) {
    const disposableId = getWorksheetDisposableID(unitId, worksheet);
    const disposable = this._worksheetDisposables.get(disposableId);
    if (disposable) {
      disposable.dispose();
      this._worksheetDisposables.delete(disposableId);
    }
  }
};
SheetInterceptorService = __decorateClass([
  __decorateParam(0, IUniverInstanceService)
], SheetInterceptorService);
function getWorksheetDisposableID(unitId, worksheet) {
  return `${unitId}|${worksheet.getSheetId()}`;
}

// ../packages/sheets/src/model/range-theme-util.ts
var serializeRangeStyle = (style) => {
  const result = {};
  if (style.bg) {
    result.bg = { ...style.bg };
  }
  if (style.ol) {
    result.ol = { ...style.ol };
  }
  if (style.bd) {
    result.bd = { ...style.bd };
  }
  if (style.cl) {
    result.cl = { ...style.cl };
  }
  if (style.ht) {
    result.ht = style.ht;
  }
  if (style.vt) {
    result.vt = style.vt;
  }
  if (style.bl !== void 0) {
    result.bl = style.bl;
  }
  return result;
};
function composeStyles2(styles) {
  const composedStyle = {};
  if (styles.length === 1) {
    return styles[0];
  }
  for (const style of styles) {
    if (style.bg) {
      composedStyle.bg = style.bg;
    }
    if (style.ol) {
      composedStyle.ol = style.ol;
    }
    if (style.bd) {
      composedStyle.bd = { ...composedStyle.bd, ...style.bd };
    }
    if (style.cl) {
      composedStyle.cl = style.cl;
    }
    if (style.ht) {
      composedStyle.ht = style.ht;
    }
    if (style.vt) {
      composedStyle.vt = style.vt;
    }
    if (style.bl !== void 0) {
      composedStyle.bl = style.bl;
    }
  }
  return composedStyle;
}
var STYLE_MAP = {
  wholeStyle: 1,
  headerRowStyle: 2,
  headerColumnStyle: 4,
  firstRowStyle: 8,
  secondRowStyle: 16,
  lastRowStyle: 32,
  firstColumnStyle: 128,
  secondColumnStyle: 256,
  lastColumnStyle: 512
};
var RangeThemeStyle = class {
  /**
   * @constructor
   * @param {string} name The name of the range theme style, it used to identify the range theme style.
   * @param {IRangeThemeStyleJSON} [options] The options to initialize the range theme style.
   */
  constructor(name, options) {
    __publicField(this, "_name");
    /**
     * @property {Nullable<IRangeThemeStyleItem>} wholeStyle effect for the whole range.
     */
    __publicField(this, "wholeStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} headerRowStyle effect for the header row.
     */
    __publicField(this, "headerRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} headerColumnStyle effect for the header column.
     */
    __publicField(this, "headerColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} firstRowStyle effect for the first row.
     */
    __publicField(this, "firstRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} secondRowStyle effect for the second row.
     */
    __publicField(this, "secondRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} lastRowStyle effect for the last row.
     */
    __publicField(this, "lastRowStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} firstColumnStyle effect for the first column.
     */
    __publicField(this, "firstColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} secondColumnStyle effect for the second column.
     */
    __publicField(this, "secondColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} lastColumnStyle effect for the last column.
     */
    __publicField(this, "lastColumnStyle", null);
    /**
     * @property {Nullable<IRangeThemeStyleItem>} quickly get merge style
     */
    __publicField(this, "_mergeCacheMap", /* @__PURE__ */ new Map());
    if (options) {
      this.fromJson({ ...options, name });
    }
    this._name = name;
  }
  /**
   * Gets the name of the range theme style.The name is read only, and use to identifier the range theme style.
   * @returns {string} The name of the range theme style.
   */
  getName() {
    return this._name;
  }
  getWholeStyle() {
    return this.wholeStyle;
  }
  setWholeStyle(style) {
    this.wholeStyle = style;
  }
  getFirstRowStyle() {
    return this.firstRowStyle;
  }
  setFirstRowStyle(style) {
    this.firstRowStyle = style;
  }
  getSecondRowStyle() {
    return this.secondRowStyle;
  }
  setSecondRowStyle(style) {
    this.secondRowStyle = style;
  }
  getLastRowStyle() {
    return this.lastRowStyle;
  }
  setLastRowStyle(style) {
    this.lastRowStyle = style;
  }
  getFirstColumnStyle() {
    return this.firstColumnStyle;
  }
  setFirstColumnStyle(style) {
    this.firstColumnStyle = style;
  }
  getSecondColumnStyle() {
    return this.secondColumnStyle;
  }
  setSecondColumnStyle(style) {
    this.secondColumnStyle = style;
  }
  getLastColumnStyle() {
    return this.lastColumnStyle;
  }
  setLastColumnStyle(style) {
    this.lastColumnStyle = style;
  }
  getHeaderRowStyle() {
    return this.headerRowStyle;
  }
  setHeaderRowStyle(style) {
    this.headerRowStyle = style;
  }
  getHeaderColumnStyle() {
    return this.headerColumnStyle;
  }
  setHeaderColumnStyle(style) {
    this.headerColumnStyle = style;
  }
  getStyle(offsetRow, offsetCol, isLastRow, isLastCol) {
    let mergeNumber = 0;
    if (isLastRow) {
      mergeNumber = mergeNumber | STYLE_MAP.lastRowStyle;
    }
    if (isLastCol) {
      mergeNumber = mergeNumber | STYLE_MAP.lastColumnStyle;
    }
    if (offsetRow >= 0 && offsetCol >= 0) {
      mergeNumber = mergeNumber | STYLE_MAP.wholeStyle;
    }
    if (offsetRow % 2 === 1) {
      mergeNumber = mergeNumber | STYLE_MAP.firstRowStyle;
    }
    if (offsetRow % 2 === 0) {
      mergeNumber = mergeNumber | STYLE_MAP.secondRowStyle;
    }
    if (offsetRow === 0) {
      mergeNumber = mergeNumber | STYLE_MAP.headerRowStyle;
    }
    if (offsetCol === 0) {
      mergeNumber = mergeNumber | STYLE_MAP.headerColumnStyle;
    }
    if (offsetCol % 2 === 1) {
      mergeNumber = mergeNumber | STYLE_MAP.firstColumnStyle;
    }
    if (offsetCol % 2 === 0) {
      mergeNumber = mergeNumber | STYLE_MAP.secondColumnStyle;
    }
    if (mergeNumber === 0) {
      return null;
    }
    return this._getMergeStyle(mergeNumber);
  }
  _getMergeStyle(mergeNumber) {
    let style = this._mergeCacheMap.get(mergeNumber);
    if (!style) {
      style = this._mergeStyle(mergeNumber);
      this._mergeCacheMap.set(mergeNumber, style);
    }
    return style;
  }
  _mergeStyle(mergeNumber) {
    const rs = [];
    if (this.wholeStyle && mergeNumber & STYLE_MAP.wholeStyle) {
      rs.push(this.wholeStyle);
    }
    if (this.firstColumnStyle && mergeNumber & STYLE_MAP.firstColumnStyle) {
      rs.push(this.firstColumnStyle);
    }
    if (this.secondColumnStyle && mergeNumber & STYLE_MAP.secondColumnStyle) {
      rs.push(this.secondColumnStyle);
    }
    if (this.firstRowStyle && mergeNumber & STYLE_MAP.firstRowStyle) {
      rs.push(this.firstRowStyle);
    }
    if (this.secondRowStyle && mergeNumber & STYLE_MAP.secondRowStyle) {
      rs.push(this.secondRowStyle);
    }
    if (this.headerColumnStyle && mergeNumber & STYLE_MAP.headerColumnStyle) {
      rs.push(this.headerColumnStyle);
    }
    if (this.lastColumnStyle && mergeNumber & STYLE_MAP.lastColumnStyle) {
      rs.push(this.lastColumnStyle);
    }
    if (this.headerRowStyle && mergeNumber & STYLE_MAP.headerRowStyle) {
      rs.push(this.headerRowStyle);
    }
    if (this.lastRowStyle && mergeNumber & STYLE_MAP.lastRowStyle) {
      rs.push(this.lastRowStyle);
    }
    return composeStyles2(rs);
  }
  toJson() {
    const jsonData = {
      name: this._name
    };
    if (this.wholeStyle) {
      jsonData.wholeStyle = serializeRangeStyle(this.wholeStyle);
    }
    if (this.headerRowStyle) {
      jsonData.headerRowStyle = serializeRangeStyle(this.headerRowStyle);
    }
    if (this.headerColumnStyle) {
      jsonData.headerColumnStyle = serializeRangeStyle(this.headerColumnStyle);
    }
    if (this.firstRowStyle) {
      jsonData.firstRowStyle = serializeRangeStyle(this.firstRowStyle);
    }
    if (this.secondRowStyle) {
      jsonData.secondRowStyle = serializeRangeStyle(this.secondRowStyle);
    }
    if (this.lastRowStyle) {
      jsonData.lastRowStyle = serializeRangeStyle(this.lastRowStyle);
    }
    if (this.firstColumnStyle) {
      jsonData.firstColumnStyle = serializeRangeStyle(this.firstColumnStyle);
    }
    if (this.secondColumnStyle) {
      jsonData.secondColumnStyle = serializeRangeStyle(this.secondColumnStyle);
    }
    if (this.lastColumnStyle) {
      jsonData.lastColumnStyle = serializeRangeStyle(this.lastColumnStyle);
    }
    return jsonData;
  }
  fromJson(json) {
    this._name = json.name;
    if (json.wholeStyle) {
      this.wholeStyle = serializeRangeStyle(json.wholeStyle);
    }
    if (json.headerRowStyle) {
      this.headerRowStyle = serializeRangeStyle(json.headerRowStyle);
    }
    if (json.headerColumnStyle) {
      this.headerColumnStyle = serializeRangeStyle(json.headerColumnStyle);
    }
    if (json.firstRowStyle) {
      this.firstRowStyle = serializeRangeStyle(json.firstRowStyle);
    }
    if (json.secondRowStyle) {
      this.secondRowStyle = serializeRangeStyle(json.secondRowStyle);
    }
    if (json.lastRowStyle) {
      this.lastRowStyle = serializeRangeStyle(json.lastRowStyle);
    }
    if (json.firstColumnStyle) {
      this.firstColumnStyle = serializeRangeStyle(json.firstColumnStyle);
    }
    if (json.secondColumnStyle) {
      this.secondColumnStyle = serializeRangeStyle(json.secondColumnStyle);
    }
    if (json.lastColumnStyle) {
      this.lastColumnStyle = serializeRangeStyle(json.lastColumnStyle);
    }
  }
  dispose() {
    this._mergeCacheMap.clear();
  }
};

// ../packages/sheets/src/model/range-themes/build-in-theme.factory.ts
var lightRangeThemeBuilder = (baseName, header, color) => {
  return new RangeThemeStyle(`light-${baseName}`, {
    headerRowStyle: {
      bg: {
        rgb: header
      }
    },
    firstColumnStyle: {
      bg: {
        rgb: "rgb(255, 255, 255)"
      }
    },
    secondColumnStyle: {
      bg: {
        rgb: color
      }
    },
    lastRowStyle: {
      bg: {
        rgb: header
      }
    }
  });
};
var middleRangeThemeBuilder = (baseName, rowHeader, colHeader) => {
  return new RangeThemeStyle(`middle-${baseName}`, {
    headerRowStyle: {
      bg: {
        rgb: rowHeader
      }
    },
    headerColumnStyle: {
      bg: {
        rgb: colHeader
      }
    },
    secondRowStyle: {
      bg: {
        rgb: colHeader
      }
    },
    lastRowStyle: {
      bg: {
        rgb: rowHeader
      }
    },
    lastColumnStyle: {
      bg: {
        rgb: colHeader
      }
    }
  });
};
var darkRangeThemeBuilder = (baseName, rowHeader, firstRow, secondRow) => {
  return new RangeThemeStyle(`dark-${baseName}`, {
    headerRowStyle: {
      bg: {
        rgb: rowHeader
      },
      cl: {
        rgb: "rgb(255, 255, 255)"
      },
      ht: 2 /* CENTER */,
      bl: 1 /* TRUE */
    },
    firstRowStyle: {
      bg: {
        rgb: firstRow
      }
    },
    secondRowStyle: {
      bg: {
        rgb: secondRow
      }
    },
    lastRowStyle: {
      bg: {
        rgb: rowHeader
      }
    }
  });
};
var lightConfig = [
  {
    baseName: "blue",
    header: "rgb(164, 202, 254)",
    color: "rgb(225, 239, 254)"
  },
  {
    baseName: "grey",
    header: "rgb(205, 208, 216)",
    color: "rgb(238, 239, 241)"
  },
  {
    baseName: "red",
    header: "rgb(248, 180, 180)",
    color: "rgb(253, 232, 232)"
  },
  {
    baseName: "orange",
    header: "rgb(253, 186, 140)",
    color: "rgb(254, 236, 220)"
  },
  {
    baseName: "yellow",
    header: "rgb(250, 200, 21)",
    color: "rgb(255, 244, 185)"
  },
  {
    baseName: "green",
    header: "rgb(132, 225, 188)",
    color: "rgb(222, 247, 236)"
  },
  {
    baseName: "azure",
    header: "rgb(126, 220, 226)",
    color: "rgb(213, 245, 246)"
  },
  {
    baseName: "indigo",
    header: "rgb(186, 198, 248)",
    color: "rgb(233, 237, 255)"
  },
  {
    baseName: "purple",
    header: "rgb(202, 191, 253)",
    color: "rgb(237, 235, 254)"
  },
  {
    baseName: "magenta",
    header: "rgb(248, 180, 217)",
    color: "rgb(252, 232, 243)"
  }
];
var middleConfig = [
  {
    baseName: "blue",
    rowHeader: "rgb(63, 131, 248)",
    colHeader: "rgb(195, 221, 253)"
  },
  {
    baseName: "grey",
    rowHeader: "rgb(95, 101, 116)",
    colHeader: "rgb(227, 229, 234)"
  },
  {
    baseName: "red",
    rowHeader: "rgb(240, 82, 82)",
    colHeader: "rgb(251, 213, 213)"
  },
  {
    baseName: "orange",
    rowHeader: "rgb(255, 90, 31)",
    colHeader: "rgb(252, 217, 189)"
  },
  {
    baseName: "yellow",
    rowHeader: "rgb(212, 157, 15)",
    colHeader: "rgb(252, 220, 106)"
  },
  {
    baseName: "green",
    rowHeader: "rgb(13, 164, 113)",
    colHeader: "rgb(188, 240, 218)"
  },
  {
    baseName: "azure",
    rowHeader: "rgb(6, 148, 162)",
    colHeader: "rgb(175, 236, 239)"
  },
  {
    baseName: "indigo",
    rowHeader: "rgb(70, 106, 247)",
    colHeader: "rgb(210, 218, 250)"
  },
  {
    baseName: "purple",
    rowHeader: "rgb(144, 97, 249)",
    colHeader: "rgb(220, 215, 254)"
  },
  {
    baseName: "magenta",
    rowHeader: "rgb(231, 70, 148)",
    colHeader: "rgb(250, 209, 232)"
  }
];
var darkConfig = [
  {
    baseName: "blue",
    rowHeader: "rgb(30, 66, 159)",
    firstRow: "rgb(195, 221, 253)",
    secondRow: "rgb(118, 169, 250)"
  },
  {
    baseName: "grey",
    rowHeader: "rgb(44, 48, 64)",
    firstRow: "rgb(227, 229, 234)",
    secondRow: "rgb(151, 157, 172)"
  },
  {
    baseName: "red",
    rowHeader: "rgb(155, 28, 28)",
    firstRow: "rgb(251, 213, 213)",
    secondRow: "rgb(249, 128, 128)"
  },
  {
    baseName: "orange",
    rowHeader: "rgb(180, 52, 3)",
    firstRow: "rgb(252, 217, 189)",
    secondRow: "rgb(255, 138, 76)"
  },
  {
    baseName: "yellow",
    rowHeader: "rgb(154, 109, 21)",
    firstRow: "rgb(252, 220, 106)",
    secondRow: "rgb(212, 157, 15)"
  },
  {
    baseName: "green",
    rowHeader: "rgb(4, 108, 78)",
    firstRow: "rgb(188, 240, 218)",
    secondRow: "rgb(49, 196, 141)"
  },
  {
    baseName: "azure",
    rowHeader: "rgb(3, 102, 114)",
    firstRow: "rgb(175, 236, 239)",
    secondRow: "rgb(22, 189, 202)"
  },
  {
    baseName: "indigo",
    rowHeader: "rgb(16, 51, 191)",
    firstRow: "rgb(210, 218, 250)",
    secondRow: "rgb(98, 128, 249)"
  },
  {
    baseName: "purple",
    rowHeader: "rgb(74, 29, 150)",
    firstRow: "rgb(220, 215, 254)",
    secondRow: "rgb(172, 148, 250)"
  },
  {
    baseName: "magenta",
    rowHeader: "rgb(153, 21, 75)",
    firstRow: "rgb(250, 209, 232)",
    secondRow: "rgb(241, 126, 184)"
  }
];
var lightThemes = lightConfig.map(({ baseName, header, color }) => {
  return lightRangeThemeBuilder(baseName, header, color);
});
var middleThemes = middleConfig.map(({ baseName, rowHeader, colHeader }) => {
  return middleRangeThemeBuilder(baseName, rowHeader, colHeader);
});
var darkThemes = darkConfig.map(({ baseName, rowHeader, firstRow, secondRow }) => {
  return darkRangeThemeBuilder(baseName, rowHeader, firstRow, secondRow);
});
var buildInThemes = [
  ...lightThemes,
  ...middleThemes,
  ...darkThemes
];

// ../packages/sheets/src/model/range-themes/default.ts
var defaultRangeThemeStyleJSON = {
  headerRowStyle: {
    bg: {
      rgb: "rgb(68,114,196)"
    },
    cl: {
      rgb: "rgb(255,255,255)"
    },
    ht: 2 /* CENTER */,
    bl: 1 /* TRUE */
  },
  firstRowStyle: {
    bg: {
      rgb: "rgb(217,225,242)"
    }
  }
};
var defaultRangeThemeStyle = new RangeThemeStyle("default", defaultRangeThemeStyleJSON);
var defaultRangeThemeStyleJSONWithLastRowStyle = new RangeThemeStyle("default-last-row", {
  ...defaultRangeThemeStyleJSON,
  lastRowStyle: {
    bd: {
      t: {
        s: 1 /* THIN */,
        cl: {
          rgb: "rgb(68,114,196)"
        }
      }
    },
    ht: 2 /* CENTER */,
    bl: 1 /* TRUE */
  }
});

// ../packages/sheets/src/model/range-theme-model.ts
var SHEET_RANGE_THEME_MODEL_PLUGIN = "SHEET_RANGE_THEME_MODEL_PLUGIN";
var SheetRangeThemeModel = class extends Disposable {
  constructor(_sheetInterceptorService, _resourceManagerService) {
    super();
    this._sheetInterceptorService = _sheetInterceptorService;
    this._resourceManagerService = _resourceManagerService;
    __publicField(this, "_rangeThemeStyleMap", /* @__PURE__ */ new Map());
    __publicField(this, "_rangeThemeStyleRuleMap", /* @__PURE__ */ new Map());
    __publicField(this, "_rTreeCollection", /* @__PURE__ */ new Map());
    __publicField(this, "_defaultRangeThemeMap", /* @__PURE__ */ new Map());
    this._registerIntercept();
    this._initSnapshot();
    this._initDefaultTheme();
  }
  _initDefaultTheme() {
    this.registerDefaultRangeTheme(defaultRangeThemeStyle);
    this.registerDefaultRangeTheme(defaultRangeThemeStyleJSONWithLastRowStyle);
    for (const theme of buildInThemes) {
      this.registerDefaultRangeTheme(theme);
    }
  }
  _ensureRangeThemeStyleMap(unitId) {
    if (!this._rangeThemeStyleMap.has(unitId)) {
      this._rangeThemeStyleMap.set(unitId, /* @__PURE__ */ new Map());
    }
    return this._rangeThemeStyleMap.get(unitId);
  }
  _ensureRangeThemeStyleRuleMap(unitId) {
    if (!this._rangeThemeStyleRuleMap.has(unitId)) {
      this._rangeThemeStyleRuleMap.set(unitId, /* @__PURE__ */ new Map());
    }
    return this._rangeThemeStyleRuleMap.get(unitId);
  }
  _ensureRTreeCollection(unitId) {
    if (!this._rTreeCollection.has(unitId)) {
      this._rTreeCollection.set(unitId, new RTree());
    }
    return this._rTreeCollection.get(unitId);
  }
  getDefaultRangeThemeStyle(name) {
    return this._defaultRangeThemeMap.get(name);
  }
  /**
   * Register range theme styles
   * @param {string} themeName
   * @param {IRangeThemeRangeInfo} rangeInfo
   */
  registerRangeThemeRule(themeName, rangeInfo) {
    const { unitId, subUnitId, range } = rangeInfo;
    const id = generateRandomId();
    const ruleMap = this._ensureRangeThemeStyleRuleMap(unitId);
    const rTreeCollection = this._ensureRTreeCollection(unitId);
    ruleMap.set(id, { rangeInfo, themeName });
    rTreeCollection.insert({ unitId, sheetId: subUnitId, range, id });
  }
  getRegisteredRangeThemeStyle(rangeInfo) {
    const { unitId, subUnitId, range } = rangeInfo;
    const rTreeCollection = this._ensureRTreeCollection(unitId);
    const themes = Array.from(rTreeCollection.bulkSearch([{ unitId, sheetId: subUnitId, range }]));
    if (themes[0]) {
      const themeRuleMap = this._ensureRangeThemeStyleRuleMap(unitId);
      const themeRule = themeRuleMap.get(themes[0]);
      if (themeRule) {
        return themeRule.themeName;
      }
    }
    return void 0;
  }
  removeRangeThemeRule(themeName, rangeInfo) {
    const { unitId, subUnitId, range } = rangeInfo;
    const rTreeCollection = this._ensureRTreeCollection(unitId);
    const themes = Array.from(rTreeCollection.bulkSearch([{ unitId, sheetId: subUnitId, range }]));
    if (themes[0]) {
      const themeRuleMap = this._ensureRangeThemeStyleRuleMap(unitId);
      const themeRule = themeRuleMap.get(themes[0]);
      if (themeRule && themeRule.themeName === themeName) {
        themeRuleMap.delete(themes[0]);
        rTreeCollection.remove({ unitId, sheetId: subUnitId, range, id: themes[0] });
      }
    }
  }
  registerDefaultRangeTheme(rangeThemeStyle) {
    this._defaultRangeThemeMap.set(rangeThemeStyle.getName(), rangeThemeStyle);
  }
  getRegisteredRangeThemes() {
    return Array.from(this._defaultRangeThemeMap.keys());
  }
  /**
   * Register custom range theme style.
   * @param {string} unitId The unit id.
   * @param {RangeThemeStyle} rangeThemeStyle The range theme style.
   */
  registerRangeThemeStyle(unitId, rangeThemeStyle) {
    this._ensureRangeThemeStyleMap(unitId).set(rangeThemeStyle.getName(), rangeThemeStyle);
  }
  /**
   *  Unregister custom range theme style.
   * @param {string} unitId The unit id.
   * @param {string} name The name of the range theme style.
   */
  unregisterRangeThemeStyle(unitId, name) {
    this._ensureRangeThemeStyleMap(unitId).delete(name);
  }
  /**
   * Gets all custom register themes
   * @return {string[]} The array of all custom registered themes.
   */
  getALLRegisteredTheme() {
    return Array.from(this._rangeThemeStyleMap.keys());
  }
  getRangeThemeStyle(unitId, name) {
    if (this._defaultRangeThemeMap.has(name)) {
      return this._defaultRangeThemeMap.get(name);
    }
    return this._ensureRangeThemeStyleMap(unitId).get(name);
  }
  getCellStyle(unitId, subUnitId, row, col) {
    const range = { startRow: row, startColumn: col, endRow: row, endColumn: col };
    const rTreeCollection = this._ensureRTreeCollection(unitId);
    const themes = Array.from(rTreeCollection.bulkSearch([{ unitId, sheetId: subUnitId, range }]));
    if (themes[0]) {
      const themeRuleMap = this._ensureRangeThemeStyleRuleMap(unitId);
      const themeRule = themeRuleMap.get(themes[0]);
      if (themeRule) {
        const { rangeInfo, themeName } = themeRule;
        const offsetRow = row - rangeInfo.range.startRow;
        const offsetCol = col - rangeInfo.range.startColumn;
        const theme = this.getRangeThemeStyle(unitId, themeName);
        return theme.getStyle(offsetRow, offsetCol, row === rangeInfo.range.endRow, col === rangeInfo.range.endColumn);
      }
    }
    return void 0;
  }
  _registerIntercept() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT, {
      id: RangeThemeInterceptorId,
      effect: 1 /* Style */,
      handler: (cell, context, next) => {
        const { row, col, unitId, subUnitId } = context;
        const style = this.getCellStyle(unitId, subUnitId, row, col);
        if (style) {
          const newCell = { ...cell };
          newCell.themeStyle = style;
          return next(newCell);
        }
        return next(cell);
      }
    }));
  }
  toJson(unitId) {
    const ruleMap = this._ensureRangeThemeStyleRuleMap(unitId);
    const rangeThemeStyleMap = this._ensureRangeThemeStyleMap(unitId);
    if (rangeThemeStyleMap.size === 0 && ruleMap.size === 0) {
      return "{}";
    }
    const rangeThemeStyleRuleMap = {};
    ruleMap.forEach((value, key) => {
      rangeThemeStyleRuleMap[key] = value;
    });
    const rangeThemeStyleMapJson = {};
    rangeThemeStyleMap.forEach((value, key) => {
      rangeThemeStyleMapJson[key] = value.toJson();
    });
    return JSON.stringify({
      rangeThemeStyleRuleMap,
      rangeThemeStyleMapJson
    });
  }
  fromJSON(unitId, json) {
    const { rangeThemeStyleRuleMap: rangeThemeStyleRuleMapJSON, rangeThemeStyleMapJson } = json;
    if (rangeThemeStyleRuleMapJSON) {
      Object.keys(rangeThemeStyleRuleMapJSON).forEach((key) => {
        const ruleMap = rangeThemeStyleRuleMapJSON[key];
        const { themeName, rangeInfo } = ruleMap;
        this.registerRangeThemeRule(themeName, rangeInfo);
        const rTreeCollection = this._ensureRTreeCollection(rangeInfo.unitId);
        rTreeCollection.insert({ unitId: key, sheetId: rangeInfo.subUnitId, range: rangeInfo.range, id: key });
      });
    }
    if (rangeThemeStyleMapJson) {
      Object.keys(rangeThemeStyleMapJson).forEach((key) => {
        const styleMap = rangeThemeStyleMapJson[key];
        const style = new RangeThemeStyle(styleMap.name);
        style.fromJson(styleMap);
        this._ensureRangeThemeStyleMap(unitId).set(style.getName(), style);
      });
    }
  }
  deleteUnitId(unitId) {
    this._rangeThemeStyleMap.delete(unitId);
    this._rangeThemeStyleRuleMap.delete(unitId);
    this._rTreeCollection.delete(unitId);
  }
  _initSnapshot() {
    this.disposeWithMe(this._resourceManagerService.registerPluginResource({
      toJson: (unitId) => {
        return this.toJson(unitId);
      },
      parseJson: (json) => {
        if (!json) {
          return {};
        }
        try {
          return JSON.parse(json);
        } catch (error) {
          return {};
        }
      },
      businesses: [O.UNIVER_SHEET],
      pluginName: SHEET_RANGE_THEME_MODEL_PLUGIN,
      onLoad: (unitId, resources) => {
        this.fromJSON(unitId, resources);
      },
      onUnLoad: (unitId) => {
        this.deleteUnitId(unitId);
      }
    }));
  }
  dispose() {
    super.dispose();
    this._rangeThemeStyleMap.clear();
    this._rangeThemeStyleRuleMap.clear();
    this._defaultRangeThemeMap.clear();
    this._rTreeCollection.clear();
  }
};
SheetRangeThemeModel = __decorateClass([
  __decorateParam(0, Inject(SheetInterceptorService)),
  __decorateParam(1, Inject(IResourceManagerService))
], SheetRangeThemeModel);

// ../packages/sheets/src/commands/commands/utils/target-util.ts
function getSheetCommandTargetWorkbook(univerInstanceService, params) {
  const { unitId } = params;
  const workbook = unitId ? univerInstanceService.getUniverSheetInstance(unitId) : univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  if (!workbook) return null;
  return {
    workbook,
    unitId: workbook.getUnitId()
  };
}
function getSheetCommandTarget(univerInstanceService, params = {}) {
  const { unitId, subUnitId } = params;
  const workbook = unitId ? univerInstanceService.getUniverSheetInstance(unitId) : univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  if (!workbook) return null;
  const worksheet = subUnitId ? workbook.getSheetBySheetId(subUnitId) : workbook.getActiveSheet(true);
  if (!worksheet) {
    return null;
  }
  return {
    worksheet,
    workbook,
    unitId: workbook.getUnitId(),
    subUnitId: worksheet.getSheetId()
  };
}
function getSheetMutationTarget(univerInstanceService, params) {
  const { unitId, subUnitId } = params;
  const workbook = univerInstanceService.getUniverSheetInstance(unitId);
  if (!workbook) return null;
  const worksheet = workbook.getSheetBySheetId(subUnitId);
  if (!worksheet) {
    return null;
  }
  return {
    worksheet,
    workbook
  };
}

// ../packages/sheets/src/commands/mutations/add-worksheet-range-theme.mutation.ts
var SetWorksheetRangeThemeStyleMutation = {
  id: "sheet.mutation.set-worksheet-range-theme-style",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, range, themeName } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    const sheetRangeThemeModel = accessor.get(SheetRangeThemeModel);
    if (!target) return false;
    sheetRangeThemeModel.registerRangeThemeRule(themeName, { range, unitId, subUnitId });
    return true;
  }
};
var SetWorksheetRangeThemeStyleMutationFactory = (accessor, params) => {
  const target = getSheetMutationTarget(accessor.get(IUniverInstanceService), params);
  if (!target) {
    throw new Error("[SetWorksheetRangeThemeStyleMutation]: worksheet is null error!");
  }
  const { worksheet } = target;
  return {
    unitId: params.unitId,
    subUnitId: worksheet.getSheetId(),
    range: params.range,
    themeName: params.themeName
  };
};

// ../packages/sheets/src/commands/mutations/delete-worksheet-range-theme.mutation.ts
var DeleteWorksheetRangeThemeStyleMutation = {
  id: "sheet.mutation.remove-worksheet-range-theme-style",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, range, themeName } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    const sheetRangeThemeModel = accessor.get(SheetRangeThemeModel);
    if (!target) return false;
    sheetRangeThemeModel.removeRangeThemeRule(themeName, { range, unitId, subUnitId });
    return true;
  }
};
var DeleteWorksheetRangeThemeStyleMutationFactory = (accessor, params) => {
  const target = getSheetMutationTarget(accessor.get(IUniverInstanceService), params);
  if (!target) {
    throw new Error("[DeleteWorksheetRangeThemeStyleMutationFactory]: worksheet is null error!");
  }
  const { worksheet } = target;
  return {
    unitId: params.unitId,
    subUnitId: worksheet.getSheetId(),
    range: params.range,
    themeName: params.themeName
  };
};

// ../packages/sheets/src/commands/commands/add-worksheet-range-theme.command.ts
var SetWorksheetRangeThemeStyleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-range-theme-style",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { unitId } = params;
    const undoMutationParams = SetWorksheetRangeThemeStyleMutationFactory(accessor, params);
    const result = commandService.syncExecuteCommand(SetWorksheetRangeThemeStyleMutation.id, params);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: DeleteWorksheetRangeThemeStyleMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetWorksheetRangeThemeStyleMutation.id, params }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/insert-row-col.mutation.ts
var InsertRowMutationUndoFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    range: params.range
  };
};
var InsertRowMutation = {
  id: "sheet.mutation.insert-row",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    var _a2;
    const { unitId, subUnitId, range, rowInfo } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    const rowWrapper = worksheet.getRowManager().getRowData();
    const defaultRowInfo = {
      h: worksheet.getConfig().defaultRowHeight,
      hd: 0
    };
    const rowIndex = range.startRow;
    const rowCount = range.endRow - range.startRow + 1;
    for (let j = rowIndex; j < rowIndex + rowCount; j++) {
      if (rowInfo) {
        insertMatrixArray(j, (_a2 = rowInfo[j - range.startRow]) != null ? _a2 : defaultRowInfo, rowWrapper);
      } else {
        insertMatrixArray(j, defaultRowInfo, rowWrapper);
      }
    }
    worksheet.setRowCount(worksheet.getRowCount() + range.endRow - range.startRow + 1);
    const cellMatrix = worksheet.getCellMatrix();
    cellMatrix.insertRows(range.startRow, rowCount);
    return true;
  }
};
var InsertColMutationUndoFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    range: params.range
  };
};
var InsertColMutation = {
  id: "sheet.mutation.insert-col",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    var _a2;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    const manager = worksheet.getColumnManager();
    const { range, colInfo } = params;
    const columnPrimitive = manager.getColumnData();
    const columnWrapper = columnPrimitive;
    const colIndex = range.startColumn;
    const colCount = range.endColumn - range.startColumn + 1;
    const defaultColWidth = worksheet.getConfig().defaultColumnWidth;
    for (let j = colIndex; j < colIndex + colCount; j++) {
      const defaultColInfo = {
        w: defaultColWidth,
        hd: 0
      };
      if (colInfo) {
        insertMatrixArray(j, (_a2 = colInfo[j - range.startColumn]) != null ? _a2 : defaultColInfo, columnWrapper);
      } else {
        insertMatrixArray(j, defaultColInfo, columnWrapper);
      }
    }
    worksheet.setColumnCount(worksheet.getColumnCount() + range.endColumn - range.startColumn + 1);
    const cellMatrix = worksheet.getCellMatrix();
    cellMatrix.insertColumns(range.startColumn, colCount);
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/remove-row-col.mutation.ts
var RemoveRowsUndoMutationFactory = (params, worksheet) => {
  const manager = worksheet.getRowManager();
  const rowPrimitive = manager.getRowData();
  const rowWrapper = rowPrimitive;
  const rowInfo = {};
  const range = params.range;
  const slice = sliceMatrixArray(range.startRow, range.endRow, rowWrapper);
  const _rowInfo = concatMatrixArray(rowInfo, slice);
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    range: params.range,
    rowInfo: _rowInfo
  };
};
var RemoveRowMutation = {
  id: "sheet.mutation.remove-rows",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    const range = params.range;
    const manager = worksheet.getRowManager();
    const rowPrimitive = manager.getRowData();
    const filterOutRows = [];
    for (let i = range.startRow; i <= range.endRow; i++) {
      if (worksheet.getRowFiltered(i)) {
        filterOutRows.push(i);
      }
    }
    const rowCount = range.endRow - range.startRow + 1;
    spliceArray(range.startRow, rowCount, rowPrimitive);
    const cellMatrix = worksheet.getCellMatrix();
    cellMatrix.removeRows(range.startRow, rowCount);
    worksheet.setRowCount(worksheet.getRowCount() - rowCount);
    return true;
  }
};
var RemoveColMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  const worksheet = universheet.getSheetBySheetId(params.subUnitId);
  if (worksheet == null) {
    throw new Error("worksheet is null error!");
  }
  const manager = worksheet.getColumnManager();
  const columnPrimitive = manager.getColumnData();
  const columnWrapper = columnPrimitive;
  const colInfo = {};
  const range = params.range;
  const slice = sliceMatrixArray(range.startColumn, range.endColumn, columnWrapper);
  const _colInfo = concatMatrixArray(colInfo, slice);
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    range: params.range,
    colInfo: _colInfo
  };
};
var RemoveColMutation = {
  id: "sheet.mutation.remove-col",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    const range = params.range;
    const manager = worksheet.getColumnManager();
    const colPrimitive = manager.getColumnData();
    const colCount = range.endColumn - range.startColumn + 1;
    spliceArray(range.startColumn, colCount, colPrimitive);
    worksheet.setColumnCount(worksheet.getColumnCount() - colCount);
    const cellMatrix = worksheet.getCellMatrix();
    cellMatrix.removeColumns(range.startColumn, colCount);
    return true;
  }
};

// ../packages/sheets/src/basics/cell-style.ts
function handleStyle(styles, oldVal, newVal) {
  var _a2;
  const oldStyle = styles.getStyleByCell(oldVal);
  if (oldStyle == null) {
    delete oldVal.s;
  }
  if (typeof newVal.s === "string") {
    newVal.s = styles.get(newVal.s);
  }
  const merge5 = mergeStyle(oldStyle, newVal.s ? newVal.s : null);
  if (merge5) {
    Tools.removeNull(merge5);
    Object.entries(merge5).forEach(([key, val]) => {
      if (typeof val === "object" && val !== null && Object.keys(val).length === 0) {
        delete merge5[key];
      }
    });
  }
  if (Tools.isEmptyObject(merge5)) {
    delete oldVal.s;
  } else {
    oldVal.s = styles.setValue(merge5);
  }
  const newValueStream = newVal.v ? `${newVal.v}\r
` : "";
  if (!newVal.p && oldVal.p) {
    if (newValueStream && newValueStream !== ((_a2 = oldVal.p.body) == null ? void 0 : _a2.dataStream)) {
      delete oldVal.p;
    } else {
      mergeRichTextStyle(oldVal.p, newVal.s ? newVal.s : null);
    }
  }
}
function transformStyle(oldStyle, newStyle) {
  if (!newStyle || !Object.keys(newStyle).length) {
    return oldStyle;
  }
  const backupStyle = oldStyle || {};
  for (const k in newStyle) {
    if (k === "bd") {
      backupStyle[k] = transformBorders(backupStyle[k] || {}, newStyle[k]);
    } else if (!(k in backupStyle)) {
      backupStyle[k] = null;
    }
  }
  return backupStyle;
}
function transformBorders(oldBorders, newBorders) {
  if (!newBorders || !Object.keys(newBorders).length) {
    return oldBorders;
  }
  for (const k in newBorders) {
    if (!(k in oldBorders)) {
      oldBorders[k] = null;
    }
  }
  return oldBorders;
}
function mergeStyle(oldStyle, newStyle, isRichText = false) {
  if (newStyle === null) return newStyle;
  if (newStyle === void 0) return oldStyle;
  const backupStyle = Tools.deepClone(oldStyle) || {};
  for (const k in newStyle) {
    if (isRichText && ["bd", "tr", "td", "ht", "vt", "tb", "pd", "bg"].includes(k)) {
      continue;
    }
    if (k in backupStyle && k === "bd") {
      backupStyle[k] = Object.assign(backupStyle[k], newStyle[k]);
    } else {
      backupStyle[k] = newStyle[k];
    }
  }
  if ("cl" in backupStyle) {
    if ("ul" in backupStyle && backupStyle.ul) {
      backupStyle.ul.cl = backupStyle.cl;
    }
    if ("ol" in backupStyle && backupStyle.ol) {
      backupStyle.ol.cl = backupStyle.cl;
    }
    if ("st" in backupStyle && backupStyle.st) {
      backupStyle.st.cl = backupStyle.cl;
    }
  }
  return backupStyle;
}
function skipParagraphs(paragraphs, offset) {
  if (paragraphs.some((p) => p.startIndex === offset)) {
    return skipParagraphs(paragraphs, offset + 1);
  }
  return offset;
}
function mergeRichTextStyle(p, newStyle) {
  var _a2;
  if (p.body == null) {
    return;
  }
  if (!Array.isArray(p.body.textRuns)) {
    p.body.textRuns = [];
  }
  let index = 0;
  const newTextRuns = [];
  const paragraphs = ((_a2 = p.body) == null ? void 0 : _a2.paragraphs) || [];
  for (const textRun of p.body.textRuns) {
    const { st, ed, ts = {} } = textRun;
    if (index < st) {
      const tr = {
        st: index,
        ed: st
      };
      const merge6 = mergeStyle({}, newStyle, true);
      merge6 && Tools.removeNull(merge6);
      if (!Tools.isEmptyObject(merge6)) {
        tr.ts = merge6;
      }
      newTextRuns.push(tr);
    }
    const merge5 = mergeStyle(ts, newStyle, true);
    merge5 && Tools.removeNull(merge5);
    if (Tools.isEmptyObject(merge5)) {
      delete textRun.ts;
    } else {
      textRun.ts = merge5;
    }
    newTextRuns.push(textRun);
    index = skipParagraphs(paragraphs, ed);
  }
  const endIndex = p.body.dataStream.endsWith("\r\n") ? p.body.dataStream.length - 2 : p.body.dataStream.length;
  if (index < endIndex) {
    const tr = {
      st: index,
      ed: endIndex
    };
    const merge5 = mergeStyle({}, newStyle, true);
    merge5 && Tools.removeNull(merge5);
    if (!Tools.isEmptyObject(merge5)) {
      tr.ts = merge5;
    }
    newTextRuns.push(tr);
  }
  p.body.textRuns = normalizeTextRuns(newTextRuns);
}

// ../packages/sheets/src/basics/cell-type.ts
function getCellType(styles, newVal, oldVal) {
  var _a2, _b2, _c;
  if (newVal.t) return newVal.t;
  if (newVal.v === null) return null;
  const newStyle = styles.getStyleByCell(newVal);
  const oldStyle = styles.getStyleByCell(oldVal);
  if (oldVal.t === 4 /* FORCE_STRING */) {
    if (!isTextFormat((_a2 = oldStyle == null ? void 0 : oldStyle.n) == null ? void 0 : _a2.pattern) && newVal.v !== void 0) {
      if (isRealNum(newVal.v)) {
        return 2 /* NUMBER */;
      } else if (isBooleanString(`${newVal.v}`)) {
        return 3 /* BOOLEAN */;
      }
    }
    return 4 /* FORCE_STRING */;
  }
  if (hasNumberFormat(newStyle)) {
    if (isTextFormat((_b2 = newStyle == null ? void 0 : newStyle.n) == null ? void 0 : _b2.pattern)) {
      return 1 /* STRING */;
    }
    return checkCellValueTypeByValue(newVal, oldVal);
  }
  if (isTextFormat((_c = oldStyle == null ? void 0 : oldStyle.n) == null ? void 0 : _c.pattern)) {
    return 1 /* STRING */;
  }
  return checkCellValueTypeByValue(newVal, oldVal);
}
function checkCellValueTypeByValue(newVal, oldVal) {
  return newVal.v !== void 0 ? checkCellValueType(newVal.v, newVal.t) : checkCellValueType(oldVal.v, oldVal.t);
}
function hasNumberFormat(style) {
  var _a2;
  return !!((_a2 = style == null ? void 0 : style.n) == null ? void 0 : _a2.pattern);
}
function checkCellValueType(v, type2) {
  if (v === null) return null;
  if (typeof v === "string") {
    if (isRealNum(v)) {
      if ((+v === 0 || +v === 1) && type2 === 3 /* BOOLEAN */) {
        return 3 /* BOOLEAN */;
      }
      return 2 /* NUMBER */;
    } else if (isBooleanString(v)) {
      return 3 /* BOOLEAN */;
    }
    return 1 /* STRING */;
  }
  if (typeof v === "number") {
    if ((v === 0 || v === 1) && type2 === 3 /* BOOLEAN */) {
      return 3 /* BOOLEAN */;
    }
    return 2 /* NUMBER */;
  }
  if (typeof v === "boolean") {
    return 3 /* BOOLEAN */;
  }
  return 4 /* FORCE_STRING */;
}

// ../packages/sheets/src/basics/cell-value.ts
function getCellValue2(type2, cell) {
  if (type2 === 2 /* NUMBER */) {
    return Number(cell.v);
  }
  if (type2 === 3 /* BOOLEAN */) {
    return extractBooleanValue(cell.v) ? 1 : 0;
  }
  if (type2 === 1 /* STRING */ || type2 === 4 /* FORCE_STRING */) {
    return `${cell.v}`;
  }
  return cell.v;
}
function extractBooleanValue(value) {
  if (typeof value === "string") {
    if (value.toUpperCase() === "TRUE") {
      return true;
    }
    ;
    if (value.toUpperCase() === "FALSE") {
      return false;
    }
    if (isSafeNumeric(value)) {
      if (Number(value) === 0) {
        return false;
      }
      if (Number(value) === 1) {
        return true;
      }
    }
  }
  if (typeof value === "number") {
    if (value === 0) {
      return false;
    }
    if (value === 1) {
      return true;
    }
  }
  if (typeof value === "boolean") {
    return value;
  }
  return null;
}
function setNull(value) {
  if (value == null) return null;
  if (value.f === void 0) {
    value.f = null;
  }
  if (value.si === void 0) {
    value.si = null;
  }
  if (value.p === void 0) {
    value.p = null;
  }
  if (value.v === void 0) {
    value.v = null;
  }
  if (value.t === void 0) {
    value.t = null;
  }
  if (value.s === void 0) {
    value.s = null;
  }
  if (value.custom === void 0) {
    value.custom = null;
  }
  return value;
}

// ../packages/sheets/src/commands/mutations/set-range-values.mutation.ts
var SetRangeValuesUndoMutationFactory = (accessor, params) => {
  const { unitId, subUnitId, cellValue } = params;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const workbook = univerInstanceService.getUniverSheetInstance(unitId);
  if (workbook == null) {
    throw new Error("workbook is null error!");
  }
  const worksheet = workbook.getSheetBySheetId(subUnitId);
  if (worksheet == null) {
    throw new Error("worksheet is null error!");
  }
  const cellMatrix = worksheet.getCellMatrix();
  const styles = workbook.getStyles();
  const undoData = new ObjectMatrix();
  const newValues = new ObjectMatrix(cellValue);
  newValues.forValue((row, col, newVal) => {
    const cell = Tools.deepClone(cellMatrix == null ? void 0 : cellMatrix.getValue(row, col)) || {};
    const oldStyle = styles.getStyleByCell(cell);
    const newStyle = styles.getStyleByCell(newVal);
    cell.s = transformStyle(oldStyle, newStyle);
    undoData.setValue(row, col, setNull(cell));
  });
  return {
    ...params,
    options: {},
    cellValue: undoData.getMatrix()
  };
};
var SetRangeValuesMutation = {
  id: "sheet.mutation.set-range-values",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { cellValue, subUnitId, unitId } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getUnit(unitId);
    if (!workbook) {
      return false;
    }
    const worksheet = workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return false;
    }
    const cellMatrix = worksheet.getCellMatrix();
    const styles = workbook.getStyles();
    const newValues = new ObjectMatrix(cellValue);
    newValues.forValue((row, col, newVal) => {
      if (!newVal) {
        cellMatrix == null ? void 0 : cellMatrix.setValue(row, col, {});
      } else {
        const oldVal = cellMatrix.getValue(row, col) || {};
        const type2 = getCellType(styles, newVal, oldVal);
        if (newVal.f !== void 0) {
          oldVal.f = newVal.f;
        }
        if (newVal.si !== void 0) {
          oldVal.si = newVal.si;
        }
        if (newVal.p !== void 0) {
          oldVal.p = newVal.p;
        }
        if (newVal.v !== void 0) {
          oldVal.v = getCellValue2(type2, newVal);
        }
        if (oldVal.v !== void 0) {
          oldVal.t = type2;
          oldVal.v = getCellValue2(type2, oldVal);
        }
        if (newVal.s !== void 0) {
          handleStyle(styles, oldVal, newVal);
        }
        if (newVal.custom !== void 0) {
          oldVal.custom = newVal.custom;
        }
        cellMatrix.setValue(row, col, Tools.removeNull(oldVal));
      }
    });
    return true;
  }
};

// ../packages/sheets/src/commands/commands/append-row.command.ts
var AppendRowCommandId = "sheet.command.append-row";
var AppendRowCommand = {
  type: 0 /* COMMAND */,
  id: AppendRowCommandId,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { unitId, subUnitId, cellValue, insertRowNums, insertColumnNums, maxRows, maxColumns } = params;
    const setRangeValuesMutationRedoParams = {
      unitId,
      subUnitId,
      cellValue
    };
    const setRangeValuesMutationUndoParams = SetRangeValuesUndoMutationFactory(
      accessor,
      setRangeValuesMutationRedoParams
    );
    const redoMutations = [{ id: SetRangeValuesMutation.id, params: setRangeValuesMutationRedoParams }];
    const undoMutations = [{ id: SetRangeValuesMutation.id, params: setRangeValuesMutationUndoParams }];
    if (insertRowNums) {
      const insertRowRedoParams = {
        unitId,
        subUnitId,
        range: {
          startRow: maxRows,
          endRow: maxRows,
          startColumn: 0,
          endColumn: maxColumns - 1
        }
      };
      const insertRowUndoParams = InsertRowMutationUndoFactory(
        accessor,
        insertRowRedoParams
      );
      redoMutations.unshift({ id: InsertRowMutation.id, params: insertRowRedoParams });
      undoMutations.push({ id: RemoveRowMutation.id, params: insertRowUndoParams });
    }
    if (insertColumnNums) {
      const insertColRedoParams = {
        unitId,
        subUnitId,
        range: {
          startRow: 0,
          endRow: maxRows - 1,
          startColumn: maxColumns,
          endColumn: maxColumns - 1 + insertColumnNums
        }
      };
      const insertColUndoParams = InsertColMutationUndoFactory(
        accessor,
        insertColRedoParams
      );
      redoMutations.unshift({ id: InsertColMutation.id, params: insertColRedoParams });
      undoMutations.push({ id: RemoveColMutation.id, params: insertColUndoParams });
    }
    const result = sequenceExecute(redoMutations, commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations,
        redoMutations
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/basics/utils.ts
function generateNullCell(range) {
  const cellValue = new ObjectMatrix();
  range.forEach((range2) => {
    const { startRow, startColumn, endRow, endColumn } = range2;
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        cellValue.setValue(i, j, null);
      }
    }
  });
  return cellValue.clone();
}
function generateNullCellValue(range) {
  const cellValue = new ObjectMatrix();
  range.forEach((range2) => {
    const { startRow, startColumn, endRow, endColumn } = range2;
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        cellValue.setValue(i, j, {
          v: null,
          p: null,
          f: null,
          si: null,
          custom: null
        });
      }
    }
  });
  return cellValue.clone();
}
function generateNullCellStyle(ranges) {
  const cellValue = new ObjectMatrix();
  ranges.forEach((range) => {
    const { startRow, startColumn, endRow, endColumn } = range;
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        cellValue.setValue(i, j, {
          s: null
        });
      }
    }
  });
  return cellValue.clone();
}
function rangeToDiscreteRange(range, accessor, unitId, subUnitId, considerHide) {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const workbook = unitId ? univerInstanceService.getUnit(unitId, O.UNIVER_SHEET) : univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
  const worksheet = subUnitId ? workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId) : workbook == null ? void 0 : workbook.getActiveSheet();
  if (!worksheet) {
    return null;
  }
  const { startRow, endRow, startColumn, endColumn } = range;
  const rows = [];
  const cols = [];
  for (let r = startRow; r <= endRow; r++) {
    if (!worksheet.getRowFiltered(r)) {
      if (considerHide) {
        if (worksheet.getRowRawVisible(r)) {
          rows.push(r);
        }
      } else {
        rows.push(r);
      }
    }
  }
  for (let c = startColumn; c <= endColumn; c++) {
    if (considerHide) {
      if (worksheet.getColVisible(c)) {
        cols.push(c);
      }
    } else {
      cols.push(c);
    }
  }
  return {
    rows,
    cols
  };
}
function getVisibleRanges(ranges, accessor, unitId, subUnitId) {
  const allRows = [];
  const allCols = [];
  for (const range of ranges) {
    const discreteRange = rangeToDiscreteRange(range, accessor, unitId, subUnitId, true);
    if (discreteRange) {
      allRows.push(...discreteRange.rows);
      allCols.push(...discreteRange.cols);
    }
  }
  const uniqueRows = Array.from(new Set(allRows)).sort((a2, b) => a2 - b);
  const uniqueCols = Array.from(new Set(allCols)).sort((a2, b) => a2 - b);
  const visibleRanges = [];
  function findContinuousSegments(arr) {
    const segments = [];
    let start = arr[0];
    for (let i = 1; i < arr.length; i++) {
      if (arr[i] !== arr[i - 1] + 1) {
        segments.push([start, arr[i - 1]]);
        start = arr[i];
      }
    }
    segments.push([start, arr[arr.length - 1]]);
    return segments;
  }
  const rowSegments = findContinuousSegments(uniqueRows);
  const colSegments = findContinuousSegments(uniqueCols);
  for (const [startRow, endRow] of rowSegments) {
    for (const [startCol, endCol] of colSegments) {
      visibleRanges.push({
        startRow,
        endRow,
        startColumn: startCol,
        endColumn: endCol
      });
    }
  }
  return visibleRanges;
}

// ../packages/sheets/src/services/selections/selection.service.ts
var import_rxjs32 = __toESM(require_cjs());

// ../packages/sheets/src/services/selections/selection-data-model.ts
var import_rxjs31 = __toESM(require_cjs());
var WorkbookSelectionModel = class extends Disposable {
  constructor(_workbook) {
    super();
    this._workbook = _workbook;
    /**
     * Selection data model for each worksheet.
     */
    __publicField(this, "_worksheetSelections", /* @__PURE__ */ new Map());
    __publicField(this, "_selectionMoveStart$", new import_rxjs31.Subject());
    __publicField(this, "selectionMoveStart$", this._selectionMoveStart$.asObservable());
    __publicField(this, "_selectionMoving$", new import_rxjs31.Subject());
    __publicField(this, "selectionMoving$", this._selectionMoving$.asObservable());
    __publicField(this, "_selectionMoveEnd$", new import_rxjs31.BehaviorSubject([]));
    __publicField(this, "selectionMoveEnd$", this._selectionMoveEnd$.asObservable());
    __publicField(this, "_selectionSet$", new import_rxjs31.BehaviorSubject([]));
    __publicField(this, "selectionSet$", this._selectionSet$.asObservable());
    __publicField(this, "selectionChanged$");
    __publicField(this, "_beforeSelectionMoveEnd$", new import_rxjs31.BehaviorSubject([]));
    __publicField(this, "beforeSelectionMoveEnd$", this._beforeSelectionMoveEnd$.asObservable());
    this.selectionChanged$ = (0, import_rxjs31.merge)(this._selectionMoveEnd$, this._selectionSet$);
  }
  dispose() {
    super.dispose();
    this._beforeSelectionMoveEnd$.complete();
    this._selectionMoveEnd$.complete();
    this._selectionMoving$.complete();
    this._selectionMoveStart$.complete();
    this._selectionSet$.complete();
  }
  addSelections(sheetId, selectionDatas) {
    const selections = this.getSelectionsOfWorksheet(sheetId);
    selections.push(...selectionDatas);
    this._selectionSet$.next(selections);
  }
  /**
   * Set selectionDatas to _worksheetSelections, and emit selectionDatas by type.
   * @param sheetId
   * @param selectionDatas
   * @param type
   */
  setSelections(sheetId, selectionDatas = [], type2) {
    this.setSelectionsOfWorksheet(sheetId, selectionDatas);
    switch (type2) {
      case 0 /* MOVE_START */:
        this._selectionMoveStart$.next(selectionDatas);
        break;
      case 1 /* MOVING */:
        this._selectionMoving$.next(selectionDatas);
        break;
      case 2 /* MOVE_END */:
        this._beforeSelectionMoveEnd$.next(selectionDatas);
        this._selectionMoveEnd$.next(selectionDatas);
        break;
      case 3 /* ONLY_SET */: {
        this._selectionSet$.next(selectionDatas);
        break;
      }
      default:
        this._selectionSet$.next(selectionDatas);
        break;
    }
  }
  getCurrentSelections() {
    return this._getCurrentSelections();
  }
  /**
   * @deprecated use `getSelectionsOfWorksheet` instead.
   * @param sheetId
   * @returns
   */
  getSelectionOfWorksheet(sheetId) {
    return this.getSelectionsOfWorksheet(sheetId);
  }
  getSelectionsOfWorksheet(sheetId) {
    if (!this._worksheetSelections.has(sheetId)) {
      this._worksheetSelections.set(sheetId, []);
    }
    return this._worksheetSelections.get(sheetId);
  }
  setSelectionsOfWorksheet(sheetId, selections) {
    this._worksheetSelections.set(sheetId, [...selections]);
  }
  deleteSheetSelection(sheetId) {
    this._worksheetSelections.set(sheetId, []);
  }
  /** Clear all selections in this workbook. */
  clear() {
    this._worksheetSelections.clear();
    this._selectionSet$.next([]);
  }
  _getCurrentSelections() {
    return this.getSelectionsOfWorksheet(this._workbook.getActiveSheet().getSheetId());
  }
  getCurrentLastSelection() {
    const selectionData = this._getCurrentSelections();
    return selectionData[selectionData.length - 1];
  }
};

// ../packages/sheets/src/services/selections/selection.service.ts
var SheetsSelectionsService = class extends RxDisposable {
  constructor(_instanceSrv) {
    super();
    this._instanceSrv = _instanceSrv;
    /**
     * Selection Events, usually triggered when pointerdown in spreadsheet by selection render service after selectionModel has updated.
     */
    __publicField(this, "selectionMoveStart$");
    /**
     * Selection Events, usually triggered when pointermove in spreadsheet by selection render service after selectionModel has updated.
     */
    __publicField(this, "selectionMoving$");
    /**
     * Selection Events, usually triggered when pointerup in spreadsheet by selection render service after selectionModel has updated.
     */
    __publicField(this, "selectionMoveEnd$");
    /**
     * Selection Events, usually triggered when changing unit.(focus in formula editor)
     */
    __publicField(this, "selectionSet$");
    /**
     * Selection Events, merge moveEnd$ and selectionSet$
     */
    __publicField(this, "selectionChanged$");
    __publicField(this, "_workbookSelections", /* @__PURE__ */ new Map());
    this._init();
  }
  get _currentSelectionPos() {
    const workbook = this._instanceSrv.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return null;
    const worksheet = workbook.getActiveSheet();
    return { unitId: workbook.getUnitId(), sheetId: worksheet.getSheetId() };
  }
  get currentSelectionParam() {
    return this._currentSelectionPos;
  }
  _init() {
    const c$ = this._instanceSrv.getCurrentTypeOfUnit$(O.UNIVER_SHEET).pipe((0, import_rxjs32.shareReplay)(1), (0, import_rxjs32.takeUntil)(this.dispose$));
    this.selectionMoveStart$ = c$.pipe((0, import_rxjs32.switchMap)((workbook) => !workbook ? (0, import_rxjs32.of)() : this._ensureWorkbookSelection(workbook.getUnitId()).selectionMoveStart$));
    this.selectionMoving$ = c$.pipe((0, import_rxjs32.switchMap)((workbook) => !workbook ? (0, import_rxjs32.of)() : this._ensureWorkbookSelection(workbook.getUnitId()).selectionMoving$));
    this.selectionMoveEnd$ = c$.pipe((0, import_rxjs32.switchMap)((workbook) => !workbook ? (0, import_rxjs32.of)([]) : this._ensureWorkbookSelection(workbook.getUnitId()).selectionMoveEnd$));
    this.selectionSet$ = c$.pipe((0, import_rxjs32.switchMap)((workbook) => !workbook ? (0, import_rxjs32.of)([]) : this._ensureWorkbookSelection(workbook.getUnitId()).selectionSet$));
    this.selectionChanged$ = c$.pipe((0, import_rxjs32.switchMap)((workbook) => !workbook ? (0, import_rxjs32.of)([]) : this._ensureWorkbookSelection(workbook.getUnitId()).selectionChanged$)).pipe(
      (0, import_rxjs32.distinctUntilChanged)((prev, curr) => {
        if (prev.length !== curr.length) return false;
        if (prev.length === 0 && curr.length === 0) return true;
        return prev.every((item, index) => {
          return JSON.stringify(item) === JSON.stringify(curr[index]);
        });
      }),
      (0, import_rxjs32.skip)(1)
    );
    this._instanceSrv.getTypeOfUnitDisposed$(O.UNIVER_SHEET).pipe((0, import_rxjs32.takeUntil)(this.dispose$)).subscribe((workbook) => {
      this._removeWorkbookSelection(workbook.getUnitId());
    });
  }
  /**
   * Clear all selections in all workbooks.
   * invoked by prompt.controller
   */
  clear() {
    this._workbookSelections.forEach((wbSelection) => wbSelection.clear());
  }
  getCurrentSelections() {
    return this._getCurrentSelections();
  }
  getCurrentLastSelection() {
    const selectionData = this._getCurrentSelections();
    return selectionData == null ? void 0 : selectionData[selectionData.length - 1];
  }
  addSelections(unitIdOrSelections, worksheetId, selectionDatas) {
    if (typeof unitIdOrSelections === "string") {
      this._ensureWorkbookSelection(unitIdOrSelections).addSelections(worksheetId, selectionDatas);
      return;
    }
    const current = this._currentSelectionPos;
    if (!current) {
      throw new Error("[SheetsSelectionsService]: cannot find current selection position!");
    }
    const { unitId, sheetId } = current;
    this._ensureWorkbookSelection(unitId).addSelections(sheetId, unitIdOrSelections);
  }
  setSelections(unitIdOrSelections, worksheetIdOrType, selectionDatas, type2) {
    if (typeof unitIdOrSelections === "string" && typeof worksheetIdOrType === "string") {
      const unitId2 = unitIdOrSelections;
      this._ensureWorkbookSelection(unitId2).setSelections(
        worksheetIdOrType,
        selectionDatas || [],
        type2 != null ? type2 : 3 /* ONLY_SET */
      );
      return;
    }
    const current = this._currentSelectionPos;
    if (!current) {
      throw new Error("[SheetsSelectionsService]: cannot find current selection position!");
    }
    const { unitId, sheetId } = current;
    if (typeof unitIdOrSelections === "object") {
      const selectionData = unitIdOrSelections != null ? unitIdOrSelections : selectionDatas;
      const type3 = worksheetIdOrType != null ? worksheetIdOrType : 3 /* ONLY_SET */;
      this._ensureWorkbookSelection(unitId).setSelections(sheetId, selectionData, type3);
    }
  }
  clearCurrentSelections() {
    const selectionData = this._getCurrentSelections();
    selectionData.splice(0);
  }
  /**
   * Determine whether multiple current selections overlap
   *
   * @deprecated this should be extracted to an pure function
   */
  isOverlapping() {
    const selectionDataList = this.getCurrentSelections();
    if (selectionDataList == null) {
      return false;
    }
    return selectionDataList.some(
      ({ range }, index) => selectionDataList.some(({ range: range2 }, index2) => {
        if (index === index2) {
          return false;
        }
        return range.startRow <= range2.endRow && range.endRow >= range2.startRow && range.startColumn <= range2.endColumn && range.endColumn >= range2.startColumn;
      })
    );
  }
  _getCurrentSelections() {
    const current = this._currentSelectionPos;
    if (!current) {
      return [];
    }
    const { unitId, sheetId } = current;
    return this._ensureWorkbookSelection(unitId).getSelectionsOfWorksheet(sheetId);
  }
  getWorkbookSelections(unitId) {
    return this._ensureWorkbookSelection(unitId);
  }
  _ensureWorkbookSelection(unitId) {
    let wbSelection = this._workbookSelections.get(unitId);
    if (!wbSelection) {
      const workbook = this._instanceSrv.getUnit(unitId);
      if (!workbook) {
        throw new Error(`[SheetsSelectionsService]: cannot resolve unit with id "${unitId}"!`);
      }
      wbSelection = new WorkbookSelectionModel(workbook);
      this._workbookSelections.set(unitId, wbSelection);
    }
    return wbSelection;
  }
  _removeWorkbookSelection(unitId) {
    this._workbookSelections.delete(unitId);
  }
};
SheetsSelectionsService = __decorateClass([
  __decorateParam(0, IUniverInstanceService)
], SheetsSelectionsService);
var REF_SELECTIONS_ENABLED = "REF_SELECTIONS_ENABLED";

// ../packages/sheets/src/commands/commands/clear-selection-all.command.ts
var ClearSelectionAllCommand = {
  id: "sheet.command.clear-selection-all",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const unitId = (params == null ? void 0 : params.unitId) || workbook.getUnitId();
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return false;
    const subUnitId = (params == null ? void 0 : params.subUnitId) || worksheet.getSheetId();
    const selections = (params == null ? void 0 : params.ranges) || ((_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range));
    if (!(selections == null ? void 0 : selections.length)) {
      return false;
    }
    const visibleRanges = getVisibleRanges(selections, accessor, unitId, subUnitId);
    const sequenceExecuteList = [];
    const sequenceExecuteUndoList = [];
    const clearMutationParams = {
      subUnitId,
      unitId,
      cellValue: generateNullCell(visibleRanges)
    };
    const undoClearMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      clearMutationParams
    );
    sequenceExecuteList.push({
      id: SetRangeValuesMutation.id,
      params: clearMutationParams
    });
    sequenceExecuteUndoList.push({
      id: SetRangeValuesMutation.id,
      params: undoClearMutationParams
    });
    const intercepted = sheetInterceptorService.onCommandExecute({ id: ClearSelectionAllCommand.id });
    sequenceExecuteList.push(...intercepted.redos);
    sequenceExecuteUndoList.unshift(...intercepted.undos);
    const result = sequenceExecute(sequenceExecuteList, commandService);
    if (result) {
      undoRedoService.pushUndoRedo({
        // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
        // Hooks can be used to hook the code of external controllers to add new actions.
        unitID: unitId,
        undoMutations: sequenceExecuteUndoList,
        redoMutations: sequenceExecuteList
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/clear-selection-content.command.ts
var ClearSelectionContentCommand = {
  id: "sheet.command.clear-selection-content",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const unitId = (params == null ? void 0 : params.unitId) || workbook.getUnitId();
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return false;
    const subUnitId = (params == null ? void 0 : params.subUnitId) || worksheet.getSheetId();
    const ranges = (params == null ? void 0 : params.ranges) || ((_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range));
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const visibleRanges = getVisibleRanges(ranges, accessor, unitId, subUnitId);
    const clearMutationParams = {
      subUnitId,
      unitId,
      cellValue: generateNullCellValue(visibleRanges)
    };
    const undoClearMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      clearMutationParams
    );
    const intercepted = sheetInterceptorService.onCommandExecute({ id: ClearSelectionContentCommand.id });
    const redos = [{ id: SetRangeValuesMutation.id, params: clearMutationParams }, ...intercepted.redos];
    const undos = [...intercepted.undos, { id: SetRangeValuesMutation.id, params: undoClearMutationParams }];
    const result = sequenceExecute(redos, commandService).result;
    if (result) {
      undoRedoService.pushUndoRedo({
        // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
        // Hooks can be used to hook the code of external controllers to add new actions.
        unitID: unitId,
        undoMutations: undos,
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/clear-selection-format.command.ts
var ClearSelectionFormatCommand = {
  id: "sheet.command.clear-selection-format",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const unitId = (params == null ? void 0 : params.unitId) || workbook.getUnitId();
    const worksheet = workbook.getActiveSheet();
    if (!worksheet) return false;
    const subUnitId = (params == null ? void 0 : params.subUnitId) || worksheet.getSheetId();
    const ranges = (params == null ? void 0 : params.ranges) || ((_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range));
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const visibleRanges = getVisibleRanges(ranges, accessor, unitId, subUnitId);
    const sequenceExecuteList = [];
    const sequenceExecuteUndoList = [];
    const clearMutationParams = {
      subUnitId,
      unitId,
      cellValue: generateNullCellStyle(visibleRanges)
    };
    const undoClearMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      clearMutationParams
    );
    sequenceExecuteList.push({
      id: SetRangeValuesMutation.id,
      params: clearMutationParams
    });
    sequenceExecuteUndoList.push({
      id: SetRangeValuesMutation.id,
      params: undoClearMutationParams
    });
    const intercepted = sheetInterceptorService.onCommandExecute({ id: ClearSelectionFormatCommand.id });
    sequenceExecuteList.push(...intercepted.redos);
    sequenceExecuteUndoList.unshift(...intercepted.undos);
    const result = sequenceExecute(sequenceExecuteList, commandService);
    if (result) {
      undoRedoService.pushUndoRedo({
        // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
        // Hooks can be used to hook the code of external controllers to add new actions.
        unitID: unitId,
        undoMutations: sequenceExecuteUndoList,
        redoMutations: sequenceExecuteList
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/insert-sheet.mutation.ts
var InsertSheetUndoMutationFactory = (_accessor, params) => ({
  subUnitId: params.sheet.id,
  unitId: params.unitId,
  subUnitName: params.sheet.name
});
var InsertSheetMutation = {
  id: "sheet.mutation.insert-sheet",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const { sheet, index, unitId } = params;
    const workbook = univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return false;
    }
    return workbook.addWorksheet(sheet.id, index, sheet);
  }
};

// ../packages/sheets/src/commands/mutations/remove-sheet.mutation.ts
var RemoveSheetUndoMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const { subUnitId, unitId } = params;
  const target = getSheetMutationTarget(univerInstanceService, params);
  if (!target) {
    throw new Error("[RemoveSheetUndoMutationFactory]: Worksheet is null error!");
  }
  const { workbook, worksheet } = target;
  const sheet = worksheet.getConfig();
  const config2 = workbook.getConfig();
  const index = config2.sheetOrder.findIndex((id) => id === subUnitId);
  return {
    index,
    sheet,
    unitId
  };
};
var RemoveSheetMutation = {
  id: "sheet.mutation.remove-sheet",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const { subUnitId, unitId } = params;
    const workbook = univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return false;
    }
    return workbook.removeSheet(subUnitId);
  }
};

// ../packages/sheets/src/commands/commands/copy-worksheet.command.ts
var CopySheetCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.copy-sheet",
  handler: (accessor, params) => {
    var _a2, _b2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const localeService = accessor.get(LocaleService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) {
      return false;
    }
    const { workbook, worksheet, unitId, subUnitId } = target;
    const config2 = Tools.deepClone(worksheet.getConfig());
    config2.name = getCopyUniqueSheetName(workbook, localeService, config2.name);
    config2.id = Tools.generateRandomId();
    const sheetIndex = workbook.getSheetIndex(worksheet);
    const insertSheetMutationParams = {
      index: sheetIndex + 1,
      sheet: config2,
      unitId
    };
    const removeSheetMutationParams = InsertSheetUndoMutationFactory(
      accessor,
      insertSheetMutationParams
    );
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: CopySheetCommand.id,
      params: { unitId, subUnitId, targetSubUnitId: config2.id }
    });
    const redos = [
      ...(_a2 = intercepted.preRedos) != null ? _a2 : [],
      { id: InsertSheetMutation.id, params: insertSheetMutationParams },
      ...intercepted.redos
    ];
    const undos = [
      ...(_b2 = intercepted.preUndos) != null ? _b2 : [],
      { id: RemoveSheetMutation.id, params: removeSheetMutationParams },
      ...intercepted.undos
    ];
    const insertResult = sequenceExecute(redos, commandService).result;
    if (insertResult) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos,
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
};
function getCopyUniqueSheetName(workbook, localeService, name) {
  let output = name + localeService.t("sheets.tabs.sheetCopy", "");
  let count = 2;
  while (workbook.checkSheetName(output)) {
    output = name + localeService.t("sheets.tabs.sheetCopy", `${count}`);
    count++;
  }
  return output;
}

// ../packages/sheets/src/commands/mutations/move-range.mutation.ts
var MoveRangeMutation = {
  id: "sheet.mutation.move-range",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { from, to } = params;
    if (!from || !to) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) {
      return false;
    }
    const fromWorksheet = workbook.getSheetBySheetId(params.from.subUnitId);
    const toWorksheet = workbook.getSheetBySheetId(params.to.subUnitId);
    if (!fromWorksheet || !toWorksheet) {
      return false;
    }
    const fromCellMatrix = fromWorksheet.getCellMatrix();
    const toCellMatrix = toWorksheet.getCellMatrix();
    new ObjectMatrix(from.value).forValue((row, col, newVal) => {
      fromCellMatrix.setValue(row, col, newVal);
    });
    new ObjectMatrix(to.value).forValue((row, col, newVal) => {
      toCellMatrix.setValue(row, col, newVal);
    });
    return true;
  }
};

// ../packages/sheets/src/commands/commands/utils/selection-utils.ts
function alignToMergedCellsBorders(startRange, worksheet, shouldRecursive = true) {
  const coveredMergedCells = worksheet.getMatrixWithMergedCells(...selectionToArray(startRange));
  const exceededMergedCells = [];
  coveredMergedCells.forValue((row, col, value) => {
    if (value.colSpan !== void 0 && value.rowSpan !== void 0) {
      const mergedCellRange = {
        startRow: row,
        startColumn: col,
        endRow: row + value.rowSpan - 1,
        endColumn: col + value.colSpan - 1
      };
      if (!Rectangle.contains(startRange, mergedCellRange)) {
        exceededMergedCells.push(mergedCellRange);
      }
    }
  });
  if (exceededMergedCells.length === 0) {
    return startRange;
  }
  const union = Rectangle.union(startRange, ...exceededMergedCells);
  if (shouldRecursive) {
    return alignToMergedCellsBorders(union, worksheet, shouldRecursive);
  }
  return union;
}
function getPrimaryForRange(range, worksheet) {
  const startRow = Number.isNaN(range.startRow) ? 0 : range.startRow;
  const startColumn = Number.isNaN(range.startColumn) ? 0 : range.startColumn;
  const mergedRange = worksheet.getMergedCell(startRow, startColumn);
  if (!mergedRange) {
    return {
      startRow,
      startColumn,
      endRow: range.startRow,
      endColumn: range.startColumn,
      actualRow: startRow,
      actualColumn: startColumn,
      rangeType: 0 /* NORMAL */,
      isMerged: false,
      isMergedMainCell: false
    };
  }
  return {
    ...mergedRange,
    actualRow: startRow,
    actualColumn: startColumn,
    rangeType: 0 /* NORMAL */,
    isMerged: true,
    isMergedMainCell: true
  };
}
var followSelectionOperation = (range, workbook, worksheet) => ({
  id: SetSelectionsOperation.id,
  params: {
    unitId: workbook.getUnitId(),
    subUnitId: worksheet.getSheetId(),
    reveal: true,
    selections: [{ range, primary: getPrimaryForRange(range, worksheet) }]
  }
});
function createRangeIteratorWithSkipFilteredRows(sheet) {
  function forOperableEach(ranges, operator) {
    function iterate(range) {
      for (let r = range.startRow; r <= range.endRow; r++) {
        if (sheet.getRowFiltered(r)) {
          continue;
        }
        for (let c = range.startColumn; c <= range.endColumn; c++) {
          operator(r, c, range);
        }
      }
    }
    ;
    iterate(ranges);
  }
  return {
    forOperableEach
  };
}
var ignoreRangeThemeInterceptorFilter = (interceptor) => interceptor.id !== RangeThemeInterceptorId;
function copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, isRow, sourceRangeIndex) {
  const cellValue = {};
  for (let row = startRow; row <= endRow; row++) {
    for (let column = startColumn; column <= endColumn; column++) {
      const cell = isRow ? worksheet.getCellWithFilteredInterceptors(sourceRangeIndex, column, IgnoreRangeThemeInterceptorKey, ignoreRangeThemeInterceptorFilter) : worksheet.getCellWithFilteredInterceptors(row, sourceRangeIndex, IgnoreRangeThemeInterceptorKey, ignoreRangeThemeInterceptorFilter);
      if (!cell || !cell.s) {
        continue;
      }
      if (!cellValue[row]) {
        cellValue[row] = {};
      }
      cellValue[row][column] = { s: cell.s };
    }
  }
  return cellValue;
}

// ../packages/sheets/src/services/selections/ref-selections.service.ts
var import_rxjs33 = __toESM(require_cjs());
var IRefSelectionsService = createIdentifier("sheets-formula.ref-selections.service");
var RefSelectionsService = class extends SheetsSelectionsService {
  constructor(_instanceSrv) {
    super(_instanceSrv);
  }
  _init() {
    const $ = this._getAliveWorkbooks$().pipe((0, import_rxjs33.takeUntil)(this.dispose$));
    this.selectionMoveStart$ = $.pipe((0, import_rxjs33.switchMap)((ss) => (0, import_rxjs33.merge)(...ss.map((s) => s.selectionMoveStart$))));
    this.selectionMoving$ = $.pipe((0, import_rxjs33.switchMap)((ss) => (0, import_rxjs33.merge)(...ss.map((s) => s.selectionMoving$))));
    this.selectionMoveEnd$ = $.pipe((0, import_rxjs33.switchMap)((ss) => (0, import_rxjs33.merge)(...ss.map((s) => s.selectionMoveEnd$))));
    this.selectionSet$ = $.pipe((0, import_rxjs33.switchMap)((ss) => (0, import_rxjs33.merge)(...ss.map((s) => s.selectionSet$))));
  }
  _getAliveWorkbooks$() {
    const aliveWorkbooks = this._instanceSrv.getAllUnitsForType(O.UNIVER_SHEET);
    aliveWorkbooks.forEach((workbook) => this._ensureWorkbookSelection(workbook.getUnitId()));
    const workbooks$ = new import_rxjs33.BehaviorSubject(aliveWorkbooks);
    this.disposeWithMe(this._instanceSrv.getTypeOfUnitAdded$(O.UNIVER_SHEET).subscribe((workbook) => {
      this._ensureWorkbookSelection(workbook.getUnitId());
      workbooks$.next([...workbooks$.getValue(), workbook]);
    }));
    this.disposeWithMe(this._instanceSrv.getTypeOfUnitDisposed$(O.UNIVER_SHEET).subscribe((workbook) => {
      this._removeWorkbookSelection(workbook.getUnitId());
      workbooks$.next(workbooks$.getValue().filter((unit) => unit !== workbook));
    }));
    return workbooks$.pipe((0, import_rxjs33.map)((workbooks) => workbooks.map((w) => this._ensureWorkbookSelection(w.getUnitId()))));
  }
};
RefSelectionsService = __decorateClass([
  __decorateParam(0, IUniverInstanceService)
], RefSelectionsService);

// ../packages/sheets/src/commands/utils/selection-command-util.ts
function getSelectionsService(accessor, fromCurrentSelection) {
  const contextService = accessor.get(IContextService);
  const isInRefSelectionMode = contextService.getContextValue(REF_SELECTIONS_ENABLED);
  return accessor.get(isInRefSelectionMode && !fromCurrentSelection ? IRefSelectionsService : SheetsSelectionsService);
}

// ../packages/sheets/src/commands/operations/selection.operation.ts
var SetSelectionsOperation = {
  id: "sheet.operation.set-selections",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    if (!params) return false;
    const { selections, type: type2, unitId, subUnitId } = params;
    const selectionManagerService = getSelectionsService(accessor);
    selectionManagerService.setSelections(unitId, subUnitId, [...selections], type2);
    return true;
  }
};
var SelectRangeCommand = {
  id: "sheet.command.select-range",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) return false;
    const { unitId, subUnit, range } = params;
    const commandService = accessor.get(ICommandService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const selections = [{
      range,
      primary: getPrimaryForRange(range, target.worksheet),
      style: null
    }];
    return commandService.syncExecuteCommand(SetSelectionsOperation.id, {
      unitId,
      subUnitId: subUnit,
      selections
    });
  }
};

// ../packages/sheets/src/commands/commands/move-range.command.ts
var MoveRangeCommandId = "sheet.command.move-range";
var MoveRangeCommand = {
  type: 0 /* COMMAND */,
  id: MoveRangeCommandId,
  handler: async (accessor, params) => {
    var _a2, _b2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const errorService = accessor.get(ErrorService);
    const localeService = accessor.get(LocaleService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const perform = await sheetInterceptorService.beforeCommandExecute({ id: MoveRangeCommand.id, params });
    if (!perform) {
      return false;
    }
    const { worksheet, subUnitId, unitId } = target;
    const moveRangeMutations = getMoveRangeUndoRedoMutations(
      accessor,
      { unitId, subUnitId, range: params.fromRange },
      { unitId, subUnitId, range: params.toRange }
    );
    if (moveRangeMutations === null) {
      errorService.emit(localeService.t("sheets.info.acrossMergedCell"));
      return false;
    }
    const interceptorCommands = sheetInterceptorService.onCommandExecute({
      id: MoveRangeCommand.id,
      params: { ...params }
    });
    const redos = [
      ...(_a2 = interceptorCommands.preRedos) != null ? _a2 : [],
      ...moveRangeMutations.redos,
      ...interceptorCommands.redos,
      {
        id: SetSelectionsOperation.id,
        params: {
          unitId,
          subUnitId,
          selections: [{ range: params.toRange, primary: getPrimaryAfterMove(params.fromRange, params.toRange, worksheet) }],
          type: 2 /* MOVE_END */
        }
      }
    ];
    const undos = [
      ...(_b2 = interceptorCommands.preUndos) != null ? _b2 : [],
      ...moveRangeMutations.undos,
      ...interceptorCommands.undos,
      {
        id: SetSelectionsOperation.id,
        params: {
          unitId,
          subUnitId,
          selections: [{ range: params.fromRange, primary: getPrimaryForRange(params.fromRange, worksheet) }],
          type: 2 /* MOVE_END */
        }
      }
    ];
    const result = sequenceExecute(redos, commandService).result;
    const afterInterceptors = sheetInterceptorService.afterCommandExecute({
      id: MoveRangeCommand.id,
      params: { ...params }
    });
    if (result) {
      sequenceExecute(afterInterceptors.redos, commandService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [...undos, ...afterInterceptors.undos],
        redoMutations: [...redos, ...afterInterceptors.redos]
      });
      return true;
    }
    return false;
  }
};
function getMoveRangeUndoRedoMutations(accessor, from, to, ignoreMerge = false) {
  const redos = [];
  const undos = [];
  const { range: fromRange, subUnitId: fromSubUnitId, unitId } = from;
  const { range: toRange, subUnitId: toSubUnitId } = to;
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const workbook = univerInstanceService.getUniverSheetInstance(unitId);
  const toWorksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(toSubUnitId);
  const fromWorksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(fromSubUnitId);
  const toCellMatrix = toWorksheet == null ? void 0 : toWorksheet.getCellMatrix();
  const fromCellMatrix = fromWorksheet == null ? void 0 : fromWorksheet.getCellMatrix();
  if (toWorksheet && fromWorksheet && toCellMatrix && fromCellMatrix) {
    const alignedRangeWithToRange = alignToMergedCellsBorders(toRange, toWorksheet, false);
    if (!Rectangle.equals(toRange, alignedRangeWithToRange) && !ignoreMerge) {
      return null;
    }
    const fromCellValue = new ObjectMatrix();
    const newFromCellValue = new ObjectMatrix();
    const fromCellStyle = new ObjectMatrix();
    Range.foreach(fromRange, (row, col) => {
      const cellData = fromCellMatrix.getValue(row, col);
      fromCellValue.setValue(row, col, Tools.deepClone(cellData));
      if (cellData) {
        const style = workbook == null ? void 0 : workbook.getStyles().get(cellData.s);
        fromCellStyle.setValue(row, col, Tools.deepClone(style));
      }
      newFromCellValue.setValue(row, col, null);
    });
    const toCellValue = new ObjectMatrix();
    const newToCellValue = new ObjectMatrix();
    Range.foreach(toRange, (row, col) => {
      toCellValue.setValue(row, col, Tools.deepClone(toCellMatrix.getValue(row, col)));
    });
    Range.foreach(fromRange, (row, col) => {
      const cellRange = cellToRange(row, col);
      const relativeRange = Rectangle.getRelativeRange(cellRange, fromRange);
      const range = Rectangle.getPositionRange(relativeRange, toRange);
      const styleValue = Tools.deepClone(fromCellStyle.getValue(row, col));
      const cellValue = Tools.deepClone(fromCellValue.getValue(row, col));
      if (cellValue && styleValue) {
        cellValue.s = styleValue;
      }
      newToCellValue.setValue(range.startRow, range.startColumn, cellValue);
    });
    const doMoveRangeMutation = {
      fromRange: from.range,
      toRange: to.range,
      from: {
        value: newFromCellValue.getMatrix(),
        subUnitId: fromSubUnitId
      },
      to: {
        value: newToCellValue.getMatrix(),
        subUnitId: toSubUnitId
      },
      unitId
    };
    const undoMoveRangeMutation = {
      fromRange: to.range,
      toRange: from.range,
      from: {
        value: fromCellValue.getMatrix(),
        subUnitId: fromSubUnitId
      },
      to: {
        value: toCellValue.getMatrix(),
        subUnitId: toSubUnitId
      },
      unitId
    };
    redos.push({ id: MoveRangeMutation.id, params: doMoveRangeMutation });
    undos.push({ id: MoveRangeMutation.id, params: undoMoveRangeMutation });
  }
  return {
    redos,
    undos
  };
}
function getPrimaryAfterMove(fromRange, toRange, worksheet) {
  const startRow = fromRange.startRow;
  const startColumn = fromRange.startColumn;
  const mergeInfo = worksheet.getMergedCell(startRow, startColumn);
  const res = getPrimaryForRange(toRange, worksheet);
  if (mergeInfo) {
    const mergeRowCount = mergeInfo.endRow - mergeInfo.startRow + 1;
    const mergeColCount = mergeInfo.endColumn - mergeInfo.startColumn + 1;
    res.endRow = res.startRow + mergeRowCount - 1;
    res.endColumn = res.startColumn + mergeColCount - 1;
    res.actualRow = res.startRow;
    res.actualColumn = res.startColumn;
    res.isMerged = false;
    res.isMergedMainCell = true;
  }
  return res;
}

// ../packages/sheets/src/services/permission/permission-point/range/edit.ts
var RangeProtectionPermissionEditPoint = class {
  constructor(unitId, subUnitId, permissionId) {
    __publicField(this, "type", a.SelectRange);
    __publicField(this, "subType", D.Edit);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "value", true);
    __publicField(this, "id");
    __publicField(this, "unitId");
    __publicField(this, "subUnitId");
    __publicField(this, "permissionId");
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    this.permissionId = permissionId;
    this.id = `${a.SelectRange}.${D.Edit}.${permissionId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/range/view.ts
var RangeProtectionPermissionViewPoint = class {
  constructor(unitId, subUnitId, permissionId) {
    __publicField(this, "type", a.SelectRange);
    __publicField(this, "subType", D.View);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "value", true);
    __publicField(this, "id");
    __publicField(this, "unitId");
    __publicField(this, "subUnitId");
    __publicField(this, "permissionId");
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    this.permissionId = permissionId;
    this.id = `${a.SelectRange}.${D.View}.${permissionId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/comment.ts
var WorkbookCommentPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.Comment);
    this.unitId = unitId;
    this.id = `${this.type}.${D.Comment}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/copy.ts
var WorkbookCopyPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.Copy);
    this.unitId = unitId;
    this.id = `${this.type}.${D.Copy}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/copy-sheet.ts
var WorkbookCopySheetPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "subType", D.CopySheet);
    __publicField(this, "status", "init" /* INIT */);
    this.unitId = unitId;
    this.id = `${this.type}.${D.CopySheet}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/create-permission.ts
var WorkbookCreateProtectPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.CreatePermissionObject);
    this.unitId = unitId;
    this.id = `${this.type}.${D.CreatePermissionObject}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/create-sheet.ts
var WorkbookCreateSheetPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.CreateSheet);
    this.unitId = unitId;
    this.id = `${this.type}.${D.CreateSheet}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/delete-sheet.ts
var WorkbookDeleteSheetPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.DeleteSheet);
    this.unitId = unitId;
    this.id = `${this.type}.${D.DeleteSheet}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/duplicate.ts
var WorkbookDuplicatePermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.Duplicate);
    this.unitId = unitId;
    this.id = `${this.type}.${D.Duplicate}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/editable.ts
var WorkbookEditablePermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.Edit);
    this.unitId = unitId;
    this.id = `${this.type}.${D.Edit}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/export.ts
var WorkbookExportPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.Export);
    this.unitId = unitId;
    this.id = `${this.type}.${D.Export}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/hide-sheet.ts
var WorkbookHideSheetPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.HideSheet);
    this.unitId = unitId;
    this.id = `${this.type}.${D.HideSheet}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/manage-collaborator.ts
var WorkbookManageCollaboratorPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.ManageCollaborator);
    this.unitId = unitId;
    this.id = `${this.type}.${D.ManageCollaborator}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/move-sheet.ts
var WorkbookMoveSheetPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.MoveSheet);
    this.unitId = unitId;
    this.id = `${this.type}.${D.MoveSheet}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/print.ts
var WorkbookPrintPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.Print);
    this.unitId = unitId;
    this.id = `${this.type}.${D.Print}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/recover-history.ts
var WorkbookRecoverHistoryPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.RecoverHistory);
    this.unitId = unitId;
    this.id = `${this.type}.${D.RecoverHistory}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/rename-sheet.ts
var WorkbookRenameSheetPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.RenameSheet);
    this.unitId = unitId;
    this.id = `${this.type}.${D.RenameSheet}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/share.ts
var WorkbookSharePermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.Share);
    this.unitId = unitId;
    this.id = `${this.type}.${D.Share}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/view.ts
var WorkbookViewPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.View);
    this.unitId = unitId;
    this.id = `${this.type}.${D.View}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/workbook/view-history.ts
var WorkbookViewHistoryPermission = class {
  constructor(unitId) {
    this.unitId = unitId;
    __publicField(this, "id");
    __publicField(this, "value", true);
    __publicField(this, "type", a.Workbook);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "subType", D.ViewHistory);
    this.unitId = unitId;
    this.id = `${this.type}.${D.ViewHistory}_${unitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/copy.ts
var WorksheetCopyPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.Copy);
    this.id = `${this.type}.${D.Copy}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/delete-column.ts
var WorksheetDeleteColumnPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.DeleteColumn);
    this.id = `${this.type}.${D.DeleteColumn}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/delete-protection.ts
var WorksheetDeleteProtectionPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.Delete);
    this.id = `${this.type}.${D.Delete}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/delete-row.ts
var WorksheetDeleteRowPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.DeleteRow);
    this.id = `${this.type}.${D.DeleteRow}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/edit.ts
var WorksheetEditPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.Edit);
    this.id = `${this.type}.${D.Edit}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/edit-extra-object.ts
var WorksheetEditExtraObjectPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.EditExtraObject);
    this.id = `${this.type}.${D.EditExtraObject}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/filter.ts
var WorksheetFilterPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.Filter);
    this.id = `${this.type}.${D.Filter}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/insert-column.ts
var WorksheetInsertColumnPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.InsertColumn);
    this.id = `${this.type}.${D.InsertColumn}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/insert-hyperlink.ts
var WorksheetInsertHyperlinkPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.InsertHyperlink);
    this.id = `${this.type}.${D.InsertHyperlink}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/insert-row.ts
var WorksheetInsertRowPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.InsertRow);
    this.id = `${this.type}.${D.InsertRow}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/manage-collaborator.ts
var WorksheetManageCollaboratorPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.ManageCollaborator);
    this.id = `${this.type}.${D.ManageCollaborator}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/pivot-table.ts
var WorksheetPivotTablePermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.PivotTable);
    this.id = `${this.type}.${D.PivotTable}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/set-cell-style.ts
var WorksheetSetCellStylePermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.SetCellStyle);
    this.id = `${this.type}.${D.SetCellStyle}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/set-cell-value.ts
var WorksheetSetCellValuePermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.SetCellValue);
    this.id = `${this.type}.${D.SetCellValue}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/set-column-style.ts
var WorksheetSetColumnStylePermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.SetColumnStyle);
    this.id = `${this.type}.${D.SetColumnStyle}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/set-row-style.ts
var WorksheetSetRowStylePermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.SetRowStyle);
    this.id = `${this.type}.${D.SetRowStyle}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/sort.ts
var WorksheetSortPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.Sort);
    this.id = `${this.type}.${D.Sort}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/worksheet/view.ts
var WorksheetViewPermission = class {
  constructor(unitId, subUnitId) {
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    __publicField(this, "value", true);
    __publicField(this, "type", a.Worksheet);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "id");
    __publicField(this, "subType", D.View);
    this.id = `${this.type}.${D.View}_${unitId}_${subUnitId}`;
  }
};

// ../packages/sheets/src/commands/commands/set-range-values.command.ts
var SetRangeValuesCommand = {
  id: "sheet.command.set-range-values",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const permissionService = accessor.get(IPermissionService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { subUnitId, unitId, workbook, worksheet } = target;
    const { value, range, redoUndoId } = params;
    const currentSelections = range ? [range] : (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    if (!currentSelections || !currentSelections.length) return false;
    if (!permissionService.getPermissionPoint(new WorksheetEditPermission(unitId, subUnitId).id)) return false;
    const cellValue = new ObjectMatrix();
    let realCellValue;
    if (Tools.isArray(value)) {
      for (let i = 0; i < currentSelections.length; i++) {
        const { startRow, startColumn, endRow, endColumn } = currentSelections[i];
        for (let r = 0; r <= endRow - startRow; r++) {
          for (let c = 0; c <= endColumn - startColumn; c++) {
            cellValue.setValue(r + startRow, c + startColumn, value[r][c]);
          }
        }
      }
    } else if (isICellData(value)) {
      for (let i = 0; i < currentSelections.length; i++) {
        const { startRow, startColumn, endRow, endColumn } = currentSelections[i];
        for (let r = startRow; r <= endRow; r++) {
          for (let c = startColumn; c <= endColumn; c++) {
            cellValue.setValue(r, c, value);
          }
        }
      }
    } else {
      realCellValue = value;
    }
    const setRangeValuesMutationParams = { subUnitId, unitId, cellValue: realCellValue != null ? realCellValue : cellValue.getMatrix() };
    const redoParams = SetRangeValuesUndoMutationFactory(accessor, setRangeValuesMutationParams);
    const setValueMutationResult = commandService.syncExecuteCommand(SetRangeValuesMutation.id, setRangeValuesMutationParams);
    if (!setValueMutationResult) return false;
    const { undos, redos } = sheetInterceptorService.onCommandExecute({
      id: SetRangeValuesCommand.id,
      params: { ...setRangeValuesMutationParams, range: currentSelections }
    });
    const result = sequenceExecute([...redos], commandService);
    if (result.result) {
      const selectionOperation = followSelectionOperation(range != null ? range : cellValue.getRange(), workbook, worksheet);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          { id: SetRangeValuesMutation.id, params: redoParams },
          ...undos,
          selectionOperation
        ],
        redoMutations: [
          { id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams },
          ...redos,
          Tools.deepClone(selectionOperation)
        ],
        id: redoUndoId
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/utils/handle-range-mutation.ts
function getInsertRangeMutations(accessor, params) {
  const redo = [];
  const undo = [];
  const { unitId, subUnitId, range, shiftDimension, cellValue = {} } = params;
  const instanceService = accessor.get(IUniverInstanceService);
  const sheetInterceptorService = accessor.get(SheetInterceptorService);
  const workbook = instanceService.getUniverSheetInstance(unitId);
  const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
  if (worksheet) {
    const cellMatrix = worksheet.getCellMatrix();
    const dataRange = cellMatrix.getDataRange();
    if (range.startColumn <= dataRange.endColumn || range.startRow <= dataRange.endRow) {
      let moveFromRange;
      let moveToRange;
      if (shiftDimension === 0 /* COLUMNS */) {
        const endRow = Math.min(range.endRow, dataRange.endRow);
        let endColumn = 0;
        for (let row = range.startRow; row <= endRow; row++) {
          const rowData = cellMatrix.getRow(row);
          const rowLength = rowData ? getArrayLength(rowData) - 1 : 0;
          endColumn = Math.max(endColumn, rowLength);
        }
        moveFromRange = {
          startRow: range.startRow,
          startColumn: range.startColumn,
          endRow,
          endColumn
        };
        const shift = range.endColumn - range.startColumn + 1;
        moveToRange = {
          startRow: range.startRow,
          startColumn: moveFromRange.startColumn + shift,
          endRow,
          endColumn: moveFromRange.endColumn + shift
        };
      } else {
        const endColumn = Math.min(range.endColumn, dataRange.endColumn);
        const endRow = dataRange.endRow;
        moveFromRange = {
          startRow: range.startRow,
          startColumn: range.startColumn,
          endRow,
          endColumn
        };
        const shift = range.endRow - range.startRow + 1;
        moveToRange = {
          startRow: moveFromRange.startRow + shift,
          startColumn: range.startColumn,
          endRow: moveFromRange.endRow + shift,
          endColumn
        };
      }
      const moveRangeMutations = getMoveRangeUndoRedoMutations(
        accessor,
        { unitId, subUnitId, range: moveFromRange },
        { unitId, subUnitId, range: moveToRange },
        true
      );
      if (moveRangeMutations) {
        redo.push(...moveRangeMutations.redos);
        undo.push(...moveRangeMutations.undos);
      }
    }
    if (Object.entries(cellValue).length === 0) {
      for (let row = range.startRow; row <= range.endRow; row++) {
        if (!cellValue[row]) {
          cellValue[row] = {};
        }
        for (let column = range.startColumn; column <= range.endColumn; column++) {
          cellValue[row][column] = null;
        }
      }
    }
    const setRangeValuesMutationParams = {
      subUnitId,
      unitId,
      cellValue
    };
    const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      setRangeValuesMutationParams
    );
    const { undos: interceptorUndos, redos: interceptorRedos } = sheetInterceptorService.onCommandExecute({
      id: SetRangeValuesCommand.id,
      params: { ...setRangeValuesMutationParams, range }
    });
    redo.push({ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }, ...interceptorRedos);
    undo.push({ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams }, ...interceptorUndos);
  }
  return {
    redo,
    undo
  };
}
function getRemoveRangeMutations(accessor, params) {
  const redo = [];
  const undo = [];
  const { unitId, subUnitId, range, shiftDimension } = params;
  const instanceService = accessor.get(IUniverInstanceService);
  const sheetInterceptorService = accessor.get(SheetInterceptorService);
  const workbook = instanceService.getUniverSheetInstance(unitId);
  const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
  if (worksheet) {
    const cellMatrix = worksheet.getCellMatrix();
    const dataRange = cellMatrix.getDataRange();
    const setRangeValuesMutationParams = {
      subUnitId,
      unitId,
      cellValue: generateNullCell([range])
    };
    const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      setRangeValuesMutationParams
    );
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: SetRangeValuesCommand.id,
      params: setRangeValuesMutationParams
    });
    redo.push({ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }, ...intercepted.redos);
    undo.push(...intercepted.undos, {
      id: SetRangeValuesMutation.id,
      params: undoSetRangeValuesMutationParams
    });
    if (range.startColumn <= dataRange.endColumn || range.startRow <= dataRange.endRow) {
      let moveFromRange = null;
      let moveToRange = null;
      if (shiftDimension === 0 /* COLUMNS */ && range.endColumn < dataRange.endColumn) {
        const endRow = Math.min(range.endRow, dataRange.endRow);
        let endColumn = 0;
        for (let row = range.startRow; row <= endRow; row++) {
          const rowData = cellMatrix.getRow(row);
          const rowLength = rowData ? getArrayLength(rowData) - 1 : 0;
          endColumn = Math.max(endColumn, rowLength);
        }
        moveFromRange = {
          startRow: range.startRow,
          startColumn: range.endColumn + 1,
          endRow,
          endColumn
        };
        const shift = range.endColumn - range.startColumn + 1;
        moveToRange = {
          startRow: range.startRow,
          startColumn: moveFromRange.startColumn - shift,
          endRow,
          endColumn: moveFromRange.endColumn - shift
        };
      }
      if (shiftDimension === 1 /* ROWS */ && range.endRow < dataRange.endRow) {
        const endColumn = Math.min(range.endColumn, dataRange.endColumn);
        const endRow = dataRange.endRow;
        moveFromRange = {
          startRow: range.endRow + 1,
          startColumn: range.startColumn,
          endRow,
          endColumn
        };
        const shift = range.endRow - range.startRow + 1;
        moveToRange = {
          startRow: moveFromRange.startRow - shift,
          startColumn: range.startColumn,
          endRow: moveFromRange.endRow - shift,
          endColumn
        };
      }
      if (moveFromRange && moveToRange) {
        const moveRangeMutations = getMoveRangeUndoRedoMutations(
          accessor,
          { unitId, subUnitId, range: moveFromRange },
          { unitId, subUnitId, range: moveToRange },
          true
        );
        if (moveRangeMutations) {
          redo.push(...moveRangeMutations.redos);
          undo.push(...moveRangeMutations.undos);
        }
      }
    }
  }
  return {
    redo,
    undo
  };
}

// ../packages/sheets/src/commands/commands/delete-range-move-left.command.ts
var DeleteRangeMoveLeftCommandId = "sheet.command.delete-range-move-left";
var DeleteRangeMoveLeftCommand = {
  type: 0 /* COMMAND */,
  id: DeleteRangeMoveLeftCommandId,
  handler: async (accessor, params) => {
    var _a2, _b2, _c;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, workbook, subUnitId, unitId } = target;
    let range = params == null ? void 0 : params.range;
    if (!range) {
      range = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.range;
    }
    if (!range) return false;
    const deleteRangeMutationParams = {
      range,
      subUnitId,
      unitId,
      shiftDimension: 0 /* COLUMNS */
    };
    const sheetInterceptor = sheetInterceptorService.onCommandExecute({
      id: DeleteRangeMoveLeftCommand.id,
      params: { range }
    });
    const { redo: removeRangeRedo, undo: removeRangeUndo } = getRemoveRangeMutations(
      accessor,
      deleteRangeMutationParams
    );
    const redos = [...(_b2 = sheetInterceptor.preRedos) != null ? _b2 : [], ...removeRangeRedo];
    const undos = [...sheetInterceptor.undos, ...removeRangeUndo];
    redos.push(...sheetInterceptor.redos);
    redos.push(followSelectionOperation(range, workbook, worksheet));
    undos.push(...(_c = sheetInterceptor.preUndos) != null ? _c : []);
    const result = sequenceExecute(redos, commandService).result;
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos.reverse(),
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
  // all subsequent mutations should succeed inorder to make the whole process succeed
  // Promise.all([]).then(() => true),
};

// ../packages/sheets/src/commands/commands/delete-range-move-up.command.ts
var DeleteRangeMoveUpCommandId = "sheet.command.delete-range-move-up";
var DeleteRangeMoveUpCommand = {
  type: 0 /* COMMAND */,
  id: DeleteRangeMoveUpCommandId,
  handler: async (accessor, params) => {
    var _a2, _b2, _c;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { unitId, subUnitId, workbook, worksheet } = target;
    let range = params == null ? void 0 : params.range;
    if (!range) {
      range = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.range;
    }
    if (!range) return false;
    const deleteRangeMutationParams = {
      range,
      subUnitId,
      unitId,
      shiftDimension: 1 /* ROWS */
    };
    const sheetInterceptor = sheetInterceptorService.onCommandExecute({
      id: DeleteRangeMoveUpCommand.id,
      params: { range }
    });
    const { redo: removeRangeRedo, undo: removeRangeUndo } = getRemoveRangeMutations(
      accessor,
      deleteRangeMutationParams
    );
    const redos = [...(_b2 = sheetInterceptor.preRedos) != null ? _b2 : [], ...removeRangeRedo];
    const undos = [...sheetInterceptor.undos, ...removeRangeUndo];
    redos.push(...sheetInterceptor.redos);
    redos.push(followSelectionOperation(range, workbook, worksheet));
    undos.push(...(_c = sheetInterceptor.preUndos) != null ? _c : []);
    const result = sequenceExecute(redos, commandService).result;
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos.reverse(),
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
  // all subsequent mutations should succeed inorder to make the whole process succeed
  // Promise.all([]).then(() => true),
};

// ../packages/sheets/src/commands/commands/delete-range-protection.command.ts
var DeleteRangeProtectionCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delete-range-protection",
  async handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { unitId, subUnitId, rule } = params;
    const redoMutationParam = {
      unitId,
      subUnitId,
      ruleIds: [rule.id]
    };
    const result = await commandService.executeCommand(DeleteRangeProtectionMutation.id, redoMutationParam);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        redoMutations: [{ id: DeleteRangeProtectionMutation.id, params: redoMutationParam }],
        undoMutations: [{ id: AddRangeProtectionMutation.id, params: { unitId, subUnitId, rules: [rule] } }]
      });
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/delete-worksheet-protection.command.ts
var DeleteWorksheetProtectionCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delete-worksheet-protection",
  handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { rule, unitId, subUnitId } = params;
    commandService.executeCommand(DeleteWorksheetProtectionMutation.id, {
      unitId,
      subUnitId
    });
    const redoMutations = [{ id: DeleteWorksheetProtectionMutation.id, params: { unitId, subUnitId } }];
    const undoMutations = [{ id: AddWorksheetProtectionMutation.id, params: { unitId, rule, subUnitId } }];
    undoRedoService.pushUndoRedo({
      unitID: unitId,
      redoMutations,
      undoMutations
    });
    return true;
  }
};

// ../packages/sheets/src/commands/commands/delete-worksheet-range-theme.command.ts
var DeleteWorksheetRangeThemeStyleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.remove-worksheet-range-theme-style",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { unitId } = params;
    const undoMutationParams = DeleteWorksheetRangeThemeStyleMutationFactory(accessor, params);
    const result = commandService.syncExecuteCommand(DeleteWorksheetRangeThemeStyleMutation.id, params);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetWorksheetRangeThemeStyleMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: DeleteWorksheetRangeThemeStyleMutation.id, params }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/insert-defined-name.command.ts
var InsertDefinedNameCommand = {
  id: "sheet.command.insert-defined-name",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    if (!params) return false;
    const insertSheetMutationParams = {
      ...params
    };
    const result = commandService.syncExecuteCommand(SetDefinedNameMutation.id, insertSheetMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: params.unitId,
        undoMutations: [{ id: RemoveDefinedNameMutation.id, params: insertSheetMutationParams }],
        redoMutations: [{ id: SetDefinedNameMutation.id, params: insertSheetMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/insert-range-move-down.command.ts
var InsertRangeMoveDownCommandId = "sheet.command.insert-range-move-down";
var InsertRangeMoveDownCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-range-move-down",
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a2, _b2, _c;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const errorService = accessor.get(ErrorService);
    const localeService = accessor.get(LocaleService);
    if (selectionManagerService.isOverlapping()) {
      errorService.emit(localeService.t("sheets.info.overlappingSelections"));
      return false;
    }
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { unitId, subUnitId, worksheet, workbook } = target;
    let range = params == null ? void 0 : params.range;
    if (!range) {
      range = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.range;
    }
    if (!range) return false;
    const redoMutations = [];
    const undoMutations = [];
    const cellMatrix = worksheet.getCellMatrix();
    const dataRange = cellMatrix.getDataRange();
    const moveSlice = cellMatrix.getSlice(dataRange.startRow, dataRange.endRow, range.startColumn, range.endColumn);
    const sliceMaxRow = moveSlice.getDataRange().endRow;
    const insertRowCount = Math.max(sliceMaxRow + (range.endRow - range.startRow + 1) - dataRange.endRow, 0);
    if (insertRowCount > 0) {
      const anchorRow = range.startRow - 1;
      const height = worksheet.getRowHeight(anchorRow);
      const insertRowParams = {
        unitId,
        subUnitId,
        range: {
          startRow: dataRange.endRow + 1,
          endRow: dataRange.endRow + insertRowCount,
          startColumn: dataRange.startColumn,
          endColumn: dataRange.endColumn
        },
        rowInfo: new Array(insertRowCount).fill(void 0).map(() => ({
          h: height,
          hd: 0 /* FALSE */
        }))
      };
      redoMutations.push({
        id: InsertRowMutation.id,
        params: insertRowParams
      });
      const undoRowInsertionParams = InsertRowMutationUndoFactory(
        accessor,
        insertRowParams
      );
      undoMutations.push({ id: RemoveRowMutation.id, params: undoRowInsertionParams });
    }
    const cellValue = {};
    Range.foreach(range, (row, col) => {
      const cell = worksheet.getCell(row, col);
      if (!cell) {
        return;
      }
      if (!cellValue[row]) {
        cellValue[row] = {};
      }
      cellValue[row][col] = { s: cell.s };
    });
    const insertRangeMutationParams = {
      range,
      subUnitId,
      unitId,
      shiftDimension: 1 /* ROWS */,
      cellValue
    };
    const { redo: insertRangeRedo, undo: insertRangeUndo } = getInsertRangeMutations(
      accessor,
      insertRangeMutationParams
    );
    redoMutations.push(...insertRangeRedo);
    undoMutations.push(...insertRangeUndo);
    const sheetInterceptor = sheetInterceptorService.onCommandExecute({
      id: InsertRangeMoveDownCommand.id,
      params: { range }
    });
    redoMutations.push(...sheetInterceptor.redos);
    redoMutations.push(followSelectionOperation(range, workbook, worksheet));
    undoMutations.push(...(_b2 = sheetInterceptor.preUndos) != null ? _b2 : []);
    redoMutations.unshift(...(_c = sheetInterceptor.preRedos) != null ? _c : []);
    undoMutations.unshift(...sheetInterceptor.undos);
    const result = sequenceExecute(redoMutations, commandService);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undoMutations.reverse(),
        redoMutations
      });
      return true;
    }
    return false;
  }
  // all subsequent mutations should succeed inorder to make the whole process succeed
  // Promise.all([]).then(() => true),
};

// ../packages/sheets/src/commands/commands/insert-range-move-right.command.ts
var InsertRangeMoveRightCommandId = "sheet.command.insert-range-move-right";
var InsertRangeMoveRightCommand = {
  type: 0 /* COMMAND */,
  id: InsertRangeMoveRightCommandId,
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a2, _b2, _c;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const errorService = accessor.get(ErrorService);
    const localeService = accessor.get(LocaleService);
    if (selectionManagerService.isOverlapping()) {
      errorService.emit(localeService.t("sheets.info.overlappingSelections"));
      return false;
    }
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { workbook, worksheet, unitId, subUnitId } = target;
    let range = params == null ? void 0 : params.range;
    if (!range) {
      range = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.range;
    }
    if (!range) return false;
    const redoMutations = [];
    const undoMutations = [];
    const cellMatrix = worksheet.getCellMatrix();
    const dataRange = cellMatrix.getDataRange();
    const moveSlice = cellMatrix.getSlice(range.startRow, range.endRow, dataRange.startColumn, dataRange.endColumn);
    const sliceMaxCol = moveSlice.getDataRange().endColumn;
    const insertColCount = Math.max(
      sliceMaxCol + (range.endColumn - range.startColumn + 1) - dataRange.endColumn,
      0
    );
    if (insertColCount > 0) {
      const anchorCol = range.startColumn - 1;
      const width = worksheet.getColumnWidth(anchorCol);
      const insertColParams = {
        unitId,
        subUnitId,
        range: {
          startRow: dataRange.startRow + 1,
          endRow: dataRange.endRow,
          startColumn: dataRange.endColumn + 1,
          endColumn: dataRange.endColumn + insertColCount
        },
        colInfo: new Array(insertColCount).fill(void 0).map(() => ({
          w: width,
          hd: 0 /* FALSE */
        }))
      };
      redoMutations.push({
        id: InsertColMutation.id,
        params: insertColParams
      });
      const undoColInsertionParams = InsertColMutationUndoFactory(
        accessor,
        insertColParams
      );
      undoMutations.push({ id: RemoveColMutation.id, params: undoColInsertionParams });
    }
    const cellValue = {};
    Range.foreach(range, (row, col) => {
      const cell = worksheet.getCell(row, col);
      if (!cell || !cell.s) {
        return;
      }
      if (!cellValue[row]) {
        cellValue[row] = {};
      }
      cellValue[row][col] = { s: cell.s };
    });
    const insertRangeMutationParams = {
      range,
      subUnitId,
      unitId,
      shiftDimension: 0 /* COLUMNS */,
      cellValue
    };
    const { redo: insertRangeRedo, undo: insertRangeUndo } = getInsertRangeMutations(
      accessor,
      insertRangeMutationParams
    );
    redoMutations.push(...insertRangeRedo);
    undoMutations.push(...insertRangeUndo);
    const sheetInterceptor = sheetInterceptorService.onCommandExecute({
      id: InsertRangeMoveRightCommand.id,
      params: { range }
    });
    redoMutations.push(...sheetInterceptor.redos);
    redoMutations.push(followSelectionOperation(range, workbook, worksheet));
    undoMutations.push(...(_b2 = sheetInterceptor.preUndos) != null ? _b2 : []);
    redoMutations.unshift(...(_c = sheetInterceptor.preRedos) != null ? _c : []);
    undoMutations.unshift(...sheetInterceptor.undos);
    const result = sequenceExecute(redoMutations, commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undoMutations.reverse(),
        redoMutations
      });
      return true;
    }
    return false;
  }
  // all subsequent mutations should succeed in order to make the whole process succeed
  // Promise.all([]).then(() => true),
};

// ../packages/sheets/src/commands/commands/insert-row-col.command.ts
var InsertRowCommandId = "sheet.command.insert-row";
var InsertRowCommand = {
  type: 0 /* COMMAND */,
  id: InsertRowCommandId,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const { range, direction, unitId, subUnitId, cellValue } = params;
    const canPerform = await sheetInterceptorService.beforeCommandExecute({
      id: InsertRowCommand.id,
      params
    });
    if (!canPerform) {
      return false;
    }
    return commandService.syncExecuteCommand(InsertRowByRangeCommand.id, {
      range,
      direction,
      unitId,
      subUnitId,
      cellValue
    });
  }
};
var InsertRowByRangeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-row-by-range",
  handler: (accessor, params) => {
    var _a2, _b2, _c, _d;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { workbook, worksheet } = target;
    const { range, direction, unitId, subUnitId, cellValue } = params;
    const { startRow, endRow } = range;
    range.rangeType = 1 /* ROW */;
    const anchorRow = direction === 0 /* UP */ ? startRow : startRow - 1;
    const height = worksheet.getRowHeight(anchorRow);
    const insertRowParams = {
      unitId,
      subUnitId,
      range,
      rowInfo: new Array(endRow - startRow + 1).fill(void 0).map(() => ({
        h: height,
        hd: 0 /* FALSE */
      }))
      // row height should inherit from the anchor row
    };
    const undoRowInsertionParams = InsertRowMutationUndoFactory(
      accessor,
      insertRowParams
    );
    const redos = [{ id: InsertRowMutation.id, params: insertRowParams }];
    const undos = [{ id: RemoveRowMutation.id, params: undoRowInsertionParams }];
    if (cellValue) {
      redos.push({
        id: SetRangeValuesMutation.id,
        params: {
          unitId,
          subUnitId,
          cellValue
        }
      });
    }
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: InsertRowCommand.id,
      params
    });
    redos.unshift(...(_a2 = intercepted.preRedos) != null ? _a2 : []);
    redos.push(...(_b2 = intercepted.redos) != null ? _b2 : []);
    redos.push(followSelectionOperation(range, workbook, worksheet));
    undos.unshift(...(_c = intercepted.preUndos) != null ? _c : []);
    undos.push(...(_d = intercepted.undos) != null ? _d : []);
    const result = sequenceExecute(redos, commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: params.unitId,
        undoMutations: undos,
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
};
var InsertRowBeforeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-row-before",
  handler: async (accessor) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0];
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, subUnitId, unitId } = target;
    const { startRow, endRow } = range;
    const startColumn = 0;
    const endColumn = worksheet.getColumnCount() - 1;
    const insertRowParams = {
      unitId,
      subUnitId,
      direction: 0 /* UP */,
      range: {
        startRow,
        endRow,
        startColumn,
        endColumn
      },
      // copy styles from the row above
      cellValue: copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, true, startRow - 1)
    };
    return accessor.get(ICommandService).executeCommand(InsertRowCommand.id, insertRowParams);
  }
};
var InsertRowAfterCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-row-after",
  handler: async (accessor) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0];
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const count = range.endRow - range.startRow + 1;
    const startRow = range.endRow + 1;
    const endRow = range.endRow + count;
    const startColumn = 0;
    const endColumn = worksheet.getColumnCount() - 1;
    const insertRowParams = {
      unitId,
      subUnitId,
      direction: 2 /* DOWN */,
      range: {
        startRow,
        endRow,
        startColumn,
        endColumn,
        rangeType: 1 /* ROW */
      },
      // copy styles from the row below
      cellValue: copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, true, range.endRow)
    };
    return accessor.get(ICommandService).executeCommand(InsertRowCommand.id, insertRowParams);
  }
};
var InsertMultiRowsAboveCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-multi-rows-above",
  handler: async (accessor, params) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0];
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const count = params.value || 0;
    const startRow = range.startRow;
    const endRow = range.startRow + count - 1;
    const startColumn = 0;
    const endColumn = worksheet.getColumnCount() - 1;
    const copiedStyle = copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, true, startRow - 1);
    const insertRowParams = {
      unitId,
      subUnitId,
      direction: 0 /* UP */,
      range: {
        startRow,
        endRow,
        startColumn,
        endColumn,
        rangeType: 1 /* ROW */
      },
      // copy styles from the row above
      cellValue: copiedStyle
    };
    return accessor.get(ICommandService).executeCommand(InsertRowCommand.id, insertRowParams);
  }
};
var InsertMultiRowsAfterCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-multi-rows-after",
  handler: async (accessor, params) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0];
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const count = params.value || 0;
    const startRow = range.endRow + 1;
    const endRow = range.endRow + count;
    const startColumn = 0;
    const endColumn = worksheet.getColumnCount() - 1;
    const insertRowParams = {
      unitId,
      subUnitId,
      direction: 2 /* DOWN */,
      range: {
        startRow,
        endRow,
        startColumn,
        endColumn,
        rangeType: 1 /* ROW */
      },
      // copy styles from the row below
      cellValue: copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, true, range.endRow)
    };
    return accessor.get(ICommandService).executeCommand(InsertRowCommand.id, insertRowParams);
  }
};
var InsertColCommandId = "sheet.command.insert-col";
var InsertColCommand = {
  type: 0 /* COMMAND */,
  id: InsertColCommandId,
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const { range, direction, subUnitId, unitId, cellValue } = params;
    const canPerform = await sheetInterceptorService.beforeCommandExecute({
      id: InsertColCommand.id,
      params
    });
    if (!canPerform) {
      return false;
    }
    return commandService.syncExecuteCommand(InsertColByRangeCommand.id, {
      range,
      direction,
      unitId,
      subUnitId,
      cellValue
    });
  }
};
var InsertColByRangeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-col-by-range",
  handler: (accessor, params) => {
    var _a2, _b2, _c, _d;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const { range, direction, subUnitId, unitId, cellValue } = params;
    const { startColumn, endColumn } = params.range;
    range.rangeType = 2 /* COLUMN */;
    const workbook = univerInstanceService.getUniverSheetInstance(params.unitId);
    const worksheet = workbook.getSheetBySheetId(params.subUnitId);
    const anchorCol = direction === 3 /* LEFT */ ? startColumn : startColumn - 1;
    const width = worksheet.getColumnWidth(anchorCol);
    const insertColParams = {
      unitId,
      subUnitId,
      range,
      colInfo: new Array(endColumn - startColumn + 1).fill(void 0).map(() => ({
        w: width,
        hd: 0 /* FALSE */
      }))
    };
    const undoColInsertionParams = InsertColMutationUndoFactory(
      accessor,
      insertColParams
    );
    const redos = [{ id: InsertColMutation.id, params: insertColParams }];
    const undos = [{ id: RemoveColMutation.id, params: undoColInsertionParams }];
    if (cellValue) {
      redos.push({
        id: SetRangeValuesMutation.id,
        params: {
          unitId,
          subUnitId,
          cellValue
        }
      });
    }
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: InsertColCommand.id,
      params
    });
    redos.unshift(...(_a2 = intercepted.preRedos) != null ? _a2 : []);
    redos.push(...(_b2 = intercepted.redos) != null ? _b2 : []);
    redos.push(followSelectionOperation(range, workbook, worksheet));
    undos.unshift(...(_c = intercepted.preUndos) != null ? _c : []);
    undos.push(...(_d = intercepted.undos) != null ? _d : []);
    const result = sequenceExecute(redos, commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: params.unitId,
        undoMutations: undos.filter(Boolean),
        redoMutations: redos.filter(Boolean)
      });
      return true;
    }
    return false;
  }
};
var InsertColBeforeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-col-before",
  handler: async (accessor) => {
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = selectionManagerService.getCurrentSelections();
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0].range;
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const { startColumn, endColumn } = range;
    const startRow = 0;
    const endRow = worksheet.getRowCount() - 1;
    const insertColParams = {
      unitId,
      subUnitId,
      direction: 3 /* LEFT */,
      range: {
        startColumn,
        endColumn,
        startRow,
        endRow,
        rangeType: 2 /* COLUMN */
      },
      // copy styles from the column before
      cellValue: copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, false, startColumn - 1)
    };
    return accessor.get(ICommandService).executeCommand(InsertColCommand.id, insertColParams);
  }
};
var InsertColAfterCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-col-after",
  handler: async (accessor) => {
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = selectionManagerService.getCurrentSelections();
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0].range;
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const count = range.endColumn - range.startColumn + 1;
    const startColumn = range.endColumn + 1;
    const endColumn = range.endColumn + count;
    const startRow = 0;
    const endRow = worksheet.getRowCount() - 1;
    const insertColParams = {
      unitId,
      subUnitId,
      direction: 1 /* RIGHT */,
      range: {
        startColumn,
        endColumn,
        startRow,
        endRow
      },
      // copy styles from the column after
      cellValue: copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, false, range.endColumn)
    };
    return accessor.get(ICommandService).executeCommand(InsertColCommand.id, insertColParams);
  }
};
var InsertMultiColsLeftCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-multi-cols-before",
  handler: async (accessor, params) => {
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = selectionManagerService.getCurrentSelections();
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0].range;
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const count = params.value || 0;
    const startColumn = range.startColumn;
    const endColumn = range.startColumn + count - 1;
    const startRow = 0;
    const endRow = worksheet.getRowCount() - 1;
    const insertColParams = {
      unitId,
      subUnitId,
      direction: 3 /* LEFT */,
      range: {
        startColumn,
        endColumn,
        startRow,
        endRow,
        rangeType: 2 /* COLUMN */
      },
      // copy styles from the column before
      cellValue: copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, false, startColumn - 1)
    };
    return accessor.get(ICommandService).executeCommand(InsertColCommand.id, insertColParams);
  }
};
var InsertMultiColsRightCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.insert-multi-cols-right",
  handler: async (accessor, params) => {
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = selectionManagerService.getCurrentSelections();
    let range;
    if ((selections == null ? void 0 : selections.length) === 1) {
      range = selections[0].range;
    } else {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const count = params.value || 0;
    const startColumn = range.endColumn + 1;
    const endColumn = range.endColumn + count;
    const startRow = 0;
    const endRow = worksheet.getRowCount() - 1;
    const insertColParams = {
      unitId,
      subUnitId,
      direction: 1 /* RIGHT */,
      range: {
        startColumn,
        endColumn,
        startRow,
        endRow
      },
      // copy styles from the column after
      cellValue: copyRangeStyles(worksheet, startRow, endRow, startColumn, endColumn, false, range.endColumn)
    };
    return accessor.get(ICommandService).executeCommand(InsertColCommand.id, insertColParams);
  }
};

// ../packages/sheets/src/commands/commands/insert-sheet.command.ts
var InsertSheetCommand = {
  id: "sheet.command.insert-sheet",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const localeService = accessor.get(LocaleService);
    const target = getSheetCommandTargetWorkbook(univerInstanceService, { unitId: params == null ? void 0 : params.unitId });
    if (!target) return false;
    const { unitId, workbook } = target;
    let index = workbook.getSheets().length;
    const sheet = params == null ? void 0 : params.sheet;
    const sheetId = sheet == null ? void 0 : sheet.id;
    const sheetConfig = mergeWorksheetSnapshotWithDefault(sheet || {});
    if (params) {
      index = (_a2 = params.index) != null ? _a2 : index;
      sheetConfig.id = sheetId || Tools.generateRandomId();
      sheetConfig.name = (sheet == null ? void 0 : sheet.name) || workbook.generateNewSheetName(`${localeService.t("sheets.tabs.sheet")}`);
    } else {
      sheetConfig.id = Tools.generateRandomId();
      sheetConfig.name = workbook.generateNewSheetName(`${localeService.t("sheets.tabs.sheet")}`);
    }
    const insertSheetMutationParams = {
      index,
      sheet: sheetConfig,
      unitId
    };
    const removeSheetMutationParams = InsertSheetUndoMutationFactory(
      accessor,
      insertSheetMutationParams
    );
    const result = commandService.syncExecuteCommand(InsertSheetMutation.id, insertSheetMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: RemoveSheetMutation.id, params: removeSheetMutationParams }],
        redoMutations: [{ id: InsertSheetMutation.id, params: insertSheetMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/move-rows-cols.mutation.ts
function MoveRowsMutationUndoFactory(_accessor, params) {
  const { unitId, subUnitId, sourceRange, targetRange } = params;
  const movingBackward = sourceRange.startRow > targetRange.startRow;
  const count = sourceRange.endRow - sourceRange.startRow + 1;
  if (movingBackward) {
    return {
      unitId,
      subUnitId,
      sourceRange: Rectangle.clone(targetRange),
      targetRange: {
        ...sourceRange,
        endRow: sourceRange.endRow + count,
        startRow: sourceRange.startRow + count
      }
    };
  }
  return {
    unitId,
    subUnitId,
    targetRange: Rectangle.clone(sourceRange),
    sourceRange: {
      ...targetRange,
      endRow: targetRange.endRow - count,
      startRow: targetRange.startRow - count
    }
  };
}
var MoveRowsMutation = {
  id: "sheet.mutation.move-rows",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, sourceRange, targetRange } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const univerSheet = univerInstanceService.getUniverSheetInstance(unitId);
    if (!univerSheet) {
      throw new Error("[MoveRowMutation] univerSheet is null!");
    }
    const worksheet = univerSheet.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      throw new Error("[MoveRowMutation] worksheet is null!");
    }
    const fromRow = sourceRange.startRow;
    const count = sourceRange.endRow - sourceRange.startRow + 1;
    const toRow = targetRange.startRow;
    const rowWrapper = worksheet.getRowManager().getRowData();
    moveMatrixArray(fromRow, count, toRow, rowWrapper);
    const cellMatrix = worksheet.getCellMatrix();
    cellMatrix.moveRows(fromRow, count, toRow);
    return true;
  }
};
function MoveColsMutationUndoFactory(_accessor, params) {
  const { unitId, subUnitId, sourceRange, targetRange } = params;
  const movingBackward = sourceRange.startColumn > targetRange.startColumn;
  const count = sourceRange.endColumn - sourceRange.startColumn + 1;
  if (movingBackward) {
    return {
      unitId,
      subUnitId,
      sourceRange: Rectangle.clone(targetRange),
      targetRange: {
        ...sourceRange,
        endColumn: sourceRange.endColumn + count,
        startColumn: sourceRange.startColumn + count
      }
    };
  }
  return {
    unitId,
    subUnitId,
    targetRange: Rectangle.clone(sourceRange),
    sourceRange: {
      ...targetRange,
      startColumn: targetRange.startColumn - count,
      endColumn: targetRange.endColumn - count
    }
  };
}
var MoveColsMutation = {
  id: "sheet.mutation.move-columns",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, sourceRange, targetRange } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const univerSheet = univerInstanceService.getUniverSheetInstance(unitId);
    if (!univerSheet) {
      throw new Error("[MoveColumnMutation] univerSheet is null!");
    }
    const worksheet = univerSheet.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      throw new Error("[MoveColumnMutation] worksheet is null!");
    }
    const fromCol = sourceRange.startColumn;
    const count = sourceRange.endColumn - sourceRange.startColumn + 1;
    const toCol = targetRange.startColumn;
    const columnWrapper = worksheet.getColumnManager().getColumnData();
    moveMatrixArray(fromCol, count, toCol, columnWrapper);
    const cellMatrix = worksheet.getCellMatrix();
    cellMatrix.moveColumns(fromCol, count, toCol);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/move-rows-cols.command.ts
function rowAcrossMergedCell(row, worksheet) {
  return worksheet.getMergeData().some((mergedCell) => mergedCell.startRow < row && row <= mergedCell.endRow);
}
function columnAcrossMergedCell(col, worksheet) {
  return worksheet.getMergeData().some((mergedCell) => mergedCell.startColumn < col && col <= mergedCell.endColumn);
}
var MoveRowsCommandId = "sheet.command.move-rows";
var MoveRowsCommand = {
  id: MoveRowsCommandId,
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: (accessor, params) => {
    var _a2, _b2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const {
      fromRange: { startRow: fromRow },
      toRange: { startRow: toRow },
      range
    } = params;
    const selections = range ? [covertRangeToSelection(range)] : selectionManagerService.getCurrentSelections();
    const filteredSelections = selections == null ? void 0 : selections.filter(
      (selection) => selection.range.rangeType === 1 /* ROW */ && selection.range.startRow <= fromRow && fromRow <= selection.range.endRow
    );
    if ((filteredSelections == null ? void 0 : filteredSelections.length) !== 1) {
      return false;
    }
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { workbook, worksheet } = target;
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    const errorService = accessor.get(ErrorService);
    const localeService = accessor.get(LocaleService);
    const rangeToMove = filteredSelections[0].range;
    const beforePrimary = filteredSelections[0].primary;
    const alignedRange = alignToMergedCellsBorders(rangeToMove, worksheet, false);
    if (!Rectangle.equals(rangeToMove, alignedRange)) {
      errorService.emit(localeService.t("sheets.info.partOfCell"));
      return false;
    }
    if (rowAcrossMergedCell(toRow, worksheet)) {
      errorService.emit(localeService.t("sheets.info.acrossMergedCell"));
      return false;
    }
    const destinationRange = {
      ...rangeToMove,
      startRow: toRow,
      endRow: toRow + rangeToMove.endRow - rangeToMove.startRow
    };
    const moveRowsParams = {
      unitId,
      subUnitId,
      sourceRange: rangeToMove,
      targetRange: destinationRange
    };
    const undoMoveRowsParams = MoveRowsMutationUndoFactory(accessor, moveRowsParams);
    const commandService = accessor.get(ICommandService);
    const interceptorCommands = sheetInterceptorService.onCommandExecute({ id: MoveRowsCommand.id, params });
    const redos = [
      ...(_a2 = interceptorCommands.preRedos) != null ? _a2 : [],
      { id: MoveRowsMutation.id, params: moveRowsParams }
    ];
    const undos = [
      ...(_b2 = interceptorCommands.preUndos) != null ? _b2 : [],
      { id: MoveRowsMutation.id, params: undoMoveRowsParams }
    ];
    if (beforePrimary) {
      const movedLength = toRow - fromRow;
      const moveBackward = movedLength < 0;
      const count = rangeToMove.endRow - rangeToMove.startRow + 1;
      const destSelection = moveBackward ? destinationRange : {
        ...destinationRange,
        startRow: destinationRange.startRow - count,
        endRow: destinationRange.endRow - count
      };
      const setSelectionsParam = {
        unitId,
        subUnitId,
        type: 2 /* MOVE_END */,
        selections: [{
          range: destSelection,
          primary: getPrimaryForRange(destSelection, worksheet),
          style: null
        }]
      };
      const undoSetSelectionsParam = {
        unitId,
        subUnitId,
        type: 2 /* MOVE_END */,
        selections: [{ range: rangeToMove, primary: beforePrimary, style: null }]
      };
      redos.push({ id: SetSelectionsOperation.id, params: setSelectionsParam });
      undos.push({ id: SetSelectionsOperation.id, params: undoSetSelectionsParam });
    }
    redos.push(...interceptorCommands.redos);
    undos.push(...interceptorCommands.undos);
    const result = sequenceExecute(redos, commandService);
    if (result.result) {
      const undoRedoService = accessor.get(IUndoRedoService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos,
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
};
var MoveColsCommandId = "sheet.command.move-cols";
var MoveColsCommand = {
  id: MoveColsCommandId,
  type: 0 /* COMMAND */,
  // eslint-disable-next-line max-lines-per-function
  handler: (accessor, params) => {
    var _a2, _b2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const {
      fromRange: { startColumn: fromCol },
      toRange: { startColumn: toCol },
      range
    } = params;
    const selections = range ? [covertRangeToSelection(range)] : selectionManagerService.getCurrentSelections();
    const filteredSelections = selections == null ? void 0 : selections.filter(
      (selection) => selection.range.rangeType === 2 /* COLUMN */ && selection.range.startColumn <= fromCol && fromCol <= selection.range.endColumn
    );
    if ((filteredSelections == null ? void 0 : filteredSelections.length) !== 1) {
      return false;
    }
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { workbook, worksheet } = target;
    const unitId = workbook.getUnitId();
    const subUnitId = worksheet.getSheetId();
    const errorService = accessor.get(ErrorService);
    const localeService = accessor.get(LocaleService);
    const rangeToMove = filteredSelections[0].range;
    const beforePrimary = filteredSelections[0].primary;
    const alignedRange = alignToMergedCellsBorders(rangeToMove, worksheet, false);
    if (!Rectangle.equals(rangeToMove, alignedRange)) {
      errorService.emit(localeService.t("sheets.info.partOfCell"));
      return false;
    }
    if (columnAcrossMergedCell(toCol, worksheet)) {
      errorService.emit(localeService.t("sheets.info.acrossMergedCell"));
      return false;
    }
    const destinationRange = {
      ...rangeToMove,
      startColumn: toCol,
      endColumn: toCol + rangeToMove.endColumn - rangeToMove.startColumn
    };
    const moveColsParams = {
      unitId,
      subUnitId,
      sourceRange: rangeToMove,
      targetRange: destinationRange
    };
    const undoMoveColsParams = MoveColsMutationUndoFactory(accessor, moveColsParams);
    const commandService = accessor.get(ICommandService);
    const interceptorCommands = sheetInterceptorService.onCommandExecute({ id: MoveColsCommand.id, params });
    const redos = [
      ...(_a2 = interceptorCommands.preRedos) != null ? _a2 : [],
      { id: MoveColsMutation.id, params: moveColsParams }
    ];
    const undos = [
      ...(_b2 = interceptorCommands.preUndos) != null ? _b2 : [],
      { id: MoveColsMutation.id, params: undoMoveColsParams }
    ];
    if (beforePrimary) {
      const count = rangeToMove.endColumn - rangeToMove.startColumn + 1;
      const movedLength = toCol - fromCol;
      const moveBackward = movedLength < 0;
      const destSelection = moveBackward ? destinationRange : {
        ...destinationRange,
        startColumn: destinationRange.startColumn - count,
        endColumn: destinationRange.endColumn - count
      };
      const setSelectionsParam = {
        unitId,
        subUnitId,
        type: 2 /* MOVE_END */,
        selections: [{ range: destSelection, primary: getPrimaryForRange(destSelection, worksheet), style: null }]
      };
      const undoSetSelectionsParam = {
        unitId,
        subUnitId,
        type: 2 /* MOVE_END */,
        selections: [{ range: rangeToMove, primary: beforePrimary, style: null }]
      };
      redos.push({ id: SetSelectionsOperation.id, params: setSelectionsParam });
      undos.push({ id: SetSelectionsOperation.id, params: undoSetSelectionsParam });
    }
    redos.push(...interceptorCommands.redos);
    undos.push(...interceptorCommands.undos);
    const result = sequenceExecute(redos, commandService);
    if (result.result) {
      const undoRedoService = accessor.get(IUndoRedoService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos,
        redoMutations: redos
      });
      return true;
    }
    return true;
  }
};
function covertRangeToSelection(range) {
  return {
    range,
    primary: null,
    style: null
  };
}

// ../packages/sheets/src/commands/mutations/register-range-theme.mutation.ts
var RegisterWorksheetRangeThemeStyleMutation = {
  id: "sheet.mutation.register-worksheet-range-theme-style",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, rangeThemeStyleJson, themeName } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    const sheetRangeThemeModel = accessor.get(SheetRangeThemeModel);
    if (!target) return false;
    const rangeThemeStyle = new RangeThemeStyle(themeName, rangeThemeStyleJson);
    sheetRangeThemeModel.registerRangeThemeStyle(unitId, rangeThemeStyle);
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/unregister-range-theme-style.mutation.ts
var UnregisterWorksheetRangeThemeStyleMutation = {
  id: "sheet.mutation.unregister-worksheet-range-theme-style",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, themeName } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    const sheetRangeThemeModel = accessor.get(SheetRangeThemeModel);
    if (!target) return false;
    sheetRangeThemeModel.unregisterRangeThemeStyle(unitId, themeName);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/register-range-theme.command.ts
var RegisterWorksheetRangeThemeStyleCommand = {
  id: "sheet.command.register-worksheet-range-theme-style",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const { unitId, rangeThemeStyle } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const redoParam = {
      unitId,
      themeName: rangeThemeStyle.getName(),
      rangeThemeStyleJson: rangeThemeStyle.toJson()
    };
    const undoParam = {
      unitId,
      themeName: rangeThemeStyle.getName()
    };
    const result = commandService.syncExecuteCommand(RegisterWorksheetRangeThemeStyleMutation.id, redoParam);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: UnregisterWorksheetRangeThemeStyleMutation.id, params: undoParam }],
        redoMutations: [{ id: RegisterWorksheetRangeThemeStyleMutation.id, params: redoParam }]
      });
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/remove-defined-name.command.ts
var RemoveDefinedNameCommand = {
  id: "sheet.command.remove-defined-name",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2, _b2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    if (!params) return false;
    const removeSheetMutationParams = {
      ...params
    };
    const interceptorCommands = sheetInterceptorService.onCommandExecute({ id: RemoveDefinedNameCommand.id, params });
    const redos = [
      ...(_a2 = interceptorCommands.preRedos) != null ? _a2 : [],
      { id: RemoveDefinedNameMutation.id, params: removeSheetMutationParams },
      ...interceptorCommands.redos
    ];
    const undos = [
      ...(_b2 = interceptorCommands.preUndos) != null ? _b2 : [],
      { id: SetDefinedNameMutation.id, params: removeSheetMutationParams },
      ...interceptorCommands.undos
    ];
    const result = sequenceExecute(redos, commandService);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: params.unitId,
        undoMutations: undos.filter(Boolean),
        redoMutations: redos.filter(Boolean)
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/remove-row-col.command.ts
var RemoveRowCommandId = "sheet.command.remove-row";
var RemoveRowByRangeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.remove-row-by-range",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { workbook, worksheet } = target;
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const { range, unitId, subUnitId } = params;
    const visibleRanges = getVisibleRanges([range], accessor, unitId, subUnitId).reverse();
    const undoMutations = [];
    const redoMutations = [];
    visibleRanges.forEach((visibleRange) => {
      var _a2, _b2, _c, _d;
      const undos = [];
      const redos = [];
      const removeRowsParams = {
        unitId,
        subUnitId,
        range: visibleRange
      };
      const undoRemoveRowsParams = RemoveRowsUndoMutationFactory(
        removeRowsParams,
        worksheet
      );
      const removedRows = worksheet.getCellMatrix().getSlice(visibleRange.startRow, visibleRange.endRow, 0, worksheet.getColumnCount() - 1);
      const undoSetRangeValuesParams = {
        unitId,
        subUnitId,
        cellValue: removedRows.getMatrix()
      };
      const intercepted = sheetInterceptorService.onCommandExecute({
        id: RemoveRowCommandId,
        params: { range: visibleRange }
      });
      redos.push(...(_a2 = intercepted.preRedos) != null ? _a2 : []);
      redos.push({ id: RemoveRowMutation.id, params: removeRowsParams });
      redos.push(...(_b2 = intercepted.redos) != null ? _b2 : []);
      undos.push(...(_c = intercepted.preUndos) != null ? _c : []);
      undos.push({ id: InsertRowMutation.id, params: undoRemoveRowsParams });
      undos.push({ id: SetRangeValuesMutation.id, params: undoSetRangeValuesParams });
      undos.push(...(_d = intercepted.undos) != null ? _d : []);
      redoMutations.push(...redos);
      undoMutations.unshift(...undos);
    });
    redoMutations.push(followSelectionOperation(range, workbook, worksheet));
    const commandService = accessor.get(ICommandService);
    const result = sequenceExecute(redoMutations, commandService);
    if (result.result) {
      const undoRedoService = accessor.get(IUndoRedoService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations,
        redoMutations
      });
      return true;
    }
    return false;
  }
};
var RemoveRowCommand = {
  type: 0 /* COMMAND */,
  id: RemoveRowCommandId,
  handler: async (accessor, params) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const commandService = accessor.get(ICommandService);
    let range = params == null ? void 0 : params.range;
    if (!range) range = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.range;
    if (!range) return false;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, subUnitId, unitId } = target;
    range = {
      ...range,
      startColumn: 0,
      endColumn: Math.max(worksheet.getMaxColumns() - 1, 0)
    };
    const canPerform = await sheetInterceptorService.beforeCommandExecute({
      id: RemoveRowCommand.id,
      params: { range }
    });
    if (!canPerform) {
      return false;
    }
    return commandService.syncExecuteCommand(RemoveRowByRangeCommand.id, {
      range,
      unitId,
      subUnitId
    });
  }
};
var RemoveColCommandId = "sheet.command.remove-col";
var RemoveColByRangeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.remove-col-by-range",
  handler: (accessor, parmas) => {
    var _a2, _b2, _c;
    if (!parmas) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, parmas);
    if (!target) return false;
    const { workbook, worksheet } = target;
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const { range, unitId, subUnitId } = parmas;
    const removeColParams = {
      unitId,
      subUnitId,
      range
    };
    const undoRemoveColParams = RemoveColMutationFactory(accessor, removeColParams);
    const removedCols = worksheet.getCellMatrix().getSlice(0, worksheet.getRowCount() - 1, range.startColumn, range.endColumn);
    const undoSetRangeValuesParams = {
      unitId,
      subUnitId,
      cellValue: removedCols.getMatrix()
    };
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: RemoveColCommandId,
      params: { range }
    });
    const commandService = accessor.get(ICommandService);
    const result = sequenceExecute(
      [
        ...(_a2 = intercepted.preRedos) != null ? _a2 : [],
        { id: RemoveColMutation.id, params: removeColParams },
        ...intercepted.redos,
        followSelectionOperation(range, workbook, worksheet)
      ],
      commandService
    );
    if (result.result) {
      const undoRedoService = accessor.get(IUndoRedoService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          ...(_b2 = intercepted.preUndos) != null ? _b2 : [],
          { id: InsertColMutation.id, params: undoRemoveColParams },
          { id: SetRangeValuesMutation.id, params: undoSetRangeValuesParams },
          ...intercepted.undos
        ],
        redoMutations: [
          ...(_c = intercepted.preRedos) != null ? _c : [],
          { id: RemoveColMutation.id, params: removeColParams },
          ...intercepted.redos
        ]
      });
      return true;
    }
    return false;
  }
};
var RemoveColCommand = {
  type: 0 /* COMMAND */,
  id: RemoveColCommandId,
  handler: async (accessor, params) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const commandService = accessor.get(ICommandService);
    let range = params == null ? void 0 : params.range;
    if (!range) range = (_a2 = selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.range;
    if (!range) return false;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, subUnitId, unitId } = target;
    range = {
      ...range,
      startRow: 0,
      endRow: Math.max(worksheet.getMaxRows() - 1, 0)
    };
    const canPerform = await sheetInterceptorService.beforeCommandExecute({
      id: RemoveColCommand.id,
      params: { range }
    });
    if (!canPerform) {
      return false;
    }
    return commandService.syncExecuteCommand(RemoveColByRangeCommand.id, {
      range,
      unitId,
      subUnitId
    });
  }
};

// ../packages/sheets/src/commands/commands/remove-sheet.command.ts
var RemoveSheetCommand = {
  id: "sheet.command.remove-sheet",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2, _b2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { unitId, subUnitId, workbook, worksheet } = target;
    if (workbook.getSheets().length <= 1) return false;
    const RemoveSheetMutationParams = {
      subUnitId,
      unitId,
      subUnitName: worksheet.getName()
    };
    const InsertSheetMutationParams = RemoveSheetUndoMutationFactory(
      accessor,
      RemoveSheetMutationParams
    );
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: RemoveSheetCommand.id,
      params: { unitId, subUnitId }
    });
    const redos = [...(_a2 = intercepted.preRedos) != null ? _a2 : [], { id: RemoveSheetMutation.id, params: RemoveSheetMutationParams }, ...intercepted.redos];
    const undos = [...(_b2 = intercepted.preUndos) != null ? _b2 : [], { id: InsertSheetMutation.id, params: InsertSheetMutationParams }, ...intercepted.undos];
    const result = sequenceExecute(redos, commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos,
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/add-worksheet-merge.mutation.ts
var AddMergeUndoMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    ranges: Tools.deepClone(params.ranges)
  };
};
var AddWorksheetMergeMutation = {
  id: "sheet.mutation.add-worksheet-merge",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    const config2 = worksheet.getConfig();
    const mergeConfigData = config2.mergeData;
    const mergeAppendData = params.ranges;
    for (let i = 0; i < mergeAppendData.length; i++) {
      mergeConfigData.push(mergeAppendData[i]);
    }
    worksheet.getSpanModel().rebuild(mergeConfigData);
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/remove-worksheet-merge.mutation.ts
var RemoveMergeUndoMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  const worksheet = universheet.getSheetBySheetId(params.subUnitId);
  if (worksheet == null) {
    throw new Error("worksheet is null error!");
  }
  const config2 = worksheet.getConfig();
  const mergeConfigData = config2.mergeData;
  const mergeRemoveData = params.ranges;
  const ranges = [];
  for (let j = 0; j < mergeRemoveData.length; j++) {
    for (let i = mergeConfigData.length - 1; i >= 0; i--) {
      const configMerge = mergeConfigData[i];
      const removeMerge = mergeRemoveData[j];
      if (Rectangle.intersects(configMerge, removeMerge)) {
        ranges.push(mergeConfigData[i]);
      }
    }
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    ranges
  };
};
var RemoveWorksheetMergeMutation = {
  id: "sheet.mutation.remove-worksheet-merge",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    const config2 = worksheet.getConfig();
    const mergeConfigData = config2.mergeData;
    const mergeRemoveData = params.ranges;
    for (let j = 0; j < mergeRemoveData.length; j++) {
      for (let i = mergeConfigData.length - 1; i >= 0; i--) {
        const configMerge = mergeConfigData[i];
        const removeMerge = mergeRemoveData[j];
        if (Rectangle.intersects(configMerge, removeMerge)) {
          mergeConfigData.splice(i, 1);
        }
      }
    }
    worksheet.getSpanModel().rebuild(mergeConfigData);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/remove-worksheet-merge.command.ts
var RemoveWorksheetMergeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.remove-worksheet-merge",
  // eslint-disable-next-line max-lines-per-function
  handler: (accessor, params) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selections = (params == null ? void 0 : params.ranges) || ((_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range));
    if (!(selections == null ? void 0 : selections.length)) return false;
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { subUnitId, unitId, worksheet } = target;
    const removeMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: selections
    };
    const mergeData = worksheet.getConfig().mergeData;
    const intersectsMerges = mergeData.filter((merge5) => {
      return selections.some((selection) => Rectangle.intersects(selection, merge5));
    });
    if (!intersectsMerges.length) return false;
    const undoredoMutationParams = RemoveMergeUndoMutationFactory(
      accessor,
      removeMergeMutationParams
    );
    const nowSelections = selectionManagerService.getCurrentSelections();
    if (!(nowSelections == null ? void 0 : nowSelections.length)) return false;
    const undoSelections = Tools.deepClone(nowSelections);
    const redoSelections = Tools.deepClone(nowSelections);
    const redoLastSelection = redoSelections[redoSelections.length - 1];
    const { startRow, startColumn } = redoLastSelection.range;
    redoLastSelection.primary = {
      startRow,
      startColumn,
      endRow: startRow,
      endColumn: startColumn,
      actualRow: startRow,
      actualColumn: startColumn,
      isMerged: false,
      isMergedMainCell: false
    };
    const getSetRangeValuesParams = getSetRangeStyleParamsForRemoveMerge(worksheet, intersectsMerges);
    const redoSetRangeValueParams = {
      unitId,
      subUnitId,
      cellValue: getSetRangeValuesParams.redoParams.getMatrix()
    };
    const undoSetRangeValueParams = {
      unitId,
      subUnitId,
      cellValue: getSetRangeValuesParams.undoParams.getMatrix()
    };
    const redoMutations = [
      { id: RemoveWorksheetMergeMutation.id, params: undoredoMutationParams },
      { id: SetRangeValuesMutation.id, params: redoSetRangeValueParams },
      { id: SetSelectionsOperation.id, params: { selections: redoSelections } }
    ];
    const undoMutations = [
      { id: AddWorksheetMergeMutation.id, params: undoredoMutationParams },
      { id: SetRangeValuesMutation.id, params: undoSetRangeValueParams },
      { id: SetSelectionsOperation.id, params: { selections: undoSelections } }
    ];
    const result = sequenceExecute(redoMutations, commandService);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations,
        redoMutations
      });
      return true;
    }
    return false;
  }
};
function getSetRangeStyleParamsForRemoveMerge(worksheet, ranges) {
  const styleRedoMatrix = new ObjectMatrix();
  const styleUndoMatrix = new ObjectMatrix();
  ranges.forEach((range) => {
    const { startRow, startColumn, endColumn, endRow } = range;
    const cellValue = worksheet.getCellMatrix().getValue(startRow, startColumn);
    if (cellValue == null ? void 0 : cellValue.s) {
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          if (i !== startRow || j !== startColumn) {
            styleRedoMatrix.setValue(i, j, { s: cellValue.s });
            styleUndoMatrix.setValue(i, j, null);
          }
        }
      }
    }
  });
  return {
    redoParams: styleRedoMatrix,
    undoParams: styleUndoMatrix
  };
}

// ../packages/sheets/src/commands/mutations/reorder-range.mutation.ts
var ReorderRangeUndoMutationFactory = (params) => {
  const { order } = params;
  const newOrder = {};
  Object.keys(order).forEach((key) => {
    newOrder[order[Number(key)]] = Number(key);
  });
  return {
    ...params,
    order: newOrder
  };
};
var ReorderRangeMutation = {
  id: "sheet.mutation.reorder-range",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { subUnitId, unitId, range, order } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getUnit(unitId);
    const worksheet = workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return false;
    }
    const cellDataMatrix = new ObjectMatrix();
    Range.foreach(range, (row, col) => {
      if (order.hasOwnProperty(row)) {
        const targetRow = order[row];
        const cloneCell = Tools.deepClone(worksheet.getCellRaw(targetRow, col));
        cellDataMatrix.setValue(row, col, cloneCell);
      }
    });
    const worksheetCellDataMatrix = worksheet.getCellMatrix();
    cellDataMatrix.forValue((row, col, cellData) => {
      worksheetCellDataMatrix.setValue(row, col, cellData);
    });
    return true;
  }
};

// ../packages/sheets/src/commands/commands/reorder-range.command.ts
var ReorderRangeCommandId = "sheet.command.reorder-range";
var ReorderRangeCommand = {
  id: ReorderRangeCommandId,
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2, _b2;
    const { subUnitId, unitId, range, order } = params;
    const commandService = accessor.get(ICommandService);
    const reorderMutation = {
      id: ReorderRangeMutation.id,
      params: {
        unitId,
        subUnitId,
        order,
        range
      }
    };
    const undoReorderMutation = {
      id: ReorderRangeMutation.id,
      params: ReorderRangeUndoMutationFactory(reorderMutation.params)
    };
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const interceptorCommands = sheetInterceptorService.onCommandExecute({ id: ReorderRangeCommand.id, params });
    const redos = [
      ...(_a2 = interceptorCommands.preRedos) != null ? _a2 : [],
      reorderMutation,
      ...interceptorCommands.redos
    ];
    const undos = [
      ...(_b2 = interceptorCommands.preUndos) != null ? _b2 : [],
      undoReorderMutation,
      ...interceptorCommands.undos
    ];
    const result = sequenceExecute(redos, commandService);
    const reoderAfterIntercepted = sheetInterceptorService.afterCommandExecute({ id: ReorderRangeCommand.id, params });
    if (result.result) {
      sequenceExecute(reoderAfterIntercepted.redos, commandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [...undos, ...reoderAfterIntercepted.undos],
        redoMutations: [...redos, ...reoderAfterIntercepted.redos]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/services/border-style-manager.service.ts
var import_rxjs34 = __toESM(require_cjs());
var BorderStyleManagerService = class {
  constructor() {
    __publicField(this, "_borderInfo", {
      type: "all" /* ALL */,
      color: "#000000",
      style: 1 /* THIN */,
      activeBorderType: false
    });
    __publicField(this, "_borderInfo$", new import_rxjs34.BehaviorSubject(this._borderInfo));
    __publicField(this, "borderInfo$", this._borderInfo$.asObservable());
  }
  dispose() {
    this._borderInfo$.complete();
  }
  setType(type2) {
    this._borderInfo.type = type2;
    this.setActiveBorderType(true);
    this._refresh();
  }
  setColor(color) {
    this._borderInfo.color = color;
    this._refresh();
  }
  setStyle(style) {
    this._borderInfo.style = style;
    this._refresh();
  }
  setActiveBorderType(status) {
    this._borderInfo.activeBorderType = status;
  }
  getBorderInfo() {
    return this._borderInfo;
  }
  _refresh() {
    this._borderInfo$.next(this._borderInfo);
  }
};

// ../packages/sheets/src/commands/commands/set-border-command.ts
function forEach(range, action) {
  const { startRow, startColumn, endRow, endColumn } = range;
  for (let i = startRow; i <= endRow; i++) {
    for (let j = startColumn; j <= endColumn; j++) {
      action(i, j);
    }
  }
}
var setBorderStyleForRange = (borderContext, range, defaultStyle, reserve) => {
  const { mr, worksheet } = borderContext;
  if (range.startRow < 0 || range.startColumn < 0) return;
  forEach(range, (row, column) => {
    var _a2, _b2;
    const rectangle = worksheet.getMergedCell(row, column);
    let bdStyle = defaultStyle;
    if (rectangle && (defaultStyle.bc_tr || defaultStyle.ml_tr || defaultStyle.bl_tr || defaultStyle.tl_mr || defaultStyle.tl_bc || defaultStyle.tl_br)) {
      if (reserve) {
        const style = Tools.deepClone(
          (_a2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _a2.s
        );
        bdStyle = (style == null ? void 0 : style.bd) ? Object.assign(style.bd, defaultStyle) : defaultStyle;
      }
      mr.setValue(rectangle.startRow, rectangle.startColumn, {
        s: {
          bd: bdStyle
        }
      });
    } else {
      if (reserve) {
        const style = Tools.deepClone((_b2 = mr.getValue(row, column)) == null ? void 0 : _b2.s);
        bdStyle = (style == null ? void 0 : style.bd) ? Object.assign(style.bd, defaultStyle) : defaultStyle;
      }
      mr.setValue(row, column, { s: { bd: bdStyle } });
    }
  });
};
var prepareEdgeRange = (range) => {
  const topRangeOut = {
    startRow: range.startRow - 1,
    startColumn: range.startColumn,
    endRow: range.startRow - 1,
    endColumn: range.endColumn
  };
  const leftRangeOut = {
    startRow: range.startRow,
    startColumn: range.startColumn - 1,
    endRow: range.endRow,
    endColumn: range.startColumn - 1
  };
  const bottomRangeOut = {
    startRow: range.endRow + 1,
    startColumn: range.startColumn,
    endRow: range.endRow + 1,
    endColumn: range.endColumn
  };
  const rightRangeOut = {
    startRow: range.startRow,
    startColumn: range.endColumn + 1,
    endRow: range.endRow,
    endColumn: range.endColumn + 1
  };
  const topRange = {
    startRow: range.startRow,
    startColumn: range.startColumn,
    endRow: range.startRow,
    endColumn: range.endColumn
  };
  const leftRange = {
    startRow: range.startRow,
    startColumn: range.startColumn,
    endRow: range.endRow,
    endColumn: range.startColumn
  };
  const bottomRange = {
    startRow: range.endRow,
    startColumn: range.startColumn,
    endRow: range.endRow,
    endColumn: range.endColumn
  };
  const rightRange = {
    startRow: range.startRow,
    startColumn: range.endColumn,
    endRow: range.endRow,
    endColumn: range.endColumn
  };
  return {
    topRangeOut,
    leftRangeOut,
    bottomRangeOut,
    rightRangeOut,
    topRange,
    leftRange,
    bottomRange,
    rightRange
  };
};
function getBorderContext(borderStyleManagerService, target, selections) {
  const { style, color, type: type2 } = borderStyleManagerService.getBorderInfo();
  const top = type2 === "top" /* TOP */ || type2 === "all" /* ALL */ || type2 === "outside" /* OUTSIDE */;
  const left = type2 === "left" /* LEFT */ || type2 === "all" /* ALL */ || type2 === "outside" /* OUTSIDE */;
  const bottom = type2 === "bottom" /* BOTTOM */ || type2 === "all" /* ALL */ || type2 === "outside" /* OUTSIDE */;
  const right = type2 === "right" /* RIGHT */ || type2 === "all" /* ALL */ || type2 === "outside" /* OUTSIDE */;
  const vertical = type2 === "vertical" /* VERTICAL */ || type2 === "all" /* ALL */ || type2 === "inside" /* INSIDE */;
  const horizontal = type2 === "horizontal" /* HORIZONTAL */ || type2 === "all" /* ALL */ || type2 === "inside" /* INSIDE */;
  const tl_br = type2.indexOf("tlbr") > -1;
  const tl_bc = type2.indexOf("tlbc") > -1;
  const tl_mr = type2.indexOf("tlmr") > -1;
  const bl_tr = type2.indexOf("bltr") > -1;
  const ml_tr = type2.indexOf("mltr") > -1;
  const bc_tr = type2.indexOf("bctr") > -1;
  const range = selections[0];
  const {
    topRangeOut,
    leftRangeOut,
    bottomRangeOut,
    rightRangeOut,
    topRange,
    leftRange,
    bottomRange,
    rightRange
  } = prepareEdgeRange(range);
  const mr = new ObjectMatrix();
  const { worksheet, unitId, subUnitId } = target;
  const borderStyle = {
    s: style,
    cl: {
      rgb: color
    }
  };
  return {
    worksheet,
    unitId,
    subUnitId,
    style,
    color,
    type: type2,
    top,
    left,
    right,
    bottom,
    vertical,
    horizontal,
    tl_br,
    tl_bc,
    tl_mr,
    bl_tr,
    ml_tr,
    bc_tr,
    topRangeOut,
    leftRangeOut,
    bottomRangeOut,
    rightRangeOut,
    topRange,
    leftRange,
    bottomRange,
    rightRange,
    range,
    mr,
    borderStyle
  };
}
var innerBorder = (borderContext) => {
  const { range, mr, borderStyle, vertical, horizontal, worksheet } = borderContext;
  if (vertical) {
    forEach(range, (row, column) => {
      var _a2, _b2, _c;
      const mergedRange = worksheet.getMergedCell(row, column);
      if (mergedRange) {
        const topLeftStyle = (_a2 = mr.getValue(mergedRange.startRow, mergedRange.startColumn)) == null ? void 0 : _a2.s;
        if (mergedRange.startColumn !== range.startColumn) {
          mr.setValue(row, column, {
            s: {
              bd: (topLeftStyle == null ? void 0 : topLeftStyle.bd) ? Object.assign(topLeftStyle.bd, { l: Tools.deepClone(borderStyle) }) : { l: Tools.deepClone(borderStyle) }
            }
          });
        }
      } else {
        if (column !== range.endColumn) {
          const style = (_b2 = mr.getValue(row, column)) == null ? void 0 : _b2.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { r: Tools.deepClone(borderStyle) }) : { r: Tools.deepClone(borderStyle) }
            }
          });
        }
        if (column !== range.startColumn) {
          const style = (_c = mr.getValue(row, column)) == null ? void 0 : _c.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { l: Tools.deepClone(borderStyle) }) : { l: Tools.deepClone(borderStyle) }
            }
          });
        }
      }
    });
  }
  if (horizontal) {
    forEach(range, (row, column) => {
      var _a2, _b2, _c;
      const mergedRange = worksheet.getMergedCell(row, column);
      if (mergedRange) {
        const topLeftStyle = (_a2 = mr.getValue(mergedRange.startRow, mergedRange.startColumn)) == null ? void 0 : _a2.s;
        if (mergedRange.startRow !== range.startRow) {
          mr.setValue(row, column, {
            s: {
              bd: (topLeftStyle == null ? void 0 : topLeftStyle.bd) ? Object.assign(topLeftStyle.bd, { t: Tools.deepClone(borderStyle) }) : { t: Tools.deepClone(borderStyle) }
            }
          });
        }
      } else {
        if (row !== range.endRow) {
          const style = (_b2 = mr.getValue(row, column)) == null ? void 0 : _b2.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { b: Tools.deepClone(borderStyle) }) : { b: Tools.deepClone(borderStyle) }
            }
          });
        }
        if (row !== range.startRow) {
          const style = (_c = mr.getValue(row, column)) == null ? void 0 : _c.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { t: Tools.deepClone(borderStyle) }) : { t: Tools.deepClone(borderStyle) }
            }
          });
        }
      }
    });
  }
};
function otherBorders(borderContext) {
  const { borderStyle, tl_br, tl_bc, tl_mr, bl_tr, ml_tr, bc_tr } = borderContext;
  const setBorderStyle = (range, defaultStyle, reserve) => {
    setBorderStyleForRange(borderContext, range, defaultStyle, reserve);
  };
  if (tl_br) {
    setBorderStyle(borderContext.range, { tl_br: Tools.deepClone(borderStyle) }, true);
  }
  if (tl_bc) {
    setBorderStyle(borderContext.range, { tl_bc: Tools.deepClone(borderStyle) }, true);
  }
  if (tl_mr) {
    setBorderStyle(borderContext.range, { tl_mr: Tools.deepClone(borderStyle) }, true);
  }
  if (bl_tr) {
    setBorderStyle(borderContext.range, { bl_tr: Tools.deepClone(borderStyle) }, true);
  }
  if (ml_tr) {
    setBorderStyle(borderContext.range, { ml_tr: Tools.deepClone(borderStyle) }, true);
  }
  if (bc_tr) {
    setBorderStyle(borderContext.range, { bc_tr: Tools.deepClone(borderStyle) }, true);
  }
}
var outlineBorder = (borderContext) => {
  const { top, left, right, bottom, borderStyle, bottomRange, topRange, leftRange, rightRange, bottomRangeOut, topRangeOut, leftRangeOut, rightRangeOut } = borderContext;
  const setBorderStyle = (range, defaultStyle, reserve) => {
    setBorderStyleForRange(borderContext, range, defaultStyle, reserve);
  };
  if (top) {
    setBorderStyle(topRangeOut, { b: null });
    setBorderStyle(topRange, { t: Tools.deepClone(borderStyle) }, true);
  }
  if (bottom) {
    setBorderStyle(bottomRangeOut, { t: null });
    setBorderStyle(bottomRange, { b: Tools.deepClone(borderStyle) }, true);
  }
  if (left) {
    setBorderStyle(leftRangeOut, { r: null });
    setBorderStyle(leftRange, { l: Tools.deepClone(borderStyle) }, true);
  }
  if (right) {
    setBorderStyle(rightRangeOut, { l: null });
    setBorderStyle(rightRange, { r: Tools.deepClone(borderStyle) }, true);
  }
};
var clearBorder = (borderContext) => {
  const { range, worksheet, mr, top, bottom, left, right, vertical, horizontal, tl_br, tl_bc, tl_mr, bl_tr, ml_tr, bc_tr, topRange, bottomRange, leftRange, rightRange, topRangeOut, bottomRangeOut, leftRangeOut, rightRangeOut } = borderContext;
  const setBorderStyle = (range2, defaultStyle, reserve) => {
    setBorderStyleForRange(borderContext, range2, defaultStyle, reserve);
  };
  if (!top && !bottom && !left && !right && !vertical && !horizontal && !tl_br && !tl_bc && !tl_mr && !bl_tr && !ml_tr && !bc_tr) {
    forEach(range, (row, column) => {
      var _a2, _b2, _c, _d, _e, _f, _g, _h;
      const mergedRange = worksheet.getMergedCell(row, column);
      if (mergedRange) {
        if (mergedRange.endColumn !== range.endColumn) {
          const style = (_a2 = mr.getValue(mergedRange.startRow, mergedRange.startColumn)) == null ? void 0 : _a2.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { r: null }) : { r: null }
            }
          });
        }
        if (mergedRange.startColumn !== range.startColumn) {
          const style = (_b2 = mr.getValue(mergedRange.startRow, mergedRange.startColumn)) == null ? void 0 : _b2.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { l: null }) : { l: null }
            }
          });
        }
        if (mergedRange.endRow !== range.endRow) {
          const style = (_c = mr.getValue(mergedRange.startRow, mergedRange.startColumn)) == null ? void 0 : _c.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { b: null }) : { b: null }
            }
          });
        }
        if (mergedRange.startRow !== range.startRow) {
          const style = (_d = mr.getValue(mergedRange.startRow, mergedRange.startColumn)) == null ? void 0 : _d.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { t: null }) : { t: null }
            }
          });
        }
      } else {
        if (column !== range.endColumn) {
          const style = (_e = mr.getValue(row, column)) == null ? void 0 : _e.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { r: null }) : { r: null }
            }
          });
        }
        if (column !== range.startColumn) {
          const style = (_f = mr.getValue(row, column)) == null ? void 0 : _f.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { l: null }) : { l: null }
            }
          });
        }
        if (row !== range.endRow) {
          const style = (_g = mr.getValue(row, column)) == null ? void 0 : _g.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { b: null }) : { b: null }
            }
          });
        }
        if (row !== range.startRow) {
          const style = (_h = mr.getValue(row, column)) == null ? void 0 : _h.s;
          mr.setValue(row, column, {
            s: {
              bd: (style == null ? void 0 : style.bd) ? Object.assign(style.bd, { t: null }) : { t: null }
            }
          });
        }
      }
    });
    setBorderStyle(topRangeOut, { b: null });
    setBorderStyle(topRange, { t: null }, true);
    setBorderStyle(bottomRangeOut, { t: null });
    setBorderStyle(bottomRange, { b: null }, true);
    setBorderStyle(leftRangeOut, { r: null });
    setBorderStyle(leftRange, { l: null }, true);
    setBorderStyle(rightRangeOut, { l: null });
    setBorderStyle(rightRange, { r: null }, true);
    setBorderStyle(range, { tl_br: null }, true);
    setBorderStyle(range, { tl_bc: null }, true);
    setBorderStyle(range, { tl_mr: null }, true);
    setBorderStyle(range, { bl_tr: null }, true);
    setBorderStyle(range, { ml_tr: null }, true);
    setBorderStyle(range, { bc_tr: null }, true);
  }
};
var SetBorderCommand = {
  id: "sheet.command.set-border",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const borderStyleManagerService = accessor.get(BorderStyleManagerService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const ranges = (params == null ? void 0 : params.ranges) || ((_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range));
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const { activeBorderType } = borderStyleManagerService.getBorderInfo();
    if (!activeBorderType) return false;
    const borderContext = getBorderContext(borderStyleManagerService, target, ranges);
    innerBorder(borderContext);
    outlineBorder(borderContext);
    otherBorders(borderContext);
    clearBorder(borderContext);
    const { unitId, subUnitId, mr } = borderContext;
    const setRangeValuesMutationParams = {
      unitId,
      subUnitId,
      cellValue: mr.getData()
    };
    const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      setRangeValuesMutationParams
    );
    const result = commandService.syncExecuteCommand(SetRangeValuesMutation.id, setRangeValuesMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams }],
        redoMutations: [{ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }]
      });
      return true;
    }
    return false;
  }
};
var SetBorderPositionCommand = {
  id: "sheet.command.set-border-position",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params.value) return false;
    const commandService = accessor.get(ICommandService);
    const borderManager = accessor.get(BorderStyleManagerService);
    borderManager.setType(params.value);
    return commandService.syncExecuteCommand(SetBorderCommand.id);
  }
};
var SetBorderStyleCommand = {
  id: "sheet.command.set-border-style",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const borderManager = accessor.get(BorderStyleManagerService);
    borderManager.setStyle(params.value);
    return commandService.syncExecuteCommand(SetBorderCommand.id);
  }
};
var SetBorderColorCommand = {
  id: "sheet.command.set-border-color",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const borderManager = accessor.get(BorderStyleManagerService);
    borderManager.setColor(params.value);
    return commandService.syncExecuteCommand(SetBorderCommand.id);
  }
};
var SetBorderBasicCommand = {
  id: "sheet.command.set-border-basic",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, value, ranges } = params;
    const { type: type2, color, style } = value;
    const commandService = accessor.get(ICommandService);
    const borderManager = accessor.get(BorderStyleManagerService);
    borderManager.setType(type2);
    if (color) borderManager.setColor(color);
    borderManager.setStyle(style);
    return commandService.syncExecuteCommand(SetBorderCommand.id, {
      unitId,
      subUnitId,
      ranges
    });
  }
};

// ../packages/sheets/src/basics/row-column-value.ts
function getOldRowData(currentRow, newRow) {
  if (currentRow === null || currentRow === void 0) {
    return currentRow;
  }
  const row = Tools.deepClone(currentRow);
  if (newRow === null || newRow === void 0) {
    return row;
  }
  const oldRow = {};
  if ("h" in newRow) {
    oldRow.h = row.h;
  }
  if ("ia" in newRow) {
    oldRow.ia = row.ia;
  }
  if ("ah" in newRow) {
    oldRow.ah = row.ah;
  }
  if ("hd" in newRow) {
    oldRow.hd = row.hd;
  }
  if ("s" in newRow) {
    oldRow.s = row.s;
  }
  if ("custom" in newRow) {
    oldRow.custom = row.custom;
  }
  return oldRow;
}
function getOldColumnData(currenColumn, newColumn) {
  if (currenColumn === null || currenColumn === void 0) {
    return currenColumn;
  }
  const column = Tools.deepClone(currenColumn);
  if (newColumn === null || newColumn === void 0) {
    return column;
  }
  const oldColumn = {};
  if ("w" in newColumn) {
    oldColumn.w = column.w;
  }
  if ("hd" in newColumn) {
    oldColumn.hd = column.hd;
  }
  if ("s" in newColumn) {
    oldColumn.s = column.s;
  }
  if ("custom" in newColumn) {
    oldColumn.custom = column.custom;
  }
  return oldColumn;
}

// ../packages/sheets/src/commands/mutations/set-col-data.mutation.ts
var SetColDataMutationFactory = (params, worksheet) => {
  const { unitId, subUnitId, columnData } = params;
  const oldColData = {};
  const manager = worksheet.getColumnManager();
  for (const colIndex in columnData) {
    const newCol = columnData[colIndex];
    const currentCol = manager.getColumn(Number(colIndex));
    oldColData[colIndex] = getOldColumnData(currentCol, newCol);
  }
  return {
    unitId,
    subUnitId,
    columnData: oldColData
  };
};
var SetColDataMutation = {
  id: "sheet.mutation.set-col-data",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { columnData } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { worksheet } = target;
    const manager = worksheet.getColumnManager();
    for (const colIndex in columnData) {
      const col = columnData[colIndex];
      if (col === null || col === void 0) {
        manager.removeColumn(Number(colIndex));
        continue;
      }
      const currentCol = manager.getColumnOrCreate(Number(colIndex));
      Object.assign(currentCol, col);
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-col-data.command.ts
var SetColDataCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-col-data",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { columnData } = params;
    const { unitId, subUnitId, worksheet } = target;
    const redoMutationParams = {
      subUnitId,
      unitId,
      columnData
    };
    const undoMutationParams = SetColDataMutationFactory(redoMutationParams, worksheet);
    const result = commandService.syncExecuteCommand(SetColDataMutation.id, redoMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetColDataMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetColDataMutation.id, params: redoMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-col-visible.mutation.ts
var SetColHiddenUndoMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    ranges: params.ranges
  };
};
var SetColHiddenMutation = {
  id: "sheet.mutation.set-col-hidden",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (!universheet) {
      return false;
    }
    const manager = universheet.getSheetBySheetId(params.subUnitId).getColumnManager();
    for (let i = 0; i < params.ranges.length; i++) {
      const range = params.ranges[i];
      for (let j = range.startColumn; j < range.endColumn + 1; j++) {
        const column = manager.getColumnOrCreate(j);
        if (column != null) {
          column.hd = 1 /* TRUE */;
        }
      }
    }
    return true;
  }
};
var SetColVisibleUndoMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    ranges: params.ranges
  };
};
var SetColVisibleMutation = {
  id: "sheet.mutation.set-col-visible",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (!universheet) {
      return false;
    }
    const manager = universheet.getSheetBySheetId(params.subUnitId).getColumnManager();
    for (let i = 0; i < params.ranges.length; i++) {
      const range = params.ranges[i];
      for (let j = range.startColumn; j < range.endColumn + 1; j++) {
        const column = manager.getColumnOrCreate(j);
        if (column != null) {
          column.hd = 0 /* FALSE */;
        }
      }
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-col-visible.command.ts
var SetSpecificColsVisibleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-col-visible-on-cols",
  handler: (accessor, params) => {
    var _a2, _b2;
    const { unitId, subUnitId, ranges } = params;
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const commandService = accessor.get(ICommandService);
    const instanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(instanceService, { unitId, subUnitId });
    if (!target) return false;
    const { worksheet } = target;
    const redoMutationParams = {
      unitId,
      subUnitId,
      ranges
    };
    const setSelectionOperationParams = {
      unitId,
      subUnitId,
      reveal: true,
      selections: ranges.map((r) => ({ range: r, primary: getPrimaryForRange(r, worksheet), style: null }))
    };
    const undoMutationParams = SetColVisibleUndoMutationFactory(accessor, redoMutationParams);
    const undoSetSelectionsOperationParams = {
      unitId,
      subUnitId,
      selections: getSelectionsAfterHiding(ranges).map((range) => ({
        range,
        primary: getPrimaryForRange(range, worksheet),
        style: null
      }))
    };
    const result = sequenceExecute([
      { id: SetColVisibleMutation.id, params: redoMutationParams },
      { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
    ], commandService);
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: SetSpecificColsVisibleCommand.id,
      params
    });
    const interceptedResult = sequenceExecute([...intercepted.redos], commandService);
    if (result.result && interceptedResult.result) {
      const undoRedoService = accessor.get(IUndoRedoService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          { id: SetColHiddenMutation.id, params: undoMutationParams },
          { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams },
          ...(_a2 = intercepted.undos) != null ? _a2 : []
        ],
        redoMutations: [
          ...(_b2 = intercepted.preRedos) != null ? _b2 : [],
          { id: SetColVisibleMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams },
          ...intercepted.redos
        ]
      });
      return true;
    }
    return true;
  }
};
var SetSelectedColsVisibleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-selected-cols-visible",
  handler: (accessor) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const commandService = accessor.get(ICommandService);
    const ranges = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range).filter((r) => r.rangeType === 2 /* COLUMN */);
    if (!(ranges == null ? void 0 : ranges.length)) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const hiddenRanges = ranges.map((r) => worksheet.getHiddenCols(r.startColumn, r.endColumn)).flat();
    return commandService.executeCommand(SetSpecificColsVisibleCommand.id, {
      unitId,
      subUnitId,
      ranges: hiddenRanges
    });
  }
};
var SetColHiddenCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-col-hidden",
  handler: (accessor, params) => {
    var _a2, _b2, _c, _d;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    let ranges = ((_a2 = params == null ? void 0 : params.ranges) == null ? void 0 : _a2.length) ? params.ranges : (_b2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _b2.map((s) => s.range).filter((r) => r.rangeType === 2 /* COLUMN */);
    if (!(ranges == null ? void 0 : ranges.length)) return false;
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    ranges = divideRangesByHiddenCols(target.worksheet, ranges);
    const redoMutationParams = { unitId, subUnitId, ranges };
    const setSelectionOperationParams = {
      unitId,
      subUnitId,
      selections: getSelectionsAfterHiding(ranges).map((range) => ({
        range,
        primary: getPrimaryForRange(range, worksheet),
        style: null
      }))
    };
    const undoMutationParams = SetColHiddenUndoMutationFactory(accessor, redoMutationParams);
    const undoSetSelectionsOperationParams = {
      unitId,
      subUnitId,
      reveal: true,
      selections: ranges.map((range) => ({
        range,
        primary: getPrimaryForRange(range, worksheet),
        style: null
      }))
    };
    const result = sequenceExecute([
      { id: SetColHiddenMutation.id, params: redoMutationParams },
      { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
    ], commandService);
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: SetColHiddenCommand.id,
      params: redoMutationParams
    });
    const interceptedResult = sequenceExecute([...intercepted.redos], commandService);
    if (result.result && interceptedResult.result) {
      const undoRedoService = accessor.get(IUndoRedoService);
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          { id: SetColVisibleMutation.id, params: undoMutationParams },
          { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams },
          ...(_c = intercepted.undos) != null ? _c : []
        ],
        redoMutations: [
          ...(_d = intercepted.preRedos) != null ? _d : [],
          { id: SetColHiddenMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams },
          ...intercepted.redos
        ]
      });
      return true;
    }
    return false;
  }
};
function divideRangesByHiddenCols(worksheet, ranges) {
  const endRow = worksheet.getRowCount() - 1;
  const hiddenCols = worksheet.getHiddenCols();
  const divided = [];
  ranges.forEach((range) => {
    const hiddenColsInSelection = hiddenCols.filter((c) => c.startColumn >= range.startColumn && c.endColumn <= range.endColumn);
    if (hiddenColsInSelection.length) {
      let startColumn = range.startColumn;
      hiddenColsInSelection.forEach((hiddenRange) => {
        if (hiddenRange.startColumn > startColumn) {
          divided.push({ startColumn, endColumn: hiddenRange.startColumn - 1, startRow: 0, endRow });
          startColumn = hiddenRange.endColumn + 1;
        }
      });
      if (startColumn <= range.endColumn) {
        divided.push({ startColumn, endColumn: range.endColumn, startRow: 0, endRow });
      }
    } else {
      divided.push(range);
    }
  });
  return divided;
}
function getSelectionsAfterHiding(ranges) {
  const merged = mergeSelections(ranges);
  return merged.map((range) => {
    const column = range.startColumn === 0 ? range.endColumn + 1 : range.startColumn - 1;
    return {
      ...range,
      startColumn: column,
      endColumn: column
    };
  });
}
function mergeSelections(ranges) {
  const merged = [];
  let current;
  ranges.sort((a2, b) => a2.startColumn - b.startColumn).forEach((range) => {
    if (!current) {
      current = range;
      return;
    }
    if (current.endColumn === range.startColumn - 1) {
      current.endColumn = range.endColumn;
    } else {
      merged.push(current);
      current = range;
    }
  });
  merged.push(current);
  return merged;
}

// ../packages/sheets/src/commands/commands/set-defined-name.command.ts
var SetDefinedNameCommand = {
  id: "sheet.command.set-defined-name",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2, _b2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    if (!params) return false;
    const newDefinedNameMutationParams = {
      ...params
    };
    const oldDefinedNameMutationParams = SetDefinedNameMutationFactory(accessor, params);
    const interceptorCommands = sheetInterceptorService.onCommandExecute({ id: SetDefinedNameCommand.id, params });
    const redos = [
      ...(_a2 = interceptorCommands.preRedos) != null ? _a2 : [],
      { id: RemoveDefinedNameMutation.id, params: oldDefinedNameMutationParams },
      { id: SetDefinedNameMutation.id, params: newDefinedNameMutationParams },
      ...interceptorCommands.redos
    ];
    const undos = [
      ...(_b2 = interceptorCommands.preUndos) != null ? _b2 : [],
      { id: RemoveDefinedNameMutation.id, params: newDefinedNameMutationParams },
      { id: SetDefinedNameMutation.id, params: oldDefinedNameMutationParams },
      ...interceptorCommands.undos
    ];
    const result = sequenceExecute(redos, commandService);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: params.unitId,
        undoMutations: undos.filter(Boolean),
        redoMutations: redos.filter(Boolean)
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-frozen.mutation.ts
var SetFrozenMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  const worksheet = universheet.getSheetBySheetId(params.subUnitId);
  if (worksheet == null) {
    throw new Error("worksheet is null error!");
  }
  const config2 = worksheet.getConfig();
  const freeze = config2.freeze;
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    ...freeze
  };
};
var SetFrozenMutation = {
  id: "sheet.mutation.set-frozen",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    const config2 = worksheet.getConfig();
    const { startRow, startColumn, ySplit, xSplit } = params;
    config2.freeze = { startRow, startColumn, ySplit, xSplit };
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-frozen.command.ts
var SetFrozenCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-frozen",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, { unitId: params.unitId, subUnitId: params.subUnitId });
    if (!target) return false;
    const { unitId, subUnitId, worksheet } = target;
    const { startColumn, startRow, xSplit, ySplit } = params;
    if (startRow >= worksheet.getRowCount() || startColumn >= worksheet.getColumnCount() || xSplit >= worksheet.getColumnCount() || ySplit >= worksheet.getRowCount()) {
      return false;
    }
    const redoMutationParams = {
      unitId,
      subUnitId,
      ...params
    };
    const undoMutationParams = SetFrozenMutationFactory(accessor, redoMutationParams);
    const result = commandService.syncExecuteCommand(SetFrozenMutation.id, redoMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetFrozenMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetFrozenMutation.id, params: redoMutationParams }]
      });
      return true;
    }
    return false;
  }
};
var CancelFrozenCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.cancel-frozen",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(univerInstanceService, { unitId: params == null ? void 0 : params.unitId, subUnitId: params == null ? void 0 : params.subUnitId });
    if (!target) return false;
    const { unitId, subUnitId } = target;
    const redoMutationParams = {
      unitId,
      subUnitId,
      startRow: -1,
      startColumn: -1,
      xSplit: 0,
      ySplit: 0
    };
    const undoMutationParams = SetFrozenMutationFactory(accessor, redoMutationParams);
    const result = commandService.syncExecuteCommand(SetFrozenMutation.id, redoMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetFrozenMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetFrozenMutation.id, params: redoMutationParams }]
      });
      return true;
    }
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/set-gridlines-color.mutation.ts
var SetGridlinesColorMutation = {
  id: "sheet.mutation.set-gridlines-color",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { worksheet } = target;
    const config2 = worksheet.getConfig();
    config2.gridlinesColor = params.color;
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-gridlines-color.command.ts
var SetGridlinesColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-gridlines-color",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    const currentlyColor = worksheet.getConfig().gridlinesColor;
    if (currentlyColor === (params == null ? void 0 : params.color)) return false;
    const { unitId, subUnitId } = target;
    const doParams = {
      color: params == null ? void 0 : params.color,
      unitId,
      subUnitId
    };
    const undoMutationParams = {
      color: currentlyColor,
      unitId,
      subUnitId
    };
    const result = commandService.syncExecuteCommand(SetGridlinesColorMutation.id, doParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetGridlinesColorMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetGridlinesColorMutation.id, params: doParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-range-protection.mutation.ts
var SetRangeProtectionMutation = {
  id: "sheet.mutation.set-range-protection",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, rule, ruleId } = params;
    const selectionProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
    selectionProtectionRuleModel.setRule(unitId, subUnitId, ruleId, rule);
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-protection.mutation.ts
var SetWorksheetProtectionMutation = {
  id: "sheet.mutation.set-worksheet-protection",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { unitId, subUnitId, rule } = params;
    const worksheetProtectionRuleModel = accessor.get(WorksheetProtectionRuleModel);
    worksheetProtectionRuleModel.setRule(unitId, subUnitId, rule);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-protection.command.ts
var SetProtectionCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-protection",
  async handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const rangeProtectionRuleModel = accessor.get(RangeProtectionRuleModel);
    const { rule, oldRule } = params;
    const { unitId, subUnitId } = rule;
    const redoMutations = [];
    const undoMutations = [];
    if ((oldRule == null ? void 0 : oldRule.unitType) === rule.unitType) {
      if (rule.unitType === a.Worksheet) {
        redoMutations.push({ id: SetWorksheetProtectionMutation.id, params: { unitId, subUnitId, rule } });
        undoMutations.push({ id: SetWorksheetProtectionMutation.id, params: { unitId, subUnitId, rule: oldRule } });
      } else {
        redoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule, ruleId: rule.id } });
        undoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, ruleId: oldRule.id, rule: oldRule } });
      }
    } else {
      if (oldRule) {
        if (oldRule.unitType === a.Worksheet) {
          redoMutations.push({ id: DeleteWorksheetProtectionMutation.id, params: { unitId, subUnitId } });
          undoMutations.push({ id: AddWorksheetProtectionMutation.id, params: { unitId, rule: oldRule, subUnitId: oldRule.subUnitId } });
        } else if (oldRule.unitType === a.SelectRange) {
          redoMutations.push({ id: DeleteRangeProtectionMutation.id, params: { unitId, subUnitId, ruleIds: [oldRule.id] } });
          undoMutations.push({ id: AddRangeProtectionMutation.id, params: { unitId, subUnitId, rules: [oldRule] } });
        }
      }
      if (rule.unitType === a.Worksheet) {
        redoMutations.push({ id: AddWorksheetProtectionMutation.id, params: { unitId, rule, subUnitId: rule.subUnitId } });
        undoMutations.unshift({ id: DeleteWorksheetProtectionMutation.id, params: { unitId, subUnitId } });
      } else if (rule.unitType === a.SelectRange) {
        rule.id = rangeProtectionRuleModel.createRuleId(unitId, subUnitId);
        redoMutations.push({ id: AddRangeProtectionMutation.id, params: { unitId, subUnitId, rules: [rule] } });
        undoMutations.unshift({ id: DeleteRangeProtectionMutation.id, params: { unitId, subUnitId, ruleIds: [rule.id] } });
      }
    }
    const result = sequenceExecute(redoMutations, commandService);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations,
        redoMutations
      });
    }
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/set-row-data.mutation.ts
var SetRowDataMutationFactory = (params, worksheet) => {
  const { unitId, subUnitId, rowData } = params;
  const oldRowData = {};
  const manager = worksheet.getRowManager();
  for (const rowIndex in rowData) {
    const newRow = rowData[rowIndex];
    const currentRow = manager.getRow(Number(rowIndex));
    oldRowData[rowIndex] = getOldRowData(currentRow, newRow);
  }
  return {
    unitId,
    subUnitId,
    rowData: oldRowData
  };
};
var SetRowDataMutation = {
  id: "sheet.mutation.set-row-data",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { rowData } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { worksheet } = target;
    const manager = worksheet.getRowManager();
    for (const rowIndex in rowData) {
      const row = rowData[rowIndex];
      if (row === null || row === void 0) {
        manager.removeRow(Number(rowIndex));
        continue;
      }
      const currentRow = manager.getRowOrCreate(Number(rowIndex));
      Object.assign(currentRow, row);
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-row-data.command.ts
var SetRowDataCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-row-data",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { rowData } = params;
    const { unitId, subUnitId, worksheet } = target;
    const redoMutationParams = {
      subUnitId,
      unitId,
      rowData
    };
    const undoMutationParams = SetRowDataMutationFactory(redoMutationParams, worksheet);
    const result = commandService.syncExecuteCommand(SetRowDataMutation.id, redoMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetRowDataMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetRowDataMutation.id, params: redoMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-row-visible.mutation.ts
var SetRowVisibleUndoMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    ranges: params.ranges
  };
};
var SetRowVisibleMutation = {
  id: "sheet.mutation.set-row-visible",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const manager = universheet.getSheetBySheetId(params.subUnitId).getRowManager();
    for (let i = 0; i < params.ranges.length; i++) {
      const range = params.ranges[i];
      for (let j = range.startRow; j < range.endRow + 1; j++) {
        const row = manager.getRowOrCreate(j);
        if (row != null) {
          row.hd = 0;
        }
      }
    }
    return true;
  }
};
var SetRowHiddenUndoMutationFactory = (accessor, params) => {
  const univerInstanceService = accessor.get(IUniverInstanceService);
  const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
  if (universheet == null) {
    throw new Error("universheet is null error!");
  }
  return {
    unitId: params.unitId,
    subUnitId: params.subUnitId,
    ranges: params.ranges
  };
};
var SetRowHiddenMutation = {
  id: "sheet.mutation.set-row-hidden",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const manager = universheet.getSheetBySheetId(params.subUnitId).getRowManager();
    for (let i = 0; i < params.ranges.length; i++) {
      const range = params.ranges[i];
      for (let j = range.startRow; j < range.endRow + 1; j++) {
        const row = manager.getRowOrCreate(j);
        if (row != null) {
          row.hd = 1;
        }
      }
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-row-visible.command.ts
var SetSpecificRowsVisibleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-specific-rows-visible",
  handler: (accessor, params) => {
    var _a2, _b2, _c;
    const { unitId, subUnitId, ranges } = params;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), { unitId, subUnitId });
    if (!target) return false;
    const { worksheet } = target;
    const redoMutationParams = { unitId, subUnitId, ranges };
    const setSelectionOperationParams = {
      unitId,
      subUnitId,
      reveal: true,
      selections: ranges.map((range) => ({
        range,
        primary: getPrimaryForRange(range, worksheet),
        style: null
      }))
    };
    const undoMutationParams = SetRowVisibleUndoMutationFactory(accessor, redoMutationParams);
    const undoSetSelectionsOperationParams = {
      unitId,
      subUnitId,
      selections: getSelectionsAfterHiding2(ranges).map((range) => ({
        range,
        primary: getPrimaryForRange(range, worksheet),
        style: null
      }))
    };
    const result = sequenceExecute(
      [
        { id: SetRowVisibleMutation.id, params: redoMutationParams },
        { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
      ],
      commandService
    );
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: SetSpecificRowsVisibleCommand.id,
      params
    });
    const interceptedResult = sequenceExecute([...intercepted.redos], commandService);
    if (result.result && interceptedResult.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          ...(_a2 = intercepted.preUndos) != null ? _a2 : [],
          { id: SetRowHiddenMutation.id, params: undoMutationParams },
          { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams },
          ...(_b2 = intercepted.undos) != null ? _b2 : []
        ],
        redoMutations: [
          ...(_c = intercepted.preRedos) != null ? _c : [],
          { id: SetRowVisibleMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams },
          ...intercepted.redos
        ]
      });
      return true;
    }
    return true;
  }
};
var SetSelectedRowsVisibleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-selected-rows-visible",
  handler: async (accessor) => {
    var _a2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const ranges = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range).filter((r) => r.rangeType === 1 /* ROW */);
    if (!(ranges == null ? void 0 : ranges.length)) return false;
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const hiddenRanges = ranges.map((r) => worksheet.getHiddenRows(r.startRow, r.endRow)).flat();
    return commandService.executeCommand(SetSpecificRowsVisibleCommand.id, {
      unitId,
      subUnitId,
      ranges: hiddenRanges
    });
  }
};
var SetRowHiddenCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-rows-hidden",
  handler: (accessor, params) => {
    var _a2, _b2, _c, _d, _e, _f;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    let ranges = ((_a2 = params == null ? void 0 : params.ranges) == null ? void 0 : _a2.length) ? params.ranges : (_b2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _b2.map((s) => s.range).filter((r) => r.rangeType === 1 /* ROW */);
    if (!(ranges == null ? void 0 : ranges.length)) return false;
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    ranges = divideRangesByHiddenRows(target.worksheet, ranges);
    const { unitId, subUnitId, worksheet } = target;
    const redoMutationParams = { unitId, subUnitId, ranges };
    const setSelectionOperationParams = {
      unitId,
      subUnitId,
      selections: getSelectionsAfterHiding2(ranges).map((range) => ({
        range,
        primary: getPrimaryForRange(range, worksheet),
        style: null
      }))
    };
    const undoMutationParams = SetRowHiddenUndoMutationFactory(accessor, redoMutationParams);
    const undoSetSelectionsOperationParams = {
      unitId,
      subUnitId,
      reveal: true,
      selections: ranges.map((range) => ({
        range,
        primary: getPrimaryForRange(range, worksheet),
        style: null
      }))
    };
    const intercepted = sheetInterceptorService.onCommandExecute({ id: SetRowHiddenCommand.id, params: redoMutationParams });
    const execution = sequenceExecute([
      ...(_c = intercepted.preRedos) != null ? _c : [],
      { id: SetRowHiddenMutation.id, params: redoMutationParams },
      { id: SetSelectionsOperation.id, params: setSelectionOperationParams },
      ...intercepted.redos
    ], commandService);
    if (execution.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          ...(_d = intercepted.preUndos) != null ? _d : [],
          { id: SetRowVisibleMutation.id, params: undoMutationParams },
          { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams },
          ...(_e = intercepted.undos) != null ? _e : []
        ],
        redoMutations: [
          ...(_f = intercepted.preRedos) != null ? _f : [],
          { id: SetRowHiddenMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams },
          ...intercepted.redos
        ]
      });
      return true;
    }
    return true;
  }
};
function divideRangesByHiddenRows(worksheet, ranges) {
  const endCol = worksheet.getMaxColumns() - 1;
  const hiddenRows = worksheet.getHiddenRows();
  const divided = [];
  ranges.forEach((range) => {
    const hiddenRowsInThisRange = hiddenRows.filter((r) => r.startRow >= range.startRow && r.endRow <= range.endRow);
    if (hiddenRowsInThisRange.length) {
      let startRow = range.startRow;
      hiddenRowsInThisRange.forEach((hiddenRange) => {
        if (hiddenRange.startRow > startRow) {
          divided.push({ startRow, endRow: hiddenRange.startRow - 1, startColumn: 0, endColumn: endCol });
          startRow = hiddenRange.endRow + 1;
        }
      });
      if (startRow <= range.endRow) {
        divided.push({ startRow, endRow: range.endRow, startColumn: 0, endColumn: endCol });
      }
    } else {
      divided.push(range);
    }
  });
  return divided;
}
function getSelectionsAfterHiding2(ranges) {
  const merged = mergeSelections2(ranges);
  return merged.map((range) => {
    const row = range.startRow === 0 ? range.endRow + 1 : range.startRow - 1;
    return {
      ...range,
      startRow: row,
      endRow: row
    };
  });
}
function mergeSelections2(ranges) {
  const merged = [];
  let current;
  ranges.sort((a2, b) => a2.startRow - b.startRow).forEach((range) => {
    if (!current) {
      current = range;
      return;
    }
    if (range.startRow === current.endRow + 1) {
      current.endRow = range.endRow;
    } else {
      merged.push(current);
      current = range;
    }
  });
  merged.push(current);
  return merged;
}

// ../packages/sheets/src/commands/commands/set-style.command.ts
var SetStyleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-style",
  handler: (accessor, params) => {
    var _a2;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { unitId, subUnitId, worksheet } = target;
    const { range, style } = params;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const ranges = range ? [range] : (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const cellValue = new ObjectMatrix();
    const iterator = createRangeIteratorWithSkipFilteredRows(worksheet);
    if (Tools.isArray(style.value)) {
      for (let i = 0; i < ranges.length; i++) {
        iterator.forOperableEach(ranges[i], (r, c, range2) => {
          cellValue.setValue(r, c, {
            s: {
              [style.type]: style.value[r - range2.startRow][c - range2.startColumn]
            }
          });
        });
      }
    } else {
      for (let i = 0; i < ranges.length; i++) {
        const styleObj = {
          s: {
            [style.type]: style.value
          }
        };
        iterator.forOperableEach(ranges[i], (r, c) => cellValue.setValue(r, c, styleObj));
      }
    }
    const setRangeValuesMutationParams = {
      subUnitId,
      unitId,
      cellValue: cellValue.getMatrix()
    };
    const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      setRangeValuesMutationParams
    );
    const setRangeValuesResult = commandService.syncExecuteCommand(
      SetRangeValuesMutation.id,
      setRangeValuesMutationParams
    );
    const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
      id: SetStyleCommand.id,
      params
    });
    const result = sequenceExecute([...redos], commandService);
    if (setRangeValuesResult && result.result) {
      undoRedoService.pushUndoRedo({
        unitID: setRangeValuesMutationParams.unitId,
        undoMutations: [{ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams }, ...undos],
        redoMutations: [{ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }, ...redos]
      });
      return true;
    }
    return false;
  }
};
var SetBoldCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-bold",
  handler: (accessor) => {
    const selection = accessor.get(SheetsSelectionsService).getCurrentLastSelection();
    if (!selection) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet } = target;
    const { actualRow, actualColumn } = selection.primary;
    const currentlyBold = worksheet.getRange(actualRow, actualColumn).getFontWeight() === 1 /* BOLD */;
    const setStyleParams = {
      style: {
        type: "bl",
        value: currentlyBold ? 0 /* FALSE */ : 1 /* TRUE */
      }
    };
    return accessor.get(ICommandService).syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetItalicCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-italic",
  handler: (accessor) => {
    const selection = accessor.get(SheetsSelectionsService).getCurrentLastSelection();
    if (!selection) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet } = target;
    let currentlyItalic = true;
    if (selection.primary) {
      const { startRow, startColumn } = selection.primary;
      currentlyItalic = worksheet.getRange(startRow, startColumn).getFontStyle() === 1 /* ITALIC */;
    }
    const setStyleParams = {
      style: {
        type: "it",
        value: currentlyItalic ? 0 /* FALSE */ : 1 /* TRUE */
      }
    };
    return accessor.get(ICommandService).syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetUnderlineCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-underline",
  handler: (accessor) => {
    const selection = accessor.get(SheetsSelectionsService).getCurrentLastSelection();
    if (!selection) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet } = target;
    let currentlyUnderline = true;
    if (selection.primary) {
      currentlyUnderline = !!worksheet.getRange(selection.primary.startRow, selection.primary.startColumn).getUnderline().s;
    }
    const setStyleParams = {
      style: {
        type: "ul",
        value: {
          s: currentlyUnderline ? 0 /* FALSE */ : 1 /* TRUE */
        }
      }
    };
    return accessor.get(ICommandService).syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetStrikeThroughCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-stroke",
  handler: (accessor) => {
    const selection = accessor.get(SheetsSelectionsService).getCurrentLastSelection();
    if (!selection) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet } = target;
    let currentlyStrokeThrough = true;
    if (selection.primary) {
      currentlyStrokeThrough = !!worksheet.getRange(selection.primary.actualRow, selection.primary.actualColumn).getStrikeThrough().s;
    }
    const setStyleParams = {
      style: {
        type: "st",
        value: { s: currentlyStrokeThrough ? 0 /* FALSE */ : 1 /* TRUE */ }
      }
    };
    return accessor.get(ICommandService).syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetOverlineCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-overline",
  handler: (accessor) => {
    const selection = accessor.get(SheetsSelectionsService).getCurrentLastSelection();
    if (!selection) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet } = target;
    let currentlyOverline = true;
    if (selection.primary) {
      currentlyOverline = !!worksheet.getRange(selection.primary.startRow, selection.primary.startColumn).getOverline().s;
    }
    const setStyleParams = {
      style: {
        type: "ol",
        value: {
          s: currentlyOverline ? 0 /* FALSE */ : 1 /* TRUE */
        }
      }
    };
    return accessor.get(ICommandService).syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetFontFamilyCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-font-family",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      style: {
        type: "ff",
        value: params.value
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetFontSizeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-font-size",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      style: {
        type: "fs",
        value: params.value
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetTextColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-text-color",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      style: {
        type: "cl",
        value: {
          rgb: params.value
        }
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var ResetTextColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.reset-text-color",
  handler: (accessor) => {
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      style: {
        type: "cl",
        value: {
          rgb: null
          // use null to reset text color
        }
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetBackgroundColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-background-color",
  handler: (accessor, params) => {
    if (!params || !params.value) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      style: {
        type: "bg",
        value: {
          rgb: params.value
        }
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var ResetBackgroundColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.reset-background-color",
  handler: (accessor) => {
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      style: {
        type: "bg",
        value: {
          rgb: null
          // use null to reset background color
        }
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetVerticalTextAlignCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-vertical-text-align",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range,
      style: {
        type: "vt",
        value: params.value
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetHorizontalTextAlignCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-horizontal-text-align",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range,
      style: {
        type: "ht",
        value: params.value
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetTextWrapCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-text-wrap",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range,
      style: {
        type: "tb",
        value: params.value
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};
var SetTextRotationCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-text-rotation",
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const value = typeof params.value === "number" ? { a: params.value } : { a: 0, v: 1 /* TRUE */ };
    const commandService = accessor.get(ICommandService);
    const setStyleParams = {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range,
      style: {
        type: "tr",
        value
      }
    };
    return commandService.syncExecuteCommand(SetStyleCommand.id, setStyleParams);
  }
};

// ../packages/sheets/src/commands/mutations/set-tab-color.mutation.ts
var SetTabColorUndoMutationFactory = (accessor, params) => {
  const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
  const worksheet = workbook.getSheetBySheetId(params.subUnitId);
  const config2 = worksheet.getConfig();
  const oldTabColor = config2.tabColor;
  return {
    ...Tools.deepClone(params),
    color: oldTabColor
  };
};
var SetTabColorMutation = {
  id: "sheet.mutation.set-tab-color",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
    if (!workbook) return false;
    const worksheet = workbook.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    worksheet.getConfig().tabColor = params.color;
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-tab-color.command.ts
var SetTabColorCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-tab-color",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { unitId, subUnitId } = target;
    const setTabColorMutationParams = {
      color: params.value,
      unitId,
      subUnitId
    };
    const undoMutationParams = SetTabColorUndoMutationFactory(accessor, setTabColorMutationParams);
    const result = commandService.syncExecuteCommand(SetTabColorMutation.id, setTabColorMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetTabColorMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetTabColorMutation.id, params: setTabColorMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-workbook-name.mutation.ts
var SetWorkbookNameMutation = {
  id: "sheet.mutation.set-workbook-name",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const workbook = accessor.get(IUniverInstanceService).getUnit(params.unitId, O.UNIVER_SHEET);
    if (!workbook) return false;
    workbook.setName(params.name);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-workbook-name.command.ts
var SetWorkbookNameCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-workbook-name",
  handler: async (accessor, params) => {
    var _a2;
    const instanceService = accessor.get(IUniverInstanceService);
    const workbook = instanceService.getUnit(params.unitId, O.UNIVER_SHEET);
    if (!workbook) return false;
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const interceptedCommands = sheetInterceptorService.onCommandExecute({
      id: SetWorkbookNameCommand.id,
      params
    });
    const redoMutationParams = {
      name: params.name,
      unitId: params.unitId
    };
    const redos = [
      ...(_a2 = interceptedCommands.preRedos) != null ? _a2 : [],
      { id: SetWorkbookNameMutation.id, params: redoMutationParams },
      ...interceptedCommands.redos
    ];
    const commandService = accessor.get(ICommandService);
    return sequenceExecute(redos, commandService).result;
  }
};

// ../packages/sheets/src/commands/operations/set-worksheet-active.operation.ts
var SetWorksheetActiveOperation = {
  id: "sheet.operation.set-worksheet-active",
  type: 1 /* OPERATION */,
  handler: (accessor, params) => {
    const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
    if (!workbook) return false;
    const worksheets = workbook.getWorksheets();
    for (const [, worksheet] of worksheets) {
      if (worksheet.getSheetId() === params.subUnitId) {
        workbook.setActiveSheet(worksheet);
        return true;
      }
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-activate.command.ts
var SET_WORKSHEET_ACTIVE_DELAY = 4;
var SetWorksheetActivateCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-activate",
  handler: (accessor, params, options) => {
    const commandService = accessor.get(ICommandService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    return new Promise((resolve) => {
      setTimeout(() => {
        const result = commandService.syncExecuteCommand(SetWorksheetActiveOperation.id, {
          unitId,
          subUnitId
        }, options);
        resolve(result);
      }, SET_WORKSHEET_ACTIVE_DELAY);
    });
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-col-width.mutation.ts
var SetWorksheetColWidthMutationFactory = (params, worksheet) => {
  const { unitId, subUnitId, ranges } = params;
  const colWidth = {};
  const manager = worksheet.getColumnManager();
  for (let i = 0; i < ranges.length; i++) {
    const range = ranges[i];
    for (let j = range.startColumn; j < range.endColumn + 1; j++) {
      const column = manager.getColumnOrCreate(j);
      colWidth[j] = column.w;
    }
  }
  return {
    unitId,
    subUnitId,
    ranges,
    colWidth
  };
};
var SetWorksheetColWidthMutation = {
  id: "sheet.mutation.set-worksheet-col-width",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    var _a2;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { worksheet } = target;
    const defaultColumnWidth = worksheet.getConfig().defaultColumnWidth;
    const manager = worksheet.getColumnManager();
    const ranges = params.ranges;
    for (let i = 0; i < ranges.length; i++) {
      const range = ranges[i];
      for (let j = range.startColumn; j < range.endColumn + 1; j++) {
        const visible = worksheet.getColVisible(j);
        if (!visible) continue;
        const column = manager.getColumnOrCreate(j);
        if (typeof params.colWidth === "number") {
          column.w = params.colWidth;
        } else {
          column.w = (_a2 = params.colWidth[j]) != null ? _a2 : defaultColumnWidth;
        }
      }
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-col-width.command.ts
var DeltaColumnWidthCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delta-column-width",
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = selectionManagerService.getCurrentSelections();
    if (!(selections == null ? void 0 : selections.length)) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet, unitId, subUnitId } = target;
    const { anchorCol, deltaX } = params;
    const anchorColWidth = worksheet.getColumnWidth(anchorCol);
    const destColumnWidth = anchorColWidth + deltaX;
    const isAllSheetRange = selections.length === 1 && selections[0].range.rangeType === 3 /* ALL */;
    const colSelections = selections.filter((s) => s.range.rangeType === 2 /* COLUMN */);
    const rangeType = isAllSheetRange ? 3 /* ALL */ : colSelections.some(({ range }) => {
      const { startColumn, endColumn } = range;
      return startColumn <= anchorCol && anchorCol <= endColumn;
    }) ? 2 /* COLUMN */ : 0 /* NORMAL */;
    let redoMutationParams;
    if (rangeType === 3 /* ALL */) {
      const rowCount = worksheet.getRowCount();
      const allColRanges = new Array(worksheet.getColumnCount()).fill(void 0).map(
        (_, index) => ({ startRow: 0, endRow: rowCount - 1, startColumn: index, endColumn: index })
      );
      redoMutationParams = {
        subUnitId,
        unitId,
        colWidth: destColumnWidth,
        ranges: allColRanges
      };
    } else if (rangeType === 2 /* COLUMN */) {
      redoMutationParams = {
        subUnitId,
        unitId,
        ranges: colSelections.map((s) => Rectangle.clone(s.range)),
        colWidth: destColumnWidth
      };
    } else {
      redoMutationParams = {
        subUnitId,
        unitId,
        colWidth: destColumnWidth,
        ranges: [
          {
            startRow: 0,
            endRow: worksheet.getMaxRows() - 1,
            startColumn: anchorCol,
            endColumn: anchorCol
          }
        ]
      };
    }
    const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
      id: DeltaColumnWidthCommand.id,
      params: redoMutationParams
    });
    const undoMutationParams = SetWorksheetColWidthMutationFactory(
      redoMutationParams,
      worksheet
    );
    const setColWidthResult = commandService.syncExecuteCommand(
      SetWorksheetColWidthMutation.id,
      redoMutationParams
    );
    const result = sequenceExecute([...redos], commandService);
    if (setColWidthResult && result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetWorksheetColWidthMutation.id, params: undoMutationParams }, ...undos],
        redoMutations: [{ id: SetWorksheetColWidthMutation.id, params: redoMutationParams }, ...redos]
      });
      return true;
    }
    return true;
  }
};
var SetColWidthCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-col-width",
  handler: (accessor, params) => {
    var _a2, _b2, _c, _d;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const selections = ((_a2 = params == null ? void 0 : params.ranges) == null ? void 0 : _a2.length) ? params.ranges : (_b2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _b2.map((s) => s.range);
    if (!(selections == null ? void 0 : selections.length)) return false;
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { subUnitId, unitId, worksheet } = target;
    const redoMutationParams = {
      subUnitId,
      unitId,
      ranges: selections,
      colWidth: params.value
    };
    const undoMutationParams = SetWorksheetColWidthMutationFactory(redoMutationParams, worksheet);
    const setColWidthResult = commandService.syncExecuteCommand(SetWorksheetColWidthMutation.id, redoMutationParams);
    const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
      id: SetColWidthCommand.id,
      params: redoMutationParams
    });
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: SetColWidthCommand.id,
      params: redoMutationParams
    });
    const result = sequenceExecute([...redos, ...intercepted.redos], commandService);
    if (setColWidthResult && result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [...(_c = intercepted.preUndos) != null ? _c : [], { id: SetWorksheetColWidthMutation.id, params: undoMutationParams }, ...undos],
        redoMutations: [...(_d = intercepted.preRedos) != null ? _d : [], { id: SetWorksheetColWidthMutation.id, params: redoMutationParams }, ...redos]
      });
      return true;
    }
    return false;
  }
};
var SetWorksheetColIsAutoWidthCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-col-is-auto-width",
  handler: async (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    let ranges = [];
    if (params == null ? void 0 : params.ranges) {
      ranges = [...params.ranges];
    } else {
      const selections = selectionManagerService.getCurrentSelections();
      for (let i = 0; i < selections.length; i++) {
        ranges.push(selections[i].range);
      }
    }
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const redoMutationParams = {
      unitId,
      subUnitId,
      ranges
    };
    const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
      id: SetWorksheetColIsAutoWidthCommand.id,
      params: redoMutationParams
    });
    const result = sequenceExecute([...redos], commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [...undos],
        redoMutations: [...redos]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-default-style.mutation.ts
var SetWorksheetDefaultStyleMutation = {
  id: "sheet.mutation.set-worksheet-default-style",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { defaultStyle } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    if (!worksheet) {
      return false;
    }
    worksheet.setDefaultCellStyle(defaultStyle);
    return true;
  }
};
var SetWorksheetDefaultStyleMutationFactory = (accessor, params) => {
  const target = getSheetMutationTarget(accessor.get(IUniverInstanceService), params);
  if (!target) {
    throw new Error("[SetWorksheetDefaultStyleMutationFactory]: worksheet is null error!");
  }
  const { worksheet } = target;
  return {
    unitId: params.unitId,
    subUnitId: worksheet.getSheetId(),
    defaultStyle: worksheet.getDefaultCellStyle()
  };
};

// ../packages/sheets/src/commands/commands/set-worksheet-default-style.command.ts
var SetWorksheetDefaultStyleCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-default-style",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { unitId } = params;
    const undoMutationParams = SetWorksheetDefaultStyleMutationFactory(accessor, params);
    const result = commandService.syncExecuteCommand(SetWorksheetDefaultStyleMutation.id, params);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetWorksheetDefaultStyleMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetWorksheetDefaultStyleMutation.id, params }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-hide.mutation.ts
var SetWorksheetHideMutationFactory = (accessor, params) => {
  const target = getSheetMutationTarget(accessor.get(IUniverInstanceService), params);
  if (!target) {
    throw new Error("[SetWorksheetHideMutationFactory]: worksheet is null error!");
  }
  const { worksheet } = target;
  return {
    hidden: worksheet.isSheetHidden(),
    unitId: params.unitId,
    subUnitId: worksheet.getSheetId()
  };
};
var SetWorksheetHideMutation = {
  id: "sheet.mutation.set-worksheet-hidden",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const universheet = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      return false;
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) {
      return false;
    }
    worksheet.getConfig().hidden = params.hidden;
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-hide.command.ts
var SetWorksheetHideCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-hidden",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const errorService = accessor.get(ErrorService);
    const localeService = accessor.get(LocaleService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { workbook, worksheet, unitId, subUnitId } = target;
    const hidden = worksheet.getConfig().hidden;
    if (hidden === 1 /* TRUE */) return false;
    const redoMutationParams = {
      unitId,
      subUnitId,
      hidden: 1 /* TRUE */
    };
    const undoMutationParams = SetWorksheetHideMutationFactory(accessor, redoMutationParams);
    const worksheets = workbook.getSheets();
    const visibleWorksheets = worksheets.filter((sheet) => sheet.getConfig().hidden === 0 /* FALSE */);
    if (visibleWorksheets.length === 1) {
      errorService.emit(localeService.t("sheets.info.hideSheet"));
      return false;
    }
    const result = commandService.syncExecuteCommand(SetWorksheetHideMutation.id, redoMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetWorksheetHideMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetWorksheetHideMutation.id, params: redoMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-name.mutation.ts
var SetWorksheetNameMutationFactory = (accessor, params) => {
  const target = getSheetMutationTarget(accessor.get(IUniverInstanceService), params);
  if (!target) {
    throw new Error("[SetWorksheetNameMutationFactory]: worksheet is null error!");
  }
  const { worksheet } = target;
  return {
    unitId: params.unitId,
    name: worksheet.getName(),
    subUnitId: worksheet.getSheetId()
  };
};
var SetWorksheetNameMutation = {
  id: "sheet.mutation.set-worksheet-name",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const universheet = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      return false;
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (!worksheet) {
      return false;
    }
    worksheet.getConfig().name = params.name;
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-name.command.ts
var SetWorksheetNameCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-name",
  handler: (accessor, params) => {
    var _a2, _b2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    const redoMutationParams = {
      subUnitId,
      name: params.name,
      unitId
    };
    const undoMutationParams = SetWorksheetNameMutationFactory(
      accessor,
      redoMutationParams
    );
    const interceptorCommands = sheetInterceptorService.onCommandExecute({
      id: SetWorksheetNameCommand.id,
      params
    });
    const redos = [
      ...(_a2 = interceptorCommands.preRedos) != null ? _a2 : [],
      { id: SetWorksheetNameMutation.id, params: redoMutationParams },
      ...interceptorCommands.redos
    ];
    const undos = [
      ...(_b2 = interceptorCommands.preUndos) != null ? _b2 : [],
      { id: SetWorksheetNameMutation.id, params: undoMutationParams },
      ...interceptorCommands.undos
    ];
    const result = sequenceExecute(redos, commandService).result;
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: undos,
        redoMutations: redos
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-order.mutation.ts
var SetWorksheetOrderUndoMutationFactory = (accessor, params) => {
  return {
    ...Tools.deepClone(params),
    toOrder: params.fromOrder,
    fromOrder: params.toOrder
  };
};
var SetWorksheetOrderMutation = {
  id: "sheet.mutation.set-worksheet-order",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
    if (!workbook) return false;
    const config2 = workbook.getConfig();
    config2.sheetOrder.splice(params.fromOrder, 1);
    config2.sheetOrder.splice(params.toOrder, 0, params.subUnitId);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-order.command.ts
var SetWorksheetOrderCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-order",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { workbook, unitId, subUnitId } = target;
    const fromOrder = workbook.getConfig().sheetOrder.indexOf(subUnitId);
    const setWorksheetOrderMutationParams = {
      fromOrder,
      toOrder: params.order,
      unitId,
      subUnitId
    };
    const undoMutationParams = SetWorksheetOrderUndoMutationFactory(accessor, setWorksheetOrderMutationParams);
    const result = commandService.syncExecuteCommand(SetWorksheetOrderMutation.id, setWorksheetOrderMutationParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetWorksheetOrderMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: SetWorksheetOrderMutation.id, params: setWorksheetOrderMutationParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/services/permission/worksheet-permission/worksheet-permission-point.model.ts
var import_rxjs35 = __toESM(require_cjs());
var WorksheetProtectionPointModel = class {
  constructor() {
    __publicField(this, "_model", /* @__PURE__ */ new Map());
    __publicField(this, "_pointChange", new import_rxjs35.Subject());
    __publicField(this, "pointChange$", this._pointChange.asObservable());
  }
  addRule(rule) {
    const subUnitMap = this._ensureSubUnitMap(rule.unitId);
    subUnitMap.set(rule.subUnitId, rule);
    this._pointChange.next(rule);
  }
  deleteRule(unitId, subUnitId) {
    var _a2, _b2, _c;
    const rule = (_a2 = this._model.get(unitId)) == null ? void 0 : _a2.get(subUnitId);
    if (rule) {
      (_c = (_b2 = this._model) == null ? void 0 : _b2.get(unitId)) == null ? void 0 : _c.delete(subUnitId);
      this._pointChange.next(rule);
    }
  }
  getRule(unitId, subUnitId) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._model) == null ? void 0 : _a2.get(unitId)) == null ? void 0 : _b2.get(subUnitId);
  }
  toObject() {
    const result = {};
    const unitKeys = [...this._model.keys()];
    unitKeys.forEach((unitId) => {
      const subUnitMap = this._model.get(unitId);
      if (subUnitMap == null ? void 0 : subUnitMap.size) {
        result[unitId] = [];
        const subUnitKeys = [...subUnitMap.keys()];
        subUnitKeys.forEach((subUnitId) => {
          const rule = subUnitMap.get(subUnitId);
          if (rule) {
            result[unitId].push(rule);
          }
        });
      }
    });
    return result;
  }
  fromObject(obj) {
    const result = /* @__PURE__ */ new Map();
    Object.keys(obj).forEach((unitId) => {
      const subUnitList = obj[unitId];
      if (subUnitList == null ? void 0 : subUnitList.length) {
        const subUnitMap = /* @__PURE__ */ new Map();
        subUnitList.forEach((rule) => {
          subUnitMap.set(rule.subUnitId, rule);
        });
        result.set(unitId, subUnitMap);
      }
    });
    this._model = result;
  }
  deleteUnitModel(unitId) {
    this._model.delete(unitId);
  }
  _ensureSubUnitMap(unitId) {
    let subUnitMap = this._model.get(unitId);
    if (!subUnitMap) {
      subUnitMap = /* @__PURE__ */ new Map();
      this._model.set(unitId, subUnitMap);
    }
    return subUnitMap;
  }
  getTargetByPermissionId(unitId, permissionId) {
    const subUnitMap = this._model.get(unitId);
    if (!subUnitMap) return null;
    for (const [subUnitId, rule] of subUnitMap) {
      if (rule.permissionId === permissionId) {
        return [unitId, subUnitId];
      }
    }
  }
};

// ../packages/sheets/src/services/permission/worksheet-permission/worksheet-permission.service.ts
var import_operators4 = __toESM(require_operators());

// ../packages/sheets/src/services/permission/permission-point/range/delete-protection.ts
var RangeProtectionPermissionDeleteProtectionPoint = class {
  constructor(unitId, subUnitId, permissionId) {
    __publicField(this, "type", a.SelectRange);
    __publicField(this, "subType", D.Delete);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "value", true);
    __publicField(this, "id");
    __publicField(this, "unitId");
    __publicField(this, "subUnitId");
    __publicField(this, "permissionId");
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    this.permissionId = permissionId;
    this.id = `${a.SelectRange}.${D.Delete}.${permissionId}`;
  }
};

// ../packages/sheets/src/services/permission/permission-point/range/manage-collaborator.ts
var RangeProtectionPermissionManageCollaPoint = class {
  constructor(unitId, subUnitId, permissionId) {
    __publicField(this, "type", a.SelectRange);
    __publicField(this, "subType", D.ManageCollaborator);
    __publicField(this, "status", "init" /* INIT */);
    __publicField(this, "value", true);
    __publicField(this, "id");
    __publicField(this, "unitId");
    __publicField(this, "subUnitId");
    __publicField(this, "permissionId");
    this.unitId = unitId;
    this.subUnitId = subUnitId;
    this.permissionId = permissionId;
    this.id = `${a.SelectRange}.${D.ManageCollaborator}.${permissionId}`;
  }
};

// ../packages/sheets/src/services/permission/range-permission/util.ts
var getAllRangePermissionPoint = () => [RangeProtectionPermissionViewPoint, RangeProtectionPermissionEditPoint, RangeProtectionPermissionManageCollaPoint, RangeProtectionPermissionDeleteProtectionPoint];
var baseProtectionActions = [D.Edit, D.View, D.ManageCollaborator, D.Delete];

// ../packages/sheets/src/services/permission/workbook-permission/util.ts
var getAllWorkbookPermissionPoint = () => [
  WorkbookEditablePermission,
  WorkbookPrintPermission,
  WorkbookCommentPermission,
  WorkbookViewPermission,
  WorkbookCopyPermission,
  WorkbookExportPermission,
  WorkbookManageCollaboratorPermission,
  WorkbookCreateSheetPermission,
  WorkbookDeleteSheetPermission,
  WorkbookRenameSheetPermission,
  WorkbookHideSheetPermission,
  WorkbookDuplicatePermission,
  WorkbookSharePermission,
  WorkbookMoveSheetPermission,
  WorkbookCopySheetPermission,
  WorkbookViewHistoryPermission,
  WorkbookRecoverHistoryPermission,
  WorkbookCreateProtectPermission
];
var defaultWorkbookPermissionPoints = [
  D.Edit,
  D.Print,
  D.Comment,
  D.View,
  D.Copy,
  D.Export,
  D.ManageCollaborator,
  D.CreateSheet,
  D.DeleteSheet,
  D.RenameSheet,
  D.HideSheet,
  D.Duplicate,
  D.Share,
  D.MoveSheet,
  D.CopySheet,
  D.RecoverHistory,
  D.ViewHistory,
  D.CreatePermissionObject
];

// ../packages/sheets/src/services/permission/worksheet-permission/utils.ts
var getAllWorksheetPermissionPoint = () => [
  WorksheetEditPermission,
  WorksheetViewPermission,
  WorksheetManageCollaboratorPermission,
  WorksheetDeleteProtectionPermission
];
var getAllWorksheetPermissionPointByPointPanel = () => [
  WorksheetCopyPermission,
  WorksheetDeleteColumnPermission,
  WorksheetDeleteRowPermission,
  WorksheetEditExtraObjectPermission,
  WorksheetFilterPermission,
  WorksheetInsertColumnPermission,
  WorksheetInsertRowPermission,
  WorksheetInsertHyperlinkPermission,
  WorksheetPivotTablePermission,
  WorksheetSetCellStylePermission,
  WorksheetSetCellValuePermission,
  WorksheetSetColumnStylePermission,
  WorksheetSetRowStylePermission,
  WorksheetSortPermission
];
var defaultWorksheetPermissionPoint = [
  D.Copy,
  D.DeleteColumn,
  D.DeleteRow,
  D.EditExtraObject,
  D.Filter,
  D.InsertColumn,
  D.InsertRow,
  D.InsertHyperlink,
  D.PivotTable,
  D.SetCellStyle,
  D.SetCellValue,
  D.SetColumnStyle,
  D.SetRowStyle,
  D.Sort
];

// ../packages/sheets/src/services/permission/worksheet-permission/worksheet-permission.service.ts
var RULE_MODEL_PLUGIN_NAME = "SHEET_WORKSHEET_PROTECTION_PLUGIN";
var POINT_MODEL_PLUGIN_NAME = "SHEET_WORKSHEET_PROTECTION_POINT_PLUGIN";
var WorksheetPermissionService = class extends RxDisposable {
  constructor(_permissionService, _univerInstanceService, _injector, _worksheetProtectionRuleModel, _worksheetProtectionPointRuleModel, _resourceManagerService, _rangeProtectionRuleModel, _logService) {
    super();
    this._permissionService = _permissionService;
    this._univerInstanceService = _univerInstanceService;
    this._injector = _injector;
    this._worksheetProtectionRuleModel = _worksheetProtectionRuleModel;
    this._worksheetProtectionPointRuleModel = _worksheetProtectionPointRuleModel;
    this._resourceManagerService = _resourceManagerService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._logService = _logService;
    this._init();
    this._initRuleChange();
    this._initRuleSnapshot();
    this._initPointSnapshot();
  }
  _init() {
    const handleWorkbook = (workbook) => {
      const unitId = workbook.getUnitId();
      const handleWorksheet = (worksheet) => {
        const subUnitId = worksheet.getSheetId();
        [...getAllWorksheetPermissionPoint(), ...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
          const instance = new F(unitId, subUnitId);
          this._permissionService.addPermissionPoint(instance);
        });
        this._logService.debug("[WorksheetPermissionService]", "Initialization completed", unitId, subUnitId);
      };
      workbook.getSheets().forEach((worksheet) => {
        handleWorksheet(worksheet);
      });
      workbook.sheetCreated$.subscribe((worksheet) => {
        handleWorksheet(worksheet);
      });
      workbook.sheetDisposed$.subscribe((worksheet) => {
        const subUnitId = worksheet.getSheetId();
        const rangeRuleList = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
        rangeRuleList.forEach((rule) => {
          [...getAllRangePermissionPoint()].forEach((F) => {
            const instance = new F(unitId, subUnitId, rule.permissionId);
            this._permissionService.deletePermissionPoint(instance.id);
          });
        });
        [...getAllWorksheetPermissionPoint(), ...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
          const instance = new F(unitId, subUnitId);
          this._permissionService.deletePermissionPoint(instance.id);
        });
      });
    };
    this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).forEach((workbook) => {
      handleWorkbook(workbook);
    });
    this._univerInstanceService.getTypeOfUnitAdded$(O.UNIVER_SHEET).pipe((0, import_operators4.takeUntil)(this.dispose$)).subscribe(handleWorkbook);
    this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET).pipe((0, import_operators4.takeUntil)(this.dispose$)).subscribe((workbook) => {
      workbook.getSheets().forEach((worksheet) => {
        const unitId = workbook.getUnitId();
        const subUnitId = worksheet.getSheetId();
        getAllWorksheetPermissionPoint().forEach((F) => {
          const instance = new F(unitId, subUnitId);
          this._permissionService.deletePermissionPoint(instance.id);
        });
      });
    });
  }
  _initRuleChange() {
    this.disposeWithMe(
      this._worksheetProtectionRuleModel.ruleChange$.subscribe((info) => {
        switch (info.type) {
          case "add": {
            break;
          }
          case "delete": {
            getAllWorksheetPermissionPoint().forEach((F) => {
              const instance = new F(info.unitId, info.subUnitId);
              this._permissionService.updatePermissionPoint(instance.id, true);
            });
            break;
          }
          case "set": {
            getAllWorksheetPermissionPoint().forEach((F) => {
              const instance = new F(info.unitId, info.subUnitId);
              this._permissionService.updatePermissionPoint(instance.id, info.rule);
            });
            break;
          }
        }
      })
    );
  }
  _initRuleSnapshot() {
    const toJson = () => {
      const object = this._worksheetProtectionRuleModel.toObject();
      return JSON.stringify(object);
    };
    const parseJson = (json) => {
      if (!json) {
        return {};
      }
      try {
        return JSON.parse(json);
      } catch (err) {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        toJson,
        parseJson,
        pluginName: RULE_MODEL_PLUGIN_NAME,
        businesses: [O.UNIVER_SHEET],
        onLoad: (unitId, resources) => {
          this._worksheetProtectionRuleModel.fromObject(resources);
          Object.keys(resources).forEach((subUnitId) => {
            getAllWorksheetPermissionPoint().forEach((F) => {
              const instance = new F(unitId, subUnitId);
              instance.value = false;
              this._permissionService.addPermissionPoint(instance);
            });
          });
          this._worksheetProtectionRuleModel.changeRuleInitState(true);
        },
        onUnLoad: (unitId) => {
          const workbook = this._univerInstanceService.getUnit(unitId);
          if (workbook) {
            workbook.getSheets().forEach((worksheet) => {
              const subUnitId = worksheet.getSheetId();
              [...getAllWorksheetPermissionPoint(), ...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
                const instance = new F(unitId, subUnitId);
                this._permissionService.deletePermissionPoint(instance.id);
              });
            });
            getAllWorkbookPermissionPoint().forEach((F) => {
              const instance = new F(unitId);
              this._permissionService.deletePermissionPoint(instance.id);
            });
          }
          this._worksheetProtectionRuleModel.deleteUnitModel(unitId);
        }
      })
    );
  }
  _initPointSnapshot() {
    const toJson = () => {
      const object = this._worksheetProtectionPointRuleModel.toObject();
      return JSON.stringify(object);
    };
    const parseJson = (json) => {
      if (!json) {
        return {};
      }
      try {
        return JSON.parse(json);
      } catch (err) {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        toJson,
        parseJson,
        pluginName: POINT_MODEL_PLUGIN_NAME,
        businesses: [O.UNIVER_SHEET],
        onLoad: (unitId, resources) => {
          this._worksheetProtectionPointRuleModel.fromObject(resources);
          Object.keys(resources).forEach((subUnitId) => {
            getAllWorksheetPermissionPointByPointPanel().forEach((F) => {
              const instance = new F(unitId, subUnitId);
              this._permissionService.addPermissionPoint(instance);
            });
          });
        },
        onUnLoad: (unitId) => {
          this._worksheetProtectionPointRuleModel.deleteUnitModel(unitId);
        }
      })
    );
  }
};
WorksheetPermissionService = __decorateClass([
  __decorateParam(0, Inject(IPermissionService)),
  __decorateParam(1, Inject(IUniverInstanceService)),
  __decorateParam(2, Inject(Injector)),
  __decorateParam(3, Inject(WorksheetProtectionRuleModel)),
  __decorateParam(4, Inject(WorksheetProtectionPointModel)),
  __decorateParam(5, Inject(IResourceManagerService)),
  __decorateParam(6, Inject(RangeProtectionRuleModel)),
  __decorateParam(7, Inject(ILogService))
], WorksheetPermissionService);

// ../packages/sheets/src/commands/mutations/set-worksheet-permission-points.mutation.ts
var SetWorksheetPermissionPointsMutation = {
  id: "sheet.mutation.set-worksheet-permission-points",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { rule } = params;
    const worksheetProtectionPointRuleModel = accessor.get(WorksheetProtectionPointModel);
    worksheetProtectionPointRuleModel.addRule(rule);
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-permission-points.command.ts
var SetWorksheetPermissionPointsCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-permission-points",
  async handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const { rule } = params;
    commandService.executeCommand(SetWorksheetPermissionPointsMutation.id, {
      rule,
      unitId: rule.unitId,
      subUnitId: rule.subUnitId
    });
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-protection.command.ts
var SetWorksheetProtectionCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-protection",
  async handler(accessor, params) {
    if (!params) {
      return false;
    }
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const { rule, permissionId, oldRule } = params;
    const { unitId, subUnitId } = rule;
    const newRule = { ...rule, permissionId };
    const result = await commandService.executeCommand(SetWorksheetProtectionMutation.id, {
      unitId,
      subUnitId,
      newRule
    });
    if (result) {
      const redoMutations = [{ id: SetWorksheetProtectionMutation.id, params: { unitId, subUnitId, newRule } }];
      const undoMutations = [{ id: SetWorksheetProtectionMutation.id, params: { unitId, subUnitId, rule: oldRule } }];
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        redoMutations,
        undoMutations
      });
    }
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-row-height.mutation.ts
var MAXIMUM_ROW_HEIGHT = 2e3;
var SetWorksheetRowHeightMutationFactory = (params, worksheet) => {
  const { unitId, subUnitId, ranges } = params;
  const rowHeight = {};
  const manager = worksheet.getRowManager();
  for (const { startRow, endRow } of ranges) {
    for (let rowIndex = startRow; rowIndex < endRow + 1; rowIndex++) {
      const row = manager.getRowOrCreate(rowIndex);
      rowHeight[rowIndex] = row.h;
    }
  }
  return {
    unitId,
    subUnitId,
    ranges,
    rowHeight
  };
};
var SetWorksheetRowIsAutoHeightMutationFactory = (params, worksheet) => {
  const { unitId, subUnitId, ranges } = params;
  const autoHeightHash = {};
  const manager = worksheet.getRowManager();
  for (const { startRow, endRow } of ranges) {
    for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
      const row = manager.getRowOrCreate(rowIndex);
      autoHeightHash[rowIndex] = row.ia;
    }
  }
  return {
    unitId,
    subUnitId,
    ranges,
    autoHeightInfo: autoHeightHash
  };
};
var SetWorksheetRowHeightMutation = {
  id: "sheet.mutation.set-worksheet-row-height",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    var _a2;
    const { ranges, rowHeight } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { worksheet } = target;
    const manager = worksheet.getRowManager();
    const defaultRowHeight = worksheet.getConfig().defaultRowHeight;
    for (const { startRow, endRow } of ranges) {
      for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
        const row = manager.getRowOrCreate(rowIndex);
        if (typeof rowHeight === "number") {
          row.h = rowHeight;
        } else {
          row.h = (_a2 = rowHeight[rowIndex]) != null ? _a2 : defaultRowHeight;
        }
        row.h = Math.min(MAXIMUM_ROW_HEIGHT, row.h);
      }
    }
    return true;
  }
};
var SetWorksheetRowIsAutoHeightMutation = {
  id: "sheet.mutation.set-worksheet-row-is-auto-height",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    var _a2;
    const { ranges, autoHeightInfo } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const manager = target.worksheet.getRowManager();
    for (const { startRow, endRow } of ranges) {
      for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
        const row = manager.getRowOrCreate(rowIndex);
        if (typeof autoHeightInfo === "number") {
          row.ia = autoHeightInfo;
        } else {
          row.ia = (_a2 = autoHeightInfo[rowIndex]) != null ? _a2 : void 0;
        }
      }
    }
    return true;
  }
};
var SetWorksheetRowAutoHeightMutation = {
  id: "sheet.mutation.set-worksheet-row-auto-height",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const { rowsAutoHeightInfo } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const rowManager = target.worksheet.getRowManager();
    for (const { row, autoHeight } of rowsAutoHeightInfo) {
      const curRow = rowManager.getRowOrCreate(row);
      curRow.ah = autoHeight;
    }
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-row-height.command.ts
var DeltaRowHeightCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.delta-row-height",
  // eslint-disable-next-line max-lines-per-function
  handler: async (accessor, params) => {
    var _a2, _b2;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = selectionManagerService.getCurrentSelections();
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    if (!(selections == null ? void 0 : selections.length)) {
      return false;
    }
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const { worksheet, subUnitId, unitId } = target;
    const { anchorRow, deltaY } = params;
    const anchorRowHeight = worksheet.getRowHeight(anchorRow);
    const destRowHeight = anchorRowHeight + deltaY;
    const isAllSheetRange = selections.length === 1 && selections[0].range.rangeType === 3 /* ALL */;
    const rowSelections = selections.filter((s) => s.range.rangeType === 1 /* ROW */);
    const rangeType = isAllSheetRange ? 3 /* ALL */ : rowSelections.some(({ range }) => {
      const { startRow, endRow } = range;
      return startRow <= anchorRow && anchorRow <= endRow;
    }) ? 1 /* ROW */ : 0 /* NORMAL */;
    let redoMutationParams;
    if (rangeType === 3 /* ALL */) {
      const colCount = worksheet.getColumnCount();
      const allRowRanges = new Array(worksheet.getRowCount()).fill(void 0).map(
        (_, index) => ({ startRow: index, endRow: index, startColumn: 0, endColumn: colCount - 1 })
      );
      redoMutationParams = {
        subUnitId,
        unitId,
        rowHeight: destRowHeight,
        ranges: allRowRanges
      };
    } else if (rangeType === 1 /* ROW */) {
      redoMutationParams = {
        subUnitId,
        unitId,
        ranges: rowSelections.map((s) => Rectangle.clone(s.range)),
        rowHeight: destRowHeight
      };
    } else {
      redoMutationParams = {
        subUnitId,
        unitId,
        rowHeight: destRowHeight,
        ranges: [
          {
            startRow: anchorRow,
            endRow: anchorRow,
            startColumn: 0,
            endColumn: worksheet.getMaxColumns() - 1
          }
        ]
      };
    }
    const undoMutationParams = SetWorksheetRowHeightMutationFactory(redoMutationParams, worksheet);
    const redoSetIsAutoHeightParams = {
      unitId,
      subUnitId,
      ranges: redoMutationParams.ranges,
      autoHeightInfo: 0 /* FALSE */
    };
    const undoSetIsAutoHeightParams = SetWorksheetRowIsAutoHeightMutationFactory(redoSetIsAutoHeightParams, worksheet);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: DeltaRowHeightCommand.id,
      params: redoMutationParams
    });
    const result = sequenceExecute([
      {
        id: SetWorksheetRowHeightMutation.id,
        params: redoMutationParams
      },
      {
        id: SetWorksheetRowIsAutoHeightMutation.id,
        params: redoSetIsAutoHeightParams
      }
    ], commandService);
    const interceptedResult = sequenceExecute([...intercepted.redos], commandService);
    if (result.result && interceptedResult.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          ...(_a2 = intercepted.preUndos) != null ? _a2 : [],
          {
            id: SetWorksheetRowHeightMutation.id,
            params: undoMutationParams
          },
          {
            id: SetWorksheetRowIsAutoHeightMutation.id,
            params: undoSetIsAutoHeightParams
          },
          ...intercepted.undos
        ],
        redoMutations: [
          ...(_b2 = intercepted.preRedos) != null ? _b2 : [],
          {
            id: SetWorksheetRowHeightMutation.id,
            params: redoMutationParams
          },
          {
            id: SetWorksheetRowIsAutoHeightMutation.id,
            params: redoSetIsAutoHeightParams
          },
          ...intercepted.redos
        ]
      });
      return true;
    }
    return false;
  }
};
var SetRowHeightCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-row-height",
  // eslint-disable-next-line max-lines-per-function
  handler: (accessor, params) => {
    var _a2, _b2, _c, _d;
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const selections = ((_a2 = params == null ? void 0 : params.ranges) == null ? void 0 : _a2.length) ? params.ranges : (_b2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _b2.map((s) => s.range);
    if (!(selections == null ? void 0 : selections.length)) {
      return false;
    }
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { unitId, subUnitId, worksheet } = target;
    const redoMutationParams = {
      subUnitId,
      unitId,
      ranges: selections,
      rowHeight: params.value
    };
    const undoMutationParams = SetWorksheetRowHeightMutationFactory(redoMutationParams, worksheet);
    const redoSetIsAutoHeightParams = {
      unitId,
      subUnitId,
      ranges: redoMutationParams.ranges,
      autoHeightInfo: 0 /* FALSE */
    };
    const undoSetIsAutoHeightParams = SetWorksheetRowIsAutoHeightMutationFactory(redoSetIsAutoHeightParams, worksheet);
    const result = sequenceExecute([
      {
        id: SetWorksheetRowHeightMutation.id,
        params: redoMutationParams
      },
      {
        id: SetWorksheetRowIsAutoHeightMutation.id,
        params: redoSetIsAutoHeightParams
      }
    ], commandService);
    const intercepted = sheetInterceptorService.onCommandExecute({
      id: SetRowHeightCommand.id,
      params: redoMutationParams
    });
    const sheetInterceptorResult = sequenceExecute([...intercepted.redos], commandService);
    if (result.result && sheetInterceptorResult.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          ...(_c = intercepted.preRedos) != null ? _c : [],
          {
            id: SetWorksheetRowHeightMutation.id,
            params: undoMutationParams
          },
          {
            id: SetWorksheetRowIsAutoHeightMutation.id,
            params: undoSetIsAutoHeightParams
          },
          ...intercepted.undos
        ],
        redoMutations: [
          ...(_d = intercepted.preRedos) != null ? _d : [],
          {
            id: SetWorksheetRowHeightMutation.id,
            params: redoMutationParams
          },
          {
            id: SetWorksheetRowIsAutoHeightMutation.id,
            params: redoSetIsAutoHeightParams
          },
          ...intercepted.redos
        ]
      });
      return true;
    }
    return false;
  }
};
var SetWorksheetRowIsAutoHeightCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-row-is-auto-height",
  handler: (accessor, params) => {
    var _a2, _b2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService, params);
    if (!target) return false;
    const { unitId, subUnitId, worksheet } = target;
    const ranges = ((_a2 = params == null ? void 0 : params.ranges) == null ? void 0 : _a2.length) ? params.ranges : (_b2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _b2.map((s) => s.range);
    if (!(ranges == null ? void 0 : ranges.length)) {
      return false;
    }
    const redoMutationParams = {
      unitId,
      subUnitId,
      ranges,
      autoHeightInfo: 1 /* TRUE */
      // Hard code first, maybe it will change by the menu item in the future.
    };
    const undoMutationParams = SetWorksheetRowIsAutoHeightMutationFactory(redoMutationParams, worksheet);
    const setIsAutoHeightResult = commandService.syncExecuteCommand(
      SetWorksheetRowIsAutoHeightMutation.id,
      redoMutationParams
    );
    const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
      id: SetWorksheetRowIsAutoHeightCommand.id,
      params: redoMutationParams
    });
    const result = sequenceExecute([...redos], commandService);
    if (setIsAutoHeightResult && result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetWorksheetRowIsAutoHeightMutation.id, params: undoMutationParams }, ...undos],
        redoMutations: [{ id: SetWorksheetRowIsAutoHeightMutation.id, params: redoMutationParams }, ...redos]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-show.command.ts
var SetWorksheetShowCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-show",
  handler: (accessor, params) => {
    const { unitId, subUnitId } = params;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const worksheet = workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) return false;
    const hidden = worksheet.getConfig().hidden;
    if (hidden === 0 /* FALSE */) return false;
    const redoMutationParams = {
      unitId,
      subUnitId,
      hidden: 0 /* FALSE */
    };
    const undoMutationParams = SetWorksheetHideMutationFactory(accessor, redoMutationParams);
    const result = commandService.syncExecuteCommand(SetWorksheetHideMutation.id, redoMutationParams);
    const activeSheetMutationParams = {
      unitId,
      subUnitId
    };
    const activeResult = commandService.syncExecuteCommand(
      SetWorksheetActiveOperation.id,
      activeSheetMutationParams
    );
    if (result && activeResult) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [
          { id: SetWorksheetHideMutation.id, params: undoMutationParams }
          // { id: SetWorksheetActiveOperation.id, params: unActiveMutationParams },
        ],
        redoMutations: [
          // { id: SetWorksheetActiveOperation.id, params: activeSheetMutationParams },
          { id: SetWorksheetHideMutation.id, params: redoMutationParams }
        ]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/basics/split-range-text.ts
var DelimiterCounter = class {
  constructor() {
    __publicField(this, "_tabCount", 0);
    __publicField(this, "_commaCount", 0);
    __publicField(this, "_semicolonCount", 0);
    __publicField(this, "_spaceCount", 0);
  }
  add(delimiter) {
    switch (delimiter) {
      case "	":
        this._tabCount++;
        break;
      case ",":
        this._commaCount++;
        break;
      case ";":
        this._semicolonCount++;
        break;
      case " ":
        this._spaceCount++;
        break;
      default:
        break;
    }
  }
  update(cellText) {
    if (cellText && typeof cellText === "string") {
      if (cellText.includes("	")) {
        this._tabCount++;
      }
      if (cellText.includes(",")) {
        this._commaCount++;
      }
      if (cellText.includes(";")) {
        this._semicolonCount++;
      }
      if (cellText.trim().includes(" ")) {
        this._spaceCount++;
      }
    }
  }
  getDelimiter() {
    const maxCount = Math.max(this._tabCount, this._commaCount, this._semicolonCount, this._spaceCount);
    if (maxCount === 0) {
      return 1 /* Tab */;
    }
    if (maxCount === this._tabCount) {
      return 1 /* Tab */;
    }
    if (maxCount === this._commaCount) {
      return 2 /* Comma */;
    }
    if (maxCount === this._semicolonCount) {
      return 4 /* Semicolon */;
    }
    if (maxCount === this._spaceCount) {
      return 8 /* Space */;
    }
    return 1 /* Tab */;
  }
};
function getDelimiterRegexItem(delimiter, treatMultipleDelimitersAsOne, customDelimiter) {
  const delimiterList = [];
  if (customDelimiter !== void 0 && (delimiter & 16 /* Custom */) > 0) {
    delimiterList.push(customDelimiter);
  }
  if ((delimiter & 1 /* Tab */) > 0) {
    delimiterList.push("	");
  }
  if ((delimiter & 2 /* Comma */) > 0) {
    delimiterList.push(",");
  }
  if ((delimiter & 4 /* Semicolon */) > 0) {
    delimiterList.push(";");
  }
  if ((delimiter & 8 /* Space */) > 0) {
    delimiterList.push(" ");
  }
  let str = "";
  for (const delimiter2 of delimiterList) {
    str += escapeRegExp2(delimiter2);
  }
  let allStr = "[".concat(str, "]");
  if (treatMultipleDelimitersAsOne) {
    allStr += "+";
  }
  return new RegExp(allStr);
}
function escapeRegExp2(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var getStringFromDataStream = (data) => {
  var _a2;
  const dataStream = ((_a2 = data.body) == null ? void 0 : _a2.dataStream.replace(/\r\n$/, "")) || "";
  return dataStream;
};
function cellValueToString(cellData) {
  if (cellData === null || cellData === void 0) {
    return void 0;
  }
  if (cellData.p) {
    return getStringFromDataStream(cellData.p);
  }
  if (cellData.v && typeof cellData.v === "string") {
    return cellData.v;
  }
  if (cellData.t && (cellData.t === 4 /* FORCE_STRING */ || cellData.t === 1 /* STRING */)) {
    return String(cellData.v);
  }
  return void 0;
}
function splitRangeText(sheet, range, delimiter, customDelimiter, treatMultipleDelimitersAsOne = false) {
  const sourceRange = Range.transformRange(range, sheet);
  const { startColumn, startRow, endColumn, endRow } = sourceRange;
  if (startColumn !== endColumn) {
    throw new Error("The range must be in the same column.");
  }
  if (delimiter && (delimiter & 16 /* Custom */) > 0 && (customDelimiter === void 0 || customDelimiter.length !== 1)) {
    throw new Error("The custom delimiter must a character.");
  }
  const needAutoDelimiter = delimiter === void 0;
  const delimiterCounter = needAutoDelimiter ? new DelimiterCounter() : null;
  const textList = [];
  for (let i = startRow; i <= endRow; i++) {
    const cell = sheet.getCell(i, startColumn);
    const cellString = cellValueToString(cell);
    textList.push(cellString);
    if (delimiterCounter) {
      delimiterCounter.update(cellString);
    }
  }
  const useDelimiter = needAutoDelimiter ? delimiterCounter.getDelimiter() : delimiter;
  const useDelimiterRegex = getDelimiterRegexItem(useDelimiter, treatMultipleDelimitersAsOne, customDelimiter);
  let maxLength = -1;
  let lastRow = 0;
  let index = 0;
  const rs = [];
  for (const text of textList) {
    if (text !== void 0) {
      const cols = String(text).split(useDelimiterRegex);
      if (maxLength < 0) {
        maxLength = cols.length;
      } else {
        maxLength = Math.max(maxLength, cols.length);
      }
      rs.push(cols);
      lastRow = index;
    } else {
      rs.push(void 0);
    }
    index++;
  }
  return {
    rs,
    maxLength: maxLength === -1 ? 0 : maxLength,
    lastRow
  };
}

// ../packages/sheets/src/commands/commands/split-text-to-columns.command.ts
var SplitTextToColumnsCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.split-text-to-columns",
  // eslint-disable-next-line max-lines-per-function
  handler: (accessor, params) => {
    const { unitId, subUnitId, range, delimiter, customDelimiter, treatMultipleDelimitersAsOne } = params;
    const commandService = accessor.get(ICommandService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService));
    if (!target) return false;
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const worksheet = workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) return false;
    const { lastRow, rs, maxLength } = splitRangeText(worksheet, range, delimiter, customDelimiter, treatMultipleDelimitersAsOne);
    const maxColumn = worksheet.getColumnCount();
    const { startColumn } = Range.transformRange(range, worksheet);
    if (range.startColumn !== range.endColumn) {
      return false;
    }
    const redoMutations = [];
    const undoMutations = [];
    const insertColCount = startColumn + maxLength + 1 - maxColumn;
    if (insertColCount > 0) {
      const insertColParams = {
        unitId,
        subUnitId,
        range: {
          startRow: 0,
          endRow: worksheet.getRowCount() - 1,
          startColumn: maxColumn - 1,
          endColumn: maxColumn - 1 + insertColCount
        }
      };
      redoMutations.push({
        id: InsertColMutation.id,
        params: insertColParams
      });
      const undoColInsertionParams = InsertColMutationUndoFactory(
        accessor,
        insertColParams
      );
      undoMutations.push({ id: RemoveColMutation.id, params: undoColInsertionParams });
    }
    const destRange = {
      startRow: range.startRow,
      endRow: lastRow,
      startColumn,
      endColumn: startColumn + maxLength
    };
    const cellValue = new ObjectMatrix();
    for (let i = destRange.startRow; i <= destRange.endRow; i++) {
      for (let j = destRange.startColumn; j <= destRange.endColumn; j++) {
        const values = rs[i - destRange.startRow];
        if (j === 0 && (values == null ? void 0 : values.length) === 1) {
          cellValue.setValue(i, j, worksheet.getCell(i, j));
        } else {
          cellValue.setValue(i, j, {
            v: (values == null ? void 0 : values[j - destRange.startColumn]) || null,
            p: null,
            f: null,
            si: null,
            custom: null
          });
        }
      }
    }
    const setValuesParams = {
      unitId,
      subUnitId,
      cellValue: cellValue.clone()
    };
    const undoSetValuesParams = SetRangeValuesUndoMutationFactory(accessor, setValuesParams);
    redoMutations.push({
      id: SetRangeValuesMutation.id,
      params: setValuesParams
    });
    undoMutations.unshift({
      id: SetRangeValuesMutation.id,
      params: undoSetValuesParams
    });
    const result = sequenceExecute(redoMutations, commandService).result;
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations,
        redoMutations
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/toggle-checkbox.command.ts
var ToggleCellCheckboxCommand = {
  id: "sheet.command.toggle-cell-checkbox",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const { unitId, subUnitId, row, col, paragraphIndex } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getUnit(unitId, O.UNIVER_SHEET);
    const sheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    const undoRedoService = accessor.get(IUndoRedoService);
    const commandService = accessor.get(ICommandService);
    if (!sheet) {
      return false;
    }
    const cell = sheet.getCell(row, col);
    if (!(cell == null ? void 0 : cell.p)) {
      return false;
    }
    const p = Tools.deepClone(cell.p);
    const documentDataModel = new DocumentDataModel(p);
    const textX = BuildTextUtils.paragraph.bullet.toggleChecklist({
      document: documentDataModel,
      paragraphIndex
    });
    if (!textX) {
      return false;
    }
    TextX.apply(documentDataModel.getBody(), textX.serialize());
    const redoParams = {
      unitId,
      subUnitId,
      cellValue: {
        [row]: {
          [col]: {
            p,
            t: 1 /* STRING */
          }
        }
      }
    };
    const redo = {
      id: SetRangeValuesMutation.id,
      params: redoParams
    };
    const undoParams = SetRangeValuesUndoMutationFactory(accessor, redoParams);
    const undo = {
      id: SetRangeValuesMutation.id,
      params: undoParams
    };
    const redos = [redo];
    const undos = [undo];
    undoRedoService.pushUndoRedo({
      redoMutations: redos,
      undoMutations: undos,
      unitID: unitId
    });
    return commandService.syncExecuteCommand(redo.id, redo.params);
  }
};

// ../packages/sheets/src/commands/mutations/toggle-gridlines.mutation.ts
var ToggleGridlinesMutation = {
  id: "sheet.mutation.toggle-gridlines",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { worksheet } = target;
    const config2 = worksheet.getConfig();
    config2.showGridlines = params.showGridlines;
    return true;
  }
};

// ../packages/sheets/src/commands/commands/toggle-gridlines.command.ts
var ToggleGridlinesCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.toggle-gridlines",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const { worksheet } = target;
    const currentlyShow = worksheet.getConfig().showGridlines;
    if (currentlyShow === (params == null ? void 0 : params.showGridlines)) return false;
    const { unitId, subUnitId } = target;
    const doParams = {
      showGridlines: currentlyShow === 1 /* TRUE */ ? 0 /* FALSE */ : 1 /* TRUE */,
      unitId,
      subUnitId
    };
    const undoMutationParams = {
      showGridlines: currentlyShow,
      unitId,
      subUnitId
    };
    const result = commandService.syncExecuteCommand(ToggleGridlinesMutation.id, doParams);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: ToggleGridlinesMutation.id, params: undoMutationParams }],
        redoMutations: [{ id: ToggleGridlinesMutation.id, params: doParams }]
      });
      return true;
    }
    return false;
  }
};

// ../packages/sheets/src/commands/commands/unregister-range-theme.command.ts
var UnregisterWorksheetRangeThemeStyleCommand = {
  id: "sheet.command.unregister-worksheet-range-theme-style",
  type: 0 /* COMMAND */,
  handler: (accessor, params) => {
    var _a2;
    if (!params) {
      return false;
    }
    const { unitId, themeName } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const sheetRangeThemeModel = accessor.get(SheetRangeThemeModel);
    const target = getSheetCommandTarget(univerInstanceService);
    if (!target) return false;
    const redoParam = {
      unitId,
      themeName
    };
    const undoParam = {
      unitId,
      themeName,
      rangeThemeStyleJson: (_a2 = sheetRangeThemeModel.getRangeThemeStyle(unitId, themeName)) == null ? void 0 : _a2.toJson()
    };
    const result = commandService.syncExecuteCommand(RegisterWorksheetRangeThemeStyleMutation.id, params);
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: RegisterWorksheetRangeThemeStyleMutation.id, params: undoParam }],
        redoMutations: [{ id: UnregisterWorksheetRangeThemeStyleMutation.id, params: redoParam }]
      });
    }
    return true;
  }
};

// ../packages/sheets/src/commands/mutations/empty.mutation.ts
var EmptyMutation = {
  id: "sheet.mutation.empty",
  type: 2 /* MUTATION */,
  handler: () => {
    return true;
  }
};

// ../packages/sheets/src/services/numfmt/type.ts
var INumfmtService = createIdentifier("INumfmtService");

// ../packages/sheets/src/commands/mutations/numfmt-mutation.ts
var SetNumfmtMutation = {
  id: "sheet.mutation.set.numfmt",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const { values, refMap } = params;
    const numfmtService = accessor.get(INumfmtService);
    const unitId = params.unitId;
    const sheetId = params.subUnitId;
    const setValues = Object.keys(values).reduce(
      (result, id) => {
        const value = refMap[id];
        const ranges = values[id].ranges;
        if (value) {
          result.push({
            ...value,
            ranges
          });
        }
        return result;
      },
      []
    );
    numfmtService.setValues(unitId, sheetId, setValues);
    return true;
  }
};
var RemoveNumfmtMutation = {
  id: "sheet.mutation.remove.numfmt",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    if (!params) {
      return false;
    }
    const { unitId, subUnitId, ranges } = params;
    const numfmtService = accessor.get(INumfmtService);
    numfmtService.deleteValues(unitId, subUnitId, ranges);
    return true;
  }
};

// ../packages/sheets/src/commands/operations/scroll-to-cell.operation.ts
var ScrollToCellOperation = {
  id: "sheet.operation.scroll-to-cell",
  type: 1 /* OPERATION */,
  handler: () => true
};

// ../packages/sheets/src/controllers/config.ts
var ONLY_REGISTER_FORMULA_RELATED_MUTATIONS_KEY = "ONLY_REGISTER_FORMULA_RELATED_MUTATIONS_KEY";

// ../packages/sheets/src/controllers/config/config.ts
var MAX_CELL_PER_SHEET_KEY = "maxCellsPerSheet";
var MAX_CELL_PER_SHEET_DEFAULT = 3e6;

// ../packages/sheets/src/controllers/basic-worksheet.controller.ts
var BasicWorksheetController = class extends Disposable {
  // eslint-disable-next-line max-lines-per-function
  constructor(_commandService, _configService, _dataSyncPrimaryController) {
    var _a2;
    super();
    this._commandService = _commandService;
    this._configService = _configService;
    this._dataSyncPrimaryController = _dataSyncPrimaryController;
    [
      SetRangeValuesMutation,
      InsertColMutation,
      InsertRowMutation,
      InsertSheetMutation,
      MoveRangeMutation,
      MoveRowsMutation,
      MoveColsMutation,
      RemoveColMutation,
      RemoveRowMutation,
      RemoveSheetMutation,
      RemoveWorksheetMergeMutation,
      RemoveNumfmtMutation,
      AddWorksheetMergeMutation,
      SetWorkbookNameMutation,
      SetWorksheetNameMutation,
      SetNumfmtMutation,
      ReorderRangeMutation,
      EmptyMutation,
      SetRowHiddenMutation,
      // formula SUBTOTAL
      SetRowVisibleMutation
    ].forEach((mutation) => {
      var _a3;
      this._commandService.registerCommand(mutation);
      (_a3 = this._dataSyncPrimaryController) == null ? void 0 : _a3.registerSyncingMutations(mutation);
    });
    const onlyRegisterFormulaRelatedMutations = (_a2 = this._configService.getConfig(ONLY_REGISTER_FORMULA_RELATED_MUTATIONS_KEY)) != null ? _a2 : false;
    if (!onlyRegisterFormulaRelatedMutations) {
      [
        AppendRowCommand,
        ClearSelectionAllCommand,
        ClearSelectionContentCommand,
        ClearSelectionFormatCommand,
        CopySheetCommand,
        DeleteRangeMoveLeftCommand,
        DeleteRangeMoveUpCommand,
        DeltaColumnWidthCommand,
        DeltaRowHeightCommand,
        InsertColAfterCommand,
        InsertColBeforeCommand,
        InsertMultiColsLeftCommand,
        InsertMultiColsRightCommand,
        InsertColByRangeCommand,
        InsertColCommand,
        InsertRangeMoveDownCommand,
        InsertRangeMoveRightCommand,
        InsertRowAfterCommand,
        InsertRowBeforeCommand,
        InsertMultiRowsAfterCommand,
        InsertMultiRowsAboveCommand,
        InsertRowByRangeCommand,
        InsertRowCommand,
        InsertSheetCommand,
        MoveColsCommand,
        MoveRangeCommand,
        MoveRowsCommand,
        RemoveRowByRangeCommand,
        RemoveColCommand,
        RemoveColByRangeCommand,
        RemoveRowCommand,
        RemoveSheetCommand,
        ReorderRangeCommand,
        RemoveWorksheetMergeCommand,
        ResetBackgroundColorCommand,
        ResetTextColorCommand,
        SetBackgroundColorCommand,
        SetBorderBasicCommand,
        SetBorderColorCommand,
        SetBorderCommand,
        SetBorderPositionCommand,
        SetBorderStyleCommand,
        SetColHiddenCommand,
        SetColHiddenMutation,
        SetColVisibleMutation,
        SetColWidthCommand,
        SetColDataCommand,
        SetColDataMutation,
        SetFrozenCommand,
        SetFrozenMutation,
        CancelFrozenCommand,
        SetHorizontalTextAlignCommand,
        SetRangeValuesCommand,
        SetRowHeightCommand,
        SetRowHiddenCommand,
        SetRowDataCommand,
        SetRowDataMutation,
        SetSelectedColsVisibleCommand,
        SetSelectedRowsVisibleCommand,
        SetSpecificColsVisibleCommand,
        SetSpecificRowsVisibleCommand,
        SetStyleCommand,
        SetTabColorCommand,
        SetTabColorMutation,
        SetTextColorCommand,
        SetTextRotationCommand,
        SetTextWrapCommand,
        SetVerticalTextAlignCommand,
        SetWorkbookNameCommand,
        SetWorksheetActivateCommand,
        SetWorksheetActiveOperation,
        SetWorksheetHideCommand,
        SetWorksheetHideMutation,
        SetWorksheetNameCommand,
        SetWorksheetOrderCommand,
        SetWorksheetOrderMutation,
        SetWorksheetRowAutoHeightMutation,
        SetWorksheetRowHeightMutation,
        SetWorksheetRowIsAutoHeightCommand,
        SetWorksheetRowIsAutoHeightMutation,
        SetWorksheetColWidthMutation,
        // SetWorksheetColIsAutoWidthCommand,
        SelectRangeCommand,
        SetSelectionsOperation,
        ScrollToCellOperation,
        InsertDefinedNameCommand,
        RemoveDefinedNameCommand,
        SetDefinedNameCommand,
        SetWorksheetShowCommand,
        ToggleGridlinesCommand,
        ToggleGridlinesMutation,
        SetGridlinesColorCommand,
        SetGridlinesColorMutation,
        // permissions range protection
        SetWorksheetPermissionPointsCommand,
        AddWorksheetProtectionMutation,
        SetWorksheetProtectionMutation,
        DeleteWorksheetProtectionMutation,
        SetWorksheetPermissionPointsMutation,
        AddRangeProtectionCommand,
        SetProtectionCommand,
        DeleteRangeProtectionCommand,
        AddWorksheetProtectionCommand,
        DeleteWorksheetProtectionCommand,
        SetWorksheetProtectionCommand,
        AddRangeProtectionMutation,
        DeleteRangeProtectionMutation,
        SetRangeProtectionMutation,
        ToggleCellCheckboxCommand,
        SetWorksheetDefaultStyleMutation,
        SetWorksheetDefaultStyleCommand,
        SplitTextToColumnsCommand,
        // range theme
        DeleteWorksheetRangeThemeStyleMutation,
        SetWorksheetRangeThemeStyleMutation,
        UnregisterWorksheetRangeThemeStyleMutation,
        RegisterWorksheetRangeThemeStyleMutation,
        UnregisterWorksheetRangeThemeStyleCommand,
        RegisterWorksheetRangeThemeStyleCommand,
        SetWorksheetRangeThemeStyleCommand,
        DeleteWorksheetRangeThemeStyleCommand
      ].forEach((command) => this.disposeWithMe(this._commandService.registerCommand(command)));
    }
    this._configService.setConfig(MAX_CELL_PER_SHEET_KEY, MAX_CELL_PER_SHEET_DEFAULT);
  }
};
BasicWorksheetController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IConfigService),
  __decorateParam(2, Optional(DataSyncPrimaryController))
], BasicWorksheetController);

// ../packages/sheets/src/controllers/calculate-result-apply.controller.ts
var CalculateResultApplyController = class extends Disposable {
  constructor(_univerInstanceService, _commandService) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._commandService = _commandService;
    this._initialize();
  }
  _initialize() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        if (command.id !== SetFormulaCalculationResultMutation.id) {
          return;
        }
        const params = command.params;
        const { unitData } = params;
        const unitIds = Object.keys(unitData);
        const redoMutationsInfo = [];
        for (let i = 0; i < unitIds.length; i++) {
          const unitId = unitIds[i];
          const sheetData = unitData[unitId];
          if (sheetData == null) {
            continue;
          }
          const sheetIds = Object.keys(sheetData);
          for (let j = 0; j < sheetIds.length; j++) {
            const sheetId = sheetIds[j];
            const cellData = sheetData[sheetId];
            if (cellData == null) {
              continue;
            }
            const cellValue = this._getMergedCellData(unitId, sheetId, cellData);
            const setRangeValuesMutation = {
              subUnitId: sheetId,
              unitId,
              cellValue
            };
            redoMutationsInfo.push({
              id: SetRangeValuesMutation.id,
              params: setRangeValuesMutation
            });
          }
        }
        const result = redoMutationsInfo.every(
          (m) => this._commandService.executeCommand(m.id, m.params, {
            onlyLocal: true
          })
        );
        return result;
      })
    );
  }
  /**
   * Priority that mainly deals with number format in unitData
   * @param unitId
   * @param sheetId
   * @param cellData
   * @returns
   */
  _getMergedCellData(unitId, sheetId, cellData) {
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    const styles = workbook == null ? void 0 : workbook.getStyles();
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(sheetId);
    const oldCellDataMatrix = worksheet == null ? void 0 : worksheet.getCellMatrix();
    const cellDataMatrix = new ObjectMatrix(cellData);
    cellDataMatrix.forValue((row, col, cell) => {
      const oldCell = oldCellDataMatrix == null ? void 0 : oldCellDataMatrix.getValue(row, col);
      const newCell = handleNumfmtInCell(oldCell, cell, styles);
      cellDataMatrix.setValue(row, col, newCell);
    });
    return cellDataMatrix.getMatrix();
  }
};
CalculateResultApplyController = __decorateClass([
  __decorateParam(0, Inject(IUniverInstanceService)),
  __decorateParam(1, ICommandService)
], CalculateResultApplyController);

// ../packages/sheets/src/controllers/config.schema.ts
var SHEETS_PLUGIN_CONFIG_KEY = "sheets.config";
var configSymbol2 = Symbol(SHEETS_PLUGIN_CONFIG_KEY);
var defaultPluginConfig2 = {};

// ../packages/sheets/src/controllers/defined-name-data.controller.ts
var SHEET_DEFINED_NAME_PLUGIN = "SHEET_DEFINED_NAME_PLUGIN";
var DefinedNameDataController = class extends Disposable {
  constructor(_definedNamesService, _resourceManagerService) {
    super();
    this._definedNamesService = _definedNamesService;
    this._resourceManagerService = _resourceManagerService;
    this._initialize();
  }
  _initialize() {
    this._initSnapshot();
  }
  _initSnapshot() {
    const toJson = (unitId) => {
      const map9 = this._definedNamesService.getDefinedNameMap(unitId);
      if (map9) {
        return JSON.stringify(map9);
      }
      return "";
    };
    const parseJson = (json) => {
      if (!json) {
        return {};
      }
      try {
        return JSON.parse(json);
      } catch (err) {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        pluginName: SHEET_DEFINED_NAME_PLUGIN,
        businesses: [O.UNIVER_SHEET],
        toJson: (unitId) => toJson(unitId),
        parseJson: (json) => parseJson(json),
        onUnLoad: (unitId) => {
          this._definedNamesService.removeUnitDefinedName(unitId);
        },
        onLoad: (unitId, value) => {
          this._definedNamesService.registerDefinedNames(unitId, value);
        }
      })
    );
  }
};
DefinedNameDataController = __decorateClass([
  __decorateParam(0, IDefinedNamesService),
  __decorateParam(1, IResourceManagerService)
], DefinedNameDataController);

// ../packages/sheets/src/controllers/merge-cell.controller.ts
var import_rxjs36 = __toESM(require_cjs());

// ../packages/sheets/src/services/ref-range/type.ts
var EffectRefRangId = {
  MoveRangeCommandId,
  InsertRowCommandId,
  InsertColCommandId,
  RemoveColCommandId,
  RemoveRowCommandId,
  DeleteRangeMoveLeftCommandId,
  DeleteRangeMoveUpCommandId,
  InsertRangeMoveDownCommandId,
  InsertRangeMoveRightCommandId,
  MoveColsCommandId,
  MoveRowsCommandId,
  ReorderRangeCommandId
};

// ../packages/sheets/src/services/ref-range/util.ts
var MAX_SAFE_INTEGER4 = Number.MAX_SAFE_INTEGER;
var handleRangeTypeInput = (range) => {
  const _range = { ...range };
  const isColumn = Number.isNaN(_range.startRow) && Number.isNaN(_range.endRow) && !Number.isNaN(_range.startColumn) && !Number.isNaN(_range.endColumn);
  const isRow = Number.isNaN(_range.startColumn) && Number.isNaN(_range.endColumn) && !Number.isNaN(_range.startRow) && !Number.isNaN(_range.endRow);
  if (_range.rangeType === 2 /* COLUMN */ || isColumn) {
    _range.startRow = 0;
    _range.endRow = MAX_SAFE_INTEGER4;
  }
  if (_range.rangeType === 1 /* ROW */ || isRow) {
    _range.startColumn = 0;
    _range.endColumn = MAX_SAFE_INTEGER4;
  }
  if (_range.rangeType === 3 /* ALL */) {
    _range.startColumn = 0;
    _range.endColumn = MAX_SAFE_INTEGER4;
    _range.startRow = 0;
    _range.endRow = MAX_SAFE_INTEGER4;
  }
  return _range;
};
var rotateRange = (range) => {
  let rangeType = range.rangeType;
  if (range.rangeType === 2 /* COLUMN */) {
    rangeType = 1 /* ROW */;
  } else if (range.rangeType === 1 /* ROW */) {
    rangeType = 2 /* COLUMN */;
  }
  return {
    startRow: range.startColumn,
    endRow: range.endColumn,
    startColumn: range.startRow,
    endColumn: range.endRow,
    rangeType
  };
};
var handleBaseMoveRowsCols = (fromRange, toRange, effectRange) => {
  const _effectRange = { ...effectRange };
  const _toRange = { ...toRange };
  const getIntersects = (line1, line2) => {
    const start = Math.max(line1.start, line2.start);
    const end = Math.min(line1.end, line2.end);
    if (end < start) {
      return null;
    }
    return { start, end };
  };
  const getLength = (line) => line.end - line.start + 1;
  const getRelative = (line, origin) => ({
    start: line.start - origin.start,
    end: line.start - origin.start + line.end - line.start
  });
  const getAbsolute = (line, origin) => ({
    start: origin.start + line.start,
    end: origin.start + line.start + line.end - line.start
  });
  const isToLargeFrom = toRange.start > fromRange.start;
  if (isToLargeFrom) {
    const step = Math.min(fromRange.end, toRange.start) - fromRange.start + 1;
    _toRange.start -= step;
    _toRange.end -= step;
  }
  const fromRangeStep = getLength(fromRange);
  const toRangeStep = fromRangeStep;
  const fromRangeIntersectsEffectRange = getIntersects(fromRange, _effectRange);
  const isFromRangeContainEffectRange = fromRangeIntersectsEffectRange && getLength(fromRangeIntersectsEffectRange) >= getLength(_effectRange);
  if (fromRange.end < _effectRange.start) {
    _effectRange.start -= fromRangeStep;
    _effectRange.end -= fromRangeStep;
  } else if (fromRangeIntersectsEffectRange) {
    const fromRangeIntersectsEffectRangeStep = getLength(fromRangeIntersectsEffectRange);
    if (isFromRangeContainEffectRange) {
      const relative = getRelative(_effectRange, fromRange);
      const newLine = getAbsolute(relative, _toRange);
      _effectRange.start = newLine.start;
      _effectRange.end = newLine.end;
    } else if (fromRangeIntersectsEffectRange.start > fromRange.start) {
      if (isToLargeFrom) {
        _effectRange.end -= fromRangeIntersectsEffectRangeStep + fromRangeStep;
        _effectRange.start -= fromRangeStep;
      } else {
        _effectRange.end -= fromRangeIntersectsEffectRangeStep;
      }
    } else {
      if (isToLargeFrom) {
        _effectRange.end -= fromRangeIntersectsEffectRangeStep;
      } else {
        if (_effectRange.start > fromRange.start && _effectRange.end > fromRange.end) {
          _effectRange.start -= fromRangeStep;
          _effectRange.end -= fromRangeStep + fromRangeIntersectsEffectRangeStep;
        } else {
          _effectRange.end -= fromRangeIntersectsEffectRangeStep;
        }
      }
    }
  }
  const toRangeIntersectsEffectRange = getIntersects(_toRange, _effectRange);
  if (!isFromRangeContainEffectRange) {
    if (_toRange.start <= _effectRange.start) {
      _effectRange.start += toRangeStep;
      _effectRange.end += toRangeStep;
    } else if (toRangeIntersectsEffectRange) {
      if (!isToLargeFrom) {
        if (_effectRange.start < _toRange.start && _effectRange.end > _toRange.start) {
          _effectRange.end += toRangeStep;
        } else if (_effectRange.start >= _toRange.end || _effectRange.start >= _toRange.start && _effectRange.start <= _toRange.end) {
          _effectRange.end += toRangeStep;
          _effectRange.start += toRangeStep;
        }
      } else {
        if (_toRange.end <= _effectRange.start || _toRange.start <= _effectRange.start && _toRange.end >= _effectRange.start) {
          _effectRange.start += toRangeStep;
          _effectRange.end += toRangeStep;
        } else if (_toRange.start >= _effectRange.start && _toRange.start <= _effectRange.end) {
          _effectRange.end += toRangeStep;
        }
      }
    }
  }
  return {
    step: _effectRange.start - effectRange.start,
    length: getLength(_effectRange) - getLength(effectRange)
  };
};
var handleMoveRows = (params, targetRange) => {
  const { fromRange, toRange } = params.params || {};
  if (!toRange || !fromRange) {
    return [];
  }
  const _fromRange = handleRangeTypeInput(fromRange);
  const _toRange = handleRangeTypeInput(toRange);
  const _targetRange = handleRangeTypeInput(targetRange);
  const result = handleBaseMoveRowsCols(
    { start: _fromRange.startRow, end: _fromRange.endRow },
    { start: _toRange.startRow, end: _toRange.endRow },
    { start: _targetRange.startRow, end: _targetRange.endRow }
  );
  if (result === null) {
    return [
      {
        type: 1 /* Delete */
      }
    ];
  }
  return [
    {
      type: 3 /* VerticalMove */,
      step: result.step || 0,
      length: result.length || 0
    }
  ];
};
var handleMoveCols = (params, targetRange) => {
  const { fromRange, toRange } = params.params || {};
  if (!toRange || !fromRange) {
    return [];
  }
  const _fromRange = handleRangeTypeInput(fromRange);
  const _toRange = handleRangeTypeInput(toRange);
  const _targetRange = handleRangeTypeInput(targetRange);
  const result = handleBaseMoveRowsCols(
    { start: _fromRange.startColumn, end: _fromRange.endColumn },
    { start: _toRange.startColumn, end: _toRange.endColumn },
    { start: _targetRange.startColumn, end: _targetRange.endColumn }
  );
  if (result === null) {
    return [
      {
        type: 1 /* Delete */
      }
    ];
  }
  return [
    {
      type: 2 /* HorizontalMove */,
      step: result.step || 0,
      length: result.length || 0
    }
  ];
};
var handleBaseRemoveRange = (_removeRange, _targetRange) => {
  const removeRange = handleRangeTypeInput(_removeRange);
  const targetRange = handleRangeTypeInput(_targetRange);
  const getLength = (range) => range.endColumn - range.startColumn + 1;
  const getRowLength = (range) => range.endRow - range.startRow + 1;
  if (removeRange.startRow <= targetRange.startRow && removeRange.endRow >= targetRange.endRow) {
    if (
      // 2
      targetRange.startColumn < removeRange.startColumn && targetRange.endColumn >= removeRange.startColumn && targetRange.endColumn <= removeRange.endColumn || // 6
      targetRange.startColumn < removeRange.startColumn && targetRange.endColumn >= removeRange.endColumn
    ) {
      const intersectedRange = Rectangle.getIntersects(targetRange, removeRange);
      if (intersectedRange) {
        const length = -getLength(intersectedRange);
        return { step: 0, length };
      }
    }
    if (targetRange.startColumn >= removeRange.startColumn && targetRange.endColumn <= removeRange.endColumn && getRowLength(removeRange) >= getRowLength(targetRange)) {
      return null;
    }
    if (targetRange.startColumn >= removeRange.startColumn && targetRange.startColumn <= removeRange.endColumn && targetRange.endColumn > removeRange.endColumn) {
      const intersectedRange = Rectangle.getIntersects(targetRange, removeRange);
      if (intersectedRange) {
        const length = -getLength(intersectedRange);
        const step = -(getLength(removeRange) - getLength(intersectedRange));
        return { step, length };
      }
    }
    if (targetRange.startColumn > removeRange.endColumn) {
      const step = -getLength(removeRange);
      return { step, length: 0 };
    }
  }
  return { step: 0, length: 0 };
};
var handleBaseInsertRange = (_insertRange, _targetRange) => {
  const insertRange = handleRangeTypeInput(_insertRange);
  const targetRange = handleRangeTypeInput(_targetRange);
  const getLength = (range) => range.endColumn - range.startColumn + 1;
  if (!(insertRange.startRow <= targetRange.startRow && insertRange.endRow >= targetRange.endRow)) {
    return { step: 0, length: 0 };
  }
  if (
    // 2
    // Case 2: Overlap on the left side
    // Target range starts before the insert range and ends within the insert range boundaries
    // targetRange:  |----------|
    // insertRange:         |-------|
    // insertRange:
    targetRange.startColumn < insertRange.startColumn && targetRange.endColumn >= insertRange.startColumn && targetRange.endColumn <= insertRange.endColumn || // 6
    // Case 6: Fully overlapping on both sides
    // Target range starts before the insert range and ends after the insert range
    // targetRange:  |----------------|
    // insertRange:         |-------|
    targetRange.startColumn < insertRange.startColumn && targetRange.endColumn >= insertRange.endColumn
  ) {
    const length = getLength(insertRange);
    return { step: 0, length };
  }
  if (
    // 3
    // Case 3: Fully contained
    // Target range is completely within the insert range
    // targetRange:      |---|
    // insertRange:    |-------|
    targetRange.startColumn >= insertRange.startColumn && targetRange.endColumn <= insertRange.endColumn || // 4
    // Case 4: Overlap on the right side
    // Target range starts within the insert range and ends after the insert range
    // targetRange:         |---------|
    // insertRange:    |-------|
    targetRange.startColumn >= insertRange.startColumn && targetRange.startColumn <= insertRange.endColumn && targetRange.endColumn > insertRange.endColumn || //5
    // Case 5: No overlap (target range starts after the insert range ends)
    // targetRange:                |-------|
    // insertRange:    |-------|
    targetRange.startColumn >= insertRange.endColumn
  ) {
    const step = getLength(insertRange);
    return { step, length: 0 };
  }
  return { step: 0, length: 0 };
};
function handleBaseMoveRange(fromRange, toRange, targetRange) {
  const operators = [];
  if (Rectangle.contains(toRange, targetRange)) {
    operators.push({
      type: 1 /* Delete */
    });
  }
  if (Rectangle.contains(fromRange, targetRange)) {
    operators.push({
      type: 1 /* Delete */
    });
    const relativeRange = Rectangle.getRelativeRange(targetRange, fromRange);
    const positionRange = Rectangle.getPositionRange(relativeRange, toRange);
    return [
      {
        type: 0 /* Set */,
        range: positionRange
      }
    ];
  }
  return operators;
}
var runRefRangeMutations = (operators, range) => {
  let result = { ...range };
  operators.forEach((operator) => {
    switch (operator.type) {
      case 1 /* Delete */: {
        result = null;
        break;
      }
      case 2 /* HorizontalMove */: {
        if (!result) {
          return;
        }
        result.startColumn += operator.step;
        result.endColumn += operator.step + (operator.length || 0);
        break;
      }
      case 3 /* VerticalMove */: {
        if (!result) {
          return;
        }
        result.startRow += operator.step;
        result.endRow += operator.step + (operator.length || 0);
        break;
      }
      case 0 /* Set */: {
        result = operator.range;
        break;
      }
    }
  });
  if (result) {
    if (result.endColumn < result.startColumn || result.endRow < result.startRow) {
      return null;
    }
  }
  return result;
};
function adjustRangeOnMutation(range, mutation) {
  const { id, params } = mutation;
  let baseRangeOperator = {
    length: 0,
    step: 0,
    type: 4 /* Unknown */
  };
  switch (id) {
    case RemoveSheetMutation.id:
      baseRangeOperator.type = 1 /* Delete */;
      break;
    case MoveRowsMutation.id:
      baseRangeOperator = handleBaseMoveRowsCols(
        { start: params.sourceRange.startRow, end: params.sourceRange.endRow },
        { start: params.targetRange.startRow, end: params.targetRange.endRow },
        { start: range.startRow, end: range.endRow }
      );
      baseRangeOperator.type = 3 /* VerticalMove */;
      break;
    case MoveColsMutation.id:
      baseRangeOperator = handleBaseMoveRowsCols(
        { start: params.sourceRange.startColumn, end: params.sourceRange.endColumn },
        { start: params.targetRange.startColumn, end: params.targetRange.endColumn },
        { start: range.startColumn, end: range.endColumn }
      );
      baseRangeOperator.type = 2 /* HorizontalMove */;
      break;
    case RemoveColMutation.id:
      baseRangeOperator = handleBaseRemoveRange(params.range, range);
      if (baseRangeOperator) {
        baseRangeOperator.type = 2 /* HorizontalMove */;
      } else {
        baseRangeOperator = { step: 0, length: 0, type: 1 /* Delete */ };
      }
      break;
    case RemoveRowMutation.id:
      baseRangeOperator = handleBaseRemoveRange(rotateRange(params.range), rotateRange(range));
      if (baseRangeOperator) {
        baseRangeOperator.type = 3 /* VerticalMove */;
      } else {
        baseRangeOperator = { step: 0, length: 0, type: 1 /* Delete */ };
      }
      break;
    case InsertRowMutation.id:
      baseRangeOperator = handleBaseInsertRange(rotateRange(params.range), rotateRange(range));
      baseRangeOperator.type = 3 /* VerticalMove */;
      break;
    case InsertColMutation.id:
      baseRangeOperator = handleBaseInsertRange(params.range, range);
      baseRangeOperator.type = 2 /* HorizontalMove */;
      break;
    case MoveRangeMutation.id:
      {
        const fromRange = params.fromRange || new ObjectMatrix(params.from).getRange();
        const toRange = params.toRange || new ObjectMatrix(params.to).getRange();
        baseRangeOperator = handleBaseMoveRange(
          fromRange,
          toRange,
          range
        );
      }
      break;
    default:
      break;
  }
  if (baseRangeOperator) {
    return Array.isArray(baseRangeOperator) ? runRefRangeMutations(baseRangeOperator, range) : runRefRangeMutations([baseRangeOperator], range);
  } else {
    return range;
  }
}
function getEffectedRangesOnMutation(mutation) {
  switch (mutation.id) {
    case MoveColsMutation.id: {
      const params = mutation.params;
      return [
        params.sourceRange,
        {
          ...params.targetRange,
          startColumn: params.targetRange.startColumn - 0.5,
          endColumn: params.targetRange.startColumn - 0.5
        }
      ];
    }
    case MoveRowsMutation.id: {
      const params = mutation.params;
      return [
        params.sourceRange,
        {
          ...params.targetRange,
          startRow: params.targetRange.startRow - 0.5,
          endRow: params.targetRange.startRow - 0.5
        }
      ];
    }
    case MoveRangeMutation.id: {
      const params = mutation.params;
      return [new ObjectMatrix(params.from.value).getRange(), new ObjectMatrix(params.to.value).getRange()];
    }
    case InsertColMutation.id: {
      const params = mutation.params;
      const range = params.range;
      return [
        {
          ...range,
          startColumn: range.startColumn - 0.5,
          endColumn: range.startColumn - 0.5
        }
      ];
    }
    case InsertRowMutation.id: {
      const params = mutation.params;
      const range = params.range;
      return [
        {
          ...range,
          startRow: range.startRow - 0.5,
          endRow: range.startRow - 0.5
        }
      ];
    }
    case RemoveColMutation.id: {
      const params = mutation.params;
      const range = params.range;
      return [range];
    }
    case RemoveRowMutation.id: {
      const params = mutation.params;
      const range = params.range;
      return [range];
    }
    default:
      break;
  }
}

// ../packages/sheets/src/services/ref-range/ref-range.service.ts
var MERGE_REDO = createInterceptorKey("MERGE_REDO");
var MERGE_UNDO = createInterceptorKey("MERGE_UNDO");
var MAX_ROW_COL = Math.floor(Number.MAX_SAFE_INTEGER / 10);
var WatchRange = class extends Disposable {
  constructor(_unitId, _subUnitId, _range, _callback, _skipIntersects = false) {
    super();
    this._unitId = _unitId;
    this._subUnitId = _subUnitId;
    this._range = _range;
    this._callback = _callback;
    this._skipIntersects = _skipIntersects;
  }
  onMutation(mutation) {
    var _a2, _b2;
    if (((_a2 = mutation.params) == null ? void 0 : _a2.unitId) !== this._unitId) {
      return;
    }
    if (mutation.id === MoveRangeMutation.id) {
      const params = mutation.params;
      if (params.from.subUnitId !== this._subUnitId || params.to.subUnitId !== this._subUnitId) {
        return;
      }
    } else if (((_b2 = mutation.params) == null ? void 0 : _b2.subUnitId) !== this._subUnitId) {
      return;
    }
    if (!this._range) {
      return;
    }
    if (this._skipIntersects) {
      if (mutation.id === RemoveSheetMutation.id) {
        return;
      }
      const effectRanges = getEffectedRangesOnMutation(mutation);
      if (effectRanges == null ? void 0 : effectRanges.some((effectRange) => Rectangle.intersects(effectRange, this._range))) {
        return;
      }
    }
    const afterRange = adjustRangeOnMutation(this._range, mutation);
    if (afterRange && Rectangle.equals(afterRange, this._range)) {
      return false;
    }
    const beforeChange = this._range;
    this._range = afterRange;
    this._callback(beforeChange, afterRange);
  }
};
var RefRangeService = class extends Disposable {
  constructor(_commandService, _sheetInterceptorService, _univerInstanceService, _selectionManagerService) {
    super();
    this._commandService = _commandService;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._univerInstanceService = _univerInstanceService;
    this._selectionManagerService = _selectionManagerService;
    __publicField(this, "interceptor", new InterceptorManager({ MERGE_REDO, MERGE_UNDO }));
    __publicField(this, "_watchRanges", /* @__PURE__ */ new Set());
    __publicField(this, "_refRangeManagerMap", /* @__PURE__ */ new Map());
    __publicField(this, "_serializer", createRangeSerializer());
    // eslint-disable-next-line max-lines-per-function
    __publicField(this, "_onRefRangeChange", () => {
      this._sheetInterceptorService.interceptCommand({
        // eslint-disable-next-line max-lines-per-function
        getMutations: (command) => {
          const worksheet = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getActiveSheet();
          const unitId = getUnitId(this._univerInstanceService);
          const subUnitId = getSubUnitId(this._univerInstanceService);
          if (!worksheet || !unitId || !subUnitId) {
            return { redos: [], undos: [], preRedos: [], preUndos: [] };
          }
          const getEffectsCbList = () => {
            switch (command.id) {
              case EffectRefRangId.MoveColsCommandId: {
                const params = command.params;
                const startColumn = Math.min(params.fromRange.startColumn, params.toRange.startColumn);
                return this._checkRange(
                  [{ ...params.fromRange, startColumn, endColumn: worksheet.getColumnCount() - 1 }],
                  unitId,
                  subUnitId
                );
              }
              case EffectRefRangId.MoveRowsCommandId: {
                const params = command.params;
                const startRow = Math.min(params.fromRange.startRow, params.toRange.startRow);
                return this._checkRange(
                  [{ ...params.fromRange, startRow, endRow: worksheet.getRowCount() - 1 }],
                  unitId,
                  subUnitId
                );
              }
              case EffectRefRangId.MoveRangeCommandId: {
                const params = command;
                return this._checkRange(
                  [params.params.fromRange, params.params.toRange],
                  unitId,
                  subUnitId
                );
              }
              case EffectRefRangId.InsertRowCommandId: {
                const params = command;
                const rowStart = params.params.range.startRow;
                const range = {
                  startRow: rowStart,
                  endRow: worksheet.getRowCount() - 1,
                  startColumn: 0,
                  endColumn: worksheet.getColumnCount() - 1,
                  rangeType: 1 /* ROW */
                };
                return this._checkRange([range], unitId, subUnitId);
              }
              case EffectRefRangId.InsertColCommandId: {
                const params = command;
                const colStart = params.params.range.startColumn;
                const range = {
                  startRow: 0,
                  endRow: worksheet.getRowCount() - 1,
                  startColumn: colStart,
                  endColumn: worksheet.getColumnCount() - 1,
                  rangeType: 2 /* COLUMN */
                };
                return this._checkRange([range], unitId, subUnitId);
              }
              case EffectRefRangId.RemoveRowCommandId: {
                const params = command;
                const rowStart = params.params.range.startRow;
                const range = {
                  startRow: rowStart,
                  endRow: worksheet.getRowCount() - 1,
                  startColumn: 0,
                  endColumn: worksheet.getColumnCount() - 1,
                  rangeType: 1 /* ROW */
                };
                return this._checkRange([range], unitId, subUnitId);
              }
              case EffectRefRangId.RemoveColCommandId: {
                const params = command;
                const colStart = params.params.range.startColumn;
                const range = {
                  startRow: 0,
                  endRow: worksheet.getRowCount() - 1,
                  startColumn: colStart,
                  endColumn: worksheet.getColumnCount() - 1,
                  rangeType: 2 /* COLUMN */
                };
                return this._checkRange([range], unitId, subUnitId);
              }
              case EffectRefRangId.DeleteRangeMoveUpCommandId:
              case EffectRefRangId.InsertRangeMoveDownCommandId: {
                const params = command;
                const range = params.params.range || getSelectionRanges(this._selectionManagerService)[0];
                const effectRange = {
                  startRow: range.startRow,
                  startColumn: range.startColumn,
                  endColumn: range.endColumn,
                  endRow: MAX_ROW_COL
                };
                return this._checkRange([effectRange], unitId, subUnitId);
              }
              case EffectRefRangId.DeleteRangeMoveLeftCommandId:
              case EffectRefRangId.InsertRangeMoveRightCommandId: {
                const params = command;
                const range = params.params.range || getSelectionRanges(this._selectionManagerService)[0];
                const effectRange = {
                  startRow: range.startRow,
                  startColumn: range.startColumn,
                  endColumn: MAX_ROW_COL,
                  endRow: range.endRow
                };
                return this._checkRange([effectRange], unitId, subUnitId);
              }
              case EffectRefRangId.ReorderRangeCommandId: {
                const params = command;
                const { range, order } = params.params;
                const effectRanges = [];
                for (let row = range.startRow; row <= range.endRow; row++) {
                  if (row in order) {
                    effectRanges.push({
                      startRow: row,
                      endRow: row,
                      startColumn: range.startColumn,
                      endColumn: range.endColumn
                    });
                  }
                }
                return this._checkRange(effectRanges, unitId, subUnitId);
              }
            }
          };
          const cbList = getEffectsCbList() || [];
          const result = cbList.reduce(
            (result2, currentFn) => {
              const v = currentFn(command);
              result2.push(v);
              return result2;
            },
            []
          ).reduce(
            (result2, currentValue) => {
              var _a2, _b2;
              result2.redos.push(...currentValue.redos);
              result2.undos.push(...currentValue.undos);
              result2.preRedos.push(...(_a2 = currentValue.preRedos) != null ? _a2 : []);
              result2.preUndos.push(...(_b2 = currentValue.preUndos) != null ? _b2 : []);
              return result2;
            },
            { redos: [], undos: [], preUndos: [], preRedos: [] }
          );
          const preRedos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_REDO)(
            result.preRedos,
            null
          ) || [];
          const redos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_REDO)(
            result.redos,
            null
          ) || [];
          const preUndos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_UNDO)(
            result.preUndos,
            null
          ) || [];
          const undos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_UNDO)(
            result.undos,
            null
          ) || [];
          return { redos, undos, preRedos, preUndos };
        }
      });
    });
    __publicField(this, "_checkRange", (effectRanges, unitId, subUnitId) => {
      const managerId = getRefRangId(unitId, subUnitId);
      const manager = this._refRangeManagerMap.get(managerId);
      if (manager) {
        const callbackSet = /* @__PURE__ */ new Set();
        const keyList = [...manager.keys()];
        keyList.forEach((key) => {
          const cbList = manager.get(key);
          const range = this._serializer.deserialize(key);
          const realRange = {
            ...range,
            startRow: +range.startRow,
            endRow: +range.endRow,
            startColumn: +range.startColumn,
            endColumn: +range.endColumn,
            rangeType: range.rangeType && +range.rangeType
          };
          if (effectRanges.some((item) => Rectangle.intersects(item, realRange))) {
            cbList && cbList.forEach((callback) => {
              callbackSet.add(callback);
            });
          }
        });
        return [...callbackSet];
      }
      return [];
    });
    /**
     * Listens to an area and triggers a fall back when movement occurs
     * @param {IRange} range the area that needs to be monitored
     * @param {RefRangCallback} callback the callback function that is executed when the range changes
     * @param {string} [_unitId]
     * @param {string} [_subUnitId]
     * @memberof RefRangeService
     */
    __publicField(this, "registerRefRange", (range, callback, _unitId, _subUnitId) => {
      const unitId = _unitId || getUnitId(this._univerInstanceService);
      const subUnitId = _subUnitId || getSubUnitId(this._univerInstanceService);
      if (!unitId || !subUnitId) {
        return toDisposable(() => {
        });
      }
      const refRangeManagerId = getRefRangId(unitId, subUnitId);
      const rangeString = this._serializer.serialize(range);
      let manager = this._refRangeManagerMap.get(refRangeManagerId);
      if (!manager) {
        manager = /* @__PURE__ */ new Map();
        this._refRangeManagerMap.set(refRangeManagerId, manager);
      }
      const refRangeCallbackList = manager.get(rangeString);
      if (refRangeCallbackList) {
        refRangeCallbackList.add(callback);
      } else {
        manager.set(rangeString, /* @__PURE__ */ new Set([callback]));
      }
      return toDisposable(() => {
        const refRangeCallbackList2 = manager.get(rangeString);
        if (refRangeCallbackList2) {
          refRangeCallbackList2.delete(callback);
          if (!refRangeCallbackList2.size) {
            manager.delete(rangeString);
            if (!manager.size) {
              this._refRangeManagerMap.delete(refRangeManagerId);
            }
          }
        }
      });
    });
    this._onRefRangeChange();
    this.interceptor.intercept(this.interceptor.getInterceptPoints().MERGE_REDO, {
      priority: -1,
      handler: (list) => list
    });
    this.interceptor.intercept(this.interceptor.getInterceptPoints().MERGE_UNDO, {
      priority: -1,
      handler: (list) => list
    });
  }
  watchRange(unitId, subUnitId, range, callback, skipIntersects) {
    let watchRangesListener;
    if (this._watchRanges.size === 0) {
      watchRangesListener = this._commandService.onCommandExecuted((command) => {
        if (command.type !== 2 /* MUTATION */) return false;
        for (const watchRange2 of this._watchRanges) {
          watchRange2.onMutation(command);
        }
      });
    }
    const watchRange = new WatchRange(unitId, subUnitId, range, callback, skipIntersects);
    this._watchRanges.add(watchRange);
    const teardownWatching = toDisposable(() => {
      this._watchRanges.delete(watchRange);
      if (this._watchRanges.size === 0) {
        watchRangesListener == null ? void 0 : watchRangesListener.dispose();
        watchRangesListener = null;
      }
    });
    const registerToService = this.disposeWithMe(teardownWatching);
    return toDisposable(() => {
      registerToService.dispose();
      teardownWatching.dispose();
    });
  }
};
RefRangeService = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, Inject(SheetInterceptorService)),
  __decorateParam(2, Inject(IUniverInstanceService)),
  __decorateParam(3, Inject(SheetsSelectionsService))
], RefRangeService);
function getUnitId(univerInstanceService) {
  return univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getUnitId();
}
function getSubUnitId(univerInstanceService) {
  var _a2;
  return (_a2 = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET).getActiveSheet()) == null ? void 0 : _a2.getSheetId();
}
function getSelectionRanges(selectionManagerService) {
  var _a2;
  return ((_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range)) || [];
}
function getRefRangId(unitId, subUnitId) {
  return `${unitId}_${subUnitId}`;
}
function createRangeSerializer() {
  const keyList = ["startRow", "startColumn", "endRow", "endColumn", "rangeType"];
  const SPLIT_CODE = "_";
  return {
    deserialize: (rangeString) => {
      const map9 = keyList.reduce(
        (preValue, currentValue, index) => {
          preValue[String(index)] = currentValue;
          return preValue;
        },
        {}
      );
      const res = rangeString.split(SPLIT_CODE).reduce(
        (preValue, currentValue, _index) => {
          const index = String(_index);
          if (currentValue && map9[index]) {
            preValue[map9[index]] = currentValue;
          }
          return preValue;
        },
        {}
      );
      return res;
    },
    serialize: (range) => keyList.reduce((preValue, currentValue, index) => {
      const value = range[currentValue];
      if (value !== void 0) {
        return `${preValue}${index > 0 ? SPLIT_CODE : ""}${value}`;
      }
      return `${preValue}`;
    }, "")
  };
}

// ../packages/sheets/src/controllers/merge-cell.controller.ts
var mutationIdByRowCol = [InsertColMutation.id, InsertRowMutation.id, RemoveColMutation.id, RemoveRowMutation.id];
var mutationIdArrByMove = [MoveRowsMutation.id, MoveColsMutation.id];
function getAddMergeMutationRangeByType(selection, type2) {
  let ranges = selection;
  if (type2 !== void 0) {
    const rectangles = [];
    for (let i = 0; i < ranges.length; i++) {
      const { startRow, endRow, startColumn, endColumn } = ranges[i];
      if (type2 === 1 /* ROWS */) {
        for (let r = startRow; r <= endRow; r++) {
          const data = {
            startRow: r,
            endRow: r,
            startColumn,
            endColumn
          };
          rectangles.push(data);
        }
      } else if (type2 === 0 /* COLUMNS */) {
        for (let c = startColumn; c <= endColumn; c++) {
          const data = {
            startRow,
            endRow,
            startColumn: c,
            endColumn: c
          };
          rectangles.push(data);
        }
      }
    }
    ranges = rectangles;
  }
  return ranges;
}
var MERGE_CELL_INTERCEPTOR_CHECK = createInterceptorKey("mergeCellPermissionCheck");
var MergeCellController = class extends Disposable {
  constructor(_commandService, _refRangeService, _univerInstanceService, _injector, _sheetInterceptorService, _selectionManagerService) {
    super();
    this._commandService = _commandService;
    this._refRangeService = _refRangeService;
    this._univerInstanceService = _univerInstanceService;
    this._injector = _injector;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._selectionManagerService = _selectionManagerService;
    __publicField(this, "disposableCollection", new DisposableCollection());
    __publicField(this, "interceptor", new InterceptorManager({ MERGE_CELL_INTERCEPTOR_CHECK }));
    this._onRefRangeChange();
    this._initCommandInterceptor();
    this._commandExecutedListener();
  }
  _initCommandInterceptor() {
    const self2 = this;
    this._sheetInterceptorService.interceptCommand({
      getMutations(commandInfo) {
        var _a2;
        switch (commandInfo.id) {
          case ClearSelectionAllCommand.id:
          case ClearSelectionFormatCommand.id: {
            const workbook = self2._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
            const unitId = workbook.getUnitId();
            const worksheet = workbook == null ? void 0 : workbook.getActiveSheet();
            if (!worksheet) {
              return { redos: [], undos: [] };
            }
            const subUnitId = worksheet.getSheetId();
            const mergeData = worksheet.getConfig().mergeData;
            const selections = (_a2 = self2._selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
            if (selections && selections.length > 0) {
              const isHasMerge = selections.some(
                (range) => mergeData.some((item) => Rectangle.intersects(item, range))
              );
              if (isHasMerge) {
                const removeMergeParams = {
                  unitId,
                  subUnitId,
                  ranges: selections
                };
                const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(self2._injector, removeMergeParams);
                const redos = [
                  { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams }
                ];
                const undos = [
                  { id: AddWorksheetMergeMutation.id, params: undoRemoveMergeParams }
                ];
                return { redos, undos };
              }
            }
          }
        }
        return { redos: [], undos: [] };
      }
    });
    this._sheetInterceptorService.interceptRanges({
      getMutations: ({ unitId, subUnitId, ranges }) => {
        const redos = [];
        const undos = [];
        const emptyInterceptorArr = { redos, undos };
        if (!ranges || !ranges.length) {
          return emptyInterceptorArr;
        }
        const target = getSheetCommandTarget(this._univerInstanceService, { unitId, subUnitId });
        if (!target) {
          return emptyInterceptorArr;
        }
        const { worksheet } = target;
        const mergeData = worksheet.getMergeData();
        const overlapRanges = mergeData.filter((item) => ranges.some((range) => Rectangle.intersects(item, range)));
        if (overlapRanges.length) {
          redos.push({
            id: RemoveWorksheetMergeMutation.id,
            params: {
              unitId,
              subUnitId,
              ranges: overlapRanges
            }
          });
          undos.push({
            id: AddWorksheetMergeMutation.id,
            params: {
              unitId,
              subUnitId,
              ranges: overlapRanges
            }
          });
          return { undos, redos };
        }
        return emptyInterceptorArr;
      }
    });
  }
  refRangeHandle(config2, unitId, subUnitId) {
    switch (config2.id) {
      case EffectRefRangId.MoveColsCommandId: {
        const params = config2.params;
        return this._handleMoveColsCommand(params, unitId, subUnitId);
      }
      case EffectRefRangId.MoveRowsCommandId: {
        const params = config2.params;
        return this._handleMoveRowsCommand(params, unitId, subUnitId);
      }
      case InsertRowCommand.id: {
        const params = config2.params;
        const _unitId = params.unitId || unitId;
        const _subUnitId = params.subUnitId || subUnitId;
        return this._handleInsertRowCommand(params, _unitId, _subUnitId);
      }
      case InsertColCommand.id: {
        const params = config2.params;
        const _unitId = params.unitId || unitId;
        const _subUnitId = params.subUnitId || subUnitId;
        return this._handleInsertColCommand(params, _unitId, _subUnitId);
      }
      case RemoveColCommand.id: {
        const params = config2.params;
        return this._handleRemoveColCommand(params, unitId, subUnitId);
      }
      case RemoveRowCommand.id: {
        const params = config2.params;
        return this._handleRemoveRowCommand(params, unitId, subUnitId);
      }
      case MoveRangeCommand.id: {
        const params = config2.params;
        return this._handleMoveRangeCommand(params, unitId, subUnitId);
      }
      case InsertRangeMoveRightCommand.id: {
        const params = config2.params;
        return this._handleInsertRangeMoveRightCommand(params, unitId, subUnitId);
      }
      case InsertRangeMoveDownCommand.id: {
        const params = config2.params;
        return this._handleInsertRangeMoveDownCommand(params, unitId, subUnitId);
      }
      case DeleteRangeMoveUpCommand.id: {
        const params = config2.params;
        return this._handleDeleteRangeMoveUpCommand(params, unitId, subUnitId);
      }
      case DeleteRangeMoveLeftCommand.id: {
        const params = config2.params;
        return this._handleDeleteRangeMoveLeftCommand(params, unitId, subUnitId);
      }
    }
    return { redos: [], undos: [] };
  }
  _onRefRangeChange() {
    const registerRefRange = (unitId, subUnitId) => {
      const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook) {
        return;
      }
      const workSheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
      if (!workSheet) {
        return;
      }
      this.disposableCollection.dispose();
      const mergeData = workSheet.getMergeData();
      const handler = (config2) => {
        return this.refRangeHandle(config2, unitId, subUnitId);
      };
      mergeData.forEach((range) => {
        this.disposableCollection.add(this._refRangeService.registerRefRange(range, handler, unitId, subUnitId));
      });
    };
    this.disposeWithMe(
      this._commandService.onCommandExecuted((commandInfo) => {
        if (commandInfo.id === SetWorksheetActiveOperation.id) {
          const params = commandInfo.params;
          const sheetId = params.subUnitId;
          const unitId = params.unitId;
          if (!sheetId || !unitId) {
            return;
          }
          registerRefRange(unitId, sheetId);
        }
        if (commandInfo.id === AddWorksheetMergeMutation.id) {
          const params = commandInfo.params;
          const sheetId = params.subUnitId;
          const unitId = params.unitId;
          if (!sheetId || !unitId) {
            return;
          }
          registerRefRange(params.unitId, params.subUnitId);
        }
      })
    );
    this._univerInstanceService.getCurrentTypeOfUnit$(O.UNIVER_SHEET).pipe((0, import_rxjs36.first)((workbook) => !!workbook)).subscribe((workbook) => {
      const sheet = workbook.getActiveSheet();
      if (!sheet) return;
      registerRefRange(workbook.getUnitId(), sheet.getSheetId());
    });
  }
  _handleMoveRowsCommand(params, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const mergeData = [...worksheet.getMergeData()];
    const removeParams = { unitId, subUnitId, ranges: [] };
    const addParams = { unitId, subUnitId, ranges: [] };
    const { fromRange } = params;
    const { startRow: sourceStart, endRow: sourceEnd } = fromRange;
    mergeData.forEach((range) => {
      if (sourceStart <= range.startRow && sourceEnd >= range.endRow) {
        removeParams.ranges.push(range);
        const operation = handleMoveRows({ id: EffectRefRangId.MoveRowsCommandId, params }, range);
        const result = runRefRangeMutations(operation, range);
        result && addParams.ranges.push(result);
      }
    });
    if (removeParams.ranges.length === 0) {
      return this._handleNull();
    }
    const removeUndo = RemoveMergeUndoMutationFactory(this._injector, removeParams);
    const addUndo = AddMergeUndoMutationFactory(this._injector, addParams);
    return {
      preRedos: [{ id: RemoveWorksheetMergeMutation.id, params: removeParams }],
      redos: [{ id: AddWorksheetMergeMutation.id, params: addParams }],
      preUndos: [{ id: RemoveWorksheetMergeMutation.id, params: addUndo }],
      undos: [{ id: AddWorksheetMergeMutation.id, params: removeUndo }]
    };
  }
  _handleMoveColsCommand(params, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const mergeData = [...worksheet.getMergeData()];
    const removeParams = { unitId, subUnitId, ranges: [] };
    const addParams = { unitId, subUnitId, ranges: [] };
    const { fromRange } = params;
    const { startColumn: sourceStart, endColumn: sourceEnd } = fromRange;
    mergeData.forEach((range) => {
      if (sourceStart <= range.startColumn && sourceEnd >= range.endColumn) {
        removeParams.ranges.push(range);
        const operation = handleMoveCols({ id: EffectRefRangId.MoveColsCommandId, params }, range);
        const result = runRefRangeMutations(operation, range);
        result && addParams.ranges.push(result);
      }
    });
    if (removeParams.ranges.length === 0) {
      return this._handleNull();
    }
    const removeUndo = RemoveMergeUndoMutationFactory(this._injector, removeParams);
    const addUndo = AddMergeUndoMutationFactory(this._injector, addParams);
    return {
      preRedos: [{ id: RemoveWorksheetMergeMutation.id, params: removeParams }],
      redos: [{ id: AddWorksheetMergeMutation.id, params: addParams }],
      preUndos: [{ id: RemoveWorksheetMergeMutation.id, params: addUndo }],
      undos: [{ id: AddWorksheetMergeMutation.id, params: removeUndo }]
    };
  }
  _handleMoveRangeCommand(params, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const mergeData = worksheet.getMergeData();
    const fromMergeRanges = mergeData.filter((item) => Rectangle.intersects(item, params.fromRange));
    const toMergeRanges = mergeData.filter((item) => Rectangle.intersects(item, params.toRange));
    const willMoveToMergeRanges = fromMergeRanges.map((mergeRange) => Rectangle.getRelativeRange(mergeRange, params.fromRange)).map((relativeRange) => Rectangle.getPositionRange(relativeRange, params.toRange));
    const addMergeCellRanges = getAddMergeMutationRangeByType(willMoveToMergeRanges).filter(
      (range) => !mergeData.some((mergeRange) => Rectangle.equals(range, mergeRange))
    );
    const redos = [
      {
        id: RemoveWorksheetMergeMutation.id,
        params: {
          unitId,
          subUnitId,
          ranges: fromMergeRanges
        }
      },
      {
        id: RemoveWorksheetMergeMutation.id,
        params: {
          unitId,
          subUnitId,
          ranges: toMergeRanges
        }
      },
      {
        id: AddWorksheetMergeMutation.id,
        params: {
          unitId,
          subUnitId,
          ranges: addMergeCellRanges
        }
      }
    ];
    const undos = [
      {
        id: RemoveWorksheetMergeMutation.id,
        params: {
          unitId,
          subUnitId,
          ranges: addMergeCellRanges
        }
      },
      {
        id: AddWorksheetMergeMutation.id,
        params: {
          unitId,
          subUnitId,
          ranges: toMergeRanges
        }
      },
      {
        id: AddWorksheetMergeMutation.id,
        params: {
          unitId,
          subUnitId,
          ranges: fromMergeRanges
        }
      }
    ];
    return { redos, undos };
  }
  _handleInsertRowCommand(config2, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const { range } = config2;
    const { startRow, endRow } = range;
    const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (startRow > cell.startRow && startRow <= cell.endRow) {
        mergeCellsHasLapping.push(cell);
      }
      return mergeCellsHasLapping;
    }, []);
    if (oldMergeCells.length === 0) {
      return this._handleNull();
    }
    const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (startRow > cell.startRow && startRow <= cell.endRow) {
        const count = endRow - startRow + 1;
        cell.endRow += count;
        if (this._checkIsMergeCell(cell)) {
          mergeCellsHasLapping.push(cell);
        }
      }
      return mergeCellsHasLapping;
    }, []);
    const removeMergeParams = {
      unitId,
      subUnitId,
      ranges: oldMergeCells
    };
    const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
      this._injector,
      removeMergeParams
    );
    const addMergeParams = {
      unitId,
      subUnitId,
      ranges: newMergeCells
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(
      this._injector,
      addMergeParams
    );
    const redos = [
      { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams },
      { id: AddWorksheetMergeMutation.id, params: addMergeParams }
    ];
    const undos = [
      { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams },
      { id: AddWorksheetMergeMutation.id, params: undoRemoveMergeParams }
    ];
    return { redos, undos };
  }
  _handleInsertColCommand(config2, unitId, subUnitId) {
    const { range } = config2;
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const { startColumn, endColumn } = range;
    const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (startColumn > cell.startColumn && startColumn <= cell.endColumn) {
        mergeCellsHasLapping.push(cell);
      }
      return mergeCellsHasLapping;
    }, []);
    if (oldMergeCells.length === 0) {
      return this._handleNull();
    }
    const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (startColumn > cell.startColumn && startColumn <= cell.endColumn) {
        const count = endColumn - startColumn + 1;
        cell.endColumn += count;
        if (this._checkIsMergeCell(cell)) {
          mergeCellsHasLapping.push(cell);
        }
      }
      return mergeCellsHasLapping;
    }, []);
    const removeMergeParams = {
      unitId,
      subUnitId,
      ranges: oldMergeCells
    };
    const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
      this._injector,
      removeMergeParams
    );
    const addMergeParams = {
      unitId,
      subUnitId,
      ranges: newMergeCells
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(
      this._injector,
      addMergeParams
    );
    const redos = [
      { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams },
      { id: AddWorksheetMergeMutation.id, params: addMergeParams }
    ];
    const undos = [
      { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams },
      { id: AddWorksheetMergeMutation.id, params: undoRemoveMergeParams }
    ];
    return { redos, undos };
  }
  _handleRemoveColCommand(config2, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const { range } = config2;
    const { startColumn, endColumn } = range;
    const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (Rectangle.intersects(range, cell)) {
        mergeCellsHasLapping.push(cell);
      }
      return mergeCellsHasLapping;
    }, []);
    if (oldMergeCells.length === 0) {
      return this._handleNull();
    }
    const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (Rectangle.intersects(range, cell)) {
        if (startColumn <= cell.startColumn && endColumn >= cell.endColumn) {
          return mergeCellsHasLapping;
        } else if (startColumn >= cell.startColumn && endColumn <= cell.endColumn) {
          cell.endColumn -= endColumn - startColumn + 1;
        } else if (startColumn < cell.startColumn) {
          cell.startColumn = startColumn;
          cell.endColumn -= endColumn - startColumn + 1;
        } else if (endColumn > cell.endColumn) {
          cell.endColumn = startColumn - 1;
        }
        if (this._checkIsMergeCell(cell)) {
          mergeCellsHasLapping.push(cell);
        }
      }
      return mergeCellsHasLapping;
    }, []);
    const removeMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: oldMergeCells
    };
    const undoRemoveMergeMutationParams = RemoveMergeUndoMutationFactory(
      this._injector,
      removeMergeMutationParams
    );
    const addMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: newMergeCells
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(
      this._injector,
      addMergeMutationParams
    );
    const preRedos = [{ id: RemoveWorksheetMergeMutation.id, params: removeMergeMutationParams }];
    const redos = [{ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams }];
    const preUndos = [{ id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }];
    const undos = [{ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams }];
    return { preUndos, undos, preRedos, redos };
  }
  _handleRemoveRowCommand(config2, unitId, subUnitId) {
    const { range } = config2;
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const { startRow, endRow } = range;
    const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (Rectangle.intersects(range, cell)) {
        mergeCellsHasLapping.push(cell);
      }
      return mergeCellsHasLapping;
    }, []);
    if (oldMergeCells.length === 0) {
      return this._handleNull();
    }
    const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
      if (Rectangle.intersects(range, cell)) {
        if (startRow <= cell.startRow && endRow >= cell.endRow) {
          return mergeCellsHasLapping;
        } else if (startRow >= cell.startRow && endRow <= cell.endRow) {
          cell.endRow -= endRow - startRow + 1;
        } else if (startRow < cell.startRow) {
          cell.startRow = startRow;
          cell.endRow -= endRow - startRow + 1;
        } else if (endRow > cell.endRow) {
          cell.endRow = startRow - 1;
        }
        if (this._checkIsMergeCell(cell)) {
          mergeCellsHasLapping.push(cell);
        }
      }
      return mergeCellsHasLapping;
    }, []);
    const removeMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: oldMergeCells
    };
    const undoRemoveMergeMutationParams = RemoveMergeUndoMutationFactory(
      this._injector,
      removeMergeMutationParams
    );
    const addMergeMutationParams = {
      unitId,
      subUnitId,
      ranges: newMergeCells
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(
      this._injector,
      addMergeMutationParams
    );
    const preRedos = [{ id: RemoveWorksheetMergeMutation.id, params: removeMergeMutationParams }];
    const redos = [{ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams }];
    const preUndos = [{ id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }];
    const undos = [{ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams }];
    return { preUndos, undos, preRedos, redos };
  }
  _handleInsertRangeMoveRightCommand(config2, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const range = config2.range;
    const maxCol = worksheet.getMaxColumns() - 1;
    const mergeData = worksheet.getMergeData();
    const removeMergeData = [];
    const addMergeData = [];
    mergeData.forEach((rect) => {
      const { startRow, endRow, startColumn, endColumn } = range;
      const intersects2 = Rectangle.intersects(
        {
          startRow,
          startColumn,
          endRow,
          endColumn: maxCol
        },
        rect
      );
      if (intersects2) {
        removeMergeData.push(rect);
        const contains2 = Rectangle.contains(
          {
            startRow,
            startColumn,
            endRow,
            endColumn: maxCol
          },
          rect
        );
        if (contains2) {
          const currentColumnsCount = endColumn - startColumn + 1;
          addMergeData.push({
            startRow: rect.startRow,
            startColumn: rect.startColumn + currentColumnsCount,
            endRow: rect.endRow,
            endColumn: rect.endColumn + currentColumnsCount
          });
        }
      }
    });
    const removeMergeParams = {
      unitId,
      subUnitId,
      ranges: removeMergeData
    };
    const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
      this._injector,
      removeMergeParams
    );
    const addMergeParams = {
      unitId,
      subUnitId,
      ranges: addMergeData
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(
      this._injector,
      addMergeParams
    );
    return {
      preRedos: [
        { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams }
      ],
      redos: [
        {
          id: AddWorksheetMergeMutation.id,
          params: addMergeParams
        }
      ],
      preUndos: [
        { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }
      ],
      undos: [
        {
          id: AddWorksheetMergeMutation.id,
          params: undoRemoveMergeParams
        }
      ]
    };
  }
  _handleInsertRangeMoveDownCommand(config2, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const range = config2.range;
    const maxRow = worksheet.getMaxRows() - 1;
    const mergeData = worksheet.getMergeData();
    const removeMergeData = [];
    const addMergeData = [];
    mergeData.forEach((rect) => {
      const { startRow, startColumn, endColumn, endRow } = range;
      const intersects2 = Rectangle.intersects({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
      if (intersects2) {
        removeMergeData.push(rect);
        const contains2 = Rectangle.contains({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
        if (contains2) {
          const rowCount = endRow - startRow + 1;
          addMergeData.push({
            startRow: rect.startRow + rowCount,
            startColumn: rect.startColumn,
            endRow: rect.endRow + rowCount,
            endColumn: rect.endColumn
          });
        }
      }
    });
    const removeMergeParams = {
      unitId,
      subUnitId,
      ranges: removeMergeData
    };
    const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
      this._injector,
      removeMergeParams
    );
    const addMergeParams = {
      unitId,
      subUnitId,
      ranges: addMergeData
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(
      this._injector,
      addMergeParams
    );
    const preRedos = [
      {
        id: RemoveWorksheetMergeMutation.id,
        params: removeMergeParams
      }
    ];
    const redos = [
      {
        id: AddWorksheetMergeMutation.id,
        params: addMergeParams
      }
    ];
    const preUndos = [
      {
        id: RemoveWorksheetMergeMutation.id,
        params: undoAddMergeParams
      }
    ];
    const undos = [
      {
        id: AddWorksheetMergeMutation.id,
        params: undoRemoveMergeParams
      }
    ];
    return { redos, undos, preRedos, preUndos };
  }
  _handleDeleteRangeMoveUpCommand(config2, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const range = config2.range;
    const maxRow = worksheet.getMaxRows() - 1;
    const mergeData = worksheet.getMergeData();
    const removeMergeData = [];
    const addMergeData = [];
    mergeData.forEach((rect) => {
      const { startRow, startColumn, endColumn, endRow } = range;
      const intersects2 = Rectangle.intersects({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
      if (intersects2) {
        removeMergeData.push(rect);
        const contains2 = Rectangle.contains({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
        if (contains2) {
          const rowCount = endRow - startRow + 1;
          const range2 = Rectangle.moveVertical(rect, -rowCount);
          addMergeData.push(range2);
        }
      }
    });
    const removeMergeParams = {
      unitId,
      subUnitId,
      ranges: removeMergeData
    };
    const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
      this._injector,
      removeMergeParams
    );
    const addMergeParams = {
      unitId,
      subUnitId,
      ranges: addMergeData
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(
      this._injector,
      addMergeParams
    );
    const preRedos = [
      {
        id: RemoveWorksheetMergeMutation.id,
        params: removeMergeParams
      }
    ];
    const redos = [
      {
        id: AddWorksheetMergeMutation.id,
        params: addMergeParams
      }
    ];
    const preUndos = [
      {
        id: RemoveWorksheetMergeMutation.id,
        params: undoAddMergeParams
      }
    ];
    const undos = [
      {
        id: AddWorksheetMergeMutation.id,
        params: undoRemoveMergeParams
      }
    ];
    return { redos, undos, preRedos, preUndos };
  }
  _handleDeleteRangeMoveLeftCommand(config2, unitId, subUnitId) {
    const workbook = getWorkbook(this._univerInstanceService, unitId);
    if (!workbook) {
      return this._handleNull();
    }
    const worksheet = getWorksheet(workbook, subUnitId);
    if (!worksheet) {
      return this._handleNull();
    }
    const range = config2.range;
    const maxCol = worksheet.getMaxColumns() - 1;
    const mergeData = worksheet.getMergeData();
    const removeMergeData = [];
    const addMergeData = [];
    mergeData.forEach((rect) => {
      const { startRow, endRow, startColumn, endColumn } = range;
      const intersects2 = Rectangle.intersects(
        {
          startRow,
          startColumn,
          endRow,
          endColumn: maxCol
        },
        rect
      );
      if (intersects2) {
        removeMergeData.push(rect);
        const contains2 = Rectangle.contains(
          {
            startRow,
            startColumn,
            endRow,
            endColumn: maxCol
          },
          rect
        );
        if (contains2) {
          const currentColumnsCount = endColumn - startColumn + 1;
          addMergeData.push({
            startRow: rect.startRow,
            startColumn: rect.startColumn - currentColumnsCount,
            endRow: rect.endRow,
            endColumn: rect.endColumn - currentColumnsCount
          });
        }
      }
    });
    const removeMergeParams = {
      unitId,
      subUnitId,
      ranges: removeMergeData
    };
    const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(this._injector, removeMergeParams);
    const addMergeParams = {
      unitId,
      subUnitId,
      ranges: addMergeData
    };
    const undoAddMergeParams = AddMergeUndoMutationFactory(this._injector, addMergeParams);
    return {
      preRedos: [
        { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams }
      ],
      redos: [
        {
          id: AddWorksheetMergeMutation.id,
          params: addMergeParams
        }
      ],
      undos: [
        {
          id: AddWorksheetMergeMutation.id,
          params: undoRemoveMergeParams
        }
      ],
      preUndos: [
        { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }
      ]
    };
  }
  _checkIsMergeCell(cell) {
    return !(cell.startRow === cell.endRow && cell.startColumn === cell.endColumn);
  }
  _handleNull() {
    return { redos: [], undos: [] };
  }
  _commandExecutedListener() {
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      if (mutationIdArrByMove.includes(command.id)) {
        if (!command.params) return;
        const workbook = this._univerInstanceService.getUniverSheetInstance(command.params.unitId);
        if (!workbook) return;
        const worksheet = workbook.getSheetBySheetId(command.params.subUnitId);
        if (!worksheet) return;
        const { sourceRange, targetRange } = command.params;
        const isRowMove = sourceRange.startColumn === targetRange.startColumn && sourceRange.endColumn === targetRange.endColumn;
        const moveLength = isRowMove ? sourceRange.endRow - sourceRange.startRow + 1 : sourceRange.endColumn - sourceRange.startColumn + 1;
        const sourceStart = isRowMove ? sourceRange.startRow : sourceRange.startColumn;
        const targetStart = isRowMove ? targetRange.startRow : targetRange.startColumn;
        const mergeData = worksheet.getConfig().mergeData;
        const adjustedMergedCells = [];
        mergeData.forEach((merge5) => {
          let { startRow, endRow, startColumn, endColumn, rangeType } = merge5;
          if (!Rectangle.intersects(merge5, sourceRange)) {
            if (isRowMove) {
              if (sourceStart < startRow && targetStart > endRow) {
                startRow -= moveLength;
                endRow -= moveLength;
              } else if (sourceStart > endRow && targetStart <= startRow) {
                startRow += moveLength;
                endRow += moveLength;
              }
            } else {
              if (sourceStart < startColumn && targetStart > endColumn) {
                startColumn -= moveLength;
                endColumn -= moveLength;
              } else if (sourceStart > endColumn && targetStart <= startColumn) {
                startColumn += moveLength;
                endColumn += moveLength;
              }
            }
          }
          if (!(merge5.startRow === merge5.endRow && merge5.startColumn === merge5.endColumn)) {
            adjustedMergedCells.push({ startRow, endRow, startColumn, endColumn, rangeType });
          }
        });
        worksheet.setMergeData(adjustedMergedCells);
        this.disposableCollection.dispose();
        const { unitId, subUnitId } = command.params;
        const handler = (config2) => {
          return this.refRangeHandle(config2, unitId, subUnitId);
        };
        adjustedMergedCells.forEach((range) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(range, handler, unitId, subUnitId));
        });
      }
      if (mutationIdByRowCol.includes(command.id)) {
        const workbook = this._univerInstanceService.getUniverSheetInstance(command.params.unitId);
        if (!workbook) return;
        const worksheet = workbook.getSheetBySheetId(command.params.subUnitId);
        if (!worksheet) return;
        const mergeData = worksheet.getConfig().mergeData;
        const params = command.params;
        if (!params) return;
        const { range } = params;
        const isRowOperation = command.id.includes("row");
        const isAddOperation = command.id.includes("insert");
        const operationStart = isRowOperation ? range.startRow : range.startColumn;
        const operationEnd = isRowOperation ? range.endRow : range.endColumn;
        const operationCount = operationEnd - operationStart + 1;
        const adjustedMergedCells = [];
        mergeData.forEach((merge5) => {
          let { startRow, endRow, startColumn, endColumn, rangeType } = merge5;
          if (isAddOperation) {
            if (isRowOperation) {
              if (operationStart <= startRow) {
                startRow += operationCount;
                endRow += operationCount;
              }
            } else {
              if (operationStart <= startColumn) {
                startColumn += operationCount;
                endColumn += operationCount;
              }
            }
          } else {
            if (isRowOperation) {
              if (operationEnd < startRow) {
                startRow -= operationCount;
                endRow -= operationCount;
              }
            } else {
              if (operationEnd < startColumn) {
                startColumn -= operationCount;
                endColumn -= operationCount;
              }
            }
          }
          if (!(merge5.startRow === merge5.endRow && merge5.startColumn === merge5.endColumn)) {
            adjustedMergedCells.push({ startRow, endRow, startColumn, endColumn, rangeType });
          }
        });
        worksheet.setMergeData(adjustedMergedCells);
        this.disposableCollection.dispose();
        const { unitId, subUnitId } = command.params;
        const handler = (config2) => {
          return this.refRangeHandle(config2, unitId, subUnitId);
        };
        adjustedMergedCells.forEach((range2) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(range2, handler, unitId, subUnitId));
        });
      }
    }));
  }
};
MergeCellController = __decorateClass([
  __decorateParam(0, Inject(ICommandService)),
  __decorateParam(1, Inject(RefRangeService)),
  __decorateParam(2, Inject(IUniverInstanceService)),
  __decorateParam(3, Inject(Injector)),
  __decorateParam(4, Inject(SheetInterceptorService)),
  __decorateParam(5, Inject(SheetsSelectionsService))
], MergeCellController);
function getWorkbook(univerInstanceService, unitId) {
  if (unitId) {
    return univerInstanceService.getUniverSheetInstance(unitId);
  }
  return univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
}
function getWorksheet(workbook, subUnitId) {
  if (subUnitId) {
    return workbook.getSheetBySheetId(subUnitId);
  }
  return workbook.getActiveSheet();
}

// ../packages/sheets/src/controllers/number-cell.controller.ts
var NumberCellDisplayController = class extends Disposable {
  constructor(_sheetInterceptorService) {
    super();
    this._sheetInterceptorService = _sheetInterceptorService;
    this._initialize();
  }
  _initialize() {
    this._initInterceptorCellContent();
  }
  _initInterceptorCellContent() {
    this.disposeWithMe(
      this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT, {
        priority: 11,
        effect: 2 /* Value */ | 1 /* Style */,
        handler: (cell, location, next) => {
          var _a2;
          const style = location.workbook.getStyles().getStyleByCell(cell);
          if ((_a2 = style == null ? void 0 : style.n) == null ? void 0 : _a2.pattern) {
            return next({ ...cell });
          }
          if ((cell == null ? void 0 : cell.t) === 2 /* NUMBER */ && cell.v !== void 0 && cell.v !== null && isRealNum(cell.v)) {
            return next({
              ...cell,
              v: stripErrorMargin(Number(cell.v))
            });
          }
          return next({ ...cell });
        }
      })
    );
  }
};
NumberCellDisplayController = __decorateClass([
  __decorateParam(0, Inject(SheetInterceptorService))
], NumberCellDisplayController);

// ../packages/sheets/src/controllers/permission/sheet-permission-check.controller.ts
var import_rxjs37 = __toESM(require_cjs());
var SheetPermissionCheckController = class extends Disposable {
  constructor(_commandService, _univerInstanceService, _permissionService, _selectionManagerService, _rangeProtectionRuleModel, _worksheetProtectionRuleModel, _localeService, _lexerTreeBuilder, _contextService, _definedNamesService) {
    super();
    this._commandService = _commandService;
    this._univerInstanceService = _univerInstanceService;
    this._permissionService = _permissionService;
    this._selectionManagerService = _selectionManagerService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._worksheetProtectionRuleModel = _worksheetProtectionRuleModel;
    this._localeService = _localeService;
    this._lexerTreeBuilder = _lexerTreeBuilder;
    this._contextService = _contextService;
    this._definedNamesService = _definedNamesService;
    __publicField(this, "disposableCollection", new DisposableCollection());
    __publicField(this, "_triggerPermissionUIEvent$", new import_rxjs37.Subject());
    __publicField(this, "triggerPermissionUIEvent$", this._triggerPermissionUIEvent$.asObservable());
    this._initialize();
  }
  blockExecuteWithoutPermission(errorMsg) {
    this._triggerPermissionUIEvent$.next(errorMsg);
    throw new CustomCommandExecutionError("have no permission");
  }
  _getPermissionCheck(id, params) {
    let permission = true;
    let errorMsg = "";
    switch (id) {
      case SetRangeValuesCommand.id:
        if (isICellData(params.value) && params.value.f) {
          permission = this._permissionCheckWithFormula(params);
          errorMsg = this._localeService.t("permission.dialog.formulaErr");
        } else {
          permission = this._permissionCheckBySetRangeValue({
            workbookTypes: [WorkbookEditablePermission],
            rangeTypes: [RangeProtectionPermissionEditPoint],
            worksheetTypes: [WorksheetSetCellValuePermission, WorksheetEditPermission]
          }, params);
        }
        break;
      case ClearSelectionContentCommand.id:
        permission = this.permissionCheckWithRanges({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetSetCellValuePermission, WorksheetEditPermission]
        });
        errorMsg = this._localeService.t("permission.dialog.editErr");
        break;
      case DeltaColumnWidthCommand.id:
      case SetColWidthCommand.id:
        permission = this.permissionCheckWithoutRange({
          worksheetTypes: [WorksheetSetColumnStylePermission]
        });
        errorMsg = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case DeltaRowHeightCommand.id:
      case SetRowHeightCommand.id:
      case SetWorksheetRowIsAutoHeightCommand.id:
        permission = this.permissionCheckWithoutRange({
          worksheetTypes: [WorksheetSetRowStylePermission]
        });
        errorMsg = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case MoveColsCommand.id:
      case MoveRowsCommand.id:
        permission = this._permissionCheckByMoveCommand(params);
        errorMsg = this._localeService.t("permission.dialog.moveRowColErr");
        break;
      case MoveRangeCommand.id:
        permission = this._permissionCheckByMoveRangeCommand(params);
        errorMsg = this._localeService.t("permission.dialog.moveRangeErr");
        break;
      case SetWorksheetOrderCommand.id:
        permission = this._permissionCheckByWorksheetCommand([WorkbookEditablePermission, WorkbookMoveSheetPermission]);
        errorMsg = this._localeService.t("permission.dialog.operatorSheetErr");
        if (permission === false) {
          this._worksheetProtectionRuleModel.resetOrder();
        }
        break;
      case SetWorksheetNameCommand.id:
        permission = this._permissionCheckByWorksheetCommand([WorkbookEditablePermission, WorkbookRenameSheetPermission]);
        errorMsg = this._localeService.t("permission.dialog.operatorSheetErr");
        if (permission === false) {
          this._worksheetProtectionRuleModel.resetOrder();
        }
        break;
      case SetWorksheetShowCommand.id:
        {
          const { unitId, subUnitId } = params;
          permission = this._permissionCheckByWorksheetCommand([WorkbookEditablePermission, WorkbookHideSheetPermission], unitId, subUnitId);
          errorMsg = this._localeService.t("permission.dialog.operatorSheetErr");
          if (permission === false) {
            this._worksheetProtectionRuleModel.resetOrder();
          }
        }
        break;
      case SetSpecificColsVisibleCommand.id:
        permission = this.permissionCheckWithRanges({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetEditPermission, WorksheetSetColumnStylePermission]
        }, params.ranges);
        errorMsg = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case SetSpecificRowsVisibleCommand.id:
        permission = this.permissionCheckWithRanges({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetEditPermission, WorksheetSetRowStylePermission]
        }, params.ranges);
        errorMsg = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case SetSelectedColsVisibleCommand.id:
        permission = this.permissionCheckWithRanges({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetEditPermission, WorksheetSetColumnStylePermission]
        });
        errorMsg = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case SetSelectedRowsVisibleCommand.id:
        permission = this.permissionCheckWithRanges({
          workbookTypes: [WorkbookEditablePermission],
          rangeTypes: [RangeProtectionPermissionEditPoint],
          worksheetTypes: [WorksheetEditPermission, WorksheetSetRowStylePermission]
        });
        errorMsg = this._localeService.t("permission.dialog.setRowColStyleErr");
        break;
      case InsertRangeMoveRightCommand.id:
        permission = this._permissionCheckWithInsertRangeMove("right");
        errorMsg = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
      case InsertRangeMoveDownCommand.id:
        permission = this._permissionCheckWithInsertRangeMove("bottom");
        errorMsg = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
      case DeleteRangeMoveLeftCommand.id:
        permission = this._permissionCheckWithInsertRangeMove("left");
        errorMsg = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
      case DeleteRangeMoveUpCommand.id:
        permission = this._permissionCheckWithInsertRangeMove("top");
        errorMsg = this._localeService.t("permission.dialog.insertOrDeleteMoveRangeErr");
        break;
      default:
        break;
    }
    if (!permission) {
      this.blockExecuteWithoutPermission(errorMsg);
    }
  }
  _initialize() {
    this._commandExecutedListener();
  }
  _commandExecutedListener() {
    this.disposeWithMe(
      this._commandService.beforeCommandExecuted((command) => {
        this._getPermissionCheck(command.id, command == null ? void 0 : command.params);
      })
    );
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command) => {
        var _a2;
        if (command.id === SetWorksheetNameMutation.id) {
          const params = command.params;
          const { unitId = (_a2 = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET)) == null ? void 0 : _a2.getUnitId(), subUnitId } = params;
          if (!unitId || !subUnitId) {
            return;
          }
          const worksheetRule = this._worksheetProtectionRuleModel.getRule(unitId, subUnitId);
          const selectionRuleList = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
          if (worksheetRule) {
            this._worksheetProtectionRuleModel.ruleRefresh(worksheetRule.permissionId);
          }
          if (selectionRuleList.length) {
            this._rangeProtectionRuleModel.ruleRefresh(subUnitId);
          }
        }
      })
    );
  }
  _permissionCheckWithInsertRangeMove(direction) {
    var _a2;
    const target = getSheetCommandTarget(this._univerInstanceService);
    if (!target) {
      return false;
    }
    const { worksheet, unitId, subUnitId } = target;
    const selectionRange = Tools.deepClone((_a2 = this._selectionManagerService.getCurrentLastSelection()) == null ? void 0 : _a2.range);
    if (!selectionRange) {
      return false;
    }
    ;
    if (direction === "top" || direction === "bottom") {
      selectionRange.endRow = worksheet.getRowCount() - 1;
    } else if (direction === "left" || direction === "right") {
      selectionRange.endColumn = worksheet.getColumnCount() - 1;
    }
    const selectionRuleRanges = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).map((rule) => rule.ranges).flat();
    const hasLap = selectionRuleRanges.some((range) => {
      return Rectangle.getIntersects(selectionRange, range);
    });
    if (hasLap) {
      return false;
    }
    return true;
  }
  _permissionCheckByWorksheetCommand(types, targetUnitId, targetSubUnitId) {
    var _a2, _b2;
    const target = getSheetCommandTarget(this._univerInstanceService, { unitId: targetUnitId, subUnitId: targetSubUnitId });
    if (!target) {
      return false;
    }
    const { unitId, subUnitId } = target;
    const worksheetRule = this._worksheetProtectionRuleModel.getRule(unitId, subUnitId);
    const selectionRule = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).length > 0;
    if (worksheetRule || selectionRule) {
      return (_b2 = (_a2 = this._permissionService.getPermissionPoint(new WorkbookManageCollaboratorPermission(unitId).id)) == null ? void 0 : _a2.value) != null ? _b2 : false;
    } else {
      return this._permissionService.composePermission(types.map((F) => new F(unitId).id)).every((permission) => permission.value);
    }
  }
  permissionCheckWithoutRange(permissionTypes) {
    var _a2, _b2, _c, _d;
    const target = getSheetCommandTarget(this._univerInstanceService);
    if (!target) {
      return false;
    }
    const { worksheet, unitId, subUnitId } = target;
    const selection = this._selectionManagerService.getCurrentLastSelection();
    if (!selection) {
      return true;
    }
    const row = (_b2 = (_a2 = selection == null ? void 0 : selection.primary) == null ? void 0 : _a2.actualRow) != null ? _b2 : 0;
    const col = (_d = (_c = selection == null ? void 0 : selection.primary) == null ? void 0 : _c.actualColumn) != null ? _d : 0;
    const { workbookTypes, worksheetTypes, rangeTypes } = permissionTypes;
    if (workbookTypes) {
      const workbookDisable = workbookTypes.some((F) => {
        var _a3, _b3;
        const instance = new F(unitId);
        const permission = (_b3 = (_a3 = this._permissionService.getPermissionPoint(instance.id)) == null ? void 0 : _a3.value) != null ? _b3 : false;
        return permission === false;
      });
      if (workbookDisable === true) {
        return false;
      }
    }
    if (worksheetTypes) {
      const worksheetDisable = worksheetTypes.some((F) => {
        var _a3, _b3;
        const instance = new F(unitId, subUnitId);
        const permission = (_b3 = (_a3 = this._permissionService.getPermissionPoint(instance.id)) == null ? void 0 : _a3.value) != null ? _b3 : false;
        return permission === false;
      });
      if (worksheetDisable === true) {
        return false;
      }
    }
    if (rangeTypes) {
      const rangeDisable = rangeTypes.some((F) => {
        var _a3, _b3, _c2, _d2, _e;
        const cellInfo = (_b3 = (_a3 = worksheet.getCell(row, col)) == null ? void 0 : _a3.selectionProtection) == null ? void 0 : _b3[0];
        if (!(cellInfo == null ? void 0 : cellInfo.ruleId)) {
          return false;
        }
        const permissionId = (_c2 = this._rangeProtectionRuleModel.getRule(unitId, subUnitId, cellInfo.ruleId)) == null ? void 0 : _c2.permissionId;
        if (!permissionId) {
          return false;
        }
        const instance = new F(unitId, subUnitId, permissionId);
        const permission = (_e = (_d2 = this._permissionService.getPermissionPoint(instance.id)) == null ? void 0 : _d2.value) != null ? _e : false;
        return permission === false;
      });
      if (rangeDisable === true) {
        return false;
      }
    }
    return true;
  }
  permissionCheckWithRanges(permissionTypes, selectionRanges, unitId, subUnitId) {
    var _a2;
    const target = getSheetCommandTarget(this._univerInstanceService);
    if (!target) {
      return false;
    }
    const { workbook, worksheet } = target;
    if (!unitId) {
      unitId = workbook.getUnitId();
    }
    if (!subUnitId) {
      subUnitId = worksheet.getSheetId();
    }
    const ranges = selectionRanges != null ? selectionRanges : (_a2 = this._selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((selection) => {
      return selection.range;
    });
    if (!ranges) {
      return false;
    }
    const { workbookTypes, worksheetTypes, rangeTypes } = permissionTypes;
    const permissionIds = [];
    if (workbookTypes) {
      permissionIds.push(...workbookTypes.map((F) => new F(unitId).id));
    }
    if (worksheetTypes) {
      permissionIds.push(...worksheetTypes.map((F) => new F(unitId, subUnitId).id));
    }
    if (rangeTypes) {
      this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).forEach((rule) => {
        const overlap = ranges.some((range) => {
          return rule.ranges.some((r) => {
            return Rectangle.intersects(r, range);
          });
        });
        if (overlap) {
          permissionIds.push(...rangeTypes.map((F) => new F(unitId, subUnitId, rule.permissionId).id));
        }
      });
    }
    if (permissionIds.length) {
      return this._permissionService.composePermission(permissionIds).every((permission) => permission.value);
    }
    return true;
  }
  _permissionCheckByMoveCommand(params) {
    const target = getSheetCommandTarget(this._univerInstanceService);
    if (!target) {
      return false;
    }
    const { worksheet, unitId, subUnitId } = target;
    const toRange = params.toRange;
    if (toRange.endRow === worksheet.getRowCount() - 1) {
      toRange.endColumn = toRange.startColumn;
    } else {
      toRange.endRow = toRange.startRow;
    }
    const permissionLapRanges = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).reduce((p, c) => {
      return [...p, ...c.ranges];
    }, []).filter((range) => {
      return Rectangle.intersects(range, toRange);
    });
    if (permissionLapRanges.length > 0) {
      return false;
    }
    permissionLapRanges.forEach((range) => {
      var _a2, _b2;
      for (let row = range.startRow; row <= range.endRow; row++) {
        for (let col = range.startColumn; col <= range.endColumn; col++) {
          const permission = (_b2 = (_a2 = worksheet.getCell(row, col)) == null ? void 0 : _a2.selectionProtection) == null ? void 0 : _b2[0];
          if ((permission == null ? void 0 : permission[D.Edit]) === false) {
            return false;
          }
        }
      }
    });
    return true;
  }
  _permissionCheckByMoveRangeCommand(params) {
    const target = getSheetCommandTarget(this._univerInstanceService);
    if (!target) {
      return false;
    }
    const { worksheet, unitId, subUnitId } = target;
    const toRange = params.toRange;
    const permissionLapRanges = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).reduce((p, c) => {
      return [...p, ...c.ranges];
    }, []).filter((range) => {
      return Rectangle.intersects(range, toRange);
    });
    if (permissionLapRanges.length > 0) {
      return false;
    }
    permissionLapRanges.forEach((range) => {
      var _a2, _b2;
      for (let row = range.startRow; row <= range.endRow; row++) {
        for (let col = range.startColumn; col <= range.endColumn; col++) {
          const permission = (_b2 = (_a2 = worksheet.getCell(row, col)) == null ? void 0 : _a2.selectionProtection) == null ? void 0 : _b2[0];
          if ((permission == null ? void 0 : permission[D.Edit]) === false) {
            return false;
          }
        }
      }
    });
    return true;
  }
  _permissionCheckBySetRangeValue(permissionTypes, setRangeValueParams) {
    let ranges = [];
    if (setRangeValueParams.range) {
      ranges = [setRangeValueParams.range];
    } else {
      const matrix = new ObjectMatrix(setRangeValueParams.value);
      const range = matrix.getDataRange();
      ranges = [range];
    }
    const { unitId, subUnitId } = setRangeValueParams;
    return this.permissionCheckWithRanges(permissionTypes, ranges, unitId, subUnitId);
  }
  _permissionCheckWithFormula(params) {
    var _a2, _b2, _c, _d, _e;
    const value = params.value;
    const range = params.range;
    const formulaString = value.f;
    if (formulaString) {
      const definedNameStr = formulaString.substring(1);
      const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
      const unitId = (_a2 = params.unitId) != null ? _a2 : workbook.getUnitId();
      const definedName = this._definedNamesService.getValueByName(unitId, definedNameStr);
      if (definedName) {
        let formulaOrRefString = definedName.formulaOrRefString;
        if (formulaOrRefString.startsWith("=" /* EQUALS */)) {
          formulaOrRefString = formulaOrRefString.slice(1);
        }
        const refRangesArr = formulaOrRefString.split(",");
        for (let i = 0; i < refRangesArr.length; i++) {
          const refRange = refRangesArr[i];
          const sequenceGrid = deserializeRangeWithSheet(refRange);
          if (sequenceGrid.sheetName) {
            const targetSheet = workbook.getSheetBySheetName(sequenceGrid.sheetName);
            if (!targetSheet) {
              return true;
            }
            const { startRow, endRow, startColumn, endColumn } = sequenceGrid.range;
            for (let i2 = startRow; i2 <= endRow; i2++) {
              for (let j = startColumn; j <= endColumn; j++) {
                const permission = (_c = (_b2 = targetSheet.getCell(i2, j)) == null ? void 0 : _b2.selectionProtection) == null ? void 0 : _c[0];
                if ((permission == null ? void 0 : permission[D.View]) === false) {
                  return false;
                }
              }
            }
          }
        }
        return true;
      } else {
        const sequenceNodes = this._lexerTreeBuilder.sequenceNodesBuilder(formulaString);
        if (!sequenceNodes) {
          return true;
        }
        for (let i = 0; i < sequenceNodes.length; i++) {
          const node = sequenceNodes[i];
          if (typeof node === "string" || node.nodeType !== 4 /* REFERENCE */) {
            continue;
          }
          const { token } = node;
          const sequenceGrid = deserializeRangeWithSheetWithCache(token);
          const workbook2 = sequenceGrid.unitId ? this._univerInstanceService.getUnit(sequenceGrid.unitId) : this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
          if (!workbook2) return true;
          let targetSheet = sequenceGrid.sheetName ? workbook2.getSheetBySheetName(sequenceGrid.sheetName) : workbook2.getActiveSheet();
          const unitId2 = workbook2.getUnitId();
          if (sequenceGrid.sheetName) {
            targetSheet = workbook2.getSheetBySheetName(sequenceGrid.sheetName);
            if (!targetSheet) {
              return true;
            }
            const subUnitId = targetSheet == null ? void 0 : targetSheet.getSheetId();
            const viewPermission = this._permissionService.getPermissionPoint(new WorksheetViewPermission(unitId2, subUnitId).id);
            if (!viewPermission) return false;
          }
          if (!targetSheet) {
            return true;
          }
          const { startRow, endRow, startColumn, endColumn } = sequenceGrid.range;
          for (let i2 = startRow; i2 <= endRow; i2++) {
            for (let j = startColumn; j <= endColumn; j++) {
              const permission = (_e = (_d = targetSheet.getCell(i2, j)) == null ? void 0 : _d.selectionProtection) == null ? void 0 : _e[0];
              if ((permission == null ? void 0 : permission[D.View]) === false) {
                return false;
              }
            }
          }
        }
        return true;
      }
    }
    if (range) {
      const target = getSheetCommandTarget(this._univerInstanceService);
      if (!target) {
        return false;
      }
      const unitId = params.unitId || target.unitId;
      const subunitId = params.subUnitId || target.subUnitId;
      const permissionList = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subunitId).filter((rule) => {
        return rule.ranges.some((ruleRange) => {
          return Rectangle.intersects(ruleRange, range);
        });
      });
      const permissionIds = permissionList.map((rule) => new RangeProtectionPermissionEditPoint(unitId, subunitId, rule.permissionId).id);
      const editPermission = this._permissionService.composePermission(permissionIds).every((permission) => permission.value);
      if (!editPermission) {
        return false;
      }
    }
    return true;
  }
};
SheetPermissionCheckController = __decorateClass([
  __decorateParam(0, ICommandService),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, IPermissionService),
  __decorateParam(3, Inject(SheetsSelectionsService)),
  __decorateParam(4, Inject(RangeProtectionRuleModel)),
  __decorateParam(5, Inject(WorksheetProtectionRuleModel)),
  __decorateParam(6, Inject(LocaleService)),
  __decorateParam(7, Inject(LexerTreeBuilder)),
  __decorateParam(8, IContextService),
  __decorateParam(9, IDefinedNamesService)
], SheetPermissionCheckController);

// ../packages/sheets/src/controllers/permission/sheet-permission-init.controller.ts
var import_rxjs39 = __toESM(require_cjs());

// ../packages/sheets/src/model/range-protection.cache.ts
var import_rxjs38 = __toESM(require_cjs());
var RangeProtectionCache = class extends Disposable {
  constructor(_ruleModel, _permissionService, _univerInstanceService) {
    super();
    this._ruleModel = _ruleModel;
    this._permissionService = _permissionService;
    this._univerInstanceService = _univerInstanceService;
    __publicField(this, "_cellRuleCache", /* @__PURE__ */ new Map());
    __publicField(this, "_permissionIdCache", /* @__PURE__ */ new Map());
    __publicField(this, "_cellInfoCache", /* @__PURE__ */ new Map());
    //  {unitId:{subUnitId:{[row/col]:{permissionId1:{edit:true},permissionId2:{edit:true},permissionId3:{edit:false}}}}}
    __publicField(this, "_rowInfoCache", /* @__PURE__ */ new Map());
    __publicField(this, "_colInfoCache", /* @__PURE__ */ new Map());
    this._initUpdateCellRuleCache();
    this._initUpdateCellInfoCache();
    this._initUpdateRowColInfoCache();
    this._initCache();
  }
  _initCache() {
    this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).forEach((workbook) => {
      workbook.getSheets().forEach((sheet) => {
        const unitId = workbook.getUnitId();
        const subUnitId = sheet.getSheetId();
        this.reBuildCache(unitId, subUnitId);
      });
    });
  }
  _initUpdateCellInfoCache() {
    this._permissionService.permissionPointUpdate$.pipe(
      (0, import_rxjs38.filter)((permission) => permission.type === a.SelectRange),
      (0, import_rxjs38.map)((permission) => permission)
    ).subscribe((permission) => {
      const { subUnitId, unitId, permissionId } = permission;
      const ruleId = this._permissionIdCache.get(permissionId);
      if (!ruleId) {
        return;
      }
      const ruleInstance = this._ruleModel.getRule(unitId, subUnitId, ruleId);
      if (!ruleInstance) {
        return;
      }
      const cellInfoMap = this._ensureCellInfoMap(unitId, subUnitId);
      ruleInstance.ranges.forEach((range) => {
        const { startRow, endRow, startColumn, endColumn } = range;
        for (let i = startRow; i <= endRow; i++) {
          for (let j = startColumn; j <= endColumn; j++) {
            cellInfoMap.delete(`${i}-${j}`);
          }
        }
      });
    });
    this._ruleModel.ruleChange$.subscribe((info) => {
      var _a2;
      const { unitId, subUnitId } = info;
      const cellInfoMap = this._ensureCellInfoMap(unitId, subUnitId);
      info.rule.ranges.forEach((range) => {
        Range.foreach(range, (row, col) => {
          cellInfoMap.delete(`${row}-${col}`);
        });
      });
      if (info.type === "set") {
        (_a2 = info.oldRule) == null ? void 0 : _a2.ranges.forEach((range) => {
          Range.foreach(range, (row, col) => {
            this._cellInfoCache.delete(`${row}-${col}`);
          });
        });
      }
    });
  }
  _initUpdateCellRuleCache() {
    this._ruleModel.ruleChange$.subscribe((ruleChange) => {
      const { type: type2 } = ruleChange;
      if (type2 === "add") {
        this._addCellRuleCache(ruleChange);
      } else if (type2 === "delete") {
        this._deleteCellRuleCache(ruleChange);
      } else {
        this._deleteCellRuleCache({ ...ruleChange, rule: ruleChange.oldRule });
        this._addCellRuleCache(ruleChange);
      }
    });
  }
  _ensureRuleMap(unitId, subUnitId) {
    let subUnitMap = this._cellRuleCache.get(unitId);
    if (!subUnitMap) {
      subUnitMap = /* @__PURE__ */ new Map();
      this._cellRuleCache.set(unitId, subUnitMap);
    }
    let cellMap = subUnitMap.get(subUnitId);
    if (!cellMap) {
      cellMap = /* @__PURE__ */ new Map();
      subUnitMap.set(subUnitId, cellMap);
    }
    return cellMap;
  }
  _ensureCellInfoMap(unitId, subUnitId) {
    let subUnitMap = this._cellInfoCache.get(unitId);
    if (!subUnitMap) {
      subUnitMap = /* @__PURE__ */ new Map();
      this._cellInfoCache.set(unitId, subUnitMap);
    }
    let cellMap = subUnitMap.get(subUnitId);
    if (!cellMap) {
      cellMap = /* @__PURE__ */ new Map();
      subUnitMap.set(subUnitId, cellMap);
    }
    return cellMap;
  }
  _ensureRowColInfoMap(unitId, subUnitId, type2) {
    let subUnitMap = type2 === "row" ? this._rowInfoCache.get(unitId) : this._colInfoCache.get(unitId);
    if (!subUnitMap) {
      subUnitMap = /* @__PURE__ */ new Map();
      type2 === "row" ? this._rowInfoCache.set(unitId, subUnitMap) : this._colInfoCache.set(unitId, subUnitMap);
    }
    let cellMap = subUnitMap.get(subUnitId);
    if (!cellMap) {
      cellMap = /* @__PURE__ */ new Map();
      subUnitMap.set(subUnitId, cellMap);
    }
    return cellMap;
  }
  _addCellRuleCache(ruleChange) {
    const { subUnitId, unitId, rule } = ruleChange;
    const cellMap = this._ensureRuleMap(unitId, subUnitId);
    rule.ranges.forEach((range) => {
      const { startRow, endRow, startColumn, endColumn } = range;
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          cellMap.set(`${i}-${j}`, rule.id);
        }
      }
    });
    this._permissionIdCache.set(rule.permissionId, rule.id);
  }
  _deleteCellRuleCache(ruleChange) {
    const { subUnitId, unitId, rule } = ruleChange;
    const cellMap = this._ensureRuleMap(unitId, subUnitId);
    const cellInfoMap = this._ensureCellInfoMap(unitId, subUnitId);
    rule.ranges.forEach((range) => {
      const { startRow, endRow, startColumn, endColumn } = range;
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          cellMap.delete(`${i}-${j}`);
          cellInfoMap.delete(`${i}-${j}`);
        }
      }
    });
    this._permissionIdCache.delete(rule.permissionId);
  }
  _getSelectionActions(unitId, subUnitId, rule) {
    var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const edit = (_c = (_b2 = this._permissionService.getPermissionPoint((_a2 = new RangeProtectionPermissionEditPoint(unitId, subUnitId, rule.permissionId)) == null ? void 0 : _a2.id)) == null ? void 0 : _b2.value) != null ? _c : true;
    const view = (_f = (_e = this._permissionService.getPermissionPoint((_d = new RangeProtectionPermissionViewPoint(unitId, subUnitId, rule.permissionId)) == null ? void 0 : _d.id)) == null ? void 0 : _e.value) != null ? _f : true;
    const manageProtection = (_i = (_h = this._permissionService.getPermissionPoint((_g = new RangeProtectionPermissionManageCollaPoint(unitId, subUnitId, rule.permissionId)) == null ? void 0 : _g.id)) == null ? void 0 : _h.value) != null ? _i : false;
    const deleteProtection = (_l = (_k = this._permissionService.getPermissionPoint((_j = new RangeProtectionPermissionDeleteProtectionPoint(unitId, subUnitId, rule.permissionId)) == null ? void 0 : _j.id)) == null ? void 0 : _k.value) != null ? _l : false;
    const selectionProtection = {
      [D.Edit]: edit,
      [D.View]: view,
      [D.ManageCollaborator]: manageProtection,
      [D.Delete]: deleteProtection
    };
    return selectionProtection;
  }
  reBuildCache(unitId, subUnitId) {
    const cellRuleMap = this._ensureRuleMap(unitId, subUnitId);
    const cellInfoMap = this._ensureCellInfoMap(unitId, subUnitId);
    cellRuleMap.clear();
    cellInfoMap.clear();
    const rowInfoMap = this._ensureRowColInfoMap(unitId, subUnitId, "row");
    const colInfoMap = this._ensureRowColInfoMap(unitId, subUnitId, "col");
    rowInfoMap.clear();
    colInfoMap.clear();
    this._ruleModel.getSubunitRuleList(unitId, subUnitId).forEach((rule) => {
      const selectionActions = this._getSelectionActions(unitId, subUnitId, rule);
      const selectionProtection = {
        ...selectionActions,
        ruleId: rule.id,
        ranges: rule.ranges
      };
      rule.ranges.forEach((range) => {
        const { startRow, endRow, startColumn, endColumn } = range;
        for (let i = startRow; i <= endRow; i++) {
          const rowInfo = rowInfoMap.get(`${i}`);
          if (!rowInfo) {
            rowInfoMap.set(`${i}`, /* @__PURE__ */ new Map([[rule.id, selectionActions]]));
          } else {
            rowInfo.set(rule.id, selectionActions);
          }
          for (let j = startColumn; j <= endColumn; j++) {
            cellRuleMap.set(`${i}-${j}`, rule.id);
            cellInfoMap.set(`${i}-${j}`, selectionProtection);
            const colInfo = colInfoMap.get(`${j}`);
            if (!colInfo) {
              colInfoMap.set(`${j}`, /* @__PURE__ */ new Map([[rule.id, selectionActions]]));
            } else {
              colInfo.set(rule.id, selectionActions);
            }
          }
        }
      });
      this._permissionIdCache.set(rule.permissionId, rule.id);
    });
  }
  getRowPermissionInfo(unitId, subUnitId, row, types) {
    var _a2;
    const rowInfo = (_a2 = this._rowInfoCache.get(unitId)) == null ? void 0 : _a2.get(subUnitId);
    if (!rowInfo) {
      return true;
    }
    const info = rowInfo.get(`${row}`);
    if (!info) {
      return true;
    }
    return types.every((type2) => {
      for (const actionGroup of info.values()) {
        if (actionGroup[type2] === false) {
          return false;
        }
      }
      return true;
    });
  }
  getColPermissionInfo(unitId, subUnitId, col, types) {
    var _a2;
    const colInfo = (_a2 = this._colInfoCache.get(unitId)) == null ? void 0 : _a2.get(subUnitId);
    if (!colInfo) {
      return true;
    }
    const info = colInfo.get(`${col}`);
    if (!info) {
      return true;
    }
    return types.every((type2) => {
      for (const actionGroup of info.values()) {
        if (actionGroup[type2] === false) {
          return false;
        }
      }
      return true;
    });
  }
  _initUpdateRowColInfoCache() {
    this._permissionService.permissionPointUpdate$.pipe(
      (0, import_rxjs38.filter)((permission) => permission.type === a.SelectRange),
      (0, import_rxjs38.map)((permission) => permission)
    ).subscribe({
      next: (permission) => {
        const { subUnitId, unitId, permissionId } = permission;
        const ruleId = this._permissionIdCache.get(permissionId);
        if (!ruleId) {
          return;
        }
        const ruleInstance = this._ruleModel.getRule(unitId, subUnitId, ruleId);
        if (!ruleInstance) {
          return;
        }
        const rowInfoMap = this._ensureRowColInfoMap(unitId, subUnitId, "row");
        const colInfoMap = this._ensureRowColInfoMap(unitId, subUnitId, "col");
        const selectionActions = this._getSelectionActions(unitId, subUnitId, ruleInstance);
        ruleInstance.ranges.forEach((range) => {
          const { startRow, endRow, startColumn, endColumn } = range;
          for (let i = startRow; i <= endRow; i++) {
            const rowInfo = rowInfoMap.get(`${i}`);
            if (!rowInfo) {
              rowInfoMap.set(`${i}`, /* @__PURE__ */ new Map([[ruleId, selectionActions]]));
            } else {
              rowInfo.set(ruleId, selectionActions);
            }
            for (let j = startColumn; j <= endColumn; j++) {
              const colInfo = colInfoMap.get(`${j}`);
              if (!colInfo) {
                colInfoMap.set(`${j}`, /* @__PURE__ */ new Map([[ruleId, selectionActions]]));
              } else {
                colInfo.set(ruleId, selectionActions);
              }
            }
          }
        });
      }
    });
    this._ruleModel.ruleChange$.subscribe((info) => {
      if (info.type === "delete") {
        const { unitId, subUnitId, rule } = info;
        const rowInfoMap = this._ensureRowColInfoMap(unitId, subUnitId, "row");
        const colInfoMap = this._ensureRowColInfoMap(unitId, subUnitId, "col");
        rule.ranges.forEach((range) => {
          const { startRow, endRow, startColumn, endColumn } = range;
          for (let i = startRow; i <= endRow; i++) {
            const rowInfo = rowInfoMap.get(`${i}`);
            rowInfo == null ? void 0 : rowInfo.delete(rule.id);
            for (let j = startColumn; j <= endColumn; j++) {
              const colInfo = colInfoMap.get(`${j}`);
              colInfo == null ? void 0 : colInfo.delete(rule.id);
            }
          }
        });
      }
    });
  }
  getCellInfo(unitId, subUnitId, row, col) {
    var _a2, _b2;
    const cellMap = this._ensureCellInfoMap(unitId, subUnitId);
    const cacheValue = cellMap.get(`${row}-${col}`);
    if (cacheValue) {
      return cacheValue;
    }
    const ruleId = (_b2 = (_a2 = this._cellRuleCache.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.get(`${row}-${col}`);
    if (!ruleId) {
      return;
    }
    const rule = this._ruleModel.getRule(unitId, subUnitId, ruleId);
    if (rule) {
      const selectionActions = this._getSelectionActions(unitId, subUnitId, rule);
      const selectionProtection = {
        ...selectionActions,
        ruleId,
        ranges: rule.ranges
      };
      cellMap.set(`${row}-${col}`, selectionProtection);
      return selectionProtection;
    }
  }
  deleteUnit(unitId) {
    this._cellRuleCache.delete(unitId);
    this._cellInfoCache.delete(unitId);
    this._rowInfoCache.delete(unitId);
    this._colInfoCache.delete(unitId);
    const workbook = this._univerInstanceService.getUnit(unitId);
    workbook == null ? void 0 : workbook.getSheets().forEach((sheet) => {
      const subUnitId = sheet.getSheetId();
      this._ruleModel.getSubunitRuleList(unitId, subUnitId).forEach((rule) => {
        this._permissionIdCache.delete(rule.permissionId);
      });
    });
  }
};
RangeProtectionCache = __decorateClass([
  __decorateParam(0, Inject(RangeProtectionRuleModel)),
  __decorateParam(1, Inject(IPermissionService)),
  __decorateParam(2, Inject(IUniverInstanceService))
], RangeProtectionCache);

// ../packages/sheets/src/controllers/permission/sheet-permission-init.controller.ts
var SheetPermissionInitController = class extends Disposable {
  constructor(_univerInstanceService, _permissionService, _authzIoService, _rangeProtectionRuleModel, _worksheetProtectionRuleModel, _userManagerService, _worksheetProtectionPointRuleModel, _sheetInterceptorService, _undoRedoService, _commandService, _rangeProtectionCache) {
    super();
    this._univerInstanceService = _univerInstanceService;
    this._permissionService = _permissionService;
    this._authzIoService = _authzIoService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._worksheetProtectionRuleModel = _worksheetProtectionRuleModel;
    this._userManagerService = _userManagerService;
    this._worksheetProtectionPointRuleModel = _worksheetProtectionPointRuleModel;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._undoRedoService = _undoRedoService;
    this._commandService = _commandService;
    this._rangeProtectionCache = _rangeProtectionCache;
  }
  initPermission() {
    this._initRangePermissionFromSnapshot();
    this._initRangePermissionChange();
    this._initWorksheetPermissionFromSnapshot();
    this._initWorksheetPermissionChange();
    this._initWorksheetPermissionPointsChange();
    this._initWorkbookPermissionFromSnapshot();
    this._initUserChange();
    this._refreshPermissionByCollaCreate();
  }
  async _initRangePermissionFromSnapshot() {
    const initRangePermissionFunc = async (workbook) => {
      const allAllowedParams = [];
      const unitId = workbook.getUnitId();
      const allSheets = workbook.getSheets();
      const permissionIdWithRuleInstanceMap = /* @__PURE__ */ new Map();
      allSheets.forEach((sheet) => {
        const subunitId = sheet.getSheetId();
        this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subunitId).forEach((rule) => {
          permissionIdWithRuleInstanceMap.set(rule.permissionId, rule);
          allAllowedParams.push({
            objectID: rule.permissionId,
            unitID: unitId,
            objectType: a.SelectRange,
            actions: baseProtectionActions
          });
        });
      });
      if (!allAllowedParams.length) {
        this._rangeProtectionRuleModel.changeRuleInitState(true);
        return;
      }
      this._authzIoService.batchAllowed(allAllowedParams).then((permissionMap) => {
        permissionMap.forEach((item) => {
          const rule = permissionIdWithRuleInstanceMap.get(item.objectID);
          if (rule) {
            getAllRangePermissionPoint().forEach((F) => {
              const instance = new F(unitId, rule.subUnitId, item.objectID);
              const unitActionName = instance.subType;
              const result = item.actions.find((action) => action.action === unitActionName);
              if ((result == null ? void 0 : result.allowed) !== void 0) {
                this._permissionService.updatePermissionPoint(instance.id, result.allowed);
              }
            });
          }
        });
        this._rangeProtectionRuleModel.changeRuleInitState(true);
      });
    };
    await Promise.all(this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).map((workbook) => initRangePermissionFunc(workbook)));
    this._rangeProtectionRuleModel.changeRuleInitState(true);
  }
  _initRangePermissionChange() {
    this.disposeWithMe(
      this._rangeProtectionRuleModel.ruleChange$.subscribe((info) => {
        if (info.type !== "delete") {
          this._authzIoService.allowed({
            objectID: info.rule.permissionId,
            unitID: info.unitId,
            objectType: a.SelectRange,
            actions: baseProtectionActions
          }).then((actionList) => {
            getAllRangePermissionPoint().forEach((F) => {
              if (info.type === "set") {
                const { rule: rule2, oldRule } = info;
                if (rule2.permissionId === (oldRule == null ? void 0 : oldRule.permissionId)) {
                  return;
                }
              }
              const rule = info.rule;
              const instance = new F(rule.unitId, rule.subUnitId, rule.permissionId);
              const unitActionName = instance.subType;
              const action = actionList.find((item) => item.action === unitActionName);
              if (action) {
                this._permissionService.updatePermissionPoint(instance.id, action.allowed);
              }
            });
            this._rangeProtectionRuleModel.ruleRefresh(info.rule.permissionId);
          });
        } else {
          const ruleList = this._rangeProtectionRuleModel.getSubunitRuleList(info.unitId, info.subUnitId);
          if (ruleList.length === 0) {
            this._worksheetProtectionPointRuleModel.deleteRule(info.unitId, info.subUnitId);
            [...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
              const instance = new F(info.unitId, info.subUnitId);
              this._permissionService.updatePermissionPoint(instance.id, instance.value);
            });
          }
        }
      })
    );
  }
  async initWorkbookPermissionChange(_unitId) {
    var _a2;
    const unitId = _unitId || ((_a2 = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET)) == null ? void 0 : _a2.getUnitId());
    if (!unitId) {
      return;
    }
    this._authzIoService.allowed({
      objectID: unitId,
      objectType: a.Workbook,
      unitID: unitId,
      actions: defaultWorkbookPermissionPoints
    }).then((actionList) => {
      getAllWorkbookPermissionPoint().forEach((F) => {
        const instance = new F(unitId);
        const unitActionName = instance.subType;
        const action = actionList.find((item) => item.action === unitActionName);
        if (action) {
          this._permissionService.updatePermissionPoint(instance.id, action.allowed);
        }
      });
    });
  }
  async _initWorkbookPermissionFromSnapshot() {
    await Promise.all(this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).map((workbook) => this.initWorkbookPermissionChange(workbook.getUnitId())));
  }
  _initWorksheetPermissionChange() {
    this.disposeWithMe(
      this._worksheetProtectionRuleModel.ruleChange$.subscribe((info) => {
        if (info.type !== "delete") {
          this._authzIoService.allowed({
            objectID: info.rule.permissionId,
            unitID: info.unitId,
            objectType: a.Worksheet,
            actions: baseProtectionActions
          }).then((actionList) => {
            getAllWorksheetPermissionPoint().forEach((F) => {
              const instance = new F(info.unitId, info.subUnitId);
              const unitActionName = instance.subType;
              const action = actionList.find((item) => item.action === unitActionName);
              if (action) {
                this._permissionService.updatePermissionPoint(instance.id, action.allowed);
              }
            });
            this._worksheetProtectionRuleModel.ruleRefresh(info.rule.permissionId);
          });
        } else {
          [...getAllWorksheetPermissionPoint(), ...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
            const instance = new F(info.unitId, info.subUnitId);
            this._permissionService.updatePermissionPoint(instance.id, true);
          });
          this._worksheetProtectionPointRuleModel.deleteRule(info.unitId, info.subUnitId);
        }
      })
    );
  }
  _initWorksheetPermissionPointsChange() {
    this.disposeWithMe(
      this._worksheetProtectionPointRuleModel.pointChange$.subscribe((info) => {
        this._authzIoService.allowed({
          objectID: info.permissionId,
          unitID: info.unitId,
          objectType: a.Worksheet,
          actions: defaultWorksheetPermissionPoint
        }).then((actionList) => {
          getAllWorksheetPermissionPointByPointPanel().forEach((F) => {
            const instance = new F(info.unitId, info.subUnitId);
            const unitActionName = instance.subType;
            const action = actionList.find((item) => item.action === unitActionName);
            if (action) {
              this._permissionService.updatePermissionPoint(instance.id, action.allowed);
            }
          });
        });
      })
    );
  }
  async _initWorksheetPermissionFromSnapshot() {
    const initSheetPermissionFunc = async (workbook) => {
      const allAllowedParams = [];
      const unitId = workbook.getUnitId();
      const allSheets = workbook.getSheets();
      const permissionIdWithRuleInstanceMap = /* @__PURE__ */ new Map();
      allSheets.forEach((sheet) => {
        const subUnitId = sheet.getSheetId();
        const rule = this._worksheetProtectionRuleModel.getRule(unitId, subUnitId);
        if (rule) {
          permissionIdWithRuleInstanceMap.set(rule.permissionId, rule);
          allAllowedParams.push({
            objectID: rule.permissionId,
            unitID: unitId,
            objectType: a.Worksheet,
            actions: baseProtectionActions
          });
        }
        const pointRule = this._worksheetProtectionPointRuleModel.getRule(unitId, subUnitId);
        if (pointRule) {
          permissionIdWithRuleInstanceMap.set(pointRule.permissionId, pointRule);
          allAllowedParams.push({
            objectID: pointRule.permissionId,
            unitID: unitId,
            objectType: a.Worksheet,
            actions: defaultWorksheetPermissionPoint
          });
        }
      });
      if (!allAllowedParams.length) {
        this._worksheetProtectionRuleModel.changeRuleInitState(true);
        return;
      }
      this._authzIoService.batchAllowed(allAllowedParams).then((permissionMap) => {
        permissionMap.forEach((item) => {
          const rule = permissionIdWithRuleInstanceMap.get(item.objectID);
          if (rule) {
            [...getAllWorksheetPermissionPoint(), ...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
              const instance = new F(unitId, rule.subUnitId);
              const unitActionName = instance.subType;
              const result = item.actions.find((action) => action.action === unitActionName);
              if ((result == null ? void 0 : result.allowed) !== void 0) {
                this._permissionService.updatePermissionPoint(instance.id, result.allowed);
              }
            });
          }
        });
        this._worksheetProtectionRuleModel.changeRuleInitState(true);
      });
    };
    await Promise.all(this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).map((workbook) => initSheetPermissionFunc(workbook)));
    this._worksheetProtectionRuleModel.changeRuleInitState(true);
  }
  _initUserChange() {
    this.disposeWithMe(
      // When the user changes, the permission points are updated. The first modification needs to be filtered here because it is a Behavior type, but in fact the user information is ready when this controller is initialized.
      this._userManagerService.currentUser$.pipe((0, import_rxjs39.skip)(1)).subscribe(() => {
        const _map = this._permissionService.getAllPermissionPoint();
        this._permissionService.clearPermissionMap();
        this._worksheetProtectionRuleModel.changeRuleInitState(false);
        const workbooks = this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET);
        workbooks.forEach((workbook) => {
          const unitId = workbook.getUnitId();
          getAllWorkbookPermissionPoint().forEach((F) => {
            let instance = new F(unitId);
            if (_map.has(instance.id)) {
              instance = _map.get(instance.id);
            }
            this._permissionService.addPermissionPoint(instance);
          });
          workbook.getSheets().forEach((sheet) => {
            const subUnitId = sheet.getSheetId();
            [...getAllWorksheetPermissionPoint(), ...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
              let instance = new F(unitId, subUnitId);
              if (_map.has(instance.id)) {
                instance = _map.get(instance.id);
              }
              this._permissionService.addPermissionPoint(instance);
            });
            const ruleList = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
            ruleList.forEach((rule) => {
              getAllRangePermissionPoint().forEach((F) => {
                let instance = new F(unitId, subUnitId, rule.permissionId);
                if (_map.has(instance.id)) {
                  instance = _map.get(instance.id);
                }
                this._permissionService.addPermissionPoint(instance);
              });
            });
          });
          this._initWorkbookPermissionFromSnapshot();
          this._initWorksheetPermissionFromSnapshot();
          this._initRangePermissionFromSnapshot();
        });
      })
    );
  }
  refreshPermission(unitId, permissionId) {
    const sheetRuleItem = this._worksheetProtectionRuleModel.getTargetByPermissionId(unitId, permissionId);
    let needClearUndoRedo = false;
    if (sheetRuleItem) {
      const [_, subUnitId] = sheetRuleItem;
      this._authzIoService.allowed({
        objectID: permissionId,
        unitID: unitId,
        objectType: a.Worksheet,
        actions: baseProtectionActions
      }).then((actionList) => {
        let key = "";
        getAllWorksheetPermissionPoint().forEach((F) => {
          var _a2;
          const instance = new F(unitId, subUnitId);
          const unitActionName = instance.subType;
          const action = actionList.find((item) => item.action === unitActionName);
          if (action) {
            const originValue = (_a2 = this._permissionService.getPermissionPoint(instance.id)) == null ? void 0 : _a2.value;
            if (originValue !== action.allowed) {
              needClearUndoRedo = true;
            }
            this._permissionService.updatePermissionPoint(instance.id, action.allowed);
            key += `${action.action}_${action.allowed}`;
          }
        });
        this._worksheetProtectionRuleModel.ruleRefresh(`${permissionId}_${key}`);
        if (needClearUndoRedo) {
          this._undoRedoService.clearUndoRedo(unitId);
        }
      });
    }
    const sheetPointItem = this._worksheetProtectionPointRuleModel.getTargetByPermissionId(unitId, permissionId);
    if (sheetPointItem) {
      const [_, subUnitId] = sheetPointItem;
      this._authzIoService.allowed({
        objectID: permissionId,
        unitID: unitId,
        objectType: a.Worksheet,
        actions: defaultWorksheetPermissionPoint
      }).then((actionList) => {
        getAllWorksheetPermissionPointByPointPanel().forEach((F) => {
          var _a2;
          const instance = new F(unitId, subUnitId);
          const unitActionName = instance.subType;
          const action = actionList.find((item) => item.action === unitActionName);
          if (action) {
            const originValue = (_a2 = this._permissionService.getPermissionPoint(instance.id)) == null ? void 0 : _a2.value;
            if (originValue !== action.allowed) {
              needClearUndoRedo = true;
            }
            this._permissionService.updatePermissionPoint(instance.id, action.allowed);
          }
        });
        if (needClearUndoRedo) {
          this._undoRedoService.clearUndoRedo(unitId);
        }
      });
    }
    const rangeRuleItem = this._rangeProtectionRuleModel.getTargetByPermissionId(unitId, permissionId);
    if (rangeRuleItem) {
      const [_, subUnitId] = rangeRuleItem;
      this._authzIoService.allowed({
        objectID: permissionId,
        unitID: unitId,
        objectType: a.SelectRange,
        actions: baseProtectionActions
      }).then((actionList) => {
        let key = "";
        getAllRangePermissionPoint().forEach((F) => {
          var _a2;
          const instance = new F(unitId, subUnitId, permissionId);
          const unitActionName = instance.subType;
          const action = actionList.find((item) => item.action === unitActionName);
          if (action) {
            const originValue = (_a2 = this._permissionService.getPermissionPoint(instance.id)) == null ? void 0 : _a2.value;
            if (originValue !== action.allowed) {
              needClearUndoRedo = true;
            }
            this._permissionService.updatePermissionPoint(instance.id, action.allowed);
            key += `${action.action}_${action.allowed}`;
          }
        });
        this._rangeProtectionRuleModel.ruleRefresh(`${permissionId}_${key}`);
        if (needClearUndoRedo) {
          this._undoRedoService.clearUndoRedo(unitId);
        }
      });
    }
  }
  _refreshPermissionByCollaCreate() {
    this.disposeWithMe(
      this._commandService.onCommandExecuted((command, options) => {
        if (options == null ? void 0 : options.fromCollab) {
          if (command.id === AddRangeProtectionMutation.id || command.id === AddWorksheetProtectionMutation.id || command.id === SetWorksheetPermissionPointsMutation.id) {
            const params = command.params;
            this._undoRedoService.clearUndoRedo(params.unitId);
          }
        }
      })
    );
  }
};
SheetPermissionInitController = __decorateClass([
  __decorateParam(0, IUniverInstanceService),
  __decorateParam(1, IPermissionService),
  __decorateParam(2, IAuthzIoService),
  __decorateParam(3, Inject(RangeProtectionRuleModel)),
  __decorateParam(4, Inject(WorksheetProtectionRuleModel)),
  __decorateParam(5, Inject(UserManagerService)),
  __decorateParam(6, Inject(WorksheetProtectionPointModel)),
  __decorateParam(7, Inject(SheetInterceptorService)),
  __decorateParam(8, Inject(IUndoRedoService)),
  __decorateParam(9, Inject(ICommandService)),
  __decorateParam(10, Inject(RangeProtectionCache))
], SheetPermissionInitController);

// ../packages/sheets/src/controllers/permission/sheet-permission-view-model.controller.ts
var SheetPermissionViewModelController = class extends Disposable {
  constructor(_permissionService, _worksheetProtectionRuleModel, _sheetInterceptorService, _rangeProtectionCache) {
    super();
    this._permissionService = _permissionService;
    this._worksheetProtectionRuleModel = _worksheetProtectionRuleModel;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._rangeProtectionCache = _rangeProtectionCache;
    this._initViewModelByRangeInterceptor();
    this._initViewModelBySheetInterceptor();
  }
  _initViewModelByRangeInterceptor() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT, {
      // permissions are placed at a high level to prioritize whether to filter subsequent renderings.
      priority: 999,
      effect: 2 /* Value */ | 1 /* Style */,
      handler: (cell = {}, context, next) => {
        const { unitId, subUnitId, row, col } = context;
        const selectionProtection = this._rangeProtectionCache.getCellInfo(unitId, subUnitId, row, col);
        if (selectionProtection) {
          const isSkipRender = selectionProtection[D.View] === false;
          const _cellData = { ...cell, selectionProtection: [selectionProtection] };
          if (isSkipRender) {
            delete _cellData.s;
            delete _cellData.v;
            delete _cellData.p;
            return _cellData;
          }
          return next(_cellData);
        }
        return next(cell);
      }
    }));
  }
  _initViewModelBySheetInterceptor() {
    this.disposeWithMe(this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.CELL_CONTENT, {
      // permissions are placed at a high level to prioritize whether to filter subsequent renderings.
      priority: 999,
      effect: 2 /* Value */ | 1 /* Style */,
      handler: (cell = {}, context, next) => {
        var _a2, _b2, _c, _d, _e;
        const { unitId, subUnitId } = context;
        const worksheetRule = this._worksheetProtectionRuleModel.getRule(unitId, subUnitId);
        if (worksheetRule == null ? void 0 : worksheetRule.permissionId) {
          const selectionProtection = [{
            [D.View]: (_b2 = (_a2 = this._permissionService.getPermissionPoint(new WorksheetViewPermission(unitId, subUnitId).id)) == null ? void 0 : _a2.value) != null ? _b2 : false,
            [D.Edit]: (_d = (_c = this._permissionService.getPermissionPoint(new WorksheetEditPermission(unitId, subUnitId).id)) == null ? void 0 : _c.value) != null ? _d : false
          }];
          const isSkipRender = !((_e = selectionProtection[0]) == null ? void 0 : _e[D.View]);
          const _cellData = { ...cell, hasWorksheetRule: true, selectionProtection };
          if (isSkipRender) {
            delete _cellData.s;
            delete _cellData.v;
            delete _cellData.p;
            return _cellData;
          }
          return next(_cellData);
        }
        return next(cell);
      }
    }));
  }
};
SheetPermissionViewModelController = __decorateClass([
  __decorateParam(0, IPermissionService),
  __decorateParam(1, Inject(WorksheetProtectionRuleModel)),
  __decorateParam(2, Inject(SheetInterceptorService)),
  __decorateParam(3, Inject(RangeProtectionCache))
], SheetPermissionViewModelController);

// ../packages/sheets/src/model/range-protection-render.model.ts
var import_operators5 = __toESM(require_operators());
var RangeProtectionRenderModel = class {
  constructor(_selectionProtectionRuleModel, _permissionService) {
    this._selectionProtectionRuleModel = _selectionProtectionRuleModel;
    this._permissionService = _permissionService;
    __publicField(this, "_cache", new LRUMap(1e4));
    this._init();
  }
  _init() {
    this._permissionService.permissionPointUpdate$.pipe(
      (0, import_operators5.filter)((permission) => permission.type === a.SelectRange),
      (0, import_operators5.filter)((permission) => getAllRangePermissionPoint().some((F) => permission instanceof F)),
      (0, import_operators5.map)((permission) => permission)
    ).subscribe((permission) => {
      const ruleMap = this._selectionProtectionRuleModel.getSubunitRuleList(permission.unitId, permission.subUnitId);
      for (const rule of ruleMap) {
        if (rule.permissionId === permission.permissionId) {
          rule.ranges.forEach((range) => {
            Range.foreach(range, (row, col) => {
              const key = this._createKey(permission.unitId, permission.subUnitId, row, col);
              this._cache.delete(key);
            });
          });
        }
      }
    });
    this._selectionProtectionRuleModel.ruleChange$.subscribe((info) => {
      var _a2;
      info.rule.ranges.forEach((range) => {
        Range.foreach(range, (row, col) => {
          const key = this._createKey(info.unitId, info.subUnitId, row, col);
          this._cache.delete(key);
        });
      });
      if (info.type === "set") {
        (_a2 = info.oldRule) == null ? void 0 : _a2.ranges.forEach((range) => {
          Range.foreach(range, (row, col) => {
            const key = this._createKey(info.unitId, info.subUnitId, row, col);
            this._cache.delete(key);
          });
        });
      }
    });
  }
  _createKey(unitId, subUnitId, row, col) {
    return `${unitId}_${subUnitId}_${row}_${col}`;
  }
  getCellInfo(unitId, subUnitId, row, col) {
    const ruleMap = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
    const defaultV = [];
    if (!ruleMap || !ruleMap.length) {
      return defaultV;
    }
    const key = this._createKey(unitId, subUnitId, row, col);
    const cacheValue = this._cache.get(key);
    if (cacheValue) {
      return cacheValue;
    }
    const result = [];
    for (const rule of ruleMap) {
      if (rule.ranges.some((range) => range.startRow <= row && range.endRow >= row && range.startColumn <= col && range.endColumn >= col)) {
        const permissionMap = getAllRangePermissionPoint().reduce((result2, F) => {
          var _a2;
          const instance = new F(unitId, subUnitId, rule.permissionId);
          const permission = this._permissionService.getPermissionPoint(instance.id);
          result2[instance.subType] = (_a2 = permission == null ? void 0 : permission.value) != null ? _a2 : instance.value;
          return result2;
        }, {});
        result.push({ ...permissionMap, ruleId: rule.id, ranges: rule.ranges });
      }
    }
    this._cache.set(key, result);
    return result;
  }
  clear() {
    this._cache.clear();
  }
};
RangeProtectionRenderModel = __decorateClass([
  __decorateParam(0, Inject(RangeProtectionRuleModel)),
  __decorateParam(1, Inject(IPermissionService))
], RangeProtectionRenderModel);

// ../packages/sheets/src/services/exclusive-range/exclusive-range-service.ts
var import_rxjs40 = __toESM(require_cjs());
var IExclusiveRangeService = createIdentifier("univer.exclusive-range-service");
var ExclusiveRangeService = class extends Disposable {
  constructor() {
    super(...arguments);
    /**
     * Exclusive range data structure is as follows: unitId -> sheetId -> feature -> range
     */
    __publicField(this, "_exclusiveRanges", /* @__PURE__ */ new Map());
    __publicField(this, "_exclusiveRangesChange$", new import_rxjs40.Subject());
    __publicField(this, "exclusiveRangesChange$", this._exclusiveRangesChange$.asObservable());
  }
  _ensureUnitMap(unitId) {
    if (!this._exclusiveRanges.has(unitId)) {
      this._exclusiveRanges.set(unitId, /* @__PURE__ */ new Map());
    }
    return this._exclusiveRanges.get(unitId);
  }
  _ensureSubunitMap(unitId, sheetId) {
    const unitMap = this._ensureUnitMap(unitId);
    if (!unitMap.has(sheetId)) {
      unitMap.set(sheetId, /* @__PURE__ */ new Map());
    }
    return unitMap.get(sheetId);
  }
  _ensureFeature(unitId, sheetId, feature) {
    const subunitMap = this._ensureSubunitMap(unitId, sheetId);
    if (!subunitMap.has(feature)) {
      subunitMap.set(feature, []);
    }
    return subunitMap.get(feature);
  }
  addExclusiveRange(unitId, sheetId, feature, ranges) {
    const featureMap = this._ensureFeature(unitId, sheetId, feature);
    featureMap.push(...ranges);
    this._exclusiveRangesChange$.next({ unitId, subUnitId: sheetId, ranges: featureMap.map((item) => item.range) });
  }
  getExclusiveRanges(unitId, sheetId, feature) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._exclusiveRanges.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(feature);
  }
  clearExclusiveRanges(unitId, sheetId, feature) {
    const ranges = this.getExclusiveRanges(unitId, sheetId, feature);
    this._exclusiveRangesChange$.next({ unitId, subUnitId: sheetId, ranges: (ranges == null ? void 0 : ranges.map((item) => item.range)) || [] });
    this._ensureFeature(unitId, sheetId, feature);
    this._exclusiveRanges.get(unitId).get(sheetId).set(feature, []);
  }
  clearExclusiveRangesByGroupId(unitId, sheetId, feature, groupId) {
    const ranges = this.getExclusiveRanges(unitId, sheetId, feature);
    this._exclusiveRangesChange$.next({ unitId, subUnitId: sheetId, ranges: (ranges == null ? void 0 : ranges.map((item) => item.range)) || [] });
    const featureMap = this.getExclusiveRanges(unitId, sheetId, feature);
    if (featureMap) {
      const newFeatureMap = featureMap.filter((item) => item.groupId !== groupId);
      this._exclusiveRanges.get(unitId).get(sheetId).set(feature, newFeatureMap);
    }
  }
  getInterestGroupId(selections) {
    const interestGroupId = [];
    selections.forEach((selection) => {
      var _a2;
      const range = selection.range;
      const { unitId, sheetId } = range;
      if (!unitId || !sheetId) return;
      const featureMap = (_a2 = this._exclusiveRanges.get(unitId)) == null ? void 0 : _a2.get(sheetId);
      if (!featureMap) return;
      for (const feature of featureMap.keys()) {
        const featureMapRanges = featureMap.get(feature);
        if (featureMapRanges) {
          for (const featureMapRange of featureMapRanges) {
            if (Rectangle.intersects(range, featureMapRange.range)) {
              interestGroupId.push(feature);
              break;
            }
          }
        }
      }
    });
    return interestGroupId;
  }
};

// ../packages/sheets/src/services/numfmt/numfmt.service.ts
var NumfmtService = class extends Disposable {
  constructor(_resourceManagerService, _univerInstanceService, _logService) {
    super();
    this._resourceManagerService = _resourceManagerService;
    this._univerInstanceService = _univerInstanceService;
    this._logService = _logService;
  }
  getValue(unitId, subUnitId, row, col) {
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return;
    }
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return;
    }
    const styles = workbook.getStyles();
    const cell = worksheet.getCellRaw(row, col);
    if (cell == null ? void 0 : cell.s) {
      const style = styles.get(cell.s);
      if (style == null ? void 0 : style.n) {
        return style.n;
      }
    }
    return null;
  }
  deleteValues(unitId, subUnitId, values) {
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return;
    }
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return;
    }
    const styles = workbook.getStyles();
    values.forEach((range) => {
      Range.foreach(range, (row, col) => {
        const cell = worksheet.getCellRaw(row, col);
        if (!cell) {
          return;
        }
        const oldStyleId = cell == null ? void 0 : cell.s;
        const oldStyle = oldStyleId && styles.get(oldStyleId) || {};
        const newStyle = { ...oldStyle };
        delete newStyle.n;
        const newStyleId = styles.setValue(newStyle);
        cell.s = newStyleId;
      });
    });
  }
  setValues(unitId, subUnitId, values) {
    const workbook = this._univerInstanceService.getUniverSheetInstance(unitId);
    if (!workbook) {
      return;
    }
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    if (!worksheet) {
      return;
    }
    const styles = workbook.getStyles();
    const matrix = worksheet.getCellMatrix();
    values.forEach((value) => {
      value.ranges.forEach((range) => {
        Range.foreach(range, (row, col) => {
          const cell = worksheet.getCellRaw(row, col);
          if (!cell) {
            const style = { n: { pattern: value.pattern } };
            const styleId = styles.setValue(style);
            styleId && matrix.setValue(row, col, { s: styleId });
          } else {
            const oldStyle = styles.getStyleByCell(cell) || {};
            const newStyle = { ...oldStyle, n: { pattern: value.pattern } };
            const styleId = styles.setValue(newStyle);
            cell.s = styleId;
          }
        });
      });
    });
  }
};
NumfmtService = __decorateClass([
  __decorateParam(0, IResourceManagerService),
  __decorateParam(1, IUniverInstanceService),
  __decorateParam(2, ILogService)
], NumfmtService);

// ../packages/sheets/src/services/permission/range-permission/range-protection.ref-range.ts
var mutationIdByRowCol2 = [InsertColMutation.id, InsertRowMutation.id, RemoveColMutation.id, RemoveRowMutation.id];
var mutationIdArrByMove2 = [MoveRowsMutation.id, MoveColsMutation.id];
var RangeProtectionRefRangeService = class extends Disposable {
  constructor(_selectionProtectionRuleModel, _univerInstanceService, _commandService, _refRangeService, _selectionProtectionRenderModel, _rangeProtectionCache, _sheetInterceptorService, _rangeProtectionRuleModel) {
    super();
    this._selectionProtectionRuleModel = _selectionProtectionRuleModel;
    this._univerInstanceService = _univerInstanceService;
    this._commandService = _commandService;
    this._refRangeService = _refRangeService;
    this._selectionProtectionRenderModel = _selectionProtectionRenderModel;
    this._rangeProtectionCache = _rangeProtectionCache;
    this._sheetInterceptorService = _sheetInterceptorService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    __publicField(this, "disposableCollection", new DisposableCollection());
    this._onRefRangeChange();
    this._correctPermissionRange();
    this._initReBuildCache();
    this._initRemoveSheet();
  }
  _onRefRangeChange() {
    const registerRefRange = (unitId, subUnitId) => {
      const workbook2 = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
      if (!workbook2) {
        return;
      }
      const workSheet = workbook2 == null ? void 0 : workbook2.getSheetBySheetId(subUnitId);
      if (!workSheet) {
        return;
      }
      this.disposableCollection.dispose();
      const handler = (config2) => {
        return this.refRangeHandle(config2, unitId, subUnitId);
      };
      const permissionRanges = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).reduce((p, c) => {
        return [...p, ...c.ranges];
      }, []);
      permissionRanges.forEach((range) => {
        this.disposableCollection.add(this._refRangeService.registerRefRange(range, handler, unitId, subUnitId));
      });
    };
    this.disposeWithMe(
      this._commandService.onCommandExecuted((commandInfo) => {
        if (commandInfo.id === SetWorksheetActivateCommand.id) {
          const params = commandInfo.params;
          const sheetId = params.subUnitId;
          const unitId = params.unitId;
          if (!sheetId || !unitId) {
            return;
          }
          registerRefRange(unitId, sheetId);
        }
        if (commandInfo.id === SetRangeProtectionMutation.id || commandInfo.id === AddRangeProtectionMutation.id) {
          const params = commandInfo.params;
          const subUnitId = params.subUnitId;
          const unitId = params.unitId;
          if (!subUnitId || !unitId) {
            return;
          }
          registerRefRange(unitId, subUnitId);
        }
      })
    );
    const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (workbook) {
      const sheet = workbook.getActiveSheet();
      if (!sheet) return;
      registerRefRange(workbook.getUnitId(), sheet.getSheetId());
    }
  }
  refRangeHandle(config2, unitId, subUnitId) {
    switch (config2.id) {
      case MoveRowsCommand.id:
        return this._getRefRangeMutationsByMoveRows(config2.params, unitId, subUnitId);
      case MoveColsCommand.id:
        return this._getRefRangeMutationsByMoveCols(config2.params, unitId, subUnitId);
      case InsertRowCommand.id:
        return this._getRefRangeMutationsByInsertRows(config2.params, unitId, subUnitId);
      case InsertColCommand.id:
        return this._getRefRangeMutationsByInsertCols(config2.params, unitId, subUnitId);
      case RemoveColCommand.id:
        return this._getRefRangeMutationsByDeleteCols(config2.params, unitId, subUnitId);
      case RemoveRowCommand.id:
        return this._getRefRangeMutationsByDeleteRows(config2.params, unitId, subUnitId);
      default:
        break;
    }
    return { redos: [], undos: [] };
  }
  _getRefRangeMutationsByDeleteCols(params, unitId, subUnitId) {
    const permissionRangeLapRules = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
      return rule.ranges.some((range) => {
        return Rectangle.intersects(range, params.range);
      });
    });
    const removeRange = params.range;
    if (permissionRangeLapRules.length) {
      const redoMutations = [];
      const undoMutations = [];
      permissionRangeLapRules.forEach((rule) => {
        const cloneRule = Tools.deepClone(rule);
        const rangesByRemove = cloneRule.ranges.reduce((p, c) => {
          if (Rectangle.intersects(c, removeRange)) {
            const cloneRange = Tools.deepClone(c);
            const { startColumn, endColumn } = removeRange;
            if (startColumn <= cloneRange.startColumn && endColumn >= cloneRange.endColumn) {
              return p;
            } else if (startColumn >= cloneRange.startColumn && endColumn <= cloneRange.endColumn) {
              cloneRange.endColumn -= endColumn - startColumn + 1;
            } else if (startColumn < cloneRange.startColumn) {
              cloneRange.startColumn = startColumn;
              cloneRange.endColumn -= endColumn - startColumn + 1;
            } else if (endColumn > cloneRange.endColumn) {
              cloneRange.endColumn = startColumn - 1;
            }
            if (this._checkIsRightRange(cloneRange)) {
              p.push(cloneRange);
            }
          }
          return p;
        }, []);
        cloneRule.ranges = rangesByRemove;
        if (cloneRule.ranges.length) {
          redoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule: cloneRule, ruleId: rule.id } });
          undoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule, ruleId: rule.id } });
        } else {
          redoMutations.push({ id: DeleteRangeProtectionMutation.id, params: { unitId, subUnitId, ruleIds: [rule.id] } });
          undoMutations.push({ id: AddRangeProtectionMutation.id, params: { unitId, subUnitId, name: "", rules: [rule] } });
        }
      });
      return { redos: redoMutations, undos: undoMutations };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByDeleteRows(params, unitId, subUnitId) {
    const permissionRangeLapRules = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
      return rule.ranges.some((range) => {
        return Rectangle.intersects(range, params.range);
      });
    });
    const removeRange = params.range;
    if (permissionRangeLapRules.length) {
      const redoMutations = [];
      const undoMutations = [];
      permissionRangeLapRules.forEach((rule) => {
        const cloneRule = Tools.deepClone(rule);
        const rangesByRemove = cloneRule.ranges.reduce((p, c) => {
          if (Rectangle.intersects(c, removeRange)) {
            const cloneRange = Tools.deepClone(c);
            const { startRow, endRow } = removeRange;
            if (startRow <= cloneRange.startRow && endRow >= cloneRange.endRow) {
              return p;
            } else if (startRow >= cloneRange.startRow && endRow <= cloneRange.endRow) {
              cloneRange.endRow -= endRow - startRow + 1;
            } else if (startRow < cloneRange.startRow) {
              cloneRange.startRow = startRow;
              cloneRange.endRow -= endRow - startRow + 1;
            } else if (endRow > cloneRange.endRow) {
              cloneRange.endRow = startRow - 1;
            }
            if (this._checkIsRightRange(cloneRange)) {
              p.push(cloneRange);
            }
          }
          return p;
        }, []);
        cloneRule.ranges = rangesByRemove;
        redoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule: cloneRule, ruleId: rule.id } });
        undoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule, ruleId: rule.id } });
      });
      return { redos: redoMutations, undos: undoMutations };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByInsertCols(params, unitId, subUnitId) {
    const insertStart = params.range.startColumn;
    const insertLength = params.range.endColumn - params.range.startColumn + 1;
    const permissionRangeLapRules = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
      return rule.ranges.some((range) => {
        return insertStart > range.startColumn && insertStart <= range.endColumn;
      });
    });
    if (permissionRangeLapRules.length) {
      const redoMutations = [];
      const undoMutations = [];
      permissionRangeLapRules.forEach((rule) => {
        const cloneRule = Tools.deepClone(rule);
        let hasLap = false;
        cloneRule.ranges.forEach((range) => {
          if (insertStart > range.startColumn && insertStart <= range.endColumn) {
            range.endColumn += insertLength;
            hasLap = true;
          }
        });
        if (hasLap) {
          redoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule: cloneRule, ruleId: rule.id } });
          undoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule, ruleId: rule.id } });
        }
      });
      return { redos: redoMutations, undos: undoMutations };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByInsertRows(params, unitId, subUnitId) {
    const insertStart = params.range.startRow;
    const insertLength = params.range.endRow - params.range.startRow + 1;
    const permissionRangeLapRules = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
      return rule.ranges.some((range) => {
        return insertStart > range.startRow && insertStart <= range.endRow;
      });
    });
    if (permissionRangeLapRules.length) {
      const redoMutations = [];
      const undoMutations = [];
      permissionRangeLapRules.forEach((rule) => {
        const cloneRule = Tools.deepClone(rule);
        let hasLap = false;
        cloneRule.ranges.forEach((range) => {
          if (insertStart > range.startRow && insertStart <= range.endRow) {
            range.endRow += insertLength;
            hasLap = true;
          }
        });
        if (hasLap) {
          redoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule: cloneRule, ruleId: rule.id } });
          undoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule, ruleId: rule.id } });
        }
      });
      return { redos: redoMutations, undos: undoMutations };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByMoveRows(params, unitId, subUnitId) {
    const toRange = params.toRange;
    const moveToStartRow = toRange.startRow;
    const moveLength = toRange.endRow - toRange.startRow + 1;
    const permissionRangeLapRules = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
      return rule.ranges.some((range) => {
        return moveToStartRow > range.startRow && moveToStartRow <= range.endRow;
      });
    });
    if (permissionRangeLapRules.length) {
      const redoMutations = [];
      const undoMutations = [];
      permissionRangeLapRules.forEach((rule) => {
        const cloneRule = Tools.deepClone(rule);
        const fromRange = params.fromRange;
        const moveFromStartRow = fromRange.startRow;
        let hasLap = false;
        cloneRule.ranges.forEach((range) => {
          if (moveToStartRow > range.startRow && moveToStartRow <= range.endRow) {
            if (moveFromStartRow < range.startRow) {
              range.startRow = range.startRow - moveLength;
              range.endRow = range.endRow - moveLength;
            }
            range.endRow += moveLength;
            hasLap = true;
          }
        });
        if (hasLap) {
          redoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule: cloneRule, ruleId: rule.id } });
          undoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule, ruleId: rule.id } });
        }
      });
      return { redos: redoMutations, undos: undoMutations };
    }
    return { undos: [], redos: [] };
  }
  _getRefRangeMutationsByMoveCols(params, unitId, subUnitId) {
    const toRange = params.toRange;
    const moveToStartCol = toRange.startColumn;
    const moveLength = toRange.endColumn - toRange.startColumn + 1;
    const permissionRangeLapRules = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).filter((rule) => {
      return rule.ranges.some((range) => {
        return moveToStartCol > range.startColumn && moveToStartCol <= range.endColumn;
      });
    });
    if (permissionRangeLapRules.length) {
      const redoMutations = [];
      const undoMutations = [];
      permissionRangeLapRules.forEach((rule) => {
        const cloneRule = Tools.deepClone(rule);
        const fromRange = params.fromRange;
        const moveFromStartCol = fromRange.startColumn;
        let hasLap = false;
        cloneRule.ranges.forEach((range) => {
          if (moveToStartCol > range.startColumn && moveToStartCol <= range.endColumn) {
            if (moveFromStartCol < range.startColumn) {
              range.startColumn = range.startColumn - moveLength;
              range.endColumn = range.endColumn - moveLength;
            }
            range.endColumn += moveLength;
            hasLap = true;
          }
        });
        if (hasLap) {
          redoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule: cloneRule, ruleId: rule.id } });
          undoMutations.push({ id: SetRangeProtectionMutation.id, params: { unitId, subUnitId, rule, ruleId: rule.id } });
        }
      });
      return { redos: redoMutations, undos: undoMutations };
    }
    return { undos: [], redos: [] };
  }
  _correctPermissionRange() {
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      if (mutationIdArrByMove2.includes(command.id)) {
        if (!command.params) return;
        const workbook = this._univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
        if (!workbook) return;
        const worksheet = workbook.getSheetBySheetId(command.params.subUnitId);
        if (!worksheet) return;
        const { sourceRange, targetRange } = command.params;
        const isRowMove = sourceRange.startColumn === targetRange.startColumn && sourceRange.endColumn === targetRange.endColumn;
        const moveLength = isRowMove ? sourceRange.endRow - sourceRange.startRow + 1 : sourceRange.endColumn - sourceRange.startColumn + 1;
        const sourceStart = isRowMove ? sourceRange.startRow : sourceRange.startColumn;
        const targetStart = isRowMove ? targetRange.startRow : targetRange.startColumn;
        const permissionListRule = this._selectionProtectionRuleModel.getSubunitRuleList(workbook.getUnitId(), worksheet.getSheetId());
        permissionListRule.forEach((rule) => {
          const ranges = rule.ranges;
          ranges.forEach((range) => {
            let { startRow, endRow, startColumn, endColumn } = range;
            if (!Rectangle.intersects(range, sourceRange)) {
              if (isRowMove) {
                if (sourceStart < startRow && targetStart > endRow) {
                  startRow -= moveLength;
                  endRow -= moveLength;
                } else if (sourceStart > endRow && targetStart <= startRow) {
                  startRow += moveLength;
                  endRow += moveLength;
                }
              } else {
                if (sourceStart < startColumn && targetStart > endColumn) {
                  startColumn -= moveLength;
                  endColumn -= moveLength;
                } else if (sourceStart > endColumn && targetStart <= startColumn) {
                  startColumn += moveLength;
                  endColumn += moveLength;
                }
              }
            }
            if (this._checkIsRightRange({ startRow, endRow, startColumn, endColumn })) {
              range.startColumn = startColumn;
              range.endColumn = endColumn;
              range.startRow = startRow;
              range.endRow = endRow;
            }
          });
        });
        this.disposableCollection.dispose();
        const { unitId, subUnitId } = command.params;
        const handler = (config2) => {
          return this.refRangeHandle(config2, unitId, subUnitId);
        };
        const permissionRanges = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).reduce((p, c) => {
          return [...p, ...c.ranges];
        }, []);
        permissionRanges.forEach((range) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(range, handler, unitId, subUnitId));
        });
        this._selectionProtectionRenderModel.clear();
      }
      if (mutationIdByRowCol2.includes(command.id)) {
        const workbook = this._univerInstanceService.getUniverSheetInstance(command.params.unitId);
        if (!workbook) return;
        const worksheet = workbook.getSheetBySheetId(command.params.subUnitId);
        if (!worksheet) return;
        const params = command.params;
        if (!params) return;
        const { range } = params;
        const isRowOperation = command.id.includes("row");
        const isAddOperation = command.id.includes("insert");
        const operationStart = isRowOperation ? range.startRow : range.startColumn;
        const operationEnd = isRowOperation ? range.endRow : range.endColumn;
        const operationCount = operationEnd - operationStart + 1;
        const permissionListRule = this._selectionProtectionRuleModel.getSubunitRuleList(workbook.getUnitId(), worksheet.getSheetId());
        permissionListRule.forEach((rule) => {
          const ranges = rule.ranges;
          ranges.forEach((range2) => {
            let { startRow, endRow, startColumn, endColumn } = range2;
            if (isAddOperation) {
              if (isRowOperation) {
                if (operationStart <= startRow) {
                  startRow += operationCount;
                  endRow += operationCount;
                }
              } else {
                if (operationStart <= startColumn) {
                  startColumn += operationCount;
                  endColumn += operationCount;
                }
              }
            } else {
              if (isRowOperation) {
                if (operationEnd < startRow) {
                  startRow -= operationCount;
                  endRow -= operationCount;
                }
              } else {
                if (operationEnd < startColumn) {
                  startColumn -= operationCount;
                  endColumn -= operationCount;
                }
              }
            }
            if (this._checkIsRightRange({ startRow, endRow, startColumn, endColumn })) {
              range2.startColumn = startColumn;
              range2.endColumn = endColumn;
              range2.startRow = startRow;
              range2.endRow = endRow;
            }
          });
        });
        this.disposableCollection.dispose();
        const { unitId, subUnitId } = command.params;
        const handler = (config2) => {
          return this.refRangeHandle(config2, unitId, subUnitId);
        };
        const permissionRanges = this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).reduce((p, c) => {
          return [...p, ...c.ranges];
        }, []);
        permissionRanges.forEach((range2) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(range2, handler, unitId, subUnitId));
        });
        this._selectionProtectionRenderModel.clear();
      }
    }));
  }
  _checkIsRightRange(range) {
    return range.startRow <= range.endRow && range.startColumn <= range.endColumn;
  }
  _initReBuildCache() {
    this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
      if (mutationIdByRowCol2.includes(command.id) || mutationIdArrByMove2.includes(command.id)) {
        const { unitId, subUnitId } = command.params;
        this._rangeProtectionCache.reBuildCache(unitId, subUnitId);
      }
    }));
  }
  _initRemoveSheet() {
    this._sheetInterceptorService.interceptCommand(
      {
        getMutations: (commandInfo) => {
          const undos = [];
          const redos = [];
          const preRedos = [];
          const preUndos = [];
          if (commandInfo.id === RemoveSheetCommand.id) {
            const params = commandInfo.params;
            const deleteRuleIds = [];
            const addRuleArr = [];
            this._rangeProtectionRuleModel.getSubunitRuleList(params.unitId, params.subUnitId).forEach((rule) => {
              deleteRuleIds.push(rule.id);
              addRuleArr.push(rule);
            });
            if (deleteRuleIds.length && addRuleArr.length) {
              preRedos.push({ id: DeleteRangeProtectionMutation.id, params: { unitId: params.unitId, subUnitId: params.subUnitId, ruleIds: deleteRuleIds } });
              undos.push({ id: AddRangeProtectionMutation.id, params: { unitId: params.unitId, subUnitId: params.subUnitId, name: "", rules: addRuleArr } });
            }
          }
          return {
            redos,
            undos,
            preRedos,
            preUndos
          };
        }
      }
    );
  }
};
RangeProtectionRefRangeService = __decorateClass([
  __decorateParam(0, Inject(RangeProtectionRuleModel)),
  __decorateParam(1, Inject(IUniverInstanceService)),
  __decorateParam(2, ICommandService),
  __decorateParam(3, Inject(RefRangeService)),
  __decorateParam(4, Inject(RangeProtectionRenderModel)),
  __decorateParam(5, Inject(RangeProtectionCache)),
  __decorateParam(6, Inject(SheetInterceptorService)),
  __decorateParam(7, Inject(RangeProtectionRuleModel))
], RangeProtectionRefRangeService);

// ../packages/sheets/src/services/permission/range-permission/range-protection.service.ts
var PLUGIN_NAME2 = "SHEET_RANGE_PROTECTION_PLUGIN";
var RangeProtectionService = class extends Disposable {
  constructor(_selectionProtectionRuleModel, _permissionService, _resourceManagerService, _selectionProtectionCache, _univerInstanceService) {
    super();
    this._selectionProtectionRuleModel = _selectionProtectionRuleModel;
    this._permissionService = _permissionService;
    this._resourceManagerService = _resourceManagerService;
    this._selectionProtectionCache = _selectionProtectionCache;
    this._univerInstanceService = _univerInstanceService;
    this._initSnapshot();
    this._initRuleChange();
  }
  _initRuleChange() {
    this.disposeWithMe(
      this._selectionProtectionRuleModel.ruleChange$.subscribe((info) => {
        switch (info.type) {
          case "add": {
            getAllRangePermissionPoint().forEach((F) => {
              const instance = new F(info.unitId, info.subUnitId, info.rule.permissionId);
              this._permissionService.addPermissionPoint(instance);
            });
            break;
          }
          case "delete": {
            getAllRangePermissionPoint().forEach((F) => {
              const instance = new F(info.unitId, info.subUnitId, info.rule.permissionId);
              this._permissionService.deletePermissionPoint(instance.id);
            });
            break;
          }
          case "set": {
            if (info.oldRule.permissionId !== info.rule.permissionId) {
              getAllRangePermissionPoint().forEach((F) => {
                const oldPermissionPoint = new F(info.unitId, info.subUnitId, info.oldRule.permissionId);
                this._permissionService.deletePermissionPoint(oldPermissionPoint.id);
                const newPermissionPoint = new F(info.unitId, info.subUnitId, info.rule.permissionId);
                this._permissionService.addPermissionPoint(newPermissionPoint);
              });
            }
            break;
          }
        }
      })
    );
  }
  _initSnapshot() {
    const toJson = (unitID) => {
      const object = this._selectionProtectionRuleModel.toObject();
      const v = object[unitID];
      return v ? JSON.stringify(v) : "";
    };
    const parseJson = (json) => {
      if (!json) {
        return {};
      }
      try {
        return JSON.parse(json);
      } catch (err) {
        return {};
      }
    };
    this.disposeWithMe(
      this._resourceManagerService.registerPluginResource({
        toJson,
        parseJson,
        pluginName: PLUGIN_NAME2,
        businesses: [O.UNIVER_SHEET],
        onLoad: (unitId, resources) => {
          const result = this._selectionProtectionRuleModel.toObject();
          result[unitId] = resources;
          this._selectionProtectionRuleModel.fromObject(result);
          const allAllowedParams = [];
          Object.keys(resources).forEach((subUnitId) => {
            const list = resources[subUnitId];
            this._selectionProtectionRuleModel.getSubunitRuleList(unitId, subUnitId).forEach((rule) => {
              allAllowedParams.push({
                objectID: rule.permissionId,
                unitID: unitId,
                objectType: a.SelectRange,
                actions: baseProtectionActions
              });
            });
            list.forEach((rule) => {
              getAllRangePermissionPoint().forEach((Factor) => {
                const instance = new Factor(unitId, subUnitId, rule.permissionId);
                instance.value = false;
                this._permissionService.addPermissionPoint(instance);
              });
            });
            this._selectionProtectionCache.reBuildCache(unitId, subUnitId);
          });
        },
        onUnLoad: (unitId) => {
          this._selectionProtectionCache.deleteUnit(unitId);
        }
      })
    );
  }
};
RangeProtectionService = __decorateClass([
  __decorateParam(0, Inject(RangeProtectionRuleModel)),
  __decorateParam(1, Inject(IPermissionService)),
  __decorateParam(2, Inject(IResourceManagerService)),
  __decorateParam(3, Inject(RangeProtectionCache)),
  __decorateParam(4, Inject(IUniverInstanceService))
], RangeProtectionService);

// ../packages/sheets/src/services/permission/workbook-permission/workbook-permission.service.ts
var WorkbookPermissionService = class extends Disposable {
  constructor(_permissionService, _univerInstanceService, _rangeProtectionRuleModel, _worksheetProtectionRuleModel, _worksheetProtectionPointModel) {
    super();
    this._permissionService = _permissionService;
    this._univerInstanceService = _univerInstanceService;
    this._rangeProtectionRuleModel = _rangeProtectionRuleModel;
    this._worksheetProtectionRuleModel = _worksheetProtectionRuleModel;
    this._worksheetProtectionPointModel = _worksheetProtectionPointModel;
    this._init();
  }
  _init() {
    const handleWorkbook = (workbook) => {
      const unitId = workbook.getUnitId();
      getAllWorkbookPermissionPoint().forEach((F) => {
        const instance = new F(unitId);
        this._permissionService.addPermissionPoint(instance);
      });
    };
    this._univerInstanceService.getAllUnitsForType(O.UNIVER_SHEET).forEach((workbook) => {
      handleWorkbook(workbook);
    });
    this.disposeWithMe(this._univerInstanceService.getTypeOfUnitAdded$(O.UNIVER_SHEET).subscribe((workbook) => {
      handleWorkbook(workbook);
    }));
    this.disposeWithMe(this._univerInstanceService.getTypeOfUnitDisposed$(O.UNIVER_SHEET).subscribe((workbook) => {
      const unitId = workbook.getUnitId();
      workbook.getSheets().forEach((worksheet) => {
        const subUnitId = worksheet.getSheetId();
        const rangeRuleList = this._rangeProtectionRuleModel.getSubunitRuleList(unitId, subUnitId);
        rangeRuleList.forEach((rule) => {
          [...getAllRangePermissionPoint()].forEach((F) => {
            const instance = new F(unitId, subUnitId, rule.permissionId);
            this._permissionService.deletePermissionPoint(instance.id);
          });
        });
        [...getAllWorksheetPermissionPoint(), ...getAllWorksheetPermissionPointByPointPanel()].forEach((F) => {
          const instance = new F(unitId, subUnitId);
          this._permissionService.deletePermissionPoint(instance.id);
        });
      });
      getAllWorkbookPermissionPoint().forEach((F) => {
        const instance = new F(unitId);
        this._permissionService.deletePermissionPoint(instance.id);
      });
      this._rangeProtectionRuleModel.deleteUnitModel(unitId);
      this._worksheetProtectionPointModel.deleteUnitModel(unitId);
      this._worksheetProtectionRuleModel.deleteUnitModel(unitId);
    }));
  }
};
WorkbookPermissionService = __decorateClass([
  __decorateParam(0, Inject(IPermissionService)),
  __decorateParam(1, Inject(IUniverInstanceService)),
  __decorateParam(2, Inject(RangeProtectionRuleModel)),
  __decorateParam(3, Inject(WorksheetProtectionRuleModel)),
  __decorateParam(4, Inject(WorksheetProtectionPointModel))
], WorkbookPermissionService);

// ../packages/sheets/src/services/range-theme-service.ts
var SheetRangeThemeService = class extends Disposable {
  constructor(_sheetRangeThemeModel) {
    super();
    this._sheetRangeThemeModel = _sheetRangeThemeModel;
  }
  /**
   * Register a custom range theme style.
   * @param {string} unitId Which unit to register the range theme style.
   * @param {RangeThemeStyle} rangeThemeStyle The range theme style to register.
   */
  registerRangeTheme(unitId, rangeThemeStyle) {
    this._sheetRangeThemeModel.registerRangeThemeStyle(unitId, rangeThemeStyle);
  }
  removeRangeThemeRule(themeName, rangeInfo) {
    this._sheetRangeThemeModel.removeRangeThemeRule(themeName, rangeInfo);
  }
  /**
   * Get custom register themes name list
   * @returns {string[]} The list of custom register themes name.
   */
  getALLRegisterThemes() {
    return this._sheetRangeThemeModel.getALLRegisteredTheme();
  }
  /**
   * Register range theme style to the range.
   * @param {string} themeName The defined theme name.
   * @param {IRangeThemeRangeInfo} rangeInfo The range info to apply the theme style.
   */
  registerRangeThemeStyle(themeName, rangeInfo) {
    this._sheetRangeThemeModel.registerRangeThemeRule(themeName, rangeInfo);
  }
  /**
   * Get applied range theme style name.
   * @param {IRangeThemeRangeInfo} rangeInfo The range info to get the applied theme style.
   * @returns {string | undefined} The applied theme style name or not exist.
   */
  getAppliedRangeThemeStyle(rangeInfo) {
    return this._sheetRangeThemeModel.getRegisteredRangeThemeStyle(rangeInfo);
  }
  /**
   * Get registered build-in range theme style
   */
  getRegisteredRangeThemes() {
    return this._sheetRangeThemeModel.getRegisteredRangeThemes();
  }
};
SheetRangeThemeService = __decorateClass([
  __decorateParam(0, Inject(SheetRangeThemeModel))
], SheetRangeThemeService);

// ../packages/sheets/src/skeleton/skeleton.service.ts
var SheetSkeletonService = class extends Disposable {
  constructor(_injector) {
    super();
    this._injector = _injector;
    __publicField(this, "_sheetSkeletonStore", /* @__PURE__ */ new Map());
    this.disposeWithMe(() => {
      this._sheetSkeletonStore = /* @__PURE__ */ new Map();
    });
  }
  getSkeleton(unitId, subUnitId) {
    if (!this._sheetSkeletonStore.has(unitId)) {
      return void 0;
    }
    return this._sheetSkeletonStore.get(unitId).get(subUnitId);
  }
  setSkeleton(unitId, subUnitId, skeleton) {
    if (!this._sheetSkeletonStore.has(unitId)) {
      this._sheetSkeletonStore.set(unitId, /* @__PURE__ */ new Map());
    }
    this._sheetSkeletonStore.get(unitId).set(subUnitId, skeleton);
  }
  deleteSkeleton(unitId, subUnitId) {
    if (!this._sheetSkeletonStore.has(unitId)) {
      return;
    }
    this._sheetSkeletonStore.get(unitId).delete(subUnitId);
  }
};
SheetSkeletonService = __decorateClass([
  __decorateParam(0, Inject(Injector))
], SheetSkeletonService);

// ../packages/sheets/src/sheets-plugin.ts
var PLUGIN_NAME3 = "SHEET_PLUGIN";
var UniverSheetsPlugin = class extends Plugin {
  constructor(_config = defaultPluginConfig2, _injector, _configService) {
    super();
    this._config = _config;
    this._injector = _injector;
    this._configService = _configService;
    const { ...rest } = merge_default(
      {},
      defaultPluginConfig2,
      this._config
    );
    this._configService.setConfig(SHEETS_PLUGIN_CONFIG_KEY, rest);
    this._initConfig();
    this._initDependencies();
  }
  _initConfig() {
    var _a2, _b2, _c;
    if ((_a2 = this._config) == null ? void 0 : _a2.onlyRegisterFormulaRelatedMutations) {
      this._configService.setConfig(ONLY_REGISTER_FORMULA_RELATED_MUTATIONS_KEY, true);
    }
    if ((_b2 = this._config) == null ? void 0 : _b2.isRowStylePrecedeColumnStyle) {
      this._configService.setConfig(IS_ROW_STYLE_PRECEDE_COLUMN_STYLE, true);
    }
    if ((_c = this._config) == null ? void 0 : _c.autoHeightForMergedCells) {
      this._configService.setConfig(AUTO_HEIGHT_FOR_MERGED_CELLS, true);
    }
  }
  _initDependencies() {
    var _a2;
    const dependencies = [
      // services
      [BorderStyleManagerService],
      [SheetsSelectionsService],
      [RefRangeService],
      [WorkbookPermissionService],
      [INumfmtService, { useClass: NumfmtService }],
      [SheetInterceptorService],
      [SheetRangeThemeService],
      [SheetSkeletonService],
      // controllers
      [BasicWorksheetController],
      [MergeCellController],
      [NumberCellDisplayController],
      [DefinedNameDataController],
      // permission
      [WorksheetPermissionService],
      [WorksheetProtectionRuleModel],
      [WorksheetProtectionPointModel],
      [SheetPermissionViewModelController],
      [SheetPermissionInitController],
      [SheetPermissionCheckController],
      // range theme
      [SheetRangeThemeModel],
      // range protection
      [RangeProtectionRenderModel],
      [RangeProtectionRuleModel],
      [RangeProtectionCache],
      [RangeProtectionRefRangeService],
      [RangeProtectionService],
      [IExclusiveRangeService, {
        useClass: ExclusiveRangeService,
        deps: [SheetsSelectionsService]
      }]
    ];
    if (!((_a2 = this._config) == null ? void 0 : _a2.notExecuteFormula)) {
      dependencies.push([CalculateResultApplyController]);
    }
    registerDependencies(this._injector, mergeOverrideWithDependencies(dependencies, this._config.override));
    touchDependencies(this._injector, [
      [SheetInterceptorService],
      [RangeProtectionService],
      [IExclusiveRangeService],
      [SheetPermissionInitController]
    ]);
  }
  onStarting() {
    touchDependencies(this._injector, [
      [BasicWorksheetController],
      [MergeCellController],
      [WorkbookPermissionService],
      [WorksheetPermissionService],
      [SheetPermissionViewModelController],
      [SheetSkeletonService]
    ]);
  }
  onRendered() {
    touchDependencies(this._injector, [
      [INumfmtService]
    ]);
  }
  onReady() {
    touchDependencies(this._injector, [
      [CalculateResultApplyController],
      [DefinedNameDataController],
      [SheetRangeThemeModel],
      [NumberCellDisplayController],
      [RangeProtectionRenderModel],
      [RangeProtectionRefRangeService],
      [RefRangeService],
      [SheetPermissionCheckController]
    ]);
  }
};
__publicField(UniverSheetsPlugin, "pluginName", PLUGIN_NAME3);
__publicField(UniverSheetsPlugin, "type", O.UNIVER_SHEET);
UniverSheetsPlugin = __decorateClass([
  DependentOn(UniverFormulaEnginePlugin),
  __decorateParam(1, Inject(Injector)),
  __decorateParam(2, IConfigService)
], UniverSheetsPlugin);

// ../packages/sheets/src/basics/const/command-listener-const.ts
var COMMAND_LISTENER_SKELETON_CHANGE = [
  SetWorksheetRowHeightMutation.id,
  SetWorksheetRowIsAutoHeightMutation.id,
  SetWorksheetRowAutoHeightMutation.id,
  SetWorksheetColWidthMutation.id,
  SetWorksheetActiveOperation.id,
  MoveRowsMutation.id,
  MoveColsMutation.id,
  SetColHiddenMutation.id,
  SetColVisibleMutation.id,
  SetRowHiddenMutation.id,
  SetRowVisibleMutation.id,
  InsertColMutation.id,
  InsertRowMutation.id,
  RemoveColMutation.id,
  RemoveRowMutation.id,
  ToggleGridlinesMutation.id,
  SetGridlinesColorMutation.id
];
var COMMAND_LISTENER_VALUE_CHANGE = [
  SetRangeValuesMutation.id,
  MoveRangeMutation.id,
  RemoveWorksheetMergeMutation.id,
  AddWorksheetMergeMutation.id,
  ReorderRangeMutation.id,
  SetWorksheetDefaultStyleMutation.id,
  SetRowDataMutation.id,
  SetColDataMutation.id,
  SetWorksheetRangeThemeStyleMutation.id,
  DeleteWorksheetRangeThemeStyleMutation.id
];

// ../packages/sheets/src/commands/commands/add-worksheet-merge.command.ts
function checkCellContentInRanges(worksheet, ranges) {
  return ranges.some((range) => checkCellContentInRange(worksheet, range));
}
function checkCellContentInRange(worksheet, range) {
  const { startRow, startColumn, endColumn, endRow } = range;
  const cellMatrix = worksheet.getMatrixWithMergedCells(startRow, startColumn, endRow, endColumn);
  let someCellGoingToBeRemoved = false;
  cellMatrix.forValue((row, col, cellData) => {
    if (cellData && (row !== startRow || col !== startColumn) && worksheet.cellHasValue(cellData)) {
      someCellGoingToBeRemoved = true;
      return false;
    }
  });
  return someCellGoingToBeRemoved;
}
function getClearContentMutationParamsForRanges(accessor, unitId, worksheet, ranges) {
  const undos = [];
  const redos = [];
  const subUnitId = worksheet.getSheetId();
  ranges.forEach((range) => {
    const redoMatrix = getClearContentMutationParamForRange(worksheet, range);
    const redoMutationParams = {
      unitId,
      subUnitId,
      cellValue: redoMatrix.getData()
    };
    const undoMutationParams = SetRangeValuesUndoMutationFactory(
      accessor,
      redoMutationParams
    );
    undos.push({ id: SetRangeValuesMutation.id, params: undoMutationParams });
    redos.push({ id: SetRangeValuesMutation.id, params: redoMutationParams });
  });
  return {
    undos,
    redos
  };
}
function getClearContentMutationParamForRange(worksheet, range) {
  const { startRow, startColumn, endColumn, endRow } = range;
  const cellMatrix = worksheet.getMatrixWithMergedCells(startRow, startColumn, endRow, endColumn, "intercepted" /* Intercepted */);
  const redoMatrix = new ObjectMatrix();
  cellMatrix.forValue((row, col, cellData) => {
    if (cellData && (row !== startRow || col !== startColumn)) {
      redoMatrix.setValue(row, col, null);
    }
  });
  return redoMatrix;
}
var AddWorksheetMergeCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge",
  handler: (accessor, params) => {
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const unitId = params.unitId;
    const subUnitId = params.subUnitId;
    const selections = params.selections;
    const ranges = getAddMergeMutationRangeByType(selections, params.value);
    const worksheet = univerInstanceService.getUniverSheetInstance(unitId).getSheetBySheetId(subUnitId);
    const redoMutations = [];
    const undoMutations = [];
    const willRemoveSomeCell = checkCellContentInRanges(worksheet, ranges);
    const removeMergeMutationParams = {
      unitId,
      subUnitId,
      ranges
    };
    const addMergeMutationParams = {
      unitId,
      subUnitId,
      ranges
    };
    redoMutations.push({ id: RemoveWorksheetMergeMutation.id, params: removeMergeMutationParams });
    redoMutations.push({ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams });
    const undoRemoveMergeMutationParams = RemoveMergeUndoMutationFactory(accessor, removeMergeMutationParams);
    const undoMutationParams = AddMergeUndoMutationFactory(accessor, addMergeMutationParams);
    undoMutations.push({ id: RemoveWorksheetMergeMutation.id, params: undoMutationParams });
    undoMutations.push({ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams });
    if (willRemoveSomeCell) {
      const data = getClearContentMutationParamsForRanges(accessor, unitId, worksheet, ranges);
      redoMutations.unshift(...data.redos);
      undoMutations.push(...data.undos);
    }
    const result = sequenceExecute(redoMutations, commandService);
    if (result.result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations,
        redoMutations
      });
      return true;
    }
    return false;
  }
};
var AddWorksheetMergeAllCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge-all",
  handler: async (accessor) => {
    var _a2;
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    if (!(selections == null ? void 0 : selections.length)) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const workSheet = workbook.getActiveSheet();
    if (!workSheet) return false;
    const unitId = workbook.getUnitId();
    const subUnitId = workSheet.getSheetId();
    return commandService.executeCommand(AddWorksheetMergeCommand.id, {
      selections,
      unitId,
      subUnitId
    });
  }
};
var AddWorksheetMergeVerticalCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge-vertical",
  handler: async (accessor) => {
    var _a2;
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    if (!(selections == null ? void 0 : selections.length)) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const workSheet = workbook.getActiveSheet();
    if (!workSheet) return false;
    const unitId = workbook.getUnitId();
    const subUnitId = workSheet.getSheetId();
    return commandService.executeCommand(AddWorksheetMergeCommand.id, {
      value: 0 /* COLUMNS */,
      selections,
      unitId,
      subUnitId
    });
  }
};
var AddWorksheetMergeHorizontalCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.add-worksheet-merge-horizontal",
  handler: async (accessor) => {
    var _a2;
    const commandService = accessor.get(ICommandService);
    const selectionManagerService = accessor.get(SheetsSelectionsService);
    const selections = (_a2 = selectionManagerService.getCurrentSelections()) == null ? void 0 : _a2.map((s) => s.range);
    if (!(selections == null ? void 0 : selections.length)) {
      return false;
    }
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUnitForType(O.UNIVER_SHEET);
    if (!workbook) return false;
    const workSheet = workbook.getActiveSheet();
    if (!workSheet) return false;
    const unitId = workbook.getUnitId();
    const subUnitId = workSheet.getSheetId();
    return commandService.executeCommand(AddWorksheetMergeCommand.id, {
      value: 1 /* ROWS */,
      selections,
      unitId,
      subUnitId
    });
  }
};

// ../packages/sheets/src/commands/mutations/set-worksheet-right-to-left.mutation.ts
var SetWorksheetRightToLeftUndoMutationFactory = (accessor, params) => {
  const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
  const worksheet = workbook.getSheetBySheetId(params.subUnitId);
  const config2 = worksheet.getConfig();
  const oldState = config2.rightToLeft;
  return {
    ...Tools.deepClone(params),
    rightToLeft: oldState
  };
};
var SetWorksheetRightToLeftMutation = {
  id: "sheet.mutation.set-worksheet-right-to-left",
  type: 2 /* MUTATION */,
  handler: (accessor, params) => {
    const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
    if (!workbook) return false;
    const worksheet = workbook.getSheetBySheetId(params.subUnitId);
    if (!worksheet) return false;
    const config2 = worksheet.getConfig();
    config2.rightToLeft = params.rightToLeft;
    return true;
  }
};

// ../packages/sheets/src/commands/commands/set-worksheet-right-to-left.command.ts
var SetWorksheetRightToLeftCommand = {
  type: 0 /* COMMAND */,
  id: "sheet.command.set-worksheet-right-to-left",
  handler: async (accessor, params) => {
    var _a2;
    const commandService = accessor.get(ICommandService);
    const undoRedoService = accessor.get(IUndoRedoService);
    const target = getSheetCommandTarget(accessor.get(IUniverInstanceService), params);
    if (!target) return false;
    const { unitId, subUnitId } = target;
    let rightToLeft = 0 /* FALSE */;
    if (params) {
      rightToLeft = (_a2 = params.rightToLeft) != null ? _a2 : 0 /* FALSE */;
    }
    const setWorksheetRightToLeftMutationParams = {
      rightToLeft,
      unitId,
      subUnitId
    };
    const undoMutationParams = SetWorksheetRightToLeftUndoMutationFactory(
      accessor,
      setWorksheetRightToLeftMutationParams
    );
    const result = commandService.syncExecuteCommand(
      SetWorksheetRightToLeftMutation.id,
      setWorksheetRightToLeftMutationParams
    );
    if (result) {
      undoRedoService.pushUndoRedo({
        unitID: unitId,
        undoMutations: [{ id: SetWorksheetRightToLeftMutation.id, params: undoMutationParams }],
        redoMutations: [
          { id: SetWorksheetRightToLeftMutation.id, params: setWorksheetRightToLeftMutationParams }
        ]
      });
      return true;
    }
    return false;
  }
};

// src/node/sdk/worker.ts
var univer = new Univer({
  locale: "zhCN" /* ZH_CN */
});
univer.registerPlugin(UniverSheetsPlugin, { onlyRegisterFormulaRelatedMutations: true });
univer.registerPlugin(UniverFormulaEnginePlugin);
univer.registerPlugin(UniverRPCNodeWorkerPlugin);
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
